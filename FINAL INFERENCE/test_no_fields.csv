,question,classification,db_id,schema_links,fields,foriegn keys,predicted_sql,gold_sql,reasoning,score
0,Show the transmitters of radios and the cities of the channels they are associated with.,NON-NESTED,tv_shows,"[radio.Transmitter, city_channel.City, city_channel_radio.Radio_ID = radio.Radio_ID, city_channel_radio.City_channel_ID = city_channel.ID]","Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
","SELECT radio.Transmitter, city_channel.City FROM radio JOIN city_channel_radio ON city_channel_radio.Radio_ID = radio.Radio_ID JOIN city_channel ON city_channel_radio.City_channel_ID = city_channel.ID;","SELECT T3.Transmitter ,  T2.City FROM city_channel_radio AS T1 JOIN city_channel AS T2 ON T1.City_channel_ID  =  T2.ID JOIN radio AS T3 ON T1.Radio_ID  =  T3.Radio_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""radio.Transmitter"" and ""city_channel.City."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""radio"" table with the ""city_channel_radio"" table on ""radio.Radio_ID"" and then connect the ""city_channel_radio"" table with the ""city_channel"" table on ""city_channel_radio.City_channel_ID = city_channel.ID"" to link transmitters with their associated cities. 4. Aggregation Structure: No aggregation is required as the query only retrieves the transmitter and city information.",1.0
1,What are the first names of all buyers and what products did they buy? List them in pairs.,NON-NESTED,e_commerce,"[Customers.customer_first_name, Products.product_name, Orders.customer_id = Customers.customer_id, Order_Items.order_id = Orders.order_id, Order_Items.product_id = Products.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.customer_first_name, Products.product_name FROM Customers JOIN Orders ON Orders.customer_id = Customers.customer_id JOIN Order_Items ON Order_Items.order_id = Orders.order_id JOIN Products ON Order_Items.product_id = Products.product_id;","SELECT T1.customer_first_name ,  T4.product_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id JOIN Products AS T4 ON T3.product_id  =  T4.product_id","1. Sequential Structure: Start with the SELECT clause to retrieve the first names of buyers (""Customers.customer_first_name"") and the names of the products they bought (""Products.product_name""). 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Customers,"" ""Orders,"" ""Order_Items,"" and ""Products"" tables. First, join ""Customers"" with ""Orders"" on ""Orders.customer_id = Customers.customer_id,"" then join ""Orders"" with ""Order_Items"" on ""Order_Items.order_id = Orders.order_id,"" and finally join ""Order_Items"" with ""Products"" on ""Order_Items.product_id = Products.product_id."" 4. Aggregation Structure: No aggregation is required, as the query simply lists pairs of buyer first names and product names.",1.0
2,What is the product id and product name for the cheapest Hardware type product?,NESTED,customers_and_orders,"[Products.product_id, Products.product_name, Products.product_price, Products.product_type_code]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT product_id, product_name FROM Products WHERE product_type_code = 'Hardware' AND product_price = (SELECT MIN(product_price) FROM Products WHERE product_type_code = 'Hardware');","SELECT product_id ,  product_name FROM Products WHERE product_type_code  =  ""Hardware"" ORDER BY product_price ASC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the product_id and product_name. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter for products of type 'Hardware' and find the one with the minimum price. 2. Condition Structure: Use the WHERE clause to filter for products where the product_type_code corresponds to 'Hardware'. Use a subquery to find the minimum price among Hardware products. 3. Join Structure: Not required, as all data is available within the Products table. 4. Aggregation Structure: Use the MIN function in a subquery to find the lowest price among Hardware products, and filter the main query based on this value.",1.0
3,What are the dates and ids of the invoices that are related to at least 2 shipments?,NON-NESTED,e_commerce,"[Invoices.invoice_date, Invoices.invoice_number, Shipments.invoice_number, Shipments.shipment_id, Shipment_Items.shipment_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Invoices.invoice_date, Invoices.invoice_number FROM Invoices JOIN Shipments ON Invoices.invoice_number = Shipments.invoice_number JOIN Shipment_Items ON Shipments.shipment_id = Shipment_Items.shipment_id GROUP BY Invoices.invoice_date, Invoices.invoice_number HAVING COUNT(Shipments.shipment_id) >= 2;","SELECT T1.invoice_date ,  T1.invoice_number FROM Invoices AS T1 JOIN Shipments AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number HAVING count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Invoices.invoice_date"" and ""Invoices.invoice_number."" 2. Condition Structure: Use a HAVING clause to filter for invoices that are related to at least 2 shipments. 3. Join Structure: Use JOINs to connect the ""Invoices"" table with the ""Shipments"" table on ""Invoices.invoice_number = Shipments.invoice_number"" and then connect the ""Shipments"" table with the ""Shipment_Items"" table on ""Shipments.shipment_id = Shipment_Items.shipment_id."" 4. Aggregation Structure: Use COUNT on ""Shipments.shipment_id"" to count the number of shipments related to each invoice, then filter with HAVING to select invoices with at least 2 shipments.",0.0
4,What is the price of all products being ordered on average?,NON-NESTED,e_commerce,"[Products.product_price, Order_Items.product_id = Products.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT AVG(Products.product_price) FROM Order_Items JOIN Products ON Order_Items.product_id = Products.product_id;,SELECT avg(T1.product_price) FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id,"1. Sequential Structure: Start with the SELECT clause to calculate the average price of all products being ordered. Use the AVG function on ""Products.product_price."" 2. Condition Structure: No specific filtering condition is required, as we are calculating the average price of all products being ordered. 3. Join Structure: Use a JOIN between the ""Order_Items"" and ""Products"" tables based on the relationship ""Order_Items.product_id = Products.product_id"" to link ordered products with their prices. 4. Aggregation Structure: Use the AVG function to compute the average price of the products being ordered.",1.0
5,What are the names of Hardware product with prices above the average price of Hardware products.,NESTED,customers_and_orders,"[Products.product_name, Products.product_price, Products.product_type_code]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT product_name FROM Products WHERE product_type_code = 'Hardware' AND product_price > (SELECT AVG(product_price) FROM Products WHERE product_type_code = 'Hardware');,"SELECT product_name FROM Products WHERE product_type_code  =  ""Hardware"" AND product_price  >  (SELECT avg(product_price) FROM Products WHERE product_type_code  =  ""Hardware"")","1. Sequential Structure: Start with the SELECT clause to retrieve the product names. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter for Hardware products with prices above the average price of all Hardware products. 2. Condition Structure: Use the WHERE clause to filter for products where the product type is 'Hardware' and the product price is greater than the average price of Hardware products. A subquery is used to calculate the average price of Hardware products. 3. Join Structure: Not required, as all data is in the Products table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average price of Hardware products, which is then used in the filtering condition.",1.0
6,"How many vehicles has a driver driven at most, and what is the driver id of the driver who has driven this many vehicles?",NON-NESTED,vehicle_driver,"[vehicle_driver.Driver_ID, vehicle_driver.Vehicle_ID, vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT vehicle_driver.Driver_ID, COUNT(vehicle_driver.Vehicle_ID) AS vehicle_count FROM vehicle_driver GROUP BY vehicle_driver.Driver_ID ORDER BY vehicle_count DESC LIMIT 1;","SELECT count(*) ,  driver_id FROM vehicle_driver GROUP BY driver_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the maximum number of vehicles driven by a driver and the corresponding driver ID. Use COUNT to count the number of vehicles driven by each driver. 2. Condition Structure: No specific filtering condition is required, as we are interested in all drivers. 3. Join Structure: No JOIN is necessary since all the required data is available in the ""vehicle_driver"" table. 4. Aggregation Structure: Use COUNT to count the number of vehicles driven by each driver, GROUP BY ""vehicle_driver.Driver_ID"" to group the counts by driver, and ORDER BY in descending order to find the maximum count. Use LIMIT 1 to get the driver with the highest count.",1.0
7,Count the number of different drivers who have driven vehicles built in 2012.,NON-NESTED,vehicle_driver,"[driver.Driver_ID,vehicle.Build_Year,vehicle_driver.Driver_ID = driver.Driver_ID,vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,2012]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT COUNT(DISTINCT driver.Driver_ID) FROM vehicle_driver JOIN vehicle ON vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID JOIN driver ON vehicle_driver.Driver_ID = driver.Driver_ID WHERE vehicle.Build_Year = 2012;,SELECT count(DISTINCT T1.driver_id) FROM vehicle_driver AS T1 JOIN vehicle AS T2 ON T1.vehicle_id  =  T2.vehicle_id WHERE T2.build_year  =  2012,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""driver.Driver_ID"" who have driven vehicles built in 2012. 2. Condition Structure: Use a WHERE clause to filter for vehicles with ""vehicle.Build_Year"" equal to 2012. 3. Join Structure: Use JOINs to connect the ""vehicle_driver"" table with the ""vehicle"" table on ""vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID"" and the ""vehicle_driver"" table with the ""driver"" table on ""vehicle_driver.Driver_ID = driver.Driver_ID"" to link drivers with the vehicles they have driven. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique drivers who meet the condition.",1.0
8,List the transmitters of radios in ascending order of erp kw .,EASY,tv_shows,"[radio.Transmitter, radio.ERP_kW]","Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
",SELECT radio.Transmitter FROM radio ORDER BY radio.ERP_kW ASC;,select transmitter from radio order by erp_kw asc,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""radio.Transmitter"". 2. Condition Structure: No specific filtering condition is required as we want all transmitters. 3. Join Structure: No JOIN is required since all necessary data is within the ""radio"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""radio.ERP_kW"" in ascending order to sort the transmitters by their ERP kW values.",1.0
9,What are the vehicle ids and models which have been driven by more than 2 drivers or been driven by the driver named 'Jeff Gordon'?,NESTED,vehicle_driver,"[vehicle.Vehicle_ID, vehicle.Model, vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID, vehicle_driver.Driver_ID = driver.Driver_ID, driver.Name, driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT DISTINCT vehicle.Vehicle_ID, vehicle.Model FROM vehicle JOIN vehicle_driver ON vehicle.Vehicle_ID = vehicle_driver.Vehicle_ID JOIN driver ON vehicle_driver.Driver_ID = driver.Driver_ID WHERE vehicle.Vehicle_ID IN ( SELECT vehicle_driver.Vehicle_ID FROM vehicle_driver GROUP BY vehicle_driver.Vehicle_ID HAVING COUNT(vehicle_driver.Driver_ID) > 2 ) OR driver.Name = 'Jeff Gordon';","SELECT T1.vehicle_id ,  T1.model FROM vehicle AS T1 JOIN vehicle_driver AS T2 ON T1.vehicle_id  =  T2.vehicle_id JOIN driver AS T3 ON T2.driver_id  =  T3.driver_id WHERE T3.name  =  'Jeff Gordon' UNION SELECT T1.vehicle_id ,  T1.model FROM vehicle AS T1 JOIN vehicle_driver AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T2.vehicle_id HAVING count(*)  >  2","1. Sequential Structure: Start with the SELECT clause to retrieve the vehicle IDs and models. Use the FROM clause to specify the vehicle table and JOIN it with the vehicle_driver and driver tables to connect vehicles with their drivers. Apply a WHERE clause to filter vehicles that have been driven by more than 2 drivers or by the driver named 'Jeff Gordon'. 2. Condition Structure: Use the WHERE clause with two conditions: one to filter vehicles driven by more than 2 drivers using a GROUP BY and HAVING clause, and another to filter vehicles driven by the driver named 'Jeff Gordon'. Combine these conditions using the OR operator. 3. Join Structure: Use INNER JOINs between the vehicle, vehicle_driver, and driver tables based on their respective keys (Vehicle_ID and Driver_ID) to connect vehicles with their drivers. 4. Aggregation Structure: Use COUNT(*) in the HAVING clause to count the number of drivers for each vehicle and filter those with more than 2 drivers.",1.0
10,What is the average price for products with type Clothes?,EASY,customers_and_orders,"[Products.product_price, Products.product_type_code, Clothes]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT AVG(Products.product_price) AS average_price FROM Products WHERE Products.product_type_code = 'Clothes';,"SELECT avg(product_price) FROM Products WHERE product_type_code  =  ""Clothes""","1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average price of products. 2. Condition Structure: Use a WHERE clause to filter for products with the type ""Clothes"". 3. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table. 4. Aggregation Structure: Use the AVG function to calculate the average price of the filtered products.",1.0
11,What is the average top speed of vehicles?,EASY,vehicle_driver,[vehicle.Top_Speed],"Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT AVG(vehicle.Top_Speed) AS average_top_speed FROM vehicle;,SELECT avg(top_speed) FROM vehicle,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average top speed of vehicles. 2. Aggregation Structure: Use the AVG function to calculate the average of the ""vehicle.Top_Speed"" field. 3. Condition Structure: No specific filtering condition is required as the query aims to calculate the average top speed for all vehicles. 4. Join Structure: No JOIN is required since all necessary data is within the ""vehicle"" table.",1.0
12,Count the number of drivers who have not driven any vehicles.,NESTED,vehicle_driver,"[driver.Driver_ID,vehicle_driver.Driver_ID,driver.Driver_ID != vehicle_driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT COUNT(*) FROM driver WHERE Driver_ID NOT IN (SELECT Driver_ID FROM vehicle_driver);,SELECT count(*) FROM driver WHERE driver_id NOT IN ( SELECT driver_id FROM vehicle_driver ),"1. Sequential Structure: Start with the SELECT clause to count the number of drivers. Use the FROM clause to specify the driver table. Apply a WHERE clause to filter drivers who have not driven any vehicles by ensuring their Driver_ID is not present in the vehicle_driver table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude drivers whose Driver_ID appears in the vehicle_driver table, meaning they have driven vehicles. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Driver_ID entries in the vehicle_driver table. 4. Aggregation Structure: Use COUNT to count the number of drivers who meet the specified condition.",1.0
13,Return the names of drivers who have driven vehicles with power over 5000.,NON-NESTED,vehicle_driver,"[driver.Name, vehicle.Power, vehicle_driver.Driver_ID = driver.Driver_ID, vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID, 5000]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT DISTINCT driver.Name FROM driver JOIN vehicle_driver ON vehicle_driver.Driver_ID = driver.Driver_ID JOIN vehicle ON vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID WHERE vehicle.Power > 5000;,SELECT DISTINCT T1.Name FROM driver AS T1 JOIN vehicle_driver AS T2 ON T1.driver_id  =  T2.driver_id JOIN vehicle AS T3 ON T2.vehicle_id  =  T3.vehicle_id WHERE T3.power  >  5000,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of drivers (""driver.Name""). 2. Condition Structure: Use a WHERE clause to filter for vehicles with power greater than 5000. 3. Join Structure: Use JOINs to connect the ""driver"" table with the ""vehicle_driver"" table on ""Driver_ID"" and the ""vehicle_driver"" table with the ""vehicle"" table on ""Vehicle_ID"" to link drivers with the vehicles they have driven. 4. Aggregation Structure: No aggregation is needed as we are only retrieving driver names.",1.0
14,From which countries are players who make more than 1200000 from?,EASY,soccer_3,"[player.Country, player.Earnings, 1200000]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT player.Country FROM player WHERE player.Earnings > 1200000;,SELECT DISTINCT Country FROM player WHERE Earnings  >  1200000,"1. Sequential Structure: Start with the SELECT clause to specify the field ""player.Country"" as we are interested in the countries of players. 2. Condition Structure: Use a WHERE clause to filter players whose ""player.Earnings"" are greater than 1200000. 3. Join Structure: No JOIN is required since all necessary information is in the ""player"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the countries of players who meet the specified earnings condition.",1.0
15,Which order have the least sum of the product prices. List the order id and sum.,NON-NESTED,e_commerce,"[Order_Items.order_id,Order_Items.product_id,Products.product_price,Order_Items.product_id = Products.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Order_Items.order_id, SUM(Products.product_price) AS total_price FROM Order_Items JOIN Products ON Order_Items.product_id = Products.product_id GROUP BY Order_Items.order_id ORDER BY total_price ASC LIMIT 1;","SELECT T1.order_id ,  sum(T2.product_price) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id GROUP BY T1.order_id ORDER BY sum(T2.product_price) ASC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""Order_Items.order_id"" and the sum of ""Products.product_price."" Use an aggregation function (SUM) to calculate the total product prices for each order. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between ""Order_Items"" and ""Products"" tables based on the relationship ""Order_Items.product_id = Products.product_id"" to link each order with its product prices. 4. Aggregation Structure: Use SUM to calculate the total product prices for each order, GROUP BY ""Order_Items.order_id"" to group results by order, and ORDER BY the sum in ascending order. Use LIMIT 1 to select the order with the least sum.",1.0
16,How many products do we have?,EASY,customers_and_orders,[Products.product_id],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(Products.product_id) AS total_products FROM Products;,SELECT count(*) FROM Products,"1. Sequential Structure: Start with the SELECT clause to count the total number of products. 2. Aggregation Structure: Use the COUNT function on ""Products.product_id"" to calculate the total number of products. 3. Condition Structure: No specific filtering condition is required as we want the total count of all products. 4. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table.",1.0
17,Which assessment has the smallest frequency count?,EASY,online_exams,[Student_Assessments.Assessment],"Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Student_Assessments.Assessment FROM Student_Assessments GROUP BY Student_Assessments.Assessment ORDER BY COUNT(*) ASC LIMIT 1;,SELECT Assessment FROM Student_Assessments GROUP BY Assessment ORDER BY COUNT(*) ASC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the assessment name. 2. Aggregation Structure: Use COUNT to calculate the frequency of each assessment. 3. Grouping Structure: Use GROUP BY on ""Student_Assessments.Assessment"" to aggregate the results by each assessment. 4. Ordering Structure: Use ORDER BY in ascending order on the frequency count to rank assessments by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the assessment with the smallest frequency count. 6. Join Structure: No JOIN is required since all necessary data is within the ""Student_Assessments"" table.",1.0
18,What are the names of clubs that have players who have won more than twice?,NON-NESTED,soccer_3,"[club.Name, player.Wins_count, player.Club_ID = club.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT DISTINCT club.Name FROM club JOIN player ON player.Club_ID = club.Club_ID WHERE player.Wins_count > 2;,SELECT T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T2.Wins_count  >  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""club.Name"" field, as we are interested in the names of clubs. 2. Condition Structure: Use a WHERE clause to filter for players who have won more than twice, i.e., ""player.Wins_count > 2."" 3. Join Structure: Use a JOIN between the ""player"" and ""club"" tables based on the relationship ""player.Club_ID = club.Club_ID"" to associate players with their respective clubs. 4. Aggregation Structure: No aggregation is needed since the query focuses on filtering and retrieving club names directly.",1.0
19,"What are the first names, middle initials, last names, and payment methods of all customers?",NON-NESTED,e_commerce,"[Customers.customer_first_name, Customers.customer_middle_initial, Customers.customer_last_name, Customer_Payment_Methods.payment_method_code, Customer_Payment_Methods.customer_id = Customers.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.customer_first_name, Customers.customer_middle_initial, Customers.customer_last_name, Customer_Payment_Methods.payment_method_code FROM Customers JOIN Customer_Payment_Methods ON Customer_Payment_Methods.customer_id = Customers.customer_id;","SELECT T1.customer_first_name ,  T1.customer_middle_initial ,  T1.customer_last_name ,  T2.Payment_method_code FROM Customers AS T1 JOIN Customer_Payment_Methods AS T2 ON T1.customer_id  =  T2.customer_id","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Customers.customer_first_name,"" ""Customers.customer_middle_initial,"" ""Customers.customer_last_name,"" and ""Customer_Payment_Methods.payment_method_code."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to combine the ""Customers"" table with the ""Customer_Payment_Methods"" table based on the relationship ""Customer_Payment_Methods.customer_id = Customers.customer_id."" 4. Aggregation Structure: No aggregation is required as the query simply retrieves the specified fields for all customers.",1.0
20,List all product type codes and the number of products in each type.,EASY,customers_and_orders,"[Products.product_type_code, Products.product_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_type_code, COUNT(Products.product_id) AS product_count FROM Products GROUP BY Products.product_type_code;","SELECT product_type_code ,  count(*) FROM Products GROUP BY product_type_code","1. Sequential Structure: Start with the SELECT clause to specify the product type codes and the count of products in each type. 2. Aggregation Structure: Use COUNT to calculate the number of products for each product type code. 3. Grouping Structure: Use GROUP BY on ""Products.product_type_code"" to group the results by each product type code. 4. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table.",1.0
21,List the name of clubs that do not have players.,NESTED,soccer_3,"[club.Name, player.Club_ID, club.Club_ID = player.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT club.Name FROM club WHERE club.Club_ID NOT IN (SELECT player.Club_ID FROM player);,SELECT Name FROM club WHERE Club_ID NOT IN (SELECT Club_ID FROM player),"1. Sequential Structure: Begin with the SELECT clause to retrieve the name of clubs. Use the FROM clause to specify the club table. Apply a WHERE clause to filter clubs that do not have any players associated with them. 2. Condition Structure: Use the WHERE clause with a subquery to exclude clubs whose Club_ID appears in the player table, meaning they have players. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Club_ID entries in the player table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
22,Please show the least common assessment for students.,EASY,online_exams,[Student_Assessments.Assessment],"Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Student_Assessments.Assessment FROM Student_Assessments GROUP BY Student_Assessments.Assessment ORDER BY COUNT(*) ASC LIMIT 1;,SELECT Assessment FROM Student_Assessments GROUP BY Assessment ORDER BY COUNT(*) ASC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the assessment type. 2. Aggregation Structure: Use COUNT to determine the frequency of each assessment type. 3. Grouping Structure: Use GROUP BY on ""Student_Assessments.Assessment"" to aggregate the results by each assessment type. 4. Ordering Structure: Use ORDER BY in ascending order on the count to rank assessments by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the least common assessment type. 6. Join Structure: No JOIN is required since all necessary data is within the ""Student_Assessments"" table.",1.0
23,Find the id and name of the channel that is not directed by Hank Baskett.,NESTED,bbc_channels,"[channel.Channel_ID, channel.Name, director.Name, director.Director_ID = program.Director_ID, program.Channel_ID = channel.Channel_ID, Hank Baskett]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
","SELECT channel.Channel_ID, channel.Name FROM channel JOIN program ON channel.Channel_ID = program.Channel_ID JOIN director ON program.Director_ID = director.Director_ID WHERE director.Name != 'Hank Baskett';","SELECT t1.name ,  t1.channel_id FROM channel AS t1 JOIN director_admin AS t2 ON t1.channel_id  =  t2.channel_id JOIN director AS t3 ON t2.director_id  =  t3.director_id WHERE t3.name != ""Hank Baskett""","1. Sequential Structure: Start with the SELECT clause to retrieve the Channel_ID and Name of the channel. Use the FROM clause to specify the channel table. Join it with the program table to connect channels with their respective directors, and then join the program table with the director table to access director details. Apply a WHERE clause to filter out channels directed by Hank Baskett. 2. Condition Structure: Use the WHERE clause to exclude channels where the director's name is 'Hank Baskett'. 3. Join Structure: Use INNER JOINs between the channel, program, and director tables. The channel table is joined with the program table on Channel_ID, and the program table is joined with the director table on Director_ID. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
24,Return the models of vehicles that have never been driven.,NESTED,vehicle_driver,"[vehicle.Model,vehicle.Vehicle_ID,vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT vehicle.Model FROM vehicle WHERE vehicle.Vehicle_ID NOT IN (SELECT Vehicle_ID FROM vehicle_driver);,SELECT model FROM vehicle EXCEPT SELECT T1.model FROM vehicle AS T1 JOIN vehicle_driver AS T2 ON T1.vehicle_id  =  T2.vehicle_id,"1. Sequential Structure: Start with the SELECT clause to retrieve the models of vehicles. Use the FROM clause to specify the vehicle table. Apply a WHERE clause to filter vehicles that have never been driven by ensuring their Vehicle_ID is not present in the vehicle_driver table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude vehicles whose Vehicle_ID appears in the vehicle_driver table, indicating they have been driven. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Vehicle_ID entries in the vehicle_driver table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
25,"What are the different names, prices, and descriptions for all products bought by female customers?",NON-NESTED,e_commerce,"[Products.product_name, Products.product_price, Products.product_description, Order_Items.product_id = Products.product_id, Order_Items.order_id = Orders.order_id, Orders.customer_id = Customers.customer_id, Customers.gender_code, female]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Products.product_name, Products.product_price, Products.product_description FROM Products JOIN Order_Items ON Order_Items.product_id = Products.product_id JOIN Orders ON Order_Items.order_id = Orders.order_id JOIN Customers ON Orders.customer_id = Customers.customer_id WHERE Customers.gender_code = 'female';","SELECT DISTINCT T1.product_name ,  T1.product_price ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id JOIN Customers AS T4 ON T3.customer_id  =  T4.customer_id WHERE T4.gender_code  =  'Female'","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Products.product_name,"" ""Products.product_price,"" and ""Products.product_description."" 2. Condition Structure: Use a WHERE clause to filter for records where ""Customers.gender_code"" corresponds to female customers. 3. Join Structure: Use multiple JOINs to connect the relevant tables: - Join ""Order_Items"" with ""Products"" on ""Order_Items.product_id = Products.product_id"" to link products with their order items. - Join ""Order_Items"" with ""Orders"" on ""Order_Items.order_id = Orders.order_id"" to link order items with orders. - Join ""Orders"" with ""Customers"" on ""Orders.customer_id = Customers.customer_id"" to link orders with customers. 4. Aggregation Structure: No aggregation is needed as the query requires detailed information for each product bought by female customers.",0.0
26,List the manufacturers that are associated with more than one club.,EASY,soccer_3,"[club.Manufacturer, club.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT club.Manufacturer FROM club GROUP BY club.Manufacturer HAVING COUNT(DISTINCT club.Club_ID) > 1;,SELECT Manufacturer FROM club GROUP BY Manufacturer HAVING COUNT(*)  >  1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the manufacturer. 2. Aggregation Structure: Use COUNT to determine the number of clubs associated with each manufacturer. 3. Grouping Structure: Use GROUP BY on ""club.Manufacturer"" to aggregate the results by each manufacturer. 4. Condition Structure: Apply the HAVING clause to filter for manufacturers that are associated with more than one club, by setting the count to be greater than 1. 5. Join Structure: No JOIN is required since all necessary data is within the ""club"" table.",1.0
27,How many different payment methods can customers choose from?,EASY,e_commerce,[Customer_Payment_Methods.payment_method_code],"Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT COUNT(DISTINCT Customer_Payment_Methods.payment_method_code) FROM Customer_Payment_Methods;,SELECT count(DISTINCT Payment_method_code) FROM Customer_Payment_Methods,"1. Sequential Structure: Begin with the SELECT clause to count the distinct payment methods available to customers. 2. Condition Structure: No specific filtering condition is required as we are interested in all payment methods. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""Customer_Payment_Methods"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Customer_Payment_Methods.payment_method_code"" to count the unique payment methods.",1.0
28,Find the name and internet web of the channel that is directed by the most directors.,NON-NESTED,bbc_channels,"[channel.Name, channel.Internet, director_admin.Channel_ID = channel.Channel_ID, director_admin.Director_ID = director.Director_ID]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
","SELECT channel.Name, channel.Internet FROM channel JOIN director_admin ON channel.Channel_ID = director_admin.Channel_ID JOIN director ON director_admin.Director_ID = director.Director_ID GROUP BY channel.Channel_ID ORDER BY COUNT(director.Director_ID) DESC LIMIT 1;","SELECT t1.name ,  t1.internet FROM channel AS t1 JOIN director_admin AS t2 ON t1.channel_id  =  t2.channel_id GROUP BY t1.channel_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""channel.Name"" and ""channel.Internet."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the channel with the most directors. 3. Join Structure: Use JOINs to connect ""channel"" with ""director_admin"" on ""channel.Channel_ID"" and ""director_admin"" with ""director"" on ""director_admin.Director_ID"" to associate each channel with its directors. 4. Aggregation Structure: Use COUNT on ""director.Director_ID"" to count the number of directors per channel. Use GROUP BY to group results by ""channel.Channel_ID,"" and ORDER BY in descending order to rank channels by the number of directors. Use LIMIT 1 to select the channel with the most directors.",1.0
29,List all the student answer texts in descending order of count.,EASY,online_exams,"[Student_Answers.Student_Answer_Text, Student_Answers.Student_Answer_Text]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Student_Answers.Student_Answer_Text, COUNT(*) AS answer_count FROM Student_Answers GROUP BY Student_Answers.Student_Answer_Text ORDER BY answer_count DESC;",SELECT Student_Answer_Text FROM Student_Answers GROUP BY Student_Answer_Text ORDER BY COUNT(*) DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the ""Student_Answers.Student_Answer_Text"" and the count of each answer text. 2. Aggregation Structure: Use COUNT to calculate the number of occurrences of each ""Student_Answers.Student_Answer_Text"". 3. Grouping Structure: Use GROUP BY on ""Student_Answers.Student_Answer_Text"" to aggregate the results by each unique answer text. 4. Ordering Structure: Use ORDER BY in descending order on the count to sort the results by the frequency of each answer text. 5. Join Structure: No JOIN is required since all necessary data is within the ""Student_Answers"" table.",1.0
30,How many radios are there?,EASY,tv_shows,[radio.Radio_ID],"Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
",SELECT COUNT(radio.Radio_ID) AS total_radios FROM radio;,SELECT count(*) FROM radio,"1. Sequential Structure: Begin with the SELECT clause to count the number of radios. 2. Aggregation Structure: Use the COUNT function to count the total number of ""radio.Radio_ID"". 3. Condition Structure: No specific filtering condition is required as we want the total count of radios. 4. Join Structure: No JOIN is necessary since all required data is within the ""radio"" table.",1.0
31,Please show the most common affiliation for city channels.,EASY,tv_shows,[city_channel.Affiliation],"Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
",SELECT city_channel.Affiliation FROM city_channel GROUP BY city_channel.Affiliation ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Affiliation FROM city_channel GROUP BY Affiliation ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""Affiliation"" of city channels. 2. Aggregation Structure: Use COUNT to determine the frequency of each affiliation. 3. Grouping Structure: Use GROUP BY on ""city_channel.Affiliation"" to aggregate the results by each affiliation. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank affiliations by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common affiliation. 6. Join Structure: No JOIN is required since all necessary data is within the ""city_channel"" table.",1.0
32,Which director is in charge of the most programs?,NON-NESTED,bbc_channels,"[director.Name, program.Director_ID, program.Program_ID, program.Director_ID = director.Director_ID]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
","SELECT director.Name, COUNT(program.Program_ID) AS program_count FROM program JOIN director ON program.Director_ID = director.Director_ID GROUP BY director.Name ORDER BY program_count DESC LIMIT 1;",SELECT t2.name FROM program AS t1 JOIN director AS t2 ON t1.director_id  =  t2.director_id GROUP BY t1.director_id ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""director.Name"" and the count of programs they are in charge of. Use an aggregate function (COUNT) on ""program.Program_ID"" to count the number of programs for each director. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all directors. 3. Join Structure: Use a JOIN between the ""program"" and ""director"" tables based on the relationship ""program.Director_ID = director.Director_ID"" to associate each program with its respective director. 4. Aggregation Structure: Use GROUP BY on ""director.Name"" to group the results by each director. Use ORDER BY in descending order of the program count to rank directors by the number of programs they are in charge of. Use LIMIT 1 to select the director with the most programs.",1.0
33,"List all the distinct product names, price and descriptions which are bought by female customers.",NON-NESTED,e_commerce,"[Products.product_name, Products.product_price, Products.product_description, Customers.gender_code, Orders.customer_id = Customers.customer_id, Order_Items.order_id = Orders.order_id, Order_Items.product_id = Products.product_id, female]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT DISTINCT Products.product_name, Products.product_price, Products.product_description FROM Products JOIN Order_Items ON Order_Items.product_id = Products.product_id JOIN Orders ON Order_Items.order_id = Orders.order_id JOIN Customers ON Orders.customer_id = Customers.customer_id WHERE Customers.gender_code = 'female';","SELECT DISTINCT T1.product_name ,  T1.product_price ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id JOIN Customers AS T4 ON T3.customer_id  =  T4.customer_id WHERE T4.gender_code  =  'Female'","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Products.product_name,"" ""Products.product_price,"" and ""Products.product_description."" 2. Condition Structure: Use a WHERE clause to filter for records where ""Customers.gender_code"" corresponds to female customers. 3. Join Structure: Use multiple JOINs to connect the relevant tables. First, join ""Orders"" with ""Customers"" on ""Orders.customer_id = Customers.customer_id"" to associate orders with customers. Then, join ""Order_Items"" with ""Orders"" on ""Order_Items.order_id = Orders.order_id"" to link order items with orders. Finally, join ""Products"" with ""Order_Items"" on ""Order_Items.product_id = Products.product_id"" to associate products with order items. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique product details are returned.",0.0
34,What are the names of players and the corresponding clubs that they are in?,NON-NESTED,soccer_3,"[player.Name, club.Name, player.Club_ID = club.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
","SELECT player.Name, club.Name FROM player JOIN club ON player.Club_ID = club.Club_ID;","SELECT T2.Name ,  T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""player.Name"" and ""club.Name."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""player"" and ""club"" tables based on the shared key ""player.Club_ID = club.Club_ID"" to associate players with their respective clubs. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the names of players and their corresponding clubs.",1.0
35,"Return the model and build year of cars that include ""DJ"" in their model names.",EASY,vehicle_driver,"[vehicle.Model, vehicle.Build_Year]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT vehicle.Model, vehicle.Build_Year FROM vehicle WHERE vehicle.Model LIKE '%DJ%';","SELECT model ,  build_year FROM vehicle WHERE model LIKE '%DJ%'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""vehicle.Model"" and ""vehicle.Build_Year"" fields. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for models that include ""DJ"" in their names. 3. Join Structure: No JOIN is required since all necessary information is in the ""vehicle"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific fields based on a condition.",1.0
36,"List the station names of city channels whose affiliation is not ""ABC"".",EASY,tv_shows,"[city_channel.Station_name,city_channel.Affiliation]","Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
",SELECT city_channel.Station_name FROM city_channel WHERE city_channel.Affiliation != 'ABC';,"SELECT Station_name FROM city_channel WHERE Affiliation != ""ABC""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""city_channel.Station_name"" of city channels. 2. Condition Structure: Use a WHERE clause to filter out records where ""city_channel.Affiliation"" is ""ABC"". 3. Join Structure: No JOIN is required since all necessary information is in the ""city_channel"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving station names based on a specific condition.",1.0
37,Give the product type codes of product types that have two or more products.,EASY,customers_and_orders,"[Products.product_type_code, Products.product_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Products.product_type_code FROM Products GROUP BY Products.product_type_code HAVING COUNT(Products.product_id) >= 2;,SELECT product_type_code FROM Products GROUP BY product_type_code HAVING count(*)  >=  2,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the product type code. 2. Aggregation Structure: Use COUNT to determine the number of products associated with each product type code. 3. Grouping Structure: Use GROUP BY on ""Products.product_type_code"" to aggregate the results by each product type code. 4. Condition Structure: Apply the HAVING clause to filter for product type codes that have two or more products, by setting the count to be greater than or equal to 2. 5. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table.",1.0
38,"Which product are listed in orders most frequently? List the id, product name and price.",NON-NESTED,e_commerce,"[Products.product_id, Products.product_name, Products.product_price, Order_Items.product_id, Order_Items.order_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Products.product_id, Products.product_name, Products.product_price FROM Products JOIN Order_Items ON Products.product_id = Order_Items.product_id GROUP BY Products.product_id, Products.product_name, Products.product_price ORDER BY COUNT(Order_Items.product_id) DESC LIMIT 1;","SELECT T1.product_id ,  T1.product_name ,  T1.product_price FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id GROUP BY T1.product_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Products.product_id,"" ""Products.product_name,"" and ""Products.product_price."" Use COUNT to determine the frequency of each product in the orders. 2. Condition Structure: No specific filtering condition is required, as we are interested in all products listed in orders. 3. Join Structure: Use a JOIN between the ""Products"" table and the ""Order_Items"" table on ""Products.product_id = Order_Items.product_id"" to link products with their corresponding orders. 4. Aggregation Structure: Use COUNT on ""Order_Items.product_id"" to count the frequency of each product in orders. Use ORDER BY in descending order to rank products by frequency and LIMIT 1 to get the most frequently listed product.",0.0
39,Find the name and website link of the channels that have more than one program.,NON-NESTED,bbc_channels,"[channel.Name, channel.Internet, program.Channel_ID, program.Program_ID, program.Channel_ID = channel.Channel_ID]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
","SELECT channel.Name, channel.Internet FROM channel JOIN program ON program.Channel_ID = channel.Channel_ID GROUP BY channel.Channel_ID HAVING COUNT(program.Program_ID) > 1;","SELECT t1.name ,  t1.internet FROM channel AS t1 JOIN program AS t2 ON t1.channel_id  =  t2.channel_id GROUP BY t1.channel_id HAVING count(*)  >  1","1. Sequential Structure: Start with the SELECT clause to retrieve ""channel.Name"" and ""channel.Internet."" 2. Condition Structure: Use a HAVING clause to filter channels that have more than one program. This requires counting the number of programs associated with each channel. 3. Join Structure: Use a JOIN between the ""channel"" and ""program"" tables based on ""program.Channel_ID = channel.Channel_ID"" to associate programs with their respective channels. 4. Aggregation Structure: Use COUNT on ""program.Program_ID"" to count the number of programs per channel, then filter with HAVING to select channels with more than one program.",1.0
40,"Of vehicles with power over 6000, return the model of the vehicle with the greatest top speed.",NESTED,vehicle_driver,"[vehicle.Model, vehicle.Power, vehicle.Top_Speed]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT Model FROM vehicle WHERE Power > 6000 AND Top_Speed = (SELECT MAX(Top_Speed) FROM vehicle WHERE Power > 6000);,SELECT model FROM vehicle WHERE power  >  6000 ORDER BY top_speed DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the model of the vehicle. Use the FROM clause to specify the vehicle table. Apply a WHERE clause to filter for vehicles with power greater than 6000. Use a subquery in the WHERE clause to find the vehicle with the greatest top speed among those that meet the power condition. 2. Condition Structure: Use the WHERE clause to filter for vehicles with power greater than 6000 and to identify the vehicle with the maximum top speed. 3. Join Structure: Not required, as all data is in the vehicle table. 4. Aggregation Structure: Use MAX in a subquery to find the greatest top speed among vehicles with power over 6000.",1.0
41,How many customers do not have any payment method?,NESTED,e_commerce,"[Customers.customer_id,Customer_Payment_Methods.customer_id,Customers.customer_id = Customer_Payment_Methods.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT COUNT(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Customer_Payment_Methods);,SELECT count(*) FROM Customers WHERE customer_id NOT IN ( SELECT customer_id FROM Customer_Payment_Methods ),"1. Sequential Structure: Start with the SELECT clause to count the number of customers. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter customers who do not have any payment method by ensuring their customer_id is not present in the Customer_Payment_Methods table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude customers whose customer_id appears in the Customer_Payment_Methods table, meaning they have a payment method. 3. Join Structure: Not required, as we only need to filter based on the absence of matching customer_id entries in the Customer_Payment_Methods table. 4. Aggregation Structure: Use COUNT to calculate the total number of customers who do not have any payment method.",1.0
42,"Show names of players from the club with manager ""Sam Allardyce"".",NON-NESTED,soccer_3,"[player.Name,club.Manager,player.Club_ID = club.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT player.Name FROM player JOIN club ON player.Club_ID = club.Club_ID WHERE club.Manager = 'Sam Allardyce';,"SELECT T2.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T1.Manager  =  ""Sam Allardyce""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""player.Name"" field. 2. Condition Structure: Use a WHERE clause to filter for the club where the ""club.Manager"" is ""Sam Allardyce."" 3. Join Structure: Use a JOIN between the ""player"" and ""club"" tables based on the ""player.Club_ID"" and ""club.Club_ID"" to associate players with their respective clubs. 4. Aggregation Structure: No aggregation is needed as the query only retrieves player names.",1.0
43,What are the names and original air dates of tv shows?,EASY,tv_shows,"[tv_show.tv_show_name, tv_show.Original_Airdate]","Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
","SELECT tv_show.tv_show_name, tv_show.Original_Airdate FROM tv_show;","SELECT tv_show_name ,  Original_Airdate FROM tv_show","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the names of the TV shows and their original air dates. 2. Condition Structure: No specific filtering condition is required as the query aims to retrieve all TV shows and their original air dates. 3. Join Structure: No JOIN is required since all necessary information is available in the ""tv_show"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and original air dates of TV shows.",1.0
44,How many channels have the word 'bbc' in their internet link?,EASY,bbc_channels,"[channel.Internet, channel.Name]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
",SELECT COUNT(*) FROM channel WHERE channel.Internet LIKE '%bbc%';,"SELECT count(*) FROM channel WHERE internet LIKE ""%bbc%""","1. Sequential Structure: Start with the SELECT clause to count the number of channels whose internet link contains the word 'bbc'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for internet links that contain the word 'bbc'. 3. Join Structure: No JOIN is required since all necessary information is in the ""channel"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of channels that meet the condition.",1.0
45,"For each order, what is its id, date, and total amount paid?",NON-NESTED,e_commerce,"[Orders.order_id, Orders.date_order_placed, Order_Items.order_id = Orders.order_id, Order_Items.product_id = Products.product_id, Products.product_price]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Orders.order_id, Orders.date_order_placed, SUM(Products.product_price) AS total_amount_paid FROM Orders JOIN Order_Items ON Order_Items.order_id = Orders.order_id JOIN Products ON Order_Items.product_id = Products.product_id GROUP BY Orders.order_id;","SELECT T1.order_id ,  T1.date_order_placed ,  sum(T3.product_price) FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id JOIN Products AS T3 ON T2.product_id  =  T3.product_id GROUP BY T1.order_id","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Orders.order_id,"" ""Orders.date_order_placed,"" and the total amount paid for each order. The total amount paid will be calculated using SUM on the product prices. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Orders"" table with the ""Order_Items"" table on ""Order_Items.order_id = Orders.order_id"" and the ""Order_Items"" table with the ""Products"" table on ""Order_Items.product_id = Products.product_id."" 4. Aggregation Structure: Use SUM on ""Products.product_price"" to calculate the total amount paid for each order, and GROUP BY ""Orders.order_id"" to group the results by each order.",1.0
46,Show names of players and names of clubs they are in.,NON-NESTED,soccer_3,"[player.Name, club.Name, player.Club_ID = club.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
","SELECT player.Name, club.Name FROM player JOIN club ON player.Club_ID = club.Club_ID;","SELECT T2.Name ,  T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""player.Name"" and ""club.Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""player"" and ""club"" tables based on the shared key ""player.Club_ID = club.Club_ID"" to associate players with their respective clubs. 4. Aggregation Structure: No aggregation is required as the query simply retrieves names of players and their clubs.",1.0
47,What are the distinct countries of players with earnings higher than 1200000?,EASY,soccer_3,"[player.Country, player.Earnings, 1200000]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT DISTINCT player.Country FROM player WHERE player.Earnings > 1200000;,SELECT DISTINCT Country FROM player WHERE Earnings  >  1200000,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct countries of players. 2. Condition Structure: Use a WHERE clause to filter players with earnings higher than 1200000. 3. Join Structure: No JOIN is required since all necessary information is in the ""player"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving distinct values based on a specific condition.",1.0
48,"For each question type, return its type code and its count of occurrence.",NON-NESTED,online_exams,"[Questions.Type_of_Question_Code, Questions.Question_ID, Questions_in_Exams.Question_ID = Questions.Question_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Questions.Type_of_Question_Code, COUNT(Questions_in_Exams.Question_ID) AS occurrence_count FROM Questions JOIN Questions_in_Exams ON Questions.Question_ID = Questions_in_Exams.Question_ID GROUP BY Questions.Type_of_Question_Code;","SELECT Type_of_Question_Code ,  COUNT(*) FROM Questions GROUP BY Type_of_Question_Code","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Questions.Type_of_Question_Code"" and the count of occurrences for each type. Use COUNT to count the occurrences of each question type. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Questions"" table and the ""Questions_in_Exams"" table based on ""Questions.Question_ID"" to link each question with its occurrences in exams. 4. Aggregation Structure: Use COUNT to count the occurrences of each question type and GROUP BY ""Questions.Type_of_Question_Code"" to group the results by question type.",1.0
49,List the distinct subject code of exams in ascending alphabetical order .,EASY,online_exams,[Exams.Subject_Code],"Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT DISTINCT Exams.Subject_Code FROM Exams ORDER BY Exams.Subject_Code ASC;,select distinct subject_code from exams order by subject_code asc,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the distinct subject code of exams. 2. Condition Structure: No specific filtering condition is required as we want all distinct subject codes. 3. Join Structure: No JOIN is required since all necessary data is within the ""Exams"" table. 4. Aggregation Structure: Use DISTINCT to ensure only unique subject codes are retrieved. Use ORDER BY to sort the results in ascending alphabetical order.",1.0
50,List all the pairs of buyer first names and product names.,NON-NESTED,e_commerce,"[Customers.customer_first_name, Products.product_name, Orders.customer_id = Customers.customer_id, Order_Items.order_id = Orders.order_id, Order_Items.product_id = Products.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.customer_first_name, Products.product_name FROM Orders JOIN Customers ON Orders.customer_id = Customers.customer_id JOIN Order_Items ON Order_Items.order_id = Orders.order_id JOIN Products ON Order_Items.product_id = Products.product_id;","SELECT T1.customer_first_name ,  T4.product_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id JOIN Products AS T4 ON T3.product_id  =  T4.product_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Customers.customer_first_name"" and ""Products.product_name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use multiple JOINs to connect the tables. First, join ""Orders"" with ""Customers"" on ""Orders.customer_id = Customers.customer_id."" Then, join ""Order_Items"" with ""Orders"" on ""Order_Items.order_id = Orders.order_id."" Finally, join ""Products"" with ""Order_Items"" on ""Order_Items.product_id = Products.product_id"" to link buyers with the products they purchased. 4. Aggregation Structure: No aggregation is required as the query simply lists all pairs of buyer first names and product names.",1.0
51,What are the login names and passwords of the customers whose phone number have the prefix '+12'?,EASY,e_commerce,"[Customers.login_name, Customers.login_password, Customers.phone_number]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.login_name, Customers.login_password FROM Customers WHERE Customers.phone_number LIKE '+12%';","SELECT login_name ,  login_password FROM Customers WHERE phone_number LIKE '+12%'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""login_name"" and ""login_password"" of customers. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for customers whose phone number starts with the prefix '+12'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
52,"What are the names of clubs, ordered descending by the average earnings of players within each?",NON-NESTED,soccer_3,"[club.Name, player.Earnings, player.Club_ID = club.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
","SELECT club.Name, AVG(player.Earnings) AS AverageEarnings FROM club JOIN player ON player.Club_ID = club.Club_ID GROUP BY club.Name ORDER BY AverageEarnings DESC;",SELECT T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID GROUP BY T1.Club_ID ORDER BY avg(T2.Earnings) DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""club.Name"" and the average earnings of players within each club. Use an aggregate function (AVG) on ""player.Earnings"" to calculate the average earnings. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""club"" and ""player"" tables based on the relationship ""player.Club_ID = club.Club_ID"" to associate players with their respective clubs. 4. Aggregation Structure: Use AVG to calculate the average earnings of players for each club, and GROUP BY ""club.Name"" to group the results by club. Use ORDER BY in descending order on the average earnings to sort the results.",1.0
53,Find the number of channels that do not run any program.,NESTED,bbc_channels,"[channel.Channel_ID, program.Channel_ID, channel.Channel_ID != program.Channel_ID]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
",SELECT COUNT(*) FROM channel WHERE Channel_ID NOT IN (SELECT Channel_ID FROM program);,SELECT count(*) FROM channel WHERE channel_id NOT IN (SELECT channel_id FROM program),"1. Sequential Structure: Start with the SELECT clause to count the number of channels. Use the FROM clause to specify the channel table. Apply a WHERE clause to filter channels that do not run any program by ensuring their Channel_ID is not present in the program table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude channels whose Channel_ID appears in the program table, meaning they run programs. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Channel_ID entries in the program table. 4. Aggregation Structure: Use COUNT to calculate the total number of channels that meet the condition of not running any program.",1.0
54,Give the id and name of the cheapest Hardware product.,EASY,customers_and_orders,"[Products.product_id, Products.product_name, Products.product_price, Products.product_type_code]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_id, Products.product_name FROM Products WHERE Products.product_type_code = 'Hardware' ORDER BY Products.product_price ASC LIMIT 1;","SELECT product_id ,  product_name FROM Products WHERE product_type_code  =  ""Hardware"" ORDER BY product_price ASC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Products.product_id"" and ""Products.product_name"" of the cheapest Hardware product. 2. Condition Structure: Use a WHERE clause to filter for products where ""Products.product_type_code"" corresponds to Hardware. 3. Aggregation Structure: Use ORDER BY on ""Products.product_price"" in ascending order to rank products by price. 4. Limiting Structure: Use LIMIT 1 to select the cheapest Hardware product. 5. Join Structure: No JOIN is required since all necessary information is in the ""Products"" table.",1.0
55,"What are the ids, first and last names of the customers who have ordered more than twice and have bought at least 3 items?",NESTED,e_commerce,"[Customers.customer_id,Customers.customer_first_name,Customers.customer_last_name,Orders.customer_id,Order_Items.order_id,Order_Items.order_item_id,Orders.order_id = Order_Items.order_id,Orders.customer_id = Customers.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.customer_id, Customers.customer_first_name, Customers.customer_last_name FROM Customers JOIN Orders ON Customers.customer_id = Orders.customer_id JOIN Order_Items ON Orders.order_id = Order_Items.order_id GROUP BY Customers.customer_id, Customers.customer_first_name, Customers.customer_last_name HAVING COUNT(DISTINCT Orders.order_id) > 2 AND COUNT(Order_Items.order_item_id) >= 3;","SELECT T1.customer_id ,  T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >  2 INTERSECT SELECT T1.customer_id ,  T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id GROUP BY T1.customer_id HAVING count(*)  >= 3","1. Sequential Structure: Start with the SELECT clause to retrieve the customer IDs, first names, and last names. Use the FROM clause to specify the Customers table and JOIN it with the Orders and Order_Items tables to link customers with their orders and the items they purchased. Use GROUP BY to group data by customer_id, and apply HAVING to filter customers who meet the conditions of ordering more than twice and buying at least 3 items. 2. Condition Structure: Use the HAVING clause to filter customers who have placed more than 2 orders and have purchased at least 3 items. 3. Join Structure: Use INNER JOINs to connect the Customers table with the Orders table on customer_id, and the Orders table with the Order_Items table on order_id, to establish the relationships between customers, their orders, and the items in those orders. 4. Aggregation Structure: Use COUNT to calculate the number of orders and the number of items purchased for each customer, and apply conditions in the HAVING clause to filter based on these counts.",0.0
56,What are the product price and the product size of the products whose price is above average?,NESTED,e_commerce,"[Products.product_price, Products.product_size]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT product_price, product_size FROM Products WHERE product_price > (SELECT AVG(product_price) FROM Products);","SELECT product_price ,  product_size FROM Products WHERE product_price  >  ( SELECT avg(product_price) FROM Products )","1. Sequential Structure: Start with the SELECT clause to retrieve the product price and product size. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter products whose price is above the average price. 2. Condition Structure: Use the WHERE clause with a subquery to filter for products where the product price is greater than the average product price. 3. Join Structure: Not required, as all data is in the Products table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average product price, which is then used in the filtering condition.",1.0
57,Return the name of the player who earns the most money.,EASY,soccer_3,"[player.Name, player.Earnings]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT player.Name FROM player ORDER BY player.Earnings DESC LIMIT 1;,SELECT Name FROM player ORDER BY Earnings DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""player.Name"" of the player who earns the most money. 2. Condition Structure: No specific filtering condition is needed since we are looking for the player with the highest earnings. 3. Join Structure: No JOIN is required, as all necessary information is in the ""player"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""player.Earnings"" to rank players by their earnings and apply LIMIT 1 to select the player with the highest earnings.",1.0
58,"For all the products sold for more than 3 times, list their id and description.",NON-NESTED,e_commerce,"[Order_Items.product_id, Products.product_id, Products.product_description]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Products.product_id, Products.product_description FROM Order_Items JOIN Products ON Order_Items.product_id = Products.product_id GROUP BY Products.product_id, Products.product_description HAVING COUNT(Order_Items.product_id) > 3;","SELECT T1.product_id ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id GROUP BY T1.product_id HAVING count(*)  >  3","1. Sequential Structure: Start with the SELECT clause to retrieve the ""product_id"" and ""product_description"" of products sold more than 3 times. 2. Condition Structure: Use a HAVING clause to filter products that have been sold more than 3 times. This requires counting the occurrences of each product in the ""Order_Items"" table. 3. Join Structure: Use a JOIN between the ""Order_Items"" and ""Products"" tables on the ""product_id"" field to link each product with its description. 4. Aggregation Structure: Use COUNT on ""Order_Items.product_id"" to count the number of times each product was sold, then filter with HAVING to include only those with a count greater than 3.",1.0
59,Show the transmitters of the radios and the number of city channels they are associated with.,NON-NESTED,tv_shows,"[radio.Transmitter, city_channel_radio.Radio_ID, city_channel_radio.City_channel_ID = city_channel.ID, city_channel_radio.Radio_ID = radio.Radio_ID]","Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
","SELECT radio.Transmitter, COUNT(city_channel.ID) AS Number_of_City_Channels FROM radio JOIN city_channel_radio ON radio.Radio_ID = city_channel_radio.Radio_ID JOIN city_channel ON city_channel_radio.City_channel_ID = city_channel.ID GROUP BY radio.Transmitter;","SELECT T2.Transmitter ,  COUNT(*) FROM city_channel_radio AS T1 JOIN radio AS T2 ON T1.Radio_ID  =  T2.Radio_ID GROUP BY T2.Transmitter","1. Sequential Structure: Start with the SELECT clause to retrieve the ""radio.Transmitter"" and the count of city channels associated with each transmitter. Use COUNT to count the number of city channels. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""radio"" table with the ""city_channel_radio"" table on ""radio.Radio_ID"" and ""city_channel_radio.Radio_ID."" Then, connect ""city_channel_radio"" with ""city_channel"" on ""city_channel_radio.City_channel_ID = city_channel.ID."" 4. Aggregation Structure: Use COUNT to count the number of city channels for each transmitter and GROUP BY ""radio.Transmitter"" to group the results by each transmitter.",1.0
60,Count the number of addresses.,EASY,customers_and_orders,[Addresses.address_id],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(Addresses.address_id) AS address_count FROM Addresses;,SELECT count(*) FROM Addresses,"1. Sequential Structure: Begin with the SELECT clause to count the number of addresses. 2. Aggregation Structure: Use the COUNT function to calculate the total number of addresses. 3. Join Structure: No JOIN is required since all necessary data is within the ""Addresses"" table. 4. Condition Structure: No specific filtering condition is needed as we are counting all addresses.",1.0
61,"Of players who have more than 2 wins, what is the country of the player who makes the most?",NESTED,soccer_3,"[player.Wins_count, player.Country, player.Earnings]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT Country FROM player WHERE Wins_count > 2 ORDER BY Earnings DESC LIMIT 1;,SELECT Country FROM player WHERE Wins_count  >  2 ORDER BY Earnings DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the country of the player. Use the FROM clause to specify the player table. Apply a WHERE clause to filter players with more than 2 wins. Use ORDER BY to sort the players by their earnings in descending order and LIMIT to select the top player. 2. Condition Structure: Use the WHERE clause to filter players who have more than 2 wins. 3. Join Structure: Not required, as all data is available within the player table. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
62,How many customers do not have a listed payment method?,NESTED,e_commerce,"[Customers.customer_id,Customer_Payment_Methods.customer_id,Customers.customer_id = Customer_Payment_Methods.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT COUNT(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Customer_Payment_Methods);,SELECT count(*) FROM Customers WHERE customer_id NOT IN ( SELECT customer_id FROM Customer_Payment_Methods ),"1. Sequential Structure: Start with the SELECT clause to count the number of customers. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter customers who do not have a listed payment method by ensuring their customer_id is not present in the Customer_Payment_Methods table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude customers whose customer_id appears in the Customer_Payment_Methods table, indicating they have a payment method. 3. Join Structure: Not required, as we only need to filter based on the absence of matching customer_id entries in the Customer_Payment_Methods table. 4. Aggregation Structure: Use COUNT to calculate the total number of customers who meet the condition of not having a listed payment method.",1.0
63,Count the number of vehicles that have a top speed equal to the maximum across all vehicles.,NESTED,vehicle_driver,"[vehicle.Top_Speed, vehicle.Vehicle_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT COUNT(*) FROM vehicle WHERE Top_Speed = (SELECT MAX(Top_Speed) FROM vehicle);,SELECT count(*) FROM vehicle WHERE top_speed  =  (SELECT max(top_speed) FROM vehicle),"1. Sequential Structure: Start with the SELECT clause to count the number of vehicles. Use the FROM clause to specify the vehicle table. Apply a WHERE clause to filter vehicles whose top speed is equal to the maximum top speed across all vehicles. 2. Condition Structure: Use the WHERE clause with a subquery to filter for vehicles whose top speed matches the maximum top speed. The subquery calculates the maximum top speed from the vehicle table. 3. Join Structure: Not required, as all data is in the vehicle table. 4. Aggregation Structure: Use the MAX function in the subquery to find the maximum top speed, and use COUNT in the main query to count the number of vehicles with this top speed.",1.0
64,Which manufacturers work for more than 1 club?,EASY,soccer_3,"[club.Manufacturer, club.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT club.Manufacturer FROM club GROUP BY club.Manufacturer HAVING COUNT(DISTINCT club.Club_ID) > 1;,SELECT Manufacturer FROM club GROUP BY Manufacturer HAVING COUNT(*)  >  1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the manufacturer. 2. Aggregation Structure: Use COUNT to determine the number of clubs each manufacturer works for. 3. Grouping Structure: Use GROUP BY on ""club.Manufacturer"" to aggregate the results by each manufacturer. 4. Condition Structure: Apply the HAVING clause to filter for manufacturers that work for more than one club, by setting the count to be greater than 1. 5. Join Structure: No JOIN is required since all necessary data is within the ""club"" table.",1.0
65,What are the invoice statuses for all orderes that have not been shipped out yet?,NESTED,e_commerce,"[Invoices.invoice_status_code,Orders.order_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT Invoices.invoice_status_code FROM Invoices JOIN Shipments ON Shipments.invoice_number = Invoices.invoice_number JOIN Orders ON Shipments.order_id = Orders.order_id WHERE Shipments.shipment_status IS NULL OR Shipments.shipment_status = 'Not Shipped';,SELECT invoice_status_code FROM Invoices WHERE invoice_number NOT IN ( SELECT invoice_number FROM Shipments ),"1. Sequential Structure: Start with the SELECT clause to retrieve the invoice statuses. Use the FROM clause to specify the Invoices table. Join it with the Shipments table to connect invoices with shipments, and then join the Shipments table with the Orders table to link orders with their shipment and invoice details. Apply a WHERE clause to filter for orders that have not been shipped out yet. 2. Condition Structure: Use the WHERE clause to filter for orders where the shipment status indicates that they have not been shipped out yet. This can be determined by checking for NULL or specific shipment status codes in the Shipments table. 3. Join Structure: Use JOINs between the Invoices, Shipments, and Orders tables based on the relationships provided: Shipments.order_id = Orders.order_id and Shipments.invoice_number = Invoices.invoice_number. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
66,Which countries have produced more than one player?,EASY,soccer_3,"[player.Country, player.Player_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT player.Country FROM player GROUP BY player.Country HAVING COUNT(player.Player_ID) > 1;,SELECT Country FROM player GROUP BY Country HAVING COUNT(*)  >  1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the country name. 2. Aggregation Structure: Use COUNT to determine the number of players from each country. 3. Grouping Structure: Use GROUP BY on ""player.Country"" to aggregate the results by each country. 4. Condition Structure: Apply the HAVING clause to filter for countries that have produced more than one player, by setting the count to be greater than 1. 5. Join Structure: No JOIN is required since all necessary data is within the ""player"" table.",1.0
67,"List the customers' first name, middle initial, last name and payment methods.",NON-NESTED,e_commerce,"[Customers.customer_first_name, Customers.customer_middle_initial, Customers.customer_last_name, Customer_Payment_Methods.payment_method_code, Customer_Payment_Methods.customer_id = Customers.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.customer_first_name, Customers.customer_middle_initial, Customers.customer_last_name, Customer_Payment_Methods.payment_method_code FROM Customers JOIN Customer_Payment_Methods ON Customers.customer_id = Customer_Payment_Methods.customer_id;","SELECT T1.customer_first_name ,  T1.customer_middle_initial ,  T1.customer_last_name ,  T2.Payment_method_code FROM Customers AS T1 JOIN Customer_Payment_Methods AS T2 ON T1.customer_id  =  T2.customer_id","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Customers.customer_first_name,"" ""Customers.customer_middle_initial,"" ""Customers.customer_last_name,"" and ""Customer_Payment_Methods.payment_method_code."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Customers"" table and the ""Customer_Payment_Methods"" table on the shared key ""Customers.customer_id = Customer_Payment_Methods.customer_id"" to link customers with their payment methods. 4. Aggregation Structure: No aggregation is required as the query only retrieves individual records.",1.0
68,What is the product name and the color of the ordered items which have been shipped?,NON-NESTED,e_commerce,"[Products.product_name, Products.product_color, Order_Items.product_id = Products.product_id, Order_Items.order_item_id = Shipment_Items.order_item_id, Shipment_Items.shipment_id = Shipments.shipment_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Products.product_name, Products.product_color FROM Order_Items JOIN Products ON Order_Items.product_id = Products.product_id JOIN Shipment_Items ON Order_Items.order_item_id = Shipment_Items.order_item_id JOIN Shipments ON Shipment_Items.shipment_id = Shipments.shipment_id;","SELECT T1.product_name ,  T1.product_color FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Shipment_Items AS T3 ON T2.order_item_id  =  T3.order_item_id JOIN Shipments AS T4 ON T3.shipment_id  =  T4.shipment_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Products.product_name"" and ""Products.product_color."" 2. Condition Structure: Use a WHERE clause to filter for items that have been shipped. This can be determined by ensuring there is a matching ""shipment_id"" in the ""Shipments"" table. 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""Order_Items"" with ""Products"" on ""Order_Items.product_id = Products.product_id"" to link products with their order items. Then, join ""Order_Items"" with ""Shipment_Items"" on ""Order_Items.order_item_id = Shipment_Items.order_item_id"" to link order items with shipment items. Finally, join ""Shipment_Items"" with ""Shipments"" on ""Shipment_Items.shipment_id = Shipments.shipment_id"" to ensure the items have been shipped. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields for shipped items.",1.0
69,List the affiliations shared by more than three city channels.,EASY,tv_shows,"[city_channel.Affiliation, city_channel.ID]","Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
",SELECT city_channel.Affiliation FROM city_channel GROUP BY city_channel.Affiliation HAVING COUNT(city_channel.ID) > 3;,SELECT Affiliation FROM city_channel GROUP BY Affiliation HAVING COUNT(*)  >  3,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""Affiliation"" shared by city channels. 2. Aggregation Structure: Use COUNT to determine the number of city channels associated with each affiliation. 3. Grouping Structure: Use GROUP BY on ""city_channel.Affiliation"" to aggregate the results by each affiliation. 4. Condition Structure: Apply the HAVING clause to filter for affiliations that are shared by more than three city channels, by setting the count to be greater than 3. 5. Join Structure: No JOIN is required since all necessary data is within the ""city_channel"" table.",1.0
70,What is the name of the most expensive product with type Clothes?,EASY,customers_and_orders,"[Products.product_name, Products.product_price, Products.product_type_code]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Products.product_name FROM Products WHERE Products.product_type_code = 'Clothes' ORDER BY Products.product_price DESC LIMIT 1;,"SELECT product_name FROM Products WHERE product_type_code  =  ""Clothes"" ORDER BY product_price DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Products.product_name"" of the most expensive product with type Clothes. 2. Condition Structure: Use a WHERE clause to filter for products where ""Products.product_type_code"" is 'Clothes'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Products"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""Products.product_price"" to rank products by price and apply LIMIT 1 to select the most expensive product.",1.0
71,What are the product type code with at least two products?,EASY,customers_and_orders,"[Products.product_type_code, Products.product_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Products.product_type_code FROM Products GROUP BY Products.product_type_code HAVING COUNT(Products.product_id) >= 2;,SELECT product_type_code FROM Products GROUP BY product_type_code HAVING count(*)  >=  2,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""product_type_code"". 2. Aggregation Structure: Use COUNT to determine the number of products for each product type code. 3. Grouping Structure: Use GROUP BY on ""Products.product_type_code"" to aggregate the results by each product type code. 4. Condition Structure: Apply the HAVING clause to filter for product type codes that have at least two products, by setting the count to be greater than or equal to 2. 5. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table.",1.0
72,Which students do not have any answers? Find their first names.,NESTED,online_exams,"[Students.First_Name,Students.Student_ID,Student_Answers.Student_ID = Students.Student_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Students.First_Name FROM Students WHERE Students.Student_ID NOT IN (SELECT Student_ID FROM Student_Answers);,SELECT First_Name FROM Students WHERE Student_ID NOT IN (SELECT Student_ID FROM Student_Answers),"1. Sequential Structure: Begin with the SELECT clause to retrieve the first names of students. Use the FROM clause to specify the Students table. Apply a WHERE clause to filter students who do not have any answers by ensuring their Student_ID is not present in the Student_Answers table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose Student_ID appears in the Student_Answers table, meaning they have provided answers. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Student_ID entries in the Student_Answers table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
73,What are the names of the drivers who are citizens of the 'United States'?,EASY,vehicle_driver,"[driver.Name,driver.Citizenship,driver.Driver_ID = vehicle_driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT driver.Name FROM driver WHERE driver.Citizenship = 'United States';,SELECT name FROM driver WHERE citizenship  =  'United States',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the drivers. 2. Condition Structure: Use a WHERE clause to filter for drivers whose citizenship is 'United States'. 3. Join Structure: No JOIN is required since the necessary information is available in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of drivers based on a specific condition.",1.0
74,what are all shipment tracking numbers and shipment dates?,EASY,e_commerce,"[Shipments.shipment_tracking_number, Shipments.shipment_date]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Shipments.shipment_tracking_number, Shipments.shipment_date FROM Shipments;","SELECT shipment_tracking_number ,  shipment_date FROM Shipments","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""shipment_tracking_number"" and ""shipment_date"". 2. Condition Structure: No specific filtering condition is required as the query asks for all shipment tracking numbers and shipment dates. 3. Join Structure: No JOIN is required since all necessary data is within the ""Shipments"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all records.",1.0
75,How many kinds of products have not been sold?,NESTED,e_commerce,"[Products.product_id,Order_Items.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT COUNT(DISTINCT product_id) AS unsold_products FROM Products WHERE product_id NOT IN (SELECT product_id FROM Order_Items);,SELECT count(*) FROM Products WHERE product_id NOT IN ( SELECT product_id FROM Order_items ),"1. Sequential Structure: Start with the SELECT clause to count the distinct product IDs from the Products table. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter for products that have not been sold by ensuring their product_id is not present in the Order_Items table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude products whose product_id appears in the Order_Items table, meaning they have been sold. 3. Join Structure: Not required, as we only need to filter based on the absence of matching product_id entries in the Order_Items table. 4. Aggregation Structure: Use COUNT to count the distinct product IDs that meet the condition of not being sold.",1.0
76,Return the top speed and power of the vehicle that was built in the year 1996.,EASY,vehicle_driver,"[vehicle.Top_Speed, vehicle.Power, vehicle.Build_Year, 1996]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT vehicle.Top_Speed, vehicle.Power FROM vehicle WHERE vehicle.Build_Year = 1996;","SELECT top_speed ,  power FROM vehicle WHERE build_year  =  1996","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are ""vehicle.Top_Speed"" and ""vehicle.Power"". 2. Condition Structure: Use a WHERE clause to filter for vehicles that were built in the year 1996. 3. Join Structure: No JOIN is required since all necessary data is within the ""vehicle"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields for vehicles built in 1996.",1.0
77,"What are the minimum, average, and maximum prices across all products?",EASY,customers_and_orders,[Products.product_price],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT MIN(Products.product_price) AS min_price, AVG(Products.product_price) AS avg_price, MAX(Products.product_price) AS max_price FROM Products;","SELECT min(product_price) ,  avg(product_price) ,  max(product_price) FROM Products","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the minimum, average, and maximum prices. 2. Aggregation Structure: Use MIN, AVG, and MAX functions to calculate the minimum, average, and maximum prices across all products. 3. Grouping Structure: No GROUP BY is required since the query is asking for aggregate values across all products. 4. Join Structure: No JOIN is required as all necessary data is within the ""Products"" table.",1.0
78,What are the distinct driver names who have driven vehicles with power more than 5000 ?,NON-NESTED,vehicle_driver,"[driver.Name, vehicle.Power, vehicle_driver.Driver_ID = driver.Driver_ID, vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT DISTINCT driver.Name FROM driver JOIN vehicle_driver ON vehicle_driver.Driver_ID = driver.Driver_ID JOIN vehicle ON vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID WHERE vehicle.Power > 5000;,select distinct t1.name from driver as t1 join vehicle_driver as t2 on t1.driver_id  =  t2.driver_id join vehicle as t3 on t2.vehicle_id  =  t3.vehicle_id where t3.power  >  5000,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct ""driver.Name."" 2. Condition Structure: Use a WHERE clause to filter for vehicles with ""vehicle.Power"" greater than 5000. 3. Join Structure: Use JOINs to connect the ""driver"" table with the ""vehicle_driver"" table on ""Driver_ID"" and the ""vehicle_driver"" table with the ""vehicle"" table on ""Vehicle_ID"" to link drivers with their respective vehicles. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique driver names are returned.",1.0
79,"What are the names of clubs, ordered alphabetically?",EASY,soccer_3,[club.Name],"Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT club.Name FROM club ORDER BY club.Name ASC;,SELECT Name FROM club ORDER BY Name ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the club name. 2. Condition Structure: No specific filtering condition is required as we want all club names. 3. Join Structure: No JOIN is required since all necessary data is within the ""club"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the club names. 5. Ordering Structure: Use ORDER BY to sort the club names alphabetically.",1.0
80,How many clubs use each manufacturer?,EASY,soccer_3,"[club.Manufacturer, club.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
","SELECT club.Manufacturer, COUNT(club.Club_ID) AS club_count FROM club GROUP BY club.Manufacturer;","SELECT Manufacturer ,  COUNT(*) FROM club GROUP BY Manufacturer","1. Sequential Structure: Begin with the SELECT clause to specify the manufacturer and the count of clubs using each manufacturer. 2. Aggregation Structure: Use COUNT to calculate the number of clubs associated with each manufacturer. 3. Grouping Structure: Use GROUP BY on ""club.Manufacturer"" to aggregate the results by each manufacturer. 4. Join Structure: No JOIN is required since all necessary data is within the ""club"" table.",1.0
81,"What are the names of the products, sorted by descending price?",EASY,customers_and_orders,"[Products.product_name, Products.product_price]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_name, Products.product_price FROM Products ORDER BY Products.product_price DESC;",SELECT product_name FROM Products ORDER BY product_price DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the product name, along with the product price for sorting purposes. 2. Condition Structure: No specific filtering condition is required as we want all product names. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Products"" table. 4. Aggregation Structure: No aggregation function is needed here, but use ORDER BY to sort the results in descending order based on ""Products.product_price"".",1.0
82,What is the payment method that most customers use?,NON-NESTED,e_commerce,"[Customer_Payment_Methods.payment_method_code,Customer_Payment_Methods.customer_id,Customer_Payment_Methods.customer_id = Customers.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT Customer_Payment_Methods.payment_method_code FROM Customer_Payment_Methods GROUP BY Customer_Payment_Methods.payment_method_code ORDER BY COUNT(Customer_Payment_Methods.payment_method_code) DESC LIMIT 1;,SELECT Payment_method_code FROM Customer_Payment_Methods GROUP BY Payment_method_code ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""payment_method_code"" and use COUNT to determine the frequency of each payment method. 2. Condition Structure: No specific filtering condition is required, as we are interested in all payment methods. 3. Join Structure: No JOIN is necessary since all the required data is available in the ""Customer_Payment_Methods"" table. 4. Aggregation Structure: Use COUNT to count the occurrences of each ""payment_method_code,"" then use ORDER BY in descending order to rank the payment methods by their frequency. Use LIMIT 1 to select the most used payment method.",1.0
83,Return the maximum and average power for the vehicles built by Zhuzhou.,EASY,vehicle_driver,"[vehicle.Power, vehicle.Builder]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT MAX(vehicle.Power) AS max_power, AVG(vehicle.Power) AS avg_power FROM vehicle WHERE vehicle.Builder = 'Zhuzhou';","SELECT max(power) ,  avg(power) FROM vehicle WHERE builder  =  'Zhuzhou'","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and average power for vehicles. 2. Condition Structure: Use a WHERE clause to filter for vehicles built by ""Zhuzhou"". 3. Aggregation Structure: Use MAX and AVG functions to calculate the maximum and average power for the filtered vehicles. 4. Join Structure: No JOIN is required since all necessary data is within the ""vehicle"" table.",1.0
84,What is the country of the player with the highest earnings among players that have more than 2 win counts?,NESTED,soccer_3,"[player.Country, player.Earnings, player.Wins_count]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT Country FROM player WHERE Wins_count > 2 ORDER BY Earnings DESC LIMIT 1;,SELECT Country FROM player WHERE Wins_count  >  2 ORDER BY Earnings DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the country of the player. Use the FROM clause to specify the player table. Apply a WHERE clause to filter players with more than 2 win counts. Use ORDER BY to sort the earnings in descending order and LIMIT 1 to get the player with the highest earnings. 2. Condition Structure: Use the WHERE clause to filter players whose win counts are greater than 2. 3. Join Structure: Not required, as all data is available within the player table. 4. Aggregation Structure: Not required, as we are only retrieving the record with the highest earnings after filtering.",1.0
85,What are the model names and build year of the cars with 'DJ' in its model name?,EASY,vehicle_driver,"[vehicle.Model, vehicle.Build_Year]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT vehicle.Model, vehicle.Build_Year FROM vehicle WHERE vehicle.Model LIKE '%DJ%';","SELECT model ,  build_year FROM vehicle WHERE model LIKE '%DJ%'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""vehicle.Model"" and ""vehicle.Build_Year"" for cars with 'DJ' in their model name. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for model names that contain 'DJ'. 3. Join Structure: No JOIN is required since all necessary information is in the ""vehicle"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
86,"What are the colors , descriptions , and sizes for all products that are not at the maximum price ?",NESTED,e_commerce,"[Products.product_color, Products.product_description, Products.product_size, Products.product_price]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT product_color, product_description, product_size FROM Products WHERE product_price < (SELECT MAX(product_price) FROM Products);","select product_color ,  product_description ,  product_size from products where product_price  !=  ( select max(product_price) from products )","1. Sequential Structure: Start with the SELECT clause to retrieve the product color, description, and size. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter out products that are priced at the maximum price. 2. Condition Structure: Use the WHERE clause with a subquery to exclude products whose price matches the maximum price. The subquery calculates the maximum price from the Products table. 3. Join Structure: Not required, as all data is available within the Products table. 4. Aggregation Structure: Use the MAX function in a subquery to find the maximum price, which is then used in the filtering condition.",1.0
87,Count the number of drivers that have raced in each series.,NON-NESTED,vehicle_driver,"[driver.Racing_Series, vehicle_driver.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT driver.Racing_Series, COUNT(DISTINCT vehicle_driver.Driver_ID) AS Driver_Count FROM vehicle_driver JOIN driver ON vehicle_driver.Driver_ID = driver.Driver_ID GROUP BY driver.Racing_Series;","SELECT count(*) ,  racing_series FROM driver GROUP BY racing_series","1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Racing_Series"" and the count of distinct ""vehicle_driver.Driver_ID"" for each series. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""vehicle_driver"" and ""driver"" tables based on the ""Driver_ID"" field to associate drivers with their respective racing series. 4. Aggregation Structure: Use COUNT with DISTINCT on ""vehicle_driver.Driver_ID"" to count the unique drivers for each racing series, and GROUP BY ""driver.Racing_Series"" to group the results by series.",1.0
88,List the order date of the orders who are placed by customers with at least 2 payment methods.,NESTED,e_commerce,"[Orders.date_order_placed,Orders.customer_id = Customers.customer_id,Customer_Payment_Methods.customer_id = Customers.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Orders.date_order_placed FROM Orders JOIN Customers ON Orders.customer_id = Customers.customer_id JOIN Customer_Payment_Methods ON Customer_Payment_Methods.customer_id = Customers.customer_id GROUP BY Orders.customer_id, Orders.date_order_placed HAVING COUNT(Customer_Payment_Methods.customer_id) >= 2;",SELECT date_order_placed FROM Orders WHERE customer_id IN ( SELECT T1.customer_id FROM Customers AS T1 JOIN Customer_Payment_Methods AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2 ),"1. Sequential Structure: Start with the SELECT clause to retrieve the order date from the Orders table. Use the FROM clause to specify the Orders table and JOIN it with the Customers table to link orders with customers. Further, JOIN the Customer_Payment_Methods table to identify customers with their payment methods. Use GROUP BY to group records by customer_id and apply a HAVING clause to filter customers with at least 2 payment methods. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for customers who have at least 2 payment methods. 3. Join Structure: Use INNER JOINs between Orders, Customers, and Customer_Payment_Methods tables based on customer_id to connect orders with customers and their payment methods. 4. Aggregation Structure: Use COUNT(*) within HAVING to count the number of payment methods per customer and filter those with at least 2 payment methods.",1.0
89,What is the transmitter of the radio with the largest ERP_kW?,EASY,tv_shows,"[radio.Transmitter, radio.ERP_kW]","Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
",SELECT radio.Transmitter FROM radio ORDER BY radio.ERP_kW DESC LIMIT 1;,SELECT Transmitter FROM radio ORDER BY ERP_kW DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""radio.Transmitter"" of the radio with the largest ""ERP_kW"". 2. Condition Structure: No specific filtering condition is needed since we are looking for the radio with the maximum ERP_kW. 3. Join Structure: No JOIN is required, as all necessary information is in the ""radio"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""radio.ERP_kW"" to rank radios by their ERP_kW and apply LIMIT 1 to select the radio with the largest ERP_kW.",1.0
90,"Show the earnings of players from country ""Australia"" or ""Zimbabwe"".",EASY,soccer_3,"[player.Earnings, player.Country, Australia, Zimbabwe]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT player.Earnings FROM player WHERE player.Country = 'Australia' OR player.Country = 'Zimbabwe';,"SELECT Earnings FROM player WHERE Country  =  ""Australia"" OR Country  =  ""Zimbabwe""","1. Sequential Structure: Start with the SELECT clause to specify the ""player.Earnings"" field, as the question asks for the earnings of players. 2. Condition Structure: Use a WHERE clause to filter players whose ""player.Country"" is either ""Australia"" or ""Zimbabwe"". 3. Join Structure: No JOIN is required since all necessary information is in the ""player"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving the earnings of players from the specified countries.",1.0
91,What is the most common valid answer text?,EASY,online_exams,[Valid_Answers.Valid_Answer_Text],"Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Valid_Answers.Valid_Answer_Text FROM Valid_Answers GROUP BY Valid_Answers.Valid_Answer_Text ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Valid_Answer_Text FROM Valid_Answers GROUP BY Valid_Answer_Text ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""Valid_Answers.Valid_Answer_Text"". 2. Aggregation Structure: Use COUNT to determine the frequency of each valid answer text. 3. Grouping Structure: Use GROUP BY on ""Valid_Answers.Valid_Answer_Text"" to aggregate the results by each valid answer text. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank the valid answer texts by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common valid answer text. 6. Join Structure: No JOIN is required since all necessary data is within the ""Valid_Answers"" table.",1.0
92,"Show all product ids, product type codes, and product name.",EASY,customers_and_orders,"[Products.product_id, Products.product_type_code, Products.product_name]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_id, Products.product_type_code, Products.product_name FROM Products;","SELECT product_id ,  product_type_code ,  product_name FROM Products","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Products.product_id,"" ""Products.product_type_code,"" and ""Products.product_name."" 2. Condition Structure: No specific filtering condition is required as the query asks for all products. 3. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all the specified fields.",1.0
93,List each gender and the corresponding number of students.,EASY,online_exams,"[Students.Gender_MFU, Students.Student_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Students.Gender_MFU, COUNT(Students.Student_ID) AS student_count FROM Students GROUP BY Students.Gender_MFU;","SELECT Gender_MFU ,  COUNT(*) FROM Students GROUP BY Gender_MFU","1. Sequential Structure: Begin with the SELECT clause to specify the gender and the count of students for each gender. 2. Aggregation Structure: Use COUNT to calculate the number of students for each gender. 3. Grouping Structure: Use GROUP BY on ""Students.Gender_MFU"" to group the results by gender. 4. Join Structure: No JOIN is required since all necessary data is within the ""Students"" table.",1.0
94,"What are the build year, model name and builder of the vehicles?",EASY,vehicle_driver,"[vehicle.Build_Year, vehicle.Model, vehicle.Builder]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT vehicle.Build_Year, vehicle.Model, vehicle.Builder FROM vehicle;","SELECT build_year ,  model ,  builder FROM vehicle","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""vehicle.Build_Year"", ""vehicle.Model"", and ""vehicle.Builder"". 2. Condition Structure: No specific filtering condition is required as the query asks for all vehicles. 3. Join Structure: No JOIN is required since all necessary information is available in the ""vehicle"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all vehicles.",1.0
95,What is the maximum and average power for the vehicles manufactured by 'Zhuzhou'?,EASY,vehicle_driver,"[vehicle.Power, vehicle.Builder, 'Zhuzhou']","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT MAX(vehicle.Power) AS max_power, AVG(vehicle.Power) AS avg_power FROM vehicle WHERE vehicle.Builder = 'Zhuzhou';","SELECT max(power) ,  avg(power) FROM vehicle WHERE builder  =  'Zhuzhou'","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and average power of the vehicles. 2. Condition Structure: Use a WHERE clause to filter for vehicles manufactured by 'Zhuzhou'. 3. Aggregation Structure: Use MAX and AVG functions to calculate the maximum and average power for the filtered vehicles. 4. Join Structure: No JOIN is required since all necessary data is within the ""vehicle"" table.",1.0
96,What is al the available information of each student?,EASY,online_exams,"[Students.Student_ID, Students.First_Name, Students.Middle_Name, Students.Last_Name, Students.Gender_MFU, Students.Student_Address, Students.Email_Adress, Students.Cell_Mobile_Phone, Students.Home_Phone]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT * FROM Students;,SELECT * FROM Students,"1. Sequential Structure: Begin with the SELECT clause to retrieve all available information for each student. Use the ""*"" wildcard to select all columns from the ""Students"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for all available information for each student. 3. Join Structure: No JOIN is necessary since all the required data is contained within the ""Students"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all the data without any summarization.",1.0
97,List all address ids and address details.,EASY,customers_and_orders,"[Addresses.address_id, Addresses.address_details]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Addresses.address_id, Addresses.address_details FROM Addresses;","SELECT address_id ,  address_details FROM Addresses","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Addresses.address_id"" and ""Addresses.address_details"". 2. Condition Structure: No specific filtering condition is required as the query asks for all address IDs and their details. 3. Join Structure: No JOIN is required since all necessary data is within the ""Addresses"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all records from the table.",1.0
98,What is the top speed and power of the vehicle manufactured in the year of 1996?,EASY,vehicle_driver,"[vehicle.Top_Speed, vehicle.Power, vehicle.Build_Year, 1996]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT vehicle.Top_Speed, vehicle.Power FROM vehicle WHERE vehicle.Build_Year = 1996;","SELECT top_speed ,  power FROM vehicle WHERE build_year  =  1996","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""vehicle.Top_Speed"" and ""vehicle.Power"". 2. Condition Structure: Use a WHERE clause to filter vehicles manufactured in the year 1996 by checking ""vehicle.Build_Year"". 3. Join Structure: No JOIN is required since all necessary data is within the ""vehicle"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields for vehicles manufactured in 1996.",1.0
99,What are the names of products that have a price above the average for all products.,NESTED,customers_and_orders,"[Products.product_name, Products.product_price]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT product_name FROM Products WHERE product_price > (SELECT AVG(product_price) FROM Products);,SELECT product_name FROM Products WHERE product_price  >  (SELECT avg(product_price) FROM Products),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of products. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter products whose price is above the average price of all products. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average price of all products and filter products whose price is greater than this value. 3. Join Structure: Not required, as all data is in the Products table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average price of all products, which is then used in the filtering condition.",1.0
100,Please show the first names of the students that have at least two answer records.,NON-NESTED,online_exams,"[Students.First_Name, Student_Answers.Student_ID, Students.Student_ID = Student_Answers.Student_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Students.First_Name FROM Students JOIN Student_Answers ON Students.Student_ID = Student_Answers.Student_ID GROUP BY Students.Student_ID HAVING COUNT(Student_Answers.Student_ID) >= 2;,SELECT T2.First_Name FROM Student_Answers AS T1 JOIN Students AS T2 ON T1.Student_ID  =  T2.Student_ID GROUP BY T1.Student_ID HAVING COUNT(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.First_Name."" 2. Condition Structure: Use a HAVING clause to filter for students who have at least two answer records. This requires counting the number of records in the ""Student_Answers"" table for each student. 3. Join Structure: Use an INNER JOIN between the ""Students"" table and the ""Student_Answers"" table on the ""Student_ID"" field to associate each student with their answer records. 4. Aggregation Structure: Use COUNT on ""Student_Answers.Student_ID"" to count the number of answer records for each student, then filter with HAVING to select students with at least two records.",1.0
101,List the dates of the orders which were placed at the earliest time or have more than 1 items.,NESTED,e_commerce,"[Orders.date_order_placed,Order_Items.order_id,Orders.order_id = Order_Items.order_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT DISTINCT Orders.date_order_placed FROM Orders JOIN Order_Items ON Orders.order_id = Order_Items.order_id WHERE Orders.date_order_placed = (SELECT MIN(date_order_placed) FROM Orders) OR Orders.order_id IN ( SELECT order_id FROM Order_Items GROUP BY order_id HAVING COUNT(order_id) > 1 );,SELECT min(date_order_placed) FROM Orders UNION SELECT T1.date_order_placed FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id HAVING count(*)  >  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the dates of the orders. Use the FROM clause to specify the Orders table. Join it with the Order_Items table to access the number of items in each order. Use a WHERE clause to filter for orders placed at the earliest time or orders with more than one item. 2. Condition Structure: Use the WHERE clause with two conditions: one to find the earliest order date using a subquery that retrieves the minimum date from the Orders table, and another to find orders with more than one item by grouping the Order_Items table by order_id and using the HAVING clause to count items. 3. Join Structure: Use an INNER JOIN between the Orders and Order_Items tables based on the order_id to connect orders with their items. 4. Aggregation Structure: Use COUNT in the HAVING clause to filter orders with more than one item. Use MIN in a subquery to find the earliest order date.",1.0
102,Show all product type codes and the average price for each type.,EASY,customers_and_orders,"[Products.product_type_code, Products.product_price]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_type_code, AVG(Products.product_price) AS avg_price FROM Products GROUP BY Products.product_type_code;","SELECT product_type_code ,  avg(product_price) FROM Products GROUP BY product_type_code","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the product type code and the average price. 2. Aggregation Structure: Use the AVG function to calculate the average price for each product type code. 3. Grouping Structure: Use GROUP BY on ""Products.product_type_code"" to calculate the average price for each type code. 4. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table.",1.0
103,What are all the order status and all the dates of orders?,EASY,e_commerce,"[Orders.order_status_code, Orders.date_order_placed]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Orders.order_status_code, Orders.date_order_placed FROM Orders;","SELECT order_status_code ,  date_order_placed FROM Orders","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Orders.order_status_code"" and ""Orders.date_order_placed"". 2. Condition Structure: No specific filtering condition is required as the query asks for all order statuses and dates of orders. 3. Join Structure: No JOIN is required since all necessary data is within the ""Orders"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all records without summarization.",1.0
104,What are the models which have not been driven by any drivers?,NESTED,vehicle_driver,"[vehicle.Model, vehicle.Vehicle_ID, vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT vehicle.Model FROM vehicle WHERE vehicle.Vehicle_ID NOT IN (SELECT Vehicle_ID FROM vehicle_driver);,SELECT model FROM vehicle EXCEPT SELECT T1.model FROM vehicle AS T1 JOIN vehicle_driver AS T2 ON T1.vehicle_id  =  T2.vehicle_id,"1. Sequential Structure: Start with the SELECT clause to retrieve the models of vehicles. Use the FROM clause to specify the vehicle table. Apply a WHERE clause to filter for vehicles that have not been driven by any drivers by ensuring that their Vehicle_ID is not present in the vehicle_driver table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude vehicles whose Vehicle_ID appears in the vehicle_driver table, meaning they have been driven by drivers. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Vehicle_ID entries in the vehicle_driver table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
105,Show the country of players with earnings more than 1400000 and players with earnings less than 1100000.,NESTED,soccer_3,"[player.Country,player.Earnings,1400000,1100000]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT player.Country FROM player WHERE player.Earnings > 1400000 OR player.Earnings < 1100000;,SELECT Country FROM player WHERE Earnings  >  1400000 INTERSECT SELECT Country FROM player WHERE Earnings  <  1100000,"1. Sequential Structure: Start with the SELECT clause to retrieve the country of players. Use the FROM clause to specify the player table. Apply a WHERE clause to filter players based on their earnings, specifically those earning more than 1,400,000 or less than 1,100,000. 2. Condition Structure: Use the WHERE clause with conditions to filter for players whose earnings are either greater than 1,400,000 or less than 1,100,000. 3. Join Structure: Not required, as all data is available within the player table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
106,Show the different affiliations of city channels and the number of city channels with each affiliation.,EASY,tv_shows,"[city_channel.Affiliation, city_channel.ID]","Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
","SELECT city_channel.Affiliation, COUNT(city_channel.ID) AS channel_count FROM city_channel GROUP BY city_channel.Affiliation;","SELECT Affiliation ,  COUNT(*) FROM city_channel GROUP BY Affiliation","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the ""city_channel.Affiliation"" and the count of city channels for each affiliation. 2. Aggregation Structure: Use COUNT to calculate the number of city channels for each affiliation. 3. Grouping Structure: Use GROUP BY on ""city_channel.Affiliation"" to aggregate the results by each affiliation. 4. Join Structure: No JOIN is required since all necessary data is within the ""city_channel"" table.",1.0
107,"Which student answer texts were given both ""Normal"" and ""Absent"" as comments?",NESTED,online_exams,"[Student_Answers.Student_Answer_Text, Student_Answers.Comments]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Student_Answer_Text FROM Student_Answers WHERE Comments IN ('Normal', 'Absent') GROUP BY Student_Answer_Text HAVING COUNT(DISTINCT Comments) = 2;","SELECT Student_Answer_Text FROM Student_Answers WHERE Comments  =  ""Normal"" INTERSECT SELECT Student_Answer_Text FROM Student_Answers WHERE Comments  =  ""Absent""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student_Answer_Text"" field from the ""Student_Answers"" table. Use the FROM clause to specify the ""Student_Answers"" table. Apply a WHERE clause to filter for answer texts that have both ""Normal"" and ""Absent"" as comments. 2. Condition Structure: Use the WHERE clause with a subquery to identify ""Student_Answer_Text"" entries that have both ""Normal"" and ""Absent"" in the ""Comments"" field. Use a GROUP BY clause to group by ""Student_Answer_Text"" and a HAVING clause to ensure both comments exist for the same answer text. 3. Join Structure: Not required, as all data is in the ""Student_Answers"" table. 4. Aggregation Structure: Use COUNT(DISTINCT Comments) in the HAVING clause to ensure that both ""Normal"" and ""Absent"" comments are associated with the same ""Student_Answer_Text"".",1.0
108,Which orders have at least 2 products on it? List the order id and date.,NON-NESTED,e_commerce,"[Orders.order_id, Orders.date_order_placed, Order_Items.order_id, Order_Items.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Orders.order_id, Orders.date_order_placed FROM Orders JOIN Order_Items ON Orders.order_id = Order_Items.order_id GROUP BY Orders.order_id, Orders.date_order_placed HAVING COUNT(Order_Items.product_id) >= 2;","SELECT T1.order_id ,  T1.date_order_placed FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id HAVING count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve ""Orders.order_id"" and ""Orders.date_order_placed."" 2. Condition Structure: Use a HAVING clause to filter for orders that have at least 2 products. This requires counting the number of products per order. 3. Join Structure: Use a JOIN between the ""Orders"" and ""Order_Items"" tables based on ""order_id"" to associate each order with its products. 4. Aggregation Structure: Use COUNT on ""Order_Items.product_id"" to count the number of products per order, then filter with HAVING to select orders with at least 2 products.",1.0
109,Return the average price of Clothes.,EASY,customers_and_orders,"[Products.product_price, Products.product_type_code, Products.product_type_code = 'Clothes']","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT AVG(Products.product_price) AS average_price FROM Products WHERE Products.product_type_code = 'Clothes';,"SELECT avg(product_price) FROM Products WHERE product_type_code  =  ""Clothes""","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average price. 2. Condition Structure: Use a WHERE clause to filter for products where the ""Products.product_type_code"" is 'Clothes'. 3. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table. 4. Aggregation Structure: Use the AVG function to calculate the average price of the filtered products.",1.0
110,What are the names of players from the club managed by Sam Allardyce?,NON-NESTED,soccer_3,"[player.Name,club.Manager,player.Club_ID = club.Club_ID,Sam Allardyce]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT player.Name FROM player JOIN club ON player.Club_ID = club.Club_ID WHERE club.Manager = 'Sam Allardyce';,"SELECT T2.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T1.Manager  =  ""Sam Allardyce""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""player.Name"" field, as the question asks for the names of players. 2. Condition Structure: Use a WHERE clause to filter for the club managed by ""Sam Allardyce."" 3. Join Structure: Use a JOIN between the ""player"" and ""club"" tables based on the shared key ""player.Club_ID = club.Club_ID"" to associate players with their respective clubs. 4. Aggregation Structure: No aggregation is needed, as the query only requires listing player names.",1.0
111,List the first names of the students who do not have any answers.,NESTED,online_exams,"[Students.First_Name,Student_Answers.Student_ID,Students.Student_ID = Student_Answers.Student_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Students.First_Name FROM Students WHERE Students.Student_ID NOT IN (SELECT Student_ID FROM Student_Answers);,SELECT First_Name FROM Students WHERE Student_ID NOT IN (SELECT Student_ID FROM Student_Answers),"1. Sequential Structure: Start with the SELECT clause to retrieve the first names of students. Use the FROM clause to specify the Students table. Apply a WHERE clause to filter students who do not have any answers by ensuring their Student_ID is not present in the Student_Answers table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose Student_ID appears in the Student_Answers table, meaning they have provided answers. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Student_ID entries in the Student_Answers table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
112,What is the average price of the products being ordered?,NON-NESTED,e_commerce,"[Products.product_price, Order_Items.product_id, Order_Items.order_id = Orders.order_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT AVG(Products.product_price) FROM Products JOIN Order_Items ON Products.product_id = Order_Items.product_id JOIN Orders ON Order_Items.order_id = Orders.order_id;,SELECT avg(T1.product_price) FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id,"1. Sequential Structure: Start with the SELECT clause to calculate the average price of the products being ordered. Use the AVG function on ""Products.product_price."" 2. Condition Structure: No specific filtering condition is required, as the question asks for the average price of all products being ordered. 3. Join Structure: Use JOINs to connect the ""Products"" table with the ""Order_Items"" table on ""Order_Items.product_id"" and then connect the ""Order_Items"" table with the ""Orders"" table on ""Order_Items.order_id = Orders.order_id"" to ensure we are considering only the products that are part of orders. 4. Aggregation Structure: Use the AVG function to compute the average price of the products being ordered.",1.0
113,What are invoices status of all the orders which have not been shipped?,NESTED,e_commerce,"[Invoices.invoice_status_code,Orders.order_id,Shipments.order_id = Orders.order_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT Invoices.invoice_status_code FROM Invoices JOIN Orders ON Invoices.order_id = Orders.order_id WHERE Orders.order_id NOT IN (SELECT order_id FROM Shipments);,SELECT invoice_status_code FROM Invoices WHERE invoice_number NOT IN ( SELECT invoice_number FROM Shipments ),"1. Sequential Structure: Start with the SELECT clause to retrieve the invoice status codes. Use the FROM clause to specify the Invoices and Orders tables. Join the Orders table with the Shipments table to identify orders that have not been shipped. Apply a WHERE clause to filter for orders that are not present in the Shipments table. 2. Condition Structure: Use the WHERE clause with a subquery to filter orders that do not have a corresponding entry in the Shipments table, indicating they have not been shipped. 3. Join Structure: Use a JOIN between the Orders and Shipments tables based on the order_id to identify orders and their shipping status. Then, link the Invoices table to the Orders table to retrieve the invoice status codes. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
114,How many products are there for each product type?,EASY,customers_and_orders,"[Products.product_id, Products.product_type_code]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_type_code, COUNT(Products.product_id) AS product_count FROM Products GROUP BY Products.product_type_code;","SELECT product_type_code ,  count(*) FROM Products GROUP BY product_type_code","1. Sequential Structure: Start with the SELECT clause to specify the product type and the count of products for each type. 2. Aggregation Structure: Use COUNT to calculate the number of products for each product type. 3. Grouping Structure: Use GROUP BY on ""Products.product_type_code"" to group the results by each product type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table.",1.0
115,What is the average price of products for each product type?,EASY,customers_and_orders,"[Products.product_price, Products.product_type_code]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_type_code, AVG(Products.product_price) AS avg_price FROM Products GROUP BY Products.product_type_code;","SELECT product_type_code ,  avg(product_price) FROM Products GROUP BY product_type_code","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the product type and the average price. 2. Aggregation Structure: Use the AVG function to calculate the average price for each product type. 3. Grouping Structure: Use GROUP BY on ""Products.product_type_code"" to calculate the average price for each product type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table.",1.0
116,"What are the email address, town and county of the customers who are of the least common gender?",NESTED,e_commerce,"[Customers.gender_code, Customers.email_address, Customers.town_city, Customers.county]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT email_address, town_city, county FROM Customers WHERE gender_code = ( SELECT gender_code FROM Customers GROUP BY gender_code ORDER BY COUNT(*) ASC LIMIT 1 );","SELECT email_address ,  town_city ,  county FROM Customers WHERE gender_code  =  ( SELECT gender_code FROM Customers GROUP BY gender_code ORDER BY count(*) ASC LIMIT 1 )","1. Sequential Structure: Start with the SELECT clause to retrieve the email address, town, and county of customers. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter customers based on the least common gender. 2. Condition Structure: Use a subquery in the WHERE clause to determine the least common gender by counting occurrences of each gender in the Customers table and selecting the one with the minimum count. 3. Join Structure: Not required, as all data is available within the Customers table. 4. Aggregation Structure: Use COUNT to calculate the frequency of each gender and MIN to identify the least common gender.",1.0
117,How many different payment methods are there?,EASY,e_commerce,[Customer_Payment_Methods.payment_method_code],"Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT COUNT(DISTINCT Customer_Payment_Methods.payment_method_code) FROM Customer_Payment_Methods;,SELECT count(DISTINCT Payment_method_code) FROM Customer_Payment_Methods,"1. Sequential Structure: Begin with the SELECT clause to count the distinct payment methods. 2. Condition Structure: No specific filtering condition is required as we want to count all distinct payment methods. 3. Join Structure: No JOIN is necessary since all required data is within the ""Customer_Payment_Methods"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Customer_Payment_Methods.payment_method_code"" to count the unique payment methods.",1.0
118,How many different customers have ordered things?,NON-NESTED,e_commerce,"[Orders.customer_id,Customers.customer_id = Orders.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT COUNT(DISTINCT Orders.customer_id) FROM Orders;,SELECT count(DISTINCT customer_id) FROM Orders,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""Orders.customer_id"" to determine the number of unique customers who have placed orders. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all customers who have placed orders. 3. Join Structure: No JOIN is necessary since the required information is available in the ""Orders"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Orders.customer_id"" to count the number of unique customers.",1.0
119,"List the id, first name and last name of the customers who both have placed more than 2 orders and have bought at least 3 items.",NESTED,e_commerce,"[Customers.customer_id,Customers.customer_first_name,Customers.customer_last_name,Orders.customer_id,Orders.order_id,Order_Items.order_id,Order_Items.order_item_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.customer_id, Customers.customer_first_name, Customers.customer_last_name FROM Customers JOIN Orders ON Customers.customer_id = Orders.customer_id JOIN Order_Items ON Orders.order_id = Order_Items.order_id GROUP BY Customers.customer_id, Customers.customer_first_name, Customers.customer_last_name HAVING COUNT(DISTINCT Orders.order_id) > 2 AND COUNT(Order_Items.order_item_id) >= 3;","SELECT T1.customer_id ,  T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >  2 INTERSECT SELECT T1.customer_id ,  T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id GROUP BY T1.customer_id HAVING count(*)  >= 3","1. Sequential Structure: Start with the SELECT clause to retrieve the customer ID, first name, and last name. Use the FROM clause to specify the Customers table. Join it with the Orders table to link customers with their orders, and then join the Orders table with the Order_Items table to link orders with their items. Use GROUP BY to group data by customer ID, first name, and last name. Apply HAVING clauses to filter customers who have placed more than 2 orders and have bought at least 3 items. 2. Condition Structure: Use HAVING clauses to filter customers who meet both conditions: more than 2 orders and at least 3 items. 3. Join Structure: Use INNER JOINs between Customers and Orders on customer_id, and between Orders and Order_Items on order_id to connect customers, their orders, and the items in those orders. 4. Aggregation Structure: Use COUNT to calculate the number of orders and the number of items for each customer, and apply conditions in the HAVING clause to filter the results.",0.0
120,Count the number of clubs.,EASY,soccer_3,[club.Club_ID],"Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT COUNT(club.Club_ID) AS club_count FROM club;,SELECT count(*) FROM club,"1. Sequential Structure: Start with the SELECT clause to count the number of clubs. 2. Aggregation Structure: Use the COUNT function to count the unique ""club.Club_ID"" values, as each club is uniquely identified by its ID. 3. Join Structure: No JOIN is required since all necessary information is in the ""club"" table. 4. Condition Structure: No specific filtering condition is needed, as we are counting all clubs.",1.0
121,What is the model of the vehicle with maximum top speed whose power is higher than 6000?,NESTED,vehicle_driver,"[vehicle.Model, vehicle.Top_Speed, vehicle.Power]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT Model FROM vehicle WHERE Power > 6000 AND Top_Speed = (SELECT MAX(Top_Speed) FROM vehicle WHERE Power > 6000);,SELECT model FROM vehicle WHERE power  >  6000 ORDER BY top_speed DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the model of the vehicle. Use the FROM clause to specify the vehicle table. Apply a WHERE clause to filter vehicles with power greater than 6000. Use a subquery in the WHERE clause to find the vehicle with the maximum top speed among those that meet the power condition. 2. Condition Structure: Use the WHERE clause to filter for vehicles with power greater than 6000 and top speed equal to the maximum top speed among these vehicles. 3. Join Structure: Not required, as all data is in the vehicle table. 4. Aggregation Structure: Use MAX in a subquery to find the maximum top speed of vehicles with power greater than 6000.",1.0
122,"Which students identify their gender as ""F"" or ""M""? Give me their last names.",EASY,online_exams,"[Students.Last_Name, Students.Gender_MFU]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Students.Last_Name FROM Students WHERE Students.Gender_MFU IN ('F', 'M');","SELECT Last_Name FROM Students WHERE Gender_MFU  =  ""F"" OR Gender_MFU  =  ""M""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.Last_Name"" of students who identify their gender as ""F"" or ""M"". 2. Condition Structure: Use a WHERE clause to filter for students whose ""Students.Gender_MFU"" is either ""F"" or ""M"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Students"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving last names based on a specific condition.",1.0
123,What are the sizes of all products whose name includes the word 'Dell'?,EASY,e_commerce,"[Products.product_name, Products.product_size]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT Products.product_size FROM Products WHERE Products.product_name LIKE '%Dell%';,SELECT product_size FROM Products WHERE product_name LIKE '%Dell%',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Products.product_size"" for products whose name includes the word 'Dell'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for product names that contain the word 'Dell'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Products"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the sizes of products that meet the specified condition.",1.0
124,What are the earnings of players from either of the countries of Australia or Zimbabwe?,EASY,soccer_3,"[player.Earnings, player.Country]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT player.Earnings FROM player WHERE player.Country = 'Australia' OR player.Country = 'Zimbabwe';,"SELECT Earnings FROM player WHERE Country  =  ""Australia"" OR Country  =  ""Zimbabwe""","1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the earnings of players. 2. Condition Structure: Use a WHERE clause to filter players whose country is either Australia or Zimbabwe. 3. Join Structure: No JOIN is required since all necessary data is within the ""player"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the earnings of players from the specified countries.",1.0
125,Show the transmitters of radios and the station names of the channels they are associated with in descending order of the ERP of the radios.,NON-NESTED,tv_shows,"[radio.Transmitter, radio.ERP_kW, city_channel.Station_name, city_channel_radio.Radio_ID = radio.Radio_ID, city_channel_radio.City_channel_ID = city_channel.ID]","Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
","SELECT radio.Transmitter, city_channel.Station_name FROM radio JOIN city_channel_radio ON city_channel_radio.Radio_ID = radio.Radio_ID JOIN city_channel ON city_channel_radio.City_channel_ID = city_channel.ID ORDER BY radio.ERP_kW DESC;","SELECT T3.Transmitter ,  T2.Station_name FROM city_channel_radio AS T1 JOIN city_channel AS T2 ON T1.City_channel_ID  =  T2.ID JOIN radio AS T3 ON T1.Radio_ID  =  T3.Radio_ID ORDER BY T3.ERP_kW DESC","1. Sequential Structure: Start with the SELECT clause to retrieve ""radio.Transmitter"" and ""city_channel.Station_name."" Additionally, include ""radio.ERP_kW"" for ordering purposes. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""radio"" table with the ""city_channel_radio"" table on ""radio.Radio_ID"" and then connect ""city_channel_radio"" with the ""city_channel"" table on ""city_channel_radio.City_channel_ID = city_channel.ID"" to associate radios with their respective channels. 4. Aggregation Structure: No aggregation is required, but use ORDER BY in descending order of ""radio.ERP_kW"" to sort the results as specified.",1.0
126,List all program titles in the order of starting year. List the most recent one first.,EASY,bbc_channels,"[program.Title, program.Start_Year]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
",SELECT program.Title FROM program ORDER BY program.Start_Year DESC;,SELECT title FROM program ORDER BY start_year DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the program title. 2. Condition Structure: No specific filtering condition is required as we want all program titles. 3. Ordering Structure: Use ORDER BY on ""program.Start_Year"" in descending order to list the most recent program first. 4. Join Structure: No JOIN is required since all necessary data is within the ""program"" table. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the program titles.",1.0
127,"What are the names of all Hardware products, sorted by price ascending?",EASY,customers_and_orders,"[Products.product_name, Products.product_price, Products.product_type_code]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_name, Products.product_price FROM Products WHERE Products.product_type_code = 'Hardware' ORDER BY Products.product_price ASC;","SELECT product_name FROM Products WHERE product_type_code  =  ""Hardware"" ORDER BY product_price ASC","1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the product name. Additionally, include the product price for sorting purposes. 2. Condition Structure: Use a WHERE clause to filter for products where the ""Products.product_type_code"" corresponds to Hardware. 3. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""Products.product_price"" in ascending order to sort the results.",1.0
128,Count the number of drivers who have raced in NASCAR.,EASY,vehicle_driver,"[driver.Driver_ID,driver.Racing_Series,NASCAR]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT COUNT(driver.Driver_ID) FROM driver WHERE driver.Racing_Series = 'NASCAR';,SELECT count(*) FROM driver WHERE Racing_Series  =  'NASCAR',"1. Sequential Structure: Start with the SELECT clause to count the number of drivers who have raced in NASCAR. 2. Condition Structure: Use a WHERE clause to filter for drivers whose ""Racing_Series"" is 'NASCAR'. 3. Join Structure: No JOIN is required since all necessary information is in the ""driver"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of drivers meeting the specified condition.",1.0
129,"What are the ids, names, and prices of all products that are ordered most frequently?",NESTED,e_commerce,"[Products.product_id, Products.product_name, Products.product_price, Order_Items.product_id, Order_Items.order_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Products.product_id, Products.product_name, Products.product_price FROM Products JOIN Order_Items ON Products.product_id = Order_Items.product_id GROUP BY Products.product_id, Products.product_name, Products.product_price ORDER BY COUNT(Order_Items.order_id) DESC;","SELECT T1.product_id ,  T1.product_name ,  T1.product_price FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id GROUP BY T1.product_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the product IDs, names, and prices. Use the FROM clause to specify the Products table and JOIN it with the Order_Items table to link products with their order frequency. Use GROUP BY to group records by product_id, allowing us to count the frequency of orders for each product. Use ORDER BY to sort the products by their order frequency in descending order and LIMIT to retrieve the most frequently ordered products. 2. Condition Structure: No specific filtering condition is required, as we are interested in the most frequently ordered products. 3. Join Structure: Use an INNER JOIN between the Products and Order_Items tables based on product_id to connect product details with their order frequency. 4. Aggregation Structure: Use COUNT(*) to calculate the frequency of orders for each product and sort by this count in descending order to identify the most frequently ordered products.",1.0
130,What is the most uncommon order status?,EASY,e_commerce,[Orders.order_status_code],"Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT Orders.order_status_code FROM Orders GROUP BY Orders.order_status_code ORDER BY COUNT(*) ASC LIMIT 1;,SELECT order_status_code FROM Orders GROUP BY order_status_code ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the order status code, as the question asks for the most uncommon order status. 2. Aggregation Structure: Use COUNT to calculate the frequency of each order status code. 3. Grouping Structure: Use GROUP BY on ""Orders.order_status_code"" to group the results by each order status code. 4. Ordering Structure: Use ORDER BY in ascending order on the count to rank the order statuses by their frequency, with the least common status appearing first. 5. Limiting Structure: Use LIMIT 1 to retrieve only the most uncommon order status. 6. Join Structure: No JOIN is required since all necessary data is within the ""Orders"" table.",1.0
131,"What is the name of the director who is in the ""Dracula"" program?",NON-NESTED,bbc_channels,"[program.Title, program.Director_ID, director.Name, program.Director_ID = director.Director_ID, Dracula]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
",SELECT director.Name FROM program JOIN director ON program.Director_ID = director.Director_ID WHERE program.Title = 'Dracula';,SELECT t2.name FROM program AS t1 JOIN director AS t2 ON t1.director_id  =  t2.director_id WHERE t1.title  =  'Dracula',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""director.Name."" 2. Condition Structure: Use a WHERE clause to filter for the program with the title ""Dracula."" 3. Join Structure: Use a JOIN between the ""program"" and ""director"" tables based on the relationship ""program.Director_ID = director.Director_ID"" to link each program with its respective director. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single director's name.",1.0
132,Count the number of products of the type Hardware.,EASY,customers_and_orders,"[Products.product_type_code, Products.product_id, Products.product_name]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(Products.product_id) FROM Products WHERE Products.product_type_code = 'Hardware';,"SELECT count(*) FROM Products WHERE product_type_code  =  ""Hardware""","1. Sequential Structure: Start with the SELECT clause to count the number of products. 2. Condition Structure: Use a WHERE clause to filter products of the type ""Hardware."" 3. Join Structure: No JOIN is required since all necessary information is in the ""Products"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of products that meet the specified condition.",1.0
133,Give me an alphabetically ordered list of the distinct subject code for exams.,EASY,online_exams,[Exams.Subject_Code],"Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT DISTINCT Exams.Subject_Code FROM Exams ORDER BY Exams.Subject_Code ASC;,SELECT DISTINCT Subject_Code FROM Exams ORDER BY Subject_Code,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct subject codes from the ""Exams"" table. 2. Condition Structure: No specific filtering condition is required as we want all distinct subject codes. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Exams"" table. 4. Aggregation Structure: No aggregation is needed, but use DISTINCT to ensure unique subject codes are retrieved. 5. Ordering Structure: Use ORDER BY to sort the distinct subject codes alphabetically.",1.0
134,Return the names of directors who are older than the average age.,NESTED,bbc_channels,"[director.Name, director.Age]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
",SELECT Name FROM director WHERE Age > (SELECT AVG(Age) FROM director);,SELECT name FROM director WHERE age  >  (SELECT avg(age) FROM director),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of directors. Use the FROM clause to specify the director table. Apply a WHERE clause to filter directors whose age is greater than the average age of all directors. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average age of all directors and filter for directors older than this average. 3. Join Structure: Not required, as all data is in the director table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average age of all directors, which is then used in the filtering condition.",1.0
135,"For the orders with any produts, how many products does each orders contain ? List the order id, status and the number.",NON-NESTED,e_commerce,"[Orders.order_id, Orders.order_status_code, Order_Items.order_id = Orders.order_id, Order_Items.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Orders.order_id, Orders.order_status_code, COUNT(Order_Items.product_id) AS number_of_products FROM Orders JOIN Order_Items ON Orders.order_id = Order_Items.order_id GROUP BY Orders.order_id, Orders.order_status_code;","SELECT T1.order_id ,  T1.order_status_code ,  count(*) FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Orders.order_id,"" ""Orders.order_status_code,"" and the count of products in each order. Use COUNT on ""Order_Items.product_id"" to calculate the number of products per order. 2. Condition Structure: No specific filtering condition is required, as we are interested in all orders with products. 3. Join Structure: Use an INNER JOIN between ""Orders"" and ""Order_Items"" on ""Orders.order_id = Order_Items.order_id"" to link orders with their respective products. 4. Aggregation Structure: Use COUNT on ""Order_Items.product_id"" to count the number of products per order, and GROUP BY ""Orders.order_id"" and ""Orders.order_status_code"" to group results by each order and its status.",1.0
136,Count the number of products.,EASY,customers_and_orders,[Products.product_id],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(Products.product_id) AS product_count FROM Products;,SELECT count(*) FROM Products,"1. Sequential Structure: Start with the SELECT clause to count the number of products. 2. Aggregation Structure: Use the COUNT function on ""Products.product_id"" to calculate the total number of products. 3. Condition Structure: No specific filtering condition is required as we want the total count of all products. 4. Join Structure: No JOIN is necessary since all required data is within the ""Products"" table.",1.0
137,"List the last names of the students whose gender is not ""M"".",EASY,online_exams,"[Students.Last_Name, Students.Gender_MFU]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Students.Last_Name FROM Students WHERE Students.Gender_MFU != 'M';,"SELECT Last_Name FROM Students WHERE Gender_MFU != ""M""","1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is ""Students.Last_Name"". 2. Condition Structure: Use a WHERE clause to filter students whose gender is not ""M"". 3. Join Structure: No JOIN is required since all necessary data is within the ""Students"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the last names of students based on a specific condition.",1.0
138,How many item states are there in the orders?,EASY,e_commerce,[Order_Items.order_item_status_code],"Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT COUNT(DISTINCT Order_Items.order_item_status_code) AS item_state_count FROM Order_Items;,SELECT count(DISTINCT order_item_status_code) FROM Order_items,"1. Sequential Structure: Begin with the SELECT clause to count the distinct item states in the orders. 2. Aggregation Structure: Use COUNT with DISTINCT to calculate the number of unique ""order_item_status_code"" values. 3. Join Structure: No JOIN is required since all necessary data is within the ""Order_Items"" table. 4. Condition Structure: No specific filtering condition is needed as we are counting all unique item states.",1.0
139,"List the name of clubs whose manufacturer is not ""Nike""",EASY,soccer_3,"[club.Name, club.Manufacturer]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT club.Name FROM club WHERE club.Manufacturer != 'Nike';,"SELECT Name FROM club WHERE Manufacturer != ""Nike""","1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the name of the clubs. 2. Condition Structure: Use a WHERE clause to filter out clubs where the manufacturer is ""Nike"". 3. Join Structure: No JOIN is required since all necessary data is within the ""club"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of clubs that meet the specified condition.",1.0
140,How many number of products does each gender of customers buy? List the gender and the number,NON-NESTED,e_commerce,"[Customers.gender_code, Customers.customer_id, Orders.customer_id = Customers.customer_id, Order_Items.order_id = Orders.order_id, Order_Items.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.gender_code, COUNT(Order_Items.product_id) AS number_of_products FROM Customers JOIN Orders ON Customers.customer_id = Orders.customer_id JOIN Order_Items ON Orders.order_id = Order_Items.order_id GROUP BY Customers.gender_code;","SELECT T1.gender_code ,  count(*) FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id GROUP BY T1.gender_code","1. Sequential Structure: Start with the SELECT clause to retrieve ""Customers.gender_code"" and the count of ""Order_Items.product_id"" for each gender. Use COUNT to calculate the number of products bought. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Customers"" table with the ""Orders"" table on ""Customers.customer_id = Orders.customer_id"" and then connect the ""Orders"" table with the ""Order_Items"" table on ""Order_Items.order_id = Orders.order_id"" to link customers with their purchased products. 4. Aggregation Structure: Use COUNT to count the number of products bought by each gender and GROUP BY ""Customers.gender_code"" to group the results by gender.",1.0
141,"What are the total cost of all the orders ? List the order id , date , and total cost .",NON-NESTED,e_commerce,"[Orders.order_id, Orders.date_order_placed, Order_Items.order_id = Orders.order_id, Order_Items.product_id, Products.product_id = Order_Items.product_id, Products.product_price]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Orders.order_id, Orders.date_order_placed, SUM(Products.product_price) AS total_cost FROM Orders JOIN Order_Items ON Orders.order_id = Order_Items.order_id JOIN Products ON Order_Items.product_id = Products.product_id GROUP BY Orders.order_id, Orders.date_order_placed;","select t1.order_id ,  t1.date_order_placed ,  sum(t3.product_price) from orders as t1 join order_items as t2 on t1.order_id  =  t2.order_id join products as t3 on t2.product_id  =  t3.product_id group by t1.order_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Orders.order_id,"" ""Orders.date_order_placed,"" and the total cost of each order. The total cost will be calculated using the SUM function on the product prices from the ""Products"" table. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Orders"" table with the ""Order_Items"" table on ""Orders.order_id = Order_Items.order_id"" and the ""Order_Items"" table with the ""Products"" table on ""Products.product_id = Order_Items.product_id."" 4. Aggregation Structure: Use SUM to calculate the total cost of products for each order, and GROUP BY ""Orders.order_id"" and ""Orders.date_order_placed"" to group the results by each order.",1.0
142,Show all information on students.,EASY,online_exams,"[Students.Student_ID, Students.First_Name, Students.Middle_Name, Students.Last_Name, Students.Gender_MFU, Students.Student_Address, Students.Email_Adress, Students.Cell_Mobile_Phone, Students.Home_Phone]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT * FROM Students;,SELECT * FROM Students,"1. Sequential Structure: Start with the SELECT clause to retrieve all columns from the ""Students"" table, as the question asks for all information on students. 2. Condition Structure: No specific filtering condition is required since the query is meant to retrieve all student information. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Students"" table. 4. Aggregation Structure: No aggregation is needed as the query is simply retrieving all rows and columns from the table.",1.0
143,Show different manufacturers and the number of clubs they are associated with.,EASY,soccer_3,"[club.Manufacturer, club.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
","SELECT club.Manufacturer, COUNT(club.Club_ID) AS club_count FROM club GROUP BY club.Manufacturer;","SELECT Manufacturer ,  COUNT(*) FROM club GROUP BY Manufacturer","1. Sequential Structure: Begin with the SELECT clause to specify the manufacturer and the count of clubs they are associated with. 2. Aggregation Structure: Use COUNT to calculate the number of clubs associated with each manufacturer. 3. Grouping Structure: Use GROUP BY on ""club.Manufacturer"" to aggregate the results by each manufacturer. 4. Join Structure: No JOIN is required since all necessary data is within the ""club"" table.",1.0
144,"For each student answer, find the first name of the student and the date of the answer.",NON-NESTED,online_exams,"[Students.First_Name, Student_Answers.Date_of_Answer, Student_Answers.Student_ID = Students.Student_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Students.First_Name, Student_Answers.Date_of_Answer FROM Students JOIN Student_Answers ON Student_Answers.Student_ID = Students.Student_ID;","SELECT T2.First_Name ,  T1.Date_of_Answer FROM Student_Answers AS T1 JOIN Students AS T2 ON T1.Student_ID  =  T2.Student_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""Students.First_Name"" and ""Student_Answers.Date_of_Answer."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Students"" table and the ""Student_Answers"" table based on the relationship ""Student_Answers.Student_ID = Students.Student_ID"" to link each student with their answers. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the first name of each student and the date of their answers.",1.0
145,How many drivers have not driven any cars?,NESTED,vehicle_driver,"[driver.Driver_ID,vehicle_driver.Driver_ID,driver.Driver_ID = vehicle_driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT COUNT(*) FROM driver WHERE Driver_ID NOT IN (SELECT Driver_ID FROM vehicle_driver);,SELECT count(*) FROM driver WHERE driver_id NOT IN ( SELECT driver_id FROM vehicle_driver ),"1. Sequential Structure: Start with the SELECT clause to count the number of drivers. Use the FROM clause to specify the driver table. Apply a WHERE clause to filter drivers who have not driven any cars by ensuring their Driver_ID is not present in the vehicle_driver table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude drivers whose Driver_ID appears in the vehicle_driver table, meaning they have driven cars. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Driver_ID entries in the vehicle_driver table. 4. Aggregation Structure: Use COUNT to calculate the total number of drivers who meet the condition of not having driven any cars.",1.0
146,"What is the status code of the items have been ordered and shipped, and also what are their shipment tracking numbers?",NON-NESTED,e_commerce,"[Order_Items.order_item_status_code,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipments.shipment_tracking_number,Shipment_Items.shipment_id = Shipments.shipment_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Order_Items.order_item_status_code, Shipments.shipment_tracking_number FROM Order_Items JOIN Shipment_Items ON Shipment_Items.order_item_id = Order_Items.order_item_id JOIN Shipments ON Shipment_Items.shipment_id = Shipments.shipment_id;","SELECT T1.order_item_status_code ,  T3.shipment_tracking_number FROM Order_items AS T1 JOIN Shipment_Items AS T2 ON T1.order_item_id  =  T2.order_item_id JOIN Shipments AS T3 ON T2.shipment_id  =  T3.shipment_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Order_Items.order_item_status_code"" and ""Shipments.shipment_tracking_number."" 2. Condition Structure: Use a WHERE clause to filter for items that have been both ordered and shipped. This condition is implied by the relationships between the tables. 3. Join Structure: Use JOINs to connect ""Order_Items"" with ""Shipment_Items"" on ""order_item_id"" and ""Shipment_Items"" with ""Shipments"" on ""shipment_id"" to link the order items with their shipment tracking numbers. 4. Aggregation Structure: No aggregation is needed as the query is retrieving specific details for each item.",1.0
147,How many hardware type products do we have?,EASY,customers_and_orders,"[Products.product_id, Products.product_type_code, Products.product_name]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(*) FROM Products WHERE Products.product_type_code = 'hardware';,"SELECT count(*) FROM Products WHERE product_type_code  =  ""Hardware""","1. Sequential Structure: Begin with the SELECT clause to count the number of products of the hardware type. 2. Condition Structure: Use a WHERE clause to filter for products where the ""Products.product_type_code"" corresponds to hardware. 3. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of hardware type products.",0.0
148,"For each student answer, find the email address of the student and the date of the answer. Sort them in descending order of dates.",NON-NESTED,online_exams,"[Student_Answers.Student_ID, Students.Email_Adress, Student_Answers.Date_of_Answer, Student_Answers.Student_ID = Students.Student_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Students.Email_Adress, Student_Answers.Date_of_Answer FROM Student_Answers JOIN Students ON Student_Answers.Student_ID = Students.Student_ID ORDER BY Student_Answers.Date_of_Answer DESC;","SELECT T2.Email_Adress ,  T1.Date_of_Answer FROM Student_Answers AS T1 JOIN Students AS T2 ON T1.Student_ID  =  T2.Student_ID ORDER BY T1.Date_of_Answer DESC","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.Email_Adress"" and ""Student_Answers.Date_of_Answer."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Student_Answers"" and ""Students"" tables based on the relationship ""Student_Answers.Student_ID = Students.Student_ID"" to link each answer with the corresponding student's email address. 4. Aggregation Structure: No aggregation is required, but apply ORDER BY in descending order on ""Student_Answers.Date_of_Answer"" to sort the results by date.",1.0
149,What is the number of products that have not been ordered yet?,NESTED,e_commerce,"[Products.product_id,Order_Items.product_id,Products.product_id != Order_Items.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT COUNT(*) FROM Products WHERE product_id NOT IN (SELECT product_id FROM Order_Items);,SELECT count(*) FROM Products WHERE product_id NOT IN ( SELECT product_id FROM Order_items ),"1. Sequential Structure: Start with the SELECT clause to count the number of products. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter products that have not been ordered yet by ensuring their product_id is not present in the Order_Items table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude products whose product_id appears in the Order_Items table, meaning they have been ordered. 3. Join Structure: Not required, as we only need to filter based on the absence of matching product_id entries in the Order_Items table. 4. Aggregation Structure: Use COUNT to calculate the total number of products that meet the condition of not being ordered.",1.0
150,What are the product sizes of the products whose name has the substring 'Dell'?,EASY,e_commerce,"[Products.product_size, Products.product_name]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT Products.product_size FROM Products WHERE Products.product_name LIKE '%Dell%';,SELECT product_size FROM Products WHERE product_name LIKE '%Dell%',"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is ""Products.product_size"". 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for product names that contain the substring 'Dell'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Products"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving product sizes based on a specific condition.",1.0
151,How many vehicles have maximum top speed?,NESTED,vehicle_driver,"[vehicle.Top_Speed, vehicle.Vehicle_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT COUNT(Vehicle_ID) AS vehicle_count FROM vehicle WHERE Top_Speed = (SELECT MAX(Top_Speed) FROM vehicle);,SELECT count(*) FROM vehicle WHERE top_speed  =  (SELECT max(top_speed) FROM vehicle),"1. Sequential Structure: Start with the SELECT clause to count the number of vehicles. Use the FROM clause to specify the vehicle table. Apply a WHERE clause to filter for vehicles with the maximum top speed. 2. Condition Structure: Use the WHERE clause with a subquery to filter for vehicles whose top speed matches the maximum top speed. 3. Join Structure: Not required, as all data is in the vehicle table. 4. Aggregation Structure: Use MAX in a subquery to find the maximum top speed, and COUNT to count the number of vehicles with that top speed.",1.0
152,Find the name of the directors whose age is between 30 and 60.,EASY,bbc_channels,"[director.Name, director.Age]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
",SELECT director.Name FROM director WHERE director.Age BETWEEN 30 AND 60;,SELECT name FROM director WHERE age BETWEEN 30 AND 60,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""director.Name"". 2. Condition Structure: Use a WHERE clause to filter directors whose ""Age"" is between 30 and 60. 3. Join Structure: No JOIN is required since all necessary data is within the ""director"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.",1.0
153,Find the name and age of the director who is in charge of the most programs?,NON-NESTED,bbc_channels,"[director.Name, director.Age, program.Director_ID, program.Program_ID, program.Director_ID = director.Director_ID]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
","SELECT director.Name, director.Age FROM director JOIN program ON program.Director_ID = director.Director_ID GROUP BY director.Director_ID ORDER BY COUNT(program.Program_ID) DESC LIMIT 1;","SELECT t2.name ,  t2.age FROM program AS t1 JOIN director AS t2 ON t1.director_id  =  t2.director_id GROUP BY t1.director_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""director.Name"" and ""director.Age."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in the director who is in charge of the most programs. 3. Join Structure: Use a JOIN between the ""program"" and ""director"" tables based on ""program.Director_ID = director.Director_ID"" to associate each program with its respective director. 4. Aggregation Structure: Use COUNT on ""program.Program_ID"" to count the number of programs each director is in charge of. Use ORDER BY in descending order to rank directors by the number of programs, and LIMIT 1 to select the director with the most programs.",1.0
154,What is the name of the player with the highest earnings?,EASY,soccer_3,"[player.Name, player.Earnings]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT player.Name FROM player ORDER BY player.Earnings DESC LIMIT 1;,SELECT Name FROM player ORDER BY Earnings DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""player.Name"" of the player with the highest earnings. 2. Condition Structure: No specific filtering condition is needed since we are looking for the player with the maximum earnings. 3. Join Structure: No JOIN is required, as all necessary information is available in the ""player"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""player.Earnings"" to rank players by their earnings and apply LIMIT 1 to select the player with the highest earnings.",1.0
155,Show names of clubs that have players with more than 2 win counts.,NON-NESTED,soccer_3,"[club.Name, player.Wins_count, player.Club_ID = club.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT club.Name FROM club JOIN player ON player.Club_ID = club.Club_ID GROUP BY club.Name HAVING SUM(player.Wins_count) > 2;,SELECT T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T2.Wins_count  >  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""club.Name."" 2. Condition Structure: Use a HAVING clause to filter for clubs where the total win count of players is greater than 2. 3. Join Structure: Use a JOIN between the ""club"" and ""player"" tables based on ""player.Club_ID = club.Club_ID"" to associate players with their respective clubs. 4. Aggregation Structure: Use SUM on ""player.Wins_count"" to calculate the total win count for each club, then filter with HAVING to select clubs with more than 2 wins.",1.0
156,How many drivers have been racing in each racing series?,NON-NESTED,vehicle_driver,"[driver.Racing_Series, vehicle_driver.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT driver.Racing_Series, COUNT(driver.Driver_ID) AS Driver_Count FROM vehicle_driver JOIN driver ON vehicle_driver.Driver_ID = driver.Driver_ID GROUP BY driver.Racing_Series;","SELECT count(*) ,  racing_series FROM driver GROUP BY racing_series","1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Racing_Series"" and the count of drivers in each series. Use COUNT to count the number of drivers. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""vehicle_driver"" and ""driver"" tables based on ""vehicle_driver.Driver_ID = driver.Driver_ID"" to associate drivers with their respective racing series. 4. Aggregation Structure: Use COUNT to count the number of drivers in each racing series and GROUP BY ""driver.Racing_Series"" to group the results by each series.",0.0
157,How many orders has each gender of customers placed?,NON-NESTED,e_commerce,"[Customers.gender_code, Orders.customer_id, Customers.customer_id = Orders.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.gender_code, COUNT(Orders.customer_id) AS total_orders FROM Customers JOIN Orders ON Customers.customer_id = Orders.customer_id GROUP BY Customers.gender_code;","SELECT T1.gender_code ,  count(*) FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.gender_code","1. Sequential Structure: Start with the SELECT clause to retrieve the gender of customers and the count of orders placed by each gender. Use COUNT to count the number of orders and GROUP BY to group the results by gender. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""Customers"" table with the ""Orders"" table based on the shared ""customer_id"" field to associate each order with the corresponding customer. 4. Aggregation Structure: Use COUNT to calculate the total number of orders for each gender, grouped by ""Customers.gender_code.""",1.0
158,Show all product names with price higher than the average.,NESTED,customers_and_orders,"[Products.product_name, Products.product_price]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT product_name FROM Products WHERE product_price > (SELECT AVG(product_price) FROM Products);,SELECT product_name FROM Products WHERE product_price  >  (SELECT avg(product_price) FROM Products),"1. Sequential Structure: Start with the SELECT clause to retrieve product names. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter products with a price higher than the average price. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average product price and filter products whose price is greater than this value. 3. Join Structure: Not required, as all data is in the Products table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average product price, which is then used in the filtering condition.",1.0
159,How many products does each gender buy?,NON-NESTED,e_commerce,"[Customers.customer_id,Customers.gender_code,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.gender_code, COUNT(Order_Items.product_id) AS product_count FROM Customers JOIN Orders ON Customers.customer_id = Orders.customer_id JOIN Order_Items ON Orders.order_id = Order_Items.order_id GROUP BY Customers.gender_code;","SELECT T1.gender_code ,  count(*) FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id GROUP BY T1.gender_code","1. Sequential Structure: Start with the SELECT clause to retrieve the gender of customers and the count of products purchased by each gender. Use COUNT on ""Order_Items.product_id"" to count the number of products. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Customers"" table with ""Orders"" on ""customer_id,"" and then connect ""Orders"" with ""Order_Items"" on ""order_id"" to link customers with their purchased products. 4. Aggregation Structure: Use GROUP BY on ""Customers.gender_code"" to group the results by gender and calculate the count of products for each gender.",1.0
160,How many items are shipped?,NON-NESTED,e_commerce,"[Shipment_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT COUNT(Shipment_Items.order_item_id) FROM Shipment_Items;,SELECT count(*) FROM Shipment_Items,"1. Sequential Structure: Start with the SELECT clause to count the total number of items shipped. Use COUNT on ""Shipment_Items.order_item_id"" to determine the total number of items. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: No JOIN is required since the count of items can be directly obtained from the ""Shipment_Items"" table. 4. Aggregation Structure: Use COUNT to aggregate the total number of items shipped.",1.0
161,give me the name of channels that have both a director younger than 40 and a director older than 60.,NESTED,bbc_channels,"[channel.Name, director.Age, program.Channel_ID = channel.Channel_ID, program.Director_ID = director.Director_ID, director_admin.Channel_ID = channel.Channel_ID, director_admin.Director_ID = director.Director_ID]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
",SELECT channel.Name FROM channel WHERE EXISTS ( SELECT 1 FROM program JOIN director ON program.Director_ID = director.Director_ID WHERE program.Channel_ID = channel.Channel_ID AND director.Age < 40 ) AND EXISTS ( SELECT 1 FROM program JOIN director ON program.Director_ID = director.Director_ID WHERE program.Channel_ID = channel.Channel_ID AND director.Age > 60 );,SELECT t1.name FROM channel AS t1 JOIN director_admin AS t2 ON t1.channel_id  =  t2.channel_id JOIN director AS t3 ON t2.director_id  =  t3.director_id WHERE t3.age  <  40 INTERSECT SELECT t1.name FROM channel AS t1 JOIN director_admin AS t2 ON t1.channel_id  =  t2.channel_id JOIN director AS t3 ON t2.director_id  =  t3.director_id WHERE t3.age  >  60,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of channels. Use the FROM clause to specify the channel table. Join it with the program and director tables to connect channels with their directors. Use a WHERE clause to filter for channels that have at least one director younger than 40 and at least one director older than 60. 2. Condition Structure: Use the WHERE clause with EXISTS subqueries to ensure that a channel has at least one director younger than 40 and at least one director older than 60. 3. Join Structure: Use INNER JOINs between the channel, program, and director tables based on their respective relationships (program.Channel_ID = channel.Channel_ID and program.Director_ID = director.Director_ID). 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
162,Which car models have total production larger than 100 or top speed higher than 150?,EASY,vehicle_driver,"[vehicle.Model, vehicle.Total_Production, vehicle.Top_Speed, 100, 150]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT vehicle.Model FROM vehicle WHERE vehicle.Total_Production > 100 OR vehicle.Top_Speed > 150;,SELECT model FROM vehicle WHERE total_production  >  100 OR top_speed  >  150,"1. Sequential Structure: Start with the SELECT clause to specify the car models that meet the given conditions. 2. Condition Structure: Use a WHERE clause to filter for car models where ""vehicle.Total_Production"" is greater than 100 or ""vehicle.Top_Speed"" is higher than 150. 3. Join Structure: No JOIN is required since all necessary information is in the ""vehicle"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving car models that meet the specified conditions.",1.0
163,How many products have been shipped?,NON-NESTED,e_commerce,"[Shipment_Items.order_item_id,Order_Items.product_id,Shipment_Items.shipment_id = Shipments.shipment_id,Shipments.order_id = Orders.order_id,Order_Items.order_id = Orders.order_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT COUNT(DISTINCT Order_Items.product_id) FROM Shipment_Items JOIN Shipments ON Shipment_Items.shipment_id = Shipments.shipment_id JOIN Orders ON Shipments.order_id = Orders.order_id JOIN Order_Items ON Orders.order_id = Order_Items.order_id;,SELECT count(*) FROM Shipment_Items,"1. Sequential Structure: Start with the SELECT clause to count the number of distinct products that have been shipped. Use COUNT with DISTINCT on ""Order_Items.product_id"" to ensure unique products are counted. 2. Condition Structure: No specific filtering condition is required, as we are interested in all shipped products. 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""Shipment_Items"" with ""Shipments"" on ""shipment_id"" to link shipment items to shipments. Then, join ""Shipments"" with ""Orders"" on ""order_id"" to link shipments to orders. Finally, join ""Orders"" with ""Order_Items"" on ""order_id"" to link orders to products. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique products that have been shipped.",0.0
164,Show the types of questions that have at least three questions.,EASY,online_exams,"[Questions.Type_of_Question_Code, Questions.Question_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Questions.Type_of_Question_Code FROM Questions GROUP BY Questions.Type_of_Question_Code HAVING COUNT(Questions.Question_ID) >= 3;,SELECT Type_of_Question_Code FROM Questions GROUP BY Type_of_Question_Code HAVING count(*)  >=  3,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the type of question. 2. Aggregation Structure: Use COUNT to determine the number of questions for each type. 3. Grouping Structure: Use GROUP BY on ""Questions.Type_of_Question_Code"" to aggregate the results by each type of question. 4. Condition Structure: Apply the HAVING clause to filter for types of questions that have at least three questions, by setting the count to be greater than or equal to 3. 5. Join Structure: No JOIN is required since all necessary data is within the ""Questions"" table.",1.0
165,Return the names of drivers with citizenship from the United States.,EASY,vehicle_driver,"[driver.Name,driver.Citizenship]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT driver.Name FROM driver WHERE driver.Citizenship = 'United States';,SELECT name FROM driver WHERE citizenship  =  'United States',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Name"" of drivers with citizenship from the United States. 2. Condition Structure: Use a WHERE clause to filter for drivers whose ""driver.Citizenship"" is 'United States'. 3. Join Structure: No JOIN is required since all necessary information is in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.",1.0
166,How many exams are there?,EASY,online_exams,[Exams.Exam_ID],"Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT COUNT(Exams.Exam_ID) AS total_exams FROM Exams;,SELECT count(*) FROM Exams,"1. Sequential Structure: Begin with the SELECT clause to count the total number of exams. 2. Aggregation Structure: Use the COUNT function on the ""Exams.Exam_ID"" field to calculate the total number of exams. 3. Condition Structure: No specific filtering condition is required as we want the total count of all exams. 4. Join Structure: No JOIN is necessary since all required data is within the ""Exams"" table.",1.0
167,How many drivers have driven vehicles built in 2012?,NON-NESTED,vehicle_driver,"[driver.Driver_ID,vehicle.Build_Year,vehicle_driver.Driver_ID = driver.Driver_ID,vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,2012]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT COUNT(DISTINCT driver.Driver_ID) FROM vehicle_driver JOIN driver ON vehicle_driver.Driver_ID = driver.Driver_ID JOIN vehicle ON vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID WHERE vehicle.Build_Year = 2012;,SELECT count(DISTINCT T1.driver_id) FROM vehicle_driver AS T1 JOIN vehicle AS T2 ON T1.vehicle_id  =  T2.vehicle_id WHERE T2.build_year  =  2012,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""driver.Driver_ID"" who have driven vehicles built in 2012. 2. Condition Structure: Use a WHERE clause to filter for vehicles with ""vehicle.Build_Year"" equal to 2012. 3. Join Structure: Use JOINs to connect the ""vehicle_driver"" table with both ""driver"" and ""vehicle"" tables. Join ""vehicle_driver.Driver_ID"" with ""driver.Driver_ID"" and ""vehicle_driver.Vehicle_ID"" with ""vehicle.Vehicle_ID"" to link drivers with the vehicles they have driven. 4. Aggregation Structure: Use COUNT with DISTINCT on ""driver.Driver_ID"" to ensure unique drivers are counted.",1.0
168,"What are the distinct student answer texts that received comments ""Normal""?",EASY,online_exams,"[Student_Answers.Student_Answer_Text,Student_Answers.Comments]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT DISTINCT Student_Answers.Student_Answer_Text FROM Student_Answers WHERE Student_Answers.Comments = 'Normal';,"SELECT DISTINCT Student_Answer_Text FROM Student_Answers WHERE Comments  =  ""Normal""","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Student_Answers.Student_Answer_Text"" values. 2. Condition Structure: Use a WHERE clause to filter for rows where ""Student_Answers.Comments"" is equal to ""Normal"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Student_Answers"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving distinct values based on a specific condition.",1.0
169,"Return the names of players in order of count of wins, ascending.",EASY,soccer_3,"[player.Name, player.Wins_count]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT player.Name FROM player ORDER BY player.Wins_count ASC;,SELECT Name FROM player ORDER BY Wins_count ASC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""player.Name"" and the count of wins. 2. Condition Structure: No specific filtering condition is required as we want all players. 3. Join Structure: No JOIN is needed since all necessary information is available in the ""player"" table. 4. Aggregation Structure: Use ORDER BY to sort the results in ascending order based on ""player.Wins_count"".",1.0
170,"What are the last names of the students with gender other than ""M""?",EASY,online_exams,"[Students.Last_Name, Students.Gender_MFU]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Students.Last_Name FROM Students WHERE Students.Gender_MFU != 'M';,"SELECT Last_Name FROM Students WHERE Gender_MFU != ""M""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.Last_Name"" of students whose gender is not ""M"". 2. Condition Structure: Use a WHERE clause to filter records where ""Students.Gender_MFU"" is not equal to ""M"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Students"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving last names based on a specific condition.",1.0
171,"Give the build year, model, and builder of each vehicle.",EASY,vehicle_driver,"[vehicle.Build_Year, vehicle.Model, vehicle.Builder]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT vehicle.Build_Year, vehicle.Model, vehicle.Builder FROM vehicle;","SELECT build_year ,  model ,  builder FROM vehicle","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""vehicle.Build_Year,"" ""vehicle.Model,"" and ""vehicle.Builder."" 2. Condition Structure: No specific filtering condition is required as the query asks for all vehicles. 3. Join Structure: No JOIN is required since all necessary information is within the ""vehicle"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the specified fields for each vehicle.",1.0
172,"What are the names and dates of the exams with subject code that is not ""Database""?",EASY,online_exams,"[Exams.Exam_Name, Exams.Exam_Date, Exams.Subject_Code]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Exams.Exam_Name, Exams.Exam_Date FROM Exams WHERE Exams.Subject_Code != 'Database';","SELECT Exam_Date ,  Exam_Name FROM Exams WHERE Subject_Code != 'Database'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Exams.Exam_Name"" and ""Exams.Exam_Date"" fields. 2. Condition Structure: Use a WHERE clause to filter out exams where the ""Exams.Subject_Code"" is ""Database"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Exams"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and dates of exams that meet the specified condition.",1.0
173,What is the average ERP across all radios?,EASY,tv_shows,[radio.ERP_kW],"Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
",SELECT AVG(radio.ERP_kW) AS average_erp FROM radio;,SELECT avg(ERP_kW) FROM radio,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average ERP. 2. Aggregation Structure: Use the AVG function to calculate the average ERP across all radios. 3. Condition Structure: No specific filtering condition is required as the query asks for the average ERP across all radios. 4. Join Structure: No JOIN is required since all necessary data is within the ""radio"" table.",1.0
174,What are the ids and dates of the orders with at least two products?,NESTED,e_commerce,"[Orders.order_id, Orders.date_order_placed, Order_Items.order_id, Order_Items.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Orders.order_id, Orders.date_order_placed FROM Orders JOIN Order_Items ON Orders.order_id = Order_Items.order_id GROUP BY Orders.order_id, Orders.date_order_placed HAVING COUNT(Order_Items.product_id) >= 2;","SELECT T1.order_id ,  T1.date_order_placed FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id HAVING count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve the order IDs and dates of the orders. Use the FROM clause to specify the Orders table and JOIN it with the Order_Items table to link orders with their products. Apply a GROUP BY clause to group records by order_id and date_order_placed, allowing us to count the number of products in each order. Use the HAVING clause to filter orders with at least two products. 2. Condition Structure: Use the HAVING clause with COUNT(product_id) to filter for orders that have at least two products. 3. Join Structure: Use an INNER JOIN between the Orders and Order_Items tables based on order_id to connect orders with their associated products. 4. Aggregation Structure: Use COUNT(product_id) within the HAVING clause to count the number of products in each order and filter out orders with fewer than two products.",1.0
175,What are the names and colors of all products that have been shipped?,NON-NESTED,e_commerce,"[Products.product_name, Products.product_color, Shipment_Items.order_item_id = Order_Items.order_item_id, Order_Items.product_id = Products.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Products.product_name, Products.product_color FROM Products JOIN Order_Items ON Products.product_id = Order_Items.product_id JOIN Shipment_Items ON Shipment_Items.order_item_id = Order_Items.order_item_id;","SELECT T1.product_name ,  T1.product_color FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Shipment_Items AS T3 ON T2.order_item_id  =  T3.order_item_id JOIN Shipments AS T4 ON T3.shipment_id  =  T4.shipment_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Products.product_name"" and ""Products.product_color."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Products"" table with ""Order_Items"" on ""Products.product_id = Order_Items.product_id"" and then connect ""Order_Items"" with ""Shipment_Items"" on ""Shipment_Items.order_item_id = Order_Items.order_item_id"" to ensure only shipped products are included. 4. Aggregation Structure: No aggregation is required as the query simply retrieves product names and colors.",1.0
176,What are the type of questions and their counts?,NON-NESTED,online_exams,"[Questions.Type_of_Question_Code, Questions.Question_ID, Questions_in_Exams.Question_ID = Questions.Question_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Questions.Type_of_Question_Code, COUNT(Questions.Question_ID) AS Question_Count FROM Questions JOIN Questions_in_Exams ON Questions.Question_ID = Questions_in_Exams.Question_ID GROUP BY Questions.Type_of_Question_Code;","SELECT Type_of_Question_Code ,  COUNT(*) FROM Questions GROUP BY Type_of_Question_Code","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Type_of_Question_Code"" and the count of questions for each type. Use COUNT on ""Questions.Question_ID"" to count the number of questions for each type. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Questions"" table and the ""Questions_in_Exams"" table based on ""Questions.Question_ID"" to link each question with its exam occurrences. 4. Aggregation Structure: Use GROUP BY on ""Questions.Type_of_Question_Code"" to group the results by the type of question, and COUNT to calculate the number of questions for each type.",1.0
177,What are the names of players in ascending order of wins count?,EASY,soccer_3,"[player.Name, player.Wins_count]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT player.Name FROM player ORDER BY player.Wins_count ASC;,SELECT Name FROM player ORDER BY Wins_count ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""player.Name"". 2. Condition Structure: No specific filtering condition is required as we want all players. 3. Join Structure: No JOIN is required since all necessary data is within the ""player"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in ascending order based on ""player.Wins_count"".",1.0
178,How many orders has each gender placed?,NON-NESTED,e_commerce,"[Customers.customer_id,Customers.gender_code,Orders.customer_id,Orders.order_id,Orders.customer_id = Customers.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.gender_code, COUNT(Orders.order_id) AS order_count FROM Customers JOIN Orders ON Customers.customer_id = Orders.customer_id GROUP BY Customers.gender_code;","SELECT T1.gender_code ,  count(*) FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.gender_code","1. Sequential Structure: Start with the SELECT clause to retrieve ""Customers.gender_code"" and the count of ""Orders.order_id"" for each gender. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Customers"" and ""Orders"" tables on ""Customers.customer_id = Orders.customer_id"" to associate each order with the corresponding customer. 4. Aggregation Structure: Use COUNT on ""Orders.order_id"" to count the number of orders placed by each gender, and GROUP BY ""Customers.gender_code"" to group the results by gender.",1.0
179,"For every order, how many products does it contain, and what are the orders' statuses and ids?",NON-NESTED,e_commerce,"[Orders.order_id,Orders.order_status_code,Order_Items.order_id,Order_Items.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Orders.order_id, Orders.order_status_code, COUNT(Order_Items.product_id) AS product_count FROM Orders JOIN Order_Items ON Orders.order_id = Order_Items.order_id GROUP BY Orders.order_id, Orders.order_status_code;","SELECT T1.order_id ,  T1.order_status_code ,  count(*) FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Orders.order_id,"" ""Orders.order_status_code,"" and the count of ""Order_Items.product_id"" for each order. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Orders"" table and the ""Order_Items"" table on the ""order_id"" field to associate each order with its products. 4. Aggregation Structure: Use COUNT on ""Order_Items.product_id"" to count the number of products for each order, and GROUP BY ""Orders.order_id"" to group the results by each order.",1.0
180,Count the number of different comments for student answers.,EASY,online_exams,[Student_Answers.Comments],"Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT COUNT(DISTINCT Student_Answers.Comments) AS distinct_comments_count FROM Student_Answers;,SELECT count(DISTINCT Comments) FROM Student_Answers,"1. Sequential Structure: Begin with the SELECT clause to count the number of distinct comments in the ""Student_Answers"" table. 2. Condition Structure: No specific filtering condition is required as we are counting all distinct comments. 3. Join Structure: No JOIN is necessary since all the required data is within the ""Student_Answers"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique comments in the ""Student_Answers.Comments"" field.",1.0
181,"For each gender, return the gender code and the number of students who identify as that gender.",EASY,online_exams,"[Students.Gender_MFU, Students.Student_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Students.Gender_MFU, COUNT(Students.Student_ID) AS student_count FROM Students GROUP BY Students.Gender_MFU;","SELECT Gender_MFU ,  COUNT(*) FROM Students GROUP BY Gender_MFU","1. Sequential Structure: Begin with the SELECT clause to specify the gender code and the count of students for each gender. 2. Aggregation Structure: Use COUNT to calculate the number of students for each gender. 3. Grouping Structure: Use GROUP BY on ""Students.Gender_MFU"" to group the results by gender. 4. Join Structure: No JOIN is required since all necessary data is within the ""Students"" table.",1.0
182,What is the price for the product with name Monitor?,EASY,customers_and_orders,"[Products.product_price, Products.product_name]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Products.product_price FROM Products WHERE Products.product_name = 'Monitor';,"SELECT product_price FROM Products WHERE product_name  =  ""Monitor""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Products.product_price"" for the product with the name ""Monitor"". 2. Condition Structure: Use a WHERE clause to filter for the product where ""Products.product_name"" is ""Monitor"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Products"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
183,List all product names in descending order of price.,EASY,customers_and_orders,"[Products.product_name, Products.product_price]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Products.product_name FROM Products ORDER BY Products.product_price DESC;,SELECT product_name FROM Products ORDER BY product_price DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the product name. Additionally, include the product price for sorting purposes. 2. Condition Structure: No specific filtering condition is required as we want all product names. 3. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the product names. 5. Ordering Structure: Use ORDER BY in descending order on ""Products.product_price"" to sort the products by their price.",1.0
184,What are the tracking numbers and dates for all shipments listed?,EASY,e_commerce,"[Shipments.shipment_tracking_number, Shipments.shipment_date]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Shipments.shipment_tracking_number, Shipments.shipment_date FROM Shipments;","SELECT shipment_tracking_number ,  shipment_date FROM Shipments","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the shipment tracking numbers and shipment dates. 2. Condition Structure: No specific filtering condition is required as the query asks for all shipments. 3. Join Structure: No JOIN is required since all necessary data is within the ""Shipments"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the tracking numbers and dates for all shipments.",1.0
185,What are the prices and sizes of all products whose price is above the mean?,NESTED,e_commerce,"[Products.product_price, Products.product_size, Products.product_price]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT product_price, product_size FROM Products WHERE product_price > (SELECT AVG(product_price) FROM Products);","SELECT product_price ,  product_size FROM Products WHERE product_price  >  ( SELECT avg(product_price) FROM Products )","1. Sequential Structure: Start with the SELECT clause to retrieve the product prices and sizes. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter products whose price is above the mean price. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the mean price of all products and filter for products with a price greater than this mean. 3. Join Structure: Not required, as all data is available within the Products table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the mean price, which is then used in the filtering condition.",1.0
186,What are the names of clubs who do not have the manufacturer Nike?,NESTED,soccer_3,"[club.Name, club.Manufacturer]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT Name FROM club WHERE Manufacturer != 'Nike';,"SELECT Name FROM club WHERE Manufacturer != ""Nike""","1. Sequential Structure: Start with the SELECT clause to retrieve the names of clubs. Use the FROM clause to specify the club table. Apply a WHERE clause to filter out clubs whose manufacturer is Nike. 2. Condition Structure: Use the WHERE clause to exclude clubs where the Manufacturer column is equal to 'Nike'. 3. Join Structure: Not required, as all data is available within the club table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
187,"What are the ids, type codes, and names for all products?",EASY,customers_and_orders,"[Products.product_id, Products.product_type_code, Products.product_name]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_id, Products.product_type_code, Products.product_name FROM Products;","SELECT product_id ,  product_type_code ,  product_name FROM Products","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Products.product_id"", ""Products.product_type_code"", and ""Products.product_name"". 2. Condition Structure: No specific filtering condition is required as the query asks for all products. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Products"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all products.",1.0
188,List the names of the products being shipped and the corresponding shipment date.,NON-NESTED,e_commerce,"[Products.product_name,Shipments.shipment_date,Order_Items.product_id = Products.product_id,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Products.product_name, Shipments.shipment_date FROM Products JOIN Order_Items ON Order_Items.product_id = Products.product_id JOIN Shipment_Items ON Shipment_Items.order_item_id = Order_Items.order_item_id JOIN Shipments ON Shipment_Items.shipment_id = Shipments.shipment_id;","SELECT T1.product_name ,  T4.shipment_date FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Shipment_Items AS T3 ON T2.order_item_id  =  T3.order_item_id JOIN Shipments AS T4 ON T3.shipment_id  =  T4.shipment_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Products.product_name"" and ""Shipments.shipment_date."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use multiple JOINs to connect the tables. First, join ""Order_Items"" with ""Products"" on ""Order_Items.product_id = Products.product_id"" to link products with their order items. Then, join ""Shipment_Items"" with ""Order_Items"" on ""Shipment_Items.order_item_id = Order_Items.order_item_id"" to link shipment items with order items. Finally, join ""Shipment_Items"" with ""Shipments"" on ""Shipment_Items.shipment_id = Shipments.shipment_id"" to link shipment items with their shipment dates. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without summarization.",1.0
189,How many different countries are players from?,EASY,soccer_3,[player.Country],"Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT COUNT(DISTINCT player.Country) FROM player;,SELECT COUNT (DISTINCT Country) FROM player,"1. Sequential Structure: Begin with the SELECT clause to count the distinct countries from which players originate. 2. Condition Structure: No specific filtering condition is required as we want to count all distinct countries. 3. Join Structure: No JOIN is necessary since all required data is within the ""player"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""player.Country"" to count the number of unique countries.",1.0
190,How many different digital terrestrial channels are there?,EASY,bbc_channels,[channel.Digital_terrestrial_channel],"Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
",SELECT COUNT(DISTINCT channel.Digital_terrestrial_channel) FROM channel;,SELECT count(DISTINCT Digital_terrestrial_channel) FROM channel,"1. Sequential Structure: Begin with the SELECT clause to count the distinct digital terrestrial channels. 2. Condition Structure: No specific filtering condition is required as we are counting all distinct digital terrestrial channels. 3. Join Structure: No JOIN is necessary since all required data is within the ""channel"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique digital terrestrial channels.",1.0
191,Return the names and citizenships of drivers who have driven the vehicle with the model 'DJ1'.,NON-NESTED,vehicle_driver,"[driver.Name, driver.Citizenship, vehicle.Model, vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID, vehicle_driver.Driver_ID = driver.Driver_ID, DJ1]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT driver.Name, driver.Citizenship FROM vehicle_driver JOIN vehicle ON vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID JOIN driver ON vehicle_driver.Driver_ID = driver.Driver_ID WHERE vehicle.Model = 'DJ1';","SELECT T1.name ,  T1.citizenship FROM driver AS T1 JOIN vehicle_driver AS T2 ON T1.driver_id  =  T2.driver_id JOIN vehicle AS T3 ON T2.vehicle_id  =  T3.vehicle_id WHERE T3.model  =  'DJ1'","1. Sequential Structure: Start with the SELECT clause to retrieve ""driver.Name"" and ""driver.Citizenship."" 2. Condition Structure: Use a WHERE clause to filter for the vehicle model ""DJ1."" 3. Join Structure: Use JOINs to connect the ""vehicle_driver"" table with the ""vehicle"" table on ""vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID"" and with the ""driver"" table on ""vehicle_driver.Driver_ID = driver.Driver_ID"" to link drivers with the vehicles they have driven. 4. Aggregation Structure: No aggregation is needed as the query only requires specific fields without any summarization.",1.0
192,"What are the names of the products tht have been shipped, and on what days were they shipped?",NON-NESTED,e_commerce,"[Products.product_name,Shipments.shipment_date,Shipment_Items.shipment_id = Shipments.shipment_id,Shipment_Items.order_item_id = Order_Items.order_item_id,Order_Items.product_id = Products.product_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Products.product_name, Shipments.shipment_date FROM Products JOIN Order_Items ON Products.product_id = Order_Items.product_id JOIN Shipment_Items ON Order_Items.order_item_id = Shipment_Items.order_item_id JOIN Shipments ON Shipment_Items.shipment_id = Shipments.shipment_id;","SELECT T1.product_name ,  T4.shipment_date FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Shipment_Items AS T3 ON T2.order_item_id  =  T3.order_item_id JOIN Shipments AS T4 ON T3.shipment_id  =  T4.shipment_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Products.product_name"" and ""Shipments.shipment_date."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use multiple JOINs to connect the tables. First, join ""Products"" with ""Order_Items"" on ""Products.product_id = Order_Items.product_id."" Then, join ""Order_Items"" with ""Shipment_Items"" on ""Order_Items.order_item_id = Shipment_Items.order_item_id."" Finally, join ""Shipment_Items"" with ""Shipments"" on ""Shipment_Items.shipment_id = Shipments.shipment_id."" 4. Aggregation Structure: No aggregation is required as the query only retrieves product names and shipment dates.",1.0
193,"What are the addresses, towns, and county information for all customers who live in the United States?",EASY,e_commerce,"[Customers.address_line_1, Customers.town_city, Customers.county, Customers.country]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.address_line_1, Customers.town_city, Customers.county FROM Customers WHERE Customers.country = 'United States';","SELECT address_line_1 ,  town_city ,  county FROM Customers WHERE Country  =  'USA'","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are ""Customers.address_line_1"", ""Customers.town_city"", and ""Customers.county"". 2. Condition Structure: Use a WHERE clause to filter customers who live in the ""United States"" by checking the ""Customers.country"" field. 3. Join Structure: No JOIN is required since all necessary data is within the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",0.0
194,What is the least common order status?,EASY,e_commerce,[Orders.order_status_code],"Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT Orders.order_status_code FROM Orders GROUP BY Orders.order_status_code ORDER BY COUNT(*) ASC LIMIT 1;,SELECT order_status_code FROM Orders GROUP BY order_status_code ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the order status code, as we are interested in finding the least common order status. 2. Aggregation Structure: Use COUNT to calculate the frequency of each order status code. 3. Grouping Structure: Use GROUP BY on ""Orders.order_status_code"" to group the results by each order status code. 4. Ordering Structure: Use ORDER BY in ascending order on the count to rank the order statuses by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the least common order status. 6. Join Structure: No JOIN is required since all necessary data is within the ""Orders"" table.",1.0
195,List the name of clubs in ascending alphabetical order.,EASY,soccer_3,[club.Name],"Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT club.Name FROM club ORDER BY club.Name ASC;,SELECT Name FROM club ORDER BY Name ASC,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the name of the clubs. 2. Condition Structure: No specific filtering condition is required as we want all club names. 3. Join Structure: No JOIN is required since all necessary data is within the ""club"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the club names. 5. Ordering Structure: Use ORDER BY in ascending alphabetical order on ""club.Name"".",1.0
196,Please show the most common manufacturer of clubs.,EASY,soccer_3,[club.Manufacturer],"Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT club.Manufacturer FROM club GROUP BY club.Manufacturer ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Manufacturer FROM club GROUP BY Manufacturer ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the manufacturer, as the question asks for the most common manufacturer. 2. Aggregation Structure: Use COUNT to calculate the number of clubs produced by each manufacturer. 3. Grouping Structure: Use GROUP BY on ""club.Manufacturer"" to group the results by each manufacturer. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank manufacturers by the number of clubs they produce. 5. Limiting Structure: Use LIMIT 1 to retrieve the manufacturer with the highest count. 6. Join Structure: No JOIN is required since all necessary data is within the ""club"" table.",1.0
197,"What are the email addresses, cities, and counties listed for all cusomters who are from the gender that orders less often?",NESTED,e_commerce,"[Customers.email_address, Customers.town_city, Customers.county, Customers.customer_id = Orders.customer_id, Customers.gender_code, Orders.customer_id, Orders.order_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.email_address, Customers.town_city, Customers.county FROM Customers JOIN Orders ON Customers.customer_id = Orders.customer_id WHERE Customers.gender_code = ( SELECT gender_code FROM Customers JOIN Orders ON Customers.customer_id = Orders.customer_id GROUP BY Customers.gender_code ORDER BY COUNT(Orders.order_id) ASC LIMIT 1 );","SELECT email_address ,  town_city ,  county FROM Customers WHERE gender_code  =  ( SELECT gender_code FROM Customers GROUP BY gender_code ORDER BY count(*) ASC LIMIT 1 )","1. Sequential Structure: Start with the SELECT clause to retrieve the email addresses, cities, and counties of customers. Use the FROM clause to specify the Customers table and JOIN it with the Orders table to link customers with their orders. Use GROUP BY to group customers by gender and count the number of orders for each gender. Use a subquery to identify the gender that orders less often, and filter customers based on this gender. 2. Condition Structure: Use a WHERE clause to filter customers based on the gender identified in the subquery as the one that orders less often. 3. Join Structure: Use an INNER JOIN between the Customers and Orders tables based on customer_id to link customer details with their orders. 4. Aggregation Structure: Use COUNT to calculate the number of orders for each gender in the subquery and identify the gender with the minimum count.",1.0
198,What are all the address ids and address details?,EASY,customers_and_orders,"[Addresses.address_id, Addresses.address_details]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Addresses.address_id, Addresses.address_details FROM Addresses;","SELECT address_id ,  address_details FROM Addresses","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Addresses.address_id"" and ""Addresses.address_details"". 2. Condition Structure: No specific filtering condition is required as the query asks for all address IDs and their details. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Addresses"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all records from the table.",1.0
199,"What is the order that total cost the least , and how much is the total cost ?",NON-NESTED,e_commerce,"[Order_Items.order_id, Order_Items.product_id, Order_Items.order_item_status_code, Order_Items.order_id = Orders.order_id, Order_Items.product_id = Products.product_id, Products.product_price]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Order_Items.order_id, SUM(Products.product_price) AS total_cost FROM Order_Items JOIN Orders ON Order_Items.order_id = Orders.order_id JOIN Products ON Order_Items.product_id = Products.product_id GROUP BY Order_Items.order_id ORDER BY total_cost ASC LIMIT 1;","select t1.order_id ,  sum(t2.product_price) from order_items as t1 join products as t2 on t1.product_id  =  t2.product_id group by t1.order_id order by sum(t2.product_price) asc limit 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""order_id"" and the total cost of the order. Use SUM to calculate the total cost by summing up the product of ""Order_Items.product_id"" and ""Products.product_price."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOIN clauses to connect ""Order_Items"" with ""Orders"" on ""Order_Items.order_id"" and ""Order_Items"" with ""Products"" on ""Order_Items.product_id"" to link orders with their respective products and prices. 4. Aggregation Structure: Use GROUP BY on ""Order_Items.order_id"" to calculate the total cost for each order. Use ORDER BY in ascending order of the total cost and LIMIT 1 to find the order with the least total cost.",1.0
200,Which manufacturer is most common among clubs?,EASY,soccer_3,[club.Manufacturer],"Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT club.Manufacturer FROM club GROUP BY club.Manufacturer ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Manufacturer FROM club GROUP BY Manufacturer ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the manufacturer, as we are interested in identifying the most common manufacturer among clubs. 2. Aggregation Structure: Use COUNT to calculate the number of clubs associated with each manufacturer. 3. Grouping Structure: Use GROUP BY on ""club.Manufacturer"" to group the results by each manufacturer. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank manufacturers by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the manufacturer that appears most frequently. 6. Join Structure: No JOIN is required since all necessary data is within the ""club"" table.",1.0
201,Return the id of the vehicle that has been driven the fewest times.,NON-NESTED,vehicle_driver,"[vehicle.Vehicle_ID, vehicle_driver.Vehicle_ID, COUNT(vehicle_driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT vehicle.Vehicle_ID FROM vehicle JOIN vehicle_driver ON vehicle.Vehicle_ID = vehicle_driver.Vehicle_ID GROUP BY vehicle.Vehicle_ID ORDER BY COUNT(vehicle_driver.Driver_ID) ASC LIMIT 1;,SELECT vehicle_id FROM vehicle_driver GROUP BY vehicle_id ORDER BY count(*) ASC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""vehicle.Vehicle_ID"" of the vehicle that has been driven the fewest times. Use COUNT on ""vehicle_driver.Driver_ID"" to count the number of times each vehicle has been driven. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the vehicle with the fewest drives. 3. Join Structure: Use a JOIN between the ""vehicle"" and ""vehicle_driver"" tables based on ""vehicle.Vehicle_ID"" to associate each vehicle with its driving records. 4. Aggregation Structure: Use GROUP BY on ""vehicle.Vehicle_ID"" to group the driving records by vehicle. Use ORDER BY in ascending order on the count of ""vehicle_driver.Driver_ID"" to rank vehicles by the number of times they have been driven. Use LIMIT 1 to select the vehicle with the fewest drives.",1.0
202,How many customers have placed any order?,NON-NESTED,e_commerce,"[Customers.customer_id, Orders.customer_id, Orders.customer_id = Customers.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT COUNT(DISTINCT Orders.customer_id) FROM Orders;,SELECT count(DISTINCT customer_id) FROM Orders,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""customer_id"" from the ""Orders"" table, as we are interested in the number of unique customers who have placed orders. 2. Condition Structure: No specific filtering condition is required since we are counting all customers who have placed any order. 3. Join Structure: No JOIN is necessary because the ""Orders"" table already contains the ""customer_id"" field, which is sufficient for this query. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique ""customer_id"" values in the ""Orders"" table.",1.0
203,What is the date of all orders that have been placed by customers with at least 2 payment methods?,NESTED,e_commerce,"[Orders.date_order_placed,Orders.customer_id = Customers.customer_id,Customer_Payment_Methods.customer_id = Customers.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Orders.date_order_placed FROM Orders JOIN Customers ON Orders.customer_id = Customers.customer_id JOIN Customer_Payment_Methods ON Customers.customer_id = Customer_Payment_Methods.customer_id GROUP BY Orders.date_order_placed, Orders.customer_id HAVING COUNT(Customer_Payment_Methods.customer_id) >= 2;",SELECT date_order_placed FROM Orders WHERE customer_id IN ( SELECT T1.customer_id FROM Customers AS T1 JOIN Customer_Payment_Methods AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2 ),"1. Sequential Structure: Start with the SELECT clause to retrieve the date of orders. Use the FROM clause to specify the Orders table. Join it with the Customers table to link orders to customers, and then join the Customers table with the Customer_Payment_Methods table to access payment method details. Use GROUP BY to group customers by their ID and count their payment methods. Apply a HAVING clause to filter customers with at least 2 payment methods. 2. Condition Structure: Use the HAVING clause to filter customers who have at least 2 payment methods by counting the number of payment methods per customer. 3. Join Structure: Use INNER JOINs between Orders, Customers, and Customer_Payment_Methods tables based on customer_id to connect orders with customers and their payment methods. 4. Aggregation Structure: Use COUNT to calculate the number of payment methods per customer and filter those with at least 2 payment methods.",1.0
204,Show the cities and station names of city channels in ascending alphabetical order of station name.,EASY,tv_shows,"[city_channel.City, city_channel.Station_name]","Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
","SELECT city_channel.City, city_channel.Station_name FROM city_channel ORDER BY city_channel.Station_name ASC;","SELECT City ,  Station_name FROM city_channel ORDER BY Station_name ASC","1. Sequential Structure: Start with the SELECT clause to retrieve the ""city_channel.City"" and ""city_channel.Station_name"". 2. Condition Structure: No specific filtering condition is required as the query asks for all city channels. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""city_channel"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""city_channel.Station_name"" in ascending alphabetical order.",1.0
205,Count the number of exams.,EASY,online_exams,[Exams.Exam_ID],"Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT COUNT(Exams.Exam_ID) AS exam_count FROM Exams;,SELECT count(*) FROM Exams,"1. Sequential Structure: Begin with the SELECT clause to count the number of exams. 2. Aggregation Structure: Use the COUNT function on the ""Exams.Exam_ID"" field to calculate the total number of exams. 3. Condition Structure: No specific filtering condition is required as we are counting all exams. 4. Join Structure: No JOIN is necessary since all required data is within the ""Exams"" table.",1.0
206,"What are the id, name, price and color of the products which have not been ordered for at least twice?",NESTED,e_commerce,"[Products.product_id, Products.product_name, Products.product_price, Products.product_color, Order_Items.product_id, Order_Items.product_id = Products.product_id, 2]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Products.product_id, Products.product_name, Products.product_price, Products.product_color FROM Products JOIN Order_Items ON Products.product_id = Order_Items.product_id GROUP BY Products.product_id, Products.product_name, Products.product_price, Products.product_color HAVING COUNT(Order_Items.product_id) < 2;","SELECT product_id ,  product_name ,  product_price ,  product_color FROM Products EXCEPT SELECT T1.product_id ,  T1.product_name ,  T1.product_price ,  T1.product_color FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id GROUP BY T1.product_id HAVING count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve the id, name, price, and color of products. Use the FROM clause to specify the Products table and JOIN it with the Order_Items table to link products with their order details. Apply a GROUP BY clause to group records by product_id, allowing us to count the number of times each product has been ordered. Use the HAVING clause to filter products that have been ordered fewer than twice. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for products that have been ordered less than twice. 3. Join Structure: Use an INNER JOIN between the Products and Order_Items tables based on product_id to connect product details with their order records. 4. Aggregation Structure: Use COUNT(*) within HAVING to count the number of orders for each product and filter out products with two or more orders.",1.0
207,Find the valid answer text that appeared most frequently.,NON-NESTED,online_exams,"[Valid_Answers.Valid_Answer_Text, Student_Assessments.Valid_Answer_ID, Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Valid_Answers.Valid_Answer_Text, COUNT(Student_Assessments.Valid_Answer_ID) AS frequency FROM Valid_Answers JOIN Student_Assessments ON Valid_Answers.Valid_Answer_ID = Student_Assessments.Valid_Answer_ID GROUP BY Valid_Answers.Valid_Answer_Text ORDER BY frequency DESC LIMIT 1;",SELECT Valid_Answer_Text FROM Valid_Answers GROUP BY Valid_Answer_Text ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Valid_Answers.Valid_Answer_Text"" and the count of its occurrences. Use an aggregate function (COUNT) to count the frequency of each valid answer text. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all valid answer texts. 3. Join Structure: Use a JOIN between the ""Valid_Answers"" and ""Student_Assessments"" tables based on the ""Valid_Answer_ID"" field to link each valid answer text with its occurrences in student assessments. 4. Aggregation Structure: Use COUNT to count the occurrences of each valid answer text, then use ORDER BY in descending order to rank the texts by frequency. Use LIMIT 1 to select the most frequently appearing valid answer text.",1.0
208,"What is the id of the driver who has driven the most vehicles, and how many vehicles is this?",NON-NESTED,vehicle_driver,"[driver.Driver_ID,vehicle_driver.Driver_ID,vehicle_driver.Vehicle_ID,vehicle.Vehicle_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT driver.Driver_ID, COUNT(vehicle_driver.Vehicle_ID) AS vehicle_count FROM driver JOIN vehicle_driver ON driver.Driver_ID = vehicle_driver.Driver_ID GROUP BY driver.Driver_ID ORDER BY vehicle_count DESC LIMIT 1;","SELECT count(*) ,  driver_id FROM vehicle_driver GROUP BY driver_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Driver_ID"" and the count of ""vehicle_driver.Vehicle_ID"" for each driver. Use an alias for the count to make it easier to reference. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all drivers. 3. Join Structure: Use a JOIN between the ""driver"" and ""vehicle_driver"" tables on ""driver.Driver_ID"" to associate each driver with the vehicles they have driven. 4. Aggregation Structure: Use COUNT on ""vehicle_driver.Vehicle_ID"" to count the number of vehicles driven by each driver. Use GROUP BY to group the results by ""driver.Driver_ID."" Finally, use ORDER BY in descending order of the count and LIMIT 1 to get the driver who has driven the most vehicles.",1.0
209,Find the number of programs for each channel. Return the name of each channel as well.,NON-NESTED,bbc_channels,"[channel.Name, program.Channel_ID, channel.Channel_ID = program.Channel_ID]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
","SELECT channel.Name, COUNT(program.Channel_ID) AS Program_Count FROM channel JOIN program ON channel.Channel_ID = program.Channel_ID GROUP BY channel.Name;","SELECT t1.name ,  count(*) FROM channel AS t1 JOIN program AS t2 ON t1.channel_id  =  t2.channel_id GROUP BY t1.channel_id","1. Sequential Structure: Start with the SELECT clause to retrieve the name of each channel and the count of programs for each channel. Use COUNT on ""program.Channel_ID"" to count the number of programs. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""channel"" table with the ""program"" table based on the relationship ""channel.Channel_ID = program.Channel_ID."" 4. Aggregation Structure: Use COUNT to aggregate the number of programs for each channel and GROUP BY ""channel.Name"" to group the results by each channel.",1.0
210,Give the price of the Monitor product.,EASY,customers_and_orders,"[Products.product_price, Products.product_name]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Products.product_price FROM Products WHERE Products.product_name = 'Monitor';,"SELECT product_price FROM Products WHERE product_name  =  ""Monitor""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Products.product_price"" for the product named ""Monitor."" 2. Condition Structure: Use a WHERE clause to filter for the product with the name ""Monitor."" 3. Join Structure: No JOIN is required since all necessary information is in the ""Products"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
211,Show all hardware product names with price higher than the average price of hardware type products.,NESTED,customers_and_orders,"[Products.product_name, Products.product_price, Products.product_type_code]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT product_name FROM Products WHERE product_type_code = 'hardware' AND product_price > (SELECT AVG(product_price) FROM Products WHERE product_type_code = 'hardware');,"SELECT product_name FROM Products WHERE product_type_code  =  ""Hardware"" AND product_price  >  (SELECT avg(product_price) FROM Products WHERE product_type_code  =  ""Hardware"")","1. Sequential Structure: Start with the SELECT clause to retrieve the product names. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter for hardware products with a price higher than the average price of hardware products. 2. Condition Structure: Use the WHERE clause to filter for products where the product type is 'hardware' and the price is greater than the average price of hardware products. Use a subquery to calculate the average price of hardware products. 3. Join Structure: Not required, as all data is available within the Products table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average price of hardware products, which is then used in the filtering condition.",0.0
212,What are the dates of the earliest order and the dates of all orders with more than 1 item?,NESTED,e_commerce,"[Orders.date_order_placed,Order_Items.order_id,Orders.order_id = Order_Items.order_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT MIN(Orders.date_order_placed) AS earliest_order_date FROM Orders UNION SELECT Orders.date_order_placed FROM Orders JOIN Order_Items ON Orders.order_id = Order_Items.order_id GROUP BY Orders.order_id, Orders.date_order_placed HAVING COUNT(Order_Items.order_id) > 1;",SELECT min(date_order_placed) FROM Orders UNION SELECT T1.date_order_placed FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id HAVING count(*)  >  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the date of the earliest order and the dates of all orders with more than one item. Use the FROM clause to specify the Orders table and JOIN it with the Order_Items table to relate orders with their items. Use a UNION to combine the results of two queries: one for the earliest order date and another for orders with more than one item. 2. Condition Structure: For the earliest order date, use an aggregate function MIN on the date_order_placed column. For orders with more than one item, use a GROUP BY clause on order_id and a HAVING clause to filter orders with a count of items greater than one. 3. Join Structure: Use an INNER JOIN between the Orders and Order_Items tables based on the order_id to connect orders with their items. 4. Aggregation Structure: Use MIN to find the earliest order date and COUNT to determine the number of items in each order for filtering.",1.0
213,What are the usernames and passwords of all customers whose phone number starts with '+12'?,EASY,e_commerce,"[Customers.login_name, Customers.login_password, Customers.phone_number]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.login_name, Customers.login_password FROM Customers WHERE Customers.phone_number LIKE '+12%';","SELECT login_name ,  login_password FROM Customers WHERE phone_number LIKE '+12%'","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Customers.login_name"" and ""Customers.login_password"". 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for customers whose phone number starts with '+12'. 3. Join Structure: No JOIN is required since all necessary data is within the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
214,Return the ids and models of vehicles that have been driven by exactly two drivers or built by Ziyang.,NESTED,vehicle_driver,"[vehicle.Vehicle_ID, vehicle.Model, vehicle.Builder, vehicle_driver.Vehicle_ID, vehicle_driver.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT vehicle.Vehicle_ID, vehicle.Model FROM vehicle LEFT JOIN vehicle_driver ON vehicle.Vehicle_ID = vehicle_driver.Vehicle_ID GROUP BY vehicle.Vehicle_ID, vehicle.Model, vehicle.Builder HAVING COUNT(vehicle_driver.Driver_ID) = 2 OR vehicle.Builder = 'Ziyang';","SELECT T1.vehicle_id ,  T1.model FROM vehicle AS T1 JOIN vehicle_driver AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T2.vehicle_id HAVING count(*)  =  2 OR T1.builder  =  'Ziyang'","1. Sequential Structure: Start with the SELECT clause to retrieve the Vehicle_ID and Model of vehicles. Use the FROM clause to specify the vehicle table and JOIN it with the vehicle_driver table to connect vehicles with their drivers. Apply a GROUP BY clause to count the number of drivers for each vehicle. Use a HAVING clause to filter vehicles driven by exactly two drivers. Additionally, use a WHERE clause to include vehicles built by ""Ziyang"". 2. Condition Structure: Use the HAVING clause to filter vehicles driven by exactly two drivers. Use the WHERE clause to include vehicles built by ""Ziyang"". 3. Join Structure: Use an INNER JOIN between the vehicle and vehicle_driver tables based on Vehicle_ID to connect vehicles with their drivers. 4. Aggregation Structure: Use COUNT to calculate the number of drivers for each vehicle and filter those with exactly two drivers using the HAVING clause.",1.0
215,"List the invoices' status, date and the date of shipment.",NON-NESTED,e_commerce,"[Invoices.invoice_status_code, Invoices.invoice_date, Shipments.shipment_date, Shipments.invoice_number = Invoices.invoice_number]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Invoices.invoice_status_code, Invoices.invoice_date, Shipments.shipment_date FROM Invoices JOIN Shipments ON Shipments.invoice_number = Invoices.invoice_number;","SELECT T1.invoice_status_code ,  T1.invoice_date ,  T2.shipment_date FROM Invoices AS T1 JOIN Shipments AS T2 ON T1.invoice_number  =  T2.invoice_number","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Invoices.invoice_status_code,"" ""Invoices.invoice_date,"" and ""Shipments.shipment_date."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Invoices"" and ""Shipments"" tables based on the relationship ""Shipments.invoice_number = Invoices.invoice_number"" to link each invoice with its corresponding shipment. 4. Aggregation Structure: No aggregation is required as the query only retrieves specific fields without any summarization.",1.0
216,Which country has produced both players with earnings over 1400000 and players with earnings below 1100000?,NESTED,soccer_3,"[player.Country, player.Earnings]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT Country FROM player GROUP BY Country HAVING COUNT(CASE WHEN Earnings > 1400000 THEN 1 END) > 0 AND COUNT(CASE WHEN Earnings < 1100000 THEN 1 END) > 0;,SELECT Country FROM player WHERE Earnings  >  1400000 INTERSECT SELECT Country FROM player WHERE Earnings  <  1100000,"1. Sequential Structure: Start with the SELECT clause to retrieve the country names. Use the FROM clause to specify the player table. Apply a GROUP BY clause to group records by country, and use the HAVING clause to filter countries that meet the condition of having players with earnings both above 1400000 and below 1100000. 2. Condition Structure: Use the HAVING clause with conditional aggregation to check for the existence of players with earnings over 1400000 and players with earnings below 1100000 within each country. 3. Join Structure: Not required, as all data is available within the player table. 4. Aggregation Structure: Use conditional aggregation with COUNT to ensure that each country has at least one player with earnings over 1400000 and at least one player with earnings below 1100000.",1.0
217,What is the status code of the items being ordered and shipped and its corresponding shipment tracking number?,NON-NESTED,e_commerce,"[Order_Items.order_item_status_code,Shipments.shipment_tracking_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Order_Items.order_item_status_code, Shipments.shipment_tracking_number FROM Order_Items JOIN Shipment_Items ON Shipment_Items.order_item_id = Order_Items.order_item_id JOIN Shipments ON Shipment_Items.shipment_id = Shipments.shipment_id;","SELECT T1.order_item_status_code ,  T3.shipment_tracking_number FROM Order_items AS T1 JOIN Shipment_Items AS T2 ON T1.order_item_id  =  T2.order_item_id JOIN Shipments AS T3 ON T2.shipment_id  =  T3.shipment_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Order_Items.order_item_status_code"" and ""Shipments.shipment_tracking_number."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Order_Items"" table with the ""Shipment_Items"" table on ""Shipment_Items.order_item_id = Order_Items.order_item_id,"" and then connect the ""Shipment_Items"" table with the ""Shipments"" table on ""Shipment_Items.shipment_id = Shipments.shipment_id."" 4. Aggregation Structure: No aggregation is required as the query is retrieving specific fields without any summarization.",1.0
218,What are the managers and captains of clubs?,EASY,soccer_3,"[club.Manager, club.Captain]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
","SELECT club.Manager, club.Captain FROM club;","SELECT Manager ,  Captain FROM club","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the ""club.Manager"" and ""club.Captain"". 2. Condition Structure: No specific filtering condition is required as the query asks for all managers and captains of clubs. 3. Join Structure: No JOIN is required since all necessary information is available in the ""club"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the manager and captain information for each club.",1.0
219,"List the dates of the exams with subject code containing the word ""data"", in descending order of dates.",EASY,online_exams,"[Exams.Exam_Date,Exams.Subject_Code]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Exams.Exam_Date FROM Exams WHERE Exams.Subject_Code LIKE '%data%' ORDER BY Exams.Exam_Date DESC;,SELECT Exam_Date FROM Exams WHERE Subject_Code LIKE '%data%' ORDER BY Exam_Date DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Exams.Exam_Date"" for exams with subject codes containing the word ""data"". 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for subject codes that contain the word ""data"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Exams"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the dates. 5. Ordering Structure: Use ORDER BY in descending order on ""Exams.Exam_Date"" to sort the results.",1.0
220,"What are the dates of the exams whose subject code contains the substring ""data""? Return them in descending order of dates.",EASY,online_exams,"[Exams.Exam_Date, Exams.Subject_Code]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Exams.Exam_Date FROM Exams WHERE Exams.Subject_Code LIKE '%data%' ORDER BY Exams.Exam_Date DESC;,SELECT Exam_Date FROM Exams WHERE Subject_Code LIKE '%data%' ORDER BY Exam_Date DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Exams.Exam_Date"" for exams whose subject code contains the substring ""data"". 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for subject codes that contain the substring ""data"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Exams"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the exam dates. 5. Ordering Structure: Use ORDER BY in descending order on ""Exams.Exam_Date"" to return the dates in the required order.",1.0
221,What is the product average price?,EASY,e_commerce,[Products.product_price],"Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT AVG(Products.product_price) AS average_price FROM Products;,SELECT avg(product_price) FROM Products,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average price of products. 2. Aggregation Structure: Use the AVG function to calculate the average of ""Products.product_price"". 3. Condition Structure: No specific filtering condition is required as the query asks for the average price of all products. 4. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table.",1.0
222,"List the address, town and county information of the customers who live in the USA.",EASY,e_commerce,"[Customers.address_line_1, Customers.town_city, Customers.county, Customers.country]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.address_line_1, Customers.town_city, Customers.county FROM Customers WHERE Customers.country = 'USA';","SELECT address_line_1 ,  town_city ,  county FROM Customers WHERE Country  =  'USA'","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Customers.address_line_1"", ""Customers.town_city"", and ""Customers.county"". 2. Condition Structure: Use a WHERE clause to filter customers who live in the USA by checking the ""Customers.country"" field. 3. Join Structure: No JOIN is required since all necessary information is in the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific fields based on a condition.",1.0
223,What are the vehicle ids and models of the vehicle which have been driven by two drivers or been manufactured by 'Ziyang'.,NESTED,vehicle_driver,"[vehicle.Vehicle_ID, vehicle.Model, vehicle.Builder, vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID, vehicle_driver.Driver_ID, driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT vehicle.Vehicle_ID, vehicle.Model FROM vehicle LEFT JOIN vehicle_driver ON vehicle.Vehicle_ID = vehicle_driver.Vehicle_ID WHERE vehicle.Builder = 'Ziyang' OR vehicle.Vehicle_ID IN ( SELECT vehicle_driver.Vehicle_ID FROM vehicle_driver GROUP BY vehicle_driver.Vehicle_ID HAVING COUNT(vehicle_driver.Driver_ID) = 2 );","SELECT T1.vehicle_id ,  T1.model FROM vehicle AS T1 JOIN vehicle_driver AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T2.vehicle_id HAVING count(*)  =  2 OR T1.builder  =  'Ziyang'","1. Sequential Structure: Start with the SELECT clause to retrieve the vehicle IDs and models. Use the FROM clause to specify the vehicle table. Use JOINs to connect the vehicle table with the vehicle_driver and driver tables to access driver-related information. Apply a WHERE clause to filter vehicles that either have been driven by two drivers or have been manufactured by 'Ziyang'. 2. Condition Structure: Use a WHERE clause with two conditions: one to check for vehicles driven by two drivers using a GROUP BY and HAVING clause, and another to check for vehicles manufactured by 'Ziyang'. Combine these conditions using an OR operator. 3. Join Structure: Use an INNER JOIN between the vehicle and vehicle_driver tables on Vehicle_ID to link vehicles with their drivers. No additional joins are needed for the manufacturer condition. 4. Aggregation Structure: Use COUNT in the HAVING clause to count the number of drivers for each vehicle and filter for vehicles with exactly two drivers.",1.0
224,"What are the color, description and size of the products priced below the maximum price.",NESTED,e_commerce,"[Products.product_color, Products.product_description, Products.product_size, Products.product_price]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT product_color, product_description, product_size FROM Products WHERE product_price < (SELECT MAX(product_price) FROM Products);","SELECT product_color ,  product_description ,  product_size FROM Products WHERE product_price  <  ( SELECT max(product_price) FROM products )","1. Sequential Structure: Start with the SELECT clause to retrieve the product color, description, and size. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter products priced below the maximum price. 2. Condition Structure: Use the WHERE clause with a subquery to filter for products whose price is less than the maximum price. The subquery calculates the maximum price from the Products table. 3. Join Structure: Not required, as all data is available within the Products table. 4. Aggregation Structure: Use the MAX function in a subquery to find the maximum price, which is then used in the filtering condition.",1.0
225,Give the name of the most expensive Clothes product.,EASY,customers_and_orders,"[Products.product_name, Products.product_price, Products.product_type_code]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Products.product_name FROM Products WHERE Products.product_type_code = 'Clothes' ORDER BY Products.product_price DESC LIMIT 1;,"SELECT product_name FROM Products WHERE product_type_code  =  ""Clothes"" ORDER BY product_price DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Products.product_name"" of the most expensive Clothes product. 2. Condition Structure: Use a WHERE clause to filter for products where ""Products.product_type_code"" corresponds to Clothes. 3. Join Structure: No JOIN is required since all necessary information is in the ""Products"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""Products.product_price"" to rank products by price and apply LIMIT 1 to select the most expensive Clothes product.",1.0
226,What is the product type code with most number of products?,EASY,customers_and_orders,[Products.product_type_code],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Products.product_type_code FROM Products GROUP BY Products.product_type_code ORDER BY COUNT(*) DESC LIMIT 1;,SELECT product_type_code FROM Products GROUP BY product_type_code ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the product type code, as the question asks for the product type code with the most number of products. 2. Aggregation Structure: Use COUNT to calculate the number of products for each product type code. 3. Grouping Structure: Use GROUP BY on ""Products.product_type_code"" to count the number of products for each product type code. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank product type codes by the number of products. 5. Limiting Structure: Use LIMIT 1 to retrieve the product type code with the most number of products. 6. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table.",1.0
227,"What are the ids , names , prices , and colors of all products that have been listed in less than two orders ?",NESTED,e_commerce,"[Products.product_id, Products.product_name, Products.product_price, Products.product_color, Order_Items.product_id, Order_Items.order_id, Orders.order_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Products.product_id, Products.product_name, Products.product_price, Products.product_color FROM Products JOIN Order_Items ON Products.product_id = Order_Items.product_id GROUP BY Products.product_id, Products.product_name, Products.product_price, Products.product_color HAVING COUNT(Order_Items.order_id) < 2;","select t1.product_id ,  t1.product_name ,  t1.product_price ,  t1.product_color from products as t1 join order_items as t2 on t1.product_id  =  t2.product_id join orders as t3 on t2.order_id  =  t3.order_id group by t1.product_id having count(*) < 2","1. Sequential Structure: Start with the SELECT clause to retrieve the product IDs, names, prices, and colors from the Products table. Use the FROM clause to specify the Products table and JOIN it with the Order_Items table to link products with their orders. Use GROUP BY to group products by their IDs and count the number of orders for each product. Apply a HAVING clause to filter products that have been listed in less than two orders. 2. Condition Structure: Use the HAVING clause with COUNT(Order_Items.order_id) to filter for products that appear in fewer than two orders. 3. Join Structure: Use an INNER JOIN between the Products and Order_Items tables based on product_id to connect products with their order details. 4. Aggregation Structure: Use COUNT(Order_Items.order_id) to count the number of orders for each product and filter based on this count.",1.0
228,Return the managers and captains of all clubs.,EASY,soccer_3,"[club.Manager, club.Captain]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
","SELECT club.Manager, club.Captain FROM club;","SELECT Manager ,  Captain FROM club","1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""club.Manager"" and ""club.Captain"" as the question asks for both managers and captains of all clubs. 2. Condition Structure: No specific filtering condition is required since the query aims to retrieve all managers and captains. 3. Join Structure: No JOIN is necessary as all the required data is available within the ""club"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the manager and captain information for all clubs.",1.0
229,Return the average top speed across all vehicles.,EASY,vehicle_driver,[vehicle.Top_Speed],"Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT AVG(vehicle.Top_Speed) AS avg_top_speed FROM vehicle;,SELECT avg(top_speed) FROM vehicle,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average top speed. 2. Aggregation Structure: Use the AVG function to calculate the average of the ""vehicle.Top_Speed"" field. 3. Condition Structure: No specific filtering condition is required as the query asks for the average across all vehicles. 4. Join Structure: No JOIN is required since all necessary data is within the ""vehicle"" table.",1.0
230,Please show the first names of students and the dates of their answers.,NON-NESTED,online_exams,"[Students.First_Name, Student_Answers.Date_of_Answer, Student_Answers.Student_ID = Students.Student_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Students.First_Name, Student_Answers.Date_of_Answer FROM Students JOIN Student_Answers ON Student_Answers.Student_ID = Students.Student_ID;","SELECT T2.First_Name ,  T1.Date_of_Answer FROM Student_Answers AS T1 JOIN Students AS T2 ON T1.Student_ID  =  T2.Student_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""Students.First_Name"" and ""Student_Answers.Date_of_Answer."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Students"" and ""Student_Answers"" tables based on the relationship ""Student_Answers.Student_ID = Students.Student_ID"" to link each student with their answers. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the relevant fields.",1.0
231,Show the distinct transmitters of radios that are not associated with any city channel.,NESTED,tv_shows,"[radio.Transmitter,city_channel_radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_radio.Radio_ID = radio.Radio_ID]","Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
",SELECT DISTINCT radio.Transmitter FROM radio WHERE radio.Radio_ID NOT IN (SELECT city_channel_radio.Radio_ID FROM city_channel_radio);,SELECT Transmitter FROM radio WHERE Radio_ID NOT IN (SELECT Radio_ID FROM city_channel_radio),"1. Sequential Structure: Start with the SELECT clause to retrieve distinct transmitters from the radio table. Use the FROM clause to specify the radio table. Apply a WHERE clause to filter radios that are not associated with any city channel. 2. Condition Structure: Use the WHERE clause with a subquery to exclude radios whose Radio_ID appears in the city_channel_radio table, meaning they are associated with a city channel. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Radio_ID entries in the city_channel_radio table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
232,List the country that have more than one player.,EASY,soccer_3,"[player.Country, player.Player_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT player.Country FROM player GROUP BY player.Country HAVING COUNT(player.Player_ID) > 1;,SELECT Country FROM player GROUP BY Country HAVING COUNT(*)  >  1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the country. 2. Aggregation Structure: Use COUNT to determine the number of players from each country. 3. Grouping Structure: Use GROUP BY on ""player.Country"" to aggregate the results by each country. 4. Condition Structure: Apply the HAVING clause to filter for countries that have more than one player, by setting the count to be greater than 1. 5. Join Structure: No JOIN is required since we are only interested in the ""player"" table.",1.0
233,How many clubs are there?,EASY,soccer_3,[club.Club_ID],"Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT COUNT(club.Club_ID) AS total_clubs FROM club;,SELECT count(*) FROM club,"1. Sequential Structure: Start with the SELECT clause to count the number of clubs. 2. Aggregation Structure: Use the COUNT function to calculate the total number of clubs based on the ""club.Club_ID"". 3. Condition Structure: No specific filtering condition is required as we want the total count of all clubs. 4. Join Structure: No JOIN is necessary since all relevant information is in the ""club"" table.",1.0
234,Find the the name of the oldest director.,EASY,bbc_channels,"[director.Name, director.Age]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
",SELECT director.Name FROM director ORDER BY director.Age DESC LIMIT 1;,SELECT name FROM director ORDER BY age DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""director.Name"" of the oldest director. 2. Condition Structure: No specific filtering condition is required since we are looking for the director with the maximum age. 3. Join Structure: No JOIN is necessary as all relevant information is available in the ""director"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""director.Age"" to rank directors by age and apply LIMIT 1 to select the oldest director.",1.0
235,"List the last names of the students whose gender is ""F"" or ""M"".",EASY,online_exams,"[Students.Last_Name, Students.Gender_MFU]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Students.Last_Name FROM Students WHERE Students.Gender_MFU = 'F' OR Students.Gender_MFU = 'M';,"SELECT Last_Name FROM Students WHERE Gender_MFU  =  ""F"" OR Gender_MFU  =  ""M""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.Last_Name"" of students. 2. Condition Structure: Use a WHERE clause to filter students whose gender is either ""F"" or ""M"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Students"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving last names based on a specific condition.",1.0
236,"For all products sold more than 3 times, what are their ids and descriptions?",NON-NESTED,e_commerce,"[Order_Items.product_id,Order_Items.order_item_id,Shipment_Items.order_item_id = Order_Items.order_item_id,Products.product_id,Products.product_description]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Products.product_id, Products.product_description FROM Order_Items JOIN Shipment_Items ON Shipment_Items.order_item_id = Order_Items.order_item_id JOIN Products ON Order_Items.product_id = Products.product_id GROUP BY Products.product_id, Products.product_description HAVING COUNT(Order_Items.product_id) > 3;","SELECT T1.product_id ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id GROUP BY T1.product_id HAVING count(*)  >  3","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Products.product_id"" and ""Products.product_description."" 2. Condition Structure: Use a HAVING clause to filter for products that have been sold more than 3 times. This requires counting the occurrences of each product in the ""Order_Items"" table. 3. Join Structure: Use JOINs to connect the ""Order_Items"" table with the ""Shipment_Items"" table on ""order_item_id"" and then connect the ""Order_Items"" table with the ""Products"" table on ""product_id"" to link products with their descriptions. 4. Aggregation Structure: Use COUNT on ""Order_Items.product_id"" to count the number of times each product has been sold, then filter with HAVING to select products sold more than 3 times.",0.0
237,Show names of clubs in descending order of average earnings of players belonging.,NON-NESTED,soccer_3,"[club.Name, player.Earnings, player.Club_ID = club.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
","SELECT club.Name, AVG(player.Earnings) AS AverageEarnings FROM club JOIN player ON player.Club_ID = club.Club_ID GROUP BY club.Name ORDER BY AverageEarnings DESC;",SELECT T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID GROUP BY T1.Club_ID ORDER BY avg(T2.Earnings) DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""club.Name"" and the average earnings of players. Use an aggregate function (AVG) on ""player.Earnings"" to calculate the average earnings for each club. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""club"" and ""player"" tables based on the relationship ""player.Club_ID = club.Club_ID"" to associate players with their respective clubs. 4. Aggregation Structure: Use AVG to calculate the average earnings of players for each club, then GROUP BY ""club.Name"" to group the results by club. Finally, use ORDER BY in descending order on the average earnings to sort the results.",1.0
238,List the invoice dates and ids of the invoices causing at least 2 shipments.,NON-NESTED,e_commerce,"[Invoices.invoice_date, Invoices.invoice_number, Shipments.invoice_number, Shipments.shipment_id, Shipment_Items.shipment_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Invoices.invoice_date, Invoices.invoice_number FROM Invoices JOIN Shipments ON Invoices.invoice_number = Shipments.invoice_number JOIN Shipment_Items ON Shipments.shipment_id = Shipment_Items.shipment_id GROUP BY Invoices.invoice_date, Invoices.invoice_number HAVING COUNT(Shipments.shipment_id) >= 2;","SELECT T1.invoice_date ,  T1.invoice_number FROM Invoices AS T1 JOIN Shipments AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number HAVING count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve ""Invoices.invoice_date"" and ""Invoices.invoice_number."" 2. Condition Structure: Use a HAVING clause to filter for invoices that are associated with at least 2 shipments. 3. Join Structure: Use JOINs to connect ""Invoices"" with ""Shipments"" on ""invoice_number"" and ""Shipments"" with ""Shipment_Items"" on ""shipment_id"" to link invoices with their respective shipments. 4. Aggregation Structure: Use COUNT on ""Shipments.shipment_id"" to count the number of shipments per invoice, then filter with HAVING to select invoices with at least 2 shipments.",0.0
239,How many drivers have raced in 'NASCAR'?,NON-NESTED,vehicle_driver,"[driver.Driver_ID,driver.Racing_Series,vehicle_driver.Driver_ID = driver.Driver_ID,NASCAR]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT COUNT(DISTINCT driver.Driver_ID) FROM driver JOIN vehicle_driver ON vehicle_driver.Driver_ID = driver.Driver_ID WHERE driver.Racing_Series = 'NASCAR';,SELECT count(*) FROM driver WHERE Racing_Series  =  'NASCAR',"1. Sequential Structure: Start with the SELECT clause to count the number of distinct ""driver.Driver_ID"" who have raced in the ""NASCAR"" series. 2. Condition Structure: Use a WHERE clause to filter for drivers whose ""Racing_Series"" is ""NASCAR."" 3. Join Structure: Use a JOIN between the ""driver"" and ""vehicle_driver"" tables based on the ""Driver_ID"" field to link drivers with their racing records. 4. Aggregation Structure: Use COUNT with DISTINCT to ensure that each driver is only counted once.",1.0
240,Show the transmitters of radios whose ERP is bigger than 150 or smaller than 30.,EASY,tv_shows,"[radio.Transmitter,radio.ERP_kW,150,30]","Table city_channel, columns = [*,ID,City,Station_name,Owned_Since,Affiliation]
Table city_channel_radio, columns = [*,City_channel_ID,Radio_ID,Is_online]
Table city_channel_tv_show, columns = [*,City_channel_ID,tv_show_ID,Is_online,Is_free]
Table radio, columns = [*,Radio_ID,Transmitter,Radio_MHz,2FM_MHz,RnaG_MHz,Lyric_FM_MHz,ERP_kW]
Table tv_show, columns = [*,tv_show_ID,tv_show_name,Sub_tittle,Next_show_name,Original_Airdate]
","Foreign_keys = [city_channel_radio.Radio_ID = radio.Radio_ID,city_channel_radio.City_channel_ID = city_channel.ID,city_channel_tv_show.tv_show_ID = tv_show.tv_show_ID,city_channel_tv_show.City_channel_ID = city_channel.ID]
",SELECT radio.Transmitter FROM radio WHERE radio.ERP_kW > 150 OR radio.ERP_kW < 30;,SELECT Transmitter FROM radio WHERE ERP_kW  >  150 OR ERP_kW  <  30,"1. Sequential Structure: Start with the SELECT clause to specify the ""radio.Transmitter"" field, as the question asks for the transmitters of radios. 2. Condition Structure: Use a WHERE clause to filter radios where the ""radio.ERP_kW"" is either greater than 150 or less than 30. 3. Join Structure: No JOIN is required since all necessary information is in the ""radio"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving transmitters that meet the specified ERP condition.",1.0
241,"WHat are the first and last names, and middle initials of all customers who did not make any orders?",NESTED,e_commerce,"[Customers.customer_first_name, Customers.customer_last_name, Customers.customer_middle_initial, Customers.customer_id, Orders.customer_id = Customers.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.customer_first_name, Customers.customer_last_name, Customers.customer_middle_initial FROM Customers WHERE Customers.customer_id NOT IN (SELECT Orders.customer_id FROM Orders);","SELECT customer_first_name ,  customer_middle_initial ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_middle_initial ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id","1. Sequential Structure: Start with the SELECT clause to retrieve the first name, last name, and middle initial of customers. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter customers who did not make any orders. 2. Condition Structure: Use the WHERE clause with a subquery to exclude customers whose customer_id appears in the Orders table, indicating they have made orders. 3. Join Structure: Not required, as we only need to filter based on the absence of matching customer_id entries in the Orders table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
242,How much do the products cost on average?,EASY,e_commerce,[Products.product_price],"Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT AVG(Products.product_price) AS average_price FROM Products;,SELECT avg(product_price) FROM Products,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average product price. 2. Aggregation Structure: Use the AVG function to calculate the average price of the products. 3. Condition Structure: No specific filtering condition is required as the query asks for the average price of all products. 4. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table.",1.0
243,Sort the student answer texts in descending order of their frequency of occurrence.,EASY,online_exams,[Student_Answers.Student_Answer_Text],"Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Student_Answers.Student_Answer_Text, COUNT(*) AS frequency FROM Student_Answers GROUP BY Student_Answers.Student_Answer_Text ORDER BY frequency DESC;",SELECT Student_Answer_Text FROM Student_Answers GROUP BY Student_Answer_Text ORDER BY COUNT(*) DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the ""Student_Answers.Student_Answer_Text"" and the count of its occurrences. 2. Aggregation Structure: Use COUNT to calculate the frequency of each ""Student_Answers.Student_Answer_Text"". 3. Grouping Structure: Use GROUP BY on ""Student_Answers.Student_Answer_Text"" to group the results by each unique answer text. 4. Ordering Structure: Use ORDER BY in descending order on the count to sort the answer texts by their frequency of occurrence. 5. Join Structure: No JOIN is required since all necessary data is within the ""Student_Answers"" table.",1.0
244,Show all driver names in the alphabetical order.,EASY,vehicle_driver,[driver.Name],"Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT driver.Name FROM driver ORDER BY driver.Name ASC;,SELECT name FROM driver ORDER BY name,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Name"" field, as the question asks for all driver names. 2. Condition Structure: No specific filtering condition is required since we want all driver names. 3. Join Structure: No JOIN is necessary because all the required data is in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the driver names in alphabetical order.",1.0
245,How many different comments are there for student answers?,EASY,online_exams,[Student_Answers.Comments],"Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT COUNT(DISTINCT Student_Answers.Comments) AS unique_comments_count FROM Student_Answers;,SELECT count(DISTINCT Comments) FROM Student_Answers,"1. Sequential Structure: Begin with the SELECT clause to count the distinct comments in the ""Student_Answers"" table. 2. Condition Structure: No specific filtering condition is required since we are interested in all comments. 3. Join Structure: No JOIN is necessary as the required data is available within the ""Student_Answers"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique comments in the ""Student_Answers.Comments"" field.",1.0
246,"List all the distinct student answer texts to which comments ""Normal"" were given?",EASY,online_exams,"[Student_Answers.Student_Answer_Text,Student_Answers.Comments]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT DISTINCT Student_Answers.Student_Answer_Text FROM Student_Answers WHERE Student_Answers.Comments = 'Normal';,"SELECT DISTINCT Student_Answer_Text FROM Student_Answers WHERE Comments  =  ""Normal""","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Student_Answers.Student_Answer_Text"" values. 2. Condition Structure: Use a WHERE clause to filter for rows where ""Student_Answers.Comments"" is equal to ""Normal"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Student_Answers"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct values based on a specific condition.",1.0
247,How many different item status codes are there listed in ordered items?,EASY,e_commerce,[Order_Items.order_item_status_code],"Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
",SELECT COUNT(DISTINCT Order_Items.order_item_status_code) AS distinct_status_codes FROM Order_Items;,SELECT count(DISTINCT order_item_status_code) FROM Order_items,"1. Sequential Structure: Start with the SELECT clause to count the distinct item status codes in the ""Order_Items"" table. 2. Condition Structure: No specific filtering condition is required as we are interested in all item status codes. 3. Join Structure: No JOIN is necessary since all required data is within the ""Order_Items"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique item status codes.",1.0
248,"Show the student answer texts that received both ""Normal"" and ""Absent"" as comments.",NESTED,online_exams,"[Student_Answers.Student_Answer_Text,Student_Answers.Comments]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Student_Answer_Text FROM Student_Answers WHERE Comments IN ('Normal', 'Absent') GROUP BY Student_Answer_Text HAVING COUNT(DISTINCT Comments) = 2;","SELECT Student_Answer_Text FROM Student_Answers WHERE Comments  =  ""Normal"" INTERSECT SELECT Student_Answer_Text FROM Student_Answers WHERE Comments  =  ""Absent""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student_Answer_Text"" from the ""Student_Answers"" table. Use the FROM clause to specify the ""Student_Answers"" table. Apply a WHERE clause to filter for answer texts that have received both ""Normal"" and ""Absent"" as comments. 2. Condition Structure: Use the WHERE clause with a subquery to identify ""Student_Answer_Text"" entries that have both ""Normal"" and ""Absent"" in the ""Comments"" column. Use a GROUP BY clause to group by ""Student_Answer_Text"" and a HAVING clause to ensure both comments exist for the same answer text. 3. Join Structure: Not required, as all data is in the ""Student_Answers"" table. 4. Aggregation Structure: Use COUNT(DISTINCT Comments) in the HAVING clause to ensure that both ""Normal"" and ""Absent"" comments are associated with the same ""Student_Answer_Text"".",1.0
249,What is the number of distinct countries of all players?,EASY,soccer_3,[player.Country],"Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT COUNT(DISTINCT player.Country) AS distinct_countries FROM player;,SELECT COUNT (DISTINCT Country) FROM player,"1. Sequential Structure: Begin with the SELECT clause to count the number of distinct countries from the ""player"" table. 2. Condition Structure: No specific filtering condition is required as we are interested in all countries. 3. Join Structure: No JOIN is necessary since all required data is within the ""player"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to calculate the number of unique countries.",1.0
250,What are the name and citizenship of the drivers who have driven the vehicle model 'DJ1'?,NON-NESTED,vehicle_driver,"[driver.Name, driver.Citizenship, vehicle.Model, vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID, vehicle_driver.Driver_ID = driver.Driver_ID, DJ1]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT driver.Name, driver.Citizenship FROM vehicle_driver JOIN vehicle ON vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID JOIN driver ON vehicle_driver.Driver_ID = driver.Driver_ID WHERE vehicle.Model = 'DJ1';","SELECT T1.name ,  T1.citizenship FROM driver AS T1 JOIN vehicle_driver AS T2 ON T1.driver_id  =  T2.driver_id JOIN vehicle AS T3 ON T2.vehicle_id  =  T3.vehicle_id WHERE T3.model  =  'DJ1'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Name"" and ""driver.Citizenship."" 2. Condition Structure: Use a WHERE clause to filter for vehicles with the model ""DJ1."" 3. Join Structure: Use JOINs to connect the ""vehicle_driver"" table with the ""vehicle"" table on ""vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID"" and the ""vehicle_driver"" table with the ""driver"" table on ""vehicle_driver.Driver_ID = driver.Driver_ID"" to link drivers with their respective vehicles. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without any summarization.",1.0
251,"What are the statuses, dates, and shipment dates for all invoices?",NON-NESTED,e_commerce,"[Invoices.invoice_status_code, Invoices.invoice_date, Shipments.shipment_date, Shipments.invoice_number = Invoices.invoice_number]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Invoices.invoice_status_code, Invoices.invoice_date, Shipments.shipment_date FROM Invoices JOIN Shipments ON Shipments.invoice_number = Invoices.invoice_number;","SELECT T1.invoice_status_code ,  T1.invoice_date ,  T2.shipment_date FROM Invoices AS T1 JOIN Shipments AS T2 ON T1.invoice_number  =  T2.invoice_number","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Invoices.invoice_status_code,"" ""Invoices.invoice_date,"" and ""Shipments.shipment_date."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Invoices"" and ""Shipments"" tables based on the relationship ""Shipments.invoice_number = Invoices.invoice_number"" to link invoices with their corresponding shipment details. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the specified fields for all records.",1.0
252,What are the names of clubs that do not have any players?,NESTED,soccer_3,"[club.Name, player.Club_ID, club.Club_ID = player.Club_ID]","Table club, columns = [*,Club_ID,Name,Manager,Captain,Manufacturer,Sponsor]
Table player, columns = [*,Player_ID,Name,Country,Earnings,Events_number,Wins_count,Club_ID]
","Foreign_keys = [player.Club_ID = club.Club_ID]
",SELECT club.Name FROM club WHERE club.Club_ID NOT IN (SELECT player.Club_ID FROM player);,SELECT Name FROM club WHERE Club_ID NOT IN (SELECT Club_ID FROM player),"1. Sequential Structure: Begin with the SELECT clause to retrieve the names of clubs. Use the FROM clause to specify the club table. Apply a WHERE clause to filter clubs that do not have any players by ensuring that the Club_ID of the club is not present in the player table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude clubs whose Club_ID appears in the player table, meaning they have players. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Club_ID entries in the player table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
253,Show all hardware type products in ascending order of price.,EASY,customers_and_orders,"[Products.product_name, Products.product_price, Products.product_type_code]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_name, Products.product_price FROM Products WHERE Products.product_type_code = 'hardware' ORDER BY Products.product_price ASC;","SELECT product_name FROM Products WHERE product_type_code  =  ""Hardware"" ORDER BY product_price ASC","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the product name and product price. 2. Condition Structure: Use a WHERE clause to filter for products of type ""hardware."" 3. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table. 4. Ordering Structure: Use ORDER BY in ascending order on ""Products.product_price"" to sort the results by price. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data.",0.0
254,Return the ids and models of vehicles that have been driven by more than 2 drivers or been driven by the Jeff Gordon.,NESTED,vehicle_driver,"[vehicle.Vehicle_ID,vehicle.Model,vehicle_driver.Vehicle_ID,vehicle_driver.Driver_ID,driver.Driver_ID,driver.Name,vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID,Jeff Gordon]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
","SELECT DISTINCT vehicle.Vehicle_ID, vehicle.Model FROM vehicle JOIN vehicle_driver ON vehicle.Vehicle_ID = vehicle_driver.Vehicle_ID JOIN driver ON vehicle_driver.Driver_ID = driver.Driver_ID WHERE vehicle.Vehicle_ID IN ( SELECT vehicle_driver.Vehicle_ID FROM vehicle_driver GROUP BY vehicle_driver.Vehicle_ID HAVING COUNT(vehicle_driver.Driver_ID) > 2 ) OR driver.Name = 'Jeff Gordon';","SELECT T1.vehicle_id ,  T1.model FROM vehicle AS T1 JOIN vehicle_driver AS T2 ON T1.vehicle_id  =  T2.vehicle_id JOIN driver AS T3 ON T2.driver_id  =  T3.driver_id WHERE T3.name  =  'Jeff Gordon' UNION SELECT T1.vehicle_id ,  T1.model FROM vehicle AS T1 JOIN vehicle_driver AS T2 ON T1.vehicle_id  =  T2.vehicle_id GROUP BY T2.vehicle_id HAVING count(*)  >  2","1. Sequential Structure: Start with the SELECT clause to retrieve the Vehicle_ID and Model of vehicles. Use the FROM clause to specify the vehicle table and JOIN it with the vehicle_driver and driver tables to connect vehicles with their drivers. Apply a WHERE clause to filter vehicles that have been driven by more than 2 drivers or by the driver named ""Jeff Gordon"". 2. Condition Structure: Use the WHERE clause with two conditions: one to filter vehicles driven by more than 2 drivers using GROUP BY and HAVING, and another to filter vehicles driven by ""Jeff Gordon"" using a subquery or direct condition on the driver's name. 3. Join Structure: Use INNER JOINs between the vehicle, vehicle_driver, and driver tables based on Vehicle_ID and Driver_ID to connect vehicles with their drivers and driver details. 4. Aggregation Structure: Use COUNT(*) in the HAVING clause to count the number of drivers per vehicle and filter for vehicles with more than 2 drivers.",1.0
255,Which types of questions have 3 or more questions? Return the questions type code.,EASY,online_exams,"[Questions.Type_of_Question_Code, Questions.Question_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Questions.Type_of_Question_Code FROM Questions GROUP BY Questions.Type_of_Question_Code HAVING COUNT(Questions.Question_ID) >= 3;,SELECT Type_of_Question_Code FROM Questions GROUP BY Type_of_Question_Code HAVING count(*)  >=  3,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""Type_of_Question_Code"". 2. Aggregation Structure: Use COUNT to determine the number of questions for each type of question code. 3. Grouping Structure: Use GROUP BY on ""Questions.Type_of_Question_Code"" to aggregate the results by each type of question code. 4. Condition Structure: Apply the HAVING clause to filter for question types that have 3 or more questions, by setting the count to be greater than or equal to 3. 5. Join Structure: No JOIN is required since all necessary data is within the ""Questions"" table.",1.0
256,How many addresses do we have?,EASY,customers_and_orders,[Addresses.address_id],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(Addresses.address_id) AS total_addresses FROM Addresses;,SELECT count(*) FROM Addresses,"1. Sequential Structure: Begin with the SELECT clause to count the total number of addresses. 2. Condition Structure: No specific filtering condition is required as we want the total count of all addresses. 3. Join Structure: No JOIN is necessary since all required data is within the ""Addresses"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of addresses.",1.0
257,What is the id of the vehicle driven for the least times for the vehicles ever used?,NESTED,vehicle_driver,"[vehicle.Vehicle_ID, vehicle_driver.Vehicle_ID, vehicle_driver.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT vehicle_driver.Vehicle_ID FROM vehicle_driver GROUP BY vehicle_driver.Vehicle_ID ORDER BY COUNT(vehicle_driver.Driver_ID) ASC LIMIT 1;,SELECT vehicle_id FROM vehicle_driver GROUP BY vehicle_id ORDER BY count(*) ASC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the Vehicle_ID of the vehicle driven the least number of times. Use the FROM clause to specify the vehicle_driver table, as it contains the relationship between vehicles and drivers. Use GROUP BY to group by Vehicle_ID and COUNT to calculate the number of times each vehicle was driven. Use ORDER BY to sort the counts in ascending order and LIMIT 1 to get the vehicle driven the least number of times. 2. Condition Structure: No specific filtering condition is required, as we are considering all vehicles that have been used. 3. Join Structure: No JOIN is required, as the necessary data is available in the vehicle_driver table. 4. Aggregation Structure: Use COUNT to calculate the number of times each vehicle was driven and ORDER BY to sort the results to find the vehicle with the least count.",1.0
258,"Which customers did not make any orders? List the first name, middle initial and last name.",NESTED,e_commerce,"[Customers.customer_first_name, Customers.customer_middle_initial, Customers.customer_last_name, Orders.customer_id = Customers.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customers.customer_first_name, Customers.customer_middle_initial, Customers.customer_last_name FROM Customers WHERE Customers.customer_id NOT IN (SELECT Orders.customer_id FROM Orders);","SELECT customer_first_name ,  customer_middle_initial ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_middle_initial ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id","1. Sequential Structure: Start with the SELECT clause to retrieve the first name, middle initial, and last name of customers. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter customers who did not make any orders by ensuring their customer_id is not present in the Orders table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude customers whose customer_id appears in the Orders table, meaning they have made orders. 3. Join Structure: Not required, as we only need to filter based on the absence of matching customer_id entries in the Orders table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
259,"Find the exams whose subject code is not ""Database"". What are the exam dates and exam names?",EASY,online_exams,"[Exams.Subject_Code, Exams.Exam_Date, Exams.Exam_Name]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Exams.Exam_Date, Exams.Exam_Name FROM Exams WHERE Exams.Subject_Code != 'Database';","SELECT Exam_Date ,  Exam_Name FROM Exams WHERE Subject_Code != 'Database'","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Exams.Exam_Date"" and ""Exams.Exam_Name"". 2. Condition Structure: Use a WHERE clause to filter out exams where the ""Exams.Subject_Code"" is ""Database"". 3. Join Structure: No JOIN is required since all necessary data is within the ""Exams"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the exam dates and names based on the specified condition.",1.0
260,Which students have 2 or more answer records? Give me their first names.,NON-NESTED,online_exams,"[Student_Answers.Student_ID,Students.First_Name,Student_Answers.Student_ID = Students.Student_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
",SELECT Students.First_Name FROM Student_Answers JOIN Students ON Student_Answers.Student_ID = Students.Student_ID GROUP BY Student_Answers.Student_ID HAVING COUNT(Student_Answers.Student_ID) >= 2;,SELECT T2.First_Name FROM Student_Answers AS T1 JOIN Students AS T2 ON T1.Student_ID  =  T2.Student_ID GROUP BY T1.Student_ID HAVING COUNT(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.First_Name"" of students who have 2 or more answer records. Use GROUP BY on ""Student_Answers.Student_ID"" to group the records by each student. 2. Condition Structure: Apply a HAVING clause to filter for students with 2 or more answer records by counting the occurrences of ""Student_Answers.Student_ID."" 3. Join Structure: Use an INNER JOIN between the ""Student_Answers"" table and the ""Students"" table on ""Student_Answers.Student_ID = Students.Student_ID"" to link each answer record to the corresponding student. 4. Aggregation Structure: Use COUNT on ""Student_Answers.Student_ID"" to count the number of answer records for each student, and filter with HAVING to include only those with 2 or more records.",1.0
261,What are the status codes and dates placed for all of the orders?,EASY,e_commerce,"[Orders.order_status_code, Orders.date_order_placed]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Orders.order_status_code, Orders.date_order_placed FROM Orders;","SELECT order_status_code ,  date_order_placed FROM Orders","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Orders.order_status_code"" and ""Orders.date_order_placed"". 2. Condition Structure: No specific filtering condition is required as the query asks for all orders. 3. Join Structure: No JOIN is required since all necessary data is within the ""Orders"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the status codes and dates for all orders.",1.0
262,Give the models of cars that have a total production of over 100 or a top speed over 150.,EASY,vehicle_driver,"[vehicle.Model, vehicle.Total_Production, vehicle.Top_Speed]","Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT vehicle.Model FROM vehicle WHERE vehicle.Total_Production > 100 OR vehicle.Top_Speed > 150;,SELECT model FROM vehicle WHERE total_production  >  100 OR top_speed  >  150,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the ""vehicle.Model"". 2. Condition Structure: Use a WHERE clause to filter for cars that either have a ""vehicle.Total_Production"" greater than 100 or a ""vehicle.Top_Speed"" greater than 150. 3. Join Structure: No JOIN is required since all necessary data is within the ""vehicle"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving models that meet the specified conditions.",1.0
263,Please show the email addresses of students and the dates of their answers in descending order of dates.,NON-NESTED,online_exams,"[Students.Email_Adress, Student_Answers.Date_of_Answer, Student_Answers.Student_ID = Students.Student_ID]","Table Exams, columns = [*,Exam_ID,Subject_Code,Exam_Date,Exam_Name]
Table Questions, columns = [*,Question_ID,Type_of_Question_Code,Question_Text]
Table Questions_in_Exams, columns = [*,Exam_ID,Question_ID]
Table Student_Answers, columns = [*,Student_Answer_ID,Exam_ID,Question_ID,Student_ID,Date_of_Answer,Comments,Satisfactory_YN,Student_Answer_Text]
Table Student_Assessments, columns = [*,Student_Answer_ID,Valid_Answer_ID,Student_Answer_Text,Satisfactory_YN,Assessment]
Table Students, columns = [*,Student_ID,First_Name,Middle_Name,Last_Name,Gender_MFU,Student_Address,Email_Adress,Cell_Mobile_Phone,Home_Phone]
Table Valid_Answers, columns = [*,Valid_Answer_ID,Question_ID,Valid_Answer_Text]
","Foreign_keys = [Questions_in_Exams.Exam_ID = Exams.Exam_ID,Questions_in_Exams.Question_ID = Questions.Question_ID,Valid_Answers.Question_ID = Questions.Question_ID,Student_Answers.Exam_ID = Questions_in_Exams.Exam_ID,Student_Answers.Question_ID = Questions_in_Exams.Question_ID,Student_Answers.Student_ID = Students.Student_ID,Student_Assessments.Valid_Answer_ID = Valid_Answers.Valid_Answer_ID]
","SELECT Students.Email_Adress, Student_Answers.Date_of_Answer FROM Students JOIN Student_Answers ON Student_Answers.Student_ID = Students.Student_ID ORDER BY Student_Answers.Date_of_Answer DESC;","SELECT T2.Email_Adress ,  T1.Date_of_Answer FROM Student_Answers AS T1 JOIN Students AS T2 ON T1.Student_ID  =  T2.Student_ID ORDER BY T1.Date_of_Answer DESC","1. Sequential Structure: Start with the SELECT clause to retrieve ""Students.Email_Adress"" and ""Student_Answers.Date_of_Answer."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Students"" and ""Student_Answers"" tables based on the shared key ""Student_Answers.Student_ID = Students.Student_ID"" to link each student's email address with their answers. 4. Aggregation Structure: No aggregation is required, but apply ORDER BY in descending order on ""Student_Answers.Date_of_Answer"" to sort the results by the dates of the answers.",1.0
264,Return the title of the program that began most recently.,EASY,bbc_channels,"[program.Title, program.Start_Year]","Table channel, columns = [*,Channel_ID,Name,Analogue_terrestrial_channel,Digital_terrestrial_channel,Internet]
Table director, columns = [*,Director_ID,Name,Age]
Table director_admin, columns = [*,Director_ID,Channel_ID,Is_first_director]
Table program, columns = [*,Program_ID,Start_Year,Title,Director_ID,Channel_ID]
","Foreign_keys = [program.Channel_ID = channel.Channel_ID,program.Director_ID = director.Director_ID,director_admin.Channel_ID = channel.Channel_ID,director_admin.Director_ID = director.Director_ID]
",SELECT program.Title FROM program ORDER BY program.Start_Year DESC LIMIT 1;,SELECT title FROM program ORDER BY start_year DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the program title. 2. Condition Structure: No specific filtering condition is required, as we are looking for the program that began most recently. 3. Join Structure: No JOIN is required since all necessary data is within the ""program"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""program.Start_Year"" to rank programs by their start year. Apply LIMIT 1 to retrieve the most recent program.",1.0
265,"What are the names of drivers, returned in alphbetical order?",EASY,vehicle_driver,[driver.Name],"Table driver, columns = [*,Driver_ID,Name,Citizenship,Racing_Series]
Table vehicle, columns = [*,Vehicle_ID,Model,Build_Year,Top_Speed,Power,Builder,Total_Production]
Table vehicle_driver, columns = [*,Driver_ID,Vehicle_ID]
","Foreign_keys = [vehicle_driver.Vehicle_ID = vehicle.Vehicle_ID,vehicle_driver.Driver_ID = driver.Driver_ID]
",SELECT driver.Name FROM driver ORDER BY driver.Name ASC;,SELECT name FROM driver ORDER BY name,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""driver.Name"". 2. Condition Structure: No specific filtering condition is required as we want all driver names. 3. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the names. 5. Ordering Structure: Use ORDER BY to sort the driver names in alphabetical order.",1.0
266,"Show the minimum, average, maximum price for all products.",EASY,customers_and_orders,[Products.product_price],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT MIN(Products.product_price) AS min_price, AVG(Products.product_price) AS avg_price, MAX(Products.product_price) AS max_price FROM Products;","SELECT min(product_price) ,  avg(product_price) ,  max(product_price) FROM Products","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the minimum, average, and maximum prices of all products. 2. Aggregation Structure: Use MIN, AVG, and MAX functions to calculate the minimum, average, and maximum prices respectively. 3. Condition Structure: No specific filtering condition is required as the query applies to all products. 4. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table.",1.0
267,What is the most popular payment method?,NON-NESTED,e_commerce,"[Customer_Payment_Methods.payment_method_code,Customer_Payment_Methods.customer_id = Customers.customer_id]","Table Customer_Payment_Methods, columns = [*,customer_id,payment_method_code]
Table Customers, columns = [*,customer_id,gender_code,customer_first_name,customer_middle_initial,customer_last_name,email_address,login_name,login_password,phone_number,address_line_1,town_city,county,country]
Table Invoices, columns = [*,invoice_number,invoice_status_code,invoice_date]
Table Order_Items, columns = [*,order_item_id,product_id,order_id,order_item_status_code]
Table Orders, columns = [*,order_id,customer_id,order_status_code,date_order_placed]
Table Products, columns = [*,product_id,parent_product_id,product_name,product_price,product_color,product_size,product_description]
Table Shipment_Items, columns = [*,shipment_id,order_item_id]
Table Shipments, columns = [*,shipment_id,order_id,invoice_number,shipment_tracking_number,shipment_date]
","Foreign_keys = [Customer_Payment_Methods.customer_id = Customers.customer_id,Orders.customer_id = Customers.customer_id,Order_Items.order_id = Orders.order_id,Order_Items.product_id = Products.product_id,Shipments.order_id = Orders.order_id,Shipments.invoice_number = Invoices.invoice_number,Shipment_Items.order_item_id = Order_Items.order_item_id,Shipment_Items.shipment_id = Shipments.shipment_id]
","SELECT Customer_Payment_Methods.payment_method_code, COUNT(*) AS method_count FROM Customer_Payment_Methods GROUP BY Customer_Payment_Methods.payment_method_code ORDER BY method_count DESC LIMIT 1;",SELECT Payment_method_code FROM Customer_Payment_Methods GROUP BY Payment_method_code ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""payment_method_code"" and use COUNT to determine the frequency of each payment method. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all payment methods. 3. Join Structure: No JOIN is required since the relevant data is contained within the ""Customer_Payment_Methods"" table. 4. Aggregation Structure: Use COUNT to calculate the frequency of each payment method, GROUP BY ""payment_method_code"" to group the results by payment method, and ORDER BY in descending order to rank the payment methods by popularity. Use LIMIT 1 to select the most popular payment method.",1.0
268,"Find the name of all the services which either have been used by customer ""Hardy Kutch"" or have been rated as ""good"" in one of the customer interactions.",NESTED,government_shift,"[Services.Service_Details,Customers.Customer_Details,Customer_Interactions.Status_Code,Customers_and_Services.Service_ID = Services.Service_ID,Customers_and_Services.Customer_ID = Customers.Customer_ID,Customer_Interactions.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Hardy Kutch,good]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT DISTINCT Services.Service_Details FROM Services JOIN Customers_and_Services ON Customers_and_Services.Service_ID = Services.Service_ID JOIN Customers ON Customers.Customer_ID = Customers_and_Services.Customer_ID LEFT JOIN Customer_Interactions ON Customer_Interactions.Service_ID = Services.Service_ID AND Customer_Interactions.Customer_ID = Customers.Customer_ID WHERE Customers.Customer_Details = 'Hardy Kutch' OR Customer_Interactions.Status_Code = 'good';,"SELECT DISTINCT t3.service_details FROM customers AS t1 JOIN customers_and_services AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id JOIN customer_interactions AS t4 ON t3.service_id  =  t4.service_id WHERE t1.customer_details  =  ""Hardy Kutch"" OR t4.services_and_channels_details  =  ""good""","1. Sequential Structure: Start with the SELECT clause to retrieve the names of services. Use the FROM clause to specify the Services table. Use JOINs to connect the Services table with Customers, Customers_and_Services, and Customer_Interactions tables to establish relationships between services, customers, and their interactions. Apply a WHERE clause to filter services that either have been used by the customer ""Hardy Kutch"" or have been rated as ""good"" in one of the customer interactions. 2. Condition Structure: Use the WHERE clause with two conditions combined using OR. The first condition checks for services used by ""Hardy Kutch"" by matching the customer name. The second condition checks for services rated as ""good"" in the Customer_Interactions table. 3. Join Structure: Use JOINs to connect the Services table with Customers_and_Services, Customers, and Customer_Interactions tables based on their respective keys (Service_ID and Customer_ID) to establish the necessary relationships. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
269,Show the completed years of buildings in descending order of the number of stories.,EASY,region_building,"[building.Completed_Year, building.Number_of_Stories]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
","SELECT building.Completed_Year, building.Number_of_Stories FROM building ORDER BY building.Number_of_Stories DESC;",SELECT Completed_Year FROM building ORDER BY Number_of_Stories DESC,"1. Sequential Structure: Start with the SELECT clause to specify the ""building.Completed_Year"" and ""building.Number_of_Stories"" fields. 2. Condition Structure: No specific filtering condition is required as we want all buildings. 3. Join Structure: No JOIN is required since all necessary information is in the ""building"" table. 4. Ordering Structure: Use ORDER BY in descending order on ""building.Number_of_Stories"" to sort the results by the number of stories. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data.",1.0
270,Which type of powertrain is most common?,EASY,vehicle_rent,[Vehicles.Type_of_powertrain],"Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT Vehicles.Type_of_powertrain FROM Vehicles GROUP BY Vehicles.Type_of_powertrain ORDER BY COUNT(*) DESC LIMIT 1;,SELECT type_of_powertrain FROM vehicles GROUP BY type_of_powertrain ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the type of powertrain, as the question asks for the most common type. 2. Aggregation Structure: Use COUNT to calculate the number of occurrences of each type of powertrain. 3. Grouping Structure: Use GROUP BY on ""Vehicles.Type_of_powertrain"" to group the results by each powertrain type. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank the powertrain types by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common type of powertrain. 6. Join Structure: No JOIN is required since all necessary data is within the ""Vehicles"" table.",1.0
271,What are the start time and end time of addresses for the students who receive 2 transcripts?,NON-NESTED,cre_Students_Information_Systems,"[Transcripts.student_id, Transcripts.transcript_id, Students_Addresses.date_from, Students_Addresses.date_to, Students_Addresses.student_id = Students.student_id, Transcripts.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students_Addresses.date_from, Students_Addresses.date_to FROM Students JOIN Transcripts ON Transcripts.student_id = Students.student_id JOIN Students_Addresses ON Students_Addresses.student_id = Students.student_id GROUP BY Students.student_id, Students_Addresses.date_from, Students_Addresses.date_to HAVING COUNT(Transcripts.transcript_id) = 2;","SELECT date_from ,  date_to FROM Students_Addresses WHERE student_id IN ( SELECT student_id FROM Transcripts GROUP BY student_id HAVING count(*)  =  2 )","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students_Addresses.date_from"" (start time) and ""Students_Addresses.date_to"" (end time) for the relevant students. 2. Condition Structure: Use a HAVING clause to filter for students who have exactly 2 transcripts. This requires counting the number of transcripts per student. 3. Join Structure: Use JOINs to connect the ""Transcripts"" table with the ""Students"" table on ""Transcripts.student_id = Students.student_id"" and the ""Students"" table with the ""Students_Addresses"" table on ""Students_Addresses.student_id = Students.student_id."" 4. Aggregation Structure: Use COUNT on ""Transcripts.transcript_id"" to count the number of transcripts per student, then filter with HAVING to select students with exactly 2 transcripts.",1.0
272,When was the earliest date of loan?,EASY,cre_Students_Information_Systems,[Student_Loans.date_of_loan],"Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT MIN(Student_Loans.date_of_loan) AS earliest_date FROM Student_Loans;,SELECT date_of_loan FROM Student_Loans ORDER BY date_of_loan ASC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the earliest date of loan. 2. Aggregation Structure: Use the MIN function to find the earliest date from the ""Student_Loans.date_of_loan"" column. 3. Condition Structure: No specific filtering condition is required as we are looking for the minimum date across all records. 4. Join Structure: No JOIN is required since all necessary data is within the ""Student_Loans"" table.",1.0
273,"What are the names of all vehicles, ordered by model year descending?",EASY,vehicle_rent,"[Vehicles.name, Vehicles.Model_year]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, Vehicles.Model_year FROM Vehicles ORDER BY Vehicles.Model_year DESC;",SELECT name FROM vehicles ORDER BY model_year DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the names of the vehicles and their model years. 2. Condition Structure: No specific filtering condition is required as we want all vehicles. 3. Join Structure: No JOIN is required since all necessary data is within the ""Vehicles"" table. 4. Ordering Structure: Use ORDER BY in descending order on ""Vehicles.Model_year"" to sort the vehicles by their model year. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data.",1.0
274,Show all Client names and their addresses.,EASY,book_1,"[Client.Name, Client.Address]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Client.Name, Client.Address FROM Client;","SELECT name ,  address FROM Client","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Client.Name"" and ""Client.Address"". 2. Condition Structure: No specific filtering condition is required as the query asks for all client names and their addresses. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Client"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all client names and their addresses.",1.0
275,"Which services are both used by the customer ""Hardy Kutch"" and are rated as ""bad"" in a customer interaction? Give me the service details.",NESTED,government_shift,"[Customers.Customer_Details,Services.Service_Details,Customer_Interactions.Status_Code,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Service_ID = Services.Service_ID,""Hardy Kutch"",bad]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Services.Service_Details FROM Services JOIN Customer_Interactions ON Customer_Interactions.Service_ID = Services.Service_ID JOIN Customers ON Customer_Interactions.Customer_ID = Customers.Customer_ID WHERE Customers.Customer_Details = 'Hardy Kutch' AND Customer_Interactions.Status_Code = 'bad';,"SELECT DISTINCT t3.service_details FROM customers AS t1 JOIN customers_and_services AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id JOIN customer_interactions AS t4 ON t3.service_id  =  t4.service_id WHERE t1.customer_details  =  ""Hardy Kutch"" AND t4.services_and_channels_details  =  ""bad""","1. Sequential Structure: Start with the SELECT clause to retrieve the service details from the Services table. Use the FROM clause to specify the Services table and join it with the Customer_Interactions and Customers tables to connect service details with customer interactions and customer information. Apply a WHERE clause to filter for interactions where the customer name is ""Hardy Kutch"" and the status code is ""bad"". 2. Condition Structure: Use the WHERE clause to filter for customer interactions where the customer name matches ""Hardy Kutch"" and the status code is ""bad"". 3. Join Structure: Use INNER JOINs between Customers, Customer_Interactions, and Services tables. Join Customers and Customer_Interactions on Customer_ID, and join Customer_Interactions and Services on Service_ID to connect customer details, interactions, and service details. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
276,Show the name and total hours of renting for each vehicle.,NON-NESTED,vehicle_rent,"[Vehicles.name, Renting_history.total_hours, Renting_history.vehicles_id = Vehicles.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, SUM(Renting_history.total_hours) AS total_hours FROM Vehicles JOIN Renting_history ON Renting_history.vehicles_id = Vehicles.id GROUP BY Vehicles.name;","SELECT T2.name ,  sum(T1.total_hours) FROM renting_history AS T1 JOIN vehicles AS T2 ON T1.vehicles_id  =  T2.id GROUP BY T2.id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Vehicles.name"" and the total hours of renting for each vehicle. Use the SUM function on ""Renting_history.total_hours"" to calculate the total hours. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Vehicles"" table and the ""Renting_history"" table based on the relationship ""Renting_history.vehicles_id = Vehicles.id"" to associate each vehicle with its renting history. 4. Aggregation Structure: Use SUM to aggregate the total hours of renting for each vehicle and GROUP BY ""Vehicles.name"" to group the results by vehicle name.",1.0
277,Which students not only got the most common result but also got a result obtained by 3 students in behaviour monitoring? List the student's biographical data and details.,NESTED,cre_Students_Information_Systems,"[Students.bio_data, Students.student_details, Behaviour_Monitoring.student_id, Behaviour_Monitoring.behaviour_monitoring_details, Behaviour_Monitoring.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.bio_data, Students.student_details FROM Students JOIN Behaviour_Monitoring ON Students.student_id = Behaviour_Monitoring.student_id WHERE Behaviour_Monitoring.behaviour_monitoring_details IN ( SELECT behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details HAVING COUNT(student_id) = (SELECT MAX(result_count) FROM (SELECT COUNT(student_id) AS result_count FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details)) ) AND Behaviour_Monitoring.behaviour_monitoring_details IN ( SELECT behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details HAVING COUNT(student_id) = 3 );","SELECT T1.bio_data ,  T1.student_details FROM Students AS T1 JOIN Behaviour_Monitoring AS T2 ON T1.student_id  =  T2.student_id WHERE T2.behaviour_monitoring_details IN ( SELECT behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details ORDER BY count(*) DESC LIMIT 1 ) INTERSECT SELECT T1.bio_data ,  T1.student_details FROM Students AS T1 JOIN Behaviour_Monitoring AS T2 ON T1.student_id  =  T2.student_id WHERE T2.behaviour_monitoring_details IN ( SELECT behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details HAVING count(*)  =  3 )","1. Sequential Structure: Start with the SELECT clause to retrieve the biographical data and details of students. Use the FROM clause to specify the Students table and JOIN it with the Behaviour_Monitoring table to link students with their behavior monitoring results. Use GROUP BY to group behavior monitoring results and COUNT to determine the frequency of each result. Use a subquery to identify the most common result and another subquery to find results obtained by exactly 3 students. Finally, filter students who meet both conditions. 2. Condition Structure: Use WHERE clauses to filter for students who obtained the most common result and a result obtained by exactly 3 students. This involves using subqueries to identify these specific results. 3. Join Structure: Use an INNER JOIN between the Students and Behaviour_Monitoring tables based on student_id to connect student data with their behavior monitoring results. 4. Aggregation Structure: Use COUNT to determine the frequency of behavior monitoring results and identify the most common result and results obtained by exactly 3 students.",0.0
278,Return the number of clients.,EASY,book_1,[Client.IdClient],"Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT COUNT(Client.IdClient) AS number_of_clients FROM Client;,SELECT count(*) FROM Client,"1. Sequential Structure: Start with the SELECT clause to count the number of clients. 2. Condition Structure: No specific filtering condition is required as we want the total number of clients. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Client"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of clients based on the ""Client.IdClient"" field.",1.0
279,"List the achievement type code, achievement details and the date of the achievements.",EASY,cre_Students_Information_Systems,"[Achievements.achievement_type_code, Achievements.achievement_details, Achievements.date_achievement]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Achievements.achievement_type_code, Achievements.achievement_details, Achievements.date_achievement FROM Achievements;","SELECT achievement_type_code ,  achievement_details ,  date_achievement FROM Achievements","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""achievement_type_code,"" ""achievement_details,"" and ""date_achievement."" 2. Condition Structure: No specific filtering condition is required as the query asks for all achievements. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Achievements"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the specified fields.",1.0
280,What is the average age for customers with a membership credit above the average?,NESTED,vehicle_rent,"[Customers.age, Customers.membership_credit]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT AVG(Customers.age) AS average_age FROM Customers WHERE Customers.membership_credit > (SELECT AVG(Customers.membership_credit) FROM Customers);,SELECT avg(age) FROM customers WHERE membership_credit  >  (SELECT avg(membership_credit) FROM customers),"1. Sequential Structure: Start with the SELECT clause to calculate the average age of customers. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter customers whose membership credit is above the average membership credit. 2. Condition Structure: Use the WHERE clause with a subquery to filter customers whose membership_credit is greater than the average membership_credit. 3. Join Structure: Not required, as all data is in the Customers table. 4. Aggregation Structure: Use AVG to calculate the average age of the filtered customers. Use another AVG in the subquery to calculate the average membership_credit.",1.0
281,How many teachers have taught a student who has not won any achievements?,NESTED,cre_Students_Information_Systems,"[Teachers.teacher_id,Classes.teacher_id,Classes.student_id,Students.student_id,Achievements.student_id,Achievements.achievement_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT COUNT(DISTINCT Teachers.teacher_id) AS teacher_count FROM Teachers JOIN Classes ON Teachers.teacher_id = Classes.teacher_id JOIN Students ON Classes.student_id = Students.student_id WHERE Students.student_id NOT IN (SELECT student_id FROM Achievements);,SELECT count(DISTINCT T1.teacher_id) FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id WHERE T2.student_id NOT IN ( SELECT student_id FROM Achievements ),"1. Sequential Structure: Start with the SELECT clause to count the distinct teacher IDs. Use the FROM clause to specify the Teachers table and JOIN it with the Classes table to link teachers with students they have taught. Further, JOIN the Students table to identify students. Use a WHERE clause to filter for students who have not won any achievements by ensuring their student_id is not present in the Achievements table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose student_id appears in the Achievements table, meaning they have won achievements. 3. Join Structure: Use INNER JOINs between Teachers, Classes, and Students tables to connect teachers with the students they have taught. Use a subquery to filter out students with achievements. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique teacher IDs who have taught students without achievements.",1.0
282,What is the product type with least number of products?,EASY,customers_and_orders,"[Products.product_type_code, Products.product_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Products.product_type_code FROM Products GROUP BY Products.product_type_code ORDER BY COUNT(Products.product_id) ASC LIMIT 1;,SELECT product_type_code FROM Products GROUP BY product_type_code ORDER BY count(*) ASC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the product type, as the question asks for the product type with the least number of products. 2. Aggregation Structure: Use COUNT to calculate the number of products for each product type. 3. Grouping Structure: Use GROUP BY on ""Products.product_type_code"" to count the number of products for each product type. 4. Ordering Structure: Use ORDER BY in ascending order on the product count to rank product types by the number of products. 5. Limiting Structure: Use LIMIT 1 to retrieve the product type with the least number of products. 6. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table.",1.0
283,Compute the average population of a region.,EASY,region_building,[region.Population],"Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT AVG(region.Population) AS avg_population FROM region;,SELECT avg(Population) FROM region,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average population. 2. Aggregation Structure: Use the AVG function to calculate the average population of the regions. 3. Condition Structure: No specific filtering condition is required as the query aims to compute the average population for all regions. 4. Join Structure: No JOIN is required since all necessary data is within the ""region"" table.",1.0
284,What are the distinct payment methods used by customers?,EASY,customers_and_orders,[Customers.payment_method_code],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT DISTINCT Customers.payment_method_code FROM Customers;,SELECT DISTINCT payment_method_code FROM Customers,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct payment methods used by customers. 2. Condition Structure: No specific filtering condition is required as we want all distinct payment methods. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Customers"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique payment methods are retrieved.",1.0
285,What are the names of products that have not been ordered?,NESTED,customers_and_orders,"[Products.product_name,Order_Items.product_id,Products.product_id = Order_Items.product_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT product_name FROM Products WHERE product_id NOT IN (SELECT product_id FROM Order_Items);,SELECT product_name FROM Products EXCEPT SELECT T1.product_name FROM Products AS t1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id,"1. Sequential Structure: Start with the SELECT clause to retrieve the product names from the Products table. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter products that have not been ordered by ensuring their product_id is not present in the Order_Items table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude products whose product_id appears in the Order_Items table, meaning they have been ordered. 3. Join Structure: Not required, as we only need to filter based on the absence of matching product_id entries in the Order_Items table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
286,Which services were used by customers by more than 3 times? Give me the service details.,NON-NESTED,government_shift,"[Services.Service_Details,Customer_Interactions.Service_ID,Customer_Interactions.Customer_ID,Customer_Interactions.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Services.Service_Details FROM Customer_Interactions JOIN Services ON Customer_Interactions.Service_ID = Services.Service_ID GROUP BY Customer_Interactions.Service_ID HAVING COUNT(Customer_Interactions.Service_ID) > 3;,SELECT t1.service_details FROM services AS t1 JOIN customers_and_services AS t2 ON t1.service_id  =  t2.service_id GROUP BY t1.service_details HAVING count(*)  >  3,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Services.Service_Details"" field, as the question asks for service details. Use GROUP BY to group the data by ""Customer_Interactions.Service_ID"" to count the number of times each service was used. 2. Condition Structure: Apply a HAVING clause to filter for services that were used more than 3 times. 3. Join Structure: Use a JOIN between ""Customer_Interactions"" and ""Services"" tables on ""Service_ID"" to link service usage with service details. 4. Aggregation Structure: Use COUNT on ""Customer_Interactions.Service_ID"" to count the number of times each service was used, and filter with HAVING to select services used more than 3 times.",0.0
287,Give the order status code that is most frequent across customer orders.,EASY,customers_and_orders,[Customer_Orders.order_status_code],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Customer_Orders.order_status_code FROM Customer_Orders GROUP BY Customer_Orders.order_status_code ORDER BY COUNT(*) DESC LIMIT 1;,SELECT order_status_code FROM Customer_orders GROUP BY order_status_code ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""order_status_code"". 2. Aggregation Structure: Use COUNT to determine the frequency of each ""order_status_code"". 3. Grouping Structure: Use GROUP BY on ""Customer_Orders.order_status_code"" to aggregate the results by each status code. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank the status codes by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most frequent ""order_status_code"". 6. Join Structure: No JOIN is required since all necessary data is within the ""Customer_Orders"" table.",1.0
288,What are the distinct descriptions of all the detentions which have ever happened?,EASY,cre_Students_Information_Systems,[Detention.detention_summary],"Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT DISTINCT Detention.detention_summary FROM Detention;,SELECT distinct(T1.detention_type_description) FROM Ref_Detention_Type AS T1 JOIN Detention AS T2 ON T1.detention_type_code  =  T2.detention_type_code,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct descriptions of detentions. 2. Condition Structure: No specific filtering condition is required as we want all detention descriptions. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Detention"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique detention descriptions are retrieved.",0.0
289,"How many courses does each student take? List the student id, the student biographical data and the course count.",NON-NESTED,cre_Students_Information_Systems,"[Students.student_id,Students.bio_data,Classes.student_id,Classes.class_id,Classes.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.student_id, Students.bio_data, COUNT(Classes.class_id) AS course_count FROM Students JOIN Classes ON Classes.student_id = Students.student_id GROUP BY Students.student_id;","SELECT T1.student_id ,  T1.bio_data ,  count(*) FROM Students AS T1 JOIN Classes AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.student_id,"" ""Students.bio_data,"" and the count of courses each student takes. Use COUNT on ""Classes.class_id"" to count the number of courses for each student. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Students"" table and the ""Classes"" table on ""Classes.student_id = Students.student_id"" to associate each student with their respective classes. 4. Aggregation Structure: Use COUNT on ""Classes.class_id"" to count the number of courses for each student, and GROUP BY ""Students.student_id"" to group the results by each student.",1.0
290,Give me a list of distinct building addresses.,EASY,region_building,[building.Address],"Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT DISTINCT building.Address FROM building;,SELECT DISTINCT Address FROM building,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct building addresses. 2. Condition Structure: No specific filtering condition is required as we want all distinct addresses. 3. Join Structure: No JOIN is needed since all necessary information is in the ""building"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique building addresses are retrieved.",1.0
291,"What are the types of powertrains for which there are two or more vehicles, and what are their average annual fuel costs?",NESTED,vehicle_rent,"[Vehicles.Type_of_powertrain, Vehicles.Annual_fuel_cost]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Type_of_powertrain, AVG(Annual_fuel_cost) AS average_annual_fuel_cost FROM Vehicles GROUP BY Type_of_powertrain HAVING COUNT(*) >= 2;","SELECT type_of_powertrain ,  avg(annual_fuel_cost) FROM vehicles GROUP BY type_of_powertrain HAVING count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve the type of powertrain and the average annual fuel cost. Use the FROM clause to specify the Vehicles table. Apply a GROUP BY clause to group records by the type of powertrain, allowing us to calculate the average annual fuel cost for each type. Use the HAVING clause to filter for powertrain types that have two or more vehicles. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for powertrain types that have two or more vehicles. 3. Join Structure: Not required, as all data is available within the Vehicles table. 4. Aggregation Structure: Use COUNT(*) to count the number of vehicles for each powertrain type and AVG() to calculate the average annual fuel cost for each powertrain type.",1.0
292,"What are the names and addressed of all clients, ordered alphabetically by name?",EASY,book_1,"[Client.Name, Client.Address]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Client.Name, Client.Address FROM Client ORDER BY Client.Name ASC;","SELECT name ,  address FROM Client ORDER BY name","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""Client.Name"" and ""Client.Address"". 2. Condition Structure: No specific filtering condition is required as we want all clients. 3. Join Structure: No JOIN is required since all necessary data is within the ""Client"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data. 5. Ordering Structure: Use ORDER BY on ""Client.Name"" to sort the results alphabetically by name.",1.0
293,Find details of the services that no customer has ever used . Return the service details .,NESTED,government_shift,"[Services.Service_Details,Customers_and_Services.Service_ID,Customers_and_Services.Service_ID = Services.Service_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Services.Service_Details FROM Services WHERE Services.Service_ID NOT IN (SELECT Service_ID FROM Customers_and_Services);,select service_details from services except select t2.service_details from customers_and_services as t1 join services as t2 on t1.service_id  =  t2.service_id,"1. Sequential Structure: Start with the SELECT clause to retrieve the service details from the Services table. Use the FROM clause to specify the Services table. Apply a WHERE clause to filter for services that have not been used by any customer. 2. Condition Structure: Use the WHERE clause with a subquery to exclude services whose Service_ID appears in the Customers_and_Services table, indicating they have been used by customers. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Service_ID entries in the Customers_and_Services table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
294,List the start time and the end time of the students' addresses for the students who have 2 transcripts.,NESTED,cre_Students_Information_Systems,"[Students.student_id,Transcripts.student_id,Students_Addresses.date_from,Students_Addresses.date_to,Students_Addresses.student_id = Students.student_id,Transcripts.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students_Addresses.date_from, Students_Addresses.date_to FROM Students_Addresses JOIN Students ON Students_Addresses.student_id = Students.student_id JOIN Transcripts ON Transcripts.student_id = Students.student_id GROUP BY Students.student_id, Students_Addresses.date_from, Students_Addresses.date_to HAVING COUNT(Transcripts.student_id) = 2;","SELECT date_from ,  date_to FROM Students_Addresses WHERE student_id IN ( SELECT student_id FROM Transcripts GROUP BY student_id HAVING count(*)  =  2 )","1. Sequential Structure: Start with the SELECT clause to retrieve the start time (date_from) and end time (date_to) of the students' addresses. Use the FROM clause to specify the Students_Addresses table. Join it with the Students table to link addresses to students, and then join with the Transcripts table to count the number of transcripts per student. Use GROUP BY to group by student_id and filter students with exactly 2 transcripts using the HAVING clause. 2. Condition Structure: Use the HAVING clause to filter for students who have exactly 2 transcripts. 3. Join Structure: Use INNER JOINs between Students_Addresses, Students, and Transcripts tables based on student_id to connect addresses with students and their transcripts. 4. Aggregation Structure: Use COUNT(*) in the HAVING clause to count the number of transcripts per student and filter for those with exactly 2 transcripts.",1.0
295,List the names of buildings in ascending order of number of stories.,EASY,region_building,"[building.Name, building.Number_of_Stories]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT building.Name FROM building ORDER BY building.Number_of_Stories ASC;,SELECT Name FROM building ORDER BY Number_of_Stories ASC,"1. Sequential Structure: Start with the SELECT clause to specify the building names and their number of stories. 2. Condition Structure: No specific filtering condition is required as we want all buildings. 3. Join Structure: No JOIN is required since all necessary information is in the ""building"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY in ascending order on ""building.Number_of_Stories"" to sort the buildings by the number of stories.",1.0
296,Show all types of powertrain and the number of vehicles in each type.,EASY,vehicle_rent,"[Vehicles.Type_of_powertrain, Vehicles.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.Type_of_powertrain, COUNT(Vehicles.id) AS vehicle_count FROM Vehicles GROUP BY Vehicles.Type_of_powertrain;","SELECT type_of_powertrain ,  count(*) FROM vehicles GROUP BY type_of_powertrain","1. Sequential Structure: Begin with the SELECT clause to specify the type of powertrain and the count of vehicles for each type. 2. Aggregation Structure: Use COUNT to calculate the number of vehicles for each type of powertrain. 3. Grouping Structure: Use GROUP BY on ""Vehicles.Type_of_powertrain"" to group the results by each powertrain type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Vehicles"" table.",1.0
297,Show all customer ids without an order.,NESTED,customers_and_orders,"[Customers.customer_id,Customer_Orders.customer_id,Customers.customer_id = Customer_Orders.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT customer_id FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Customer_Orders);,SELECT customer_id FROM Customers EXCEPT SELECT customer_id FROM Customer_orders,"1. Sequential Structure: Start with the SELECT clause to retrieve all customer IDs from the Customers table. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter out customers who have placed orders by ensuring their customer_id is not present in the Customer_Orders table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude customer IDs that appear in the Customer_Orders table, indicating they have placed orders. 3. Join Structure: Not required, as we only need to filter based on the absence of matching customer_id entries in the Customer_Orders table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
298,How many vehicles have each type of powertrain?,EASY,vehicle_rent,[Vehicles.Type_of_powertrain],"Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.Type_of_powertrain, COUNT(*) AS vehicle_count FROM Vehicles GROUP BY Vehicles.Type_of_powertrain;","SELECT type_of_powertrain ,  count(*) FROM vehicles GROUP BY type_of_powertrain","1. Sequential Structure: Begin with the SELECT clause to specify the type of powertrain and the count of vehicles for each type. 2. Aggregation Structure: Use COUNT to calculate the number of vehicles for each type of powertrain. 3. Grouping Structure: Use GROUP BY on ""Vehicles.Type_of_powertrain"" to aggregate the results by each powertrain type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Vehicles"" table.",1.0
299,Count the number of differnt customers who have made an order.,NON-NESTED,customers_and_orders,"[Customer_Orders.customer_id,Customers.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(DISTINCT Customer_Orders.customer_id) FROM Customer_Orders;,SELECT count(DISTINCT customer_id) FROM Customer_orders,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""customer_id"" from the ""Customer_Orders"" table, as we are interested in the number of unique customers who have made an order. 2. Condition Structure: No specific filtering condition is required since we are counting all customers who have made an order. 3. Join Structure: No JOIN is necessary because the required information is available in the ""Customer_Orders"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique ""customer_id"" values in the ""Customer_Orders"" table.",1.0
300,List the names of the regions with the top 5 largest areas.,EASY,region_building,"[region.Name, region.Area]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT region.Name FROM region ORDER BY region.Area DESC LIMIT 5;,SELECT Name FROM region ORDER BY Area DESC LIMIT 5,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the region name. 2. Aggregation Structure: No aggregation function is needed since we are directly comparing the areas of regions. 3. Ordering Structure: Use ORDER BY in descending order on ""region.Area"" to rank regions by their area size. 4. Limiting Structure: Use LIMIT 5 to retrieve only the names of the top 5 regions with the largest areas. 5. Join Structure: No JOIN is required since all necessary data is within the ""region"" table.",1.0
301,What is the biographical information of the students who got the most common result for their behaviour monitoring details ?,NESTED,cre_Students_Information_Systems,"[Students.bio_data,Behaviour_Monitoring.behaviour_monitoring_details,Behaviour_Monitoring.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Students.bio_data FROM Students JOIN Behaviour_Monitoring ON Behaviour_Monitoring.student_id = Students.student_id WHERE Behaviour_Monitoring.behaviour_monitoring_details = ( SELECT behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details ORDER BY COUNT(*) DESC LIMIT 1 );,select t1.bio_data from students as t1 join behaviour_monitoring as t2 on t1.student_id  =  t2.student_id where t2.behaviour_monitoring_details in ( select behaviour_monitoring_details from behaviour_monitoring group by behaviour_monitoring_details order by count(*) desc limit 1 ) except select t1.bio_data from students as t1 join behaviour_monitoring as t2 on t1.student_id  =  t2.student_id where t2.behaviour_monitoring_details not in ( select behaviour_monitoring_details from behaviour_monitoring group by behaviour_monitoring_details order by count(*) desc limit 1 ),1. Sequential Structure: Start with the SELECT clause to retrieve the biographical information of students. Use the FROM clause to specify the Students table and JOIN it with the Behaviour_Monitoring table on the student_id field. Use GROUP BY on the behaviour_monitoring_details to identify the most common result. Use a subquery to find the most common behaviour_monitoring_details and filter the main query based on this result. 2. Condition Structure: Use a WHERE clause to filter students whose behaviour_monitoring_details match the most common result. 3. Join Structure: Use an INNER JOIN between the Students and Behaviour_Monitoring tables based on student_id to connect student biographical information with their behaviour monitoring details. 4. Aggregation Structure: Use COUNT to determine the frequency of each behaviour_monitoring_details and identify the most common one.,1.0
302,"What are the type code, details, and date of each achievement?",EASY,cre_Students_Information_Systems,"[Achievements.achievement_type_code, Achievements.achievement_details, Achievements.date_achievement]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Achievements.achievement_type_code, Achievements.achievement_details, Achievements.date_achievement FROM Achievements;","SELECT achievement_type_code ,  achievement_details ,  date_achievement FROM Achievements","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""achievement_type_code,"" ""achievement_details,"" and ""date_achievement."" 2. Condition Structure: No specific filtering condition is required as the query asks for all achievements. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Achievements"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all records with the specified fields.",1.0
303,Which students have a student loan more than the average amount? List the students' biographical data and the details.,NESTED,cre_Students_Information_Systems,"[Student_Loans.amount_of_loan,Students.student_id = Student_Loans.student_id,Students.bio_data,Students.student_details]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.bio_data, Students.student_details FROM Students JOIN Student_Loans ON Students.student_id = Student_Loans.student_id WHERE Student_Loans.amount_of_loan > (SELECT AVG(amount_of_loan) FROM Student_Loans);","SELECT T1.bio_data ,  T1.student_details FROM Students AS T1 JOIN Student_Loans AS T2 ON T1.student_id  =  T2.student_id WHERE T2.amount_of_loan  >  ( SELECT avg(amount_of_loan) FROM Student_Loans )","1. Sequential Structure: Start with the SELECT clause to retrieve the biographical data and details of students. Use the FROM clause to specify the Students table and JOIN it with the Student_Loans table on the student_id. Apply a WHERE clause to filter for students whose loan amount is greater than the average loan amount. 2. Condition Structure: Use the WHERE clause with a subquery to filter for students whose loan amount exceeds the average loan amount. The subquery calculates the average loan amount from the Student_Loans table. 3. Join Structure: Use an INNER JOIN between the Students and Student_Loans tables based on student_id to connect student information with their loan details. 4. Aggregation Structure: Use AVG in a subquery to calculate the average loan amount, which is then used in the filtering condition.",1.0
304,What are the names of all books and their corresponding authors?,NON-NESTED,book_1,"[Book.Title, Author.Name, Author_Book.ISBN = Book.ISBN, Author_Book.Author = Author.idAuthor]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Book.Title, Author.Name FROM Book JOIN Author_Book ON Book.ISBN = Author_Book.ISBN JOIN Author ON Author_Book.Author = Author.idAuthor;","SELECT T3.title ,  T1.name FROM Author AS T1 JOIN Author_Book AS T2 ON T2.Author  =  T1.idAuthor JOIN Book AS T3 ON T2.isbn  =  T3.isbn","1. Sequential Structure: Start with the SELECT clause to retrieve ""Book.Title"" and ""Author.Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Book"" table with the ""Author_Book"" table on ""Book.ISBN = Author_Book.ISBN"" and then connect the ""Author_Book"" table with the ""Author"" table on ""Author_Book.Author = Author.idAuthor"" to link books with their respective authors. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the names of books and their authors.",1.0
305,"What is the customer address, customer phone, and customer email for Jeromy?",EASY,customers_and_orders,"[Customers.customer_address, Customers.customer_phone, Customers.customer_email, Customers.customer_name]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customers.customer_address, Customers.customer_phone, Customers.customer_email FROM Customers WHERE Customers.customer_name = 'Jeromy';","SELECT customer_address ,  customer_phone ,  customer_email FROM Customers WHERE customer_name  =  ""Jeromy""","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Customers.customer_address,"" ""Customers.customer_phone,"" and ""Customers.customer_email."" 2. Condition Structure: Use a WHERE clause to filter for the customer whose name is ""Jeromy."" 3. Join Structure: No JOIN is required since all necessary information is within the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields for a single customer.",1.0
306,"Show the id and the product type for all products, order by product name.",EASY,customers_and_orders,"[Products.product_id, Products.product_type_code, Products.product_name]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_id, Products.product_type_code FROM Products ORDER BY Products.product_name;","SELECT product_id ,  product_type_code FROM Products ORDER BY product_name","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Products.product_id"" and ""Products.product_type_code"". 2. Condition Structure: No specific filtering condition is required as the query asks for all products. 3. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table. 4. Aggregation Structure: No aggregation is needed as the query does not involve any summarization. 5. Ordering Structure: Use ORDER BY on ""Products.product_name"" to sort the results by product name.",1.0
307,What is the list of channel details ordered alphabetically ?,EASY,government_shift,[Channels.Channel_Details],"Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Channels.Channel_Details FROM Channels ORDER BY Channels.Channel_Details ASC;,select channel_details from channels order by channel_details,"1. Sequential Structure: Begin with the SELECT clause to retrieve the ""Channels.Channel_Details"" field, as the question asks for the list of channel details. 2. Condition Structure: No specific filtering condition is required since the query aims to retrieve all channel details. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Channels"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves and orders the data. 5. Ordering Structure: Use ORDER BY in ascending order to sort the channel details alphabetically.",1.0
308,Which region has the largest population? Give me the capital of the region.,NESTED,region_building,"[region.Population, region.Capital]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT Capital FROM region ORDER BY Population DESC LIMIT 1;,SELECT Capital FROM region ORDER BY Population DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the capital of the region. Use the FROM clause to specify the region table. Apply an ORDER BY clause to sort the regions by population in descending order and use LIMIT 1 to get the region with the largest population. 2. Condition Structure: No specific condition (WHERE clause) is needed as we are interested in the region with the largest population. 3. Join Structure: Not required, as all data is available within the region table. 4. Aggregation Structure: Not needed, as we are simply sorting and retrieving the top record based on population.",1.0
309,How many customers do we have?,EASY,customers_and_orders,[Customers.customer_id],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(Customers.customer_id) AS total_customers FROM Customers;,SELECT count(*) FROM Customers,"1. Sequential Structure: Start with the SELECT clause to count the total number of customers. 2. Aggregation Structure: Use the COUNT function to count the number of unique customer IDs. 3. Condition Structure: No specific filtering condition is required as we want the total count of all customers. 4. Join Structure: No JOIN is required since all necessary information is in the ""Customers"" table.",1.0
310,What are the names of vehicles that have never been rented?,NESTED,vehicle_rent,"[Vehicles.name, Renting_history.vehicles_id, Vehicles.id = Renting_history.vehicles_id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT Vehicles.name FROM Vehicles WHERE Vehicles.id NOT IN (SELECT Renting_history.vehicles_id FROM Renting_history);,SELECT name FROM vehicles WHERE id NOT IN (SELECT vehicles_id FROM renting_history),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of vehicles. Use the FROM clause to specify the Vehicles table. Apply a WHERE clause to filter vehicles that have never been rented by ensuring their IDs are not present in the Renting_history table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude vehicles whose IDs appear in the Renting_history table, indicating they have been rented. 3. Join Structure: Not required, as we only need to filter based on the absence of matching vehicle IDs in the Renting_history table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
311,Count the number of customer orders.,EASY,customers_and_orders,[Customer_Orders.order_id],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(Customer_Orders.order_id) AS total_orders FROM Customer_Orders;,SELECT count(*) FROM Customer_orders,"1. Sequential Structure: Begin with the SELECT clause to count the number of customer orders. 2. Aggregation Structure: Use the COUNT function on the ""Customer_Orders.order_id"" field to calculate the total number of orders. 3. Condition Structure: No specific filtering condition is required as we want the total count of all orders. 4. Join Structure: No JOIN is necessary since all required data is within the ""Customer_Orders"" table.",1.0
312,Which service ( s ) has never been used by any customer ? List their details .,NESTED,government_shift,"[Services.Service_ID,Services.Service_Details,Customer_Interactions.Service_ID,Services.Service_ID != Customer_Interactions.Service_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
","SELECT Service_ID, Service_Details FROM Services WHERE Service_ID NOT IN (SELECT Service_ID FROM Customer_Interactions);",select service_details from services except select t2.service_details from customers_and_services as t1 join services as t2 on t1.service_id  =  t2.service_id,"1. Sequential Structure: Start with the SELECT clause to retrieve the details of services. Use the FROM clause to specify the Services table. Apply a WHERE clause to filter services that have never been used by any customer. 2. Condition Structure: Use the WHERE clause with a subquery to exclude services whose Service_ID appears in the Customer_Interactions table, indicating they have been used. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Service_ID entries in the Customer_Interactions table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
313,"Show the name, age, membership credit for all customers?",EASY,vehicle_rent,"[Customers.name, Customers.age, Customers.membership_credit]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Customers.name, Customers.age, Customers.membership_credit FROM Customers;","SELECT name ,  age ,  membership_credit FROM customers","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Customers.name,"" ""Customers.age,"" and ""Customers.membership_credit."" 2. Condition Structure: No specific filtering condition is required as the query asks for all customers. 3. Join Structure: No JOIN is required since all necessary data is within the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the specified fields for all customers.",1.0
314,Which students have 'Suite' as a substring in their details? Give me their biographical information.,EASY,cre_Students_Information_Systems,"[Students.student_details, Students.bio_data]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Students.bio_data FROM Students WHERE Students.student_details LIKE '%Suite%';,SELECT bio_data FROM Students WHERE student_details LIKE '%Suite%',"1. Sequential Structure: Start with the SELECT clause to retrieve the biographical information of students whose details contain the substring 'Suite'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for students whose ""Students.student_details"" field contains the substring 'Suite'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Students"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific rows based on a condition.",1.0
315,"Which services have been rated as ""unsatisfied"" in customers and services details? Give me the service_details.",NON-NESTED,government_shift,"[Services.Service_Details,Customers_and_Services.Service_ID,Customers_and_Services.Customers_and_Services_Details,Customers_and_Services.Service_ID = Services.Service_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Services.Service_Details FROM Services JOIN Customers_and_Services ON Customers_and_Services.Service_ID = Services.Service_ID WHERE Customers_and_Services.Customers_and_Services_Details = 'unsatisfied';,"SELECT DISTINCT t1.service_details FROM services AS t1 JOIN customers_and_services AS t2 ON t1.service_id  =  t2.service_id WHERE t2.customers_and_services_details  =  ""Unsatisfied""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Services.Service_Details"" field, as the question asks for the service details. 2. Condition Structure: Use a WHERE clause to filter for records where ""Customers_and_Services.Customers_and_Services_Details"" is rated as ""unsatisfied."" 3. Join Structure: Use a JOIN between the ""Services"" and ""Customers_and_Services"" tables based on the shared key ""Service_ID"" to link services with their customer ratings. 4. Aggregation Structure: No aggregation is needed since the query only retrieves specific service details based on a condition.",0.0
316,What are the order ids and corresponding order dates for orders with a quantity greater than 6 or consisting of more than 3 products?,NON-NESTED,customers_and_orders,"[Customer_Orders.order_id,Customer_Orders.order_date,Order_Items.order_id,Order_Items.order_quantity,Order_Items.product_id = Products.product_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customer_Orders.order_id, Customer_Orders.order_date FROM Customer_Orders JOIN Order_Items ON Customer_Orders.order_id = Order_Items.order_id GROUP BY Customer_Orders.order_id, Customer_Orders.order_date HAVING SUM(Order_Items.order_quantity) > 6 OR COUNT(DISTINCT Order_Items.product_id) > 3;","SELECT T1.order_date ,  T1.order_id FROM Customer_Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id WHERE T2.order_quantity  >  6 UNION SELECT T1.order_date ,  T1.order_id FROM Customer_Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id HAVING count(*)  >  3;","1. Sequential Structure: Start with the SELECT clause to retrieve ""Customer_Orders.order_id"" and ""Customer_Orders.order_date."" 2. Condition Structure: Use a WHERE clause to filter orders where the total quantity of items in an order is greater than 6 or the number of distinct products in an order is more than 3. 3. Join Structure: Use a JOIN between ""Customer_Orders"" and ""Order_Items"" on ""order_id"" to link orders with their items. Additionally, ""Order_Items"" is linked to ""Products"" via ""product_id"" if needed for product-related information. 4. Aggregation Structure: Use GROUP BY on ""Customer_Orders.order_id"" to group items by order. Use HAVING to apply the conditions for total quantity and distinct product count.",1.0
317,Which students never had a detention or student loan ? Find their biographical data .,NESTED,cre_Students_Information_Systems,"[Students.student_id,Students.bio_data,Detention.student_id,Student_Loans.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Students.bio_data FROM Students WHERE Students.student_id NOT IN (SELECT student_id FROM Detention) AND Students.student_id NOT IN (SELECT student_id FROM Student_Loans);,select bio_data from students where student_id not in (select t1.student_id from students as t1 join detention as t2 on t1.student_id  =  t2.student_id union select t1.student_id from students as t1 join student_loans as t2 on t1.student_id  =  t2.student_id),"1. Sequential Structure: Start with the SELECT clause to retrieve the biographical data of students. Use the FROM clause to specify the Students table. Apply a WHERE clause to filter students who are not present in either the Detention or Student_Loans tables. 2. Condition Structure: Use the WHERE clause with NOT IN subqueries to exclude students whose student_id appears in the Detention or Student_Loans tables. 3. Join Structure: Not required, as the filtering is done using subqueries and no direct joining of tables is needed. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
318,Count the number of customers who have not made an order.,NESTED,customers_and_orders,"[Customers.customer_id,Customer_Orders.customer_id,Customers.customer_id = Customer_Orders.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Customer_Orders);,SELECT count(*) FROM Customers WHERE customer_id NOT IN  ( SELECT customer_id FROM Customer_orders),"1. Sequential Structure: Start with the SELECT clause to count the number of customers. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter customers who have not made an order by ensuring their customer_id is not present in the Customer_Orders table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude customers whose customer_id appears in the Customer_Orders table, meaning they have made an order. 3. Join Structure: Not required, as we only need to filter based on the absence of matching customer_id entries in the Customer_Orders table. 4. Aggregation Structure: Use COUNT to count the number of customers who meet the condition of not having made an order.",1.0
319,"Find the names of all the services which both have been used by customer ""Hardy Kutch"" and have been rated ""bad"" in one of the customer interactions.",NESTED,government_shift,"[Services.Service_ID, Services.Service_Details, Customers.Customer_ID, Customers.Customer_Details, Customers_and_Services.Customer_ID = Customers.Customer_ID, Customers_and_Services.Service_ID = Services.Service_ID, Customer_Interactions.Customer_ID = Customers.Customer_ID, Customer_Interactions.Service_ID = Services.Service_ID, Customer_Interactions.Status_Code, Hardy Kutch, bad]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT DISTINCT Services.Service_Details FROM Services JOIN Customers_and_Services ON Services.Service_ID = Customers_and_Services.Service_ID JOIN Customers ON Customers_and_Services.Customer_ID = Customers.Customer_ID JOIN Customer_Interactions ON Services.Service_ID = Customer_Interactions.Service_ID AND Customers.Customer_ID = Customer_Interactions.Customer_ID WHERE Customers.Customer_Details = 'Hardy Kutch' AND Customer_Interactions.Status_Code = 'bad';,"SELECT DISTINCT t3.service_details FROM customers AS t1 JOIN customers_and_services AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id JOIN customer_interactions AS t4 ON t3.service_id  =  t4.service_id WHERE t1.customer_details  =  ""Hardy Kutch"" AND t4.services_and_channels_details  =  ""bad""","1. Sequential Structure: Start with the SELECT clause to retrieve the names of services. Use the FROM clause to specify the Services table and JOIN it with the Customers_and_Services and Customer_Interactions tables to link services with customer interactions and customer details. Apply a WHERE clause to filter for services used by the customer ""Hardy Kutch"" and those that have been rated ""bad"" in customer interactions. 2. Condition Structure: Use the WHERE clause to filter for the customer name ""Hardy Kutch"" and the status code ""bad"" in the Customer_Interactions table. 3. Join Structure: Use INNER JOINs between the Services, Customers_and_Services, and Customer_Interactions tables based on the shared keys (Customer_ID and Service_ID) to connect the relevant data. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
320,"Which customers have experienced status ""Stuck"" and service and channel detail ""bad"" in  an interaction? Give me the customer details.",NON-NESTED,government_shift,"[Customer_Interactions.Status_Code,Customer_Interactions.Services_and_Channels_Details,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customers.Customer_Details,Stuck,bad]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Customers.Customer_Details FROM Customer_Interactions JOIN Customers ON Customer_Interactions.Customer_ID = Customers.Customer_ID WHERE Customer_Interactions.Status_Code = 'Stuck' AND Customer_Interactions.Services_and_Channels_Details = 'bad';,"SELECT t1.customer_details FROM customers AS t1 JOIN customer_interactions AS t2 ON t1.customer_id  =  t2.customer_id WHERE t2.status_code  =  ""Stuck"" AND services_and_channels_details  =  ""bad""","1. Sequential Structure: Start with the SELECT clause to retrieve the customer details from the ""Customers"" table. 2. Condition Structure: Use a WHERE clause to filter for interactions where the ""Customer_Interactions.Status_Code"" is ""Stuck"" and ""Customer_Interactions.Services_and_Channels_Details"" is ""bad."" 3. Join Structure: Use a JOIN between the ""Customer_Interactions"" table and the ""Customers"" table based on the shared key ""Customer_Interactions.Customer_ID = Customers.Customer_ID"" to link interactions with customer details. 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving specific customer details based on conditions.",1.0
321,How many students got the most common result in the behavioral monitoring details? Also list the result details.,NESTED,cre_Students_Information_Systems,"[Behaviour_Monitoring.behaviour_monitoring_details, Behaviour_Monitoring.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT behaviour_monitoring_details, COUNT(student_id) AS student_count FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details ORDER BY student_count DESC LIMIT 1;","SELECT count(DISTINCT student_id) ,  behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the count of students and the most common behavioral monitoring result details. Use the FROM clause to specify the Behaviour_Monitoring table. Use GROUP BY to group records by behavior monitoring details and COUNT to calculate the number of students for each result. Use ORDER BY to sort the results by the count in descending order and LIMIT to get the most common result. 2. Condition Structure: No specific WHERE clause is needed as we are analyzing all records in the Behaviour_Monitoring table. 3. Join Structure: Not required, as all necessary data is in the Behaviour_Monitoring table. 4. Aggregation Structure: Use COUNT to calculate the number of students for each behavioral monitoring result and MAX to identify the most common result.",0.0
322,Which student has the loan with the minimum value? List the student's biographical information.,NON-NESTED,cre_Students_Information_Systems,"[Student_Loans.amount_of_loan,Student_Loans.student_id,Students.student_id = Student_Loans.student_id,Students.bio_data]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Students.bio_data FROM Students JOIN Student_Loans ON Students.student_id = Student_Loans.student_id WHERE Student_Loans.amount_of_loan = (SELECT MIN(Student_Loans.amount_of_loan) FROM Student_Loans);,SELECT T1.bio_data FROM Students AS T1 JOIN Student_Loans AS T2 ON T1.student_id  =  T2.student_id ORDER BY T2.amount_of_loan ASC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the biographical information of the student. Since the question asks for the student with the minimum loan value, we will use a subquery to find the minimum loan value. 2. Condition Structure: Use a WHERE clause to filter the records where the loan amount matches the minimum loan value. 3. Join Structure: Use a JOIN between the ""Students"" table and the ""Student_Loans"" table based on the ""student_id"" field to link each student with their loan information. 4. Aggregation Structure: Use the MIN function in a subquery to determine the minimum loan value.",1.0
323,Which regions have more than one building? Give me the names of the regions.,NON-NESTED,region_building,"[region.Name, building.Region_ID, building.Region_ID = region.Region_ID]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT region.Name FROM region JOIN building ON building.Region_ID = region.Region_ID GROUP BY region.Region_ID HAVING COUNT(building.Region_ID) > 1;,SELECT T2.Name FROM building AS T1 JOIN region AS T2 ON T1.Region_ID  =  T2.Region_ID GROUP BY T1.Region_ID HAVING COUNT(*)  >  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of regions. Use GROUP BY to group the data by region. 2. Condition Structure: Apply a HAVING clause to filter regions that have more than one building. 3. Join Structure: Use a JOIN between the ""region"" and ""building"" tables based on ""Region_ID"" to associate each region with its buildings. 4. Aggregation Structure: Use COUNT on ""building.Region_ID"" to count the number of buildings per region, then filter with HAVING to select regions with more than one building.",1.0
324,Show all author names and the numbers of books each has written.,NON-NESTED,book_1,"[Author.Name, Author.idAuthor, Author_Book.idAuthor = Author.idAuthor, Author_Book.ISBN, Book.ISBN = Author_Book.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Author.Name, COUNT(Book.ISBN) AS NumberOfBooks FROM Author JOIN Author_Book ON Author.idAuthor = Author_Book.idAuthor JOIN Book ON Author_Book.ISBN = Book.ISBN GROUP BY Author.Name;","SELECT T1.name ,  count(*) FROM Author AS T1 JOIN Author_Book AS T2 ON T1.idAuthor  =  T2.Author GROUP BY T1.idAuthor","1. Sequential Structure: Start with the SELECT clause to retrieve ""Author.Name"" and the count of books each author has written. Use COUNT to count the number of books. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Author"" table with the ""Author_Book"" table on ""Author.idAuthor"" and ""Author_Book.idAuthor,"" and then connect the ""Author_Book"" table with the ""Book"" table on ""Author_Book.ISBN"" and ""Book.ISBN."" 4. Aggregation Structure: Use COUNT to count the number of books for each author and GROUP BY ""Author.Name"" to group the results by author.",0.0
325,What are the biographical data and student id of the students who either took two or more classes and or have less than two detentions?,NESTED,cre_Students_Information_Systems,"[Students.student_id, Students.bio_data, Classes.student_id, Detention.student_id, Classes.class_id, Detention.detention_id, Classes.student_id = Students.student_id, Detention.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.student_id, Students.bio_data FROM Students LEFT JOIN Classes ON Students.student_id = Classes.student_id LEFT JOIN Detention ON Students.student_id = Detention.student_id GROUP BY Students.student_id, Students.bio_data HAVING COUNT(DISTINCT Classes.class_id) >= 2 OR COUNT(DISTINCT Detention.detention_id) < 2;","SELECT T1.bio_data ,  T1.student_id FROM Students AS T1 JOIN Classes AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  >=  2 UNION SELECT T1.bio_data ,  T1.student_id FROM Students AS T1 JOIN Detention AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  <  2","1. Sequential Structure: Start with the SELECT clause to retrieve the biographical data and student ID of students. Use the FROM clause to specify the Students table. Join it with the Classes and Detention tables to access information about the classes taken and detentions. Use GROUP BY to group data by student ID and apply conditions in the HAVING clause to filter students who either took two or more classes or have less than two detentions. 2. Condition Structure: Use the HAVING clause to filter students who meet either of the two conditions: (a) the count of classes taken is two or more, or (b) the count of detentions is less than two. 3. Join Structure: Use INNER JOINs between the Students, Classes, and Detention tables based on the student_id to combine relevant data. 4. Aggregation Structure: Use COUNT to calculate the number of classes taken and the number of detentions for each student, and apply these counts in the HAVING clause to filter the results.",1.0
326,What is the most common student address type? Give me the code and description of the address type.,NON-NESTED,cre_Students_Information_Systems,"[Ref_Address_Types.address_type_code,Ref_Address_Types.address_type_description,Students_Addresses.address_type_code,Students_Addresses.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Ref_Address_Types.address_type_code, Ref_Address_Types.address_type_description FROM Students_Addresses JOIN Ref_Address_Types ON Students_Addresses.address_type_code = Ref_Address_Types.address_type_code GROUP BY Ref_Address_Types.address_type_code, Ref_Address_Types.address_type_description ORDER BY COUNT(Students_Addresses.address_type_code) DESC LIMIT 1;","SELECT T1.address_type_code ,  T2.address_type_description FROM Students_Addresses AS T1 JOIN Ref_Address_Types AS T2 WHERE T1.address_type_code  =  T2.address_type_code GROUP BY T1.address_type_code ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""address_type_code"" and ""address_type_description"" of the most common address type. Use COUNT to determine the frequency of each address type. 2. Condition Structure: No specific filtering condition is required, as we are analyzing all address types. 3. Join Structure: Use a JOIN between ""Students_Addresses"" and ""Ref_Address_Types"" on ""address_type_code"" to link the address type codes with their descriptions. 4. Aggregation Structure: Use COUNT to calculate the frequency of each address type, then use ORDER BY in descending order to rank them by frequency. Use LIMIT 1 to select the most common address type.",1.0
327,What are the ids and names of all customers?,EASY,customers_and_orders,"[Customers.customer_id, Customers.customer_name]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customers.customer_id, Customers.customer_name FROM Customers;","SELECT customer_id ,  customer_name FROM Customers","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""customer_id"" and ""customer_name"". 2. Condition Structure: No specific filtering condition is required as the query asks for all customers. 3. Join Structure: No JOIN is required since all necessary data is within the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all customer IDs and names.",1.0
328,Return the name of the discount that corresponds to the most rental history records.,NON-NESTED,vehicle_rent,"[Discount.name, Renting_history.discount_id, Renting_history.discount_id = Discount.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT Discount.name FROM Renting_history JOIN Discount ON Renting_history.discount_id = Discount.id GROUP BY Discount.name ORDER BY COUNT(Renting_history.discount_id) DESC LIMIT 1;,SELECT T2.name FROM renting_history AS T1 JOIN discount AS T2 ON T1.discount_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Discount.name"" corresponding to the most rental history records. Use COUNT to count the number of rental history records for each discount. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the discount with the most rental history records. 3. Join Structure: Use a JOIN between the ""Renting_history"" and ""Discount"" tables based on ""Renting_history.discount_id = Discount.id"" to associate rental history records with their corresponding discounts. 4. Aggregation Structure: Use COUNT to count the number of rental history records for each discount. Use ORDER BY in descending order to rank discounts by the number of rental history records and LIMIT 1 to select the discount with the most records.",0.0
329,List the names of regions that do not have any buildings.,NESTED,region_building,"[region.Name, building.Region_ID = region.Region_ID]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT region.Name FROM region WHERE region.Region_ID NOT IN (SELECT building.Region_ID FROM building);,SELECT Name FROM region WHERE Region_ID NOT IN (SELECT Region_ID FROM building),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of regions. Use the FROM clause to specify the region table. Apply a WHERE clause to filter regions that do not have any associated buildings by ensuring that their Region_ID is not present in the building table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude regions whose Region_ID appears in the building table, meaning they have associated buildings. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Region_ID entries in the building table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
330,What are the names of customers who use the least common payment method?,NESTED,customers_and_orders,"[Customers.customer_name,Customers.payment_method_code,Customer_Orders.customer_id = Customers.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Customers.customer_name FROM Customers JOIN Customer_Orders ON Customers.customer_id = Customer_Orders.customer_id WHERE Customers.payment_method_code = ( SELECT payment_method_code FROM Customers GROUP BY payment_method_code ORDER BY COUNT(payment_method_code) ASC LIMIT 1 );,SELECT customer_name FROM Customers WHERE payment_method_code  =  ( SELECT payment_method_code FROM Customers GROUP BY payment_method_code ORDER BY count(*) ASC LIMIT 1),1. Sequential Structure: Start with the SELECT clause to retrieve the names of customers. Use the FROM clause to specify the Customers table and JOIN it with the Customer_Orders table to link customers with their orders. Use GROUP BY on the payment_method_code to count the occurrences of each payment method. Use a subquery to identify the least common payment method and filter customers who use it. 2. Condition Structure: Use a WHERE clause to filter for customers whose payment_method_code matches the least common payment method identified in the subquery. 3. Join Structure: Use an INNER JOIN between Customers and Customer_Orders tables based on customer_id to connect customer details with their orders. 4. Aggregation Structure: Use COUNT to calculate the frequency of each payment method in the subquery and MIN to identify the least common payment method.,0.0
331,"Show the order ids, order dates, and order status codes for all orders by customer Jeromy.",NON-NESTED,customers_and_orders,"[Customer_Orders.order_id,Customer_Orders.order_date,Customer_Orders.order_status_code,Customers.customer_name,Customer_Orders.customer_id = Customers.customer_id,Jeromy]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customer_Orders.order_id, Customer_Orders.order_date, Customer_Orders.order_status_code FROM Customer_Orders JOIN Customers ON Customer_Orders.customer_id = Customers.customer_id WHERE Customers.customer_name = 'Jeromy';","SELECT order_id ,  order_date ,  order_status_code FROM Customer_orders AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_name  =  ""Jeromy""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Customer_Orders.order_id,"" ""Customer_Orders.order_date,"" and ""Customer_Orders.order_status_code."" 2. Condition Structure: Use a WHERE clause to filter for orders placed by the customer named ""Jeromy."" 3. Join Structure: Use a JOIN between the ""Customer_Orders"" and ""Customers"" tables based on the relationship ""Customer_Orders.customer_id = Customers.customer_id"" to associate orders with the respective customer. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields for the filtered records.",1.0
332,Show the vehicle name with a descending order of total hours of renting.,NON-NESTED,vehicle_rent,"[Vehicles.name, Renting_history.total_hours, Renting_history.vehicles_id = Vehicles.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, SUM(Renting_history.total_hours) AS total_hours FROM Vehicles JOIN Renting_history ON Renting_history.vehicles_id = Vehicles.id GROUP BY Vehicles.name ORDER BY total_hours DESC;",SELECT T2.name FROM renting_history AS T1 JOIN vehicles AS T2 ON T1.vehicles_id  =  T2.id GROUP BY T2.id ORDER BY sum(T1.total_hours) DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Vehicles.name"" and the total hours of renting. Use SUM on ""Renting_history.total_hours"" to calculate the total hours for each vehicle. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Vehicles"" and ""Renting_history"" tables based on the relationship ""Renting_history.vehicles_id = Vehicles.id"" to associate each vehicle with its renting history. 4. Aggregation Structure: Use SUM to aggregate the total hours of renting for each vehicle, then GROUP BY ""Vehicles.name"" to group the results by vehicle. Finally, use ORDER BY in descending order on the aggregated total hours.",1.0
333,What are the names and model years for vehicles that have a city fuel economy rate less than or equal to its highway fuel economy rate?,EASY,vehicle_rent,"[Vehicles.name, Vehicles.Model_year, Vehicles.City_fuel_economy_rate, Vehicles.Highway_fuel_economy_rate]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, Vehicles.Model_year FROM Vehicles WHERE Vehicles.City_fuel_economy_rate <= Vehicles.Highway_fuel_economy_rate;","SELECT name ,  model_year FROM vehicles WHERE city_fuel_economy_rate  <=  highway_fuel_economy_rate","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Vehicles.name"" and ""Vehicles.Model_year"" for vehicles that meet the specified condition. 2. Condition Structure: Use a WHERE clause to filter vehicles where the ""Vehicles.City_fuel_economy_rate"" is less than or equal to the ""Vehicles.Highway_fuel_economy_rate"". 3. Join Structure: No JOIN is required since all necessary information is available in the ""Vehicles"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and model years of vehicles that meet the specified condition.",1.0
334,List the capital of the region with the largest population.,NESTED,region_building,"[region.Capital, region.Population]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT Capital FROM region WHERE Population = (SELECT MAX(Population) FROM region);,SELECT Capital FROM region ORDER BY Population DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the capital of the region. Use the FROM clause to specify the region table. Apply a WHERE clause to filter for the region with the largest population. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the region with the maximum population. 3. Join Structure: Not required, as all data is in the region table. 4. Aggregation Structure: Use MAX in a subquery to find the largest population, and filter the main query based on this value.",1.0
335,What are the ids of all orders and the corresponding client names?,NON-NESTED,book_1,"[Orders.IdOrder, Client.Name, Orders.IdClient = Client.IdClient]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Orders.IdOrder, Client.Name FROM Orders JOIN Client ON Orders.IdClient = Client.IdClient;","SELECT T1.idOrder ,  T2.name FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient","1. Sequential Structure: Start with the SELECT clause to retrieve ""Orders.IdOrder"" and ""Client.Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Orders"" and ""Client"" tables based on the relationship ""Orders.IdClient = Client.IdClient"" to link each order with its corresponding client. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the order IDs and client names.",1.0
336,Show the names of regions that have more than one building.,NON-NESTED,region_building,"[region.Name, building.Region_ID, building.Building_ID, building.Region_ID = region.Region_ID]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT region.Name FROM region JOIN building ON building.Region_ID = region.Region_ID GROUP BY region.Region_ID HAVING COUNT(building.Building_ID) > 1;,SELECT T2.Name FROM building AS T1 JOIN region AS T2 ON T1.Region_ID  =  T2.Region_ID GROUP BY T1.Region_ID HAVING COUNT(*)  >  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""region.Name"" field. 2. Condition Structure: Use a HAVING clause to filter regions that have more than one building. This requires counting the number of buildings per region. 3. Join Structure: Use a JOIN between the ""region"" and ""building"" tables based on the relationship ""building.Region_ID = region.Region_ID"" to associate buildings with their respective regions. 4. Aggregation Structure: Use COUNT on ""building.Building_ID"" to count the number of buildings per region, then filter with HAVING to select regions with more than one building.",1.0
337,Which students have gone through any event? List the students' biographical data and event date.,NON-NESTED,cre_Students_Information_Systems,"[Students.bio_data, Student_Events.event_date, Student_Events.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.bio_data, Student_Events.event_date FROM Students JOIN Student_Events ON Student_Events.student_id = Students.student_id;","SELECT T1.bio_data ,  T2.event_date FROM Students AS T1 JOIN Student_Events AS T2 ON T1.student_id  =  T2.student_id","1. Sequential Structure: Start with the SELECT clause to retrieve the biographical data of students (""Students.bio_data"") and the event date (""Student_Events.event_date""). 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Students"" table and the ""Student_Events"" table based on the shared key ""Student_Events.student_id = Students.student_id"" to link students with their respective events. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the relevant data without summarization.",1.0
338,What are the capitals of the regions with area bigger than 10000?,EASY,region_building,"[region.Capital, region.Area, 10000]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT region.Capital FROM region WHERE region.Area > 10000;,SELECT Capital FROM region WHERE Area  >  10000,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the capital of the regions. 2. Condition Structure: Use a WHERE clause to filter regions where the ""region.Area"" is greater than 10000. 3. Join Structure: No JOIN is required since all necessary information is available in the ""region"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving the capitals of regions that meet the specified area condition.",1.0
339,Return the distinct descriptions of all the detentions that have happened.,EASY,cre_Students_Information_Systems,[Detention.detention_summary],"Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT DISTINCT Detention.detention_summary FROM Detention;,SELECT distinct(T1.detention_type_description) FROM Ref_Detention_Type AS T1 JOIN Detention AS T2 ON T1.detention_type_code  =  T2.detention_type_code,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct descriptions of detentions. 2. Condition Structure: No specific filtering condition is required as we want all distinct detention descriptions. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Detention"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct values.",0.0
340,Find the details of the services that have been used by more than 3 times .,NON-NESTED,government_shift,"[Services.Service_Details,Customer_Interactions.Service_ID,Customer_Interactions.Customer_ID,Customer_Interactions.Service_ID = Services.Service_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Services.Service_Details FROM Services JOIN Customer_Interactions ON Customer_Interactions.Service_ID = Services.Service_ID GROUP BY Services.Service_ID HAVING COUNT(Customer_Interactions.Service_ID) > 3;,select t1.service_details from services as t1 join customers_and_services as t2 on t1.service_id  =  t2.service_id group by t1.service_details having count(*)  >  3,"1. Sequential Structure: Start with the SELECT clause to retrieve the details of the services, specifically ""Services.Service_Details."" 2. Condition Structure: Use a HAVING clause to filter for services that have been used more than 3 times. This requires counting the occurrences of each ""Customer_Interactions.Service_ID."" 3. Join Structure: Use a JOIN between the ""Services"" and ""Customer_Interactions"" tables based on ""Service_ID"" to link each service with its usage records. 4. Aggregation Structure: Use COUNT on ""Customer_Interactions.Service_ID"" to count the number of times each service has been used, then filter with HAVING to select services used more than 3 times.",0.0
341,List all the author names.,EASY,book_1,[Author.Name],"Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Author.Name FROM Author;,SELECT name FROM Author,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Author.Name"" field, as the question asks for all author names. 2. Condition Structure: No specific filtering condition is required since we want all author names. 3. Join Structure: No JOIN is necessary because the required data is available in the ""Author"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all author names.",1.0
342,Show the capital of the region that has the most buildings.,NON-NESTED,region_building,"[region.Capital, building.Region_ID, building.Region_ID = region.Region_ID]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT region.Capital FROM region JOIN building ON building.Region_ID = region.Region_ID GROUP BY region.Region_ID ORDER BY COUNT(building.Region_ID) DESC LIMIT 1;,SELECT T2.capital FROM building AS T1 JOIN region AS T2 ON T1.Region_ID  =  T2.Region_ID GROUP BY T1.Region_ID ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""region.Capital"" of the region with the most buildings. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the region with the maximum number of buildings. 3. Join Structure: Use a JOIN between the ""region"" and ""building"" tables based on ""Region_ID"" to associate buildings with their respective regions. 4. Aggregation Structure: Use COUNT to count the number of buildings per region, GROUP BY ""region.Region_ID"" to group the counts by region, and ORDER BY the count in descending order to find the region with the most buildings. Use LIMIT 1 to select only the top result.",1.0
343,Which students only got the most common result for his or her all behaviour monitoring details? List the students' biographical information.,NESTED,cre_Students_Information_Systems,"[Students.student_id,Students.bio_data,Behaviour_Monitoring.student_id,Behaviour_Monitoring.behaviour_monitoring_details,Behaviour_Monitoring.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.bio_data FROM Students JOIN Behaviour_Monitoring ON Students.student_id = Behaviour_Monitoring.student_id GROUP BY Students.student_id, Students.bio_data HAVING COUNT(DISTINCT Behaviour_Monitoring.behaviour_monitoring_details) = 1;",SELECT T1.bio_data FROM Students AS T1 JOIN Behaviour_Monitoring AS T2 ON T1.student_id  =  T2.student_id WHERE T2.behaviour_monitoring_details IN ( SELECT behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details ORDER BY count(*) DESC LIMIT 1 ) EXCEPT SELECT T1.bio_data FROM Students AS T1 JOIN Behaviour_Monitoring AS T2 ON T1.student_id  =  T2.student_id WHERE T2.behaviour_monitoring_details NOT IN ( SELECT behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details ORDER BY count(*) DESC LIMIT 1 ),"1. Sequential Structure: Start with the SELECT clause to retrieve the biographical information of students. Use the FROM clause to specify the Students table and JOIN it with the Behaviour_Monitoring table on the student_id. Use GROUP BY to group behaviour monitoring details by student_id and COUNT to determine the frequency of each behaviour monitoring detail. Use a subquery to identify the most common behaviour monitoring detail for each student and filter students who only have this most common result. 2. Condition Structure: Use a HAVING clause to ensure that the student only has one unique behaviour monitoring detail, which is the most common result. 3. Join Structure: Use an INNER JOIN between the Students and Behaviour_Monitoring tables based on student_id to connect student biographical information with their behaviour monitoring details. 4. Aggregation Structure: Use COUNT to determine the frequency of behaviour monitoring details and filter students who only have the most common result for all their behaviour monitoring details.",1.0
344,Count the number of authors.,EASY,book_1,[Author.idAuthor],"Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT COUNT(DISTINCT Author.idAuthor) AS author_count FROM Author;,SELECT count(*) FROM Author,"1. Sequential Structure: Begin with the SELECT clause to count the number of authors. 2. Aggregation Structure: Use the COUNT function to count the distinct author IDs, as each author is uniquely identified by ""Author.idAuthor"". 3. Join Structure: No JOIN is required since all necessary data is within the ""Author"" table. 4. Condition Structure: No specific filtering condition is needed as we want the total count of authors.",1.0
345,What is the name and model year of the vehicle which has been rented the most times?,NON-NESTED,vehicle_rent,"[Vehicles.name, Vehicles.Model_year, Renting_history.vehicles_id, Renting_history.vehicles_id = Vehicles.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, Vehicles.Model_year FROM Vehicles JOIN Renting_history ON Renting_history.vehicles_id = Vehicles.id GROUP BY Vehicles.id ORDER BY COUNT(Renting_history.vehicles_id) DESC LIMIT 1;","SELECT T2.name ,  T2.model_year FROM renting_history AS T1 JOIN vehicles AS T2 ON T1.vehicles_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Vehicles.name"" and ""Vehicles.Model_year"" fields. Use an aggregate function (COUNT) to count the number of times each vehicle has been rented. Use ORDER BY in descending order to rank vehicles by the number of rentals and LIMIT 1 to get the vehicle rented the most times. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all rental records. 3. Join Structure: Use a JOIN between the ""Vehicles"" table and the ""Renting_history"" table based on the relationship ""Renting_history.vehicles_id = Vehicles.id"" to link rental records with vehicle details. 4. Aggregation Structure: Use COUNT on ""Renting_history.vehicles_id"" to count the number of rentals for each vehicle, then use ORDER BY and LIMIT to find the vehicle with the highest count.",1.0
346,Return all information about discounts.,EASY,vehicle_rent,"[Discount.id, Discount.name, Discount.membership_credit]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT * FROM Discount;,SELECT * FROM discount,"1. Sequential Structure: Start with the SELECT clause to retrieve all fields from the ""Discount"" table since the question asks for all information about discounts. 2. Condition Structure: No specific filtering condition is required as the query aims to return all information. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Discount"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all records.",1.0
347,List the details of all the customers who are associated with a failed integration platform .,NON-NESTED,government_shift,"[Customers.Customer_Details,Integration_Platform.Customer_Interaction_ID,Integration_Platform.Integration_Platform_Details,Customer_Interactions.Customer_ID = Customers.Customer_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Customer_Interactions.Status_Code]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Customers.Customer_Details FROM Customers JOIN Customer_Interactions ON Customer_Interactions.Customer_ID = Customers.Customer_ID JOIN Integration_Platform ON Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID WHERE Customer_Interactions.Status_Code = 'Failed';,"select distinct t1.customer_details from customers as t1 join customer_interactions as t2 on t1.customer_id  =  t2.customer_id join integration_platform as t3 where t3.integration_platform_details  =  ""fail""","1. Sequential Structure: Start with the SELECT clause to retrieve all details of customers from the ""Customers"" table. 2. Condition Structure: Use a WHERE clause to filter for records where the ""Customer_Interactions.Status_Code"" indicates a failed integration platform. The specific status code for failure is assumed to be identifiable from the data. 3. Join Structure: Use JOINs to connect the ""Customers"" table with ""Customer_Interactions"" on ""Customer_Interactions.Customer_ID = Customers.Customer_ID"" and then connect ""Customer_Interactions"" with ""Integration_Platform"" on ""Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID."" 4. Aggregation Structure: No aggregation is needed as the query is retrieving detailed information for each customer.",1.0
348,Count the number of vehicles.,EASY,vehicle_rent,[Vehicles.id],"Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT COUNT(Vehicles.id) AS vehicle_count FROM Vehicles;,SELECT count(*) FROM vehicles,"1. Sequential Structure: Begin with the SELECT clause to count the number of vehicles. 2. Aggregation Structure: Use the COUNT function to count the total number of vehicle IDs. 3. Condition Structure: No specific filtering condition is required as we want the total count of vehicles. 4. Join Structure: No JOIN is necessary since all required data is within the ""Vehicles"" table.",1.0
349,What are the starting time and ending time of each detention record?,EASY,cre_Students_Information_Systems,"[Detention.datetime_detention_start, Detention.datetime_detention_end]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Detention.datetime_detention_start, Detention.datetime_detention_end FROM Detention;","SELECT datetime_detention_start ,  datetime_detention_end FROM Detention","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the starting time and ending time of each detention record. 2. Condition Structure: No specific filtering condition is required as the query aims to retrieve all detention records. 3. Join Structure: No JOIN is necessary since all the required data is contained within the ""Detention"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the starting and ending times for each detention record.",1.0
350,"For each student, find the student id and the total amount of loan he or she has.",NON-NESTED,cre_Students_Information_Systems,"[Students.student_id, Student_Loans.amount_of_loan, Student_Loans.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.student_id, SUM(Student_Loans.amount_of_loan) AS total_loan FROM Students JOIN Student_Loans ON Student_Loans.student_id = Students.student_id GROUP BY Students.student_id;","SELECT student_id ,  sum(amount_of_loan) FROM Student_Loans GROUP BY student_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Students.student_id"" and the total loan amount for each student. Use the SUM function to calculate the total loan amount. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to combine the ""Students"" table with the ""Student_Loans"" table based on the relationship ""Student_Loans.student_id = Students.student_id."" 4. Aggregation Structure: Use SUM to calculate the total loan amount for each student and GROUP BY ""Students.student_id"" to group the results by student.",1.0
351,Show the detention start time and end time of the detentions.,EASY,cre_Students_Information_Systems,"[Detention.datetime_detention_start, Detention.datetime_detention_end]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Detention.datetime_detention_start, Detention.datetime_detention_end FROM Detention;","SELECT datetime_detention_start ,  datetime_detention_end FROM Detention","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are ""Detention.datetime_detention_start"" and ""Detention.datetime_detention_end"". 2. Condition Structure: No specific filtering condition is required as the query aims to retrieve all detention start and end times. 3. Join Structure: No JOIN is necessary since all the required data is contained within the ""Detention"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the start and end times of detentions.",1.0
352,Count the total number of available customers and services details.,NON-NESTED,government_shift,"[Customers.Customer_Details, Services.Service_Details]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
","SELECT (SELECT COUNT(*) FROM Customers) AS Total_Customers, (SELECT COUNT(*) FROM Services) AS Total_Services;",SELECT count(DISTINCT customers_and_services_details) FROM customers_and_services,"1. Sequential Structure: Start with the SELECT clause to count the total number of customers and services. Use COUNT for both ""Customers.Customer_Details"" and ""Services.Service_Details."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: No JOIN is required since the question does not specify any relationship between the ""Customers"" and ""Services"" tables. 4. Aggregation Structure: Use COUNT to calculate the total number of entries in both ""Customers.Customer_Details"" and ""Services.Service_Details.""",0.0
353,"Among the students who have an event record, who do not have a student loan? Return the students' biographical data.",NESTED,cre_Students_Information_Systems,"[Students.bio_data,Student_Events.student_id,Student_Loans.student_id,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Students.bio_data FROM Students WHERE Students.student_id IN (SELECT Student_Events.student_id FROM Student_Events) AND Students.student_id NOT IN (SELECT Student_Loans.student_id FROM Student_Loans);,SELECT T1.bio_data FROM Students AS T1 JOIN Student_Events AS T2 WHERE T1.student_id  =  T2.student_id EXCEPT SELECT T1.bio_data FROM Students AS T1 JOIN Student_Loans AS T2 WHERE T1.student_id  =  T2.student_id,"1. Sequential Structure: Start with the SELECT clause to retrieve the biographical data of students. Use the FROM clause to specify the Students table. Apply a WHERE clause to filter students who have an event record but do not have a student loan. 2. Condition Structure: Use the WHERE clause with a subquery to filter students who have an event record (Student_Events table) and exclude those who have a student loan (Student_Loans table). 3. Join Structure: Not required, as the filtering is done using subqueries on the Student_Events and Student_Loans tables, which are linked to the Students table via student_id. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
354,"Give me the details of all the services that have interacted with the channel with detail ""15 ij"".",NON-NESTED,government_shift,"[Services.Service_Details,Customer_Interactions.Service_ID,Customer_Interactions.Channel_ID,Channels.Channel_Details,Customer_Interactions.Service_ID = Services.Service_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,""15 ij""]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Services.* FROM Services JOIN Customer_Interactions ON Services.Service_ID = Customer_Interactions.Service_ID JOIN Channels ON Customer_Interactions.Channel_ID = Channels.Channel_ID WHERE Channels.Channel_Details = '15 ij';,"SELECT DISTINCT t1.service_details FROM services AS t1 JOIN customer_interactions AS t2 ON t1.service_id  =  t2.service_id JOIN channels AS t3 ON t2.channel_id  =  t3.channel_id WHERE t3.channel_details  =  ""15 ij""","1. Sequential Structure: Start with the SELECT clause to retrieve all details of the services from the ""Services"" table. 2. Condition Structure: Use a WHERE clause to filter for interactions where the ""Channels.Channel_Details"" is ""15 ij."" 3. Join Structure: Use JOINs to connect the ""Services"" table with the ""Customer_Interactions"" table on ""Service_ID"" and the ""Customer_Interactions"" table with the ""Channels"" table on ""Channel_ID"" to link services with their respective channel details. 4. Aggregation Structure: No aggregation is needed as the query is retrieving detailed information without summarization.",1.0
355,Find the biographical information of the student with the smallest student loan.,NON-NESTED,cre_Students_Information_Systems,"[Students.bio_data, Student_Loans.amount_of_loan, Student_Loans.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Students.bio_data FROM Students JOIN Student_Loans ON Student_Loans.student_id = Students.student_id ORDER BY Student_Loans.amount_of_loan ASC LIMIT 1;,SELECT T1.bio_data FROM Students AS T1 JOIN Student_Loans AS T2 ON T1.student_id  =  T2.student_id ORDER BY T2.amount_of_loan ASC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.bio_data"" field, which contains the biographical information of the student. 2. Condition Structure: No specific filtering condition is needed, but we need to identify the student with the smallest loan amount. This will be achieved using ORDER BY on ""Student_Loans.amount_of_loan"" in ascending order and LIMIT 1 to select the smallest loan. 3. Join Structure: Use a JOIN between the ""Students"" and ""Student_Loans"" tables based on the shared key ""student_id"" to link each student with their loan information. 4. Aggregation Structure: No aggregation is required, as we are only interested in the student with the smallest loan.",1.0
356,"Among the buildings not completed in 1980, what is the maximum number of stories?",NESTED,region_building,"[building.Number_of_Stories, building.Completed_Year]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT MAX(Number_of_Stories) AS max_stories FROM building WHERE Completed_Year != 1980;,"SELECT max(Number_of_Stories) FROM building WHERE Completed_Year != ""1980""","1. Sequential Structure: Start with the SELECT clause to retrieve the maximum number of stories. Use the FROM clause to specify the building table. Apply a WHERE clause to filter out buildings that were completed in the year 1980. 2. Condition Structure: Use the WHERE clause to exclude buildings with a Completed_Year of 1980. 3. Join Structure: Not required, as all data is in the building table. 4. Aggregation Structure: Use the MAX function to find the maximum number of stories among the filtered buildings.",1.0
357,What is the discount name with most number of renting history records?,NON-NESTED,vehicle_rent,"[Discount.name, Renting_history.discount_id, Renting_history.discount_id = Discount.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT Discount.name FROM Renting_history JOIN Discount ON Renting_history.discount_id = Discount.id GROUP BY Discount.name ORDER BY COUNT(Renting_history.discount_id) DESC LIMIT 1;,SELECT T2.name FROM renting_history AS T1 JOIN discount AS T2 ON T1.discount_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Discount.name"" field. Use COUNT to count the number of renting history records associated with each discount. 2. Condition Structure: No specific filtering condition is required, as we are interested in all renting history records. 3. Join Structure: Use a JOIN between the ""Renting_history"" and ""Discount"" tables based on the relationship ""Renting_history.discount_id = Discount.id"" to associate renting history records with their respective discounts. 4. Aggregation Structure: Use COUNT to count the number of renting history records for each discount. Use ORDER BY in descending order to rank discounts by the number of renting history records, and LIMIT 1 to select the discount with the most records.",0.0
358,Show all the order dates and ids of the orders with quantity of any product larger than 6 or with more than 3 products.,NON-NESTED,customers_and_orders,"[Customer_Orders.order_date, Customer_Orders.order_id, Order_Items.order_quantity, Order_Items.order_id = Customer_Orders.order_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customer_Orders.order_date, Customer_Orders.order_id FROM Customer_Orders JOIN Order_Items ON Order_Items.order_id = Customer_Orders.order_id WHERE Order_Items.order_quantity > 6 OR Customer_Orders.order_id IN ( SELECT Order_Items.order_id FROM Order_Items GROUP BY Order_Items.order_id HAVING COUNT(Order_Items.order_id) > 3 );","SELECT T1.order_date ,  T1.order_id FROM Customer_Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id WHERE T2.order_quantity  >  6 UNION SELECT T1.order_date ,  T1.order_id FROM Customer_Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id HAVING count(*)  >  3;","1. Sequential Structure: Start with the SELECT clause to retrieve ""Customer_Orders.order_date"" and ""Customer_Orders.order_id."" 2. Condition Structure: Use a WHERE clause to filter orders where the quantity of any product is larger than 6 or the total number of products in the order is more than 3. This requires a subquery to count the number of products per order. 3. Join Structure: Use a JOIN between ""Customer_Orders"" and ""Order_Items"" on ""Order_Items.order_id = Customer_Orders.order_id"" to link orders with their respective items. 4. Aggregation Structure: Use COUNT to calculate the total number of products per order and GROUP BY to group results by ""Order_Items.order_id."" Use HAVING to filter orders with more than 3 products.",1.0
359,What are the names and addressed of all clients?,EASY,book_1,"[Client.Name, Client.Address]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Client.Name, Client.Address FROM Client;","SELECT name ,  address FROM Client","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""Client.Name"" and ""Client.Address"". 2. Condition Structure: No specific filtering condition is required as the query asks for all clients. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Client"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and addresses of all clients.",1.0
360,In which years did both buildings with more than 20 stories and buildings with less than 15 stories were completed?,NESTED,region_building,"[building.Completed_Year, building.Number_of_Stories]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT Completed_Year FROM building GROUP BY Completed_Year HAVING SUM(CASE WHEN Number_of_Stories > 20 THEN 1 ELSE 0 END) > 0 AND SUM(CASE WHEN Number_of_Stories < 15 THEN 1 ELSE 0 END) > 0;,SELECT Completed_Year FROM building WHERE Number_of_Stories  >  20 INTERSECT SELECT Completed_Year FROM building WHERE Number_of_Stories  <  15,"1. Sequential Structure: Start with the SELECT clause to retrieve the years when buildings with more than 20 stories and buildings with less than 15 stories were completed. Use the FROM clause to specify the building table. Apply a WHERE clause to filter buildings based on the number of stories. Use a GROUP BY clause to group by the completed year and a HAVING clause to ensure that both conditions (more than 20 stories and less than 15 stories) are satisfied for the same year. 2. Condition Structure: Use the HAVING clause to ensure that the count of buildings with more than 20 stories and the count of buildings with less than 15 stories are both greater than zero for a given year. 3. Join Structure: Not required, as all data is in the building table. 4. Aggregation Structure: Use COUNT(*) to count the number of buildings satisfying each condition within each year.",1.0
361,What are the types of powertrains that have vehicles that were made in both 2013 and 2014?,NESTED,vehicle_rent,"[Vehicles.Type_of_powertrain, Vehicles.Model_year]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT DISTINCT Type_of_powertrain FROM Vehicles WHERE Model_year IN (2013, 2014) GROUP BY Type_of_powertrain HAVING COUNT(DISTINCT Model_year) = 2;",SELECT type_of_powertrain FROM vehicles WHERE model_year  =  2014 INTERSECT SELECT type_of_powertrain FROM vehicles WHERE model_year  =  2013,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct types of powertrains. Use the FROM clause to specify the Vehicles table. Apply a WHERE clause to filter for vehicles made in both 2013 and 2014. Use a GROUP BY clause to group by the type of powertrain and a HAVING clause to ensure that both years (2013 and 2014) are present for each powertrain type. 2. Condition Structure: Use the WHERE clause to filter for vehicles with model years 2013 or 2014. Then, use the HAVING clause to ensure that both years are present for each powertrain type. 3. Join Structure: Not required, as all data is available within the Vehicles table. 4. Aggregation Structure: Use COUNT(DISTINCT Model_year) in the HAVING clause to ensure that both years (2013 and 2014) are represented for each powertrain type.",1.0
362,Give me the detention start date for all the detention records.,EASY,cre_Students_Information_Systems,[Detention.datetime_detention_start],"Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Detention.datetime_detention_start FROM Detention;,SELECT datetime_detention_start FROM Detention,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the detention start date. 2. Condition Structure: No specific filtering condition is required as the query asks for all detention start dates. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Detention"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all detention start dates.",1.0
363,Find details of all the services that have been marked as `` unsatisfied '' in customers and services details .,NON-NESTED,government_shift,"[Services.Service_Details,Customers_and_Services.Customers_and_Services_Details,Customers_and_Services.Service_ID = Services.Service_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Services.* FROM Services JOIN Customers_and_Services ON Services.Service_ID = Customers_and_Services.Service_ID WHERE Customers_and_Services.Customers_and_Services_Details = 'unsatisfied';,"select distinct t1.service_details from services as t1 join customers_and_services as t2 on t1.service_id  =  t2.service_id where t2.customers_and_services_details  =  ""unsatisfied""","1. Sequential Structure: Start with the SELECT clause to retrieve all details of the services. Since the question asks for ""details of all the services,"" we will select all columns from the ""Services"" table. 2. Condition Structure: Use a WHERE clause to filter for services that are marked as ""unsatisfied"" in the ""Customers_and_Services.Customers_and_Services_Details"" column. 3. Join Structure: Use a JOIN between the ""Services"" table and the ""Customers_and_Services"" table based on the shared key ""Service_ID"" to link services with their customer satisfaction details. 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving specific details without summarization.",1.0
364,Return the average age for customers who have membership above the average across all customers.,NESTED,vehicle_rent,"[Customers.age, Customers.membership_credit]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT AVG(Customers.age) AS average_age FROM Customers WHERE Customers.membership_credit > (SELECT AVG(Customers.membership_credit) FROM Customers);,SELECT avg(age) FROM customers WHERE membership_credit  >  (SELECT avg(membership_credit) FROM customers),"1. Sequential Structure: Start with the SELECT clause to calculate the average age of customers. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter customers whose membership credit is above the average membership credit across all customers. 2. Condition Structure: Use the WHERE clause with a subquery to filter customers whose membership_credit is greater than the average membership_credit. 3. Join Structure: Not required, as all data is in the Customers table. 4. Aggregation Structure: Use AVG to calculate the average age of the filtered customers and another AVG in the subquery to calculate the average membership_credit across all customers.",1.0
365,Please show each completion year and the number of buildings completed in that year.,EASY,region_building,"[building.Completed_Year, building.Building_ID]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
","SELECT building.Completed_Year, COUNT(building.Building_ID) AS number_of_buildings FROM building GROUP BY building.Completed_Year;","SELECT Completed_Year ,  COUNT(*) FROM building GROUP BY Completed_Year","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the completion year and the count of buildings completed in that year. 2. Aggregation Structure: Use COUNT to calculate the number of buildings completed in each year. 3. Grouping Structure: Use GROUP BY on ""building.Completed_Year"" to aggregate the results by each completion year. 4. Join Structure: No JOIN is required since all necessary data is within the ""building"" table.",1.0
366,What are the pairs of teachers and students who are in the same class? Give me the pairs of their details.,NON-NESTED,cre_Students_Information_Systems,"[Teachers.teacher_details, Students.student_details, Classes.teacher_id = Teachers.teacher_id, Classes.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Teachers.teacher_details, Students.student_details FROM Classes JOIN Teachers ON Classes.teacher_id = Teachers.teacher_id JOIN Students ON Classes.student_id = Students.student_id;","SELECT T1.teacher_details ,  T3.student_details FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id JOIN Students AS T3 ON T2.student_id  =  T3.student_id","1. Sequential Structure: Start with the SELECT clause to retrieve the details of teachers and students who are in the same class. This includes ""Teachers.teacher_details"" and ""Students.student_details."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Classes"" table with both ""Teachers"" and ""Students"" tables. The ""Classes.teacher_id"" is joined with ""Teachers.teacher_id,"" and ""Classes.student_id"" is joined with ""Students.student_id"" to link teachers and students in the same class. 4. Aggregation Structure: No aggregation is required as the query is focused on retrieving pairs of details without summarization.",1.0
367,Show the name and model year of the vehicle with most number of renting history records.,NON-NESTED,vehicle_rent,"[Vehicles.name, Vehicles.Model_year, Renting_history.vehicles_id, Renting_history.vehicles_id = Vehicles.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, Vehicles.Model_year FROM Vehicles JOIN Renting_history ON Renting_history.vehicles_id = Vehicles.id GROUP BY Vehicles.id ORDER BY COUNT(Renting_history.vehicles_id) DESC LIMIT 1;","SELECT T2.name ,  T2.model_year FROM renting_history AS T1 JOIN vehicles AS T2 ON T1.vehicles_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""Vehicles.name"" and ""Vehicles.Model_year."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the vehicle with the most renting history records. 3. Join Structure: Use a JOIN between the ""Vehicles"" table and the ""Renting_history"" table based on the relationship ""Renting_history.vehicles_id = Vehicles.id"" to link each vehicle with its renting history records. 4. Aggregation Structure: Use COUNT on ""Renting_history.vehicles_id"" to count the number of renting history records for each vehicle. Use ORDER BY in descending order to rank vehicles by the number of renting history records, and LIMIT 1 to select the vehicle with the most records.",1.0
368,List the details of the teachers who teach some class whose detail has the substring 'data' but do not teach a class whose detail contains the prefix 'net',NESTED,cre_Students_Information_Systems,"[Teachers.teacher_id,Classes.teacher_id,Classes.class_details,Classes.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT DISTINCT Teachers.* FROM Teachers JOIN Classes ON Teachers.teacher_id = Classes.teacher_id WHERE Classes.class_details LIKE '%data%' AND Teachers.teacher_id NOT IN ( SELECT teacher_id FROM Classes WHERE class_details LIKE 'net%' );,SELECT T1.teacher_details FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id WHERE T2.class_details LIKE '%data%' EXCEPT SELECT T1.teacher_details FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id WHERE T2.class_details LIKE 'net%',"1. Sequential Structure: Start with the SELECT clause to retrieve the details of teachers. Use the FROM clause to specify the Teachers table and JOIN it with the Classes table to link teachers with the classes they teach. Apply a WHERE clause to filter for teachers who teach classes with details containing the substring 'data' but exclude those who teach classes with details starting with the prefix 'net'. 2. Condition Structure: Use the WHERE clause with conditions to filter for class details containing the substring 'data' using the LIKE operator with '%data%'. Exclude teachers who teach classes with details starting with 'net' using the NOT LIKE operator with 'net%'. 3. Join Structure: Use an INNER JOIN between the Teachers and Classes tables based on teacher_id to connect teachers with the classes they teach. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
369,What are the personal details and the address type descriptions of each student?,NON-NESTED,cre_Students_Information_Systems,"[Students.student_details,Students.student_id,Students_Addresses.address_type_code,Ref_Address_Types.address_type_description,Students_Addresses.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.student_details, Ref_Address_Types.address_type_description FROM Students JOIN Students_Addresses ON Students_Addresses.student_id = Students.student_id JOIN Ref_Address_Types ON Students_Addresses.address_type_code = Ref_Address_Types.address_type_code;","SELECT DISTINCT T1.student_details ,  T3.address_type_description FROM Students AS T1 JOIN Students_Addresses AS T2 ON T1.student_id  =  T2.student_id JOIN Ref_Address_Types AS T3 ON T2.address_type_code  =  T3.address_type_code","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields, which include ""Students.student_details"" and ""Ref_Address_Types.address_type_description."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Students"" table with the ""Students_Addresses"" table on ""Students_Addresses.student_id = Students.student_id"" and then connect ""Students_Addresses"" with ""Ref_Address_Types"" on ""Students_Addresses.address_type_code = Ref_Address_Types.address_type_code."" 4. Aggregation Structure: No aggregation is required as the query is retrieving detailed information for each student.",1.0
370,Show all order ids and their client names.,NON-NESTED,book_1,"[Orders.IdOrder, Client.Name, Orders.IdClient = Client.IdClient]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Orders.IdOrder, Client.Name FROM Orders JOIN Client ON Orders.IdClient = Client.IdClient;","SELECT T1.idOrder ,  T2.name FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient","1. Sequential Structure: Start with the SELECT clause to retrieve ""Orders.IdOrder"" and ""Client.Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Orders"" table and the ""Client"" table based on the relationship ""Orders.IdClient = Client.IdClient"" to link each order with its respective client. 4. Aggregation Structure: No aggregation is required as the query simply retrieves all order IDs and their corresponding client names.",1.0
371,Which customers never used any services ? Give me the customer details .,NESTED,government_shift,"[Customers.Customer_ID,Customers.Customer_Details,Customers_and_Services.Customer_ID = Customers.Customer_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Customer_Details FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Customers_and_Services);,select customer_details from customers where customer_id not in (select customer_id from customers_and_services),"1. Sequential Structure: Start with the SELECT clause to retrieve customer details from the Customers table. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter customers who have not used any services by ensuring their Customer_ID is not present in the Customers_and_Services table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude customers whose Customer_ID appears in the Customers_and_Services table, meaning they have used services. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Customer_ID entries in the Customers_and_Services table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
372,What is the order status code that is most common?,EASY,customers_and_orders,[Customer_Orders.order_status_code],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Customer_Orders.order_status_code FROM Customer_Orders GROUP BY Customer_Orders.order_status_code ORDER BY COUNT(*) DESC LIMIT 1;,SELECT order_status_code FROM Customer_orders GROUP BY order_status_code ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""order_status_code"". 2. Aggregation Structure: Use COUNT to determine the frequency of each ""order_status_code"". 3. Grouping Structure: Use GROUP BY on ""Customer_Orders.order_status_code"" to aggregate the results by each status code. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank the status codes by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common ""order_status_code"". 6. Join Structure: No JOIN is required since all necessary data is within the ""Customer_Orders"" table.",1.0
373,"Show name, type of powertrain, and annual fuel cost for all vehicles with model year 2013 or 2014.",EASY,vehicle_rent,"[Vehicles.name, Vehicles.Type_of_powertrain, Vehicles.Annual_fuel_cost, Vehicles.Model_year, 2013, 2014]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, Vehicles.Type_of_powertrain, Vehicles.Annual_fuel_cost FROM Vehicles WHERE Vehicles.Model_year IN (2013, 2014);","SELECT name ,  type_of_powertrain ,  annual_fuel_cost FROM vehicles WHERE model_year  =  2013 OR model_year  =  2014","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Vehicles.name"", ""Vehicles.Type_of_powertrain"", and ""Vehicles.Annual_fuel_cost"". 2. Condition Structure: Use a WHERE clause to filter vehicles with ""Vehicles.Model_year"" equal to 2013 or 2014. 3. Join Structure: No JOIN is required since all necessary data is within the ""Vehicles"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
374,Show the biographical information of the students whose details include the substring 'Suite'.,EASY,cre_Students_Information_Systems,"[Students.bio_data, Students.student_details]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Students.bio_data FROM Students WHERE Students.student_details LIKE '%Suite%';,SELECT bio_data FROM Students WHERE student_details LIKE '%Suite%',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.bio_data"" field, as the question asks for the biographical information of students. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for student details that include the substring 'Suite'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Students"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving biographical information based on a specific condition.",1.0
375,Show types of powertrain with vehicles both from 2014 and 2013.,NESTED,vehicle_rent,"[Vehicles.Type_of_powertrain, Vehicles.Model_year]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT DISTINCT Type_of_powertrain FROM Vehicles WHERE Type_of_powertrain IN ( SELECT Type_of_powertrain FROM Vehicles WHERE Model_year IN (2013, 2014) GROUP BY Type_of_powertrain HAVING COUNT(DISTINCT Model_year) = 2 );",SELECT type_of_powertrain FROM vehicles WHERE model_year  =  2014 INTERSECT SELECT type_of_powertrain FROM vehicles WHERE model_year  =  2013,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct types of powertrain. Use the FROM clause to specify the Vehicles table. Apply a WHERE clause to filter for vehicles from both 2014 and 2013. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the type of powertrain is associated with vehicles from both 2014 and 2013. This can be achieved by grouping by the type of powertrain and using a HAVING clause to check for the presence of both years. 3. Join Structure: Not required, as all data is available within the Vehicles table. 4. Aggregation Structure: Use GROUP BY to group records by the type of powertrain and HAVING to ensure that both years (2014 and 2013) are present for each type of powertrain.",1.0
376,"What are the minimum, maximum, and average annual fuel costs across all vehicles?",EASY,vehicle_rent,[Vehicles.Annual_fuel_cost],"Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT MIN(Vehicles.Annual_fuel_cost) AS min_fuel_cost, MAX(Vehicles.Annual_fuel_cost) AS max_fuel_cost, AVG(Vehicles.Annual_fuel_cost) AS avg_fuel_cost FROM Vehicles;","SELECT min(annual_fuel_cost) ,  max(annual_fuel_cost) ,  avg(annual_fuel_cost) FROM vehicles","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the minimum, maximum, and average annual fuel costs. 2. Aggregation Structure: Use MIN, MAX, and AVG functions to calculate the minimum, maximum, and average annual fuel costs across all vehicles. 3. Grouping Structure: No GROUP BY is needed since the query asks for aggregate values across all vehicles. 4. Join Structure: No JOIN is required as all necessary data is within the ""Vehicles"" table.",1.0
377,Count the number of teachers who have taught students who have never won an achievement.,NESTED,cre_Students_Information_Systems,"[Teachers.teacher_id,Classes.teacher_id,Classes.student_id,Students.student_id,Achievements.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT COUNT(DISTINCT Teachers.teacher_id) AS teacher_count FROM Teachers JOIN Classes ON Teachers.teacher_id = Classes.teacher_id JOIN Students ON Classes.student_id = Students.student_id LEFT JOIN Achievements ON Students.student_id = Achievements.student_id WHERE Achievements.student_id IS NULL;,SELECT count(DISTINCT T1.teacher_id) FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id WHERE T2.student_id NOT IN ( SELECT student_id FROM Achievements ),"1. Sequential Structure: Start with the SELECT clause to count the number of distinct teachers. Use the FROM clause to specify the Teachers table and JOIN it with the Classes table to link teachers with students they have taught. Further, JOIN the Students table to identify students taught by these teachers. Use a LEFT JOIN with the Achievements table to identify students who have never won an achievement. Apply a WHERE clause to filter out students who have achievements (i.e., where the achievement record is NULL). 2. Condition Structure: Use the WHERE clause to filter for students who have never won an achievement by checking for NULL values in the Achievements table. 3. Join Structure: Use INNER JOINs between Teachers, Classes, and Students to connect teachers with the students they have taught. Use a LEFT JOIN between Students and Achievements to include all students and identify those without achievements. 4. Aggregation Structure: Use COUNT with DISTINCT to count the number of unique teachers who meet the specified condition.",1.0
378,"Show the number of stories of buildings in the region with name ""Abruzzo"".",NON-NESTED,region_building,"[building.Number_of_Stories, region.Name, building.Region_ID = region.Region_ID, Abruzzo]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT COUNT(building.Number_of_Stories) FROM building JOIN region ON building.Region_ID = region.Region_ID WHERE region.Name = 'Abruzzo';,"SELECT T1.Number_of_Stories FROM building AS T1 JOIN region AS T2 ON T1.Region_ID  =  T2.Region_ID WHERE T2.Name  =  ""Abruzzo""","1. Sequential Structure: Start with the SELECT clause to count the number of stories of buildings. Use COUNT to aggregate the number of stories. 2. Condition Structure: Use a WHERE clause to filter for buildings in the region with the name ""Abruzzo."" 3. Join Structure: Use a JOIN between the ""building"" and ""region"" tables based on the ""Region_ID"" field to associate buildings with their respective regions. 4. Aggregation Structure: Use COUNT to calculate the number of stories for buildings in the specified region.",0.0
379,What are the different types of powertrains?,EASY,vehicle_rent,[Vehicles.Type_of_powertrain],"Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT DISTINCT Vehicles.Type_of_powertrain FROM Vehicles;,SELECT DISTINCT type_of_powertrain FROM vehicles,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct types of powertrains. 2. Condition Structure: No specific filtering condition is required as we want all distinct powertrain types. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Vehicles"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique powertrain types are retrieved.",1.0
380,return the details of the customer with largest count of used services.,NON-NESTED,government_shift,"[Customers.Customer_Details,Customers.Customer_ID,Customers_and_Services.Customer_ID,Customers_and_Services.Service_ID,Services.Service_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Customers.Customer_Details FROM Customers JOIN Customers_and_Services ON Customers.Customer_ID = Customers_and_Services.Customer_ID JOIN Services ON Customers_and_Services.Service_ID = Services.Service_ID GROUP BY Customers.Customer_ID ORDER BY COUNT(Customers_and_Services.Service_ID) DESC LIMIT 1;,select t1.customer_details from customers as t1 join customers_and_services as t2 on t1.customer_id  =  t2.customer_id group by t1.customer_details order by count(*) desc limit 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the details of the customer. Since we need the customer with the largest count of used services, we will use COUNT to count the number of services used by each customer. 2. Condition Structure: No specific filtering condition is required, as we are interested in all customers to determine the one with the largest count of services. 3. Join Structure: Use JOINs to connect the ""Customers"" table with the ""Customers_and_Services"" table on ""Customer_ID"" and then with the ""Services"" table on ""Service_ID"" to link customers with their used services. 4. Aggregation Structure: Use COUNT to count the number of services used by each customer, GROUP BY ""Customers.Customer_ID"" to group the counts by customer, and ORDER BY the count in descending order. Use LIMIT 1 to get the customer with the largest count.",1.0
381,List the year in which the most buildings are completed.,EASY,region_building,[building.Completed_Year],"Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT building.Completed_Year FROM building GROUP BY building.Completed_Year ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Completed_Year FROM building GROUP BY Completed_Year ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the year in which the most buildings are completed. 2. Aggregation Structure: Use COUNT to calculate the number of buildings completed in each year. 3. Grouping Structure: Use GROUP BY on ""building.Completed_Year"" to group the results by year. 4. Ordering Structure: Use ORDER BY in descending order on the count of buildings to rank the years by the number of buildings completed. 5. Limiting Structure: Use LIMIT 1 to retrieve the year with the most buildings completed. 6. Join Structure: No JOIN is required since all necessary data is within the ""building"" table.",1.0
382,Show all product names without an order.,NESTED,customers_and_orders,"[Products.product_name,Order_Items.product_id,Products.product_id = Order_Items.product_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT product_name FROM Products WHERE product_id NOT IN (SELECT product_id FROM Order_Items);,SELECT product_name FROM Products EXCEPT SELECT T1.product_name FROM Products AS t1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id,"1. Sequential Structure: Start with the SELECT clause to retrieve product names from the Products table. Use the FROM clause to specify the Products table. Apply a WHERE clause to filter products that do not have any associated orders in the Order_Items table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude products whose product_id appears in the Order_Items table, meaning they have been ordered. 3. Join Structure: Not required, as we only need to filter based on the absence of matching product_id entries in the Order_Items table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
383,Find the details of the customer who has used services the most times.,NON-NESTED,government_shift,"[Customer_Interactions.Customer_ID,Customer_Interactions.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Customers.* FROM Customer_Interactions JOIN Customers ON Customer_Interactions.Customer_ID = Customers.Customer_ID GROUP BY Customer_Interactions.Customer_ID ORDER BY COUNT(Customer_Interactions.Customer_ID) DESC LIMIT 1;,SELECT t1.customer_details FROM customers AS t1 JOIN customers_and_services AS t2 ON t1.customer_id  =  t2.customer_id GROUP BY t1.customer_details ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve all details of the customer. Since we need the customer who has used services the most times, we will use COUNT to count the number of interactions for each customer and ORDER BY in descending order to rank them. Use LIMIT 1 to get the top customer. 2. Condition Structure: No specific filtering condition is required as we are considering all customers. 3. Join Structure: Use a JOIN between the ""Customer_Interactions"" table and the ""Customers"" table based on ""Customer_ID"" to link each interaction with the corresponding customer details. 4. Aggregation Structure: Use COUNT on ""Customer_Interactions.Customer_ID"" to count the number of services used by each customer, then use ORDER BY and LIMIT to find the customer with the highest count.",0.0
384,Which teachers teach a class that has the substring 'data' in its detail but do not teach a class that has prefix 'net' in its detail? Give me the teacher details.,NESTED,cre_Students_Information_Systems,"[Classes.class_details, Classes.teacher_id, Teachers.teacher_details, Classes.teacher_id = Teachers.teacher_id, 'data', 'net']","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Teachers.teacher_details FROM Teachers JOIN Classes ON Teachers.teacher_id = Classes.teacher_id WHERE Classes.class_details LIKE '%data%' AND Teachers.teacher_id NOT IN ( SELECT teacher_id FROM Classes WHERE class_details LIKE 'net%' );,SELECT T1.teacher_details FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id WHERE T2.class_details LIKE '%data%' EXCEPT SELECT T1.teacher_details FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id WHERE T2.class_details LIKE 'net%',"1. Sequential Structure: Start with the SELECT clause to retrieve teacher details from the Teachers table. Use the FROM clause to specify the Teachers table and JOIN it with the Classes table on teacher_id to link teachers with the classes they teach. Apply a WHERE clause to filter teachers who teach classes with 'data' in their details but exclude those who teach classes with 'net' as a prefix in their details. 2. Condition Structure: Use the WHERE clause with conditions to filter for class details containing the substring 'data' using the LIKE operator. Use a subquery with NOT IN to exclude teachers who teach classes with 'net' as a prefix in their details. 3. Join Structure: Use an INNER JOIN between the Teachers and Classes tables based on teacher_id to connect teacher details with the classes they teach. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
385,Which students take 2 courses? List student id and details.,NON-NESTED,cre_Students_Information_Systems,"[Classes.student_id, Students.student_id, Classes.class_id, Classes.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.student_id, Students.* FROM Classes JOIN Students ON Classes.student_id = Students.student_id GROUP BY Classes.student_id HAVING COUNT(Classes.class_id) = 2;","SELECT T1.student_id ,  T1.student_details FROM Students AS T1 JOIN Classes AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2","1. Sequential Structure: Start with the SELECT clause to retrieve the ""student_id"" and other details of students who take exactly 2 courses. Use GROUP BY on ""Classes.student_id"" to group the data by each student. 2. Condition Structure: Use a HAVING clause to filter for students who are associated with exactly 2 courses. 3. Join Structure: Use a JOIN between the ""Classes"" and ""Students"" tables based on the relationship ""Classes.student_id = Students.student_id"" to link each student with their details. 4. Aggregation Structure: Use COUNT on ""Classes.class_id"" to count the number of courses each student is taking, and filter for those with exactly 2 courses using the HAVING clause.",1.0
386,"What is the customer id, name, phone, and email for the customer with most orders?",NON-NESTED,customers_and_orders,"[Customers.customer_id, Customers.customer_name, Customers.customer_phone, Customers.customer_email, Customer_Orders.customer_id, Customer_Orders.order_id, Customer_Orders.customer_id = Customers.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customers.customer_id, Customers.customer_name, Customers.customer_phone, Customers.customer_email FROM Customers JOIN Customer_Orders ON Customer_Orders.customer_id = Customers.customer_id GROUP BY Customers.customer_id ORDER BY COUNT(Customer_Orders.order_id) DESC LIMIT 1;","SELECT T1.customer_id ,  T2.customer_name ,  T2.customer_phone ,  T2.customer_email FROM Customer_orders AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Customers.customer_id,"" ""Customers.customer_name,"" ""Customers.customer_phone,"" and ""Customers.customer_email."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the customer with the most orders. 3. Join Structure: Use a JOIN between the ""Customers"" table and the ""Customer_Orders"" table on ""Customer_Orders.customer_id = Customers.customer_id"" to link customers with their orders. 4. Aggregation Structure: Use COUNT on ""Customer_Orders.order_id"" to count the number of orders for each customer. Use GROUP BY on ""Customers.customer_id"" to group the results by customer. Use ORDER BY in descending order on the count of orders to rank customers by the number of orders, and LIMIT 1 to select the customer with the most orders.",1.0
387,"Count the number of integration platforms that have ""Success"" in the details.",EASY,government_shift,"[Integration_Platform.Integration_Platform_ID,Integration_Platform.Integration_Platform_Details]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT COUNT(Integration_Platform.Integration_Platform_ID) FROM Integration_Platform WHERE Integration_Platform.Integration_Platform_Details LIKE '%Success%';,"SELECT count(*) FROM integration_platform WHERE integration_platform_details  =  ""Success""","1. Sequential Structure: Start with the SELECT clause to count the number of integration platforms. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for integration platforms where the ""Integration_Platform.Integration_Platform_Details"" contains the word ""Success"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Integration_Platform"" table. 4. Aggregation Structure: Use COUNT to calculate the number of integration platforms that meet the specified condition.",1.0
388,What are the names and powertrain types of cars that have more than 30 total rental hours?,NON-NESTED,vehicle_rent,"[Vehicles.name, Vehicles.Type_of_powertrain, Renting_history.vehicles_id = Vehicles.id, Renting_history.total_hours, 30]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, Vehicles.Type_of_powertrain FROM Vehicles JOIN Renting_history ON Renting_history.vehicles_id = Vehicles.id WHERE Renting_history.total_hours > 30;","SELECT T2.name ,  T2.Type_of_powertrain FROM renting_history AS T1 JOIN vehicles AS T2 ON T1.vehicles_id  =  T2.id GROUP BY T1.vehicles_id HAVING sum(T1.total_hours)  >  30","1. Sequential Structure: Start with the SELECT clause to retrieve ""Vehicles.name"" and ""Vehicles.Type_of_powertrain."" 2. Condition Structure: Use a WHERE clause to filter for cars that have more than 30 total rental hours. This will involve checking the ""Renting_history.total_hours"" field. 3. Join Structure: Use a JOIN between the ""Vehicles"" table and the ""Renting_history"" table based on the relationship ""Renting_history.vehicles_id = Vehicles.id"" to link each vehicle with its rental history. 4. Aggregation Structure: No aggregation is needed, as the query only filters and retrieves specific fields without summarizing data.",1.0
389,"For completion year, return the year and the number of buildings completed.",EASY,region_building,[building.Completed_Year],"Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
","SELECT building.Completed_Year, COUNT(*) AS building_count FROM building GROUP BY building.Completed_Year;","SELECT Completed_Year ,  COUNT(*) FROM building GROUP BY Completed_Year","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the completion year and the count of buildings. 2. Aggregation Structure: Use COUNT to calculate the number of buildings completed in each year. 3. Grouping Structure: Use GROUP BY on ""building.Completed_Year"" to count buildings for each completion year. 4. Join Structure: No JOIN is required since all necessary data is within the ""building"" table.",1.0
390,"Sort the buildings in descending order of building completion year, and return the building addresses.",EASY,region_building,"[building.Address, building.Completed_Year]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT building.Address FROM building ORDER BY building.Completed_Year DESC;,SELECT Address FROM building ORDER BY Completed_Year DESC,"1. Sequential Structure: Start with the SELECT clause to specify the required fields, which are the building addresses. 2. Condition Structure: No specific filtering condition is required as we want all buildings. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""building"" table. 4. Ordering Structure: Use ORDER BY in descending order on ""building.Completed_Year"" to sort the buildings by their completion year. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data.",1.0
391,Find the biographical data and details for students whose student loan is above the average amount.,NESTED,cre_Students_Information_Systems,"[Students.bio_data, Students.student_details, Student_Loans.amount_of_loan, Student_Loans.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.bio_data, Students.student_details FROM Students JOIN Student_Loans ON Students.student_id = Student_Loans.student_id WHERE Student_Loans.amount_of_loan > (SELECT AVG(amount_of_loan) FROM Student_Loans);","SELECT T1.bio_data ,  T1.student_details FROM Students AS T1 JOIN Student_Loans AS T2 ON T1.student_id  =  T2.student_id WHERE T2.amount_of_loan  >  ( SELECT avg(amount_of_loan) FROM Student_Loans )","1. Sequential Structure: Start with the SELECT clause to retrieve the biographical data and details of students. Use the FROM clause to specify the Students table and JOIN it with the Student_Loans table on the student_id field to connect students with their loan information. Apply a WHERE clause to filter for students whose loan amount is above the average loan amount. 2. Condition Structure: Use the WHERE clause with a subquery to filter for students whose loan amount is greater than the average loan amount. The subquery calculates the average loan amount from the Student_Loans table. 3. Join Structure: Use an INNER JOIN between the Students and Student_Loans tables based on student_id to link student details with their loan information. 4. Aggregation Structure: Use AVG in a subquery to calculate the average loan amount, which is then used in the filtering condition.",1.0
392,"What were the ids, dates, and status codes for orders made by Jeromy?",NON-NESTED,customers_and_orders,"[Customers.customer_name,Customers.customer_id,Customer_Orders.customer_id = Customers.customer_id,Customer_Orders.order_id,Customer_Orders.order_date,Customer_Orders.order_status_code]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customer_Orders.order_id, Customer_Orders.order_date, Customer_Orders.order_status_code FROM Customers JOIN Customer_Orders ON Customers.customer_id = Customer_Orders.customer_id WHERE Customers.customer_name = 'Jeromy';","SELECT order_id ,  order_date ,  order_status_code FROM Customer_orders AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_name  =  ""Jeromy""","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Customer_Orders.order_id,"" ""Customer_Orders.order_date,"" and ""Customer_Orders.order_status_code."" 2. Condition Structure: Use a WHERE clause to filter for orders made by the customer named ""Jeromy."" This requires filtering ""Customers.customer_name"" for ""Jeromy."" 3. Join Structure: Use an INNER JOIN to connect the ""Customers"" table with the ""Customer_Orders"" table based on the shared key ""customer_id."" 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields for the filtered records.",1.0
393,"Which services are used by the customer ""Hardy Kutch"" or are rated as ""good"" in a customer interaction? Give me the service details.",NON-NESTED,government_shift,"[Services.Service_Details,Customers.Customer_ID,Customers.Customer_Details,Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Service_ID = Services.Service_ID,Customer_Interactions.Status_Code,Hardy Kutch,good]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT DISTINCT Services.Service_Details FROM Customers JOIN Customers_and_Services ON Customers.Customer_ID = Customers_and_Services.Customer_ID JOIN Services ON Customers_and_Services.Service_ID = Services.Service_ID LEFT JOIN Customer_Interactions ON Customer_Interactions.Customer_ID = Customers.Customer_ID AND Customer_Interactions.Service_ID = Services.Service_ID WHERE Customers.Customer_Details = 'Hardy Kutch' OR Customer_Interactions.Status_Code = 'good';,"SELECT DISTINCT t3.service_details FROM customers AS t1 JOIN customers_and_services AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id JOIN customer_interactions AS t4 ON t3.service_id  =  t4.service_id WHERE t1.customer_details  =  ""Hardy Kutch"" OR t4.services_and_channels_details  =  ""good""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Services.Service_Details"" as the question asks for service details. 2. Condition Structure: Use a WHERE clause to filter for services that are either used by the customer ""Hardy Kutch"" or have a ""good"" rating in a customer interaction. This involves checking the customer's name and the ""Customer_Interactions.Status_Code."" 3. Join Structure: Use JOINs to connect the ""Customers,"" ""Services,"" ""Customers_and_Services,"" and ""Customer_Interactions"" tables. Specifically: - Join ""Customers"" with ""Customers_and_Services"" on ""Customers.Customer_ID = Customers_and_Services.Customer_ID."" - Join ""Customers_and_Services"" with ""Services"" on ""Customers_and_Services.Service_ID = Services.Service_ID."" - Join ""Customer_Interactions"" with ""Customers"" on ""Customer_Interactions.Customer_ID = Customers.Customer_ID"" and with ""Services"" on ""Customer_Interactions.Service_ID = Services.Service_ID."" 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving service details based on specific conditions.",0.0
394,Count the number of different customers who have bought a Monitor Product.,NON-NESTED,customers_and_orders,"[Products.product_name, Customers.customer_id, Customer_Orders.customer_id = Customers.customer_id, Order_Items.product_id = Products.product_id, Order_Items.order_id = Customer_Orders.order_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(DISTINCT Customers.customer_id) FROM Products JOIN Order_Items ON Order_Items.product_id = Products.product_id JOIN Customer_Orders ON Order_Items.order_id = Customer_Orders.order_id JOIN Customers ON Customer_Orders.customer_id = Customers.customer_id WHERE Products.product_name = 'Monitor';,"SELECT count(DISTINCT T3.customer_id) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Customer_orders AS T3 ON T3.order_id  =  T1.order_id WHERE T2.product_name  =  ""Monitor""","1. Sequential Structure: Start with the SELECT clause to count the distinct ""Customers.customer_id"" who have purchased a ""Monitor"" product. 2. Condition Structure: Use a WHERE clause to filter for records where ""Products.product_name"" is ""Monitor."" 3. Join Structure: Use multiple JOINs to connect the relevant tables: - Join ""Order_Items"" with ""Products"" on ""Order_Items.product_id = Products.product_id"" to link products with their order items. - Join ""Order_Items"" with ""Customer_Orders"" on ""Order_Items.order_id = Customer_Orders.order_id"" to link order items with customer orders. - Join ""Customer_Orders"" with ""Customers"" on ""Customer_Orders.customer_id = Customers.customer_id"" to link customer orders with customers. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique customer IDs who purchased the specified product.",1.0
395,Give me the type code and description of the least common detention type.,NESTED,cre_Students_Information_Systems,"[Ref_Detention_Type.detention_type_code, Ref_Detention_Type.detention_type_description, Detention.detention_type_code = Ref_Detention_Type.detention_type_code]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Ref_Detention_Type.detention_type_code, Ref_Detention_Type.detention_type_description FROM Ref_Detention_Type JOIN Detention ON Ref_Detention_Type.detention_type_code = Detention.detention_type_code GROUP BY Ref_Detention_Type.detention_type_code, Ref_Detention_Type.detention_type_description ORDER BY COUNT(Detention.detention_type_code) ASC LIMIT 1;","SELECT T1.detention_type_code ,  T2.detention_type_description FROM Detention AS T1 JOIN Ref_Detention_Type AS T2 ON T1.detention_type_code  =  T2.detention_type_code GROUP BY T1.detention_type_code ORDER BY count(*) ASC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the detention type code and description. Use the FROM clause to specify the Ref_Detention_Type table and JOIN it with the Detention table to link detention types with their occurrences. Use GROUP BY to group by detention type code and description, and apply an ORDER BY clause to sort by the count of occurrences in ascending order. Use LIMIT to retrieve the least common detention type. 2. Condition Structure: No specific filtering condition is required, as we are interested in the least common detention type based on its occurrence count. 3. Join Structure: Use an INNER JOIN between the Ref_Detention_Type and Detention tables on the detention_type_code to connect detention types with their occurrences. 4. Aggregation Structure: Use COUNT to calculate the number of occurrences for each detention type and sort them in ascending order to identify the least common type.",1.0
396,"Which customers have integration platform details ""Fail"" in interactions? Give me the customer details.",NON-NESTED,government_shift,"[Customers.Customer_Details,Integration_Platform.Integration_Platform_Details,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Fail]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Customers.Customer_Details FROM Customers JOIN Customer_Interactions ON Customer_Interactions.Customer_ID = Customers.Customer_ID JOIN Integration_Platform ON Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID WHERE Integration_Platform.Integration_Platform_Details = 'Fail';,"SELECT DISTINCT t1.customer_details FROM customers AS t1 JOIN customer_interactions AS t2 ON t1.customer_id  =  t2.customer_id JOIN integration_platform AS t3 WHERE t3.integration_platform_details  =  ""Fail""","1. Sequential Structure: Start with the SELECT clause to retrieve customer details from the ""Customers"" table. 2. Condition Structure: Use a WHERE clause to filter for records where the ""Integration_Platform.Integration_Platform_Details"" is ""Fail."" 3. Join Structure: Use JOINs to connect the ""Customers"" table with ""Customer_Interactions"" on ""Customer_Interactions.Customer_ID = Customers.Customer_ID"" and then connect ""Customer_Interactions"" with ""Integration_Platform"" on ""Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID."" 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving specific customer details.",0.0
397,List the the address details and the biographical information of the students.,NON-NESTED,cre_Students_Information_Systems,"[Addresses.address_details, Students.bio_data, Students_Addresses.address_id = Addresses.address_id, Students_Addresses.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Addresses.address_details, Students.bio_data FROM Students JOIN Students_Addresses ON Students_Addresses.student_id = Students.student_id JOIN Addresses ON Students_Addresses.address_id = Addresses.address_id;","SELECT T1.address_details ,  T3.bio_data FROM Addresses AS T1 JOIN Students_Addresses AS T2 ON T1.address_id  =  T2.address_id JOIN Students AS T3 ON T2.student_id  =  T3.student_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Addresses.address_details"" and ""Students.bio_data."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Students"" table with the ""Addresses"" table through the ""Students_Addresses"" table. Specifically, join ""Students_Addresses.student_id"" with ""Students.student_id"" and ""Students_Addresses.address_id"" with ""Addresses.address_id."" 4. Aggregation Structure: No aggregation is required as the query simply retrieves the address details and biographical information of students.",1.0
398,What are the names of regions in which there are no buildings?,NESTED,region_building,"[region.Name,building.Region_ID,region.Region_ID = building.Region_ID]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT region.Name FROM region WHERE region.Region_ID NOT IN (SELECT building.Region_ID FROM building);,SELECT Name FROM region WHERE Region_ID NOT IN (SELECT Region_ID FROM building),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of regions. Use the FROM clause to specify the region table. Apply a WHERE clause to filter regions that do not have any associated buildings. 2. Condition Structure: Use the WHERE clause with a subquery to exclude regions whose Region_ID appears in the building table, meaning they have associated buildings. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Region_ID entries in the building table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
399,What are the address details and biographical information of each student?,NON-NESTED,cre_Students_Information_Systems,"[Students.student_id,Students.bio_data,Students_Addresses.student_id = Students.student_id,Students_Addresses.address_id = Addresses.address_id,Addresses.address_details]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.bio_data, Addresses.address_details FROM Students JOIN Students_Addresses ON Students.student_id = Students_Addresses.student_id JOIN Addresses ON Students_Addresses.address_id = Addresses.address_id;","SELECT T1.address_details ,  T3.bio_data FROM Addresses AS T1 JOIN Students_Addresses AS T2 ON T1.address_id  =  T2.address_id JOIN Students AS T3 ON T2.student_id  =  T3.student_id","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields, ""Students.bio_data"" and ""Addresses.address_details."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Students"" table with ""Students_Addresses"" on ""Students.student_id,"" and then connect ""Students_Addresses"" with ""Addresses"" on ""Addresses.address_id"" to link each student with their address details. 4. Aggregation Structure: No aggregation is needed as the query is retrieving detailed information for each student.",1.0
400,"What are the titles, ISBNs, and sale prices for all books?",EASY,book_1,"[Book.Title, Book.ISBN, Book.SalePrice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Book.Title, Book.ISBN, Book.SalePrice FROM Book;","SELECT title ,  isbn ,  SalePrice FROM Book","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the book titles, ISBNs, and sale prices. 2. Condition Structure: No specific filtering condition is required as the query asks for all books. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Book"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all books.",1.0
401,Find the name and powertrain type of the cars that rented for more than 30 total hours.,NON-NESTED,vehicle_rent,"[Vehicles.name, Vehicles.Type_of_powertrain, Renting_history.vehicles_id, Renting_history.total_hours, Renting_history.vehicles_id = Vehicles.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, Vehicles.Type_of_powertrain FROM Vehicles JOIN Renting_history ON Renting_history.vehicles_id = Vehicles.id WHERE Renting_history.total_hours > 30;","SELECT T2.name ,  T2.Type_of_powertrain FROM renting_history AS T1 JOIN vehicles AS T2 ON T1.vehicles_id  =  T2.id GROUP BY T1.vehicles_id HAVING sum(T1.total_hours)  >  30","1. Sequential Structure: Start with the SELECT clause to retrieve ""Vehicles.name"" and ""Vehicles.Type_of_powertrain."" 2. Condition Structure: Use a WHERE clause to filter for cars that have been rented for more than 30 total hours. This condition will be applied to the ""Renting_history.total_hours"" field. 3. Join Structure: Use a JOIN between the ""Vehicles"" table and the ""Renting_history"" table based on the relationship ""Renting_history.vehicles_id = Vehicles.id"" to link each vehicle with its renting history. 4. Aggregation Structure: No aggregation is needed since the query only involves filtering and retrieving specific fields.",1.0
402,What are the ids and details of the students who take 2 courses?,NESTED,cre_Students_Information_Systems,"[Students.student_id,Classes.student_id,Classes.class_id,Classes.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.student_id, Students.* FROM Students JOIN Classes ON Students.student_id = Classes.student_id GROUP BY Students.student_id HAVING COUNT(Classes.class_id) = 2;","SELECT T1.student_id ,  T1.student_details FROM Students AS T1 JOIN Classes AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2","1. Sequential Structure: Start with the SELECT clause to retrieve the student IDs and details from the Students table. Use the FROM clause to specify the Students table and JOIN it with the Classes table to link students with the courses they take. Use GROUP BY to group records by student_id, allowing us to count the number of courses each student takes. Apply a HAVING clause to filter students who take exactly 2 courses. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for students who are enrolled in exactly 2 courses. 3. Join Structure: Use an INNER JOIN between the Students and Classes tables based on student_id to connect student details with their course enrollments. 4. Aggregation Structure: Use COUNT(*) within HAVING to aggregate the number of courses per student and filter out students who take fewer or more than 2 courses.",1.0
403,How many buildings are there?,EASY,region_building,[building.Building_ID],"Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT COUNT(building.Building_ID) AS total_buildings FROM building;,SELECT count(*) FROM building,"1. Sequential Structure: Start with the SELECT clause to count the number of buildings. 2. Aggregation Structure: Use the COUNT function to calculate the total number of buildings. 3. Condition Structure: No specific filtering condition is required as we want the total count of all buildings. 4. Join Structure: No JOIN is required since all necessary data is within the ""building"" table.",1.0
404,Give the payment method code and customer number corresponding to the customer named Jeromy.,EASY,customers_and_orders,"[Customers.payment_method_code, Customers.customer_number, Customers.customer_name, Customers.customer_name = 'Jeromy']","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customers.payment_method_code, Customers.customer_number FROM Customers WHERE Customers.customer_name = 'Jeromy';","SELECT payment_method_code ,  customer_number FROM Customers WHERE customer_name  =  ""Jeromy""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""payment_method_code"" and ""customer_number"" for the customer named ""Jeromy"". 2. Condition Structure: Use a WHERE clause to filter for the customer whose ""customer_name"" is 'Jeromy'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
405,"What are the names of vehicles, sorted descending by total hours of renting?",NON-NESTED,vehicle_rent,"[Vehicles.name, Renting_history.total_hours, Renting_history.vehicles_id = Vehicles.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, SUM(Renting_history.total_hours) AS total_renting_hours FROM Vehicles JOIN Renting_history ON Renting_history.vehicles_id = Vehicles.id GROUP BY Vehicles.name ORDER BY total_renting_hours DESC;",SELECT T2.name FROM renting_history AS T1 JOIN vehicles AS T2 ON T1.vehicles_id  =  T2.id GROUP BY T2.id ORDER BY sum(T1.total_hours) DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Vehicles.name"" and the total hours of renting. Use SUM on ""Renting_history.total_hours"" to calculate the total hours for each vehicle. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Vehicles"" table and the ""Renting_history"" table based on the relationship ""Renting_history.vehicles_id = Vehicles.id"" to link each vehicle with its renting history. 4. Aggregation Structure: Use SUM to aggregate the total hours of renting for each vehicle, then GROUP BY ""Vehicles.name"" to group the results by vehicle. Finally, use ORDER BY in descending order on the aggregated total hours to sort the results.",1.0
406,How many customers use each payment method?,NON-NESTED,customers_and_orders,"[Customers.payment_method_code, Customers.customer_id, Customer_Orders.customer_id = Customers.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customers.payment_method_code, COUNT(Customers.customer_id) AS customer_count FROM Customers GROUP BY Customers.payment_method_code;","SELECT payment_method_code ,  count(*) FROM Customers GROUP BY payment_method_code","1. Sequential Structure: Start with the SELECT clause to retrieve the ""payment_method_code"" and the count of customers using each payment method. Use COUNT on ""Customers.customer_id"" to count the number of customers for each payment method. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: No JOIN is necessary since all the required data is available in the ""Customers"" table. 4. Aggregation Structure: Use GROUP BY on ""payment_method_code"" to group the results by each payment method and apply COUNT to calculate the number of customers for each group.",1.0
407,What are the date and detail of each transcript?,EASY,cre_Students_Information_Systems,"[Transcripts.date_of_transcript, Transcripts.transcript_details]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Transcripts.date_of_transcript, Transcripts.transcript_details FROM Transcripts;","SELECT date_of_transcript ,  transcript_details FROM Transcripts","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""Transcripts.date_of_transcript"" and ""Transcripts.transcript_details"". 2. Condition Structure: No specific filtering condition is required as the query asks for all transcripts. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Transcripts"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving all records without any summarization.",1.0
408,What is the average population for all regions?,EASY,region_building,[region.Population],"Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT AVG(region.Population) AS avg_population FROM region;,SELECT avg(Population) FROM region,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average population. 2. Aggregation Structure: Use the AVG function to calculate the average population across all regions. 3. Condition Structure: No specific filtering condition is required as the query asks for the average population of all regions. 4. Join Structure: No JOIN is required since all necessary data is within the ""region"" table.",1.0
409,What is the transcript issuance date for the student with the largest amount of loan?,NON-NESTED,cre_Students_Information_Systems,"[Student_Loans.amount_of_loan,Student_Loans.student_id,Transcripts.date_of_transcript,Transcripts.student_id = Student_Loans.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Transcripts.date_of_transcript FROM Student_Loans JOIN Transcripts ON Transcripts.student_id = Student_Loans.student_id WHERE Student_Loans.amount_of_loan = (SELECT MAX(Student_Loans.amount_of_loan) FROM Student_Loans);,SELECT T1.date_of_transcript FROM Transcripts AS T1 JOIN Student_Loans AS T2 ON T1.student_id  =  T2.student_id ORDER BY T2.amount_of_loan DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Transcripts.date_of_transcript"" field. 2. Condition Structure: Use a WHERE clause to filter for the student with the largest loan amount. This requires a subquery to find the maximum ""Student_Loans.amount_of_loan."" 3. Join Structure: Use a JOIN between the ""Student_Loans"" and ""Transcripts"" tables based on the ""student_id"" field to link each loan record with its corresponding transcript. 4. Aggregation Structure: Use MAX in the subquery to determine the largest loan amount, and filter the main query using this value.",1.0
410,What is the total number of Monitor products that have been ordered?,NON-NESTED,customers_and_orders,"[Products.product_name, Products.product_id, Order_Items.product_id = Products.product_id, Order_Items.order_quantity]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT SUM(Order_Items.order_quantity) FROM Products JOIN Order_Items ON Products.product_id = Order_Items.product_id WHERE Products.product_name = 'Monitor';,"SELECT sum(order_quantity) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id WHERE T2.product_name  =  ""Monitor""","1. Sequential Structure: Start with the SELECT clause to calculate the total number of ""Monitor"" products ordered. Use the SUM function on ""Order_Items.order_quantity"" to compute the total quantity. 2. Condition Structure: Use a WHERE clause to filter for products with the name ""Monitor"" in the ""Products"" table. 3. Join Structure: Use an INNER JOIN to connect the ""Products"" table with the ""Order_Items"" table based on the shared ""product_id"" field. 4. Aggregation Structure: Use the SUM function to aggregate the ""order_quantity"" values for the filtered ""Monitor"" products.",1.0
411,Show all book titles and corresponding author names.,NON-NESTED,book_1,"[Book.Title, Author.Name, Author_Book.ISBN = Book.ISBN, Author_Book.Author = Author.idAuthor]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Book.Title, Author.Name FROM Book JOIN Author_Book ON Book.ISBN = Author_Book.ISBN JOIN Author ON Author_Book.Author = Author.idAuthor;","SELECT T3.title ,  T1.name FROM Author AS T1 JOIN Author_Book AS T2 ON T2.Author  =  T1.idAuthor JOIN Book AS T3 ON T2.isbn  =  T3.isbn","1. Sequential Structure: Start with the SELECT clause to retrieve ""Book.Title"" and ""Author.Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Book"" table with the ""Author_Book"" table on ""Book.ISBN = Author_Book.ISBN"" and then connect the ""Author_Book"" table with the ""Author"" table on ""Author_Book.Author = Author.idAuthor"" to link books with their respective authors. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all book titles and their corresponding author names.",1.0
412,Count the number of customers.,EASY,customers_and_orders,[Customers.customer_id],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(Customers.customer_id) AS customer_count FROM Customers;,SELECT count(*) FROM Customers,"1. Sequential Structure: Start with the SELECT clause to count the number of customers. 2. Aggregation Structure: Use the COUNT function to count the total number of customer IDs. 3. Condition Structure: No specific filtering condition is required as we want the total count of all customers. 4. Join Structure: No JOIN is required since all necessary data is within the ""Customers"" table.",1.0
413,Show all information for all discounts.,EASY,vehicle_rent,"[Discount.id, Discount.name, Discount.membership_credit]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT * FROM Discount;,SELECT * FROM discount,"1. Sequential Structure: Start with the SELECT clause to retrieve all fields from the ""Discount"" table since the question asks for all information. 2. Condition Structure: No specific filtering condition is required as the query is meant to retrieve all records. 3. Join Structure: No JOIN is necessary since all required data is within the ""Discount"" table. 4. Aggregation Structure: No aggregation is needed as the query is simply retrieving all information.",1.0
414,List all distinct types of powertrain of vehicles.,EASY,vehicle_rent,[Vehicles.Type_of_powertrain],"Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT DISTINCT Vehicles.Type_of_powertrain FROM Vehicles;,SELECT DISTINCT type_of_powertrain FROM vehicles,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct types of powertrain from the ""Vehicles"" table. 2. Condition Structure: No specific filtering condition is required as we want all distinct types of powertrain. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Vehicles"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique types of powertrain are retrieved.",1.0
415,What is the code and description of the most common student address type?,NON-NESTED,cre_Students_Information_Systems,"[Ref_Address_Types.address_type_code,Ref_Address_Types.address_type_description,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Ref_Address_Types.address_type_code, Ref_Address_Types.address_type_description FROM Students_Addresses JOIN Ref_Address_Types ON Students_Addresses.address_type_code = Ref_Address_Types.address_type_code GROUP BY Ref_Address_Types.address_type_code, Ref_Address_Types.address_type_description ORDER BY COUNT(Students_Addresses.address_type_code) DESC LIMIT 1;","SELECT T1.address_type_code ,  T2.address_type_description FROM Students_Addresses AS T1 JOIN Ref_Address_Types AS T2 WHERE T1.address_type_code  =  T2.address_type_code GROUP BY T1.address_type_code ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""Ref_Address_Types.address_type_code"" and ""Ref_Address_Types.address_type_description."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the most common address type. 3. Join Structure: Use a JOIN between ""Students_Addresses"" and ""Ref_Address_Types"" on ""address_type_code"" to link student addresses with their corresponding address type descriptions. 4. Aggregation Structure: Use COUNT to determine the frequency of each address type. Use ORDER BY in descending order on the count to rank address types by frequency, and LIMIT 1 to select the most common address type.",1.0
416,What are the names of customers who have two or more records of rental history?,NON-NESTED,vehicle_rent,"[Customers.name, Renting_history.customer_id, Renting_history.customer_id = Customers.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT Customers.name FROM Customers JOIN Renting_history ON Renting_history.customer_id = Customers.id GROUP BY Renting_history.customer_id HAVING COUNT(Renting_history.customer_id) >= 2;,SELECT T2.name FROM renting_history AS T1 JOIN customers AS T2 ON T1.customer_id  =  T2.id GROUP BY T2.id HAVING count(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of customers. Use GROUP BY to group records by customer ID, as we need to count the number of rental history records for each customer. Use HAVING to filter customers with two or more rental history records. 2. Condition Structure: Use a HAVING clause to filter groups where the count of rental history records is two or more. 3. Join Structure: Use a JOIN between the ""Customers"" table and the ""Renting_history"" table based on the relationship ""Renting_history.customer_id = Customers.id"" to associate rental history records with customer names. 4. Aggregation Structure: Use COUNT on ""Renting_history.customer_id"" to count the number of rental history records for each customer.",1.0
417,Give me the capitals of the regions whose area is larger than 10000.,EASY,region_building,"[region.Capital, region.Area, region.Region_ID = building.Region_ID]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT region.Capital FROM region WHERE region.Area > 10000;,SELECT Capital FROM region WHERE Area  >  10000,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the capital of the regions. 2. Condition Structure: Use a WHERE clause to filter regions where the ""region.Area"" is larger than 10000. 3. Join Structure: No JOIN is required since all necessary information is in the ""region"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the capitals of regions that meet the specified area condition.",1.0
418,Find the average city and highway fuel rates for cars with different powertrain types.,EASY,vehicle_rent,"[Vehicles.Type_of_powertrain, Vehicles.City_fuel_economy_rate, Vehicles.Highway_fuel_economy_rate]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.Type_of_powertrain, AVG(Vehicles.City_fuel_economy_rate) AS avg_city_fuel_rate, AVG(Vehicles.Highway_fuel_economy_rate) AS avg_highway_fuel_rate FROM Vehicles GROUP BY Vehicles.Type_of_powertrain;","SELECT avg(City_fuel_economy_rate) ,  avg(Highway_fuel_economy_rate) , Type_of_powertrain FROM vehicles GROUP BY Type_of_powertrain","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the type of powertrain and the average city and highway fuel economy rates. 2. Aggregation Structure: Use the AVG function to calculate the average city and highway fuel economy rates for each powertrain type. 3. Grouping Structure: Use GROUP BY on ""Vehicles.Type_of_powertrain"" to calculate these aggregate values for each powertrain type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Vehicles"" table.",1.0
419,Find the details of the customer who has never used any services .,NESTED,government_shift,"[Customers.Customer_ID,Customers_and_Services.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT * FROM Customers WHERE Customer_ID NOT IN (SELECT Customer_ID FROM Customers_and_Services);,select customer_details from customers where customer_id not in (select customer_id from customers_and_services),"1. Sequential Structure: Start with the SELECT clause to retrieve all details of customers. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter customers who have never used any services by ensuring their Customer_ID is not present in the Customers_and_Services table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude customers whose Customer_ID appears in the Customers_and_Services table, indicating they have used services. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Customer_ID entries in the Customers_and_Services table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
420,In which year did the most building constructions complete?,EASY,region_building,[building.Completed_Year],"Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT building.Completed_Year FROM building GROUP BY building.Completed_Year ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Completed_Year FROM building GROUP BY Completed_Year ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the year of building completion, as the question asks for the year with the most building constructions completed. 2. Aggregation Structure: Use COUNT to calculate the number of buildings completed in each year. 3. Grouping Structure: Use GROUP BY on ""building.Completed_Year"" to group the results by each year. 4. Ordering Structure: Use ORDER BY in descending order on the count of buildings to rank the years by the number of constructions completed. 5. Limiting Structure: Use LIMIT 1 to retrieve the year with the highest number of building completions. 6. Join Structure: No JOIN is required since all necessary data is within the ""building"" table.",1.0
421,How much total loan does each student have ? List the student ids and the amounts .,NON-NESTED,cre_Students_Information_Systems,"[Student_Loans.student_id, Student_Loans.amount_of_loan, Students.student_id = Student_Loans.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Student_Loans.student_id, SUM(Student_Loans.amount_of_loan) AS total_loan FROM Student_Loans GROUP BY Student_Loans.student_id;","select student_id ,  sum(amount_of_loan) from student_loans group by student_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Student_Loans.student_id"" and the total loan amount for each student. Use the SUM function to calculate the total loan amount. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: No JOIN is necessary since all the required data is available in the ""Student_Loans"" table. 4. Aggregation Structure: Use SUM to calculate the total loan amount for each student and GROUP BY ""Student_Loans.student_id"" to group the results by student ID.",1.0
422,"For each student, find the student id, student biographical data, and the number of courses he or she takes.",NON-NESTED,cre_Students_Information_Systems,"[Students.student_id, Students.bio_data, Classes.student_id, Classes.class_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.student_id, Students.bio_data, COUNT(Classes.class_id) AS num_courses FROM Students JOIN Classes ON Students.student_id = Classes.student_id GROUP BY Students.student_id;","SELECT T1.student_id ,  T1.bio_data ,  count(*) FROM Students AS T1 JOIN Classes AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.student_id,"" ""Students.bio_data,"" and the count of courses each student takes. Use COUNT on ""Classes.class_id"" to count the number of courses. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Students"" and ""Classes"" tables based on ""Students.student_id"" and ""Classes.student_id"" to associate each student with their courses. 4. Aggregation Structure: Use COUNT on ""Classes.class_id"" to count the number of courses for each student, and GROUP BY ""Students.student_id"" to group the results by each student.",1.0
423,Count the number of students who have a detention record.,NON-NESTED,cre_Students_Information_Systems,"[Detention.student_id,Students.student_id,Detention.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT COUNT(DISTINCT Detention.student_id) FROM Detention JOIN Students ON Detention.student_id = Students.student_id;,SELECT count(DISTINCT student_id) FROM Detention,"1. Sequential Structure: Start with the SELECT clause to count the number of students who have a detention record. Use COUNT on ""Detention.student_id"" to get the total number of students with a detention record. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all students with a detention record. 3. Join Structure: Use an INNER JOIN between the ""Detention"" and ""Students"" tables on ""Detention.student_id = Students.student_id"" to ensure we only count students who have a matching record in both tables. 4. Aggregation Structure: Use COUNT to aggregate the number of students with a detention record.",1.0
424,What is the average amount of a student loan?,EASY,cre_Students_Information_Systems,[Student_Loans.amount_of_loan],"Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT AVG(Student_Loans.amount_of_loan) AS average_loan FROM Student_Loans;,SELECT avg(amount_of_loan) FROM Student_Loans,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average amount of a student loan. 2. Aggregation Structure: Use the AVG function to calculate the average of the ""Student_Loans.amount_of_loan"" field. 3. Condition Structure: No specific filtering condition is required as we want the average for all student loans. 4. Join Structure: No JOIN is required since all necessary data is within the ""Student_Loans"" table.",1.0
425,"What is the type of event the most students joined? Give me the number of students, and the event type code and description.",NON-NESTED,cre_Students_Information_Systems,"[Student_Events.event_type_code,Student_Events.student_id,Ref_Event_Types.event_type_code = Student_Events.event_type_code,Ref_Event_Types.event_type_description]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Student_Events.event_type_code, Ref_Event_Types.event_type_description, COUNT(Student_Events.student_id) AS student_count FROM Student_Events JOIN Ref_Event_Types ON Ref_Event_Types.event_type_code = Student_Events.event_type_code GROUP BY Student_Events.event_type_code, Ref_Event_Types.event_type_description ORDER BY student_count DESC LIMIT 1;","SELECT count(*) ,  T2.event_type_code ,  T3.event_type_description FROM Students AS T1 JOIN Student_Events AS T2 ON T1.student_id  =  T2.student_id JOIN Ref_Event_Types AS T3 ON T2.event_type_code  =  T3.event_type_code GROUP BY T2.event_type_code ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the event type code, its description, and the number of students who joined each event type. Use COUNT on ""Student_Events.student_id"" to count the number of students for each event type. 2. Condition Structure: No specific filtering condition is required, as we are interested in all event types. 3. Join Structure: Use a JOIN between ""Student_Events"" and ""Ref_Event_Types"" on ""event_type_code"" to link each event type with its description. 4. Aggregation Structure: Use GROUP BY on ""Student_Events.event_type_code"" and ""Ref_Event_Types.event_type_description"" to group the results by event type. Use ORDER BY in descending order of the student count to rank the event types by popularity, and LIMIT 1 to select the event type with the most students.",1.0
426,What is the least common detention type? Show the type code and the description.,NON-NESTED,cre_Students_Information_Systems,"[Detention.detention_type_code, Ref_Detention_Type.detention_type_code, Ref_Detention_Type.detention_type_description]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Ref_Detention_Type.detention_type_code, Ref_Detention_Type.detention_type_description FROM Detention JOIN Ref_Detention_Type ON Detention.detention_type_code = Ref_Detention_Type.detention_type_code GROUP BY Ref_Detention_Type.detention_type_code, Ref_Detention_Type.detention_type_description ORDER BY COUNT(Detention.detention_type_code) ASC LIMIT 1;","SELECT T1.detention_type_code ,  T2.detention_type_description FROM Detention AS T1 JOIN Ref_Detention_Type AS T2 ON T1.detention_type_code  =  T2.detention_type_code GROUP BY T1.detention_type_code ORDER BY count(*) ASC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""detention_type_code"" and ""detention_type_description."" Use an aggregate function (COUNT) to count the occurrences of each detention type. 2. Condition Structure: No specific filtering condition is required, as we are interested in all detention types. 3. Join Structure: Use a JOIN between the ""Detention"" table and the ""Ref_Detention_Type"" table on the ""detention_type_code"" field to link detention records with their descriptions. 4. Aggregation Structure: Use COUNT to count the occurrences of each detention type, then use ORDER BY in ascending order to find the least common type. Use LIMIT 1 to select the least common detention type.",1.0
427,What are the biographical data and the date of transcript issuance of each student?,NON-NESTED,cre_Students_Information_Systems,"[Students.bio_data, Transcripts.date_of_transcript, Transcripts.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.bio_data, Transcripts.date_of_transcript FROM Students JOIN Transcripts ON Transcripts.student_id = Students.student_id;","SELECT T1.bio_data ,  T2.date_of_transcript FROM Students AS T1 JOIN Transcripts AS T2 ON T1.student_id  =  T2.student_id","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields, ""Students.bio_data"" and ""Transcripts.date_of_transcript."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Students"" and ""Transcripts"" tables based on the relationship ""Transcripts.student_id = Students.student_id"" to link each student with their transcript data. 4. Aggregation Structure: No aggregation is required as the query simply retrieves data for each student.",1.0
428,How many authors are there?,EASY,book_1,[Author.idAuthor],"Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT COUNT(Author.idAuthor) AS total_authors FROM Author;,SELECT count(*) FROM Author,"1. Sequential Structure: Start with the SELECT clause to count the number of authors. 2. Aggregation Structure: Use COUNT to calculate the total number of authors based on their unique IDs. 3. Join Structure: No JOIN is required since all necessary data is within the ""Author"" table. 4. Condition Structure: No specific filtering condition is needed as we want the total count of all authors.",1.0
429,Show the completed years shared by buildings with more than 20 stories and buildings with less than 15 stories.,NESTED,region_building,"[building.Completed_Year, building.Number_of_Stories, 20, 15]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT Completed_Year FROM building WHERE Number_of_Stories > 20 INTERSECT SELECT Completed_Year FROM building WHERE Number_of_Stories < 15;,SELECT Completed_Year FROM building WHERE Number_of_Stories  >  20 INTERSECT SELECT Completed_Year FROM building WHERE Number_of_Stories  <  15,"1. Sequential Structure: Start with the SELECT clause to retrieve the completed years. Use the FROM clause to specify the building table. Apply a WHERE clause to filter buildings with more than 20 stories and buildings with less than 15 stories. Use an INTERSECT operator to find the shared completed years between these two groups. 2. Condition Structure: Use two separate WHERE clauses to filter buildings with more than 20 stories and buildings with less than 15 stories. The INTERSECT operator will ensure only the shared completed years are returned. 3. Join Structure: Not required, as all data is within the building table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
430,Show the name of customer with at least two renting history records.,NON-NESTED,vehicle_rent,"[Customers.name, Renting_history.customer_id, Renting_history.customer_id = Customers.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT Customers.name FROM Customers JOIN Renting_history ON Renting_history.customer_id = Customers.id GROUP BY Customers.id HAVING COUNT(Renting_history.customer_id) >= 2;,SELECT T2.name FROM renting_history AS T1 JOIN customers AS T2 ON T1.customer_id  =  T2.id GROUP BY T2.id HAVING count(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Customers.name."" 2. Condition Structure: Use a HAVING clause to filter customers who have at least two renting history records. This requires counting the occurrences of ""Renting_history.customer_id."" 3. Join Structure: Use a JOIN between the ""Customers"" table and the ""Renting_history"" table based on ""Renting_history.customer_id = Customers.id"" to associate each customer with their renting history. 4. Aggregation Structure: Use COUNT on ""Renting_history.customer_id"" to count the number of renting history records for each customer, then filter with HAVING to select customers with at least two records.",1.0
431,Show the names of buildings and the names of regions they are in.,NON-NESTED,region_building,"[building.Name, region.Name, building.Region_ID = region.Region_ID]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
","SELECT building.Name, region.Name FROM building JOIN region ON building.Region_ID = region.Region_ID;","SELECT T1.Name ,  T2.Name FROM building AS T1 JOIN region AS T2 ON T1.Region_ID  =  T2.Region_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""building.Name"" and ""region.Name."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""building"" and ""region"" tables based on the shared key ""Region_ID"" to associate each building with its respective region. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves and displays the names of buildings and their corresponding regions.",1.0
432,"Show all customer names, ids and the number of orders by each customer.",NON-NESTED,customers_and_orders,"[Customers.customer_name, Customers.customer_id, Customer_Orders.customer_id = Customers.customer_id, Customer_Orders.order_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customers.customer_name, Customers.customer_id, COUNT(Customer_Orders.order_id) AS number_of_orders FROM Customers JOIN Customer_Orders ON Customers.customer_id = Customer_Orders.customer_id GROUP BY Customers.customer_id;","SELECT T2.customer_name ,  T1.customer_id ,  count(*) FROM Customer_orders AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Customers.customer_name,"" ""Customers.customer_id,"" and the count of ""Customer_Orders.order_id"" for each customer. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""Customers"" table with the ""Customer_Orders"" table based on the shared key ""customer_id."" 4. Aggregation Structure: Use COUNT on ""Customer_Orders.order_id"" to count the number of orders for each customer, and GROUP BY ""Customers.customer_id"" to group the results by each customer.",1.0
433,"Return the number of stories for each building in the region named ""Abruzzo"".",NON-NESTED,region_building,"[building.Number_of_Stories,region.Name,building.Region_ID = region.Region_ID,Abruzzo]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
","SELECT building.Number_of_Stories, COUNT(*) FROM building JOIN region ON building.Region_ID = region.Region_ID WHERE region.Name = 'Abruzzo' GROUP BY building.Number_of_Stories;","SELECT T1.Number_of_Stories FROM building AS T1 JOIN region AS T2 ON T1.Region_ID  =  T2.Region_ID WHERE T2.Name  =  ""Abruzzo""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""building.Number_of_Stories"" and group them by each building. Also include the ""region.Name"" to filter for the specific region named ""Abruzzo."" 2. Condition Structure: Use a WHERE clause to filter for the region with the name ""Abruzzo."" 3. Join Structure: Use a JOIN between the ""building"" and ""region"" tables based on the ""Region_ID"" field to associate buildings with their respective regions. 4. Aggregation Structure: Use COUNT to calculate the number of stories for each building in the specified region.",1.0
434,Which student is taking the most courses? Give me the id of the student and the number of courses he or she is taking.,NON-NESTED,cre_Students_Information_Systems,"[Classes.student_id, COUNT(Classes.class_id), Classes.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Classes.student_id, COUNT(Classes.class_id) AS course_count FROM Classes GROUP BY Classes.student_id ORDER BY course_count DESC LIMIT 1;","SELECT count(*) ,  student_id FROM Classes GROUP BY student_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Classes.student_id"" and the count of ""Classes.class_id"" for each student. Use an alias for the count to make it easier to reference. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all students. 3. Join Structure: No JOIN is required since all the necessary data is in the ""Classes"" table. 4. Aggregation Structure: Use COUNT on ""Classes.class_id"" to count the number of courses each student is taking. Use GROUP BY on ""Classes.student_id"" to group the results by student. Use ORDER BY in descending order on the count to rank students by the number of courses they are taking. Use LIMIT 1 to select the student taking the most courses.",1.0
435,Find details of all the services that have interacted with `` 15 ij '' for the the channel details.,NON-NESTED,government_shift,"[Services.Service_Details,Customer_Interactions.Service_ID,Customer_Interactions.Customer_ID,Customer_Interactions.Channel_ID,Channels.Channel_Details,Customer_Interactions.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
","SELECT Services.Service_Details, Channels.Channel_Details FROM Customer_Interactions JOIN Services ON Customer_Interactions.Service_ID = Services.Service_ID JOIN Channels ON Customer_Interactions.Channel_ID = Channels.Channel_ID WHERE Customer_Interactions.Customer_ID = '15 ij';","select distinct t1.service_details from services as t1 join customer_interactions as t2 on t1.service_id  =  t2.service_id join channels as t3 on t2.channel_id  =  t3.channel_id where t3.channel_details  =  ""15 ij""","1. Sequential Structure: Start with the SELECT clause to retrieve the details of services and the channel details. The required fields are ""Services.Service_Details"" and ""Channels.Channel_Details."" 2. Condition Structure: Use a WHERE clause to filter for interactions involving the customer with ID ""15 ij."" 3. Join Structure: Use JOINs to connect the ""Customer_Interactions"" table with the ""Services"" table on ""Customer_Interactions.Service_ID = Services.Service_ID"" and with the ""Channels"" table on ""Customer_Interactions.Channel_ID = Channels.Channel_ID."" 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving specific details without summarization.",0.0
436,Which customer has used the most types of services ? Give me the customer details .,NON-NESTED,government_shift,"[Customers.Customer_Details,Customers.Customer_ID,Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
","SELECT Customers.Customer_Details, Customers.Customer_ID FROM Customers JOIN Customers_and_Services ON Customers.Customer_ID = Customers_and_Services.Customer_ID GROUP BY Customers.Customer_ID ORDER BY COUNT(DISTINCT Customers_and_Services.Service_ID) DESC LIMIT 1;",select t1.customer_details from customers as t1 join customers_and_services as t2 on t1.customer_id  =  t2.customer_id group by t1.customer_details order by count(*) desc limit 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the customer details from the ""Customers.Customer_Details"" field. Additionally, include the ""Customers.Customer_ID"" to group by customer and count the distinct types of services they have used. 2. Condition Structure: No specific filtering condition is required, as we are interested in all customers. 3. Join Structure: Use a JOIN between the ""Customers"" table and the ""Customers_and_Services"" table based on the ""Customer_ID"" field to link customers with the services they have used. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Customers_and_Services.Service_ID"" to count the number of unique services used by each customer. Use ORDER BY in descending order to rank customers by the number of services used, and LIMIT 1 to get the customer who has used the most types of services.",1.0
437,How many vehicles do we have?,EASY,vehicle_rent,[Vehicles.id],"Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT COUNT(Vehicles.id) AS total_vehicles FROM Vehicles;,SELECT count(*) FROM vehicles,"1. Sequential Structure: Start with the SELECT clause to count the total number of vehicles. 2. Aggregation Structure: Use the COUNT function on the ""Vehicles.id"" field to calculate the total number of vehicles. 3. Condition Structure: No specific filtering condition is required as we want the total count of all vehicles. 4. Join Structure: No JOIN is required since all necessary information is in the ""Vehicles"" table.",1.0
438,What is the payment method and customer number for customer named Jeromy?,EASY,customers_and_orders,"[Customers.payment_method_code, Customers.customer_number, Customers.customer_name, Customers.customer_name = 'Jeromy']","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customers.payment_method_code, Customers.customer_number FROM Customers WHERE Customers.customer_name = 'Jeromy';","SELECT payment_method_code ,  customer_number FROM Customers WHERE customer_name  =  ""Jeromy""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""payment_method_code"" and ""customer_number"" for the customer named ""Jeromy"". 2. Condition Structure: Use a WHERE clause to filter for the customer whose ""customer_name"" is 'Jeromy'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
439,What are the names of regions in ascending alphabetical order?,EASY,region_building,[region.Name],"Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT region.Name FROM region ORDER BY region.Name ASC;,SELECT Name FROM region ORDER BY Name ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the region name. 2. Condition Structure: No specific filtering condition is required as we want all region names. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""region"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the region names. 5. Ordering Structure: Use ORDER BY in ascending alphabetical order on ""region.Name"".",1.0
440,What are the names of the 5 largest regions in terms of area?,EASY,region_building,"[region.Name, region.Area]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT region.Name FROM region ORDER BY region.Area DESC LIMIT 5;,SELECT Name FROM region ORDER BY Area DESC LIMIT 5,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the region name. 2. Aggregation Structure: No aggregation function is needed since we are simply sorting by the area. 3. Ordering Structure: Use ORDER BY in descending order on ""region.Area"" to rank regions by their size. 4. Limiting Structure: Use LIMIT 5 to retrieve only the names of the 5 largest regions. 5. Join Structure: No JOIN is required since all necessary data is within the ""region"" table.",1.0
441,List the date of the transcripts and the transcript details.,EASY,cre_Students_Information_Systems,"[Transcripts.date_of_transcript, Transcripts.transcript_details]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Transcripts.date_of_transcript, Transcripts.transcript_details FROM Transcripts;","SELECT date_of_transcript ,  transcript_details FROM Transcripts","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Transcripts.date_of_transcript"" and ""Transcripts.transcript_details"". 2. Condition Structure: No specific filtering condition is required as the query asks for all dates and details of transcripts. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Transcripts"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the specified fields.",1.0
442,Find the analytical layer type code that appears most often.,EASY,government_shift,[Analytical_Layer.Analytical_Layer_Type_Code],"Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Analytical_Layer.Analytical_Layer_Type_Code FROM Analytical_Layer GROUP BY Analytical_Layer.Analytical_Layer_Type_Code ORDER BY COUNT(*) DESC LIMIT 1;,SELECT analytical_layer_type_code FROM analytical_layer GROUP BY analytical_layer_type_code ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the analytical layer type code, as the question asks for the type code that appears most often. 2. Aggregation Structure: Use COUNT to calculate the frequency of each analytical layer type code. 3. Grouping Structure: Use GROUP BY on ""Analytical_Layer.Analytical_Layer_Type_Code"" to count occurrences for each type code. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank the type codes by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the analytical layer type code that appears most often. 6. Join Structure: No JOIN is required since all necessary data is within the ""Analytical_Layer"" table.",1.0
443,Which customers used the least commonly-used service ? Give me the distinct customer details .,NESTED,government_shift,"[Customers.Customer_Details,Customer_Interactions.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT DISTINCT Customers.Customer_Details FROM Customers JOIN Customer_Interactions ON Customers.Customer_ID = Customer_Interactions.Customer_ID WHERE Customer_Interactions.Service_ID = ( SELECT Service_ID FROM Customer_Interactions GROUP BY Service_ID ORDER BY COUNT(Service_ID) ASC LIMIT 1 );,select distinct t1.customer_details from customers as t1 join customers_and_services as t2 on t1.customer_id  =  t2.customer_id where t2.service_id  =  (select service_id from services group by service_id order by count(*) asc limit 1),1. Sequential Structure: Start with the SELECT clause to retrieve distinct customer details. Use the FROM clause to specify the Customers and Customer_Interactions tables. Join these tables to link customer details with their interactions. Use a subquery to identify the least commonly-used service by counting the occurrences of each service in the Customer_Interactions table. Filter the main query to include only customers who used this service. 2. Condition Structure: Use a WHERE clause to filter for customers who used the least commonly-used service. The subquery calculates the service with the minimum usage count. 3. Join Structure: Use INNER JOINs to connect Customers with Customer_Interactions based on Customer_ID and to link services through the Service_ID. 4. Aggregation Structure: Use COUNT in the subquery to determine the usage frequency of each service and MIN to find the least commonly-used service.,0.0
444,List the detail and id of the teacher who teaches the most courses.,NON-NESTED,cre_Students_Information_Systems,"[Teachers.teacher_id,Teachers.teacher_details,Classes.teacher_id,Classes.class_id,Classes.teacher_id = Teachers.teacher_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Teachers.teacher_id, Teachers.teacher_details FROM Teachers JOIN Classes ON Teachers.teacher_id = Classes.teacher_id GROUP BY Teachers.teacher_id, Teachers.teacher_details ORDER BY COUNT(Classes.class_id) DESC LIMIT 1;","SELECT T1.teacher_details ,  T1.teacher_id FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id GROUP BY T1.teacher_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""Teachers.teacher_id"" and ""Teachers.teacher_details."" Use an aggregate function (COUNT) to count the number of courses taught by each teacher. 2. Condition Structure: Use a HAVING clause to filter for the teacher who teaches the most courses. This requires comparing the count of courses for each teacher. 3. Join Structure: Use a JOIN between the ""Teachers"" and ""Classes"" tables based on ""teacher_id"" to associate each teacher with the classes they teach. 4. Aggregation Structure: Use COUNT on ""Classes.class_id"" to count the number of courses taught by each teacher. Use ORDER BY in descending order of the count and LIMIT 1 to get the teacher with the highest count.",0.0
445,What is the most frequent product type code?,NON-NESTED,customers_and_orders,"[Products.product_type_code,Order_Items.product_id = Products.product_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_type_code, COUNT(*) AS frequency FROM Order_Items JOIN Products ON Order_Items.product_id = Products.product_id GROUP BY Products.product_type_code ORDER BY frequency DESC LIMIT 1;",SELECT product_type_code FROM Products GROUP BY product_type_code ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Products.product_type_code"" and the count of its occurrences. Use COUNT to determine the frequency of each product type code. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the most frequent product type code across all records. 3. Join Structure: Use a JOIN between the ""Order_Items"" and ""Products"" tables based on ""Order_Items.product_id = Products.product_id"" to link each order item with its corresponding product. 4. Aggregation Structure: Use GROUP BY on ""Products.product_type_code"" to group the data by product type code. Use ORDER BY in descending order on the count to rank the product type codes by frequency, and LIMIT 1 to select the most frequent one.",1.0
446,What are the names and total rental hours for each vehicle?,NON-NESTED,vehicle_rent,"[Vehicles.name, Renting_history.total_hours, Renting_history.vehicles_id = Vehicles.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, SUM(Renting_history.total_hours) AS total_rental_hours FROM Vehicles JOIN Renting_history ON Renting_history.vehicles_id = Vehicles.id GROUP BY Vehicles.name;","SELECT T2.name ,  sum(T1.total_hours) FROM renting_history AS T1 JOIN vehicles AS T2 ON T1.vehicles_id  =  T2.id GROUP BY T2.id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Vehicles.name"" and the total rental hours for each vehicle. Use the SUM function on ""Renting_history.total_hours"" to calculate the total rental hours. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Vehicles"" table and the ""Renting_history"" table based on the relationship ""Renting_history.vehicles_id = Vehicles.id"" to associate each vehicle with its rental history. 4. Aggregation Structure: Use SUM to aggregate the total rental hours for each vehicle and GROUP BY ""Vehicles.name"" to group the results by vehicle name.",1.0
447,List the biographical data and the date of the transcript of all the students.,NON-NESTED,cre_Students_Information_Systems,"[Students.bio_data, Transcripts.date_of_transcript, Transcripts.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.bio_data, Transcripts.date_of_transcript FROM Students JOIN Transcripts ON Transcripts.student_id = Students.student_id;","SELECT T1.bio_data ,  T2.date_of_transcript FROM Students AS T1 JOIN Transcripts AS T2 ON T1.student_id  =  T2.student_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Students.bio_data"" and ""Transcripts.date_of_transcript."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Students"" and ""Transcripts"" tables based on the relationship ""Transcripts.student_id = Students.student_id"" to link each student with their transcript data. 4. Aggregation Structure: No aggregation is required as the query simply retrieves data without summarization.",1.0
448,Find all the details of the customers who have been involved in an interaction with status `` Stuck '' and service and channel detail `` bad '' .,NON-NESTED,government_shift,"[Customer_Interactions.Status_Code,Customer_Interactions.Service_ID,Customer_Interactions.Channel_ID,Customer_Interactions.Customer_ID,Services.Service_Details,Channels.Channel_Details,Customer_Interactions.Service_ID = Services.Service_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customers.Customer_Details,Stuck,bad]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Customers.* FROM Customer_Interactions JOIN Services ON Customer_Interactions.Service_ID = Services.Service_ID JOIN Channels ON Customer_Interactions.Channel_ID = Channels.Channel_ID JOIN Customers ON Customer_Interactions.Customer_ID = Customers.Customer_ID WHERE Customer_Interactions.Status_Code = 'Stuck' AND Services.Service_Details = 'bad' AND Channels.Channel_Details = 'bad';,"select t1.customer_details from customers as t1 join customer_interactions as t2 on t1.customer_id  =  t2.customer_id where t2.status_code  =  ""stuck"" and services_and_channels_details  =  ""bad""","1. Sequential Structure: Start with the SELECT clause to retrieve all details of the customers. This involves selecting all fields from the ""Customers"" table. 2. Condition Structure: Use a WHERE clause to filter for interactions where the ""Customer_Interactions.Status_Code"" is ""Stuck"" and both the ""Services.Service_Details"" and ""Channels.Channel_Details"" are ""bad."" 3. Join Structure: Use JOINs to connect the ""Customer_Interactions"" table with the ""Services,"" ""Channels,"" and ""Customers"" tables. The joins are based on the relationships: ""Customer_Interactions.Service_ID = Services.Service_ID,"" ""Customer_Interactions.Channel_ID = Channels.Channel_ID,"" and ""Customer_Interactions.Customer_ID = Customers.Customer_ID."" 4. Aggregation Structure: No aggregation is needed as the query is retrieving detailed information without summarization.",1.0
449,List the addresses of buildings in descending order of building completion year.,EASY,region_building,"[building.Address, building.Completed_Year]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT building.Address FROM building ORDER BY building.Completed_Year DESC;,SELECT Address FROM building ORDER BY Completed_Year DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the address of the building. 2. Condition Structure: No specific filtering condition is required as we want all building addresses. 3. Join Structure: No JOIN is required since all necessary data is within the ""building"" table. 4. Ordering Structure: Use ORDER BY in descending order on the ""building.Completed_Year"" to sort the results by the year of completion. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data.",1.0
450,"Give the address, phone, and email for customers with the name Jeromy.",EASY,customers_and_orders,"[Customers.customer_address, Customers.customer_phone, Customers.customer_email, Customers.customer_name, Jeromy]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customers.customer_address, Customers.customer_phone, Customers.customer_email FROM Customers WHERE Customers.customer_name = 'Jeromy';","SELECT customer_address ,  customer_phone ,  customer_email FROM Customers WHERE customer_name  =  ""Jeromy""","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Customers.customer_address,"" ""Customers.customer_phone,"" and ""Customers.customer_email."" 2. Condition Structure: Use a WHERE clause to filter for customers whose name is ""Jeromy."" 3. Join Structure: No JOIN is required since all necessary information is in the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
451,"Which services were used by the customer with details ""Hardy Kutch""? Give me the service details.",NON-NESTED,government_shift,"[Customers.Customer_Details,Customers.Customer_ID,Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID,Services.Service_ID = Customers_and_Services.Service_ID,Services.Service_Details,""Hardy Kutch""]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Services.Service_Details FROM Customers JOIN Customers_and_Services ON Customers.Customer_ID = Customers_and_Services.Customer_ID JOIN Services ON Customers_and_Services.Service_ID = Services.Service_ID WHERE Customers.Customer_Details = 'Hardy Kutch';,"SELECT t3.service_details FROM customers AS t1 JOIN customers_and_services AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id WHERE t1.customer_details  =  ""Hardy Kutch""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Services.Service_Details"" as the question asks for the service details. 2. Condition Structure: Use a WHERE clause to filter for the customer with the details ""Hardy Kutch."" 3. Join Structure: Use JOINs to connect the ""Customers"" table with the ""Customers_and_Services"" table on ""Customer_ID"" and then connect the ""Customers_and_Services"" table with the ""Services"" table on ""Service_ID"" to link customers with their respective services. 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving specific service details for a particular customer.",1.0
452,"How many students have joined in the most common type of event? List the number, the event type and description.",NESTED,cre_Students_Information_Systems,"[Student_Events.student_id,Student_Events.event_type_code,Ref_Event_Types.event_type_code,Ref_Event_Types.event_type_description]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT COUNT(Student_Events.student_id) AS student_count, Student_Events.event_type_code, Ref_Event_Types.event_type_description FROM Student_Events JOIN Ref_Event_Types ON Student_Events.event_type_code = Ref_Event_Types.event_type_code GROUP BY Student_Events.event_type_code, Ref_Event_Types.event_type_description ORDER BY student_count DESC LIMIT 1;","SELECT count(*) ,  T2.event_type_code ,  T3.event_type_description FROM Students AS T1 JOIN Student_Events AS T2 ON T1.student_id  =  T2.student_id JOIN Ref_Event_Types AS T3 ON T2.event_type_code  =  T3.event_type_code GROUP BY T2.event_type_code ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the number of students, the event type, and its description. Use the FROM clause to specify the Student_Events table and join it with the Ref_Event_Types table to get the event type description. Use GROUP BY to group by event type and description, and COUNT to calculate the number of students for each event type. Finally, use ORDER BY to sort by the count in descending order and LIMIT to get the most common event type. 2. Condition Structure: No specific filtering condition is required, as we are interested in all event types and their counts. 3. Join Structure: Use an INNER JOIN between Student_Events and Ref_Event_Types on the event_type_code to connect event types with their descriptions. 4. Aggregation Structure: Use COUNT to calculate the number of students for each event type and description, and use MAX or ORDER BY to identify the most common event type.",1.0
453,Return the earliest date of loan in the record.,EASY,cre_Students_Information_Systems,[Student_Loans.date_of_loan],"Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT MIN(Student_Loans.date_of_loan) AS earliest_date FROM Student_Loans;,SELECT date_of_loan FROM Student_Loans ORDER BY date_of_loan ASC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the earliest date of loan from the ""Student_Loans.date_of_loan"" field. 2. Aggregation Structure: Use the MIN function to find the earliest date in the ""Student_Loans.date_of_loan"" field. 3. Condition Structure: No specific filtering condition is required as we are looking for the minimum date across all records. 4. Join Structure: No JOIN is necessary since all required data is within the ""Student_Loans"" table.",1.0
454,Find the biographical data and event date for students who participated in any events.,NON-NESTED,cre_Students_Information_Systems,"[Students.bio_data, Student_Events.event_date, Student_Events.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.bio_data, Student_Events.event_date FROM Students JOIN Student_Events ON Student_Events.student_id = Students.student_id;","SELECT T1.bio_data ,  T2.event_date FROM Students AS T1 JOIN Student_Events AS T2 ON T1.student_id  =  T2.student_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Students.bio_data"" and ""Student_Events.event_date."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Students"" and ""Student_Events"" tables based on the relationship ""Student_Events.student_id = Students.student_id"" to link students with their event participation. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the biographical data and event dates for students who participated in events.",1.0
455,When did all the detentions start?,EASY,cre_Students_Information_Systems,[Detention.datetime_detention_start],"Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Detention.datetime_detention_start FROM Detention;,SELECT datetime_detention_start FROM Detention,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""datetime_detention_start"" from the ""Detention"" table. 2. Condition Structure: No specific filtering condition is required, as the question asks for all detention start times. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Detention"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving the start times of all detentions.",1.0
456,Show addresses of buildings and the capitals of regions they are in.,NON-NESTED,region_building,"[building.Address, region.Capital, building.Region_ID = region.Region_ID]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
","SELECT building.Address, region.Capital FROM building JOIN region ON building.Region_ID = region.Region_ID;","SELECT T1.Address ,  T2.Capital FROM building AS T1 JOIN region AS T2 ON T1.Region_ID  =  T2.Region_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""building.Address"" and ""region.Capital."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""building"" and ""region"" tables based on the shared key ""Region_ID"" to associate each building with its corresponding region. 4. Aggregation Structure: No aggregation is required as the query simply retrieves and displays the data.",1.0
457,What are the names of all the authors?,EASY,book_1,[Author.Name],"Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Author.Name FROM Author;,SELECT name FROM Author,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""Author.Name"". 2. Condition Structure: No specific filtering condition is required as the query asks for all author names. 3. Join Structure: No JOIN is required since all necessary data is within the ""Author"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all author names.",1.0
458,How many distinct customer and services details are there?,EASY,government_shift,[Customers_and_Services.Customers_and_Services_Details],"Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT COUNT(DISTINCT Customers_and_Services.Customers_and_Services_Details) FROM Customers_and_Services;,SELECT count(DISTINCT customers_and_services_details) FROM customers_and_services,"1. Sequential Structure: Begin with the SELECT clause to count the distinct customer and service details. 2. Condition Structure: No specific filtering condition is required as the query aims to count all distinct details. 3. Join Structure: No JOIN is necessary since all required data is within the ""Customers_and_Services"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique customer and service details.",1.0
459,"What are the details of the customers who have ""Kutch"" in part of their details?",EASY,government_shift,"[Customers.Customer_Details, Customers.Customer_ID = Customers_and_Services.Customer_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Customers.Customer_Details FROM Customers WHERE Customers.Customer_Details LIKE '%Kutch%';,"SELECT customer_details FROM customers WHERE customer_details LIKE ""%Kutch%""","1. Sequential Structure: Start with the SELECT clause to retrieve all details of customers who have ""Kutch"" in their details. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for customer details that contain ""Kutch"". 3. Join Structure: No JOIN is required since the query only involves the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific customer details based on a condition.",1.0
460,Show all order status and the number of orders in each status.,EASY,customers_and_orders,"[Customer_Orders.order_status_code, Customer_Orders.order_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customer_Orders.order_status_code, COUNT(Customer_Orders.order_id) AS order_count FROM Customer_Orders GROUP BY Customer_Orders.order_status_code;","SELECT order_status_code ,  count(*) FROM Customer_orders GROUP BY order_status_code","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the order status and the count of orders. 2. Aggregation Structure: Use COUNT to calculate the number of orders for each order status. 3. Grouping Structure: Use GROUP BY on ""Customer_Orders.order_status_code"" to group the results by each order status. 4. Join Structure: No JOIN is required since all necessary data is within the ""Customer_Orders"" table.",1.0
461,How many products named Monitor have been ordered?,NON-NESTED,customers_and_orders,"[Products.product_name, Order_Items.product_id, Order_Items.order_quantity, Products.product_id = Order_Items.product_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT SUM(Order_Items.order_quantity) FROM Products JOIN Order_Items ON Products.product_id = Order_Items.product_id WHERE Products.product_name = 'Monitor';,"SELECT sum(order_quantity) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id WHERE T2.product_name  =  ""Monitor""","1. Sequential Structure: Start with the SELECT clause to calculate the total number of ""Monitor"" products ordered. Use SUM on ""Order_Items.order_quantity"" to aggregate the total quantity. 2. Condition Structure: Use a WHERE clause to filter for products with the name ""Monitor."" 3. Join Structure: Use an INNER JOIN between the ""Products"" table and the ""Order_Items"" table based on the shared key ""product_id"" to link product details with order details. 4. Aggregation Structure: Use SUM to calculate the total quantity of ""Monitor"" products ordered.",1.0
462,How many courses do students take at most? Also find the id of the student who takes the most courses.,NON-NESTED,cre_Students_Information_Systems,"[Classes.student_id, Classes.class_id, Students.student_id = Classes.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Classes.student_id, COUNT(Classes.class_id) AS course_count FROM Classes GROUP BY Classes.student_id ORDER BY course_count DESC LIMIT 1;","SELECT count(*) ,  student_id FROM Classes GROUP BY student_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the maximum number of courses taken by any student and the ID of the student who takes the most courses. Use COUNT to count the number of courses taken by each student. 2. Condition Structure: No specific filtering condition is required, as we are interested in all students. 3. Join Structure: No JOIN is necessary since the relevant data is available in the ""Classes"" table, and the relationship between ""Students"" and ""Classes"" is already established through ""student_id."" 4. Aggregation Structure: Use COUNT to count the number of courses taken by each student, GROUP BY ""Classes.student_id"" to group the counts by student, and ORDER BY the count in descending order to find the maximum. Use LIMIT 1 to retrieve the student with the most courses.",1.0
463,What is the name and age of the customer with the most membership credit?,EASY,vehicle_rent,"[Customers.name, Customers.age, Customers.membership_credit]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Customers.name, Customers.age FROM Customers ORDER BY Customers.membership_credit DESC LIMIT 1;","SELECT name ,  age FROM customers ORDER BY membership_credit DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Customers.name"" and ""Customers.age"" of the customer with the most membership credit. 2. Condition Structure: No specific filtering condition is needed since we are looking for the customer with the highest membership credit. 3. Join Structure: No JOIN is required, as all necessary information is available in the ""Customers"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""Customers.membership_credit"" to rank customers by their membership credit and apply LIMIT 1 to select the customer with the highest membership credit.",1.0
464,Show all payment method codes and the number of customers in each code.,EASY,customers_and_orders,"[Customers.payment_method_code, Customers.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customers.payment_method_code, COUNT(Customers.customer_id) AS customer_count FROM Customers GROUP BY Customers.payment_method_code;","SELECT payment_method_code ,  count(*) FROM Customers GROUP BY payment_method_code","1. Sequential Structure: Begin with the SELECT clause to specify the payment method codes and the count of customers for each code. 2. Aggregation Structure: Use COUNT to calculate the number of customers for each payment method code. 3. Grouping Structure: Use GROUP BY on ""Customers.payment_method_code"" to group the results by each payment method code. 4. Join Structure: No JOIN is required since all necessary data is within the ""Customers"" table.",1.0
465,"What are the names, ids, and number of orders made for each customer?",NON-NESTED,customers_and_orders,"[Customers.customer_id,Customers.customer_name,Customer_Orders.customer_id = Customers.customer_id,Customer_Orders.order_id,Order_Items.order_id = Customer_Orders.order_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customers.customer_id, Customers.customer_name, COUNT(Customer_Orders.order_id) AS number_of_orders FROM Customers JOIN Customer_Orders ON Customers.customer_id = Customer_Orders.customer_id JOIN Order_Items ON Customer_Orders.order_id = Order_Items.order_id GROUP BY Customers.customer_id, Customers.customer_name;","SELECT T2.customer_name ,  T1.customer_id ,  count(*) FROM Customer_orders AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Customers.customer_id,"" ""Customers.customer_name,"" and the count of ""Customer_Orders.order_id"" for each customer. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect ""Customers"" with ""Customer_Orders"" on ""Customers.customer_id = Customer_Orders.customer_id"" and ""Customer_Orders"" with ""Order_Items"" on ""Customer_Orders.order_id = Order_Items.order_id"" to link customers with their orders. 4. Aggregation Structure: Use COUNT on ""Customer_Orders.order_id"" to count the number of orders made by each customer, and GROUP BY ""Customers.customer_id"" and ""Customers.customer_name"" to group results by each customer.",0.0
466,Show the distinct addresses of buildings.,EASY,region_building,[building.Address],"Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT DISTINCT building.Address FROM building;,SELECT DISTINCT Address FROM building,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct addresses of buildings. 2. Condition Structure: No specific filtering condition is required as we want all distinct addresses. 3. Join Structure: No JOIN is needed since all necessary information is in the ""building"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique addresses are retrieved.",1.0
467,Count the number of books.,EASY,book_1,[Book.ISBN],"Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT COUNT(Book.ISBN) AS book_count FROM Book;,SELECT count(*) FROM Book,"1. Sequential Structure: Begin with the SELECT clause to count the number of books. 2. Aggregation Structure: Use the COUNT function to count the total number of entries in the ""Book"" table, specifically using the ""Book.ISBN"" field as it uniquely identifies each book. 3. Condition Structure: No specific filtering condition is required since we want the total count of all books. 4. Join Structure: No JOIN is required as all necessary information is within the ""Book"" table.",1.0
468,How many orders have each order status code?,EASY,customers_and_orders,[Customer_Orders.order_status_code],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customer_Orders.order_status_code, COUNT(*) AS order_count FROM Customer_Orders GROUP BY Customer_Orders.order_status_code;","SELECT order_status_code ,  count(*) FROM Customer_orders GROUP BY order_status_code","1. Sequential Structure: Begin with the SELECT clause to specify the order status code and the count of orders for each status code. 2. Aggregation Structure: Use COUNT to calculate the number of orders for each order status code. 3. Grouping Structure: Use GROUP BY on ""Customer_Orders.order_status_code"" to group the results by each status code. 4. Join Structure: No JOIN is required since all necessary data is within the ""Customer_Orders"" table.",1.0
469,How many integration platforms are successful?,NON-NESTED,government_shift,"[Integration_Platform.Integration_Platform_ID,Customer_Interactions.Status_Code,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT COUNT(Integration_Platform.Integration_Platform_ID) FROM Integration_Platform JOIN Customer_Interactions ON Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID WHERE Customer_Interactions.Status_Code = 'Success';,"SELECT count(*) FROM integration_platform WHERE integration_platform_details  =  ""Success""","1. Sequential Structure: Start with the SELECT clause to count the number of successful integration platforms. Use COUNT on ""Integration_Platform.Integration_Platform_ID."" 2. Condition Structure: Use a WHERE clause to filter for records where ""Customer_Interactions.Status_Code"" indicates success. 3. Join Structure: Use a JOIN between the ""Integration_Platform"" and ""Customer_Interactions"" tables based on the relationship ""Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID."" 4. Aggregation Structure: Use COUNT to aggregate the number of successful integration platforms.",0.0
470,What is the payment method code used by most number of customers?,EASY,customers_and_orders,"[Customers.payment_method_code,Customers.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Customers.payment_method_code FROM Customers GROUP BY Customers.payment_method_code ORDER BY COUNT(Customers.customer_id) DESC LIMIT 1;,SELECT payment_method_code FROM Customers GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the payment method code, as the question asks for the payment method code used by the most number of customers. 2. Aggregation Structure: Use COUNT to calculate the number of customers using each payment method code. 3. Grouping Structure: Use GROUP BY on ""Customers.payment_method_code"" to aggregate the results by each payment method code. 4. Ordering Structure: Use ORDER BY in descending order on the count of customers to rank payment methods by popularity. 5. Limiting Structure: Use LIMIT 1 to retrieve the payment method code used by the most number of customers. 6. Join Structure: No JOIN is required since all necessary data is within the ""Customers"" table.",1.0
471,What are the detail and id of the teacher who teaches the largest number of courses?,NON-NESTED,cre_Students_Information_Systems,"[Teachers.teacher_id,Teachers.teacher_details,Classes.teacher_id,Classes.class_id,Classes.teacher_id = Teachers.teacher_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Teachers.teacher_id, Teachers.teacher_details FROM Teachers JOIN Classes ON Classes.teacher_id = Teachers.teacher_id GROUP BY Teachers.teacher_id ORDER BY COUNT(Classes.class_id) DESC LIMIT 1;","SELECT T1.teacher_details ,  T1.teacher_id FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id GROUP BY T1.teacher_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Teachers.teacher_id"" and ""Teachers.teacher_details."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the teacher who teaches the largest number of courses. 3. Join Structure: Use a JOIN between the ""Teachers"" and ""Classes"" tables on ""Classes.teacher_id = Teachers.teacher_id"" to associate each teacher with their respective classes. 4. Aggregation Structure: Use COUNT on ""Classes.class_id"" to count the number of courses taught by each teacher. Use GROUP BY on ""Teachers.teacher_id"" to group the results by teacher. Use ORDER BY in descending order on the count and LIMIT 1 to select the teacher with the largest number of courses.",1.0
472,Find the biographical data and details of students who got not only the most common result but also a result that is obtained by 3 students in behaviour monitoring.,NESTED,cre_Students_Information_Systems,"[Students.bio_data, Students.student_details, Behaviour_Monitoring.student_id, Behaviour_Monitoring.behaviour_monitoring_details, Behaviour_Monitoring.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.bio_data, Students.student_details FROM Students JOIN Behaviour_Monitoring ON Students.student_id = Behaviour_Monitoring.student_id WHERE Behaviour_Monitoring.behaviour_monitoring_details IN ( SELECT behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details HAVING COUNT(*) = (SELECT MAX(result_count) FROM (SELECT COUNT(*) AS result_count FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details)) OR COUNT(*) = 3 );","SELECT T1.bio_data ,  T1.student_details FROM Students AS T1 JOIN Behaviour_Monitoring AS T2 ON T1.student_id  =  T2.student_id WHERE T2.behaviour_monitoring_details IN ( SELECT behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details ORDER BY count(*) DESC LIMIT 1 ) INTERSECT SELECT T1.bio_data ,  T1.student_details FROM Students AS T1 JOIN Behaviour_Monitoring AS T2 ON T1.student_id  =  T2.student_id WHERE T2.behaviour_monitoring_details IN ( SELECT behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details HAVING count(*)  =  3 )",1. Sequential Structure: Start with the SELECT clause to retrieve the biographical data and details of students. Use the FROM clause to specify the Students table and JOIN it with the Behaviour_Monitoring table on the student_id field. Use GROUP BY to group results by behaviour monitoring details and COUNT to determine the frequency of each result. Use a WHERE clause to filter for students who obtained both the most common result and a result obtained by exactly 3 students. 2. Condition Structure: Use a WHERE clause with subqueries to filter for students who have the most common result and a result obtained by exactly 3 students. The subqueries will calculate the most common result and the result obtained by 3 students. 3. Join Structure: Use an INNER JOIN between the Students and Behaviour_Monitoring tables based on student_id to connect student details with their behaviour monitoring records. 4. Aggregation Structure: Use COUNT to determine the frequency of each behaviour monitoring result and filter based on the conditions for the most common result and the result obtained by 3 students.,1.0
473,"For each building, return the address of the building and the name of the region it belongs to.",NON-NESTED,region_building,"[building.Address, region.Name, building.Region_ID = region.Region_ID]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
","SELECT building.Address, region.Name FROM building JOIN region ON building.Region_ID = region.Region_ID;","SELECT T1.Address ,  T2.Capital FROM building AS T1 JOIN region AS T2 ON T1.Region_ID  =  T2.Region_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""building.Address"" and ""region.Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""building"" and ""region"" tables based on the relationship ""building.Region_ID = region.Region_ID"" to associate each building with its corresponding region. 4. Aggregation Structure: No aggregation is required as the query only involves retrieving and displaying data.",0.0
474,List details of all the channel in alphabetical order .,EASY,government_shift,[Channels.Channel_Details],"Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT * FROM Channels ORDER BY Channel_Details ASC;,select channel_details from channels order by channel_details,"1. Sequential Structure: Begin with the SELECT clause to retrieve all details of the channels. 2. Condition Structure: No specific filtering condition is required as the query asks for all channel details. 3. Join Structure: No JOIN is necessary since all required data is within the ""Channels"" table. 4. Ordering Structure: Use ORDER BY to sort the results alphabetically by channel details. 5. Aggregation Structure: No aggregation is needed as the query does not involve any summarization.",1.0
475,"For those students who have gone through an event, who do not have a student loan? List the students' biographical data",NESTED,cre_Students_Information_Systems,"[Students.student_id,Student_Events.student_id,Student_Loans.student_id,Students.bio_data,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Students.bio_data FROM Students JOIN Student_Events ON Student_Events.student_id = Students.student_id WHERE Students.student_id NOT IN (SELECT student_id FROM Student_Loans);,SELECT T1.bio_data FROM Students AS T1 JOIN Student_Events AS T2 WHERE T1.student_id  =  T2.student_id EXCEPT SELECT T1.bio_data FROM Students AS T1 JOIN Student_Loans AS T2 WHERE T1.student_id  =  T2.student_id,"1. Sequential Structure: Start with the SELECT clause to retrieve the biographical data of students. Use the FROM clause to specify the Students table. Join it with the Student_Events table to identify students who have attended an event. Use a WHERE clause to filter out students who have a student loan by ensuring their student_id is not present in the Student_Loans table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose student_id appears in the Student_Loans table, indicating they have a loan. 3. Join Structure: Use an INNER JOIN between the Students and Student_Events tables based on student_id to identify students who have attended an event. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
476,"What are the average city fuel economy rate, average highway fuel economy rate for different types of powertrains?",EASY,vehicle_rent,"[Vehicles.Type_of_powertrain, Vehicles.City_fuel_economy_rate, Vehicles.Highway_fuel_economy_rate]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.Type_of_powertrain, AVG(Vehicles.City_fuel_economy_rate) AS avg_city_fuel_economy, AVG(Vehicles.Highway_fuel_economy_rate) AS avg_highway_fuel_economy FROM Vehicles GROUP BY Vehicles.Type_of_powertrain;","SELECT avg(City_fuel_economy_rate) ,  avg(Highway_fuel_economy_rate) , Type_of_powertrain FROM vehicles GROUP BY Type_of_powertrain","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the type of powertrain, the average city fuel economy rate, and the average highway fuel economy rate. 2. Aggregation Structure: Use AVG to calculate the average city fuel economy rate and the average highway fuel economy rate for each type of powertrain. 3. Grouping Structure: Use GROUP BY on ""Vehicles.Type_of_powertrain"" to calculate these aggregate values for each powertrain type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Vehicles"" table.",1.0
477,Show the name of vehicles with no renting history.,NESTED,vehicle_rent,"[Vehicles.name, Renting_history.vehicles_id, Vehicles.id = Renting_history.vehicles_id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT Vehicles.name FROM Vehicles WHERE Vehicles.id NOT IN (SELECT Renting_history.vehicles_id FROM Renting_history);,SELECT name FROM vehicles WHERE id NOT IN (SELECT vehicles_id FROM renting_history),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of vehicles. Use the FROM clause to specify the Vehicles table. Apply a WHERE clause to filter vehicles that do not have any renting history by ensuring that their IDs are not present in the Renting_history table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude vehicles whose IDs appear in the Renting_history table, meaning they have a renting history. 3. Join Structure: Not required, as we only need to filter based on the absence of matching vehicle IDs in the Renting_history table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
478,Show all customer names with the  payment method code used by least number of customers.,NESTED,customers_and_orders,"[Customers.customer_name, Customers.payment_method_code]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT customer_name, payment_method_code FROM Customers WHERE payment_method_code = ( SELECT payment_method_code FROM Customers GROUP BY payment_method_code ORDER BY COUNT(*) ASC LIMIT 1 );",SELECT customer_name FROM Customers WHERE payment_method_code  =  ( SELECT payment_method_code FROM Customers GROUP BY payment_method_code ORDER BY count(*) ASC LIMIT 1),"1. Sequential Structure: Start with the SELECT clause to retrieve customer names and their payment method codes. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter for the payment method code used by the least number of customers. 2. Condition Structure: Use a subquery to calculate the count of customers for each payment method code and identify the minimum count. Use this result in the WHERE clause to filter for the payment method code with the least number of customers. 3. Join Structure: Not required, as all data is in the Customers table. 4. Aggregation Structure: Use COUNT to calculate the number of customers for each payment method code and MIN to find the least used payment method code.",1.0
479,List the biographical data and student id for the students who take 2 or more classes and the students who have less than 2 detentions.,NESTED,cre_Students_Information_Systems,"[Students.student_id, Students.bio_data, Classes.student_id, Detention.student_id, Classes.class_id, Detention.detention_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.student_id, Students.bio_data FROM Students LEFT JOIN Classes ON Students.student_id = Classes.student_id LEFT JOIN Detention ON Students.student_id = Detention.student_id GROUP BY Students.student_id, Students.bio_data HAVING COUNT(DISTINCT Classes.class_id) >= 2 OR COUNT(DISTINCT Detention.detention_id) < 2;","SELECT T1.bio_data ,  T1.student_id FROM Students AS T1 JOIN Classes AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  >=  2 UNION SELECT T1.bio_data ,  T1.student_id FROM Students AS T1 JOIN Detention AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  <  2","1. Sequential Structure: Start with the SELECT clause to retrieve the biographical data and student ID from the Students table. Use the FROM clause to specify the Students table. Use JOINs to connect the Students table with the Classes and Detention tables. Apply GROUP BY to group by student_id for counting classes and detentions. Use the HAVING clause to filter students who take 2 or more classes or have less than 2 detentions. 2. Condition Structure: Use the HAVING clause to filter students who meet either of the two conditions: taking 2 or more classes or having less than 2 detentions. 3. Join Structure: Use INNER JOINs between the Students table and the Classes and Detention tables based on student_id to connect students with their classes and detentions. 4. Aggregation Structure: Use COUNT to calculate the number of classes and detentions for each student, and apply the conditions in the HAVING clause.",1.0
480,When was the transcript issued for the student with loan of maximum value?,NESTED,cre_Students_Information_Systems,"[Student_Loans.amount_of_loan,Student_Loans.student_id,Transcripts.date_of_transcript,Transcripts.student_id = Student_Loans.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Transcripts.date_of_transcript FROM Transcripts JOIN Student_Loans ON Transcripts.student_id = Student_Loans.student_id WHERE Student_Loans.amount_of_loan = (SELECT MAX(amount_of_loan) FROM Student_Loans);,SELECT T1.date_of_transcript FROM Transcripts AS T1 JOIN Student_Loans AS T2 ON T1.student_id  =  T2.student_id ORDER BY T2.amount_of_loan DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the date of the transcript. Use the FROM clause to specify the Transcripts table and join it with the Student_Loans table to connect the transcript issuance date with the student who has the maximum loan. Use a WHERE clause to filter for the student with the maximum loan value. 2. Condition Structure: Use a WHERE clause with a subquery to identify the student with the maximum loan value by comparing the loan amount. 3. Join Structure: Use an INNER JOIN between the Transcripts and Student_Loans tables based on the student_id to link the transcript issuance date with the loan details. 4. Aggregation Structure: Use the MAX function in a subquery to find the maximum loan value, which is then used in the filtering condition.",1.0
481,Which region has the largest number of buildings? Show me the capital of the region.,NON-NESTED,region_building,"[region.Capital,building.Region_ID,region.Region_ID = building.Region_ID]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT region.Capital FROM region JOIN building ON region.Region_ID = building.Region_ID GROUP BY region.Region_ID ORDER BY COUNT(building.Region_ID) DESC LIMIT 1;,SELECT T2.capital FROM building AS T1 JOIN region AS T2 ON T1.Region_ID  =  T2.Region_ID GROUP BY T1.Region_ID ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""region.Capital"" of the region with the largest number of buildings. Use COUNT to count the number of buildings in each region. 2. Condition Structure: No specific filtering condition is needed, but we need to identify the region with the maximum count of buildings. 3. Join Structure: Use a JOIN between the ""region"" and ""building"" tables based on ""region.Region_ID = building.Region_ID"" to associate buildings with their respective regions. 4. Aggregation Structure: Use COUNT to count the number of buildings per region, GROUP BY ""region.Region_ID"" to group the counts by region, and ORDER BY the count in descending order. Use LIMIT 1 to select the region with the largest number of buildings.",1.0
482,Show name and model year for vehicles with city fuel economy rate less than or equal to highway fuel economy rate.,EASY,vehicle_rent,"[Vehicles.name, Vehicles.Model_year, Vehicles.City_fuel_economy_rate, Vehicles.Highway_fuel_economy_rate]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, Vehicles.Model_year FROM Vehicles WHERE Vehicles.City_fuel_economy_rate <= Vehicles.Highway_fuel_economy_rate;","SELECT name ,  model_year FROM vehicles WHERE city_fuel_economy_rate  <=  highway_fuel_economy_rate","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Vehicles.name"" and ""Vehicles.Model_year"" fields for vehicles that meet the specified condition. 2. Condition Structure: Use a WHERE clause to filter vehicles where the ""Vehicles.City_fuel_economy_rate"" is less than or equal to the ""Vehicles.Highway_fuel_economy_rate"". 3. Join Structure: No JOIN is required since all necessary information is available in the ""Vehicles"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving data based on a specific condition.",1.0
483,Count the number of services.,EASY,government_shift,[Services.Service_ID],"Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT COUNT(Services.Service_ID) AS service_count FROM Services;,SELECT count(*) FROM services,"1. Sequential Structure: Begin with the SELECT clause to count the number of services. 2. Aggregation Structure: Use the COUNT function on the ""Services.Service_ID"" field to calculate the total number of services. 3. Condition Structure: No specific filtering condition is required as we are counting all services. 4. Join Structure: No JOIN is required since all necessary data is within the ""Services"" table.",1.0
484,How many customers have an order?,NON-NESTED,customers_and_orders,"[Customers.customer_id,Customer_Orders.customer_id,Customer_Orders.customer_id = Customers.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(DISTINCT Customer_Orders.customer_id) FROM Customers JOIN Customer_Orders ON Customers.customer_id = Customer_Orders.customer_id;,SELECT count(DISTINCT customer_id) FROM Customer_orders,"1. Sequential Structure: Start with the SELECT clause to count the number of distinct customers who have placed an order. Use COUNT with DISTINCT on ""Customer_Orders.customer_id."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in all customers who have an order. 3. Join Structure: Use an INNER JOIN between the ""Customers"" and ""Customer_Orders"" tables based on the shared key ""customer_id"" to ensure we only count customers who have orders. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique customers who have placed orders.",1.0
485,"Sort buildings in descending order of the number of stories, and return their completion years.",EASY,region_building,"[building.Number_of_Stories, building.Completed_Year]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
","SELECT building.Number_of_Stories, building.Completed_Year FROM building ORDER BY building.Number_of_Stories DESC;",SELECT Completed_Year FROM building ORDER BY Number_of_Stories DESC,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the building's number of stories and its completion year. 2. Condition Structure: No specific filtering condition is required as we want all buildings. 3. Join Structure: No JOIN is required since all necessary data is within the ""building"" table. 4. Aggregation Structure: No aggregation is needed as we are simply sorting the buildings. 5. Ordering Structure: Use ORDER BY in descending order on ""building.Number_of_Stories"" to sort the buildings by the number of stories.",1.0
486,Show names for all vehicles in descending order of model year.,EASY,vehicle_rent,"[Vehicles.name, Vehicles.Model_year]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT Vehicles.name FROM Vehicles ORDER BY Vehicles.Model_year DESC;,SELECT name FROM vehicles ORDER BY model_year DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the vehicle name. 2. Condition Structure: No specific filtering condition is required as we want all vehicle names. 3. Join Structure: No JOIN is required since all necessary data is within the ""Vehicles"" table. 4. Ordering Structure: Use ORDER BY in descending order on ""Vehicles.Model_year"" to sort the results by model year. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data.",1.0
487,"Find all the services that has been used by the customer with details ""Hardy Kutch"".",NON-NESTED,government_shift,"[Customers.Customer_Details,Services.Service_ID,Services.Service_Details,Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Hardy Kutch]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Services.Service_Details FROM Customers JOIN Customers_and_Services ON Customers.Customer_ID = Customers_and_Services.Customer_ID JOIN Services ON Customers_and_Services.Service_ID = Services.Service_ID WHERE Customers.Customer_Details = 'Hardy Kutch';,"SELECT t3.service_details FROM customers AS t1 JOIN customers_and_services AS t2 ON t1.customer_id  =  t2.customer_id JOIN services AS t3 ON t2.service_id  =  t3.service_id WHERE t1.customer_details  =  ""Hardy Kutch""","1. Sequential Structure: Start with the SELECT clause to retrieve the details of the services used by the customer. This includes ""Services.Service_Details."" 2. Condition Structure: Use a WHERE clause to filter for the customer with the details ""Hardy Kutch."" 3. Join Structure: Use JOINs to connect the ""Customers"" table with the ""Customers_and_Services"" table on ""Customer_ID"" and then connect the ""Customers_and_Services"" table with the ""Services"" table on ""Service_ID"" to link customers with their respective services. 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving specific service details for a particular customer.",1.0
488,How many customers have ordered the product named Monitor?,NON-NESTED,customers_and_orders,"[Products.product_name, Customers.customer_id, Customer_Orders.customer_id = Customers.customer_id, Order_Items.product_id = Products.product_id, Order_Items.order_id = Customer_Orders.order_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(DISTINCT Customers.customer_id) FROM Products JOIN Order_Items ON Order_Items.product_id = Products.product_id JOIN Customer_Orders ON Order_Items.order_id = Customer_Orders.order_id JOIN Customers ON Customer_Orders.customer_id = Customers.customer_id WHERE Products.product_name = 'Monitor';,"SELECT count(DISTINCT T3.customer_id) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id JOIN Customer_orders AS T3 ON T3.order_id  =  T1.order_id WHERE T2.product_name  =  ""Monitor""","1. Sequential Structure: Start with the SELECT clause to count the number of distinct customers who ordered the product named ""Monitor."" 2. Condition Structure: Use a WHERE clause to filter for the product with the name ""Monitor."" 3. Join Structure: Use multiple JOINs to connect the relevant tables. First, join ""Products"" with ""Order_Items"" on ""product_id"" to link products with their order items. Then, join ""Order_Items"" with ""Customer_Orders"" on ""order_id"" to link order items with customer orders. Finally, join ""Customer_Orders"" with ""Customers"" on ""customer_id"" to associate orders with customers. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Customers.customer_id"" to count the unique customers who ordered the specified product.",1.0
489,"What are the names, ages, and membership credits for all customers?",EASY,vehicle_rent,"[Customers.name, Customers.age, Customers.membership_credit]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Customers.name, Customers.age, Customers.membership_credit FROM Customers;","SELECT name ,  age ,  membership_credit FROM customers","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Customers.name,"" ""Customers.age,"" and ""Customers.membership_credit."" 2. Condition Structure: No specific filtering condition is required as the query asks for all customers. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all customers.",1.0
490,How are all the achievements described? List the achievement detail and the type description.,NON-NESTED,cre_Students_Information_Systems,"[Achievements.achievement_details,Ref_Achievement_Type.achievement_type_description,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Achievements.achievement_details, Ref_Achievement_Type.achievement_type_description FROM Achievements JOIN Ref_Achievement_Type ON Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code;","SELECT T1.achievement_details ,  T2.achievement_type_description FROM Achievements AS T1 JOIN Ref_Achievement_Type AS T2 ON T1.achievement_type_code  =  T2.achievement_type_code","1. Sequential Structure: Start with the SELECT clause to retrieve ""Achievements.achievement_details"" and ""Ref_Achievement_Type.achievement_type_description."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Achievements"" table and the ""Ref_Achievement_Type"" table based on the relationship ""Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code"" to link achievements with their type descriptions. 4. Aggregation Structure: No aggregation is required as the query simply retrieves and lists the details and descriptions.",1.0
491,"Show the type of powertrain with at least two vehicles, and the average annual fuel cost for vehicles in each such type.",EASY,vehicle_rent,"[Vehicles.Type_of_powertrain, Vehicles.Annual_fuel_cost, Vehicles.id]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.Type_of_powertrain, AVG(Vehicles.Annual_fuel_cost) AS avg_annual_fuel_cost FROM Vehicles GROUP BY Vehicles.Type_of_powertrain HAVING COUNT(Vehicles.id) >= 2;","SELECT type_of_powertrain ,  avg(annual_fuel_cost) FROM vehicles GROUP BY type_of_powertrain HAVING count(*)  >=  2","1. Sequential Structure: Begin with the SELECT clause to specify the type of powertrain and the average annual fuel cost. 2. Aggregation Structure: Use AVG to calculate the average annual fuel cost for vehicles in each type of powertrain. 3. Grouping Structure: Use GROUP BY on ""Vehicles.Type_of_powertrain"" to calculate the average annual fuel cost for each powertrain type. 4. Condition Structure: Apply the HAVING clause to filter for powertrain types that have at least two vehicles, by setting the count of vehicles to be greater than or equal to 2. 5. Join Structure: No JOIN is required since all necessary data is within the ""Vehicles"" table.",1.0
492,How many students have gone through a detention?,NON-NESTED,cre_Students_Information_Systems,"[Detention.student_id, Students.student_id, Detention.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT COUNT(DISTINCT Detention.student_id) FROM Detention JOIN Students ON Detention.student_id = Students.student_id;,SELECT count(DISTINCT student_id) FROM Detention,"1. Sequential Structure: Start with the SELECT clause to count the number of students who have gone through detention. Use COUNT on ""Detention.student_id"" to get the total number of students. 2. Condition Structure: No specific filtering condition is required since we are interested in all students who have gone through detention. 3. Join Structure: Use an INNER JOIN between the ""Detention"" and ""Students"" tables on ""Detention.student_id = Students.student_id"" to ensure we only count valid student records. 4. Aggregation Structure: Use COUNT to aggregate the total number of students who have gone through detention.",1.0
493,What is the code of the product type that is least common?,NESTED,customers_and_orders,"[Products.product_type_code, Order_Items.product_id, Order_Items.order_id = Customer_Orders.order_id, Order_Items.product_id = Products.product_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Products.product_type_code FROM Products JOIN Order_Items ON Products.product_id = Order_Items.product_id GROUP BY Products.product_type_code ORDER BY COUNT(Order_Items.product_id) ASC LIMIT 1;,SELECT product_type_code FROM Products GROUP BY product_type_code ORDER BY count(*) ASC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the product type code. Use the FROM clause to specify the Products and Order_Items tables. Join these tables to link product type codes with order items. Use GROUP BY to group by product type code and COUNT to determine the frequency of each product type. Finally, use ORDER BY to sort by the count in ascending order and LIMIT 1 to get the least common product type. 2. Condition Structure: No specific filtering condition is required, as we are interested in all product type codes and their frequencies. 3. Join Structure: Use an INNER JOIN between the Products and Order_Items tables based on product_id to associate product type codes with order items. 4. Aggregation Structure: Use COUNT to calculate the frequency of each product type code and ORDER BY to sort by this count in ascending order to identify the least common product type.",1.0
494,What is the most common analytical layer type code?,EASY,government_shift,[Analytical_Layer.Analytical_Layer_Type_Code],"Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Analytical_Layer.Analytical_Layer_Type_Code FROM Analytical_Layer GROUP BY Analytical_Layer.Analytical_Layer_Type_Code ORDER BY COUNT(*) DESC LIMIT 1;,SELECT analytical_layer_type_code FROM analytical_layer GROUP BY analytical_layer_type_code ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the analytical layer type code, as the question asks for the most common type code. 2. Aggregation Structure: Use COUNT to calculate the frequency of each analytical layer type code. 3. Grouping Structure: Use GROUP BY on ""Analytical_Layer.Analytical_Layer_Type_Code"" to group the results by each type code. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank the type codes by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common analytical layer type code. 6. Join Structure: No JOIN is required since all necessary data is within the ""Analytical_Layer"" table.",1.0
495,"For each analytical layer, return the analytical layer type code and the number of times it was used.",EASY,government_shift,"[Analytical_Layer.Analytical_Layer_Type_Code, Analytical_Layer.Analytical_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
","SELECT Analytical_Layer.Analytical_Layer_Type_Code, COUNT(Analytical_Layer.Analytical_ID) AS usage_count FROM Analytical_Layer GROUP BY Analytical_Layer.Analytical_Layer_Type_Code;","SELECT analytical_layer_type_code ,  count(*) FROM analytical_layer GROUP BY analytical_layer_type_code","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the ""Analytical_Layer.Analytical_Layer_Type_Code"" and the count of ""Analytical_Layer.Analytical_ID"". 2. Aggregation Structure: Use COUNT to calculate the number of times each analytical layer type code was used. 3. Grouping Structure: Use GROUP BY on ""Analytical_Layer.Analytical_Layer_Type_Code"" to aggregate the results by each analytical layer type code. 4. Join Structure: No JOIN is required since all necessary data is within the ""Analytical_Layer"" table.",1.0
496,Find the details of the teachers who have taught the student with the earliest transcript issuance.,NESTED,cre_Students_Information_Systems,"[Teachers.teacher_details,Transcripts.date_of_transcript,Transcripts.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Teachers.teacher_details FROM Teachers JOIN Classes ON Teachers.teacher_id = Classes.teacher_id JOIN Students ON Classes.student_id = Students.student_id JOIN Transcripts ON Students.student_id = Transcripts.student_id WHERE Transcripts.date_of_transcript = (SELECT MIN(date_of_transcript) FROM Transcripts);,SELECT T1.teacher_details FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id JOIN Transcripts AS T3 ON T2.student_id  =  T3.student_id ORDER BY T3.date_of_transcript ASC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the details of teachers. Use the FROM clause to specify the Teachers table. Join it with the Classes table to link teachers with the students they have taught. Further, join the Students table and the Transcripts table to identify the student with the earliest transcript issuance. Use a WHERE clause to filter for the earliest transcript date. 2. Condition Structure: Use a subquery in the WHERE clause to find the minimum date of transcript issuance from the Transcripts table. Filter the main query to only include records for this date. 3. Join Structure: Use INNER JOINs to connect the Teachers table with the Classes table on teacher_id, the Classes table with the Students table on student_id, and the Students table with the Transcripts table on student_id. 4. Aggregation Structure: Use MIN in a subquery to find the earliest transcript issuance date, which is then used in the filtering condition.",1.0
497,Compute the average amount of student loans.,EASY,cre_Students_Information_Systems,[Student_Loans.amount_of_loan],"Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT AVG(Student_Loans.amount_of_loan) AS average_loan FROM Student_Loans;,SELECT avg(amount_of_loan) FROM Student_Loans,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average amount of student loans. 2. Aggregation Structure: Use the AVG function to calculate the average of the ""Student_Loans.amount_of_loan"" field. 3. Condition Structure: No specific filtering condition is required as the query aims to compute the average for all student loans. 4. Join Structure: No JOIN is required since all necessary data is within the ""Student_Loans"" table.",1.0
498,List the details for all the pairs of teachers and students who are in the same class.,NON-NESTED,cre_Students_Information_Systems,"[Classes.teacher_id, Classes.student_id, Teachers.teacher_id = Classes.teacher_id, Students.student_id = Classes.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Teachers.*, Students.* FROM Classes JOIN Teachers ON Classes.teacher_id = Teachers.teacher_id JOIN Students ON Classes.student_id = Students.student_id;","SELECT T1.teacher_details ,  T3.student_details FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id JOIN Students AS T3 ON T2.student_id  =  T3.student_id","1. Sequential Structure: Start with the SELECT clause to retrieve the details of teachers and students who are in the same class. This includes fields from the ""Teachers"" and ""Students"" tables. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Classes"" table with the ""Teachers"" table on ""Classes.teacher_id = Teachers.teacher_id"" and the ""Classes"" table with the ""Students"" table on ""Classes.student_id = Students.student_id"" to link teachers and students in the same class. 4. Aggregation Structure: No aggregation is required as the query is about listing details, not summarizing data.",1.0
499,"What are the ids and product types for all products, sorted alphabetically by product name?",EASY,customers_and_orders,"[Products.product_id, Products.product_type_code, Products.product_name]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Products.product_id, Products.product_type_code FROM Products ORDER BY Products.product_name ASC;","SELECT product_id ,  product_type_code FROM Products ORDER BY product_name","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""Products.product_id"" and ""Products.product_type_code"". 2. Condition Structure: No specific filtering condition is required as the query asks for all products. 3. Join Structure: No JOIN is required since all necessary data is within the ""Products"" table. 4. Aggregation Structure: No aggregation is needed as the query does not involve any summarization. 5. Ordering Structure: Use ORDER BY on ""Products.product_name"" in ascending order to sort the results alphabetically by product name.",1.0
500,Give the different payment method codes that customers use.,EASY,customers_and_orders,[Customers.payment_method_code],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT DISTINCT Customers.payment_method_code FROM Customers;,SELECT DISTINCT payment_method_code FROM Customers,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct payment method codes used by customers. 2. Condition Structure: No specific filtering condition is required as we want all distinct payment method codes. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is used to ensure unique payment method codes are retrieved.",1.0
501,"For each building, return the name of the building and the name of the region it belongs to.",NON-NESTED,region_building,"[building.Name, region.Name, building.Region_ID = region.Region_ID]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
","SELECT building.Name, region.Name FROM building JOIN region ON building.Region_ID = region.Region_ID;","SELECT T1.Name ,  T2.Name FROM building AS T1 JOIN region AS T2 ON T1.Region_ID  =  T2.Region_ID","1. Sequential Structure: Start with the SELECT clause to retrieve the ""building.Name"" and ""region.Name."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""building"" table with the ""region"" table based on the relationship ""building.Region_ID = region.Region_ID."" 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the names of buildings and their corresponding regions.",1.0
502,What are the ids of customers who have not made an order?,NESTED,customers_and_orders,"[Customers.customer_id,Customer_Orders.customer_id,Customers.customer_id = Customer_Orders.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT customer_id FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Customer_Orders);,SELECT customer_id FROM Customers EXCEPT SELECT customer_id FROM Customer_orders,"1. Sequential Structure: Start with the SELECT clause to retrieve the customer IDs from the Customers table. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter customers who have not made an order by ensuring their customer_id is not present in the Customer_Orders table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude customers whose customer_id appears in the Customer_Orders table, meaning they have made an order. 3. Join Structure: Not required, as we only need to filter based on the absence of matching customer_id entries in the Customer_Orders table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
503,How many customer orders do we have?,EASY,customers_and_orders,[Customer_Orders.order_id],"Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(Customer_Orders.order_id) AS total_orders FROM Customer_Orders;,SELECT count(*) FROM Customer_orders,"1. Sequential Structure: Start with the SELECT clause to count the total number of customer orders. 2. Condition Structure: No specific filtering condition is required since we want the total count of all orders. 3. Join Structure: No JOIN is necessary as the required information is available in the ""Customer_Orders"" table. 4. Aggregation Structure: Use COUNT on ""Customer_Orders.order_id"" to calculate the total number of orders.",1.0
504,"What are the names, types of powertrains, and yearly fuel costs for vehicles with model years in either 2013 2014?",EASY,vehicle_rent,"[Vehicles.name, Vehicles.Type_of_powertrain, Vehicles.Annual_fuel_cost, Vehicles.Model_year, 2013, 2014]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Vehicles.name, Vehicles.Type_of_powertrain, Vehicles.Annual_fuel_cost FROM Vehicles WHERE Vehicles.Model_year IN (2013, 2014);","SELECT name ,  type_of_powertrain ,  annual_fuel_cost FROM vehicles WHERE model_year  =  2013 OR model_year  =  2014","1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""Vehicles.name,"" ""Vehicles.Type_of_powertrain,"" and ""Vehicles.Annual_fuel_cost"" for vehicles with model years 2013 or 2014. 2. Condition Structure: Use a WHERE clause to filter for vehicles where ""Vehicles.Model_year"" is either 2013 or 2014. 3. Join Structure: No JOIN is required since all necessary information is in the ""Vehicles"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving specific fields for vehicles that meet the specified condition.",1.0
505,Count the number of buildings.,EASY,region_building,[building.Building_ID],"Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT COUNT(building.Building_ID) AS building_count FROM building;,SELECT count(*) FROM building,"1. Sequential Structure: Start with the SELECT clause to count the number of buildings. 2. Aggregation Structure: Use the COUNT function to calculate the total number of buildings. 3. Condition Structure: No specific filtering condition is required as we want to count all buildings. 4. Join Structure: No JOIN is required since all necessary data is within the ""building"" table.",1.0
506,Show all book isbns and the numbers of orders for each.,NON-NESTED,book_1,"[Book.ISBN, Books_Order.ISBN, Books_Order.IdOrder, Books_Order.amount]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Book.ISBN, COUNT(Books_Order.IdOrder) AS number_of_orders FROM Book JOIN Books_Order ON Book.ISBN = Books_Order.ISBN GROUP BY Book.ISBN;","SELECT isbn ,  count(*) FROM Books_Order GROUP BY isbn","1. Sequential Structure: Start with the SELECT clause to retrieve ""Book.ISBN"" and the count of orders for each book. Use COUNT on ""Books_Order.IdOrder"" to count the number of orders. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Book"" and ""Books_Order"" tables based on the ""ISBN"" field to link books with their orders. 4. Aggregation Structure: Use COUNT to aggregate the number of orders for each book and GROUP BY ""Book.ISBN"" to group the results by each book's ISBN.",1.0
507,Show the name and age of the customer with maximum membership credit.,EASY,vehicle_rent,"[Customers.name, Customers.age, Customers.membership_credit]","Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT Customers.name, Customers.age FROM Customers ORDER BY Customers.membership_credit DESC LIMIT 1;","SELECT name ,  age FROM customers ORDER BY membership_credit DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Customers.name"" and ""Customers.age"" of the customer with the maximum membership credit. 2. Condition Structure: No specific filtering condition is needed since we are looking for the customer with the highest membership credit. 3. Join Structure: No JOIN is required, as all necessary information is available in the ""Customers"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""Customers.membership_credit"" to rank customers by their membership credit and apply LIMIT 1 to select the customer with the maximum membership credit.",1.0
508,How many courses do teachers teach at most? Also find the id of the teacher who teaches the most.,NON-NESTED,cre_Students_Information_Systems,"[Classes.teacher_id, Classes.class_id, Teachers.teacher_id = Classes.teacher_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Classes.teacher_id, COUNT(Classes.class_id) AS course_count FROM Classes GROUP BY Classes.teacher_id ORDER BY course_count DESC LIMIT 1;","SELECT count(*) ,  teacher_id FROM Classes GROUP BY teacher_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the maximum number of courses taught by any teacher and the ID of the teacher who teaches the most. Use COUNT to count the number of courses taught by each teacher. 2. Condition Structure: No specific filtering condition is required, as we are interested in all teachers. 3. Join Structure: No JOIN is necessary since the relevant data is within the ""Classes"" table, and the teacher ID is directly available. 4. Aggregation Structure: Use COUNT to count the number of courses taught by each teacher, GROUP BY to group the data by teacher ID, and ORDER BY in descending order to rank teachers by the number of courses they teach. Use LIMIT 1 to get the teacher who teaches the most courses.",1.0
509,How many customers do not have an order?,NESTED,customers_and_orders,"[Customers.customer_id,Customer_Orders.customer_id,Customers.customer_id = Customer_Orders.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT COUNT(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Customer_Orders);,SELECT count(*) FROM Customers WHERE customer_id NOT IN  ( SELECT customer_id FROM Customer_orders),"1. Sequential Structure: Start with the SELECT clause to count the number of customers. Use the FROM clause to specify the Customers table. Apply a WHERE clause to filter customers who do not have an order by ensuring their customer_id is not present in the Customer_Orders table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude customers whose customer_id appears in the Customer_Orders table, meaning they have placed orders. 3. Join Structure: Not required, as we only need to filter based on the absence of matching customer_id entries in the Customer_Orders table. 4. Aggregation Structure: Use COUNT to calculate the total number of customers who do not have an order.",1.0
510,Find all the layer type codes with their corresponding usage count.,EASY,government_shift,"[Analytical_Layer.Analytical_Layer_Type_Code, Analytical_Layer.Customers_and_Services_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
","SELECT Analytical_Layer.Analytical_Layer_Type_Code, COUNT(Analytical_Layer.Customers_and_Services_ID) AS usage_count FROM Analytical_Layer GROUP BY Analytical_Layer.Analytical_Layer_Type_Code;","SELECT analytical_layer_type_code ,  count(*) FROM analytical_layer GROUP BY analytical_layer_type_code","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the ""Analytical_Layer.Analytical_Layer_Type_Code"" and the count of its usage. 2. Aggregation Structure: Use COUNT to calculate the number of occurrences of each ""Analytical_Layer.Analytical_Layer_Type_Code"". 3. Grouping Structure: Use GROUP BY on ""Analytical_Layer.Analytical_Layer_Type_Code"" to aggregate the results by each layer type code. 4. Join Structure: No JOIN is required since all necessary data is within the ""Analytical_Layer"" table.",1.0
511,What are the loan amounts and loan dates of the students who have at least 2 achievements?,NESTED,cre_Students_Information_Systems,"[Student_Loans.amount_of_loan, Student_Loans.date_of_loan, Achievements.student_id, Achievements.achievement_id, Achievements.student_id = Student_Loans.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Student_Loans.amount_of_loan, Student_Loans.date_of_loan FROM Student_Loans JOIN Achievements ON Student_Loans.student_id = Achievements.student_id GROUP BY Student_Loans.student_id, Student_Loans.amount_of_loan, Student_Loans.date_of_loan HAVING COUNT(Achievements.achievement_id) >= 2;","SELECT amount_of_loan ,  date_of_loan FROM Student_Loans WHERE student_id IN ( SELECT student_id FROM Achievements GROUP BY student_id HAVING count(*)  >=  2 )","1. Sequential Structure: Start with the SELECT clause to retrieve the loan amounts and loan dates from the Student_Loans table. Use the FROM clause to specify the Student_Loans table and JOIN it with the Achievements table to link students with their achievements. Apply a GROUP BY clause to group records by student_id, allowing us to count achievements for each student. Use the HAVING clause to filter students with at least 2 achievements. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for students who have at least 2 achievements. 3. Join Structure: Use an INNER JOIN between the Student_Loans and Achievements tables based on student_id to connect loan details with achievements. 4. Aggregation Structure: Use COUNT(*) within HAVING to aggregate the number of achievements per student and filter out students with fewer than 2 achievements.",1.0
512,"What is the list of building names, sorted by the number of stories of each building in ascending order?",EASY,region_building,"[building.Name, building.Number_of_Stories]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT building.Name FROM building ORDER BY building.Number_of_Stories ASC;,SELECT Name FROM building ORDER BY Number_of_Stories ASC,"1. Sequential Structure: Start with the SELECT clause to retrieve the building names and their number of stories. 2. Condition Structure: No specific filtering condition is required as we want all buildings. 3. Join Structure: No JOIN is needed since all necessary information is available in the ""building"" table. 4. Aggregation Structure: No aggregation is needed as we are simply sorting the buildings by the number of stories. 5. Ordering Structure: Use ORDER BY in ascending order on ""building.Number_of_Stories"" to sort the results.",1.0
513,Which teacher teaches the most courses? Give me the id of the teacher and the number of courses he or she teaches.,NON-NESTED,cre_Students_Information_Systems,"[Classes.teacher_id,Classes.class_id,Teachers.teacher_id = Classes.teacher_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Classes.teacher_id, COUNT(Classes.class_id) AS course_count FROM Classes GROUP BY Classes.teacher_id ORDER BY course_count DESC LIMIT 1;","SELECT count(*) ,  teacher_id FROM Classes GROUP BY teacher_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher_id"" and the count of courses taught by each teacher. Use COUNT on ""Classes.class_id"" to count the number of courses taught. 2. Condition Structure: No specific filtering condition is required, as we are interested in all teachers. 3. Join Structure: No JOIN is necessary since the required data is available in the ""Classes"" table, and the relationship between ""Teachers"" and ""Classes"" is already established through ""teacher_id."" 4. Aggregation Structure: Use GROUP BY on ""Classes.teacher_id"" to group the data by teacher. Use ORDER BY in descending order of the course count to rank teachers by the number of courses they teach. Use LIMIT 1 to get the teacher who teaches the most courses.",1.0
514,What is the maximum number of stories of buildings not completed in 1980?,NESTED,region_building,"[building.Number_of_Stories, building.Completed_Year]","Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT MAX(Number_of_Stories) AS max_stories FROM building WHERE Completed_Year != 1980;,"SELECT max(Number_of_Stories) FROM building WHERE Completed_Year != ""1980""","1. Sequential Structure: Start with the SELECT clause to retrieve the maximum number of stories. Use the FROM clause to specify the building table. Apply a WHERE clause to filter buildings that were not completed in the year 1980. 2. Condition Structure: Use the WHERE clause to exclude buildings with a Completed_Year of 1980. 3. Join Structure: Not required, as all data is available within the building table. 4. Aggregation Structure: Use the MAX function to find the maximum number of stories among the filtered buildings.",1.0
515,List the amount and date of loan for the students who have two or more achievements.,NESTED,cre_Students_Information_Systems,"[Student_Loans.amount_of_loan, Student_Loans.date_of_loan, Achievements.student_id, Achievements.achievement_id, Achievements.student_id = Student_Loans.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Student_Loans.amount_of_loan, Student_Loans.date_of_loan FROM Student_Loans JOIN Achievements ON Student_Loans.student_id = Achievements.student_id GROUP BY Student_Loans.student_id, Student_Loans.amount_of_loan, Student_Loans.date_of_loan HAVING COUNT(Achievements.achievement_id) >= 2;","SELECT amount_of_loan ,  date_of_loan FROM Student_Loans WHERE student_id IN ( SELECT student_id FROM Achievements GROUP BY student_id HAVING count(*)  >=  2 )","1. Sequential Structure: Start with the SELECT clause to retrieve the amount and date of loans. Use the FROM clause to specify the Student_Loans table and JOIN it with the Achievements table to link students with their achievements. Apply a GROUP BY clause to group records by student_id, allowing us to count achievements for each student. Use the HAVING clause to filter students with two or more achievements. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for students having two or more achievements. 3. Join Structure: Use an INNER JOIN between the Student_Loans and Achievements tables based on student_id to connect loan details with achievements. 4. Aggregation Structure: Use COUNT(*) within HAVING to aggregate the number of achievements per student and filter out students with fewer than two achievements.",1.0
516,What are the achievement detail and the type description of each achievements?,NON-NESTED,cre_Students_Information_Systems,"[Achievements.achievement_details,Ref_Achievement_Type.achievement_type_description,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Achievements.achievement_details, Ref_Achievement_Type.achievement_type_description FROM Achievements JOIN Ref_Achievement_Type ON Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code;","SELECT T1.achievement_details ,  T2.achievement_type_description FROM Achievements AS T1 JOIN Ref_Achievement_Type AS T2 ON T1.achievement_type_code  =  T2.achievement_type_code","1. Sequential Structure: Start with the SELECT clause to retrieve ""Achievements.achievement_details"" and ""Ref_Achievement_Type.achievement_type_description."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Achievements"" table and the ""Ref_Achievement_Type"" table based on the relationship ""Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code"" to link each achievement with its type description. 4. Aggregation Structure: No aggregation is required as the query simply retrieves details and descriptions for each achievement.",1.0
517,What is the type of powertrain with most number of vehicles.,EASY,vehicle_rent,[Vehicles.Type_of_powertrain],"Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
",SELECT Vehicles.Type_of_powertrain FROM Vehicles GROUP BY Vehicles.Type_of_powertrain ORDER BY COUNT(*) DESC LIMIT 1;,SELECT type_of_powertrain FROM vehicles GROUP BY type_of_powertrain ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the type of powertrain, as the question asks for the type with the most number of vehicles. 2. Aggregation Structure: Use COUNT to calculate the number of vehicles for each type of powertrain. 3. Grouping Structure: Use GROUP BY on ""Vehicles.Type_of_powertrain"" to aggregate the results by each powertrain type. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank powertrain types by the number of vehicles. 5. Limiting Structure: Use LIMIT 1 to retrieve only the type of powertrain with the most vehicles. 6. Join Structure: No JOIN is required since all necessary data is within the ""Vehicles"" table.",1.0
518,Find the most common result in the behavioral monitoring details. What are the count and the details of this result?,EASY,cre_Students_Information_Systems,"[Behaviour_Monitoring.behaviour_monitoring_details, Behaviour_Monitoring.behaviour_monitoring_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Behaviour_Monitoring.behaviour_monitoring_details, COUNT(*) AS result_count FROM Behaviour_Monitoring GROUP BY Behaviour_Monitoring.behaviour_monitoring_details ORDER BY result_count DESC LIMIT 1;","SELECT count(DISTINCT student_id) ,  behaviour_monitoring_details FROM Behaviour_Monitoring GROUP BY behaviour_monitoring_details ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the ""behaviour_monitoring_details"" and the count of occurrences for each detail. 2. Aggregation Structure: Use COUNT to calculate the number of occurrences of each ""behaviour_monitoring_details"". 3. Grouping Structure: Use GROUP BY on ""Behaviour_Monitoring.behaviour_monitoring_details"" to aggregate the results by each detail. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank the details by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve only the most common result. 6. Join Structure: No JOIN is required since all necessary data is within the ""Behaviour_Monitoring"" table.",0.0
519,How many books do we have?,EASY,book_1,[Book.ISBN],"Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT COUNT(Book.ISBN) AS total_books FROM Book;,SELECT count(*) FROM Book,"1. Sequential Structure: Start with the SELECT clause to count the total number of books. 2. Aggregation Structure: Use the COUNT function on the ""Book.ISBN"" field to calculate the total number of books. 3. Condition Structure: No specific filtering condition is required as we want the total count of all books. 4. Join Structure: No JOIN is required since all necessary data is within the ""Book"" table.",1.0
520,List the names of regions in alphabetical order.,EASY,region_building,[region.Name],"Table building, columns = [*,Building_ID,Region_ID,Name,Address,Number_of_Stories,Completed_Year]
Table region, columns = [*,Region_ID,Name,Capital,Area,Population]
","Foreign_keys = [building.Region_ID = region.Region_ID]
",SELECT region.Name FROM region ORDER BY region.Name ASC;,SELECT Name FROM region ORDER BY Name ASC,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""region.Name"". 2. Condition Structure: No specific filtering condition is required as we want all region names. 3. Join Structure: No JOIN is required since all necessary information is in the ""region"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the region names. 5. Ordering Structure: Use ORDER BY in ascending order to list the region names alphabetically.",1.0
521,Find the details of the customers who have used the least-used service .,NESTED,government_shift,"[Customers.Customer_Details,Customers.Customer_ID,Services.Service_ID,Services.Service_Details,Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Customers.Customer_Details FROM Customers JOIN Customers_and_Services ON Customers.Customer_ID = Customers_and_Services.Customer_ID JOIN Services ON Customers_and_Services.Service_ID = Services.Service_ID WHERE Services.Service_ID = ( SELECT Service_ID FROM Customers_and_Services GROUP BY Service_ID ORDER BY COUNT(*) ASC LIMIT 1 );,select distinct t1.customer_details from customers as t1 join customers_and_services as t2 on t1.customer_id  =  t2.customer_id where t2.service_id  =  (select service_id from services group by service_id order by count(*) asc limit 1),"1. Sequential Structure: Start with the SELECT clause to retrieve the details of customers. Use the FROM clause to specify the Customers table and JOIN it with the Customers_and_Services table to link customers with the services they have used. Further, JOIN the Services table to get the service details. Use GROUP BY to group by service ID and COUNT to determine the usage of each service. Use a subquery to find the least-used service and filter customers who have used that service. 2. Condition Structure: Use a WHERE clause to filter for customers who have used the least-used service. The least-used service is determined using a subquery that calculates the minimum count of service usage. 3. Join Structure: Use INNER JOINs between Customers, Customers_and_Services, and Services tables based on Customer_ID and Service_ID to connect customer details with the services they have used. 4. Aggregation Structure: Use COUNT to calculate the usage of each service and MIN to find the least-used service.",0.0
522,"Give the id, name, phone, and email corresponding to the customer who made the most orders.",NON-NESTED,customers_and_orders,"[Customers.customer_id,Customers.customer_name,Customers.customer_phone,Customers.customer_email,Customer_Orders.customer_id,Customer_Orders.order_id,Customer_Orders.customer_id = Customers.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customers.customer_id, Customers.customer_name, Customers.customer_phone, Customers.customer_email FROM Customers JOIN Customer_Orders ON Customer_Orders.customer_id = Customers.customer_id GROUP BY Customer_Orders.customer_id ORDER BY COUNT(Customer_Orders.order_id) DESC LIMIT 1;","SELECT T1.customer_id ,  T2.customer_name ,  T2.customer_phone ,  T2.customer_email FROM Customer_orders AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Customers.customer_id,"" ""Customers.customer_name,"" ""Customers.customer_phone,"" and ""Customers.customer_email."" 2. Condition Structure: No specific filtering condition is needed, but we need to identify the customer who made the most orders. This requires using an aggregation function and filtering based on the maximum count of orders. 3. Join Structure: Use a JOIN between the ""Customers"" table and the ""Customer_Orders"" table on ""Customer_Orders.customer_id = Customers.customer_id"" to link customers with their orders. 4. Aggregation Structure: Use COUNT to count the number of orders for each customer, GROUP BY ""Customer_Orders.customer_id"" to group the counts by customer, and ORDER BY the count in descending order. Use LIMIT 1 to select the customer with the most orders.",1.0
523,How many clients are there?,EASY,book_1,[Client.IdClient],"Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT COUNT(Client.IdClient) AS total_clients FROM Client;,SELECT count(*) FROM Client,"1. Sequential Structure: Begin with the SELECT clause to count the total number of clients. 2. Aggregation Structure: Use the COUNT function to calculate the total number of clients based on their unique IDs. 3. Condition Structure: No specific filtering condition is required as we want the total count of all clients. 4. Join Structure: No JOIN is necessary since all required data is within the ""Client"" table.",1.0
524,"What are the names of all the authors, and how many books has each written?",NON-NESTED,book_1,"[Author.Name, Author.idAuthor, Author_Book.idAuthor, Author_Book.ISBN, Book.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Author.Name, COUNT(Book.ISBN) AS NumberOfBooks FROM Author JOIN Author_Book ON Author.idAuthor = Author_Book.idAuthor JOIN Book ON Author_Book.ISBN = Book.ISBN GROUP BY Author.Name;","SELECT T1.name ,  count(*) FROM Author AS T1 JOIN Author_Book AS T2 ON T1.idAuthor  =  T2.Author GROUP BY T1.idAuthor","1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors (""Author.Name"") and the count of books each has written. Use COUNT to count the number of books associated with each author. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Author"" table with the ""Author_Book"" table on ""Author.idAuthor = Author_Book.idAuthor"" and the ""Author_Book"" table with the ""Book"" table on ""Author_Book.ISBN = Book.ISBN"" to link authors with their books. 4. Aggregation Structure: Use GROUP BY on ""Author.Name"" to group the results by each author and apply COUNT to calculate the number of books written by each author.",0.0
525,Show all customer ids and customer names.,EASY,customers_and_orders,"[Customers.customer_id, Customers.customer_name]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
","SELECT Customers.customer_id, Customers.customer_name FROM Customers;","SELECT customer_id ,  customer_name FROM Customers","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""customer_id"" and ""customer_name"". 2. Condition Structure: No specific filtering condition is required as the query asks for all customer IDs and names. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all customer IDs and names.",1.0
526,"Show minimum, maximum, and average annual fuel cost for all vehicles.",EASY,vehicle_rent,[Vehicles.Annual_fuel_cost],"Table Customers, columns = [*,id,name,age,membership_credit]
Table Discount, columns = [*,id,name,membership_credit]
Table Renting_history, columns = [*,id,customer_id,discount_id,vehicles_id,total_hours]
Table Vehicles, columns = [*,id,name,Model_year,Type_of_powertrain,Combined_fuel_economy_rate,City_fuel_economy_rate,Highway_fuel_economy_rate,Cost_per_25_miles,Annual_fuel_cost,Notes]
","Foreign_keys = [Renting_history.discount_id = Discount.id,Renting_history.vehicles_id = Vehicles.id,Renting_history.customer_id = Customers.id]
","SELECT MIN(Vehicles.Annual_fuel_cost) AS min_fuel_cost, MAX(Vehicles.Annual_fuel_cost) AS max_fuel_cost, AVG(Vehicles.Annual_fuel_cost) AS avg_fuel_cost FROM Vehicles;","SELECT min(annual_fuel_cost) ,  max(annual_fuel_cost) ,  avg(annual_fuel_cost) FROM vehicles","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the minimum, maximum, and average annual fuel costs. 2. Aggregation Structure: Use MIN, MAX, and AVG functions to calculate the minimum, maximum, and average annual fuel costs for all vehicles. 3. Condition Structure: No specific filtering condition is required as the query applies to all vehicles. 4. Join Structure: No JOIN is required since all necessary data is within the ""Vehicles"" table.",1.0
527,List names and addresses of all clients in alphabetical order by their names.,EASY,book_1,"[Client.Name, Client.Address]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Client.Name, Client.Address FROM Client ORDER BY Client.Name ASC;","SELECT name ,  address FROM Client ORDER BY name","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""Client.Name"" and ""Client.Address"". 2. Condition Structure: No specific filtering condition is required as we want all clients. 3. Join Structure: No JOIN is required since all necessary data is within the ""Client"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""Client.Name"" in ascending order to list the clients alphabetically.",1.0
528,"List all Book titles, ISBNs, and sale prices.",EASY,book_1,"[Book.Title, Book.ISBN, Book.SalePrice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Book.Title, Book.ISBN, Book.SalePrice FROM Book;","SELECT title ,  isbn ,  SalePrice FROM Book","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Book.Title,"" ""Book.ISBN,"" and ""Book.SalePrice."" 2. Condition Structure: No specific filtering condition is required as the query asks for all book titles, ISBNs, and sale prices. 3. Join Structure: No JOIN is required since all necessary data is within the ""Book"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all records from the ""Book"" table.",1.0
529,List the personal details and the address type descriptions of all the students.,NON-NESTED,cre_Students_Information_Systems,"[Students.student_details, Ref_Address_Types.address_type_description, Students.student_id = Students_Addresses.student_id, Students_Addresses.address_type_code = Ref_Address_Types.address_type_code]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
","SELECT Students.student_details, Ref_Address_Types.address_type_description FROM Students JOIN Students_Addresses ON Students.student_id = Students_Addresses.student_id JOIN Ref_Address_Types ON Students_Addresses.address_type_code = Ref_Address_Types.address_type_code;","SELECT DISTINCT T1.student_details ,  T3.address_type_description FROM Students AS T1 JOIN Students_Addresses AS T2 ON T1.student_id  =  T2.student_id JOIN Ref_Address_Types AS T3 ON T2.address_type_code  =  T3.address_type_code","1. Sequential Structure: Start with the SELECT clause to retrieve the personal details of students from ""Students.student_details"" and the address type descriptions from ""Ref_Address_Types.address_type_description."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Students"" table with ""Students_Addresses"" on ""Students.student_id"" and then connect ""Students_Addresses"" with ""Ref_Address_Types"" on ""Students_Addresses.address_type_code."" 4. Aggregation Structure: No aggregation is required as the query simply retrieves and lists the relevant details.",1.0
530,List the biographical data of the students who never had a detention or student loan .,NESTED,cre_Students_Information_Systems,"[Students.bio_data,Detention.student_id,Student_Loans.student_id,Detention.student_id = Students.student_id,Student_Loans.student_id = Students.student_id]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Students.bio_data FROM Students WHERE Students.student_id NOT IN (SELECT Detention.student_id FROM Detention) AND Students.student_id NOT IN (SELECT Student_Loans.student_id FROM Student_Loans);,select bio_data from students where student_id not in (select t1.student_id from students as t1 join detention as t2 on t1.student_id  =  t2.student_id union select t1.student_id from students as t1 join student_loans as t2 on t1.student_id  =  t2.student_id),"1. Sequential Structure: Start with the SELECT clause to retrieve the biographical data of students. Use the FROM clause to specify the Students table. Apply a WHERE clause to filter students who never had a detention or a student loan. 2. Condition Structure: Use the WHERE clause with subqueries to exclude students whose IDs appear in the Detention or Student_Loans tables, as these indicate students who had a detention or a loan. 3. Join Structure: Not required, as the filtering is based on subqueries that check for the absence of student IDs in the Detention and Student_Loans tables. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
531,Which teachers have taught the student with the earliest transcript issuance? List the teacher details.,NESTED,cre_Students_Information_Systems,"[Teachers.teacher_details,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Transcripts.student_id = Students.student_id,Transcripts.date_of_transcript]","Table Achievements, columns = [*,achievement_id,achievement_type_code,student_id,date_achievement,achievement_details,other_details]
Table Addresses, columns = [*,address_id,address_details]
Table Behaviour_Monitoring, columns = [*,behaviour_monitoring_id,student_id,behaviour_monitoring_details]
Table Classes, columns = [*,class_id,student_id,teacher_id,class_details]
Table Detention, columns = [*,detention_id,detention_type_code,student_id,datetime_detention_start,datetime_detention_end,detention_summary,other_details]
Table Ref_Achievement_Type, columns = [*,achievement_type_code,achievement_type_description]
Table Ref_Address_Types, columns = [*,address_type_code,address_type_description]
Table Ref_Detention_Type, columns = [*,detention_type_code,detention_type_description]
Table Ref_Event_Types, columns = [*,event_type_code,event_type_description]
Table Student_Events, columns = [*,event_id,event_type_code,student_id,event_date,other_details]
Table Student_Loans, columns = [*,student_loan_id,student_id,date_of_loan,amount_of_loan,other_details]
Table Students, columns = [*,student_id,bio_data,student_details]
Table Students_Addresses, columns = [*,student_address_id,address_id,address_type_code,student_id,date_from,date_to]
Table Teachers, columns = [*,teacher_id,teacher_details]
Table Transcripts, columns = [*,transcript_id,student_id,date_of_transcript,transcript_details]
","Foreign_keys = [Transcripts.student_id = Students.student_id,Behaviour_Monitoring.student_id = Students.student_id,Student_Events.event_type_code = Ref_Event_Types.event_type_code,Student_Events.student_id = Students.student_id,Student_Loans.student_id = Students.student_id,Classes.teacher_id = Teachers.teacher_id,Classes.student_id = Students.student_id,Students_Addresses.address_type_code = Ref_Address_Types.address_type_code,Students_Addresses.address_id = Addresses.address_id,Students_Addresses.student_id = Students.student_id,Detention.detention_type_code = Ref_Detention_Type.detention_type_code,Detention.student_id = Students.student_id,Achievements.achievement_type_code = Ref_Achievement_Type.achievement_type_code,Achievements.student_id = Students.student_id]
",SELECT Teachers.teacher_details FROM Teachers JOIN Classes ON Classes.teacher_id = Teachers.teacher_id JOIN Students ON Classes.student_id = Students.student_id JOIN Transcripts ON Transcripts.student_id = Students.student_id WHERE Transcripts.date_of_transcript = (SELECT MIN(date_of_transcript) FROM Transcripts);,SELECT T1.teacher_details FROM Teachers AS T1 JOIN Classes AS T2 ON T1.teacher_id  =  T2.teacher_id JOIN Transcripts AS T3 ON T2.student_id  =  T3.student_id ORDER BY T3.date_of_transcript ASC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve teacher details. Use the FROM clause to specify the Teachers table. Join it with the Classes table to link teachers to the classes they taught. Further, join the Classes table with the Students table to connect students to their classes. Finally, join the Students table with the Transcripts table to access the transcript issuance date. Use a WHERE clause to filter for the student with the earliest transcript issuance date. 2. Condition Structure: Use the WHERE clause with a subquery to find the earliest transcript issuance date from the Transcripts table and filter for the corresponding student. 3. Join Structure: Use INNER JOINs between Teachers, Classes, Students, and Transcripts tables based on their respective relationships (teacher_id, student_id) to connect teacher details with the student having the earliest transcript issuance. 4. Aggregation Structure: Use MIN in a subquery to find the earliest transcript issuance date, which is then used in the filtering condition.",1.0
532,Give the code of the payment method that is most commonly used.,NON-NESTED,customers_and_orders,"[Customers.payment_method_code,Customer_Orders.customer_id = Customers.customer_id]","Table Addresses, columns = [*,address_id,address_details]
Table Customer_Orders, columns = [*,order_id,customer_id,order_date,order_status_code]
Table Customers, columns = [*,customer_id,address_id,payment_method_code,customer_number,customer_name,customer_address,customer_phone,customer_email]
Table Order_Items, columns = [*,order_item_id,order_id,product_id,order_quantity]
Table Products, columns = [*,product_id,product_type_code,product_name,product_price]
","Foreign_keys = [Customer_Orders.customer_id = Customers.customer_id,Order_Items.product_id = Products.product_id,Order_Items.order_id = Customer_Orders.order_id]
",SELECT Customers.payment_method_code FROM Customers JOIN Customer_Orders ON Customer_Orders.customer_id = Customers.customer_id GROUP BY Customers.payment_method_code ORDER BY COUNT(Customers.payment_method_code) DESC LIMIT 1;,SELECT payment_method_code FROM Customers GROUP BY payment_method_code ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Customers.payment_method_code"" that is most commonly used. Use COUNT to determine the frequency of each payment method. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the most commonly used payment method across all records. 3. Join Structure: Use a JOIN between the ""Customers"" and ""Customer_Orders"" tables based on ""Customer_Orders.customer_id = Customers.customer_id"" to link orders with their respective customers. 4. Aggregation Structure: Use COUNT to count the occurrences of each payment method, GROUP BY ""Customers.payment_method_code"" to group by payment method, and ORDER BY the count in descending order to find the most commonly used payment method. Use LIMIT 1 to select the top result.",1.0
533,"Find all the customers whose name contains ""Kutch"".",EASY,government_shift,[Customers.Customer_Details],"Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Customers.Customer_Details FROM Customers WHERE Customers.Customer_Details LIKE '%Kutch%';,"SELECT customer_details FROM customers WHERE customer_details LIKE ""%Kutch%""","1. Sequential Structure: Start with the SELECT clause to retrieve the customer details for customers whose name contains ""Kutch"". 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for customer names that contain ""Kutch"". 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Customers"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific customer details based on a condition.",1.0
534,How many services are there?,EASY,government_shift,[Services.Service_ID],"Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT COUNT(Services.Service_ID) AS total_services FROM Services;,SELECT count(*) FROM services,"1. Sequential Structure: Start with the SELECT clause to count the total number of services. 2. Aggregation Structure: Use the COUNT function on ""Services.Service_ID"" to calculate the total number of services. 3. Condition Structure: No specific filtering condition is required as we want the total count of all services. 4. Join Structure: No JOIN is necessary since all required data is within the ""Services"" table.",1.0
535,Find the name of the customer who has used the most types of services .,NON-NESTED,government_shift,"[Customers.Customer_ID,Customers.Customer_Details,Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID,Services.Service_ID]","Table Analytical_Layer, columns = [*,Analytical_ID,Customers_and_Services_ID,Pattern_Recognition,Analytical_Layer_Type_Code]
Table Channels, columns = [*,Channel_ID,Channel_Details]
Table Customer_Interactions, columns = [*,Customer_Interaction_ID,Channel_ID,Customer_ID,Service_ID,Status_Code,Services_and_Channels_Details]
Table Customers, columns = [*,Customer_ID,Customer_Details]
Table Customers_and_Services, columns = [*,Customers_and_Services_ID,Customer_ID,Service_ID,Customers_and_Services_Details]
Table Integration_Platform, columns = [*,Integration_Platform_ID,Customer_Interaction_ID,Integration_Platform_Details]
Table Services, columns = [*,Service_ID,Service_Details]
","Foreign_keys = [Customers_and_Services.Customer_ID = Customers.Customer_ID,Customers_and_Services.Service_ID = Services.Service_ID,Customer_Interactions.Customer_ID = Customers.Customer_ID,Customer_Interactions.Channel_ID = Channels.Channel_ID,Customer_Interactions.Service_ID = Services.Service_ID,Integration_Platform.Customer_Interaction_ID = Customer_Interactions.Customer_Interaction_ID,Analytical_Layer.Customers_and_Services_ID = Customers_and_Services.Customers_and_Services_ID]
",SELECT Customers.Customer_Details FROM Customers JOIN Customers_and_Services ON Customers.Customer_ID = Customers_and_Services.Customer_ID JOIN Services ON Customers_and_Services.Service_ID = Services.Service_ID GROUP BY Customers.Customer_ID ORDER BY COUNT(DISTINCT Customers_and_Services.Service_ID) DESC LIMIT 1;,select t1.customer_details from customers as t1 join customers_and_services as t2 on t1.customer_id  =  t2.customer_id group by t1.customer_details order by count(*) desc limit 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the customer. Use COUNT with DISTINCT on ""Customers_and_Services.Service_ID"" to count the number of unique services used by each customer. Use ORDER BY in descending order to rank customers by the number of services used and LIMIT 1 to get the customer who used the most types of services. 2. Condition Structure: No specific filtering condition is required, as we are interested in all customers. 3. Join Structure: Use JOINs to connect ""Customers"" with ""Customers_and_Services"" on ""Customer_ID"" and ""Customers_and_Services"" with ""Services"" on ""Service_ID"" to link customers with their services. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique services used by each customer, then use ORDER BY and LIMIT to find the customer with the highest count.",1.0
536,Show names for all USA city ordered by latitude.,EASY,address_1,"[City.city_name, City.country, City.latitude]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.city_name FROM City WHERE City.country = 'USA' ORDER BY City.latitude;,"SELECT city_name FROM City WHERE country  =  ""USA"" ORDER BY latitude","1. Sequential Structure: Start with the SELECT clause to specify the field ""City.city_name"" as we are interested in the names of cities. 2. Condition Structure: Use a WHERE clause to filter cities located in the USA by checking ""City.country"". 3. Ordering Structure: Use ORDER BY on ""City.latitude"" to sort the cities by their latitude. 4. Join Structure: No JOIN is required since all necessary data is within the ""City"" table. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering city names.",1.0
537,What is the maximum and the minimum sale price?,EASY,book_1,[Book.SalePrice],"Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT MAX(Book.SalePrice) AS max_sale_price, MIN(Book.SalePrice) AS min_sale_price FROM Book;","SELECT max(saleprice) ,  min(saleprice) FROM Book","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum sale prices. 2. Aggregation Structure: Use the MAX and MIN functions to calculate the maximum and minimum sale prices, respectively. 3. Join Structure: No JOIN is required since all necessary data is within the ""Book"" table. 4. Condition Structure: No specific filtering condition is needed as we are calculating the overall maximum and minimum sale prices.",1.0
538,Which customers have total order quantity greater than 1? Give me the customer names.,NON-NESTED,restaurant_bills,"[customer.Name, customer_order.Customer_ID, customer_order.Quantity, customer_order.Customer_ID = customer.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
","SELECT customer.Name FROM customer JOIN customer_order ON customer.Customer_ID = customer_order.Customer_ID GROUP BY customer.Customer_ID, customer.Name HAVING SUM(customer_order.Quantity) > 1;",SELECT T1.Name FROM customer AS T1 JOIN customer_order AS T2 ON T1.Customer_ID  =  T2.Customer_ID GROUP BY T1.Name HAVING sum(T2.Quantity)  >  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""customer.Name"" of customers whose total order quantity is greater than 1. 2. Condition Structure: Use a HAVING clause to filter customers whose total order quantity (SUM of ""customer_order.Quantity"") exceeds 1. 3. Join Structure: Use an INNER JOIN to connect the ""customer"" table with the ""customer_order"" table based on the shared key ""customer.Customer_ID = customer_order.Customer_ID."" 4. Aggregation Structure: Use SUM on ""customer_order.Quantity"" to calculate the total order quantity for each customer, then group by ""customer.Customer_ID"" and ""customer.Name"" to aggregate the results.",1.0
539,Give the name of the author who wrote the book titled Pride and Prejudice.,NON-NESTED,book_1,"[Book.Title,Book.ISBN = Author_Book.ISBN,Author_Book.Author,Author.idAuthor = Author_Book.Author,Author.Name,Pride and Prejudice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Author.Name FROM Book JOIN Author_Book ON Book.ISBN = Author_Book.ISBN JOIN Author ON Author.idAuthor = Author_Book.Author WHERE Book.Title = 'Pride and Prejudice';,"SELECT T3.name FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T1.title  =  ""Pride and Prejudice""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Author.Name"" of the author who wrote the book titled ""Pride and Prejudice."" 2. Condition Structure: Use a WHERE clause to filter for the book with the title ""Pride and Prejudice."" 3. Join Structure: Use JOINs to connect the ""Book"" table with the ""Author_Book"" table on ""Book.ISBN = Author_Book.ISBN"" and then connect the ""Author_Book"" table with the ""Author"" table on ""Author.idAuthor = Author_Book.Author"" to link books with their respective authors. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single author's name.",1.0
540,Show different nationalities along with the number of members of each nationality.,EASY,club_leader,"[member.Nationality, member.Member_ID]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
","SELECT member.Nationality, COUNT(member.Member_ID) AS member_count FROM member GROUP BY member.Nationality;","SELECT Nationality ,  COUNT(*) FROM member GROUP BY Nationality","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the nationality and the count of members for each nationality. 2. Aggregation Structure: Use COUNT to calculate the number of members for each nationality. 3. Grouping Structure: Use GROUP BY on ""member.Nationality"" to group the results by each nationality. 4. Join Structure: No JOIN is required since all necessary data is within the ""member"" table.",1.0
541,What is the latitude and longitude for Baltimore?,EASY,address_1,"[City.latitude, City.longitude, City.city_name, Baltimore]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.latitude, City.longitude FROM City WHERE City.city_name = 'Baltimore';","SELECT latitude ,  longitude FROM City WHERE city_name  =  ""Baltimore""","1. Sequential Structure: Start with the SELECT clause to retrieve the latitude and longitude of the city. 2. Condition Structure: Use a WHERE clause to filter for the city name ""Baltimore"". 3. Join Structure: No JOIN is required since all necessary information is in the ""City"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
542,What is the title of the book written by Plato has price lower than the average sale price of all books?,NESTED,book_1,"[Book.Title,Book.SalePrice,Author.Name,Author_Book.ISBN = Book.ISBN,Book.SalePrice,Author.Name = 'Plato']","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book JOIN Author_Book ON Author_Book.ISBN = Book.ISBN JOIN Author ON Author.Name = 'Plato' WHERE Book.SalePrice < (SELECT AVG(SalePrice) FROM Book);,"SELECT T1.title FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T3.name  =  ""Plato"" AND T1.saleprice  <  (SELECT avg(saleprice) FROM Book)","1. Sequential Structure: Start with the SELECT clause to retrieve the title of the book. Use the FROM clause to specify the Book table and JOIN it with the Author_Book table to connect books with their authors. Further, JOIN the Author table to filter books written by Plato. Apply a WHERE clause to filter books with a sale price lower than the average sale price of all books. 2. Condition Structure: Use the WHERE clause to filter for books written by Plato and with a sale price less than the average sale price of all books. The condition for the average sale price is implemented using a subquery. 3. Join Structure: Use INNER JOINs between the Book, Author_Book, and Author tables based on their relationships (ISBN and Name) to connect books with their authors. 4. Aggregation Structure: Use AVG in a subquery to calculate the average sale price of all books, which is then used in the filtering condition.",1.0
543,What is the average sale price of books written by George Orwell?,NON-NESTED,book_1,"[Book.SalePrice,Book.Author,Author.Name,Book.ISBN = Author_Book.ISBN,Author_Book.Author = Author.idAuthor,George Orwell]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT AVG(Book.SalePrice) FROM Book JOIN Author_Book ON Book.ISBN = Author_Book.ISBN JOIN Author ON Author_Book.Author = Author.idAuthor WHERE Author.Name = 'George Orwell';,"SELECT avg(saleprice) FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T3.name  =  ""George Orwell""","1. Sequential Structure: Start with the SELECT clause to calculate the average sale price of books. Use the AVG function on the ""Book.SalePrice"" field. 2. Condition Structure: Use a WHERE clause to filter for books written by ""George Orwell."" This requires filtering based on the author's name. 3. Join Structure: Use JOINs to connect the ""Book"" table with the ""Author_Book"" table on ""Book.ISBN = Author_Book.ISBN"" and the ""Author_Book"" table with the ""Author"" table on ""Author_Book.Author = Author.idAuthor"" to link books with their respective authors. 4. Aggregation Structure: Use the AVG function to calculate the average sale price of the filtered books.",1.0
544,Which collection subset does collection name Best in? List collection subset name.,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name, Collection_Subsets.Collection_Subset_Name, Collection_Subset_Members.Collection_ID = Collections.Collection_ID, Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID, Best]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collection_Subsets.Collection_Subset_Name FROM Collections JOIN Collection_Subset_Members ON Collections.Collection_ID = Collection_Subset_Members.Collection_ID JOIN Collection_Subsets ON Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID WHERE Collections.Collection_Name = 'Best';,"SELECT DISTINCT T1.Collection_Subset_Name FROM Collection_Subsets AS T1 JOIN Collection_Subset_Members AS T2 ON T1.Collection_Subset_ID =  T2.Collection_Subset_ID JOIN Collections AS T3 ON T2.Collection_ID =  T3.Collection_ID WHERE T3.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collection_Subsets.Collection_Subset_Name."" 2. Condition Structure: Use a WHERE clause to filter for the collection name ""Best"" in the ""Collections.Collection_Name"" field. 3. Join Structure: Use JOINs to connect the ""Collections"" table with the ""Collection_Subset_Members"" table on ""Collection_ID"" and then connect ""Collection_Subset_Members"" with the ""Collection_Subsets"" table on ""Collection_Subset_ID."" 4. Aggregation Structure: No aggregation is needed as we are simply listing the subset names.",1.0
545,What are the distinct names of the participants who have sung a song in 'English'?,NON-NESTED,sing_contest,"[participants.name,performance_score.participant_id = participants.id,performance_score.songs_id = songs.id,songs.language,English]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
",SELECT DISTINCT participants.name FROM participants JOIN performance_score ON performance_score.participant_id = participants.id JOIN songs ON performance_score.songs_id = songs.id WHERE songs.language = 'English';,SELECT DISTINCT T1.name FROM participants AS T1 JOIN performance_score AS T2 ON T2.participant_id  =  T1.id JOIN songs AS T3 ON T3.id  =  T2.songs_id WHERE T3.language  =  'English',"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of participants who have sung a song in English. 2. Condition Structure: Use a WHERE clause to filter for records where the ""songs.language"" is 'English.' 3. Join Structure: Use JOINs to connect ""participants"" with ""performance_score"" on ""participants.id = performance_score.participant_id"" and ""performance_score"" with ""songs"" on ""performance_score.songs_id = songs.id"" to link participants with the songs they performed. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique participant names are returned.",1.0
546,List document id of all documents.,EASY,cre_Doc_and_collections,[Document_Objects.Document_Object_ID],"Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Objects.Document_Object_ID FROM Document_Objects;,SELECT Document_Object_ID FROM Document_Objects;,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""Document_Object_ID"". 2. Condition Structure: No specific filtering condition is required as the query asks for all document IDs. 3. Join Structure: No JOIN is required since all necessary information is in the ""Document_Objects"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all document IDs.",1.0
547,What is the parent document of document owned by Marlin? List the document id.,NON-NESTED,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID, Document_Objects.Parent_Document_Object_ID, Document_Objects.Owner, Document_Objects.Document_Object_ID = Document_Subset_Members.Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Objects.Parent_Document_Object_ID, Document_Objects.Document_Object_ID FROM Document_Objects WHERE Document_Objects.Owner = 'Marlin';",SELECT Parent_Document_Object_ID FROM Document_Objects WHERE OWNER  =  'Marlin',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Objects.Parent_Document_Object_ID"" and ""Document_Objects.Document_Object_ID."" 2. Condition Structure: Use a WHERE clause to filter for records where ""Document_Objects.Owner"" is 'Marlin.' 3. Join Structure: No JOIN is required since the necessary information is available within the ""Document_Objects"" table. 4. Aggregation Structure: No aggregation is needed as the query is focused on filtering and retrieving specific fields.",1.0
548,List the titles of books in ascending alphabetical order.,EASY,book_review,[book.Title],"Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT book.Title FROM book ORDER BY book.Title ASC;,SELECT Title FROM book ORDER BY Title ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the book title. 2. Condition Structure: No specific filtering condition is required as we want all book titles. 3. Join Structure: No JOIN is required since all necessary data is within the ""book"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the titles. 5. Ordering Structure: Use ORDER BY in ascending alphabetical order on ""book.Title"".",1.0
549,List the names of members that are not club leaders.,NESTED,club_leader,"[member.Name,member.Member_ID,club_leader.Member_ID = member.Member_ID]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT member.Name FROM member WHERE member.Member_ID NOT IN (SELECT club_leader.Member_ID FROM club_leader);,SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM club_leader),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of members. Use the FROM clause to specify the member table. Apply a WHERE clause to filter out members who are club leaders by ensuring their Member_ID is not present in the club_leader table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude members whose Member_ID appears in the club_leader table. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Member_ID entries in the club_leader table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
550,Count the number of cities in Canada.,EASY,address_1,"[City.city_code, City.country, 'Canada']","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT COUNT(City.city_code) FROM City WHERE City.country = 'Canada';,"SELECT count(*) FROM City WHERE country  =  ""CANADA""","1. Sequential Structure: Start with the SELECT clause to count the number of cities in Canada. 2. Condition Structure: Use a WHERE clause to filter cities where the ""City.country"" is 'Canada'. 3. Join Structure: No JOIN is required since all necessary information is in the ""City"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cities that meet the specified condition.",0.0
551,List the name of all collections.,EASY,cre_Doc_and_collections,[Collections.Collection_Name],"Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collections.Collection_Name FROM Collections;,SELECT Collection_Name FROM Collections;,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""Collection_Name"" from the ""Collections"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for all collection names. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Collections"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all collection names.",1.0
552,Which customers do not have any order? Give me the customer names.,NESTED,restaurant_bills,"[customer.Name, customer.Customer_ID, customer_order.Customer_ID = customer.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT customer.Name FROM customer WHERE customer.Customer_ID NOT IN (SELECT customer_order.Customer_ID FROM customer_order);,SELECT name FROM customer WHERE Customer_ID NOT IN (SELECT Customer_ID FROM customer_order),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of customers. Use the FROM clause to specify the customer table. Apply a WHERE clause to filter customers who do not have any orders by ensuring their Customer_ID is not present in the customer_order table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude customers whose Customer_ID appears in the customer_order table, meaning they have placed orders. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Customer_ID entries in the customer_order table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
553,List all book titles which have the lowest sale price .,NESTED,book_1,"[Book.Title, Book.SalePrice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Title FROM Book WHERE SalePrice = (SELECT MIN(SalePrice) FROM Book);,select title from book order by saleprice asc limit 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of books. Use the FROM clause to specify the Book table. Apply a WHERE clause to filter for books with the lowest sale price. 2. Condition Structure: Use the WHERE clause with a subquery to identify the lowest sale price in the Book table. The subquery calculates the minimum sale price, and the main query filters books with this price. 3. Join Structure: Not required, as all data is in the Book table. 4. Aggregation Structure: Use the MIN function in a subquery to find the lowest sale price, which is then used in the filtering condition.",1.0
554,How many songs listed are not performed?,NESTED,sing_contest,"[songs.id, performance_score.songs_id = songs.id]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
",SELECT COUNT(*) FROM songs WHERE id NOT IN (SELECT songs_id FROM performance_score);,SELECT count(*) FROM songs WHERE id NOT IN ( SELECT songs_id FROM performance_score );,"1. Sequential Structure: Start with the SELECT clause to count the number of songs. Use the FROM clause to specify the songs table. Apply a WHERE clause to filter songs that are not performed by checking if their ID is not present in the performance_score table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude songs whose IDs appear in the performance_score table, indicating they have been performed. 3. Join Structure: Not required, as we only need to filter based on the absence of matching song IDs in the performance_score table. 4. Aggregation Structure: Use COUNT to calculate the total number of songs that are not performed.",1.0
555,"What are the names of all the clients, and the total amount of books ordered by each?",NON-NESTED,book_1,"[Client.Name, Client.IdClient, Orders.IdClient = Client.IdClient, Books_Order.IdOrder = Orders.IdOrder, Books_Order.amount]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Client.Name, SUM(Books_Order.amount) AS TotalBooksOrdered FROM Client JOIN Orders ON Client.IdClient = Orders.IdClient JOIN Books_Order ON Books_Order.IdOrder = Orders.IdOrder GROUP BY Client.Name;","SELECT T2.name ,  sum(T3.amount) FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient JOIN Books_Order AS T3 ON T3.idOrder  =  T1.idOrder GROUP BY T1.idClient","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Client.Name"" and the total amount of books ordered by each client. Use SUM on ""Books_Order.amount"" to calculate the total amount of books ordered. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Client"" table with the ""Orders"" table on ""Client.IdClient = Orders.IdClient"" and the ""Orders"" table with the ""Books_Order"" table on ""Books_Order.IdOrder = Orders.IdOrder."" 4. Aggregation Structure: Use SUM to aggregate the total amount of books ordered for each client and GROUP BY ""Client.Name"" to group the results by client.",1.0
556,Which state has most number of students?,NON-NESTED,address_1,"[Student.city_code, City.state, Student.city_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.state, COUNT(Student.city_code) AS student_count FROM Student JOIN City ON Student.city_code = City.city_code GROUP BY City.state ORDER BY student_count DESC LIMIT 1;",SELECT T1.state FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.state ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.state"" and the count of students. Use COUNT to calculate the number of students in each state. 2. Condition Structure: No specific filtering condition is required, as we are interested in all states. 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to associate each student with their respective state. 4. Aggregation Structure: Use COUNT to count the number of students per state, GROUP BY ""City.state"" to group the results by state, and ORDER BY the count in descending order to find the state with the most students. Use LIMIT 1 to get the state with the highest count.",1.0
557,"How many orders do we have for ""Pride and Prejudice""?",NON-NESTED,book_1,"[Book.Title,Books_Order.IdOrder,Books_Order.ISBN = Book.ISBN,Orders.IdOrder]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT COUNT(Orders.IdOrder) FROM Book JOIN Books_Order ON Books_Order.ISBN = Book.ISBN JOIN Orders ON Books_Order.IdOrder = Orders.IdOrder WHERE Book.Title = 'Pride and Prejudice';,"SELECT count(*) FROM Book AS T1 JOIN Books_Order AS T2 ON T1.isbn  =  T2.isbn WHERE T1.title  =  ""Pride and Prejudice""","1. Sequential Structure: Start with the SELECT clause to count the number of orders for the book ""Pride and Prejudice."" 2. Condition Structure: Use a WHERE clause to filter for the book with the title ""Pride and Prejudice."" 3. Join Structure: Use JOINs to connect the ""Book"" table with the ""Books_Order"" table on ""ISBN"" and then connect the ""Books_Order"" table with the ""Orders"" table on ""IdOrder"" to link the book with its orders. 4. Aggregation Structure: Use COUNT to count the number of orders for the specified book.",1.0
558,What are the ids and names of the participants who have performed at least two songs?,NESTED,sing_contest,"[participants.id, participants.name, performance_score.participant_id = participants.id, performance_score.songs_id]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
","SELECT participants.id, participants.name FROM participants JOIN performance_score ON performance_score.participant_id = participants.id GROUP BY participants.id, participants.name HAVING COUNT(performance_score.songs_id) >= 2;","SELECT T1.id ,  T1.Name FROM participants AS T1 JOIN performance_score AS T2 ON T2.participant_id  =  T1.id GROUP BY T1.id HAVING count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve the IDs and names of participants. Use the FROM clause to specify the participants table and JOIN it with the performance_score table to link participants with their performances. Apply a GROUP BY clause to group records by participant ID and name, and use the HAVING clause to filter participants who have performed at least two songs. 2. Condition Structure: Use the HAVING clause with COUNT(songs_id) to filter participants who have performed two or more songs. 3. Join Structure: Use an INNER JOIN between the participants and performance_score tables based on participant_id to connect participants with their performance records. 4. Aggregation Structure: Use COUNT(songs_id) to count the number of songs performed by each participant and filter based on this count.",1.0
559,Give the country with the fewest number of cities.,NESTED,address_1,"[City.country, City.city_code, Student.city_code = City.city_code, Direct_distance.city1_code = City.city_code, Direct_distance.city2_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.country FROM City GROUP BY City.country ORDER BY COUNT(City.city_code) ASC LIMIT 1;,SELECT country FROM City GROUP BY country ORDER BY count(*) ASC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the country with the fewest number of cities. Use the FROM clause to specify the City table. Apply a GROUP BY clause to group records by country, and use the COUNT function to count the number of cities in each country. Use the ORDER BY clause to sort the results by the count of cities in ascending order, and LIMIT the result to the top entry. 2. Condition Structure: No specific filtering condition is required, as we are interested in all countries and their city counts. 3. Join Structure: Not required, as all the necessary data is available in the City table. 4. Aggregation Structure: Use the COUNT function to calculate the number of cities per country and sort the results to find the country with the fewest cities.",1.0
560,Which states have at least two cities?,NESTED,address_1,"[City.state, City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT state FROM City GROUP BY state HAVING COUNT(city_code) >= 2;,SELECT state FROM City GROUP BY state HAVING count(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct states. Use the FROM clause to specify the City table. Apply a GROUP BY clause to group records by state, and use the HAVING clause to filter states with at least two cities. 2. Condition Structure: Use the HAVING clause with COUNT(city_code) to filter for states that have two or more cities. 3. Join Structure: Not required, as all data is available within the City table. 4. Aggregation Structure: Use COUNT(city_code) to count the number of cities in each state and filter states with at least two cities using the HAVING clause.",1.0
561,How many cities are there in each country?,EASY,address_1,"[City.city_code, City.country]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.country, COUNT(City.city_code) AS city_count FROM City GROUP BY City.country;","SELECT country ,  count(*) FROM City GROUP BY country","1. Sequential Structure: Begin with the SELECT clause to specify the country and the count of cities in each country. 2. Aggregation Structure: Use COUNT to calculate the number of cities for each country. 3. Grouping Structure: Use GROUP BY on ""City.country"" to group the results by each country. 4. Join Structure: No JOIN is required since all necessary data is within the ""City"" table.",1.0
562,How many cities do we have?,EASY,address_1,[City.city_name],"Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT COUNT(City.city_name) AS total_cities FROM City;,SELECT count(*) FROM City,"1. Sequential Structure: Start with the SELECT clause to count the number of cities. 2. Condition Structure: No specific filtering condition is required as we want the total count of all cities. 3. Join Structure: No JOIN is necessary since all required data is within the ""City"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cities.",1.0
563,Show the types of books that have both books with more than 75 chapters and books with less than 50 chapters.,NESTED,book_review,"[book.Type, book.Chapters, book.Book_ID = review.Book_ID, 75, 50]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT DISTINCT book.Type FROM book WHERE book.Type IN ( SELECT book.Type FROM book WHERE book.Chapters > 75 INTERSECT SELECT book.Type FROM book WHERE book.Chapters < 50 );,SELECT TYPE FROM book WHERE Chapters  >  75 INTERSECT SELECT TYPE FROM book WHERE Chapters  <  50,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct types of books. Use the FROM clause to specify the book table. Apply a WHERE clause to filter for books with more than 75 chapters and books with less than 50 chapters. Use a GROUP BY clause to group by book type and a HAVING clause to ensure that each type has books meeting both conditions. 2. Condition Structure: Use the WHERE clause to filter books based on the number of chapters (greater than 75 and less than 50). Use the HAVING clause to ensure that each book type satisfies both conditions. 3. Join Structure: Not required, as all necessary data is in the book table. 4. Aggregation Structure: Use COUNT(*) in the HAVING clause to ensure that each book type has books meeting both conditions.",1.0
564,What are the full names of students living in MD?,NON-NESTED,address_1,"[Student.Fname, Student.LName, Student.city_code = City.city_code, City.state, MD]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Student.Fname || ' ' || Student.LName AS FullName FROM Student JOIN City ON Student.city_code = City.city_code WHERE City.state = 'MD';,"SELECT T2.Fname ,  T2.Lname FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE T1.state  =  ""MD""","1. Sequential Structure: Start with the SELECT clause to retrieve the full names of students, which can be constructed by combining ""Student.Fname"" and ""Student.LName."" 2. Condition Structure: Use a WHERE clause to filter for students living in the state ""MD."" This requires checking the ""City.state"" field for the value ""MD."" 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the shared ""city_code"" field to associate each student with their city information. 4. Aggregation Structure: No aggregation is needed, as the query only retrieves individual student names.",1.0
565,List the names of customers in ascending order of level of membership.,EASY,restaurant_bills,"[customer.Name, customer.Level_of_Membership]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT customer.Name FROM customer ORDER BY customer.Level_of_Membership ASC;,SELECT Name FROM customer ORDER BY Level_of_Membership ASC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""customer.Name"" and ""customer.Level_of_Membership"". 2. Condition Structure: No specific filtering condition is required as we want all customer names. 3. Join Structure: No JOIN is needed since all necessary information is available in the ""customer"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in ascending order based on ""customer.Level_of_Membership"".",1.0
566,What are the different subset names of all documents owned by Braeden?,NON-NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_Name,Document_Objects.Owner,Document_Objects.Document_Object_ID = Document_Subset_Members.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Braeden]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT DISTINCT Document_Subsets.Document_Subset_Name FROM Document_Objects JOIN Document_Subset_Members ON Document_Objects.Document_Object_ID = Document_Subset_Members.Document_Object_ID JOIN Document_Subsets ON Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID WHERE Document_Objects.Owner = 'Braeden';,SELECT DISTINCT T1.Document_Subset_Name FROM Document_Subsets AS T1 JOIN Document_Subset_Members AS T2 ON T1.Document_Subset_ID =  T2.Document_Subset_ID JOIN Document_Objects AS T3 ON T2.Document_Object_ID  =  T3.Document_Object_ID WHERE T3.owner  =  'Braeden',"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Document_Subsets.Document_Subset_Name"" since we are looking for different subset names. 2. Condition Structure: Use a WHERE clause to filter for documents owned by ""Braeden"" in the ""Document_Objects.Owner"" field. 3. Join Structure: Use JOINs to connect the ""Document_Objects"" table with ""Document_Subset_Members"" on ""Document_Object_ID"" and then connect ""Document_Subset_Members"" with ""Document_Subsets"" on ""Document_Subset_ID"" to link documents with their subsets. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique subset names are returned.",1.0
567,What are the names of clients who have ordered Pride and Prejudice?,NON-NESTED,book_1,"[Client.Name,Client.IdClient,Orders.IdClient = Client.IdClient,Orders.IdOrder = Books_Order.IdOrder,Books_Order.ISBN = Book.ISBN,Book.Title,Pride and Prejudice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Client.Name FROM Client JOIN Orders ON Orders.IdClient = Client.IdClient JOIN Books_Order ON Orders.IdOrder = Books_Order.IdOrder JOIN Book ON Books_Order.ISBN = Book.ISBN WHERE Book.Title = 'Pride and Prejudice';,"SELECT T3.name FROM Orders AS T1 JOIN Books_Order AS T2 ON T1.idOrder  =  T2.idOrder JOIN Client AS T3 ON T1.idClient  =  T3.idClient JOIN Book AS T4 ON T4.isbn  =  T2.isbn WHERE T4.title  =  ""Pride and Prejudice""","1. Sequential Structure: Start with the SELECT clause to retrieve the names of clients (""Client.Name""). 2. Condition Structure: Use a WHERE clause to filter for records where the book title is ""Pride and Prejudice."" 3. Join Structure: Use multiple JOINs to connect the relevant tables: - Join ""Client"" with ""Orders"" on ""Orders.IdClient = Client.IdClient"" to associate clients with their orders. - Join ""Orders"" with ""Books_Order"" on ""Orders.IdOrder = Books_Order.IdOrder"" to link orders with the books ordered. - Join ""Books_Order"" with ""Book"" on ""Books_Order.ISBN = Book.ISBN"" to get the book details. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific client names.",1.0
568,What is the name of the oldest member?,EASY,club_leader,"[member.Name, member.Age]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT member.Name FROM member ORDER BY member.Age DESC LIMIT 1;,SELECT Name FROM member ORDER BY Age DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""member.Name"" of the oldest member. 2. Condition Structure: No specific filtering condition is needed since we are looking for the member with the maximum age. 3. Join Structure: No JOIN is required as all necessary information is available in the ""member"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""member.Age"" to rank members by age and apply LIMIT 1 to select the oldest member.",1.0
569,Show all book isbns which were ordered by both client Peter Doe and client James Smith.,NESTED,book_1,"[Client.IdClient, Client.Name, Orders.IdClient = Client.IdClient, Orders.IdOrder, Books_Order.IdOrder = Orders.IdOrder, Books_Order.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT DISTINCT b1.ISBN FROM Books_Order b1 JOIN Orders o1 ON b1.IdOrder = o1.IdOrder JOIN Client c1 ON o1.IdClient = c1.IdClient WHERE c1.Name = 'Peter Doe' AND b1.ISBN IN ( SELECT b2.ISBN FROM Books_Order b2 JOIN Orders o2 ON b2.IdOrder = o2.IdOrder JOIN Client c2 ON o2.IdClient = c2.IdClient WHERE c2.Name = 'James Smith' );,"SELECT T2.isbn FROM Orders AS T1 JOIN Books_Order AS T2 ON T1.idOrder  =  T2.idOrder JOIN Client AS T3 ON T1.idClient  =  T3.idClient WHERE T3.name  =  ""Peter Doe"" INTERSECT SELECT T2.isbn FROM Orders AS T1 JOIN Books_Order AS T2 ON T1.idOrder  =  T2.idOrder JOIN Client AS T3 ON T1.idClient  =  T3.idClient WHERE T3.name  =  ""James Smith""","1. Sequential Structure: Start with the SELECT clause to retrieve the ISBNs of books. Use the FROM clause to specify the relevant tables (Client, Orders, and Books_Order). Apply a WHERE clause to filter for orders made by both clients Peter Doe and James Smith. 2. Condition Structure: Use the WHERE clause to filter for clients named Peter Doe and James Smith. Use a subquery or an intersection to find ISBNs that appear in orders made by both clients. 3. Join Structure: Use JOINs to connect the Client table with the Orders table on IdClient, and the Orders table with the Books_Order table on IdOrder, to link clients to the books they ordered. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
570,Which nationality does the most customers have?,EASY,restaurant_bills,[customer.Nationality],"Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT customer.Nationality FROM customer GROUP BY customer.Nationality ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Nationality FROM customer GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the nationality, as the question asks for the nationality with the most customers. 2. Aggregation Structure: Use COUNT to calculate the number of customers for each nationality. 3. Grouping Structure: Use GROUP BY on ""customer.Nationality"" to group the results by nationality. 4. Ordering Structure: Use ORDER BY in descending order on the count of customers to rank nationalities by the number of customers. 5. Limiting Structure: Use LIMIT 1 to retrieve the nationality with the most customers. 6. Join Structure: No JOIN is required since all necessary data is within the ""customer"" table.",1.0
571,How many customers are associated with each nationality? List the nationality and the number of customers.,EASY,restaurant_bills,"[customer.Nationality, customer.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
","SELECT customer.Nationality, COUNT(customer.Customer_ID) AS customer_count FROM customer GROUP BY customer.Nationality;","SELECT Nationality ,  COUNT(*) FROM customer GROUP BY Nationality","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the nationality and the count of customers. 2. Aggregation Structure: Use COUNT to calculate the number of customers for each nationality. 3. Grouping Structure: Use GROUP BY on ""customer.Nationality"" to group the results by nationality. 4. Join Structure: No JOIN is required since all necessary data is within the ""customer"" table.",1.0
572,What is the name of the client who has ordered the greatest total amount of books?,NON-NESTED,book_1,"[Client.Name, Client.IdClient, Orders.IdClient = Client.IdClient, Orders.IdOrder = Books_Order.IdOrder, Books_Order.amount]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Client.Name FROM Client JOIN Orders ON Client.IdClient = Orders.IdClient JOIN Books_Order ON Orders.IdOrder = Books_Order.IdOrder GROUP BY Client.IdClient ORDER BY SUM(Books_Order.amount) DESC LIMIT 1;,SELECT T2.name FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient JOIN Books_Order AS T3 ON T3.idOrder  =  T1.idOrder GROUP BY T1.idClient ORDER BY sum(T3.amount) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Client.Name"" of the client who has ordered the greatest total amount of books. Use SUM on ""Books_Order.amount"" to calculate the total amount of books ordered by each client. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the client with the greatest total amount of books ordered. 3. Join Structure: Use JOINs to connect the ""Client"" table with the ""Orders"" table on ""Client.IdClient = Orders.IdClient"" and the ""Orders"" table with the ""Books_Order"" table on ""Orders.IdOrder = Books_Order.IdOrder."" 4. Aggregation Structure: Use GROUP BY on ""Client.IdClient"" to calculate the total amount of books ordered for each client. Use ORDER BY in descending order on the total amount and LIMIT 1 to select the client with the greatest total amount.",1.0
573,What is the detail of document subset with name 'Best for 2000'?,EASY,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_Details,Document_Subsets.Document_Subset_Name,'Best for 2000']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Subsets.Document_Subset_Details FROM Document_Subsets WHERE Document_Subsets.Document_Subset_Name = 'Best for 2000';,"SELECT Document_Subset_Details FROM Document_Subsets WHERE Document_Subset_Name = ""Best for 2000"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subsets.Document_Subset_Details"" for the subset with the name 'Best for 2000'. 2. Condition Structure: Use a WHERE clause to filter for the subset where ""Document_Subsets.Document_Subset_Name"" is 'Best for 2000'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Document_Subsets"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a specific detail based on a condition.",1.0
574,What are the nationalities and card credits of customers?,EASY,restaurant_bills,"[customer.Nationality, customer.Card_Credit]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
","SELECT customer.Nationality, customer.Card_Credit FROM customer;","SELECT Nationality ,  Card_Credit FROM customer","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""customer.Nationality"" and ""customer.Card_Credit"". 2. Condition Structure: No specific filtering condition is required as the query asks for all nationalities and card credits of customers. 3. Join Structure: No JOIN is required since all necessary data is within the ""customer"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the specified fields.",1.0
575,What are the document subset names?,EASY,cre_Doc_and_collections,[Document_Subsets.Document_Subset_Name],"Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Subsets.Document_Subset_Name FROM Document_Subsets;,SELECT Document_Subset_Name FROM Document_Subsets;,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subsets.Document_Subset_Name"" field, as the question asks for the names of document subsets. 2. Condition Structure: No specific filtering condition is required since we want all document subset names. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Document_Subsets"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all document subset names.",1.0
576,Show the names of customers and names of dishes they order.,NON-NESTED,restaurant_bills,"[customer.Name, customer_order.Dish_Name, customer.Customer_ID = customer_order.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
","SELECT customer.Name, customer_order.Dish_Name FROM customer JOIN customer_order ON customer.Customer_ID = customer_order.Customer_ID;","SELECT T1.Name ,  T2.Dish_Name FROM customer AS T1 JOIN customer_order AS T2 ON T1.Customer_ID  =  T2.Customer_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""customer.Name"" and ""customer_order.Dish_Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""customer"" and ""customer_order"" tables based on the shared key ""customer.Customer_ID = customer_order.Customer_ID"" to link customers with their orders. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the names of customers and the dishes they ordered.",1.0
577,What are the maximum and minimum number of chapters for each book?,EASY,book_review,"[book.Book_ID, book.Chapters]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
","SELECT book.Book_ID, MAX(book.Chapters) AS max_chapters, MIN(book.Chapters) AS min_chapters FROM book GROUP BY book.Book_ID;","SELECT max(Chapters) ,  min(Chapters) FROM book","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the book ID and the maximum and minimum number of chapters. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum number of chapters for each book. 3. Grouping Structure: Use GROUP BY on ""book.Book_ID"" to calculate these aggregate values for each book. 4. Join Structure: No JOIN is required since all necessary data is within the ""book"" table.",1.0
578,List all states with at least two cities.,NESTED,address_1,"[City.state, City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT state FROM City GROUP BY state HAVING COUNT(city_code) >= 2;,SELECT state FROM City GROUP BY state HAVING count(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct states. Use the FROM clause to specify the City table. Apply a GROUP BY clause to group records by state, and use the HAVING clause to filter states with at least two cities. 2. Condition Structure: Use the HAVING clause with COUNT(city_code) to filter for states that have two or more cities. 3. Join Structure: Not required, as all data is available within the City table. 4. Aggregation Structure: Use COUNT(city_code) to count the number of cities in each state and filter based on this count.",1.0
579,What are the ids of the documents that are not parent documents?,NESTED,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID,Document_Objects.Parent_Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Object_ID FROM Document_Objects WHERE Document_Object_ID NOT IN (SELECT Parent_Document_Object_ID FROM Document_Objects WHERE Parent_Document_Object_ID IS NOT NULL);,SELECT Document_Object_ID FROM Document_Objects EXCEPT SELECT Parent_Document_Object_ID FROM Document_Objects,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of documents. Use the FROM clause to specify the Document_Objects table. Apply a WHERE clause to filter out documents that are parent documents by ensuring that their IDs do not appear in the Parent_Document_Object_ID column. 2. Condition Structure: Use the WHERE clause with a subquery to exclude document IDs that are listed as Parent_Document_Object_ID, meaning they are parent documents. 3. Join Structure: Not required, as all data is within the Document_Objects table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
580,"Show the name of the leader of the club named ""Houston"".",NON-NESTED,club_leader,"[club.Club_Name, club_leader.Member_ID = member.Member_ID, club_leader.Club_ID = club.Club_ID, club.Team_Leader, member.Name, club.Club_Name = ""Houston""]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
","SELECT member.Name FROM club JOIN club_leader ON club.Club_ID = club_leader.Club_ID JOIN member ON club_leader.Member_ID = member.Member_ID WHERE club.Club_Name = ""Houston"";","SELECT T3.Name FROM club_leader AS T1 JOIN club AS T2 ON T1.Club_ID  =  T2.Club_ID JOIN member AS T3 ON T1.Member_ID  =  T3.Member_ID WHERE T2.Club_Name  =  ""Houston""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""member.Name,"" which corresponds to the leader of the club. 2. Condition Structure: Use a WHERE clause to filter for the club with the name ""Houston."" 3. Join Structure: Use JOINs to connect the ""club"" table with the ""club_leader"" table on ""club.Club_ID = club_leader.Club_ID"" and then connect the ""club_leader"" table with the ""member"" table on ""club_leader.Member_ID = member.Member_ID"" to link the club leader to their name. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single leader's name.",1.0
581,Return the sale prices of books authored by Plato.,NON-NESTED,book_1,"[Book.SalePrice,Author.Name,Author_Book.ISBN = Book.ISBN,Author_Book.Author = Author.idAuthor,Plato]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.SalePrice FROM Book JOIN Author_Book ON Book.ISBN = Author_Book.ISBN JOIN Author ON Author_Book.Author = Author.idAuthor WHERE Author.Name = 'Plato';,"SELECT saleprice FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T3.name  =  ""Plato""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Book.SalePrice"" field, as the question asks for the sale prices of books. 2. Condition Structure: Use a WHERE clause to filter for books authored by ""Plato."" This requires filtering on the ""Author.Name"" field. 3. Join Structure: Use JOINs to connect the ""Book"" table with the ""Author_Book"" table on ""Book.ISBN = Author_Book.ISBN"" and the ""Author_Book"" table with the ""Author"" table on ""Author_Book.Author = Author.idAuthor"" to link books with their respective authors. 4. Aggregation Structure: No aggregation is needed, as the question only asks for the sale prices of books authored by Plato.",1.0
582,Count the number of coutries.,EASY,address_1,[City.country],"Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT COUNT(DISTINCT City.country) AS country_count FROM City;,SELECT count(DISTINCT country) FROM City,"1. Sequential Structure: Start with the SELECT clause to count the number of countries. 2. Aggregation Structure: Use COUNT with DISTINCT to count unique countries. 3. Join Structure: No JOIN is required since the information is available in the ""City"" table. 4. Condition Structure: No specific filtering condition is needed as we are counting all unique countries.",1.0
583,What are the ids of the dcouments that have between 2 and 4 related documents and how many related items are there?,NON-NESTED,cre_Doc_and_collections,"[Document_Subset_Members.Document_Object_ID, Document_Subset_Members.Related_Document_Object_ID, Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Subset_Members.Document_Object_ID, COUNT(Document_Subset_Members.Related_Document_Object_ID) AS Related_Items_Count FROM Document_Subset_Members GROUP BY Document_Subset_Members.Document_Object_ID HAVING COUNT(Document_Subset_Members.Related_Document_Object_ID) BETWEEN 2 AND 4;","SELECT Document_Object_ID , count(*) FROM Document_Subset_Members GROUP BY Document_Object_ID HAVING count(*) BETWEEN 2 AND 4;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subset_Members.Document_Object_ID"" and the count of related documents. Use COUNT to calculate the number of related documents for each document. 2. Condition Structure: Apply a HAVING clause to filter for documents that have between 2 and 4 related documents (inclusive). 3. Join Structure: No JOIN is necessary as all the required data is available in the ""Document_Subset_Members"" table. 4. Aggregation Structure: Use COUNT on ""Document_Subset_Members.Related_Document_Object_ID"" to count the number of related documents for each ""Document_Subset_Members.Document_Object_ID,"" and group the results by ""Document_Subset_Members.Document_Object_ID.""",1.0
584,"What are all isbns for each book, and how many times has each been ordered?",NON-NESTED,book_1,"[Book.ISBN, Books_Order.ISBN, Books_Order.IdOrder, Books_Order.amount]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Book.ISBN, COUNT(Books_Order.IdOrder) AS order_count FROM Book JOIN Books_Order ON Book.ISBN = Books_Order.ISBN GROUP BY Book.ISBN;","SELECT isbn ,  count(*) FROM Books_Order GROUP BY isbn","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Book.ISBN"" and the count of how many times each ISBN has been ordered. Use COUNT on ""Books_Order.IdOrder"" to count the number of orders for each ISBN. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Book"" and ""Books_Order"" tables based on the ""ISBN"" field to link each book with its order records. 4. Aggregation Structure: Use COUNT to count the number of orders for each ISBN and GROUP BY ""Book.ISBN"" to group the results by each book's ISBN.",1.0
585,List all different states .,EASY,address_1,[City.state],"Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT DISTINCT City.state FROM City;,select distinct state from city,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct states from the ""City"" table. 2. Condition Structure: No specific filtering condition is required as we want all distinct states. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""City"" table. 4. Aggregation Structure: Use DISTINCT to ensure only unique states are retrieved.",1.0
586,What are the ids of the documents that have more than one child?,NON-NESTED,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID, Document_Subset_Members.Document_Object_ID, Document_Subset_Members.Related_Document_Object_ID, Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Subset_Members.Document_Object_ID FROM Document_Subset_Members GROUP BY Document_Subset_Members.Document_Object_ID HAVING COUNT(Document_Subset_Members.Related_Document_Object_ID) > 1;,SELECT T2.Document_Object_ID FROM Document_Objects AS T1 JOIN Document_Objects AS T2 ON T1.Parent_Document_Object_ID = T2.Document_Object_ID GROUP BY T2.Document_Object_ID HAVING count(*)  >  1;,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subset_Members.Document_Object_ID"" for documents that have more than one child. Use GROUP BY to group by ""Document_Subset_Members.Document_Object_ID"" and HAVING to filter groups with more than one child. 2. Condition Structure: Use a HAVING clause to filter for documents where the count of ""Related_Document_Object_ID"" is greater than one. 3. Join Structure: No JOIN is required as all necessary data is available in the ""Document_Subset_Members"" table. 4. Aggregation Structure: Use COUNT on ""Related_Document_Object_ID"" to count the number of children for each document, and filter with HAVING to select documents with more than one child.",1.0
587,Please show the most common nationality of members.,EASY,club_leader,[member.Nationality],"Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT member.Nationality FROM member GROUP BY member.Nationality ORDER BY COUNT(*) DESC LIMIT 1;,"SELECT Nationality ,  COUNT(*) FROM member GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1","1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the nationality of members. 2. Aggregation Structure: Use COUNT to determine the frequency of each nationality among members. 3. Grouping Structure: Use GROUP BY on ""member.Nationality"" to aggregate the results by each nationality. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank nationalities by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common nationality. 6. Join Structure: No JOIN is required since all necessary data is within the ""member"" table.",0.0
588,How many child collection does the collection named Best has?,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name, Collections.Collection_ID, Collection_Subset_Members.Collection_ID, Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID, Best]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT COUNT(Collection_Subset_Members.Related_Collection_ID) FROM Collections JOIN Collection_Subset_Members ON Collections.Collection_ID = Collection_Subset_Members.Collection_ID WHERE Collections.Collection_Name = 'Best';,"SELECT count(*) FROM Collections AS T1 JOIN Collections AS T2 ON T1.Parent_Collection_ID = T2.Collection_ID WHERE T2.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to count the number of child collections related to the collection named ""Best."" Use COUNT on the ""Collection_Subset_Members.Related_Collection_ID"" field. 2. Condition Structure: Use a WHERE clause to filter for the collection named ""Best"" by matching ""Collections.Collection_Name"" to ""Best."" 3. Join Structure: Use a JOIN between the ""Collections"" table and the ""Collection_Subset_Members"" table. The JOIN is based on ""Collections.Collection_ID"" and ""Collection_Subset_Members.Collection_ID"" to link collections with their subsets. 4. Aggregation Structure: Use COUNT to aggregate the number of child collections related to the ""Best"" collection.",1.0
589,What are the collection descriptions that are named as 'Best'?,EASY,cre_Doc_and_collections,"[Collections.Collection_Description,Collections.Collection_Name,'Best']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collections.Collection_Description FROM Collections WHERE Collections.Collection_Name = 'Best';,"SELECT Collection_Description FROM Collections WHERE Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collections.Collection_Description"" for collections named 'Best'. 2. Condition Structure: Use a WHERE clause to filter for rows where ""Collections.Collection_Name"" is equal to 'Best'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Collections"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific descriptions based on a condition.",1.0
590,What is the average card credit of customers with membership level higher than 1?,EASY,restaurant_bills,"[customer.Card_Credit, customer.Level_of_Membership]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT AVG(customer.Card_Credit) AS avg_card_credit FROM customer WHERE customer.Level_of_Membership > 1;,SELECT avg(Card_Credit) FROM customer WHERE Level_of_Membership  >  1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average card credit. 2. Condition Structure: Use a WHERE clause to filter customers with a membership level higher than 1. 3. Aggregation Structure: Use the AVG function to calculate the average card credit for the filtered customers. 4. Join Structure: No JOIN is required since all necessary data is within the ""customer"" table.",1.0
591,What are the types of books that have at least three books belonging to?,NON-NESTED,book_review,"[book.Type, book.Book_ID, review.Book_ID = book.Book_ID]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT book.Type FROM book GROUP BY book.Type HAVING COUNT(book.Book_ID) >= 3;,SELECT TYPE FROM book GROUP BY TYPE HAVING COUNT(*)  >=  3,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""book.Type"" field. Use GROUP BY to group the results by ""book.Type."" 2. Condition Structure: Use a HAVING clause to filter for types of books that have at least three books. This will be determined by counting the number of ""book.Book_ID"" for each type. 3. Join Structure: No JOIN is necessary since all the required information is available in the ""book"" table. 4. Aggregation Structure: Use COUNT on ""book.Book_ID"" to count the number of books for each type, and apply the HAVING clause to filter for counts greater than or equal to 3.",1.0
592,How many books are there?,EASY,book_review,[book.Book_ID],"Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT COUNT(book.Book_ID) AS total_books FROM book;,SELECT count(*) FROM book,"1. Sequential Structure: Start with the SELECT clause to count the total number of books. 2. Aggregation Structure: Use the COUNT function on the ""book.Book_ID"" field to calculate the total number of books. 3. Condition Structure: No specific filtering condition is required as we want the total count of all books. 4. Join Structure: No JOIN is necessary since all required information is in the ""book"" table.",1.0
593,Show the nations that have both members older than 22 and members younger than 19.,NESTED,club_leader,"[member.Nationality, member.Age]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT Nationality FROM member WHERE Age > 22 OR Age < 19 GROUP BY Nationality HAVING COUNT(CASE WHEN Age > 22 THEN 1 END) > 0 AND COUNT(CASE WHEN Age < 19 THEN 1 END) > 0;,SELECT Nationality FROM member WHERE Age  >  22 INTERSECT SELECT Nationality FROM member WHERE Age  <  19,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct nationalities of members. Use the FROM clause to specify the member table. Apply a WHERE clause to filter for members older than 22 and members younger than 19. Use GROUP BY to group by nationality and HAVING to ensure that each nationality has members satisfying both conditions. 2. Condition Structure: Use the WHERE clause to filter members based on age (older than 22 or younger than 19). Then, use the HAVING clause to ensure that each nationality has at least one member older than 22 and one member younger than 19. 3. Join Structure: Not required, as all data is in the member table. 4. Aggregation Structure: Use COUNT with conditional logic in the HAVING clause to ensure both conditions (older than 22 and younger than 19) are met for each nationality.",1.0
594,What is the title of the book written by George Orwell that has the lowest sale price?,NON-NESTED,book_1,"[Book.Title,Book.SalePrice,Book.Author,Author.Name,Author.idAuthor = Book.Author,George Orwell]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book JOIN Author ON Author.idAuthor = Book.Author WHERE Author.Name = 'George Orwell' ORDER BY Book.SalePrice ASC LIMIT 1;,"SELECT T1.title FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T3.name  =  ""George Orwell"" ORDER BY T1.saleprice LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Book.Title"" of the book with the lowest sale price written by George Orwell. 2. Condition Structure: Use a WHERE clause to filter for books written by George Orwell. This requires matching the ""Author.Name"" to ""George Orwell."" 3. Join Structure: Use a JOIN between the ""Book"" and ""Author"" tables based on the relationship ""Author.idAuthor = Book.Author"" to associate books with their respective authors. 4. Aggregation Structure: Use ORDER BY on ""Book.SalePrice"" in ascending order to find the book with the lowest sale price. Use LIMIT 1 to select only the book with the lowest price.",0.0
595,"What is the subset id, name, and number of different documents for each subset?",NON-NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name, Document_Subset_Members.Document_Object_ID, Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name, COUNT(DISTINCT Document_Subset_Members.Document_Object_ID) AS Number_of_Documents FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID GROUP BY Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name;","SELECT T1.Document_Subset_ID ,  T2.Document_Subset_Name , count(DISTINCT T1.Document_Object_ID) FROM Document_Subset_Members AS T1 JOIN Document_Subsets AS T2 ON T1.Document_Subset_ID =  T2.Document_Subset_ID GROUP BY T1.Document_Subset_ID;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subsets.Document_Subset_ID,"" ""Document_Subsets.Document_Subset_Name,"" and the count of distinct ""Document_Subset_Members.Document_Object_ID"" for each subset. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect ""Document_Subsets"" with ""Document_Subset_Members"" on ""Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID"" to link subsets with their respective documents. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Document_Subset_Members.Document_Object_ID"" to count the number of different documents for each subset, and GROUP BY ""Document_Subsets.Document_Subset_ID"" and ""Document_Subsets.Document_Subset_Name"" to group results by each subset.",1.0
596,"What are the ids, names and popularity of the participants, order by the number of songs they perform?",NON-NESTED,sing_contest,"[participants.id, participants.name, participants.popularity, performance_score.participant_id, performance_score.songs_id = songs.id]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
","SELECT participants.id, participants.name, participants.popularity, COUNT(performance_score.songs_id) AS song_count FROM participants JOIN performance_score ON participants.id = performance_score.participant_id JOIN songs ON performance_score.songs_id = songs.id GROUP BY participants.id, participants.name, participants.popularity ORDER BY song_count DESC;","SELECT T1.id ,  T1.Name ,  T1.popularity FROM participants AS T1 JOIN performance_score AS T2 ON T2.participant_id  =  T1.id GROUP BY T1.id ORDER BY count(*)","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""participants.id,"" ""participants.name,"" and ""participants.popularity."" Additionally, count the number of songs each participant performs using COUNT on ""performance_score.songs_id."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between ""participants"" and ""performance_score"" on ""participants.id = performance_score.participant_id"" to link participants with their performances. Also, join ""performance_score"" with ""songs"" on ""performance_score.songs_id = songs.id"" to ensure the songs are correctly associated. 4. Aggregation Structure: Use COUNT to calculate the number of songs performed by each participant. Group the results by ""participants.id"" to ensure the count is calculated per participant. Finally, use ORDER BY to sort the results by the number of songs performed in descending order.",1.0
597,"For each document object id, how many children do they have?",NON-NESTED,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID,Document_Objects.Document_Object_ID = Document_Subset_Members.Related_Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Objects.Document_Object_ID, COUNT(Document_Subset_Members.Document_Object_ID) AS Number_of_Children FROM Document_Objects JOIN Document_Subset_Members ON Document_Objects.Document_Object_ID = Document_Subset_Members.Related_Document_Object_ID GROUP BY Document_Objects.Document_Object_ID;","SELECT T2.Document_Object_ID ,  count(*) FROM Document_Objects AS T1 JOIN Document_Objects AS T2 ON T1.Parent_Document_Object_ID = T2.Document_Object_ID GROUP BY T2.Document_Object_ID ORDER BY count(*) DESC LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve ""Document_Objects.Document_Object_ID"" and the count of its children. Use COUNT to count the number of related document object IDs for each document object ID. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between ""Document_Objects"" and ""Document_Subset_Members"" tables based on the relationship ""Document_Objects.Document_Object_ID = Document_Subset_Members.Related_Document_Object_ID"" to link each document object with its children. 4. Aggregation Structure: Use COUNT to count the number of children for each document object ID and GROUP BY ""Document_Objects.Document_Object_ID"" to group the results by each document object ID.",1.0
598,Show all states where more than 5 students live.,NON-NESTED,address_1,"[Student.city_code, City.state, Student.city_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.state FROM Student JOIN City ON Student.city_code = City.city_code GROUP BY City.state HAVING COUNT(Student.city_code) > 5;,SELECT T1.state FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.state HAVING count(*)  >  5,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""City.state"" where more than 5 students live. 2. Condition Structure: Use a HAVING clause to filter states where the count of students exceeds 5. 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on ""Student.city_code = City.city_code"" to associate students with their respective states. 4. Aggregation Structure: Use COUNT on ""Student.city_code"" to count the number of students in each state, then filter with HAVING to select states with more than 5 students.",1.0
599,Return the largest difference in sale price and purchase price.,EASY,book_1,"[Book.SalePrice, Book.PurchasePrice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT MAX(Book.SalePrice - Book.PurchasePrice) AS max_difference FROM Book;,SELECT max(saleprice - purchaseprice) FROM Book,"1. Sequential Structure: Begin with the SELECT clause to calculate the largest difference between the sale price and purchase price. 2. Aggregation Structure: Use the MAX function to find the maximum difference between ""Book.SalePrice"" and ""Book.PurchasePrice"". 3. Condition Structure: No specific filtering condition is required as we are calculating the largest difference across all records. 4. Join Structure: No JOIN is required since all necessary data is within the ""Book"" table.",1.0
600,Which nations have both customers with card credit above 50 and customers with card credit below 75.,NESTED,restaurant_bills,"[customer.Nationality, customer.Card_Credit, customer.Customer_ID = customer_order.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT Nationality FROM customer WHERE Card_Credit > 50 OR Card_Credit < 75 GROUP BY Nationality HAVING SUM(Card_Credit > 50) > 0 AND SUM(Card_Credit < 75) > 0;,SELECT Nationality FROM customer WHERE Card_Credit  <  50 INTERSECT SELECT Nationality FROM customer WHERE Card_Credit  >  75,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct nationalities of customers. Use the FROM clause to specify the customer table. Apply a WHERE clause to filter customers with card credit above 50 and customers with card credit below 75. Use GROUP BY to group by nationality and HAVING to ensure that both conditions are satisfied for each nationality. 2. Condition Structure: Use the WHERE clause to filter customers based on card credit values (above 50 and below 75). Use the HAVING clause to ensure that both conditions are met for each nationality. 3. Join Structure: No JOIN is required, as all necessary data is available in the customer table. 4. Aggregation Structure: Use COUNT or conditional checks in the HAVING clause to ensure that each nationality has customers satisfying both conditions.",1.0
601,List all documents ids that are not the parent of other documents.,NESTED,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID,Document_Objects.Parent_Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Object_ID FROM Document_Objects WHERE Document_Object_ID NOT IN (SELECT Parent_Document_Object_ID FROM Document_Objects WHERE Parent_Document_Object_ID IS NOT NULL);,SELECT Document_Object_ID FROM Document_Objects EXCEPT SELECT Parent_Document_Object_ID FROM Document_Objects,"1. Sequential Structure: Start with the SELECT clause to retrieve the document IDs. Use the FROM clause to specify the Document_Objects table. Apply a WHERE clause to filter for document IDs that are not listed as Parent_Document_Object_ID in the table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude document IDs that appear as Parent_Document_Object_ID in the Document_Objects table. 3. Join Structure: Not required, as all data is within the same table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
602,List id of documents that in document subset Best for 2000 or in collection named Best.,NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_ID,Document_Subsets.Document_Subset_Name,Document_Subset_Members.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Collections.Collection_Name,Documents_in_Collections.Document_Object_ID,Documents_in_Collections.Collection_ID = Collections.Collection_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT DISTINCT Document_Subset_Members.Document_Object_ID FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID WHERE Document_Subsets.Document_Subset_Name = 'Best for 2000' UNION SELECT DISTINCT Documents_in_Collections.Document_Object_ID FROM Collections JOIN Documents_in_Collections ON Documents_in_Collections.Collection_ID = Collections.Collection_ID WHERE Collections.Collection_Name = 'Best';,"SELECT DISTINCT T1.Document_Object_ID FROM Document_Subset_Members AS T1 JOIN Document_Subsets AS T2 ON T1.Document_Subset_ID =  T2.Document_Subset_ID JOIN Documents_in_Collections AS T3 ON T1.Document_Object_ID  =  T3.Document_Object_ID JOIN Collections AS T4 ON T3.Collection_ID  =  T4.Collection_ID WHERE T2.Document_Subset_Name = ""Best for 2000"" OR T4.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of documents. Use the FROM clause to specify the relevant tables: Document_Subsets, Document_Subset_Members, Collections, and Documents_in_Collections. Apply a WHERE clause to filter for documents that are either in the subset named ""Best for 2000"" or in the collection named ""Best"". 2. Condition Structure: Use the WHERE clause to filter for documents that belong to the subset ""Best for 2000"" by matching the subset name in the Document_Subsets table. Similarly, filter for documents in the collection named ""Best"" by matching the collection name in the Collections table. Combine these conditions using the OR operator. 3. Join Structure: Use JOINs to connect the Document_Subsets table with the Document_Subset_Members table based on the subset ID, and the Collections table with the Documents_in_Collections table based on the collection ID. This ensures we can filter documents based on both subsets and collections. 4. Aggregation Structure: Not required, as we are retrieving specific document IDs without any aggregation.",1.0
603,Show the names of clients who have ordered at least once.,NON-NESTED,book_1,"[Client.Name, Client.IdClient, Orders.IdClient = Client.IdClient]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT DISTINCT Client.Name FROM Client JOIN Orders ON Client.IdClient = Orders.IdClient;,SELECT DISTINCT T1.name FROM Client AS T1 JOIN Orders AS T2 ON T1.idClient  =  T2.idClient,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of clients who have placed at least one order. 2. Condition Structure: No specific filtering condition is needed, as we are interested in clients who have any associated orders. 3. Join Structure: Use a JOIN between the ""Client"" and ""Orders"" tables based on the ""IdClient"" field to link clients with their orders. 4. Aggregation Structure: Use DISTINCT to ensure that each client name is listed only once.",1.0
604,Who are the distinct managers of branches?,EASY,restaurant_bills,[branch.Manager],"Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT DISTINCT branch.Manager FROM branch;,SELECT DISTINCT Manager FROM branch,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct managers of branches. 2. Condition Structure: No specific filtering condition is required as we want all distinct managers. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""branch"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique managers are retrieved.",1.0
605,Which collection is not the parent of other collection? List the collection's name.,NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID,Collections.Parent_Collection_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collection_Name FROM Collections WHERE Collection_ID NOT IN (SELECT Parent_Collection_ID FROM Collections WHERE Parent_Collection_ID IS NOT NULL);,SELECT Collection_Name FROM Collections EXCEPT SELECT T2.Collection_Name FROM Collections AS T1 JOIN Collections AS T2 ON T1.Parent_Collection_ID = T2.Collection_ID;,"1. Sequential Structure: Start with the SELECT clause to retrieve the collection name. Use the FROM clause to specify the Collections table. Apply a WHERE clause to filter collections that are not the parent of any other collection. 2. Condition Structure: Use the WHERE clause to check for collections whose Collection_ID does not appear as a Parent_Collection_ID in the Collections table. 3. Join Structure: Not required, as all data is within the Collections table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
606,What are the names and nationalities of the members?,EASY,club_leader,"[member.Name, member.Nationality]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
","SELECT member.Name, member.Nationality FROM member;","SELECT Name ,  Nationality FROM member","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""member.Name"" and ""member.Nationality"". 2. Condition Structure: No specific filtering condition is required as the query asks for all members' names and nationalities. 3. Join Structure: No JOIN is required since all necessary information is available in the ""member"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and nationalities of all members.",1.0
607,What is the number of child collections belonging to the collection named Best?,NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID,Collections.Parent_Collection_ID = Collections.Collection_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT COUNT(*) AS number_of_child_collections FROM Collections WHERE Parent_Collection_ID = (SELECT Collection_ID FROM Collections WHERE Collection_Name = 'Best');,"SELECT count(*) FROM Collections AS T1 JOIN Collections AS T2 ON T1.Parent_Collection_ID = T2.Collection_ID WHERE T2.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to count the number of child collections. Use the FROM clause to specify the Collections table. Apply a WHERE clause to filter for child collections whose Parent_Collection_ID matches the Collection_ID of the collection named 'Best'. 2. Condition Structure: Use the WHERE clause to filter for records where the Parent_Collection_ID corresponds to the Collection_ID of the collection named 'Best'. 3. Join Structure: Not required, as all data is within the same Collections table. 4. Aggregation Structure: Use the COUNT function to count the number of child collections that meet the specified condition.",1.0
608,What are the average rhythm scores for the songs in each different language?,NON-NESTED,sing_contest,"[songs.language, performance_score.rhythm_tempo, performance_score.songs_id = songs.id]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
","SELECT songs.language, AVG(performance_score.rhythm_tempo) AS average_rhythm_score FROM songs JOIN performance_score ON performance_score.songs_id = songs.id GROUP BY songs.language;","SELECT avg(T2.rhythm_tempo) ,  T1.language FROM songs AS T1 JOIN performance_score AS T2 ON T2.songs_id  =  T1.id GROUP BY T1.language","1. Sequential Structure: Start with the SELECT clause to retrieve the ""songs.language"" and the average rhythm scores. Use the AVG function on ""performance_score.rhythm_tempo"" to calculate the average rhythm scores for each language. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""songs"" table and the ""performance_score"" table based on the relationship ""performance_score.songs_id = songs.id"" to link each song with its performance scores. 4. Aggregation Structure: Use AVG to calculate the average rhythm scores and GROUP BY ""songs.language"" to group the results by each language.",1.0
609,What are the different document ids that are in the subset named 'Best for 2000' or in the collection named 'Best'?,NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_Name,Document_Subsets.Document_Subset_ID,Document_Subset_Members.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Collections.Collection_Name,Collections.Collection_ID,Documents_in_Collections.Document_Object_ID,Documents_in_Collections.Collection_ID = Collections.Collection_ID,'Best for 2000','Best']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT DISTINCT Document_Subset_Members.Document_Object_ID FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subsets.Document_Subset_ID = Document_Subset_Members.Document_Subset_ID WHERE Document_Subsets.Document_Subset_Name = 'Best for 2000' UNION SELECT DISTINCT Documents_in_Collections.Document_Object_ID FROM Collections JOIN Documents_in_Collections ON Collections.Collection_ID = Documents_in_Collections.Collection_ID WHERE Collections.Collection_Name = 'Best';,"SELECT DISTINCT T1.Document_Object_ID FROM Document_Subset_Members AS T1 JOIN Document_Subsets AS T2 ON T1.Document_Subset_ID =  T2.Document_Subset_ID JOIN Documents_in_Collections AS T3 ON T1.Document_Object_ID  =  T3.Document_Object_ID JOIN Collections AS T4 ON T3.Collection_ID  =  T4.Collection_ID WHERE T2.Document_Subset_Name = ""Best for 2000"" OR T4.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to retrieve distinct document IDs. Use the FROM clause to specify the relevant tables: Document_Subsets, Document_Subset_Members, Collections, and Documents_in_Collections. Use UNION to combine results from two conditions: document IDs in the subset named 'Best for 2000' and document IDs in the collection named 'Best'. 2. Condition Structure: Use WHERE clauses to filter for the subset named 'Best for 2000' in the Document_Subsets table and for the collection named 'Best' in the Collections table. 3. Join Structure: Use INNER JOINs to connect Document_Subsets with Document_Subset_Members on Document_Subset_ID, and Collections with Documents_in_Collections on Collection_ID, to retrieve document IDs based on the subset or collection. 4. Aggregation Structure: Not required, as we are retrieving distinct document IDs without any aggregation.",1.0
610,How many documents does collection named 'Best' has?,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID,Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT COUNT(Documents_in_Collections.Document_Object_ID) FROM Collections JOIN Documents_in_Collections ON Collections.Collection_ID = Documents_in_Collections.Collection_ID WHERE Collections.Collection_Name = 'Best';,"SELECT count(*) FROM Collections AS T1 JOIN Documents_in_Collections AS T2 ON T1.Collection_ID = T2.Collection_ID WHERE T1.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to count the number of documents in the collection. Use COUNT on ""Documents_in_Collections.Document_Object_ID"" to get the total number of documents. 2. Condition Structure: Use a WHERE clause to filter for the collection named ""Best"" by matching ""Collections.Collection_Name."" 3. Join Structure: Use a JOIN between the ""Collections"" table and the ""Documents_in_Collections"" table based on ""Collection_ID"" to link collections with their documents. 4. Aggregation Structure: Use COUNT to aggregate the total number of documents for the specified collection.",1.0
611,Give the average sale price of books authored by George Orwell.,NON-NESTED,book_1,"[Book.SalePrice,Author.Name,Author_Book.ISBN = Book.ISBN,Author_Book.Author = Author.idAuthor,George Orwell]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT AVG(Book.SalePrice) FROM Book JOIN Author_Book ON Book.ISBN = Author_Book.ISBN JOIN Author ON Author_Book.Author = Author.idAuthor WHERE Author.Name = 'George Orwell';,"SELECT avg(saleprice) FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T3.name  =  ""George Orwell""","1. Sequential Structure: Start with the SELECT clause to calculate the average sale price of books authored by George Orwell using the AVG function on ""Book.SalePrice."" 2. Condition Structure: Use a WHERE clause to filter for books authored by George Orwell. This requires identifying the author through the ""Author.Name"" field. 3. Join Structure: Use JOINs to connect the ""Book"" table with the ""Author_Book"" table on ""Book.ISBN = Author_Book.ISBN"" and the ""Author_Book"" table with the ""Author"" table on ""Author_Book.Author = Author.idAuthor."" 4. Aggregation Structure: Use the AVG function to compute the average sale price of the filtered books.",1.0
612,What are the names of clients who have never made an order?,NESTED,book_1,"[Client.IdClient, Orders.IdClient, Client.Name]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Client.Name FROM Client WHERE Client.IdClient NOT IN (SELECT Orders.IdClient FROM Orders);,SELECT name FROM Client EXCEPT SELECT T1.name FROM Client AS T1 JOIN Orders AS T2 ON T1.idClient  =  T2.idClient,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of clients. Use the FROM clause to specify the Client table. Apply a WHERE clause to filter clients who have never made an order by ensuring their IdClient is not present in the Orders table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude clients whose IdClient appears in the Orders table, meaning they have made an order. 3. Join Structure: Not required, as we only need to filter based on the absence of matching IdClient entries in the Orders table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
613,What is the average age of all the club leaders?,NON-NESTED,club_leader,"[member.Age, club_leader.Member_ID = member.Member_ID]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT AVG(member.Age) FROM club_leader JOIN member ON club_leader.Member_ID = member.Member_ID;,SELECT avg(T2.age) FROM club_leader AS T1 JOIN member AS T2 ON T1.member_id  =  T2.member_id,"1. Sequential Structure: Start with the SELECT clause to calculate the average age of club leaders using the AVG function on the ""member.Age"" field. 2. Condition Structure: No specific filtering condition is needed, as we are calculating the average age of all club leaders. 3. Join Structure: Use a JOIN between the ""club_leader"" and ""member"" tables based on the ""Member_ID"" field to link club leaders with their corresponding member details. 4. Aggregation Structure: Use the AVG function to compute the average age of the club leaders.",1.0
614,"Find the original artists who sing songs with rhythm tempo above 5 , and list results in descending order of voice sound quality .",NON-NESTED,sing_contest,"[songs.original_artist,performance_score.rhythm_tempo,performance_score.voice_sound_quality,performance_score.songs_id = songs.id]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
","SELECT songs.original_artist, performance_score.voice_sound_quality FROM songs JOIN performance_score ON performance_score.songs_id = songs.id WHERE performance_score.rhythm_tempo > 5 ORDER BY performance_score.voice_sound_quality DESC;",select t2.original_artist from performance_score as t1 join songs as t2 on t2.id  =  t1.songs_id where t1.rhythm_tempo  >  5 order by t1.voice_sound_quality desc,"1. Sequential Structure: Start with the SELECT clause to retrieve ""songs.original_artist"" and ""performance_score.voice_sound_quality."" 2. Condition Structure: Use a WHERE clause to filter for records where ""performance_score.rhythm_tempo"" is greater than 5. 3. Join Structure: Use a JOIN between the ""songs"" and ""performance_score"" tables based on ""performance_score.songs_id = songs.id"" to link each song with its performance score. 4. Aggregation Structure: No aggregation is needed, but apply ORDER BY in descending order on ""performance_score.voice_sound_quality"" to rank results by voice sound quality.",1.0
615,Find the nationality and card credit of each customer.,EASY,restaurant_bills,"[customer.Nationality, customer.Card_Credit]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
","SELECT customer.Nationality, customer.Card_Credit FROM customer;","SELECT Nationality ,  Card_Credit FROM customer","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""customer.Nationality"" and ""customer.Card_Credit"". 2. Condition Structure: No specific filtering condition is required as the query asks for all customers' nationalities and card credits. 3. Join Structure: No JOIN is required since all necessary data is within the ""customer"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the specified fields for all customers.",1.0
616,How many members are there?,EASY,club_leader,[member.Member_ID],"Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT COUNT(member.Member_ID) AS total_members FROM member;,SELECT count(*) FROM member,"1. Sequential Structure: Begin with the SELECT clause to count the number of members. 2. Aggregation Structure: Use the COUNT function to calculate the total number of members based on the ""member.Member_ID"" field. 3. Condition Structure: No specific filtering condition is required as we want the total count of all members. 4. Join Structure: No JOIN is necessary since all required data is within the ""member"" table.",1.0
617,What are the first names and majors of students living in Baltimore?,NON-NESTED,address_1,"[Student.Fname, Student.Major, Student.city_code = City.city_code, City.city_name, Baltimore]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT Student.Fname, Student.Major FROM Student JOIN City ON Student.city_code = City.city_code WHERE City.city_name = 'Baltimore';","SELECT T2.Fname ,  T2.Major FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE T1.city_name  =  ""Baltimore""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Student.Fname"" and ""Student.Major."" 2. Condition Structure: Use a WHERE clause to filter for students living in Baltimore. This requires matching the ""Student.city_code"" with ""City.city_code"" and filtering for ""City.city_name = 'Baltimore'."" 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to associate students with their respective cities. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields for students living in Baltimore.",1.0
618,What is the owner of document with the Description 'Braeden Collection'?,EASY,cre_Doc_and_collections,"[Document_Objects.Owner,Document_Objects.Description]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Objects.Owner FROM Document_Objects WHERE Document_Objects.Description = 'Braeden Collection';,SELECT OWNER FROM Document_Objects WHERE Description  =  'Braeden Collection',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Objects.Owner"" of the document with the specified description. 2. Condition Structure: Use a WHERE clause to filter for the document where ""Document_Objects.Description"" matches 'Braeden Collection'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Document_Objects"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
619,"Which customers have nationality ""England"" or ""Australia""? Give me their names.",EASY,restaurant_bills,"[customer.Name, customer.Nationality]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT customer.Name FROM customer WHERE customer.Nationality = 'England' OR customer.Nationality = 'Australia';,"SELECT Name FROM customer WHERE Nationality  =  ""England"" OR Nationality  =  ""Australia""","1. Sequential Structure: Start with the SELECT clause to retrieve the names of customers. 2. Condition Structure: Use a WHERE clause to filter customers whose nationality is either ""England"" or ""Australia"". 3. Join Structure: No JOIN is required since all necessary information is in the ""customer"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving customer names based on a specific condition.",1.0
620,How many students live in each city?,NON-NESTED,address_1,"[Student.city_code, City.city_code, City.city_name, Student.StuID]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.city_name, COUNT(Student.StuID) AS student_count FROM Student JOIN City ON Student.city_code = City.city_code GROUP BY City.city_name;","SELECT T1.city_name ,  count(*) FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.city_code","1. Sequential Structure: Start with the SELECT clause to retrieve the city name and the count of students living in each city. Use COUNT on ""Student.StuID"" to count the number of students. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to associate each student with their respective city. 4. Aggregation Structure: Use COUNT to aggregate the number of students per city and GROUP BY ""City.city_name"" to group the results by city.",1.0
621,What are the details on the document subsets that are named 'Best for 2000'?,EASY,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_Details,Document_Subsets.Document_Subset_Name,'Best for 2000']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Subsets.Document_Subset_Details FROM Document_Subsets WHERE Document_Subsets.Document_Subset_Name = 'Best for 2000';,"SELECT Document_Subset_Details FROM Document_Subsets WHERE Document_Subset_Name = ""Best for 2000"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subsets.Document_Subset_Details"" for the document subsets named 'Best for 2000'. 2. Condition Structure: Use a WHERE clause to filter for rows where ""Document_Subsets.Document_Subset_Name"" is equal to 'Best for 2000'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Document_Subsets"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific details based on a condition.",1.0
622,"For ever collection named 'Best', what is the name and id of the one with the most documents, and how many documents does it have?",NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID,Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID,Collections.Collection_Name = 'Best']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Collections.Collection_Name, Collections.Collection_ID, COUNT(Documents_in_Collections.Document_Object_ID) AS document_count FROM Collections JOIN Documents_in_Collections ON Collections.Collection_ID = Documents_in_Collections.Collection_ID WHERE Collections.Collection_Name = 'Best' GROUP BY Collections.Collection_ID, Collections.Collection_Name ORDER BY document_count DESC LIMIT 1;","SELECT T1.Collection_Name ,  T1.Collection_ID ,  count(*) FROM Collections AS T1 JOIN Documents_in_Collections AS T2 ON T1.Collection_ID = T2.Collection_ID WHERE T1.Collection_Name = ""Best"" GROUP BY T1.Collection_ID ORDER BY count(*) DESC LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the name, ID, and the count of documents for the collection. Use the FROM clause to specify the Collections table and JOIN it with the Documents_in_Collections table to link collections with their documents. Use GROUP BY to group by collection ID and name, and apply ORDER BY to sort by the count of documents in descending order. Use LIMIT to get the collection with the most documents. 2. Condition Structure: Use the WHERE clause to filter for collections with the name 'Best'. 3. Join Structure: Use an INNER JOIN between the Collections table and the Documents_in_Collections table based on Collection_ID to connect collections with their documents. 4. Aggregation Structure: Use COUNT to calculate the number of documents in each collection and sort by this count to identify the collection with the most documents.",1.0
623,What is the collection name of a document owned by 'Ransom'?,NON-NESTED,cre_Doc_and_collections,"[Document_Objects.Owner,Collections.Collection_Name,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Documents_in_Collections.Collection_ID = Collections.Collection_ID,Ransom]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collections.Collection_Name FROM Documents_in_Collections JOIN Document_Objects ON Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID JOIN Collections ON Documents_in_Collections.Collection_ID = Collections.Collection_ID WHERE Document_Objects.Owner = 'Ransom';,SELECT T1.Collection_Name FROM Collections AS T1 JOIN Documents_in_Collections AS T2 ON T1.Collection_ID = T2.Collection_ID JOIN Document_Objects AS T3 ON T2.Document_object_id  =  T3.Document_object_id WHERE T3.owner  =  'Ransom',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collections.Collection_Name"" field, as we are looking for the collection name. 2. Condition Structure: Use a WHERE clause to filter for documents owned by ""Ransom"" by checking the ""Document_Objects.Owner"" field. 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""Documents_in_Collections"" with ""Document_Objects"" on ""Document_Object_ID"" to link documents with their owners. Then, join ""Documents_in_Collections"" with ""Collections"" on ""Collection_ID"" to link documents with their respective collections. 4. Aggregation Structure: No aggregation is needed, as we are retrieving a specific collection name.",1.0
624,"List the name of the songs in ascending, lexicographical order.",EASY,sing_contest,[songs.name],"Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
",SELECT songs.name FROM songs ORDER BY songs.name ASC;,SELECT name FROM songs ORDER BY name,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the name of the songs. 2. Condition Structure: No specific filtering condition is required as we want all song names. 3. Join Structure: No JOIN is required since all necessary data is within the ""songs"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the song names. 5. Ordering Structure: Use ORDER BY in ascending lexicographical order on ""songs.name"".",1.0
625,What are the voice sound quality scores received for the song named ' The Balkan Girls ' in English language ?,NON-NESTED,sing_contest,"[songs.name, songs.language, performance_score.voice_sound_quality, performance_score.songs_id = songs.id, 'The Balkan Girls', 'English']","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
",SELECT performance_score.voice_sound_quality FROM songs JOIN performance_score ON performance_score.songs_id = songs.id WHERE songs.name = 'The Balkan Girls' AND songs.language = 'English';,SELECT T1.voice_sound_quality FROM performance_score AS T1 JOIN songs AS T2 ON T1.songs_id  =  T2.id WHERE T2.name  =  ' The Balkan Girls ' AND T2.language  =  'English',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""performance_score.voice_sound_quality"" field, as the question asks for the voice sound quality scores. 2. Condition Structure: Use a WHERE clause to filter for the song named ""The Balkan Girls"" and the language ""English."" 3. Join Structure: Use a JOIN between the ""songs"" table and the ""performance_score"" table based on the relationship ""performance_score.songs_id = songs.id"" to link the scores with the corresponding song. 4. Aggregation Structure: No aggregation is needed, as the question asks for individual scores rather than a summary.",0.0
626,List the titles of books in descending order of pages.,EASY,book_review,"[book.Title, book.Pages]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT book.Title FROM book ORDER BY book.Pages DESC;,SELECT Title FROM book ORDER BY Pages DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the book title. 2. Condition Structure: No specific filtering condition is required as we want all book titles. 3. Ordering Structure: Use ORDER BY in descending order on the ""book.Pages"" field to sort the books by the number of pages. 4. Join Structure: No JOIN is required since all necessary data is within the ""book"" table. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the book titles.",1.0
627,What is the most common type of books?,EASY,book_review,[book.Type],"Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT book.Type FROM book GROUP BY book.Type ORDER BY COUNT(*) DESC LIMIT 1;,SELECT TYPE FROM book GROUP BY TYPE ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the type of books. 2. Aggregation Structure: Use COUNT to determine the number of books for each type. 3. Grouping Structure: Use GROUP BY on ""book.Type"" to aggregate the results by each book type. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank the book types by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common type of books. 6. Join Structure: No JOIN is required since all necessary data is within the ""book"" table.",1.0
628,"What are the titles of books that are not ""Poet""?",EASY,book_review,"[book.Title, book.Type]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT book.Title FROM book WHERE book.Type != 'Poet';,"SELECT Title FROM book WHERE TYPE != ""Poet""","1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the book title. 2. Condition Structure: Use a WHERE clause to filter out books where the ""book.Type"" is ""Poet"". 3. Join Structure: No JOIN is required since all necessary data is within the ""book"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving book titles that meet the specified condition.",1.0
629,What are the maximum and minimum voice sound quality score of the performances?,EASY,sing_contest,[performance_score.voice_sound_quality],"Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
","SELECT MAX(performance_score.voice_sound_quality) AS max_voice_sound_quality, MIN(performance_score.voice_sound_quality) AS min_voice_sound_quality FROM performance_score;","SELECT max(voice_sound_quality) ,  min(voice_sound_quality) FROM performance_score","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum voice sound quality scores. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum voice sound quality scores. 3. Grouping Structure: No grouping is required since the query asks for overall maximum and minimum scores across all performances. 4. Join Structure: No JOIN is required as all necessary data is within the ""performance_score"" table.",1.0
630,Show the client names and their total amounts of books ordered.,NON-NESTED,book_1,"[Client.Name, Books_Order.amount, Orders.IdClient = Client.IdClient, Books_Order.IdOrder = Orders.IdOrder]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Client.Name, SUM(Books_Order.amount) AS TotalAmount FROM Client JOIN Orders ON Client.IdClient = Orders.IdClient JOIN Books_Order ON Books_Order.IdOrder = Orders.IdOrder GROUP BY Client.Name;","SELECT T2.name ,  sum(T3.amount) FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient JOIN Books_Order AS T3 ON T3.idOrder  =  T1.idOrder GROUP BY T1.idClient","1. Sequential Structure: Start with the SELECT clause to retrieve ""Client.Name"" and the total ""Books_Order.amount"" for each client. Use SUM to calculate the total amount of books ordered. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Client"" table with the ""Orders"" table on ""Client.IdClient = Orders.IdClient"" and the ""Orders"" table with the ""Books_Order"" table on ""Books_Order.IdOrder = Orders.IdOrder"" to link clients with their book orders. 4. Aggregation Structure: Use SUM to aggregate the ""Books_Order.amount"" for each client and GROUP BY ""Client.Name"" to group the results by client.",1.0
631,How many countries do we have?,EASY,address_1,[City.country],"Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT COUNT(DISTINCT City.country) AS country_count FROM City;,SELECT count(DISTINCT country) FROM City,"1. Sequential Structure: Start with the SELECT clause to count the number of distinct countries. 2. Condition Structure: No specific filtering condition is required as we want to count all countries. 3. Join Structure: No JOIN is necessary since the required information is available within the ""City"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique countries.",1.0
632,"Which collection have most number of documents? List collection name, id and number of documents.",NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name, Collections.Collection_ID, Documents_in_Collections.Collection_ID, Documents_in_Collections.Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Collections.Collection_Name, Collections.Collection_ID, COUNT(Documents_in_Collections.Document_Object_ID) AS Number_of_Documents FROM Collections JOIN Documents_in_Collections ON Collections.Collection_ID = Documents_in_Collections.Collection_ID GROUP BY Collections.Collection_ID ORDER BY Number_of_Documents DESC LIMIT 1;","SELECT T1.Collection_Name ,  T1.Collection_ID ,  count(*) FROM Collections AS T1 JOIN Documents_in_Collections AS T2 ON T1.Collection_ID = T2.Collection_ID WHERE T1.Collection_Name = ""Best"" GROUP BY T1.Collection_ID ORDER BY count(*) DESC LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collections.Collection_Name,"" ""Collections.Collection_ID,"" and the count of documents in each collection. Use COUNT on ""Documents_in_Collections.Document_Object_ID"" to count the number of documents. 2. Condition Structure: No specific filtering condition is required, as we are interested in all collections. 3. Join Structure: Use a JOIN between ""Collections"" and ""Documents_in_Collections"" on ""Collection_ID"" to associate collections with their documents. 4. Aggregation Structure: Use COUNT to calculate the number of documents per collection, GROUP BY ""Collections.Collection_ID"" to group results by each collection, and ORDER BY the count in descending order to find the collection with the most documents. Use LIMIT 1 to retrieve only the collection with the highest count.",0.0
633,"List collection subset id, name and number of collections in each subset.",NON-NESTED,cre_Doc_and_collections,"[Collection_Subsets.Collection_Subset_ID, Collection_Subsets.Collection_Subset_Name, Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID, Collection_Subset_Members.Collection_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Collection_Subsets.Collection_Subset_ID, Collection_Subsets.Collection_Subset_Name, COUNT(Collection_Subset_Members.Collection_ID) AS Number_of_Collections FROM Collection_Subsets JOIN Collection_Subset_Members ON Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID GROUP BY Collection_Subsets.Collection_Subset_ID, Collection_Subsets.Collection_Subset_Name;","SELECT T2.Collection_Subset_ID ,  T1.Collection_Subset_Name ,  count(*) FROM Collection_Subsets AS T1 JOIN Collection_Subset_Members AS T2 ON T1.Collection_Subset_ID =  T2.Collection_Subset_ID GROUP BY T2.Collection_Subset_ID;","1. Sequential Structure: Start with the SELECT clause to retrieve ""Collection_Subsets.Collection_Subset_ID,"" ""Collection_Subsets.Collection_Subset_Name,"" and the count of collections in each subset. Use COUNT to calculate the number of collections in each subset. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between ""Collection_Subsets"" and ""Collection_Subset_Members"" on ""Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID"" to link subsets with their collections. 4. Aggregation Structure: Use COUNT on ""Collection_Subset_Members.Collection_ID"" to count the number of collections in each subset, and GROUP BY ""Collection_Subsets.Collection_Subset_ID"" and ""Collection_Subsets.Collection_Subset_Name"" to group results by each subset.",1.0
634,"Show all client names who have orders for ""Pride and Prejudice"".",NON-NESTED,book_1,"[Client.Name, Orders.IdClient = Client.IdClient, Books_Order.IdOrder = Orders.IdOrder, Books_Order.ISBN = Book.ISBN, Book.Title, ""Pride and Prejudice""]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Client.Name FROM Client JOIN Orders ON Orders.IdClient = Client.IdClient JOIN Books_Order ON Books_Order.IdOrder = Orders.IdOrder JOIN Book ON Books_Order.ISBN = Book.ISBN WHERE Book.Title = 'Pride and Prejudice';,"SELECT T3.name FROM Orders AS T1 JOIN Books_Order AS T2 ON T1.idOrder  =  T2.idOrder JOIN Client AS T3 ON T1.idClient  =  T3.idClient JOIN Book AS T4 ON T4.isbn  =  T2.isbn WHERE T4.title  =  ""Pride and Prejudice""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Client.Name."" 2. Condition Structure: Use a WHERE clause to filter for orders where the book title is ""Pride and Prejudice."" 3. Join Structure: Use multiple JOINs to connect the relevant tables. First, join ""Orders"" with ""Client"" on ""Orders.IdClient = Client.IdClient"" to associate orders with clients. Then, join ""Books_Order"" with ""Orders"" on ""Books_Order.IdOrder = Orders.IdOrder"" to link books to orders. Finally, join ""Book"" with ""Books_Order"" on ""Books_Order.ISBN = Book.ISBN"" to access the book title. 4. Aggregation Structure: No aggregation is needed as we are retrieving individual client names.",1.0
635,"What are the names of all the clients, and how many times has each of them ordered?",NON-NESTED,book_1,"[Client.Name, Orders.IdClient, Orders.IdOrder = Books_Order.IdOrder]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Client.Name, COUNT(Books_Order.IdOrder) AS OrderCount FROM Client JOIN Orders ON Client.Id = Orders.IdClient JOIN Books_Order ON Orders.IdOrder = Books_Order.IdOrder GROUP BY Client.Name;","SELECT T2.name ,  count(*) FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient GROUP BY T1.idClient","1. Sequential Structure: Start with the SELECT clause to retrieve the names of clients and the count of their orders. Use COUNT to count the number of orders for each client. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Client"" table with the ""Orders"" table on ""Client.Id = Orders.IdClient"" and the ""Orders"" table with the ""Books_Order"" table on ""Orders.IdOrder = Books_Order.IdOrder"" to link clients with their orders. 4. Aggregation Structure: Use COUNT to count the number of orders for each client and GROUP BY ""Client.Name"" to group the results by client name.",0.0
636,What are the different owners of documents that are related to ones owned by Braeden?,NESTED,cre_Doc_and_collections,"[Document_Objects.Owner,Document_Objects.Document_Object_ID,Document_Subset_Members.Related_Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Objects.Owner = 'Braeden']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT DISTINCT Document_Objects.Owner FROM Document_Objects JOIN Document_Subset_Members ON Document_Objects.Document_Object_ID = Document_Subset_Members.Related_Document_Object_ID WHERE Document_Subset_Members.Document_Object_ID IN ( SELECT Document_Object_ID FROM Document_Objects WHERE Document_Objects.Owner = 'Braeden' );,SELECT DISTINCT OWNER FROM Document_Subset_Members AS T1 JOIN Document_Objects AS T2 ON T1.Related_Document_Object_ID  =  T2.Document_Object_ID WHERE T2.Owner  =  'Braeden';,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct owners of documents. Use the FROM clause to specify the Document_Objects table and join it with the Document_Subset_Members table to find related documents. Apply a WHERE clause to filter documents owned by 'Braeden' and retrieve the owners of related documents. 2. Condition Structure: Use the WHERE clause to filter for documents owned by 'Braeden' and find related documents. 3. Join Structure: Use an INNER JOIN between Document_Objects and Document_Subset_Members tables based on Document_Object_ID to connect documents with their related documents. 4. Aggregation Structure: Not required, as we are retrieving distinct owners without any aggregation.",0.0
637,Which country has fewest number of cities?,NESTED,address_1,"[City.country, City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT country FROM City GROUP BY country ORDER BY COUNT(city_code) ASC LIMIT 1;,SELECT country FROM City GROUP BY country ORDER BY count(*) ASC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the country name. Use the FROM clause to specify the City table. Apply a GROUP BY clause to group records by country, allowing us to count the number of cities per country. Use the ORDER BY clause to sort the results by the count of cities in ascending order, and LIMIT the result to 1 to get the country with the fewest cities. 2. Condition Structure: No specific filtering condition is required, as we are interested in all countries and their city counts. 3. Join Structure: Not required, as all necessary data is available in the City table. 4. Aggregation Structure: Use COUNT(city_code) to count the number of cities per country.",1.0
638,List the names of members whose nationality is not `` England '' .,EASY,club_leader,"[member.Name, member.Nationality]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT member.Name FROM member WHERE member.Nationality != 'England';,"select name from member where nationality != ""england""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""member.Name"" of members whose nationality is not ""England"". 2. Condition Structure: Use a WHERE clause to filter out members whose ""member.Nationality"" is ""England"". 3. Join Structure: No JOIN is required since all necessary information is in the ""member"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.",0.0
639,"Show ids for orders including both ""Pride and Prejudice"" and ""The Little Prince"".",NESTED,book_1,"[Book.Title,Books_Order.ISBN,Books_Order.IdOrder,Book.ISBN = Books_Order.ISBN,Books_Order.IdOrder = Orders.IdOrder,""Pride and Prejudice"",""The Little Prince""]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Books_Order.IdOrder FROM Books_Order JOIN Book ON Book.ISBN = Books_Order.ISBN WHERE Book.Title IN ('Pride and Prejudice', 'The Little Prince') GROUP BY Books_Order.IdOrder HAVING COUNT(DISTINCT Book.Title) = 2;","SELECT idOrder FROM Book AS T1 JOIN Books_Order AS T2 ON T1.isbn  =  T2.isbn WHERE T1.title  =  ""Pride and Prejudice"" INTERSECT SELECT idOrder FROM Book AS T1 JOIN Books_Order AS T2 ON T1.isbn  =  T2.isbn WHERE T1.title  =  ""The Little Prince""","1. Sequential Structure: Start with the SELECT clause to retrieve the order IDs. Use the FROM clause to specify the Books_Order table and JOIN it with the Book table to connect orders with book titles. Apply a WHERE clause to filter for orders that include both ""Pride and Prejudice"" and ""The Little Prince"". 2. Condition Structure: Use a WHERE clause to filter for books with titles ""Pride and Prejudice"" and ""The Little Prince"". Use a GROUP BY clause to group by order IDs and a HAVING clause to ensure that both books are included in the same order. 3. Join Structure: Use an INNER JOIN between the Books_Order and Book tables based on the ISBN to connect book titles with their respective orders. 4. Aggregation Structure: Use COUNT(DISTINCT Book.Title) in the HAVING clause to ensure that both titles are present in the same order.",1.0
640,Which state has most number of cities?,EASY,address_1,"[City.state, City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.state FROM City GROUP BY City.state ORDER BY COUNT(City.city_code) DESC LIMIT 1;,SELECT state FROM City GROUP BY state ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the state, as the question asks for the state with the most number of cities. 2. Aggregation Structure: Use COUNT to calculate the number of cities in each state. 3. Grouping Structure: Use GROUP BY on ""City.state"" to count cities for each state. 4. Ordering Structure: Use ORDER BY in descending order on the city count to rank states by the number of cities. 5. Limiting Structure: Use LIMIT 1 to retrieve only the state with the most number of cities. 6. Join Structure: No JOIN is required since all necessary data is within the ""City"" table.",1.0
641,"Who is the author of the book ""Pride and Prejudice""?",NON-NESTED,book_1,"[Book.Title, Author_Book.ISBN = Book.ISBN, Author_Book.Author, Author.idAuthor, Author.Name]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Author.Name FROM Book JOIN Author_Book ON Author_Book.ISBN = Book.ISBN JOIN Author ON Author_Book.idAuthor = Author.idAuthor WHERE Book.Title = 'Pride and Prejudice';,"SELECT T3.name FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T1.title  =  ""Pride and Prejudice""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Author.Name"" since the question asks for the author of the book. 2. Condition Structure: Use a WHERE clause to filter for the book with the title ""Pride and Prejudice."" 3. Join Structure: Use JOINs to connect the ""Book"" table with the ""Author_Book"" table on ""ISBN"" and then connect the ""Author_Book"" table with the ""Author"" table on ""idAuthor"" to link the book with its author. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single author's name.",0.0
642,Show each customer name and the total quantities of dishes ordered by that customer.,NON-NESTED,restaurant_bills,"[customer.Name, customer_order.Customer_ID, customer_order.Quantity, customer.Customer_ID = customer_order.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
","SELECT customer.Name, SUM(customer_order.Quantity) AS Total_Quantity FROM customer JOIN customer_order ON customer.Customer_ID = customer_order.Customer_ID GROUP BY customer.Name;","SELECT T1.Name ,  sum(T2.Quantity) FROM customer AS T1 JOIN customer_order AS T2 ON T1.Customer_ID  =  T2.Customer_ID GROUP BY T1.Name","1. Sequential Structure: Start with the SELECT clause to retrieve ""customer.Name"" and the total quantities of dishes ordered by each customer. Use SUM on ""customer_order.Quantity"" to calculate the total quantities. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""customer"" and ""customer_order"" tables based on the shared key ""customer.Customer_ID = customer_order.Customer_ID"" to associate each customer with their orders. 4. Aggregation Structure: Use SUM to aggregate the total quantities of dishes ordered by each customer, and GROUP BY ""customer.Name"" to group the results by customer.",1.0
643,What are the name and popularity of participants who have sung a song both in 'Croatian' language and in 'English' language?,NESTED,sing_contest,"[participants.name, participants.popularity, songs.language, performance_score.participant_id = participants.id, performance_score.songs_id = songs.id, 'Croatian', 'English']","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
","SELECT participants.name, participants.popularity FROM participants JOIN performance_score ON performance_score.participant_id = participants.id JOIN songs ON performance_score.songs_id = songs.id WHERE participants.id IN ( SELECT participant_id FROM performance_score JOIN songs ON performance_score.songs_id = songs.id WHERE songs.language = 'Croatian' ) AND participants.id IN ( SELECT participant_id FROM performance_score JOIN songs ON performance_score.songs_id = songs.id WHERE songs.language = 'English' );","SELECT T1.name ,  T1.popularity FROM participants AS T1 JOIN performance_score AS T2 ON T2.participant_id  =  T1.id JOIN songs AS T3 ON T3.id  =  T2.songs_id WHERE T3.language  =  'Croatian' INTERSECT SELECT T1.name ,  T1.popularity FROM participants AS T1 JOIN performance_score AS T2 ON T2.participant_id  =  T1.id JOIN songs AS T3 ON T3.id  =  T2.songs_id WHERE T3.language  =  'English'","1. Sequential Structure: Start with the SELECT clause to retrieve the name and popularity of participants. Use the FROM clause to specify the participants table and JOIN it with the performance_score and songs tables to connect participants with the songs they have performed. Apply a WHERE clause to filter participants who have sung songs in both 'Croatian' and 'English' languages. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the participant has performed songs in both 'Croatian' and 'English'. This can be achieved by checking that the participant's ID appears in the performance_score table for songs in both languages. 3. Join Structure: Use INNER JOINs between participants, performance_score, and songs tables based on participant_id and songs_id to connect participants with the songs they have performed. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
644,What are the document object ids of the objects owned by Marlin?,EASY,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID,Document_Objects.Owner,Document_Objects.Owner = 'Marlin']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Objects.Document_Object_ID FROM Document_Objects WHERE Document_Objects.Owner = 'Marlin';,SELECT Parent_Document_Object_ID FROM Document_Objects WHERE OWNER  =  'Marlin',"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the ""Document_Objects.Document_Object_ID"". 2. Condition Structure: Use a WHERE clause to filter for objects where the ""Document_Objects.Owner"" is 'Marlin'. 3. Join Structure: No JOIN is required since all necessary information is within the ""Document_Objects"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving document object IDs based on a specific condition.",0.0
645,Show names for all cities in state PA.,EASY,address_1,"[City.city_name,City.state,PA]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.city_name FROM City WHERE City.state = 'PA';,"SELECT city_name FROM City WHERE state  =  ""PA""","1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the city name. 2. Condition Structure: Use a WHERE clause to filter cities where the state is 'PA'. 3. Join Structure: No JOIN is required since all necessary data is within the ""City"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving city names based on a specific condition.",1.0
646,For each book type return the type and the number of books of that type.,EASY,book_review,"[book.Type, book.Book_ID]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
","SELECT book.Type, COUNT(book.Book_ID) AS book_count FROM book GROUP BY book.Type;","SELECT TYPE ,  COUNT(*) FROM book GROUP BY TYPE","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the book type and the count of books for each type. 2. Aggregation Structure: Use COUNT to calculate the number of books for each type. 3. Grouping Structure: Use GROUP BY on ""book.Type"" to group the results by each book type. 4. Join Structure: No JOIN is required since all necessary data is within the ""book"" table.",1.0
647,"What are the different subsets of documents related to each document id , list the name of the document subset and id of the actual document ?",NON-NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_Name,Document_Subsets.Document_Subset_ID,Document_Subset_Members.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Subsets.Document_Subset_Name, Document_Subset_Members.Document_Object_ID FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID;","select distinct t3.document_subset_name ,  t1.document_object_id from document_subset_members as t1 join document_subset_members  as t2 on t1.related_document_object_id = t2.document_object_id join document_subsets as t3 on t2.document_subset_id =  t3.document_subset_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subsets.Document_Subset_Name"" and ""Document_Subset_Members.Document_Object_ID"" as these are the required fields. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Document_Subsets"" and ""Document_Subset_Members"" tables based on the relationship ""Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID"" to link each document subset with its members. 4. Aggregation Structure: No aggregation is needed as the query simply lists the subsets and their corresponding document IDs.",1.0
648,What are the titles of books with the highest purchase price across all books ?,NESTED,book_1,"[Book.Title, Book.PurchasePrice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Title FROM Book WHERE PurchasePrice = (SELECT MAX(PurchasePrice) FROM Book);,select title from book order by purchaseprice  desc limit 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of books. Use the FROM clause to specify the Book table. Apply a WHERE clause to filter for books with the highest purchase price. 2. Condition Structure: Use the WHERE clause with a subquery to filter for books where the purchase price matches the maximum purchase price across all books. 3. Join Structure: Not required, as all data is available within the Book table. 4. Aggregation Structure: Use the MAX function in a subquery to find the highest purchase price, which is then used in the filtering condition.",1.0
649,List all name of collections that are related to collection named Best.,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID,Collection_Subset_Members.Related_Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID,Collections.Collection_Name = 'Best']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collections.Collection_Name FROM Collections JOIN Collection_Subset_Members ON Collections.Collection_ID = Collection_Subset_Members.Related_Collection_ID WHERE Collection_Subset_Members.Collection_ID = (SELECT Collection_ID FROM Collections WHERE Collection_Name = 'Best');,"SELECT DISTINCT T4.Collection_Name FROM Collection_Subset_Members AS T1 JOIN Collection_Subset_Members AS T2 ON T1.Related_Collection_ID = T2.Collection_ID JOIN Collections AS T3 ON T1.Collection_ID = T3.Collection_ID JOIN Collections AS T4 ON T2.Collection_ID = T4.Collection_ID WHERE T3.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collections.Collection_Name"" of related collections. 2. Condition Structure: Use a WHERE clause to filter for the collection named ""Best"" and find its related collections. 3. Join Structure: Use a JOIN between the ""Collections"" table and the ""Collection_Subset_Members"" table. The JOIN will be based on ""Collections.Collection_ID"" and ""Collection_Subset_Members.Collection_ID"" to link collections with their related collections. 4. Aggregation Structure: No aggregation is needed as we are simply listing the names of related collections.",1.0
650,List all collections' subset. List the subsets' names.,NON-NESTED,cre_Doc_and_collections,"[Collection_Subsets.Collection_Subset_Name,Collection_Subsets.Collection_Subset_ID = Collection_Subset_Members.Collection_Subset_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collection_Subsets.Collection_Subset_Name FROM Collection_Subsets JOIN Collection_Subset_Members ON Collection_Subsets.Collection_Subset_ID = Collection_Subset_Members.Collection_Subset_ID;,SELECT Collection_Subset_Name FROM Collection_Subsets;,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collection_Subsets.Collection_Subset_Name"" field, which contains the names of the subsets. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Collection_Subsets"" table and the ""Collection_Subset_Members"" table based on the ""Collection_Subset_ID"" field to link subsets with their members. 4. Aggregation Structure: No aggregation is required as the task is to list all subset names.",0.0
651,List the names and languages of the songs .,EASY,sing_contest,"[songs.name, songs.language]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
","SELECT songs.name, songs.language FROM songs;","select name , language from songs","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the song names and their languages. 2. Condition Structure: No specific filtering condition is required as the query asks for all songs and their languages. 3. Join Structure: No JOIN is required since all necessary information is available in the ""songs"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and languages of all songs.",1.0
652,What collection details are there on the subset named 'Top collection'?,NON-NESTED,cre_Doc_and_collections,"[Collection_Subsets.Collection_Subset_Name,Collection_Subsets.Collection_Subset_Details,Collection_Subsets.Collection_Subset_ID = Collection_Subset_Members.Collection_Subset_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID,Collections.Collection_Description,'Top collection']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Collection_Subsets.Collection_Subset_Details, Collections.Collection_Description FROM Collection_Subsets JOIN Collection_Subset_Members ON Collection_Subsets.Collection_Subset_ID = Collection_Subset_Members.Collection_Subset_ID JOIN Collections ON Collection_Subset_Members.Collection_ID = Collections.Collection_ID WHERE Collection_Subsets.Collection_Subset_Name = 'Top collection';","SELECT Collecrtion_Subset_Details FROM Collection_Subsets WHERE Collection_Subset_Name = ""Top collection"";","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields, which include ""Collection_Subsets.Collection_Subset_Details"" and ""Collections.Collection_Description."" 2. Condition Structure: Use a WHERE clause to filter for the subset named ""Top collection"" by matching ""Collection_Subsets.Collection_Subset_Name."" 3. Join Structure: Use JOINs to connect the ""Collection_Subsets"" table with ""Collection_Subset_Members"" on ""Collection_Subsets.Collection_Subset_ID"" and then with ""Collections"" on ""Collection_Subset_Members.Collection_ID = Collections.Collection_ID"" to link the subset details with the collection descriptions. 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving details for a specific subset.",0.0
653,What is the number of documents in the collection named 'Best'?,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID = Documents_in_Collections.Collection_ID,Documents_in_Collections.Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT COUNT(Documents_in_Collections.Document_Object_ID) FROM Collections JOIN Documents_in_Collections ON Collections.Collection_ID = Documents_in_Collections.Collection_ID WHERE Collections.Collection_Name = 'Best';,"SELECT count(*) FROM Collections AS T1 JOIN Documents_in_Collections AS T2 ON T1.Collection_ID = T2.Collection_ID WHERE T1.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to count the number of documents in the collection. Use COUNT on ""Documents_in_Collections.Document_Object_ID"" to get the total number of documents. 2. Condition Structure: Use a WHERE clause to filter for the collection named ""Best"" by matching ""Collections.Collection_Name."" 3. Join Structure: Use a JOIN between the ""Collections"" table and the ""Documents_in_Collections"" table based on ""Collections.Collection_ID = Documents_in_Collections.Collection_ID"" to link collections with their documents. 4. Aggregation Structure: Use COUNT to aggregate the total number of documents in the specified collection.",1.0
654,"For each order, return the customer name and the dish name.",NON-NESTED,restaurant_bills,"[customer.Name, customer_order.Dish_Name, customer.Customer_ID = customer_order.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
","SELECT customer.Name, customer_order.Dish_Name FROM customer JOIN customer_order ON customer.Customer_ID = customer_order.Customer_ID;","SELECT T1.Name ,  T2.Dish_Name FROM customer AS T1 JOIN customer_order AS T2 ON T1.Customer_ID  =  T2.Customer_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""customer.Name"" and ""customer_order.Dish_Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""customer"" and ""customer_order"" tables based on the relationship ""customer.Customer_ID = customer_order.Customer_ID"" to link each customer with their respective orders. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the customer name and dish name for each order.",1.0
655,Show the number of students living in each country.,NON-NESTED,address_1,"[Student.city_code, City.country, Student.city_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.country, COUNT(Student.city_code) AS student_count FROM Student JOIN City ON Student.city_code = City.city_code GROUP BY City.country;","SELECT T1.country ,  count(*) FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.country","1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.country"" and the count of students living in each country. Use COUNT to count the number of students. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to associate each student with their respective country. 4. Aggregation Structure: Use COUNT to count the number of students for each country and GROUP BY ""City.country"" to group the results by country.",1.0
656,List the Collection Name that document owned by 'Ransom ' belong to .,NON-NESTED,cre_Doc_and_collections,"[Document_Objects.Owner, Collections.Collection_Name, Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID, Documents_in_Collections.Collection_ID = Collections.Collection_ID, Ransom]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collections.Collection_Name FROM Document_Objects JOIN Documents_in_Collections ON Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID JOIN Collections ON Documents_in_Collections.Collection_ID = Collections.Collection_ID WHERE Document_Objects.Owner = 'Ransom';,select t1.collection_name from collections as t1 join documents_in_collections as t2 on t1.collection_id = t2.collection_id join document_objects as t3 on t2.document_object_id  =  t3.document_object_id where t3.owner  =  'ransom',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collections.Collection_Name."" 2. Condition Structure: Use a WHERE clause to filter for documents owned by ""Ransom"" in the ""Document_Objects.Owner"" field. 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""Document_Objects"" with ""Documents_in_Collections"" on ""Document_Objects.Document_Object_ID = Documents_in_Collections.Document_Object_ID."" Then, join ""Documents_in_Collections"" with ""Collections"" on ""Documents_in_Collections.Collection_ID = Collections.Collection_ID."" 4. Aggregation Structure: No aggregation is needed as we are retrieving specific collection names.",1.0
657,What are the titles of books that have a sale price equal to the lowest sale price across all books ?,NESTED,book_1,"[Book.Title, Book.SalePrice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Title FROM Book WHERE SalePrice = (SELECT MIN(SalePrice) FROM Book);,select title from book order by saleprice asc limit 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of books. Use the FROM clause to specify the Book table. Apply a WHERE clause to filter books whose sale price is equal to the lowest sale price across all books. 2. Condition Structure: Use the WHERE clause with a subquery to identify books whose SalePrice matches the minimum SalePrice in the Book table. 3. Join Structure: Not required, as all data is in the Book table. 4. Aggregation Structure: Use the MIN function in a subquery to find the lowest SalePrice, which is then used in the filtering condition.",1.0
658,What is detail of collection subset with name 'Top collection'?,EASY,cre_Doc_and_collections,"[Collection_Subsets.Collection_Subset_Details,Collection_Subsets.Collection_Subset_Name,'Top collection']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collection_Subsets.Collection_Subset_Details FROM Collection_Subsets WHERE Collection_Subsets.Collection_Subset_Name = 'Top collection';,"SELECT Collecrtion_Subset_Details FROM Collection_Subsets WHERE Collection_Subset_Name = ""Top collection"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collection_Subsets.Collection_Subset_Details"" for the subset with the name 'Top collection'. 2. Condition Structure: Use a WHERE clause to filter for the subset where ""Collection_Subsets.Collection_Subset_Name"" is equal to 'Top collection'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Collection_Subsets"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a specific detail based on a condition.",0.0
659,Who is the owner of the parent document of every documents where 'Marlin' is the owner?,NESTED,cre_Doc_and_collections,"[Document_Objects.Owner,Document_Objects.Document_Object_ID,Document_Objects.Parent_Document_Object_ID,Document_Objects.Owner = 'Marlin']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Parent.Owner FROM Document_Objects AS Child JOIN Document_Objects AS Parent ON Child.Parent_Document_Object_ID = Parent.Document_Object_ID WHERE Child.Owner = 'Marlin';,SELECT T2.Owner FROM Document_Objects AS T1 JOIN Document_Objects AS T2 ON T1.Parent_Document_Object_ID = T2.Document_Object_ID WHERE T1.Owner  =  'Marlin',"1. Sequential Structure: Start with the SELECT clause to retrieve the owner of the parent document. Use the FROM clause to specify the Document_Objects table. Apply a WHERE clause to filter for documents where the owner is 'Marlin'. Use a subquery to find the parent document's owner for each document owned by 'Marlin'. 2. Condition Structure: Use the WHERE clause to filter for documents where the owner is 'Marlin'. Use a subquery to retrieve the parent document's owner by matching the Parent_Document_Object_ID with the Document_Object_ID. 3. Join Structure: Not required, as all data is within the same table (Document_Objects). 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
660,Return the first name and major of students are living in Baltimore?,NON-NESTED,address_1,"[Student.Fname, Student.Major, Student.city_code = City.city_code, City.city_name, Baltimore]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT Student.Fname, Student.Major FROM Student JOIN City ON Student.city_code = City.city_code WHERE City.city_name = 'Baltimore';","SELECT T2.Fname ,  T2.Major FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE T1.city_name  =  ""Baltimore""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Student.Fname"" and ""Student.Major."" 2. Condition Structure: Use a WHERE clause to filter for students living in Baltimore. This requires matching the ""Student.city_code"" with ""City.city_code"" and filtering where ""City.city_name"" is 'Baltimore.' 3. Join Structure: Use an INNER JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to associate students with their respective cities. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields for students living in Baltimore.",1.0
661,Show all client names for clients who have not made orders.,NESTED,book_1,"[Client.Name, Client.IdClient, Orders.IdClient]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Client.Name FROM Client WHERE Client.IdClient NOT IN (SELECT Orders.IdClient FROM Orders);,SELECT name FROM Client EXCEPT SELECT T1.name FROM Client AS T1 JOIN Orders AS T2 ON T1.idClient  =  T2.idClient,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of clients. Use the FROM clause to specify the Client table. Apply a WHERE clause to filter clients who have not made any orders by ensuring their IdClient is not present in the Orders table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude clients whose IdClient appears in the Orders table, meaning they have made orders. 3. Join Structure: Not required, as we only need to filter based on the absence of matching IdClient entries in the Orders table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
662,What is the title and purchase price of the book that has the highest total order amount?,NON-NESTED,book_1,"[Book.Title, Book.PurchasePrice, Books_Order.amount, Books_Order.ISBN = Book.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Book.Title, Book.PurchasePrice FROM Book JOIN Books_Order ON Books_Order.ISBN = Book.ISBN GROUP BY Book.ISBN, Book.Title, Book.PurchasePrice ORDER BY SUM(Books_Order.amount) DESC LIMIT 1;","SELECT T2.title ,  T2.PurchasePrice FROM Books_Order AS T1 JOIN BOOk AS T2 ON T1.isbn  =  T2.isbn GROUP BY T1.isbn ORDER BY sum(amount) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""Book.Title"" and ""Book.PurchasePrice."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the book with the highest total order amount. 3. Join Structure: Use a JOIN between the ""Book"" and ""Books_Order"" tables based on the ""ISBN"" field to link each book with its order details. 4. Aggregation Structure: Use SUM on ""Books_Order.amount"" to calculate the total order amount for each book. Use ORDER BY in descending order on the aggregated total order amount and LIMIT 1 to select the book with the highest total order amount.",1.0
663,Show the names of club leaders and the names of clubs they joined.,NON-NESTED,club_leader,"[member.Name, club.Club_Name, club_leader.Member_ID = member.Member_ID, club_leader.Club_ID = club.Club_ID]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
","SELECT member.Name, club.Club_Name FROM club_leader JOIN member ON club_leader.Member_ID = member.Member_ID JOIN club ON club_leader.Club_ID = club.Club_ID;","SELECT T3.Name ,  T2.Club_Name FROM club_leader AS T1 JOIN club AS T2 ON T1.Club_ID  =  T2.Club_ID JOIN member AS T3 ON T1.Member_ID  =  T3.Member_ID","1. Sequential Structure: Start with the SELECT clause to retrieve the names of club leaders and the names of the clubs they joined. This involves selecting ""member.Name"" and ""club.Club_Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""club_leader"" table with the ""member"" table on ""club_leader.Member_ID = member.Member_ID"" and with the ""club"" table on ""club_leader.Club_ID = club.Club_ID"" to link club leaders with their respective clubs. 4. Aggregation Structure: No aggregation is required as the query only retrieves the names of club leaders and their clubs.",1.0
664,List all book titles which have highest purchase prices .,NESTED,book_1,"[Book.Title,Book.PurchasePrice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Title FROM Book WHERE PurchasePrice = (SELECT MAX(PurchasePrice) FROM Book);,select title from book order by purchaseprice  desc limit 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of books. Use the FROM clause to specify the Book table. Apply a WHERE clause to filter for books with the highest purchase price. 2. Condition Structure: Use the WHERE clause with a subquery to filter for books whose purchase price matches the maximum purchase price. 3. Join Structure: Not required, as all data is in the Book table. 4. Aggregation Structure: Use the MAX function in a subquery to find the highest purchase price, which is then used in the filtering condition.",1.0
665,List the titles of books in ascending order of the ratings in review?,NON-NESTED,book_review,"[book.Title, review.Rating, review.Book_ID = book.Book_ID]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT book.Title FROM book JOIN review ON review.Book_ID = book.Book_ID ORDER BY review.Rating ASC;,SELECT T1.Title FROM book AS T1 JOIN review AS T2 ON T1.Book_ID  =  T2.Book_ID ORDER BY T2.Rating ASC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""book.Title."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""book"" and ""review"" tables based on the ""Book_ID"" field to associate each book with its reviews. 4. Aggregation Structure: Use ORDER BY to sort the results in ascending order of ""review.Rating.""",1.0
666,Find the customer with the highest membership level and return his or her card credit.,EASY,restaurant_bills,"[customer.Level_of_Membership, customer.Card_Credit]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT customer.Card_Credit FROM customer ORDER BY customer.Level_of_Membership DESC LIMIT 1;,SELECT Card_Credit FROM customer ORDER BY Level_of_Membership DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""customer.Card_Credit"" of the customer with the highest membership level. 2. Condition Structure: No specific filtering condition is needed since we are looking for the customer with the highest membership level. 3. Join Structure: No JOIN is required, as all necessary information is in the ""customer"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""customer.Level_of_Membership"" to rank customers by membership level and apply LIMIT 1 to select the customer with the highest membership level.",1.0
667,Show all states and number of cities in each state.,EASY,address_1,"[City.state, City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.state, COUNT(City.city_code) AS number_of_cities FROM City GROUP BY City.state;","SELECT state ,  count(*) FROM City GROUP BY state","1. Sequential Structure: Begin with the SELECT clause to specify the state and the count of cities in each state. 2. Aggregation Structure: Use COUNT to calculate the number of cities in each state. 3. Grouping Structure: Use GROUP BY on ""City.state"" to group the results by each state. 4. Join Structure: No JOIN is required since all necessary data is within the ""City"" table.",1.0
668,What are the owners of the document objects described as the 'Braeden Collection'?,NON-NESTED,cre_Doc_and_collections,"[Document_Objects.Owner,Document_Objects.Description,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Documents_in_Collections.Collection_ID = Collections.Collection_ID,Collections.Collection_Name,'Braeden Collection']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Objects.Owner FROM Document_Objects JOIN Documents_in_Collections ON Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID JOIN Collections ON Documents_in_Collections.Collection_ID = Collections.Collection_ID WHERE Collections.Collection_Name = 'Braeden Collection';,SELECT OWNER FROM Document_Objects WHERE Description  =  'Braeden Collection',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Objects.Owner"" field, as we are interested in the owners of the document objects. 2. Condition Structure: Use a WHERE clause to filter for document objects that are part of the collection named ""Braeden Collection."" 3. Join Structure: Use JOINs to connect the ""Document_Objects"" table with the ""Documents_in_Collections"" table on ""Document_Object_ID"" and then connect the ""Documents_in_Collections"" table with the ""Collections"" table on ""Collection_ID"" to link document objects with their respective collections. 4. Aggregation Structure: No aggregation is needed, as we are retrieving specific data without any summarization.",0.0
669,"Show different nationalities of customers, along with the number of customers of each nationality.",EASY,restaurant_bills,"[customer.Nationality, customer.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
","SELECT customer.Nationality, COUNT(customer.Customer_ID) AS customer_count FROM customer GROUP BY customer.Nationality;","SELECT Nationality ,  COUNT(*) FROM customer GROUP BY Nationality","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the nationality and the count of customers. 2. Aggregation Structure: Use COUNT to calculate the number of customers for each nationality. 3. Grouping Structure: Use GROUP BY on ""customer.Nationality"" to group the results by each nationality. 4. Join Structure: No JOIN is required since all necessary data is within the ""customer"" table.",1.0
670,What are sale prices of books written by Plato?,NON-NESTED,book_1,"[Book.SalePrice,Author.Name,Author.idAuthor = Author_Book.Author,Author_Book.ISBN = Book.ISBN,Plato]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.SalePrice FROM Author JOIN Author_Book ON Author.idAuthor = Author_Book.Author JOIN Book ON Author_Book.ISBN = Book.ISBN WHERE Author.Name = 'Plato';,"SELECT saleprice FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T3.name  =  ""Plato""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Book.SalePrice"" field, as the question asks for the sale prices of books. 2. Condition Structure: Use a WHERE clause to filter for books written by the author ""Plato."" 3. Join Structure: Use JOINs to connect the ""Author"" table with the ""Author_Book"" table on ""Author.idAuthor = Author_Book.Author"" and the ""Author_Book"" table with the ""Book"" table on ""Author_Book.ISBN = Book.ISBN"" to link authors with their books. 4. Aggregation Structure: No aggregation is needed, as the question only asks for the sale prices of books written by Plato.",1.0
671,Give the state that has the most students.,NON-NESTED,address_1,"[Student.city_code, City.state, Student.city_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.state, COUNT(Student.city_code) AS student_count FROM Student JOIN City ON Student.city_code = City.city_code GROUP BY City.state ORDER BY student_count DESC LIMIT 1;",SELECT T1.state FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.state ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.state"" and the count of students. Use COUNT to count the number of students in each state. 2. Condition Structure: No specific filtering condition is required, as we are interested in all states. 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to associate each student with their respective state. 4. Aggregation Structure: Use COUNT to count the number of students per state, GROUP BY ""City.state"" to group the results by state, and ORDER BY the count in descending order to find the state with the most students. Use LIMIT 1 to return only the top result.",1.0
672,"What are the collection subset ids, names, and number of collections for each subset?",NON-NESTED,cre_Doc_and_collections,"[Collection_Subsets.Collection_Subset_ID, Collection_Subsets.Collection_Subset_Name, Collection_Subset_Members.Collection_ID, Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Collection_Subsets.Collection_Subset_ID, Collection_Subsets.Collection_Subset_Name, COUNT(Collection_Subset_Members.Collection_ID) AS Number_of_Collections FROM Collection_Subsets JOIN Collection_Subset_Members ON Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID GROUP BY Collection_Subsets.Collection_Subset_ID, Collection_Subsets.Collection_Subset_Name;","SELECT T2.Collection_Subset_ID ,  T1.Collection_Subset_Name ,  count(*) FROM Collection_Subsets AS T1 JOIN Collection_Subset_Members AS T2 ON T1.Collection_Subset_ID =  T2.Collection_Subset_ID GROUP BY T2.Collection_Subset_ID;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collection_Subsets.Collection_Subset_ID,"" ""Collection_Subsets.Collection_Subset_Name,"" and the count of collections for each subset. Use COUNT to calculate the number of collections. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between ""Collection_Subsets"" and ""Collection_Subset_Members"" on ""Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID"" to link subsets with their collections. 4. Aggregation Structure: Use COUNT on ""Collection_Subset_Members.Collection_ID"" to count the number of collections for each subset, and GROUP BY ""Collection_Subsets.Collection_Subset_ID"" and ""Collection_Subsets.Collection_Subset_Name"" to group the results by subset.",1.0
673,List all owner of documents that is related to documents owned by Braeden.,NESTED,cre_Doc_and_collections,"[Document_Objects.Owner,Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Objects.Owner,Braeden]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT DISTINCT Document_Objects.Owner FROM Document_Objects JOIN Document_Subset_Members ON Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID WHERE Document_Subset_Members.Document_Object_ID IN ( SELECT Document_Object_ID FROM Document_Objects WHERE Owner = 'Braeden' );,SELECT DISTINCT OWNER FROM Document_Subset_Members AS T1 JOIN Document_Objects AS T2 ON T1.Related_Document_Object_ID  =  T2.Document_Object_ID WHERE T2.Owner  =  'Braeden';,"1. Sequential Structure: Start with the SELECT clause to retrieve the owners of documents. Use the FROM clause to specify the Document_Objects table and join it with the Document_Subset_Members table to establish relationships between documents. Apply a WHERE clause to filter for documents related to those owned by ""Braeden."" 2. Condition Structure: Use the WHERE clause to first identify documents owned by ""Braeden"" and then find related documents using the relationship in the Document_Subset_Members table. 3. Join Structure: Use INNER JOIN between Document_Objects and Document_Subset_Members tables based on Document_Object_ID to connect documents with their related documents. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
674,What are the different titles of books that have been ordered in the past?,NON-NESTED,book_1,"[Book.Title, Books_Order.ISBN, Book.ISBN = Books_Order.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT DISTINCT Book.Title FROM Book JOIN Books_Order ON Book.ISBN = Books_Order.ISBN;,SELECT DISTINCT T1.title FROM book AS T1 JOIN books_order AS T2 ON T1.isbn  =  T2.isbn,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct titles of books that have been ordered. Use DISTINCT to ensure unique titles are returned. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all books that have been ordered in the past. 3. Join Structure: Use a JOIN between the ""Book"" and ""Books_Order"" tables based on the ""ISBN"" field to link books with their orders. 4. Aggregation Structure: No aggregation is needed, as we are only retrieving distinct book titles.",1.0
675,What is the count of documents owned by Marlin?,EASY,cre_Doc_and_collections,"[Document_Objects.Owner,Document_Objects.Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT COUNT(Document_Objects.Document_Object_ID) FROM Document_Objects WHERE Document_Objects.Owner = 'Marlin';,"SELECT count(*) FROM Document_Objects WHERE OWNER = ""Marlin"";","1. Sequential Structure: Start with the SELECT clause to count the number of documents owned by ""Marlin"". 2. Condition Structure: Use a WHERE clause to filter records where ""Document_Objects.Owner"" is ""Marlin"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Document_Objects"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of documents owned by ""Marlin"".",1.0
676,Find the average card credit customers whose membership level is above 1.,EASY,restaurant_bills,"[customer.Card_Credit, customer.Level_of_Membership]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT AVG(customer.Card_Credit) AS avg_card_credit FROM customer WHERE customer.Level_of_Membership > 1;,SELECT avg(Card_Credit) FROM customer WHERE Level_of_Membership  >  1,"1. Sequential Structure: Begin with the SELECT clause to calculate the average card credit for customers. 2. Condition Structure: Use a WHERE clause to filter customers whose ""Level_of_Membership"" is above 1. 3. Join Structure: No JOIN is required since all necessary data is within the ""customer"" table. 4. Aggregation Structure: Use the AVG function to calculate the average card credit for the filtered customers.",1.0
677,List the names of members in ascending order of age.,EASY,club_leader,"[member.Name, member.Age]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT member.Name FROM member ORDER BY member.Age ASC;,SELECT Name FROM member ORDER BY Age ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""member.Name"". 2. Condition Structure: No specific filtering condition is required as we want all members. 3. Join Structure: No JOIN is required since all necessary data is within the ""member"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the names of members. 5. Ordering Structure: Use ORDER BY on ""member.Age"" in ascending order to sort the results by age.",1.0
678,What is the average purchase price and the average sale price?,EASY,book_1,"[Book.PurchasePrice, Book.SalePrice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT AVG(Book.PurchasePrice) AS avg_purchase_price, AVG(Book.SalePrice) AS avg_sale_price FROM Book;","SELECT avg(purchaseprice) ,  avg(saleprice) FROM Book","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the average purchase price and the average sale price. 2. Aggregation Structure: Use the AVG function to calculate the average purchase price and the average sale price. 3. Grouping Structure: No GROUP BY is needed since we are calculating the overall averages. 4. Join Structure: No JOIN is required as all necessary data is within the ""Book"" table.",1.0
679,What is the title of the book that has been ordered the greatest number of times?,NON-NESTED,book_1,"[Book.Title, Books_Order.ISBN, Books_Order.amount, Books_Order.ISBN = Book.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book JOIN Books_Order ON Books_Order.ISBN = Book.ISBN GROUP BY Book.Title ORDER BY SUM(Books_Order.amount) DESC LIMIT 1;,SELECT T2.title FROM Books_Order AS T1 JOIN Book AS T2 ON T1.isbn  =  T2.isbn GROUP BY T1.isbn ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Book.Title"" of the book that has been ordered the greatest number of times. Use an aggregate function (SUM) on ""Books_Order.amount"" to calculate the total number of orders for each book. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the book with the highest total orders. 3. Join Structure: Use a JOIN between the ""Book"" and ""Books_Order"" tables based on the ""ISBN"" field to link each book with its order records. 4. Aggregation Structure: Use SUM to calculate the total number of orders for each book, then use ORDER BY in descending order on the aggregated total to rank books by the number of orders. Use LIMIT 1 to select the book with the greatest number of orders.",1.0
680,How many customers are there?,EASY,restaurant_bills,[customer.Customer_ID],"Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT COUNT(customer.Customer_ID) AS total_customers FROM customer;,SELECT count(*) FROM customer,"1. Sequential Structure: Start with the SELECT clause to count the total number of customers. 2. Aggregation Structure: Use the COUNT function to calculate the total number of unique customers based on ""customer.Customer_ID"". 3. Condition Structure: No specific filtering condition is required as we want the total count of all customers. 4. Join Structure: No JOIN is required since all necessary information is in the ""customer"" table.",1.0
681,What are the names and original artists of the song whose English translation is 'All the streets of love'?,EASY,sing_contest,"[songs.name, songs.original_artist, songs.english_translation, songs.english_translation = 'All the streets of love']","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
","SELECT songs.name, songs.original_artist FROM songs WHERE songs.english_translation = 'All the streets of love';","SELECT name ,  original_artist FROM songs WHERE english_translation  =  'All the streets of love'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""songs.name"" and ""songs.original_artist"" fields for the song whose English translation matches the given value. 2. Condition Structure: Use a WHERE clause to filter for the song where ""songs.english_translation"" is equal to 'All the streets of love'. 3. Join Structure: No JOIN is required since all necessary information is in the ""songs"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
682,Count the number of students living in China.,NON-NESTED,address_1,"[Student.city_code, City.country, Student.city_code = City.city_code, China]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT COUNT(Student.id) FROM Student JOIN City ON Student.city_code = City.city_code WHERE City.country = 'China';,"SELECT count(*) FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE T1.country  =  ""CHINA""","1. Sequential Structure: Start with the SELECT clause to count the number of students. Use COUNT on ""Student.id"" to get the total number of students. 2. Condition Structure: Use a WHERE clause to filter for students living in cities where the country is ""China."" 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to associate each student with their respective city and country. 4. Aggregation Structure: Use COUNT to aggregate the total number of students living in China.",0.0
683,What are the names of cities with at least three students?,NON-NESTED,address_1,"[City.city_name, Student.city_code, Student.StuID, Student.city_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.city_name FROM City JOIN Student ON City.city_code = Student.city_code GROUP BY City.city_name HAVING COUNT(Student.StuID) >= 3;,SELECT T1.city_name FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.city_code HAVING count(*)  >=  3,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of cities. Use COUNT to count the number of students in each city. 2. Condition Structure: Apply a HAVING clause to filter for cities with at least three students. 3. Join Structure: Use a JOIN between the ""City"" and ""Student"" tables based on the ""city_code"" field to associate each student with their respective city. 4. Aggregation Structure: Use COUNT on ""Student.StuID"" to count the number of students per city, then filter with HAVING to select cities with at least three students.",1.0
684,What are the names of the collections that are not the parent of the other collections?,NESTED,cre_Doc_and_collections,"[Collections.Collection_Name, Collections.Collection_ID, Collections.Parent_Collection_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collection_Name FROM Collections WHERE Collection_ID NOT IN (SELECT Parent_Collection_ID FROM Collections WHERE Parent_Collection_ID IS NOT NULL);,SELECT Collection_Name FROM Collections EXCEPT SELECT T2.Collection_Name FROM Collections AS T1 JOIN Collections AS T2 ON T1.Parent_Collection_ID = T2.Collection_ID;,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of collections. Use the FROM clause to specify the Collections table. Apply a WHERE clause to filter collections that are not the parent of any other collection. 2. Condition Structure: Use the WHERE clause with a subquery to exclude collections whose Collection_ID appears as a Parent_Collection_ID in the Collections table. 3. Join Structure: Not required, as all data is within the Collections table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
685,What are the document object ids of the related to the document owned by Ransom ?,NON-NESTED,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID,Document_Objects.Owner,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Related_Document_Object_ID,Document_Objects.Owner = 'Ransom']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Subset_Members.Related_Document_Object_ID FROM Document_Objects JOIN Document_Subset_Members ON Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID WHERE Document_Objects.Owner = 'Ransom';,select t1.document_object_id from document_subset_members as t1 join document_objects as t2 on t1.document_object_id  =  t2.document_object_id where t2.owner  =  'ransom',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subset_Members.Related_Document_Object_ID"" as we are interested in the related document object IDs. 2. Condition Structure: Use a WHERE clause to filter for documents owned by ""Ransom."" This requires filtering ""Document_Objects.Owner"" to match 'Ransom.' 3. Join Structure: Use a JOIN between ""Document_Objects"" and ""Document_Subset_Members"" on ""Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID"" to link documents with their related documents. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific related document object IDs.",1.0
686,What are the names of all parent collections of the collection named Nice?,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name, Collections.Parent_Collection_ID, Collections.Collection_ID = Collection_Subset_Members.Collection_ID, Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID, Nice]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collections.Collection_Name FROM Collections JOIN Collection_Subset_Members ON Collections.Collection_ID = Collection_Subset_Members.Related_Collection_ID WHERE Collection_Subset_Members.Collection_ID = (SELECT Collection_ID FROM Collections WHERE Collection_Name = 'Nice');,"SELECT T2.Collection_Name FROM Collections AS T1 JOIN Collections AS T2 ON T1.Parent_Collection_ID = T2.Collection_ID WHERE T1.Collection_Name = ""Nice"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collections.Collection_Name"" of the parent collections. 2. Condition Structure: Use a WHERE clause to filter for the collection named ""Nice"" and find its parent collections. 3. Join Structure: Use a JOIN between the ""Collections"" table and the ""Collection_Subset_Members"" table to link collections with their related collections. Then, use the ""Parent_Collection_ID"" field to identify the parent collections. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific names of parent collections.",1.0
687,"Which document subset has most of number of distinct documents ? List subset id , name and number of documents .",NON-NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name, Document_Subset_Members.Document_Object_ID, Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name, COUNT(DISTINCT Document_Subset_Members.Document_Object_ID) AS Number_of_Documents FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID GROUP BY Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name ORDER BY Number_of_Documents DESC LIMIT 1;","select t1.document_subset_id ,  t2.document_subset_name , count(distinct t1.document_object_id) from document_subset_members as t1 join document_subsets as t2 on t1.document_subset_id =  t2.document_subset_id group by t1.document_subset_id order by count(*) desc limit 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subsets.Document_Subset_ID,"" ""Document_Subsets.Document_Subset_Name,"" and the count of distinct ""Document_Subset_Members.Document_Object_ID"" for each subset. Use an alias for the count to represent the number of documents. 2. Condition Structure: No specific filtering condition is required, as we are interested in all subsets. 3. Join Structure: Use a JOIN between ""Document_Subsets"" and ""Document_Subset_Members"" on ""Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID"" to link subsets with their respective documents. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Document_Subset_Members.Document_Object_ID"" to count the unique documents for each subset. Use ORDER BY in descending order on the count to rank subsets by the number of documents, and LIMIT 1 to select the subset with the most documents.",0.0
688,What are all the distinct states?,EASY,address_1,[City.state],"Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT DISTINCT City.state FROM City;,SELECT DISTINCT state FROM City,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct states. 2. Condition Structure: No specific filtering condition is required as we want all distinct states. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""City"" table. 4. Aggregation Structure: Use DISTINCT to ensure only unique states are retrieved.",1.0
689,How many books do not have reviews?,NESTED,book_review,"[book.Book_ID, review.Book_ID, review.Book_ID = book.Book_ID]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT COUNT(*) FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM review);,SELECT count(*) FROM book WHERE Book_ID NOT IN (SELECT Book_ID FROM review),"1. Sequential Structure: Start with the SELECT clause to count the number of books. Use the FROM clause to specify the book table. Apply a WHERE clause to filter books that do not have reviews by ensuring their Book_ID is not present in the review table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude books whose Book_ID appears in the review table, meaning they have reviews. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Book_ID entries in the review table. 4. Aggregation Structure: Use the COUNT function to count the number of books that meet the condition of not having reviews.",1.0
690,"How many songs contain ""Love"" in their names?",EASY,sing_contest,[songs.name],"Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
",SELECT COUNT(*) FROM songs WHERE songs.name LIKE '%Love%';,"SELECT count(*) FROM songs WHERE name LIKE ""%Love%""","1. Sequential Structure: Start with the SELECT clause to count the number of songs that contain ""Love"" in their names. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for song names that contain the word ""Love"". 3. Join Structure: No JOIN is required since all necessary information is in the ""songs"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of songs that meet the condition.",1.0
691,List the names of customers that do not have any order.,NESTED,restaurant_bills,"[customer.Name, customer.Customer_ID, customer_order.Customer_ID = customer.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT customer.Name FROM customer WHERE customer.Customer_ID NOT IN (SELECT customer_order.Customer_ID FROM customer_order);,SELECT name FROM customer WHERE Customer_ID NOT IN (SELECT Customer_ID FROM customer_order),"1. Sequential Structure: Begin with the SELECT clause to retrieve the names of customers. Use the FROM clause to specify the customer table. Apply a WHERE clause to filter customers who do not have any orders by ensuring their Customer_ID is not present in the customer_order table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude customers whose Customer_ID appears in the customer_order table, meaning they have placed orders. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Customer_ID entries in the customer_order table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
692,How many collections does each document belong to? List the count and the document id.,NON-NESTED,cre_Doc_and_collections,"[Documents_in_Collections.Document_Object_ID, Documents_in_Collections.Collection_ID, Documents_in_Collections.Collection_ID = Collections.Collection_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Documents_in_Collections.Document_Object_ID, COUNT(Documents_in_Collections.Collection_ID) AS Collection_Count FROM Documents_in_Collections GROUP BY Documents_in_Collections.Document_Object_ID;","SELECT count(*) ,  T2.Document_Object_ID FROM Collections AS T1 JOIN Documents_in_Collections AS T2 ON T1.Collection_ID = T2.Collection_ID GROUP BY T2.Document_Object_ID","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Documents_in_Collections.Document_Object_ID"" and the count of collections each document belongs to. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: No JOIN is necessary as all the required information is available in the ""Documents_in_Collections"" table. 4. Aggregation Structure: Use COUNT on ""Documents_in_Collections.Collection_ID"" to count the number of collections for each document, and GROUP BY ""Documents_in_Collections.Document_Object_ID"" to group the results by document ID.",1.0
693,"Which song names have the substring ""Is""?",EASY,sing_contest,[songs.name],"Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
",SELECT songs.name FROM songs WHERE songs.name LIKE '%Is%';,"SELECT name FROM songs WHERE name LIKE ""%Is%""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""songs.name"" field, as the question asks for song names. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for song names that contain the substring ""Is"". 3. Join Structure: No JOIN is required since all necessary information is in the ""songs"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving song names based on a specific condition.",1.0
694,Count the number of customers.,EASY,restaurant_bills,[customer.Customer_ID],"Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT COUNT(customer.Customer_ID) AS customer_count FROM customer;,SELECT count(*) FROM customer,"1. Sequential Structure: Start with the SELECT clause to count the number of customers. 2. Condition Structure: No specific filtering condition is required as we want to count all customers. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""customer"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of customers.",1.0
695,What is the number of document object ids in the collection named Best?,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID = Documents_in_Collections.Collection_ID,Documents_in_Collections.Document_Object_ID,Best]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT COUNT(Documents_in_Collections.Document_Object_ID) FROM Collections JOIN Documents_in_Collections ON Collections.Collection_ID = Documents_in_Collections.Collection_ID WHERE Collections.Collection_Name = 'Best';,"SELECT T2.Document_Object_ID FROM Collections AS T1 JOIN Documents_in_Collections AS T2 ON T1.Collection_ID = T2.Collection_ID WHERE T1.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to count the number of ""Documents_in_Collections.Document_Object_ID."" 2. Condition Structure: Use a WHERE clause to filter for the collection named ""Best."" 3. Join Structure: Use a JOIN between the ""Collections"" table and the ""Documents_in_Collections"" table based on ""Collections.Collection_ID = Documents_in_Collections.Collection_ID"" to link collections with their documents. 4. Aggregation Structure: Use COUNT to calculate the total number of document object IDs for the specified collection.",0.0
696,How many documents owned by Marlin?,EASY,cre_Doc_and_collections,"[Document_Objects.Owner, Document_Objects.Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT COUNT(Document_Objects.Document_Object_ID) FROM Document_Objects WHERE Document_Objects.Owner = 'Marlin';,"SELECT count(*) FROM Document_Objects WHERE OWNER = ""Marlin"";","1. Sequential Structure: Begin with the SELECT clause to count the number of documents owned by ""Marlin"". 2. Condition Structure: Use a WHERE clause to filter records where ""Document_Objects.Owner"" is ""Marlin"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Document_Objects"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of documents owned by ""Marlin"".",1.0
697,Which document has most of child? List the document id and the number of child.,EASY,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID,Document_Objects.Parent_Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Objects.Parent_Document_Object_ID AS document_id, COUNT(*) AS number_of_children FROM Document_Objects GROUP BY Document_Objects.Parent_Document_Object_ID ORDER BY COUNT(*) DESC LIMIT 1;","SELECT T2.Document_Object_ID ,  count(*) FROM Document_Objects AS T1 JOIN Document_Objects AS T2 ON T1.Parent_Document_Object_ID = T2.Document_Object_ID GROUP BY T2.Document_Object_ID ORDER BY count(*) DESC LIMIT 1;","1. Sequential Structure: Begin with the SELECT clause to specify the document ID and the count of its children. 2. Aggregation Structure: Use COUNT to calculate the number of children for each document. 3. Grouping Structure: Use GROUP BY on ""Document_Objects.Parent_Document_Object_ID"" to group the results by parent document ID. 4. Ordering Structure: Use ORDER BY in descending order on the count of children to rank documents by the number of children. 5. Limiting Structure: Use LIMIT 1 to retrieve the document with the most children. 6. Join Structure: No JOIN is required since all necessary data is within the ""Document_Objects"" table.",1.0
698,Show all client names and the number of orders each has made.,NON-NESTED,book_1,"[Client.Name, Orders.IdClient, Client.IdClient = Orders.IdClient]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Client.Name, COUNT(Orders.IdClient) AS NumberOfOrders FROM Client JOIN Orders ON Client.IdClient = Orders.IdClient GROUP BY Client.Name;","SELECT T2.name ,  count(*) FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient GROUP BY T1.idClient","1. Sequential Structure: Start with the SELECT clause to retrieve ""Client.Name"" and the count of orders made by each client. Use COUNT on ""Orders.IdClient"" to count the number of orders. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""Client"" table with the ""Orders"" table based on the relationship ""Client.IdClient = Orders.IdClient."" 4. Aggregation Structure: Use COUNT to aggregate the number of orders for each client and GROUP BY ""Client.Name"" to group the results by client.",1.0
699,What is the rank of the book with the smallest number of pages?,NESTED,book_review,"[book.Pages, book.Book_ID, review.Rank, review.Book_ID = book.Book_ID]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT review.Rank FROM book JOIN review ON book.Book_ID = review.Book_ID WHERE book.Pages = (SELECT MIN(Pages) FROM book);,SELECT T2.Rank FROM book AS T1 JOIN review AS T2 ON T1.Book_ID  =  T2.Book_ID ORDER BY T1.Pages ASC LIMIT 1,1. Sequential Structure: Start with the SELECT clause to retrieve the rank of the book. Use the FROM clause to specify the book and review tables. Apply a WHERE clause to filter for the book with the smallest number of pages. 2. Condition Structure: Use the WHERE clause with a subquery to identify the book with the smallest number of pages by using the MIN function on the Pages column. 3. Join Structure: Use an INNER JOIN between the book and review tables based on the Book_ID to connect book details with their ranks. 4. Aggregation Structure: Use the MIN function in a subquery to find the book with the smallest number of pages.,1.0
700,What are the types and release dates of books?,EASY,book_review,"[book.Type, book.Release]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
","SELECT book.Type, book.Release FROM book;","SELECT TYPE ,  Release FROM book","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""book.Type"" and ""book.Release"". 2. Condition Structure: No specific filtering condition is required as the query asks for all types and release dates of books. 3. Join Structure: No JOIN is required since all necessary information is available in the ""book"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the type and release date of books.",1.0
701,"For the document subset with the most number of different documents , what are the ids and names of the subset , as well as the number of documents ?",NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name, Document_Subset_Members.Document_Object_ID, Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name, COUNT(DISTINCT Document_Subset_Members.Document_Object_ID) AS Number_of_Documents FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subsets.Document_Subset_ID = Document_Subset_Members.Document_Subset_ID GROUP BY Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name ORDER BY Number_of_Documents DESC LIMIT 1;","select t1.document_subset_id ,  t2.document_subset_name , count(distinct t1.document_object_id) from document_subset_members as t1 join document_subsets as t2 on t1.document_subset_id =  t2.document_subset_id group by t1.document_subset_id order by count(*) desc limit 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the subset IDs, names, and the count of distinct documents. Use the FROM clause to specify the Document_Subsets table and JOIN it with the Document_Subset_Members table to link subsets with their documents. Use GROUP BY to group by subset ID and name, and apply ORDER BY to sort by the count of distinct documents in descending order. Use LIMIT to retrieve only the subset with the most documents. 2. Condition Structure: No specific filtering condition is required, as we are interested in all subsets and their document counts. 3. Join Structure: Use an INNER JOIN between Document_Subsets and Document_Subset_Members on Document_Subset_ID to connect subsets with their documents. 4. Aggregation Structure: Use COUNT(DISTINCT Document_Object_ID) to count the number of distinct documents in each subset.",0.0
702,How many students live in China?,NON-NESTED,address_1,"[Student.city_code, City.country, Student.city_code = City.city_code, China]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT COUNT(Student.id) FROM Student JOIN City ON Student.city_code = City.city_code WHERE City.country = 'China';,"SELECT count(*) FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE T1.country  =  ""CHINA""","1. Sequential Structure: Start with the SELECT clause to count the number of students. Use COUNT on ""Student.id"" to get the total number of students. 2. Condition Structure: Use a WHERE clause to filter for students who live in cities located in China. This requires filtering ""City.country"" for ""China."" 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the shared ""city_code"" field to associate each student with their respective city and country. 4. Aggregation Structure: Use COUNT to aggregate the total number of students who meet the condition.",0.0
703,List all book titles which have sale prices higher than the average.,NESTED,book_1,"[Book.Title, Book.SalePrice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Title FROM Book WHERE SalePrice > (SELECT AVG(SalePrice) FROM Book);,SELECT title FROM book WHERE saleprice  >  (SELECT avg(saleprice) FROM book),"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of books. Use the FROM clause to specify the Book table. Apply a WHERE clause to filter books whose sale prices are higher than the average sale price. 2. Condition Structure: Use the WHERE clause with a subquery to compare each book's sale price to the average sale price. The subquery calculates the average sale price from the Book table. 3. Join Structure: Not required, as all data is in the Book table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average sale price, which is then used in the filtering condition.",1.0
704,What are the different document object ids in the subset named 'Best for 2000' and in the collection named 'Best'?,NON-NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_Name,Document_Subsets.Document_Subset_ID,Document_Subset_Members.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Collections.Collection_Name,Collections.Collection_ID,Documents_in_Collections.Document_Object_ID,Documents_in_Collections.Collection_ID = Collections.Collection_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT DISTINCT Document_Subset_Members.Document_Object_ID FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID JOIN Documents_in_Collections ON Documents_in_Collections.Document_Object_ID = Document_Subset_Members.Document_Object_ID JOIN Collections ON Documents_in_Collections.Collection_ID = Collections.Collection_ID WHERE Document_Subsets.Document_Subset_Name = 'Best for 2000' AND Collections.Collection_Name = 'Best';,"SELECT DISTINCT T1.Document_Object_ID FROM Document_Subset_Members AS T1 JOIN Document_Subsets AS T2 ON T1.Document_Subset_ID =  T2.Document_Subset_ID JOIN Documents_in_Collections AS T3 ON T1.Document_Object_ID  =  T3.Document_Object_ID JOIN Collections AS T4 ON T3.Collection_ID  =  T4.Collection_ID WHERE T2.Document_Subset_Name = ""Best for 2000"" AND T4.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Document_Subset_Members.Document_Object_ID"" since we are interested in the unique document object IDs. 2. Condition Structure: Use a WHERE clause to filter for the subset named ""Best for 2000"" and the collection named ""Best."" 3. Join Structure: Use JOINs to connect the relevant tables: - Join ""Document_Subsets"" with ""Document_Subset_Members"" on ""Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID"" to link subsets with their members. - Join ""Collections"" with ""Documents_in_Collections"" on ""Documents_in_Collections.Collection_ID = Collections.Collection_ID"" to link collections with their documents. - Use an additional condition to ensure the document object IDs match between ""Document_Subset_Members"" and ""Documents_in_Collections."" 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique document object IDs are returned.",1.0
705,"What is the average number of readers for books of type ""Novel""?",NON-NESTED,book_review,"[book.Type, book.Book_ID, review.Book_ID = book.Book_ID, review.Readers_in_Million, Novel]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT AVG(review.Readers_in_Million) FROM book JOIN review ON review.Book_ID = book.Book_ID WHERE book.Type = 'Novel';,"SELECT avg(T2.Readers_in_Million) FROM book AS T1 JOIN review AS T2 ON T1.Book_ID  =  T2.Book_ID WHERE T1.Type  =  ""Novel""","1. Sequential Structure: Start with the SELECT clause to calculate the average number of readers for books of type ""Novel."" Use the AVG function on the ""review.Readers_in_Million"" field. 2. Condition Structure: Use a WHERE clause to filter for books where the ""book.Type"" is ""Novel."" 3. Join Structure: Use a JOIN between the ""book"" and ""review"" tables based on the ""Book_ID"" field to associate books with their reviews. 4. Aggregation Structure: Use the AVG function to compute the average number of readers for the filtered books.",1.0
706,What are the collection susbset names?,EASY,cre_Doc_and_collections,[Collection_Subsets.Collection_Subset_Name],"Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collection_Subsets.Collection_Subset_Name FROM Collection_Subsets;,SELECT Collection_Subset_Name FROM Collection_Subsets;,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is ""Collection_Subsets.Collection_Subset_Name"". 2. Condition Structure: No specific filtering condition is required as the query aims to retrieve all collection subset names. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""Collection_Subsets"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all collection subset names.",1.0
707,List document that have more than one child. List the document id.,EASY,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID,Document_Objects.Parent_Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Objects.Parent_Document_Object_ID AS document_id FROM Document_Objects GROUP BY Document_Objects.Parent_Document_Object_ID HAVING COUNT(Document_Objects.Document_Object_ID) > 1;,SELECT T2.Document_Object_ID FROM Document_Objects AS T1 JOIN Document_Objects AS T2 ON T1.Parent_Document_Object_ID = T2.Document_Object_ID GROUP BY T2.Document_Object_ID HAVING count(*)  >  1;,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the document ID. 2. Aggregation Structure: Use COUNT to determine the number of children for each document. 3. Grouping Structure: Use GROUP BY on ""Document_Objects.Parent_Document_Object_ID"" to aggregate the results by each parent document ID. 4. Condition Structure: Apply the HAVING clause to filter for documents that have more than one child, by setting the count to be greater than 1. 5. Join Structure: No JOIN is required since all necessary data is within the ""Document_Objects"" table.",1.0
708,Give the maximum and minimum sale price of books.,EASY,book_1,[Book.SalePrice],"Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT MAX(Book.SalePrice) AS max_sale_price, MIN(Book.SalePrice) AS min_sale_price FROM Book;","SELECT max(saleprice) ,  min(saleprice) FROM Book","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum sale prices of books. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum sale prices, respectively. 3. Grouping Structure: No GROUP BY is needed since we are calculating the overall maximum and minimum sale prices across all books. 4. Join Structure: No JOIN is required as all necessary data is within the ""Book"" table.",1.0
709,"For document subset named 'Best for 2000', List all document id that in this subset.",NON-NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_Name,Document_Subsets.Document_Subset_ID,Document_Subset_Members.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,'Best for 2000']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Subset_Members.Document_Object_ID FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID WHERE Document_Subsets.Document_Subset_Name = 'Best for 2000';,"SELECT DISTINCT T1.Document_Object_ID FROM Document_Subset_Members AS T1 JOIN Document_Subsets AS T2 ON T1.Document_Subset_ID =  T2.Document_Subset_ID WHERE T2.Document_Subset_Name = ""Best for 2000"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subset_Members.Document_Object_ID,"" which corresponds to the document IDs in the subset. 2. Condition Structure: Use a WHERE clause to filter for the subset named ""Best for 2000."" This requires matching ""Document_Subsets.Document_Subset_Name"" with the given name. 3. Join Structure: Use a JOIN between ""Document_Subsets"" and ""Document_Subset_Members"" on ""Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID"" to link subsets with their members. 4. Aggregation Structure: No aggregation is needed as we are listing all document IDs in the specified subset.",1.0
710,Show the customers with total quantity of order bigger than 1.,NON-NESTED,restaurant_bills,"[customer.Customer_ID, customer_order.Customer_ID, customer_order.Quantity, customer_order.Customer_ID = customer.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT customer.Customer_ID FROM customer JOIN customer_order ON customer.Customer_ID = customer_order.Customer_ID GROUP BY customer.Customer_ID HAVING SUM(customer_order.Quantity) > 1;,SELECT T1.Name FROM customer AS T1 JOIN customer_order AS T2 ON T1.Customer_ID  =  T2.Customer_ID GROUP BY T1.Name HAVING sum(T2.Quantity)  >  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the customer information. Since we need to find customers with a total quantity of orders greater than 1, include ""customer.Customer_ID"" in the SELECT clause. 2. Condition Structure: Use a HAVING clause to filter customers whose total quantity of orders exceeds 1. 3. Join Structure: Use an INNER JOIN to connect the ""customer"" table with the ""customer_order"" table based on the ""Customer_ID"" field. 4. Aggregation Structure: Use SUM on ""customer_order.Quantity"" to calculate the total quantity of orders for each customer, then filter using the HAVING clause.",0.0
711,"What are the id, language and original artist of the songs whose name is not 'Love'?",EASY,sing_contest,"[songs.id, songs.language, songs.original_artist, songs.name]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
","SELECT songs.id, songs.language, songs.original_artist FROM songs WHERE songs.name != 'Love';","SELECT id ,  LANGUAGE ,  original_artist FROM songs WHERE name != 'Love'","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""songs.id"", ""songs.language"", and ""songs.original_artist"". 2. Condition Structure: Use a WHERE clause to filter songs where the ""songs.name"" is not equal to 'Love'. 3. Join Structure: No JOIN is required since all necessary data is within the ""songs"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific fields based on a condition.",1.0
712,Show the most common nationality of customers.,EASY,restaurant_bills,[customer.Nationality],"Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT customer.Nationality FROM customer GROUP BY customer.Nationality ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Nationality FROM customer GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the nationality of customers, as we are looking for the most common nationality. 2. Aggregation Structure: Use COUNT to calculate the number of occurrences of each nationality. 3. Grouping Structure: Use GROUP BY on ""customer.Nationality"" to group the results by each nationality. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank nationalities by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve only the most common nationality. 6. Join Structure: No JOIN is required since all necessary data is within the ""customer"" table.",1.0
713,What are the names of all cities in PA?,EASY,address_1,"[City.city_name,City.state,PA]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.city_name FROM City WHERE City.state = 'PA';,"SELECT city_name FROM City WHERE state  =  ""PA""","1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the city name. 2. Condition Structure: Use a WHERE clause to filter cities where the state is 'PA'. 3. Join Structure: No JOIN is required since all necessary information is in the ""City"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving city names based on a specific condition.",1.0
714,Show the nations that have at least two members.,EASY,club_leader,"[member.Nationality, member.Member_ID, club_leader.Member_ID = member.Member_ID]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT member.Nationality FROM member GROUP BY member.Nationality HAVING COUNT(member.Member_ID) >= 2;,SELECT Nationality FROM member GROUP BY Nationality HAVING COUNT(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to specify the nationality of members, as the question asks for nations with at least two members. 2. Aggregation Structure: Use COUNT to count the number of members for each nationality. 3. Grouping Structure: Use GROUP BY on ""member.Nationality"" to group the results by nationality. 4. Condition Structure: Apply the HAVING clause to filter for nationalities with at least two members, by setting the count to be greater than or equal to 2. 5. Join Structure: No JOIN is required since all necessary data is within the ""member"" table.",1.0
715,What is the owner of the parent document of document owned by 'Marlin'?,NESTED,cre_Doc_and_collections,"[Document_Objects.Owner, Document_Objects.Parent_Document_Object_ID, Document_Objects.Document_Object_ID = Document_Subset_Members.Document_Object_ID, Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID, 'Marlin']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT parent.Owner FROM Document_Objects AS child JOIN Document_Subset_Members ON child.Document_Object_ID = Document_Subset_Members.Document_Object_ID JOIN Document_Objects AS parent ON Document_Subset_Members.Related_Document_Object_ID = parent.Document_Object_ID WHERE child.Owner = 'Marlin';,SELECT T2.Owner FROM Document_Objects AS T1 JOIN Document_Objects AS T2 ON T1.Parent_Document_Object_ID = T2.Document_Object_ID WHERE T1.Owner  =  'Marlin',"1. Sequential Structure: Start with the SELECT clause to retrieve the owner of the parent document. Use the FROM clause to specify the Document_Objects table. Use JOINs to connect the Document_Objects table with the Document_Subset_Members table to trace the relationships between documents. Apply a WHERE clause to filter for the document owned by 'Marlin' and trace its parent document. 2. Condition Structure: Use the WHERE clause to filter for the document owned by 'Marlin' and then trace its parent document using the Parent_Document_Object_ID field. 3. Join Structure: Use JOINs between Document_Objects and Document_Subset_Members to connect the document relationships and trace the parent document. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
716,Which unique subset does document owned by Braeden belong to? List the subset name.,NON-NESTED,cre_Doc_and_collections,"[Document_Objects.Owner, Document_Objects.Document_Object_ID, Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID, Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name, Braeden]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT DISTINCT Document_Subsets.Document_Subset_Name FROM Document_Objects JOIN Document_Subset_Members ON Document_Objects.Document_Object_ID = Document_Subset_Members.Document_Object_ID JOIN Document_Subsets ON Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID WHERE Document_Objects.Owner = 'Braeden';,SELECT DISTINCT T1.Document_Subset_Name FROM Document_Subsets AS T1 JOIN Document_Subset_Members AS T2 ON T1.Document_Subset_ID =  T2.Document_Subset_ID JOIN Document_Objects AS T3 ON T2.Document_Object_ID  =  T3.Document_Object_ID WHERE T3.owner  =  'Braeden',"1. Sequential Structure: Start with the SELECT clause to retrieve the unique subset name, ""Document_Subsets.Document_Subset_Name."" 2. Condition Structure: Use a WHERE clause to filter for documents owned by ""Braeden"" in the ""Document_Objects"" table. 3. Join Structure: Use JOINs to connect the ""Document_Objects"" table with ""Document_Subset_Members"" on ""Document_Object_ID,"" and then connect ""Document_Subset_Members"" with ""Document_Subsets"" on ""Document_Subset_ID"" to link documents with their subsets. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique subset names are returned.",1.0
717,List titles of all books published by an author whose name contains the string 'Plato'?,NON-NESTED,book_1,"[Book.Title,Author.Name,Author_Book.ISBN = Book.ISBN,Author_Book.Author = Author.idAuthor,'Plato']","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book JOIN Author_Book ON Author_Book.ISBN = Book.ISBN JOIN Author ON Author_Book.Author = Author.idAuthor WHERE Author.Name LIKE '%Plato%';,"SELECT T1.title FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T3.name LIKE ""%Plato%""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Book.Title"" field, as the question asks for the titles of books. 2. Condition Structure: Use a WHERE clause to filter for authors whose name contains the string 'Plato'. This will involve the ""Author.Name"" field. 3. Join Structure: Use JOINs to connect the ""Book"" table with the ""Author_Book"" table on ""Book.ISBN = Author_Book.ISBN"" and the ""Author_Book"" table with the ""Author"" table on ""Author_Book.Author = Author.idAuthor"" to link books with their respective authors. 4. Aggregation Structure: No aggregation is needed, as the query only requires listing book titles.",1.0
718,Show the names of members whose age is either 19 or 20.,EASY,club_leader,"[member.Name, member.Age]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT member.Name FROM member WHERE member.Age = 19 OR member.Age = 20;,SELECT Name FROM member WHERE Age  =  19 OR Age  =  20,"1. Sequential Structure: Start with the SELECT clause to specify the field ""member.Name"" as we are interested in the names of members. 2. Condition Structure: Use a WHERE clause to filter members whose age is either 19 or 20. 3. Join Structure: No JOIN is required since all necessary information is in the ""member"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on the specified age condition.",1.0
719,Show all countries and number of cities in each .,EASY,address_1,"[City.country, City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.country, COUNT(City.city_code) AS number_of_cities FROM City GROUP BY City.country;","select country ,  count(*) from city group by country","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the country and the count of cities. 2. Aggregation Structure: Use COUNT to calculate the number of cities in each country. 3. Grouping Structure: Use GROUP BY on ""City.country"" to group the results by each country. 4. Join Structure: No JOIN is required since all necessary data is within the ""City"" table.",1.0
720,Give the state that has the most cities.,EASY,address_1,"[City.state, City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.state FROM City GROUP BY City.state ORDER BY COUNT(City.city_code) DESC LIMIT 1;,SELECT state FROM City GROUP BY state ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the state, as the question asks for the state with the most cities. 2. Aggregation Structure: Use COUNT to calculate the number of cities in each state. 3. Grouping Structure: Use GROUP BY on ""City.state"" to group the cities by state. 4. Ordering Structure: Use ORDER BY in descending order on the count of cities to rank states by the number of cities they have. 5. Limiting Structure: Use LIMIT 1 to retrieve only the state with the most cities. 6. Join Structure: No JOIN is required since all necessary data is within the ""City"" table.",1.0
721,List id of documents that in document subset Best for 2000 and collection named Best.,NON-NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_ID,Document_Subsets.Document_Subset_Name,Document_Subset_Members.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Collections.Collection_ID,Collections.Collection_Name,Documents_in_Collections.Document_Object_ID,Documents_in_Collections.Collection_ID = Collections.Collection_ID,Best for 2000,Best]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Subset_Members.Document_Object_ID FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID JOIN Documents_in_Collections ON Document_Subset_Members.Document_Object_ID = Documents_in_Collections.Document_Object_ID JOIN Collections ON Documents_in_Collections.Collection_ID = Collections.Collection_ID WHERE Document_Subsets.Document_Subset_Name = 'Best for 2000' AND Collections.Collection_Name = 'Best';,"SELECT DISTINCT T1.Document_Object_ID FROM Document_Subset_Members AS T1 JOIN Document_Subsets AS T2 ON T1.Document_Subset_ID =  T2.Document_Subset_ID JOIN Documents_in_Collections AS T3 ON T1.Document_Object_ID  =  T3.Document_Object_ID JOIN Collections AS T4 ON T3.Collection_ID  =  T4.Collection_ID WHERE T2.Document_Subset_Name = ""Best for 2000"" AND T4.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subset_Members.Document_Object_ID,"" which represents the IDs of the documents. 2. Condition Structure: Use WHERE clauses to filter for the document subset named ""Best for 2000"" and the collection named ""Best."" 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""Document_Subsets"" with ""Document_Subset_Members"" on ""Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID"" to link document subsets with their members. Then, join ""Collections"" with ""Documents_in_Collections"" on ""Documents_in_Collections.Collection_ID = Collections.Collection_ID"" to link collections with their documents. Finally, join the results on ""Document_Subset_Members.Document_Object_ID = Documents_in_Collections.Document_Object_ID"" to ensure the document IDs match across subsets and collections. 4. Aggregation Structure: No aggregation is needed, as the query only retrieves document IDs that meet the specified conditions.",1.0
722,"What are the titles of books that the client Peter Doe ordered, but the client James Smith did not?",NESTED,book_1,"[Client.Name, Orders.IdClient, Orders.IdOrder, Books_Order.IdOrder = Orders.IdOrder, Books_Order.ISBN, Book.ISBN = Books_Order.ISBN, Book.Title]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book JOIN Books_Order ON Book.ISBN = Books_Order.ISBN JOIN Orders ON Books_Order.IdOrder = Orders.IdOrder JOIN Client ON Orders.IdClient = Client.IdClient WHERE Client.Name = 'Peter Doe' AND Book.ISBN NOT IN ( SELECT Book.ISBN FROM Book JOIN Books_Order ON Book.ISBN = Books_Order.ISBN JOIN Orders ON Books_Order.IdOrder = Orders.IdOrder JOIN Client ON Orders.IdClient = Client.IdClient WHERE Client.Name = 'James Smith' );,"SELECT T4.title FROM Orders AS T1 JOIN Books_Order AS T2 ON T1.idOrder  =  T2.idOrder JOIN Client AS T3 ON T1.idClient  =  T3.idClient JOIN book AS T4 ON T2.ISBN  =  T4.isbn WHERE T3.name  =  ""Peter Doe"" EXCEPT SELECT T4.title FROM Orders AS T1 JOIN Books_Order AS T2 ON T1.idOrder  =  T2.idOrder JOIN Client AS T3 ON T1.idClient  =  T3.idClient JOIN book AS T4 ON T2.ISBN  =  T4.isbn WHERE T3.name  =  ""James Smith""","1. Sequential Structure: Start with the SELECT clause to retrieve the titles of books. Use the FROM clause to specify the Book table and join it with the Books_Order and Orders tables to link books with orders and clients. Apply a WHERE clause to filter books ordered by the client ""Peter Doe"" but not by ""James Smith"". 2. Condition Structure: Use the WHERE clause to filter for orders made by ""Peter Doe"". Use a subquery to exclude books ordered by ""James Smith"". 3. Join Structure: Use JOINs between the Book, Books_Order, and Orders tables to connect book titles with client orders. Additionally, join the Client table to filter by client names. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
723,How many performances have a stage presence score less than 7 or higher than 9?,EASY,sing_contest,"[performance_score.stage_presence,7,9]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
",SELECT COUNT(*) FROM performance_score WHERE performance_score.stage_presence < 7 OR performance_score.stage_presence > 9;,SELECT count(*) FROM performance_score WHERE stage_presence  <  7 OR stage_presence  >  9,"1. Sequential Structure: Start with the SELECT clause to count the number of performances that meet the specified stage presence score conditions. 2. Condition Structure: Use a WHERE clause to filter performances where the ""performance_score.stage_presence"" is less than 7 or greater than 9. 3. Join Structure: No JOIN is required since all necessary information is in the ""performance_score"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of performances that meet the specified conditions.",1.0
724,"For the document subset named 'Best for 2000', what are the document ids in that subset?",NON-NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_Name, Document_Subsets.Document_Subset_ID, Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID, Document_Subset_Members.Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Subset_Members.Document_Object_ID FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subsets.Document_Subset_ID = Document_Subset_Members.Document_Subset_ID WHERE Document_Subsets.Document_Subset_Name = 'Best for 2000';,"SELECT DISTINCT T1.Document_Object_ID FROM Document_Subset_Members AS T1 JOIN Document_Subsets AS T2 ON T1.Document_Subset_ID =  T2.Document_Subset_ID WHERE T2.Document_Subset_Name = ""Best for 2000"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subset_Members.Document_Object_ID,"" which represents the document IDs in the subset. 2. Condition Structure: Use a WHERE clause to filter for the subset named ""Best for 2000"" by matching ""Document_Subsets.Document_Subset_Name."" 3. Join Structure: Use a JOIN between ""Document_Subsets"" and ""Document_Subset_Members"" on ""Document_Subsets.Document_Subset_ID"" and ""Document_Subset_Members.Document_Subset_ID"" to link subsets with their members. 4. Aggregation Structure: No aggregation is needed as we are retrieving individual document IDs.",1.0
725,Give the country with the fewest students.,NON-NESTED,address_1,"[Student.StuID, Student.city_code, City.city_code, City.country, Student.city_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.country, COUNT(Student.StuID) AS student_count FROM Student JOIN City ON Student.city_code = City.city_code GROUP BY City.country ORDER BY student_count ASC LIMIT 1;",SELECT T1.country FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.country ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.country"" and the count of students. Use an aggregate function (COUNT) to count the number of students in each country. 2. Condition Structure: No specific filtering condition is required, as we are interested in all countries. 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to associate each student with their respective country. 4. Aggregation Structure: Use COUNT to count the number of students per country, GROUP BY ""City.country"" to group the results by country, and ORDER BY the count in ascending order to find the country with the fewest students. Use LIMIT 1 to select only the country with the fewest students.",1.0
726,Show names for all cities where at least three students live.,NON-NESTED,address_1,"[City.city_name, Student.city_code, City.city_code = Student.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.city_name FROM City JOIN Student ON City.city_code = Student.city_code GROUP BY City.city_name HAVING COUNT(Student.city_code) >= 3;,SELECT T1.city_name FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.city_code HAVING count(*)  >=  3,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.city_name."" 2. Condition Structure: Use a HAVING clause to filter for cities where the count of students is at least three. 3. Join Structure: Use a JOIN between the ""City"" and ""Student"" tables based on the ""city_code"" field to associate each city with its students. 4. Aggregation Structure: Use COUNT on ""Student.city_code"" to count the number of students per city, then filter with HAVING to select cities with at least three students.",1.0
727,What is the card credit of the customer with the highest membership level?,EASY,restaurant_bills,"[customer.Card_Credit, customer.Level_of_Membership]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT customer.Card_Credit FROM customer ORDER BY customer.Level_of_Membership DESC LIMIT 1;,SELECT Card_Credit FROM customer ORDER BY Level_of_Membership DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""customer.Card_Credit"" of the customer with the highest membership level. 2. Condition Structure: No specific filtering condition is needed since we are looking for the customer with the highest membership level. 3. Join Structure: No JOIN is required as all necessary information is in the ""customer"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""customer.Level_of_Membership"" to rank customers by membership level and apply LIMIT 1 to select the customer with the highest membership level.",1.0
728,List all documents's subset. List the subset's name.,EASY,cre_Doc_and_collections,[Document_Subsets.Document_Subset_Name],"Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Subsets.Document_Subset_Name FROM Document_Subsets;,SELECT Document_Subset_Name FROM Document_Subsets;,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the subset name from the ""Document_Subsets"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for all document subsets. 3. Join Structure: No JOIN is required since all necessary data is within the ""Document_Subsets"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all subset names.",1.0
729,What is the object id of the document objects?,EASY,cre_Doc_and_collections,[Document_Objects.Document_Object_ID],"Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Objects.Document_Object_ID FROM Document_Objects;,SELECT Document_Object_ID FROM Document_Objects;,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the ""Document_Object_ID"". 2. Condition Structure: No specific filtering condition is required as the query aims to retrieve all document object IDs. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""Document_Objects"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the object IDs.",1.0
730,What is the maximum difference between the sale price and purchase price?,EASY,book_1,"[Book.SalePrice, Book.PurchasePrice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT MAX(Book.SalePrice - Book.PurchasePrice) AS max_difference FROM Book;,SELECT max(saleprice - purchaseprice) FROM Book,"1. Sequential Structure: Begin with the SELECT clause to calculate the maximum difference between the sale price and purchase price. 2. Aggregation Structure: Use the MAX function to find the maximum difference. The difference is calculated as ""Book.SalePrice - Book.PurchasePrice"". 3. Join Structure: No JOIN is required since all necessary data is within the ""Book"" table. 4. Condition Structure: No specific filtering condition is needed as we are calculating the maximum difference across all records.",1.0
731,What are the titles and ratings of books?,NON-NESTED,book_review,"[book.Title, review.Rating, review.Book_ID = book.Book_ID]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
","SELECT book.Title, review.Rating FROM book JOIN review ON review.Book_ID = book.Book_ID;","SELECT T1.Title ,  T2.Rating FROM book AS T1 JOIN review AS T2 ON T1.Book_ID  =  T2.Book_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""book.Title"" and ""review.Rating."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""book"" and ""review"" tables based on the shared key ""Book_ID"" to link each book with its ratings. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the titles and ratings of books.",1.0
732,What are the titles of books with sale prices above the average sale price across all books?,NESTED,book_1,"[Book.Title,Book.SalePrice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Title FROM Book WHERE SalePrice > (SELECT AVG(SalePrice) FROM Book);,SELECT title FROM book WHERE saleprice  >  (SELECT avg(saleprice) FROM book),"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of books. Use the FROM clause to specify the Book table. Apply a WHERE clause to filter books with sale prices above the average sale price. 2. Condition Structure: Use the WHERE clause with a subquery to compare each book's sale price to the average sale price across all books. The subquery calculates the average sale price. 3. Join Structure: Not required, as all data is in the Book table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average sale price of all books, which is then used in the filtering condition.",1.0
733,Which club name contains the string 'state'?,EASY,club_leader,[club.Club_Name],"Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT club.Club_Name FROM club WHERE club.Club_Name LIKE '%state%';,SELECT club_name FROM club WHERE club_name LIKE '%state%',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""club.Club_Name"" of the clubs whose names contain the string 'state'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for club names that contain the string 'state'. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""club"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
734,Which document has least number of related documents? List the document id and the number of related documents.,NON-NESTED,cre_Doc_and_collections,"[Document_Subset_Members.Document_Object_ID, Document_Subset_Members.Related_Document_Object_ID, Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Subset_Members.Document_Object_ID, COUNT(Document_Subset_Members.Related_Document_Object_ID) AS related_count FROM Document_Subset_Members GROUP BY Document_Subset_Members.Document_Object_ID ORDER BY related_count ASC LIMIT 1;","SELECT Document_Object_ID , count(*) FROM Document_Subset_Members GROUP BY Document_Object_ID ORDER BY count(*) ASC LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Object_ID"" and the count of related documents. Use COUNT to calculate the number of related documents for each document. 2. Condition Structure: No specific filtering condition is required, as we need to consider all documents. 3. Join Structure: No JOIN is necessary since all the required data is available in the ""Document_Subset_Members"" table. 4. Aggregation Structure: Use GROUP BY on ""Document_Object_ID"" to group the results by each document. Use ORDER BY in ascending order of the count of related documents and LIMIT 1 to find the document with the least number of related documents.",1.0
735,What is the name of the client with the most number of orders?,NON-NESTED,book_1,"[Client.Name, Orders.IdClient, COUNT(Orders.IdOrder), Orders.IdClient = Client.IdClient]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Client.Name, COUNT(Orders.IdOrder) AS OrderCount FROM Client JOIN Orders ON Orders.IdClient = Client.IdClient GROUP BY Client.Name ORDER BY OrderCount DESC LIMIT 1;",SELECT T2.name FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient GROUP BY T1.idClient ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Client.Name"" and the count of orders for each client. Use COUNT on ""Orders.IdOrder"" to count the number of orders per client. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the client with the most orders. 3. Join Structure: Use a JOIN between the ""Client"" and ""Orders"" tables based on ""Orders.IdClient = Client.IdClient"" to associate each client with their orders. 4. Aggregation Structure: Use GROUP BY on ""Client.Name"" to group the results by client. Use ORDER BY in descending order on the count of orders to rank clients by the number of orders. Use LIMIT 1 to select the client with the most orders.",1.0
736,"What are the voice sound quality score, rhythm tempo score and stage presence score performed by the participant named 'Freeway'?",NON-NESTED,sing_contest,"[participants.name,performance_score.voice_sound_quality,performance_score.rhythm_tempo,performance_score.stage_presence,performance_score.participant_id = participants.id,Freeway]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
","SELECT performance_score.voice_sound_quality, performance_score.rhythm_tempo, performance_score.stage_presence FROM participants JOIN performance_score ON performance_score.participant_id = participants.id WHERE participants.name = 'Freeway';","SELECT T1.voice_sound_quality ,  T1.rhythm_tempo ,  T1.stage_presence FROM performance_score AS T1 JOIN participants AS T2 ON T1.participant_id  =  T2.id WHERE T2.name  =  'Freeway'","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""performance_score.voice_sound_quality,"" ""performance_score.rhythm_tempo,"" and ""performance_score.stage_presence."" 2. Condition Structure: Use a WHERE clause to filter for the participant named ""Freeway."" 3. Join Structure: Use a JOIN between the ""participants"" table and the ""performance_score"" table based on the relationship ""performance_score.participant_id = participants.id"" to link each participant with their performance scores. 4. Aggregation Structure: No aggregation is needed as the query is retrieving specific fields for a single participant.",1.0
737,"What is the number of child documents for each parent document, and what are the ids of the parent documents?",EASY,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID, Document_Objects.Parent_Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Objects.Parent_Document_Object_ID AS parent_id, COUNT(Document_Objects.Document_Object_ID) AS child_count FROM Document_Objects GROUP BY Document_Objects.Parent_Document_Object_ID;","SELECT T2.Document_Object_ID ,  count(*) FROM Document_Objects AS T1 JOIN Document_Objects AS T2 ON T1.Parent_Document_Object_ID = T2.Document_Object_ID GROUP BY T2.Document_Object_ID;","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the parent document ID and the count of child documents. 2. Aggregation Structure: Use COUNT to calculate the number of child documents for each parent document. 3. Grouping Structure: Use GROUP BY on ""Document_Objects.Parent_Document_Object_ID"" to group the results by each parent document. 4. Join Structure: No JOIN is required since all necessary data is within the ""Document_Objects"" table.",1.0
738,What is the title of the book with the highest rank in the review?,NON-NESTED,book_review,"[book.Title, review.Rank, review.Book_ID = book.Book_ID]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT book.Title FROM book JOIN review ON review.Book_ID = book.Book_ID ORDER BY review.Rank DESC LIMIT 1;,SELECT T1.Title FROM book AS T1 JOIN review AS T2 ON T1.Book_ID  =  T2.Book_ID ORDER BY T2.Rank LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""book.Title"" of the book with the highest rank. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the book with the highest rank. 3. Join Structure: Use a JOIN between the ""book"" and ""review"" tables based on the shared key ""Book_ID"" to link each book with its review. 4. Aggregation Structure: Use ORDER BY in descending order on ""review.Rank"" to rank books by their rank. Use LIMIT 1 to select the book with the highest rank.",0.0
739,What are the names of the collections that are related to the collection named Best?,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID,Collection_Subset_Members.Related_Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID,Best]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collections.Collection_Name FROM Collections JOIN Collection_Subset_Members ON Collections.Collection_ID = Collection_Subset_Members.Related_Collection_ID WHERE Collection_Subset_Members.Collection_ID = (SELECT Collection_ID FROM Collections WHERE Collection_Name = 'Best');,"SELECT DISTINCT T4.Collection_Name FROM Collection_Subset_Members AS T1 JOIN Collection_Subset_Members AS T2 ON T1.Related_Collection_ID = T2.Collection_ID JOIN Collections AS T3 ON T1.Collection_ID = T3.Collection_ID JOIN Collections AS T4 ON T2.Collection_ID = T4.Collection_ID WHERE T3.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collections.Collection_Name"" for the related collections. 2. Condition Structure: Use a WHERE clause to filter for the collection named ""Best"" by matching ""Collections.Collection_Name"" and then find related collections using the ""Collection_Subset_Members"" table. 3. Join Structure: Use a JOIN between ""Collections"" and ""Collection_Subset_Members"" on ""Collections.Collection_ID"" and ""Collection_Subset_Members.Collection_ID"" to link collections with their related collections. 4. Aggregation Structure: No aggregation is needed as we are retrieving the names of related collections directly.",1.0
740,Show the book title and purchase price of the book that has had the greatest amount in orders.,NON-NESTED,book_1,"[Book.Title, Book.PurchasePrice, Books_Order.amount, Books_Order.ISBN = Book.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Book.Title, Book.PurchasePrice FROM Book JOIN Books_Order ON Book.ISBN = Books_Order.ISBN ORDER BY Books_Order.amount DESC LIMIT 1;","SELECT T2.title ,  T2.PurchasePrice FROM Books_Order AS T1 JOIN BOOk AS T2 ON T1.isbn  =  T2.isbn GROUP BY T1.isbn ORDER BY sum(amount) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""Book.Title"" and ""Book.PurchasePrice."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in the book with the greatest amount in orders. 3. Join Structure: Use a JOIN between the ""Book"" and ""Books_Order"" tables based on the ""ISBN"" field to link each book with its order details. 4. Aggregation Structure: Use ORDER BY in descending order on ""Books_Order.amount"" to rank books by the amount in orders. Use LIMIT 1 to select the book with the greatest amount in orders.",1.0
741,What is the description of collection named Best?,EASY,cre_Doc_and_collections,"[Collections.Collection_Description,Collections.Collection_Name,Collections.Collection_Name = 'Best']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collections.Collection_Description FROM Collections WHERE Collections.Collection_Name = 'Best';,"SELECT Collection_Description FROM Collections WHERE Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collections.Collection_Description"" for the collection named ""Best"". 2. Condition Structure: Use a WHERE clause to filter for the collection where ""Collections.Collection_Name"" is equal to 'Best'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Collections"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
742,"For each order, find the customer name and the dish name. Sort the result in descending order of the quantity of dish.",NON-NESTED,restaurant_bills,"[customer.Name, customer_order.Dish_Name, customer_order.Quantity, customer.Customer_ID = customer_order.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
","SELECT customer.Name, customer_order.Dish_Name, customer_order.Quantity FROM customer JOIN customer_order ON customer.Customer_ID = customer_order.Customer_ID ORDER BY customer_order.Quantity DESC;","SELECT T1.Name ,  T2.Dish_Name FROM customer AS T1 JOIN customer_order AS T2 ON T1.Customer_ID  =  T2.Customer_ID ORDER BY T2.Quantity DESC","1. Sequential Structure: Start with the SELECT clause to retrieve ""customer.Name,"" ""customer_order.Dish_Name,"" and ""customer_order.Quantity."" The result should be sorted in descending order of the quantity of the dish, so include an ORDER BY clause with ""customer_order.Quantity"" in descending order. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""customer"" and ""customer_order"" tables based on the relationship ""customer.Customer_ID = customer_order.Customer_ID"" to link each customer with their respective orders. 4. Aggregation Structure: No aggregation is required as the query does not involve any aggregate functions.",1.0
743,Which document has between 2 and 4 number of documents ? List the document id and the number of related documents .,NON-NESTED,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID,Document_Subset_Members.Related_Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Subset_Members.Document_Object_ID, COUNT(Document_Subset_Members.Related_Document_Object_ID) AS Number_of_Related_Documents FROM Document_Subset_Members GROUP BY Document_Subset_Members.Document_Object_ID HAVING COUNT(Document_Subset_Members.Related_Document_Object_ID) BETWEEN 2 AND 4;","select document_object_id , count(*) from document_subset_members group by document_object_id having count(*) between 2 and 4;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subset_Members.Document_Object_ID"" and the count of related documents. Use COUNT to calculate the number of related documents for each document. 2. Condition Structure: Apply a HAVING clause to filter for documents that have between 2 and 4 related documents (inclusive). 3. Join Structure: No explicit JOIN is needed since the relevant data is within the ""Document_Subset_Members"" table, but the relationship between ""Document_Subset_Members.Document_Object_ID"" and ""Document_Objects.Document_Object_ID"" ensures the connection. 4. Aggregation Structure: Use COUNT to count the number of related documents for each document, and GROUP BY ""Document_Subset_Members.Document_Object_ID"" to group the results by each document.",1.0
744,"What are all the city names for cities in the USA, ordered by latitude?",EASY,address_1,"[City.city_name, City.country, City.latitude]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.city_name FROM City WHERE City.country = 'USA' ORDER BY City.latitude;,"SELECT city_name FROM City WHERE country  =  ""USA"" ORDER BY latitude","1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.city_name"" for cities in the USA, along with their latitude for ordering purposes. 2. Condition Structure: Use a WHERE clause to filter cities where ""City.country"" is 'USA'. 3. Join Structure: No JOIN is required since all necessary information is in the ""City"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering city names. 5. Ordering Structure: Use ORDER BY on ""City.latitude"" to sort the results by latitude.",1.0
745,Show all book titles for books that have no orders.,NESTED,book_1,"[Book.Title,Books_Order.ISBN,Book.ISBN = Books_Order.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book WHERE Book.ISBN NOT IN (SELECT Books_Order.ISBN FROM Books_Order);,SELECT title FROM book EXCEPT SELECT T1.title FROM book AS T1 JOIN books_order AS T2 ON T1.isbn  =  T2.isbn,"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of books. Use the FROM clause to specify the Book table. Apply a WHERE clause to filter books that have no orders by ensuring their ISBN is not present in the Books_Order table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude books whose ISBN appears in the Books_Order table, meaning they have orders. 3. Join Structure: Not required, as we only need to filter based on the absence of matching ISBN entries in the Books_Order table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
746,What are the names of the different clients who have made an order?,NON-NESTED,book_1,"[Client.Name, Orders.IdClient, Client.IdClient = Orders.IdClient]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT DISTINCT Client.Name FROM Client JOIN Orders ON Client.IdClient = Orders.IdClient;,SELECT DISTINCT T1.name FROM Client AS T1 JOIN Orders AS T2 ON T1.idClient  =  T2.idClient,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of clients who have made an order. 2. Condition Structure: No specific filtering condition is required, as we are interested in all clients who have made an order. 3. Join Structure: Use a JOIN between the ""Client"" and ""Orders"" tables based on the relationship ""Client.IdClient = Orders.IdClient"" to link clients with their orders. 4. Aggregation Structure: Use DISTINCT to ensure that only unique client names are returned.",1.0
747,what are the collection names?,EASY,cre_Doc_and_collections,[Collections.Collection_Name],"Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collections.Collection_Name FROM Collections;,SELECT Collection_Name FROM Collections;,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collection_Name"" field from the ""Collections"" table. 2. Condition Structure: No specific filtering condition is required as the query aims to retrieve all collection names. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Collections"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all collection names.",1.0
748,What are the different descriptions of all the parent documents?,EASY,cre_Doc_and_collections,"[Document_Objects.Description, Document_Objects.Document_Object_ID, Document_Objects.Parent_Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT DISTINCT Document_Objects.Description FROM Document_Objects WHERE Document_Objects.Parent_Document_Object_ID IS NOT NULL;,SELECT DISTINCT T2.Description FROM Document_Objects AS T1 JOIN Document_Objects AS T2 ON T1.Parent_Document_Object_ID = T2.Document_Object_ID,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""Document_Objects.Description"". 2. Condition Structure: Use a WHERE clause to filter for rows where ""Document_Objects.Parent_Document_Object_ID"" is not NULL, as we are interested in parent documents. 3. Join Structure: No JOIN is required since all necessary data is within the ""Document_Objects"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique descriptions of parent documents are retrieved.",1.0
749,How many cities are in each state?,EASY,address_1,"[City.city_name, City.state]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.state, COUNT(City.city_name) AS city_count FROM City GROUP BY City.state;","SELECT state ,  count(*) FROM City GROUP BY state","1. Sequential Structure: Begin with the SELECT clause to specify the state and the count of cities in each state. 2. Aggregation Structure: Use COUNT to calculate the number of cities in each state. 3. Grouping Structure: Use GROUP BY on ""City.state"" to group the results by each state. 4. Join Structure: No JOIN is required since all necessary data is within the ""City"" table.",1.0
750,What are the distinct stage presence scores for all the songs that are in language 'English' ?,NON-NESTED,sing_contest,"[songs.language, performance_score.stage_presence, performance_score.songs_id = songs.id, English]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
",SELECT DISTINCT performance_score.stage_presence FROM performance_score JOIN songs ON performance_score.songs_id = songs.id WHERE songs.language = 'English';,SELECT DISTINCT T2.stage_presence FROM songs AS T1 JOIN performance_score AS T2 ON T1.id  =  T2.songs_id WHERE T1.language  =  'English',"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""performance_score.stage_presence"" values. 2. Condition Structure: Use a WHERE clause to filter for songs that are in the language ""English."" 3. Join Structure: Use a JOIN between the ""performance_score"" and ""songs"" tables based on ""performance_score.songs_id = songs.id"" to associate each song with its stage presence score. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique stage presence scores are returned.",1.0
751,How many different collections are related to the one named 'Best'?,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID,Collection_Subset_Members.Related_Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID,'Best']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT COUNT(DISTINCT Collection_Subset_Members.Related_Collection_ID) FROM Collections JOIN Collection_Subset_Members ON Collections.Collection_ID = Collection_Subset_Members.Collection_ID WHERE Collections.Collection_Name = 'Best';,"SELECT count(DISTINCT T1.Related_Collection_ID) FROM Collection_Subset_Members AS T1 JOIN Collections AS T2 ON T1.Collection_ID  =  T2.Collection_ID WHERE T2.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to count the distinct ""Collection_Subset_Members.Related_Collection_ID"" that are related to the collection named ""Best."" 2. Condition Structure: Use a WHERE clause to filter for the collection with the name ""Best"" by matching ""Collections.Collection_Name"" to ""Best."" 3. Join Structure: Use a JOIN between the ""Collections"" table and the ""Collection_Subset_Members"" table on ""Collections.Collection_ID"" and ""Collection_Subset_Members.Collection_ID"" to link collections with their related collections. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique related collection IDs.",1.0
752,How many collections that are related to collection named Best?,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID,Collection_Subset_Members.Related_Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID,Best]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT COUNT(*) FROM Collection_Subset_Members JOIN Collections ON Collection_Subset_Members.Collection_ID = Collections.Collection_ID WHERE Collections.Collection_Name = 'Best';,"SELECT count(DISTINCT T1.Related_Collection_ID) FROM Collection_Subset_Members AS T1 JOIN Collections AS T2 ON T1.Collection_ID  =  T2.Collection_ID WHERE T2.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to count the number of collections related to the collection named ""Best."" 2. Condition Structure: Use a WHERE clause to filter for the collection named ""Best"" in the ""Collections"" table and find its ""Collection_ID."" Then, use this ""Collection_ID"" to filter related collections in the ""Collection_Subset_Members"" table. 3. Join Structure: Use a JOIN between the ""Collections"" table and the ""Collection_Subset_Members"" table on ""Collection_ID"" to link collections with their related collections. 4. Aggregation Structure: Use COUNT to count the number of related collections.",1.0
753,What is the total quantities of dishes ordered by each customer ? List the customer name and the total quantity .,NON-NESTED,restaurant_bills,"[customer.Name, customer_order.Customer_ID, customer_order.Quantity, customer.Customer_ID = customer_order.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
","SELECT customer.Name, SUM(customer_order.Quantity) AS Total_Quantity FROM customer JOIN customer_order ON customer.Customer_ID = customer_order.Customer_ID GROUP BY customer.Name;","select t1.name ,  sum(t2.quantity) from customer as t1 join customer_order as t2 on t1.customer_id  =  t2.customer_id group by t1.name","1. Sequential Structure: Start with the SELECT clause to retrieve the ""customer.Name"" and the total quantity of dishes ordered by each customer. Use the SUM function to calculate the total quantity. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""customer"" table with the ""customer_order"" table based on the ""Customer_ID"" field to associate each customer with their orders. 4. Aggregation Structure: Use SUM to calculate the total quantity of dishes ordered by each customer and GROUP BY ""customer.Name"" to group the results by customer.",1.0
754,Give the average purchase price and average sale price for books.,EASY,book_1,"[Book.PurchasePrice, Book.SalePrice]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT AVG(Book.PurchasePrice) AS avg_purchase_price, AVG(Book.SalePrice) AS avg_sale_price FROM Book;","SELECT avg(purchaseprice) ,  avg(saleprice) FROM Book","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the average purchase price and average sale price. 2. Aggregation Structure: Use the AVG function to calculate the average purchase price and average sale price for books. 3. Grouping Structure: No GROUP BY is needed since we are calculating the overall averages for all books. 4. Join Structure: No JOIN is required as all necessary data is within the ""Book"" table.",1.0
755,What are the id and name of the song sung by the most participants?,NON-NESTED,sing_contest,"[songs.id, songs.name, performance_score.songs_id = songs.id, performance_score.participant_id = participants.id]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
","SELECT songs.id, songs.name FROM songs JOIN performance_score ON performance_score.songs_id = songs.id JOIN participants ON performance_score.participant_id = participants.id GROUP BY songs.id, songs.name ORDER BY COUNT(participants.id) DESC LIMIT 1;","SELECT T1.id ,  T1.name FROM songs AS T1 JOIN performance_score AS T2 ON T1.id  =  T2.songs_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""songs.id"" and ""songs.name"" of the song sung by the most participants. Use COUNT to count the number of participants for each song. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the song with the highest number of participants. 3. Join Structure: Use JOIN clauses to connect ""songs"" with ""performance_score"" on ""performance_score.songs_id = songs.id"" and ""performance_score"" with ""participants"" on ""performance_score.participant_id = participants.id"" to link songs with their participants. 4. Aggregation Structure: Use COUNT to count the number of participants for each song, GROUP BY ""songs.id"" and ""songs.name"" to group the results by song, and ORDER BY the count in descending order to find the song with the most participants. Use LIMIT 1 to select the top result.",0.0
756,Return the number of orders received for Pride and Prejudice.,NON-NESTED,book_1,"[Book.Title,Books_Order.IdOrder,Books_Order.ISBN = Book.ISBN,Book.Title = 'Pride and Prejudice']","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT COUNT(Books_Order.IdOrder) FROM Books_Order JOIN Book ON Books_Order.ISBN = Book.ISBN WHERE Book.Title = 'Pride and Prejudice';,"SELECT count(*) FROM Book AS T1 JOIN Books_Order AS T2 ON T1.isbn  =  T2.isbn WHERE T1.title  =  ""Pride and Prejudice""","1. Sequential Structure: Start with the SELECT clause to count the number of orders. Use COUNT on ""Books_Order.IdOrder"" to calculate the total number of orders for the specified book. 2. Condition Structure: Use a WHERE clause to filter for the book with the title ""Pride and Prejudice."" 3. Join Structure: Use a JOIN between the ""Books_Order"" and ""Book"" tables based on the ""ISBN"" field to associate orders with their respective books. 4. Aggregation Structure: Use COUNT to aggregate the number of orders for the specified book.",1.0
757,What are the id and name of the participants who received score 5 for their sound quality or rhythm tempo?,NON-NESTED,sing_contest,"[participants.id, participants.name, performance_score.voice_sound_quality, performance_score.rhythm_tempo, performance_score.participant_id = participants.id, 5]","Table participants, columns = [*,id,name,popularity]
Table performance_score, columns = [*,participant_id,songs_id,voice_sound_quality,rhythm_tempo,stage_presence]
Table songs, columns = [*,id,language,original_artist,name,english_translation]
","Foreign_keys = [performance_score.songs_id = songs.id,performance_score.participant_id = participants.id]
","SELECT participants.id, participants.name FROM participants JOIN performance_score ON performance_score.participant_id = participants.id WHERE performance_score.voice_sound_quality = 5 OR performance_score.rhythm_tempo = 5;","SELECT T1.id ,  T1.name FROM participants AS T1 JOIN performance_score AS T2 ON T2.participant_id  =  T1.id WHERE T2.voice_sound_quality  =  5 OR T2.rhythm_tempo  =  5","1. Sequential Structure: Start with the SELECT clause to retrieve the ""participants.id"" and ""participants.name."" 2. Condition Structure: Use a WHERE clause to filter for participants who received a score of 5 in either ""performance_score.voice_sound_quality"" or ""performance_score.rhythm_tempo."" 3. Join Structure: Use a JOIN between the ""participants"" table and the ""performance_score"" table based on ""performance_score.participant_id = participants.id"" to link participants with their performance scores. 4. Aggregation Structure: No aggregation is needed as the query is focused on filtering and retrieving specific participant details.",1.0
758,What latitude and longitude correspond to Baltimore?,EASY,address_1,"[City.latitude, City.longitude, City.city_name, Baltimore]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.latitude, City.longitude FROM City WHERE City.city_name = 'Baltimore';","SELECT latitude ,  longitude FROM City WHERE city_name  =  ""Baltimore""","1. Sequential Structure: Start with the SELECT clause to retrieve the latitude and longitude of the city. 2. Condition Structure: Use a WHERE clause to filter for the city name ""Baltimore"". 3. Join Structure: No JOIN is required since all necessary information is in the ""City"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
759,Show the nations that have both customers with card credit smaller than 50 and customers with card credit bigger than 75.,NESTED,restaurant_bills,"[customer.Nationality, customer.Card_Credit]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT DISTINCT Nationality FROM customer WHERE Nationality IN (SELECT Nationality FROM customer WHERE Card_Credit < 50) AND Nationality IN (SELECT Nationality FROM customer WHERE Card_Credit > 75);,SELECT Nationality FROM customer WHERE Card_Credit  <  50 INTERSECT SELECT Nationality FROM customer WHERE Card_Credit  >  75,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct nationalities of customers. Use the FROM clause to specify the customer table. Apply a WHERE clause to filter customers based on their card credit values being smaller than 50 and bigger than 75. 2. Condition Structure: Use two subqueries in the WHERE clause to ensure that a nationality has customers with card credit smaller than 50 and also customers with card credit bigger than 75. 3. Join Structure: Not required, as all data is in the customer table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
760,What are the order ids for orders that include both Pride and Prejudice and The Little Prince?,NESTED,book_1,"[Book.Title,Books_Order.ISBN,Books_Order.IdOrder,Book.ISBN = Books_Order.ISBN,Books_Order.IdOrder = Orders.IdOrder]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT DISTINCT bo1.IdOrder FROM Books_Order bo1 JOIN Book b1 ON bo1.ISBN = b1.ISBN WHERE b1.Title = 'Pride and Prejudice' AND bo1.IdOrder IN ( SELECT bo2.IdOrder FROM Books_Order bo2 JOIN Book b2 ON bo2.ISBN = b2.ISBN WHERE b2.Title = 'The Little Prince' );,"SELECT idOrder FROM Book AS T1 JOIN Books_Order AS T2 ON T1.isbn  =  T2.isbn WHERE T1.title  =  ""Pride and Prejudice"" INTERSECT SELECT idOrder FROM Book AS T1 JOIN Books_Order AS T2 ON T1.isbn  =  T2.isbn WHERE T1.title  =  ""The Little Prince""","1. Sequential Structure: Start with the SELECT clause to retrieve the order IDs. Use the FROM clause to specify the Books_Order table and JOIN it with the Book table to link book titles with orders. Use a WHERE clause to filter for orders that include both ""Pride and Prejudice"" and ""The Little Prince"". 2. Condition Structure: Use a WHERE clause with a subquery to identify orders that include both books. The subquery ensures that the same order ID appears for both titles. 3. Join Structure: Use an INNER JOIN between the Book and Books_Order tables based on the ISBN to connect book titles with their respective orders. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
761,Which country has least number of students?,NON-NESTED,address_1,"[Student.StuID,City.country,Student.city_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.country, COUNT(Student.StuID) AS student_count FROM Student JOIN City ON Student.city_code = City.city_code GROUP BY City.country ORDER BY student_count ASC LIMIT 1;",SELECT T1.country FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.country ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.country"" and the count of students. Use COUNT to count the number of students for each country. 2. Condition Structure: No specific filtering condition is required, as we are interested in all countries. 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to associate each student with their respective country. 4. Aggregation Structure: Use COUNT to count the number of students per country, GROUP BY ""City.country"" to group the results by country, and ORDER BY the count in ascending order to find the country with the least number of students. Use LIMIT 1 to select the country with the smallest count.",1.0
762,What is the name of the parent collection of the collection named Nice?,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Parent_Collection_ID,Collections.Collection_ID = Collection_Subset_Members.Collection_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Nice]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Parent_Collections.Collection_Name FROM Collections AS Child_Collections JOIN Collections AS Parent_Collections ON Child_Collections.Parent_Collection_ID = Parent_Collections.Collection_ID WHERE Child_Collections.Collection_Name = 'Nice';,"SELECT T2.Collection_Name FROM Collections AS T1 JOIN Collections AS T2 ON T1.Parent_Collection_ID = T2.Collection_ID WHERE T1.Collection_Name = ""Nice"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collections.Collection_Name"" of the parent collection. 2. Condition Structure: Use a WHERE clause to filter for the collection named ""Nice"" and find its ""Parent_Collection_ID."" 3. Join Structure: Use a JOIN between the ""Collections"" table and itself to link the ""Parent_Collection_ID"" of the collection named ""Nice"" with the ""Collection_ID"" of the parent collection. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single parent collection name.",1.0
763,What are the collection subsets that the collection named 'Best' in?,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collection_Subset_Members.Collection_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subsets.Collection_Subset_Name,'Best']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Collection_Subsets.Collection_Subset_Name FROM Collections JOIN Collection_Subset_Members ON Collections.Collection_ID = Collection_Subset_Members.Collection_ID JOIN Collection_Subsets ON Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID WHERE Collections.Collection_Name = 'Best';,"SELECT DISTINCT T1.Collection_Subset_Name FROM Collection_Subsets AS T1 JOIN Collection_Subset_Members AS T2 ON T1.Collection_Subset_ID =  T2.Collection_Subset_ID JOIN Collections AS T3 ON T2.Collection_ID =  T3.Collection_ID WHERE T3.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Collection_Subsets.Collection_Subset_Name"" field, which represents the names of the subsets. 2. Condition Structure: Use a WHERE clause to filter for the collection named ""Best"" in the ""Collections.Collection_Name"" field. 3. Join Structure: Use JOINs to connect the ""Collections"" table with ""Collection_Subset_Members"" on ""Collection_ID"" and then with ""Collection_Subsets"" on ""Collection_Subset_ID"" to link the collection with its subsets. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific subset names.",1.0
764,Show distinct managers of branches.,EASY,restaurant_bills,[branch.Manager],"Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT DISTINCT branch.Manager FROM branch;,SELECT DISTINCT Manager FROM branch,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct managers of branches. 2. Condition Structure: No specific filtering condition is required as we want all distinct managers. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""branch"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct values.",1.0
765,List id of documents that in collection named Best but not in document subset Best for 2000.,NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID = Documents_in_Collections.Collection_ID,Documents_in_Collections.Document_Object_ID,Document_Subsets.Document_Subset_Name,Document_Subsets.Document_Subset_ID = Document_Subset_Members.Document_Subset_ID,Document_Subset_Members.Document_Object_ID,Best,Best for 2000]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Documents_in_Collections.Document_Object_ID FROM Collections JOIN Documents_in_Collections ON Collections.Collection_ID = Documents_in_Collections.Collection_ID WHERE Collections.Collection_Name = 'Best' AND Documents_in_Collections.Document_Object_ID NOT IN ( SELECT Document_Subset_Members.Document_Object_ID FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subsets.Document_Subset_ID = Document_Subset_Members.Document_Subset_ID WHERE Document_Subsets.Document_Subset_Name = 'Best for 2000' );,"SELECT DISTINCT T2.Document_Object_ID FROM Collections AS T1 JOIN Documents_in_Collections AS T2 ON T1.Collection_ID = T2.Collection_ID WHERE T1.Collection_Name = ""Best"" EXCEPT SELECT DISTINCT T3.Document_Object_ID FROM Document_Subset_Members AS T3 JOIN Document_Subsets AS T4 ON T3.Document_Subset_ID =  T4.Document_Subset_ID WHERE T4.Document_Subset_Name = ""Best for 2000""","1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of documents. Use the FROM clause to specify the relevant tables, Collections, Documents_in_Collections, Document_Subsets, and Document_Subset_Members. Apply a WHERE clause to filter documents that are in the collection named 'Best' but not in the document subset named 'Best for 2000'. 2. Condition Structure: Use the WHERE clause to filter for documents in the 'Best' collection by matching the Collection_Name. Use a subquery to exclude documents that are in the 'Best for 2000' subset by matching the Document_Subset_Name. 3. Join Structure: Use JOINs to connect Collections with Documents_in_Collections on Collection_ID, and Document_Subsets with Document_Subset_Members on Document_Subset_ID. This allows us to relate collections, documents, and subsets. 4. Aggregation Structure: Not required, as we are retrieving specific document IDs without any aggregation.",1.0
766,How many child documents does each parent document has? List the document id and the number.,EASY,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID, Document_Objects.Parent_Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Objects.Parent_Document_Object_ID AS parent_document_id, COUNT(Document_Objects.Document_Object_ID) AS child_count FROM Document_Objects GROUP BY Document_Objects.Parent_Document_Object_ID;","SELECT T2.Document_Object_ID ,  count(*) FROM Document_Objects AS T1 JOIN Document_Objects AS T2 ON T1.Parent_Document_Object_ID = T2.Document_Object_ID GROUP BY T2.Document_Object_ID;","1. Sequential Structure: Begin with the SELECT clause to specify the parent document ID and the count of child documents for each parent. 2. Aggregation Structure: Use COUNT to calculate the number of child documents for each parent document. 3. Grouping Structure: Use GROUP BY on ""Document_Objects.Parent_Document_Object_ID"" to group the results by each parent document. 4. Join Structure: No JOIN is required since all necessary data is within the ""Document_Objects"" table.",1.0
767,List all document which is related to document owned by Ransom . List the document id .,NON-NESTED,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID,Document_Objects.Owner,Document_Subset_Members.Document_Object_ID,Document_Subset_Members.Related_Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Ransom]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Subset_Members.Related_Document_Object_ID FROM Document_Objects JOIN Document_Subset_Members ON Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID WHERE Document_Objects.Owner = 'Ransom';,select t1.document_object_id from document_subset_members as t1 join document_objects as t2 on t1.document_object_id  =  t2.document_object_id where t2.owner  =  'ransom',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Subset_Members.Related_Document_Object_ID"" as we are interested in related documents. 2. Condition Structure: Use a WHERE clause to filter for documents owned by ""Ransom."" This requires filtering ""Document_Objects.Owner"" for the value ""Ransom."" 3. Join Structure: Use a JOIN between ""Document_Objects"" and ""Document_Subset_Members"" on ""Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID"" to link documents with their related documents. 4. Aggregation Structure: No aggregation is needed as we are listing all related document IDs.",1.0
768,"Show the names of customers with nationality ""England"" or ""Australia"".",EASY,restaurant_bills,"[customer.Name, customer.Nationality]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT customer.Name FROM customer WHERE customer.Nationality = 'England' OR customer.Nationality = 'Australia';,"SELECT Name FROM customer WHERE Nationality  =  ""England"" OR Nationality  =  ""Australia""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""customer.Name"" of customers with the specified nationalities. 2. Condition Structure: Use a WHERE clause to filter customers whose ""customer.Nationality"" is either ""England"" or ""Australia"". 3. Join Structure: No JOIN is required since all necessary information is in the ""customer"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving customer names based on a specific condition.",1.0
769,Give the name of the client who has made the most orders.,NON-NESTED,book_1,"[Client.Name, Orders.IdClient, Orders.IdClient = Client.IdClient]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Client.Name FROM Client JOIN Orders ON Orders.IdClient = Client.IdClient GROUP BY Client.IdClient ORDER BY COUNT(Orders.IdClient) DESC LIMIT 1;,SELECT T2.name FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient GROUP BY T1.idClient ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Client.Name"" of the client who has made the most orders. Use COUNT to count the number of orders for each client. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all clients. 3. Join Structure: Use a JOIN between the ""Client"" and ""Orders"" tables based on ""Orders.IdClient = Client.IdClient"" to associate each order with its respective client. 4. Aggregation Structure: Use COUNT to count the number of orders for each client, GROUP BY ""Client.IdClient"" to group the results by client, and ORDER BY the count in descending order to rank clients by the number of orders. Use LIMIT 1 to select the client with the most orders.",1.0
770,How many distinct types of book are there?,EASY,book_review,[book.Type],"Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT COUNT(DISTINCT book.Type) AS distinct_book_types FROM book;,SELECT count(DISTINCT TYPE) FROM book,"1. Sequential Structure: Start with the SELECT clause to count the distinct types of books. 2. Condition Structure: No specific filtering condition is required as we are interested in all book types. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""book"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique types of books.",1.0
771,"Sort all the customers by the level of membership in ascending order, and return the customer names.",EASY,restaurant_bills,"[customer.Name, customer.Level_of_Membership]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
",SELECT customer.Name FROM customer ORDER BY customer.Level_of_Membership ASC;,SELECT Name FROM customer ORDER BY Level_of_Membership ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the customer name. 2. Condition Structure: No specific filtering condition is required as we want all customers. 3. Join Structure: No JOIN is required since all necessary data is within the ""customer"" table. 4. Aggregation Structure: No aggregation is needed as we are simply sorting the data. 5. Ordering Structure: Use ORDER BY on ""customer.Level_of_Membership"" in ascending order to sort the customers by their membership level.",1.0
772,What are the isbns of books ordered by both clients named Peter Doe and James Smith?,NESTED,book_1,"[Client.Name,Client.IdClient = Orders.IdClient,Orders.IdOrder = Books_Order.IdOrder,Books_Order.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Books_Order.ISBN FROM Client JOIN Orders ON Client.IdClient = Orders.IdClient JOIN Books_Order ON Orders.IdOrder = Books_Order.IdOrder WHERE Client.Name = 'Peter Doe' INTERSECT SELECT Books_Order.ISBN FROM Client JOIN Orders ON Client.IdClient = Orders.IdClient JOIN Books_Order ON Orders.IdOrder = Books_Order.IdOrder WHERE Client.Name = 'James Smith';,"SELECT T2.isbn FROM Orders AS T1 JOIN Books_Order AS T2 ON T1.idOrder  =  T2.idOrder JOIN Client AS T3 ON T1.idClient  =  T3.idClient WHERE T3.name  =  ""Peter Doe"" INTERSECT SELECT T2.isbn FROM Orders AS T1 JOIN Books_Order AS T2 ON T1.idOrder  =  T2.idOrder JOIN Client AS T3 ON T1.idClient  =  T3.idClient WHERE T3.name  =  ""James Smith""","1. Sequential Structure: Start with the SELECT clause to retrieve the ISBNs of books. Use the FROM clause to specify the relevant tables (Client, Orders, Books_Order). Apply a WHERE clause to filter for orders made by clients named ""Peter Doe"" and ""James Smith"". Use an INTERSECT operation to find books ordered by both clients. 2. Condition Structure: Use the WHERE clause to filter for clients with the names ""Peter Doe"" and ""James Smith"". Retrieve the ISBNs of books ordered by each client separately and then find the intersection of these results. 3. Join Structure: Use JOINs to connect the Client table with the Orders table on IdClient, and the Orders table with the Books_Order table on IdOrder, to link clients to the books they ordered. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
773,Show the names of club leaders of clubs with overall ranking higher than 100.,NON-NESTED,club_leader,"[club.Club_Name,club.Overall_Ranking,club_leader.Club_ID = club.Club_ID,club_leader.Member_ID = member.Member_ID,member.Name,100]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT member.Name FROM club JOIN club_leader ON club.Club_ID = club_leader.Club_ID JOIN member ON club_leader.Member_ID = member.Member_ID WHERE club.Overall_Ranking > 100;,"SELECT T3.Name ,  T2.Club_Name FROM club_leader AS T1 JOIN club AS T2 ON T1.Club_ID  =  T2.Club_ID JOIN member AS T3 ON T1.Member_ID  =  T3.Member_ID WHERE T2.Overall_Ranking  <  100","1. Sequential Structure: Start with the SELECT clause to retrieve the ""member.Name"" of club leaders. 2. Condition Structure: Use a WHERE clause to filter for clubs with an ""Overall_Ranking"" higher than 100. 3. Join Structure: Use JOINs to connect the ""club"" table with the ""club_leader"" table on ""Club_ID"" and then connect the ""club_leader"" table with the ""member"" table on ""Member_ID"" to link each club leader with their respective club and member details. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific data based on the condition.",0.0
774,Count the number of cities.,EASY,address_1,[City.city_code],"Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT COUNT(DISTINCT City.city_code) AS city_count FROM City;,SELECT count(*) FROM City,"1. Sequential Structure: Begin with the SELECT clause to count the number of cities. 2. Aggregation Structure: Use the COUNT function to count the distinct city codes, as each city is uniquely identified by its city code. 3. Join Structure: No JOIN is required since all necessary data is within the ""City"" table. 4. Condition Structure: No specific filtering condition is needed, as we are counting all cities.",1.0
775,What is the unique description of every parent document?,EASY,cre_Doc_and_collections,"[Document_Objects.Description, Document_Objects.Document_Object_ID, Document_Objects.Parent_Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT DISTINCT Document_Objects.Description FROM Document_Objects WHERE Document_Objects.Parent_Document_Object_ID IS NULL;,SELECT DISTINCT T2.Description FROM Document_Objects AS T1 JOIN Document_Objects AS T2 ON T1.Parent_Document_Object_ID = T2.Document_Object_ID,"1. Sequential Structure: Begin with the SELECT clause to specify the unique descriptions of parent documents. 2. Condition Structure: Use a WHERE clause to filter for rows where the ""Parent_Document_Object_ID"" is NULL, as this indicates a parent document. 3. Join Structure: No JOIN is required since all necessary data is within the ""Document_Objects"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving unique descriptions directly.",0.0
776,"Show names, codes, states, countries for all cities.",EASY,address_1,"[City.city_name, City.city_code, City.state, City.country]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.city_name, City.city_code, City.state, City.country FROM City;","SELECT city_name ,  city_code ,  state ,  country FROM City","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""City.city_name"", ""City.city_code"", ""City.state"", and ""City.country"". 2. Condition Structure: No specific filtering condition is required as the query asks for all cities. 3. Join Structure: No JOIN is required since all necessary information is available in the ""City"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all the specified fields for all cities.",1.0
777,Give the title of book by George Orwell that has the lowest saleprice.,NON-NESTED,book_1,"[Book.Title,Book.SalePrice,Book.Author,Author.Name,Author_Book.ISBN = Book.ISBN,George Orwell]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book JOIN Author_Book ON Book.ISBN = Author_Book.ISBN JOIN Author ON Author_Book.AuthorID = Author.ID WHERE Author.Name = 'George Orwell' ORDER BY Book.SalePrice ASC LIMIT 1;,"SELECT T1.title FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T3.name  =  ""George Orwell"" ORDER BY T1.saleprice LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Book.Title"" of the book with the lowest sale price. Use the MIN function on ""Book.SalePrice"" to find the lowest price. 2. Condition Structure: Use a WHERE clause to filter for books authored by ""George Orwell."" This requires joining the ""Author"" table to identify the author and linking it to the ""Book"" table through the ""Author_Book"" table. 3. Join Structure: Use JOINs to connect ""Author"" with ""Author_Book"" on ""Author.ID"" and ""Author_Book"" with ""Book"" on ""Book.ISBN"" to associate books with their respective authors. 4. Aggregation Structure: Use MIN to find the book with the lowest sale price, and filter the result to only include books by ""George Orwell.""",0.0
778,Give the titles of books authored by Plato that have a sale price lower than the average sale price across all books.,NESTED,book_1,"[Book.Title,Book.SalePrice,Author.Name,Author_Book.ISBN = Book.ISBN,Author_Book.Author = Author.idAuthor,Plato]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book JOIN Author_Book ON Author_Book.ISBN = Book.ISBN JOIN Author ON Author_Book.Author = Author.idAuthor WHERE Author.Name = 'Plato' AND Book.SalePrice < (SELECT AVG(SalePrice) FROM Book);,"SELECT T1.title FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T3.name  =  ""Plato"" AND T1.saleprice  <  (SELECT avg(saleprice) FROM Book)","1. Sequential Structure: Start with the SELECT clause to retrieve the titles of books. Use the FROM clause to specify the Book table and join it with the Author_Book and Author tables to connect books with their authors. Apply a WHERE clause to filter books authored by Plato and with a sale price lower than the average sale price across all books. 2. Condition Structure: Use the WHERE clause to filter for books authored by Plato and with a sale price less than the average sale price. The average sale price is calculated using a subquery. 3. Join Structure: Use INNER JOINs between the Book, Author_Book, and Author tables based on ISBN and Author ID to connect books with their respective authors. 4. Aggregation Structure: Use AVG in a subquery to calculate the average sale price of all books, which is then used in the filtering condition.",1.0
779,List the document id of all documents in collection named Best.,NON-NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID,Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Documents_in_Collections.Document_Object_ID FROM Collections JOIN Documents_in_Collections ON Collections.Collection_ID = Documents_in_Collections.Collection_ID WHERE Collections.Collection_Name = 'Best';,"SELECT T2.Document_Object_ID FROM Collections AS T1 JOIN Documents_in_Collections AS T2 ON T1.Collection_ID = T2.Collection_ID WHERE T1.Collection_Name = ""Best"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Documents_in_Collections.Document_Object_ID,"" which represents the document IDs. 2. Condition Structure: Use a WHERE clause to filter for the collection named ""Best"" by matching ""Collections.Collection_Name"" to 'Best.' 3. Join Structure: Use a JOIN between the ""Collections"" table and the ""Documents_in_Collections"" table based on the shared key ""Collection_ID"" to link collections with their documents. 4. Aggregation Structure: No aggregation is needed as we are simply listing document IDs.",1.0
780,What are the type and title of the books that are not rated?,NESTED,book_review,"[book.Type, book.Title, review.Rating, review.Book_ID = book.Book_ID]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
","SELECT book.Type, book.Title FROM book LEFT JOIN review ON book.Book_ID = review.Book_ID WHERE review.Rating IS NULL;","SELECT TYPE ,  title FROM book EXCEPT SELECT T1.type ,  T1.title FROM book AS T1 JOIN review AS T2 ON T1.Book_ID  =  T2.Book_ID;","1. Sequential Structure: Start with the SELECT clause to retrieve the type and title of books. Use the FROM clause to specify the book table and JOIN it with the review table on the Book_ID field to connect books with their reviews. Apply a WHERE clause to filter for books that do not have a rating. 2. Condition Structure: Use the WHERE clause to check for books where the Rating field is NULL, indicating that the book is not rated. 3. Join Structure: Use an INNER JOIN between the book and review tables based on the Book_ID field to link books with their reviews. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
781,Find the title of books which are ordered by client Peter Doe but not client James Smith.,NESTED,book_1,"[Client.Name, Client.IdClient, Orders.IdClient = Client.IdClient, Orders.IdOrder, Books_Order.IdOrder = Orders.IdOrder, Books_Order.ISBN, Book.ISBN = Books_Order.ISBN, Book.Title, Peter Doe, James Smith]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book JOIN Books_Order ON Book.ISBN = Books_Order.ISBN JOIN Orders ON Books_Order.IdOrder = Orders.IdOrder JOIN Client ON Orders.IdClient = Client.IdClient WHERE Client.Name = 'Peter Doe' AND Book.ISBN NOT IN ( SELECT Book.ISBN FROM Book JOIN Books_Order ON Book.ISBN = Books_Order.ISBN JOIN Orders ON Books_Order.IdOrder = Orders.IdOrder JOIN Client ON Orders.IdClient = Client.IdClient WHERE Client.Name = 'James Smith' );,"SELECT T4.title FROM Orders AS T1 JOIN Books_Order AS T2 ON T1.idOrder  =  T2.idOrder JOIN Client AS T3 ON T1.idClient  =  T3.idClient JOIN book AS T4 ON T2.ISBN  =  T4.isbn WHERE T3.name  =  ""Peter Doe"" EXCEPT SELECT T4.title FROM Orders AS T1 JOIN Books_Order AS T2 ON T1.idOrder  =  T2.idOrder JOIN Client AS T3 ON T1.idClient  =  T3.idClient JOIN book AS T4 ON T2.ISBN  =  T4.isbn WHERE T3.name  =  ""James Smith""","1. Sequential Structure: Start with the SELECT clause to retrieve the title of books. Use the FROM clause to specify the Book table and JOIN it with the Books_Order table on ISBN to link books with orders. Then, JOIN the Orders table on IdOrder to connect orders with clients, and finally JOIN the Client table on IdClient to identify the clients who placed the orders. Apply a WHERE clause to filter books ordered by Peter Doe but not by James Smith. 2. Condition Structure: Use the WHERE clause to filter for books ordered by Peter Doe. Use a subquery to exclude books ordered by James Smith by ensuring their ISBNs are not in the set of ISBNs associated with James Smith. 3. Join Structure: Use INNER JOINs between the Book, Books_Order, Orders, and Client tables based on their respective relationships (ISBN, IdOrder, and IdClient) to connect books with the clients who ordered them. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
782,"What are the isbns for all books, and what is the total amount ordered for each?",NON-NESTED,book_1,"[Book.ISBN, Books_Order.amount, Books_Order.ISBN = Book.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Book.ISBN, SUM(Books_Order.amount) AS total_amount FROM Book JOIN Books_Order ON Books_Order.ISBN = Book.ISBN GROUP BY Book.ISBN;","SELECT isbn ,  sum(amount) FROM Books_Order GROUP BY isbn","1. Sequential Structure: Start with the SELECT clause to retrieve ""Book.ISBN"" and the total amount ordered for each book. Use SUM on ""Books_Order.amount"" to calculate the total amount ordered for each ISBN. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Book"" and ""Books_Order"" tables based on the shared ""ISBN"" field to link books with their order amounts. 4. Aggregation Structure: Use SUM to aggregate the ""Books_Order.amount"" for each ""Book.ISBN"" and GROUP BY ""Book.ISBN"" to group the results by each book's ISBN.",1.0
783,What are the titles of all books written by an author with a name that contains Plato?,NON-NESTED,book_1,"[Book.Title,Author.Name,Author_Book.ISBN = Book.ISBN,Author_Book.Author = Author.idAuthor,Plato]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book JOIN Author_Book ON Author_Book.ISBN = Book.ISBN JOIN Author ON Author_Book.Author = Author.idAuthor WHERE Author.Name LIKE '%Plato%';,"SELECT T1.title FROM Book AS T1 JOIN Author_book AS T2 ON T1.isbn  =  T2.isbn JOIN Author AS T3 ON T2.Author  =  T3.idAuthor WHERE T3.name LIKE ""%Plato%""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Book.Title"" field, as the question asks for the titles of books. 2. Condition Structure: Use a WHERE clause to filter for authors whose name contains ""Plato."" 3. Join Structure: Use JOINs to connect the ""Book"" table with the ""Author_Book"" table on ""Author_Book.ISBN = Book.ISBN"" and the ""Author_Book"" table with the ""Author"" table on ""Author_Book.Author = Author.idAuthor"" to link books with their respective authors. 4. Aggregation Structure: No aggregation is needed, as the query is retrieving specific book titles.",1.0
784,What is the average rating in reviews?,EASY,book_review,[review.Rating],"Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT AVG(review.Rating) AS average_rating FROM review;,SELECT avg(Rating) FROM review,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average rating. 2. Aggregation Structure: Use the AVG function to calculate the average of the ""review.Rating"" field. 3. Condition Structure: No specific filtering condition is required as the query aims to calculate the overall average rating. 4. Join Structure: No JOIN is required since all necessary data is within the ""review"" table.",1.0
785,Show the client name who has the most total amount of books ordered.,NON-NESTED,book_1,"[Client.Name, Orders.IdClient, Books_Order.IdOrder = Orders.IdOrder, Books_Order.amount]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Client.Name FROM Client JOIN Orders ON Client.Id = Orders.IdClient JOIN Books_Order ON Books_Order.IdOrder = Orders.IdOrder GROUP BY Client.Name ORDER BY SUM(Books_Order.amount) DESC LIMIT 1;,SELECT T2.name FROM Orders AS T1 JOIN Client AS T2 ON T1.idClient  =  T2.idClient JOIN Books_Order AS T3 ON T3.idOrder  =  T1.idOrder GROUP BY T1.idClient ORDER BY sum(T3.amount) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Client.Name"" of the client who has the most total amount of books ordered. Use an aggregate function (SUM) on ""Books_Order.amount"" to calculate the total amount of books ordered by each client. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the client with the highest total amount of books ordered. 3. Join Structure: Use JOINs to connect the ""Client"" table with the ""Orders"" table on ""Client.Id = Orders.IdClient"" and the ""Books_Order"" table on ""Books_Order.IdOrder = Orders.IdOrder"" to link clients with their respective orders and the amounts of books ordered. 4. Aggregation Structure: Use SUM to calculate the total amount of books ordered for each client, then use ORDER BY in descending order on the aggregated total to rank clients by the total amount of books ordered. Use LIMIT 1 to select the client with the highest total.",0.0
786,Show the titles of books that have been ordered.,NON-NESTED,book_1,"[Book.Title, Books_Order.ISBN, Books_Order.ISBN = Book.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book JOIN Books_Order ON Books_Order.ISBN = Book.ISBN;,SELECT DISTINCT T1.title FROM book AS T1 JOIN books_order AS T2 ON T1.isbn  =  T2.isbn,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Book.Title."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in all books that have been ordered. 3. Join Structure: Use a JOIN between the ""Book"" and ""Books_Order"" tables based on the ""ISBN"" field to link books with their orders. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving the titles of books that have been ordered.",1.0
787,"List subset id, name and number of different documents in each subset.",NON-NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name, Document_Subset_Members.Document_Object_ID, Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name, COUNT(DISTINCT Document_Subset_Members.Document_Object_ID) AS Number_of_Documents FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID GROUP BY Document_Subsets.Document_Subset_ID, Document_Subsets.Document_Subset_Name;","SELECT T1.Document_Subset_ID ,  T2.Document_Subset_Name , count(DISTINCT T1.Document_Object_ID) FROM Document_Subset_Members AS T1 JOIN Document_Subsets AS T2 ON T1.Document_Subset_ID =  T2.Document_Subset_ID GROUP BY T1.Document_Subset_ID;","1. Sequential Structure: Start with the SELECT clause to retrieve ""Document_Subsets.Document_Subset_ID,"" ""Document_Subsets.Document_Subset_Name,"" and the count of distinct ""Document_Subset_Members.Document_Object_ID"" for each subset. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect ""Document_Subsets"" with ""Document_Subset_Members"" on ""Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID"" to link subsets with their respective documents. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Document_Subset_Members.Document_Object_ID"" to count the number of different documents in each subset, and GROUP BY ""Document_Subsets.Document_Subset_ID"" and ""Document_Subsets.Document_Subset_Name"" to group results by each subset.",1.0
788,What is the document object id with the least number of documents ?,NON-NESTED,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID, Documents_in_Collections.Document_Object_ID, Documents_in_Collections.Collection_ID = Collections.Collection_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT Document_Objects.Document_Object_ID FROM Document_Objects JOIN Documents_in_Collections ON Document_Objects.Document_Object_ID = Documents_in_Collections.Document_Object_ID GROUP BY Document_Objects.Document_Object_ID ORDER BY COUNT(Documents_in_Collections.Document_Object_ID) ASC LIMIT 1;,"select document_object_id , count(*) from document_subset_members group by document_object_id order by count(*) asc limit 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Objects.Document_Object_ID"" with the least number of documents. Use COUNT to count the number of documents associated with each Document_Object_ID. 2. Condition Structure: No specific filtering condition is required, as we are interested in all document object IDs. 3. Join Structure: Use a JOIN between ""Document_Objects"" and ""Documents_in_Collections"" on ""Document_Object_ID"" to link document objects with their associated documents. 4. Aggregation Structure: Use COUNT to count the number of documents for each Document_Object_ID, GROUP BY to group the results by Document_Object_ID, and ORDER BY in ascending order to find the one with the least number of documents. Use LIMIT 1 to select the Document_Object_ID with the least count.",0.0
789,List all document subsets of documents that related to each document id. List the name of document subset and the document id.,NON-NESTED,cre_Doc_and_collections,"[Document_Subsets.Document_Subset_Name,Document_Subset_Members.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Subsets.Document_Subset_Name, Document_Subset_Members.Document_Object_ID FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID;","SELECT DISTINCT T3.Document_Subset_Name ,  T1.Document_Object_ID FROM Document_Subset_Members AS T1 JOIN Document_Subset_Members  AS T2 ON T1.Related_Document_Object_ID = T2.Document_Object_ID JOIN Document_Subsets AS T3 ON T2.Document_Subset_ID =  T3.Document_Subset_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""Document_Subsets.Document_Subset_Name"" and ""Document_Subset_Members.Document_Object_ID."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between ""Document_Subsets"" and ""Document_Subset_Members"" on ""Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID"" to link each document subset with its related document IDs. 4. Aggregation Structure: No aggregation is required as the query simply lists the document subset names and their related document IDs.",1.0
790,What are the titles of books that have never been ordered?,NESTED,book_1,"[Book.Title,Book.ISBN,Books_Order.ISBN = Book.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book WHERE Book.ISBN NOT IN (SELECT Books_Order.ISBN FROM Books_Order);,SELECT title FROM book EXCEPT SELECT T1.title FROM book AS T1 JOIN books_order AS T2 ON T1.isbn  =  T2.isbn,"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of books. Use the FROM clause to specify the Book table. Apply a WHERE clause to filter books that have never been ordered by ensuring their ISBN is not present in the Books_Order table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude books whose ISBN appears in the Books_Order table, meaning they have been ordered. 3. Join Structure: Not required, as we only need to filter based on the absence of matching ISBN entries in the Books_Order table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
791,What is the rating of the book with the largest number of chapters?,NESTED,book_review,"[book.Chapters, book.Book_ID, review.Rating, review.Book_ID = book.Book_ID]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
",SELECT review.Rating FROM book JOIN review ON review.Book_ID = book.Book_ID WHERE book.Chapters = (SELECT MAX(Chapters) FROM book);,SELECT T2.Rating FROM book AS T1 JOIN review AS T2 ON T1.Book_ID  =  T2.Book_ID ORDER BY T1.Chapters DESC LIMIT 1,1. Sequential Structure: Start with the SELECT clause to retrieve the rating of the book. Use the FROM clause to specify the book and review tables. Use a subquery to determine the book with the largest number of chapters. 2. Condition Structure: Use a WHERE clause to filter for the book with the largest number of chapters by comparing the chapters of each book to the maximum number of chapters. 3. Join Structure: Use an INNER JOIN between the book and review tables based on the Book_ID to connect the book details with their ratings. 4. Aggregation Structure: Use MAX in a subquery to find the book with the largest number of chapters.,1.0
792,List the title and audio length for all the books in descending order of the number of readers.,NON-NESTED,book_review,"[book.Title, book.Audio, review.Readers_in_Million, review.Book_ID = book.Book_ID]","Table book, columns = [*,Book_ID,Title,Type,Pages,Chapters,Audio,Release]
Table review, columns = [*,Review_ID,Book_ID,Rating,Readers_in_Million,Rank]
","Foreign_keys = [review.Book_ID = book.Book_ID]
","SELECT book.Title, book.Audio FROM book JOIN review ON review.Book_ID = book.Book_ID ORDER BY review.Readers_in_Million DESC;","SELECT T1.Title ,  T1.audio FROM book AS T1 JOIN review AS T2 ON T1.Book_ID  =  T2.Book_ID ORDER BY T2.Readers_in_Million DESC","1. Sequential Structure: Start with the SELECT clause to retrieve ""book.Title"" and ""book.Audio."" Additionally, include the number of readers from the ""review.Readers_in_Million"" field for sorting purposes. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""book"" and ""review"" tables based on the shared key ""Book_ID"" to associate each book with its review data. 4. Aggregation Structure: No aggregation is required, but use ORDER BY in descending order on ""review.Readers_in_Million"" to sort the books by the number of readers.",1.0
793,Show the names of club leaders that joined their club before 2018.,NON-NESTED,club_leader,"[member.Name, club_leader.Member_ID = member.Member_ID, club_leader.Year_Join, 2018]","Table club, columns = [*,Club_ID,Overall_Ranking,Team_Leader,Club_Name]
Table club_leader, columns = [*,Club_ID,Member_ID,Year_Join]
Table member, columns = [*,Member_ID,Name,Nationality,Age]
","Foreign_keys = [club_leader.Member_ID = member.Member_ID,club_leader.Club_ID = club.Club_ID]
",SELECT member.Name FROM club_leader JOIN member ON club_leader.Member_ID = member.Member_ID WHERE club_leader.Year_Join < 2018;,"SELECT T3.Name ,  T2.Club_Name FROM club_leader AS T1 JOIN club AS T2 ON T1.Club_ID  =  T2.Club_ID JOIN member AS T3 ON T1.Member_ID  =  T3.Member_ID WHERE T1.Year_Join  <  2018","1. Sequential Structure: Start with the SELECT clause to retrieve the names of club leaders. The ""member.Name"" field is required for this. 2. Condition Structure: Use a WHERE clause to filter for club leaders who joined their club before the year 2018. This condition will be applied on the ""club_leader.Year_Join"" field. 3. Join Structure: Use a JOIN between the ""club_leader"" and ""member"" tables based on the ""Member_ID"" field to associate each club leader with their corresponding name. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific records based on the condition.",0.0
794,"For each document object id, how many collections does it belong to?",NON-NESTED,cre_Doc_and_collections,"[Document_Objects.Document_Object_ID, Documents_in_Collections.Collection_ID, Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID, Documents_in_Collections.Collection_ID = Collections.Collection_ID]","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
","SELECT Document_Objects.Document_Object_ID, COUNT(Documents_in_Collections.Collection_ID) AS Collection_Count FROM Document_Objects JOIN Documents_in_Collections ON Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID GROUP BY Document_Objects.Document_Object_ID;","SELECT count(*) ,  T2.Document_Object_ID FROM Collections AS T1 JOIN Documents_in_Collections AS T2 ON T1.Collection_ID = T2.Collection_ID GROUP BY T2.Document_Object_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""Document_Objects.Document_Object_ID"" and the count of collections it belongs to. Use COUNT on ""Documents_in_Collections.Collection_ID"" to count the number of collections for each document object. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between ""Document_Objects"" and ""Documents_in_Collections"" on ""Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID"" to associate each document object with its collections. 4. Aggregation Structure: Use COUNT to count the number of collections for each document object and GROUP BY ""Document_Objects.Document_Object_ID"" to group the results by each document object.",1.0
795,"What are the names, codes, states, and countries for all cities?",EASY,address_1,"[City.city_name, City.city_code, City.state, City.country]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.city_name, City.city_code, City.state, City.country FROM City;","SELECT city_name ,  city_code ,  state ,  country FROM City","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""City.city_name"", ""City.city_code"", ""City.state"", and ""City.country"". 2. Condition Structure: No specific filtering condition is required as the query asks for all cities. 3. Join Structure: No JOIN is required since all necessary information is available in the ""City"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all the specified fields for all cities.",1.0
796,What are the different document object ids that are in the collection named Best but not in the subset named 'Best for 2000'?,NESTED,cre_Doc_and_collections,"[Collections.Collection_Name,Collections.Collection_ID = Documents_in_Collections.Collection_ID,Documents_in_Collections.Document_Object_ID,Document_Subsets.Document_Subset_Name,Document_Subsets.Document_Subset_ID = Document_Subset_Members.Document_Subset_ID,Document_Subset_Members.Document_Object_ID,'Best','Best for 2000']","Table Collection_Subset_Members, columns = [*,Collection_ID,Related_Collection_ID,Collection_Subset_ID]
Table Collection_Subsets, columns = [*,Collection_Subset_ID,Collection_Subset_Name,Collecrtion_Subset_Details]
Table Collections, columns = [*,Collection_ID,Parent_Collection_ID,Collection_Name,Collection_Description]
Table Document_Objects, columns = [*,Document_Object_ID,Parent_Document_Object_ID,Owner,Description,Other_Details]
Table Document_Subset_Members, columns = [*,Document_Object_ID,Related_Document_Object_ID,Document_Subset_ID]
Table Document_Subsets, columns = [*,Document_Subset_ID,Document_Subset_Name,Document_Subset_Details]
Table Documents_in_Collections, columns = [*,Document_Object_ID,Collection_ID]
","Foreign_keys = [Documents_in_Collections.Collection_ID = Collections.Collection_ID,Documents_in_Collections.Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Subset_ID = Document_Subsets.Document_Subset_ID,Document_Subset_Members.Related_Document_Object_ID = Document_Objects.Document_Object_ID,Document_Subset_Members.Document_Object_ID = Document_Objects.Document_Object_ID,Collection_Subset_Members.Collection_Subset_ID = Collection_Subsets.Collection_Subset_ID,Collection_Subset_Members.Related_Collection_ID = Collections.Collection_ID,Collection_Subset_Members.Collection_ID = Collections.Collection_ID]
",SELECT DISTINCT Documents_in_Collections.Document_Object_ID FROM Collections JOIN Documents_in_Collections ON Collections.Collection_ID = Documents_in_Collections.Collection_ID WHERE Collections.Collection_Name = 'Best' AND Documents_in_Collections.Document_Object_ID NOT IN ( SELECT Document_Subset_Members.Document_Object_ID FROM Document_Subsets JOIN Document_Subset_Members ON Document_Subsets.Document_Subset_ID = Document_Subset_Members.Document_Subset_ID WHERE Document_Subsets.Document_Subset_Name = 'Best for 2000' );,"SELECT DISTINCT T2.Document_Object_ID FROM Collections AS T1 JOIN Documents_in_Collections AS T2 ON T1.Collection_ID = T2.Collection_ID WHERE T1.Collection_Name = ""Best"" EXCEPT SELECT DISTINCT T3.Document_Object_ID FROM Document_Subset_Members AS T3 JOIN Document_Subsets AS T4 ON T3.Document_Subset_ID =  T4.Document_Subset_ID WHERE T4.Document_Subset_Name = ""Best for 2000""","1. Sequential Structure: Start with the SELECT clause to retrieve distinct document object IDs. Use the FROM clause to specify the relevant tables. Apply a WHERE clause to filter for document object IDs that are in the collection named 'Best' but not in the subset named 'Best for 2000'. 2. Condition Structure: Use the WHERE clause to filter for document object IDs that belong to the collection named 'Best' and exclude those that are part of the subset named 'Best for 2000'. This involves using subqueries to identify the relevant collection and subset IDs. 3. Join Structure: Use JOINs to connect the Collections table with the Documents_in_Collections table based on Collection_ID, and the Document_Subsets table with the Document_Subset_Members table based on Document_Subset_ID. This allows us to relate collections and subsets to their respective document object IDs. 4. Aggregation Structure: Not required, as we are retrieving specific document object IDs without any aggregation.",1.0
797,How many cities are in Canada?,EASY,address_1,"[City.city_name,City.country]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT COUNT(City.city_name) FROM City WHERE City.country = 'Canada';,"SELECT count(*) FROM City WHERE country  =  ""CANADA""","1. Sequential Structure: Start with the SELECT clause to count the number of cities in Canada. 2. Condition Structure: Use a WHERE clause to filter cities where the ""City.country"" is 'Canada'. 3. Join Structure: No JOIN is required since all necessary information is in the ""City"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cities in Canada.",0.0
798,"Show the names of customers and names of dishes they order, in descending order of the quantity of dish.",NON-NESTED,restaurant_bills,"[customer.Name, customer_order.Dish_Name, customer_order.Quantity, customer.Customer_ID = customer_order.Customer_ID]","Table branch, columns = [*,Branch_ID,Manager,Years_opened,Location_of_office]
Table customer, columns = [*,Customer_ID,Name,Nationality,Card_Credit,Level_of_Membership]
Table customer_order, columns = [*,Customer_ID,Branch_ID,Dish_Name,Quantity]
","Foreign_keys = [customer_order.Branch_ID = branch.Branch_ID,customer_order.Customer_ID = customer.Customer_ID]
","SELECT customer.Name, customer_order.Dish_Name FROM customer JOIN customer_order ON customer.Customer_ID = customer_order.Customer_ID ORDER BY customer_order.Quantity DESC;","SELECT T1.Name ,  T2.Dish_Name FROM customer AS T1 JOIN customer_order AS T2 ON T1.Customer_ID  =  T2.Customer_ID ORDER BY T2.Quantity DESC","1. Sequential Structure: Start with the SELECT clause to retrieve ""customer.Name"" and ""customer_order.Dish_Name."" Additionally, include ""customer_order.Quantity"" to sort the results based on the quantity of the dish. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""customer"" and ""customer_order"" tables based on the shared key ""customer.Customer_ID = customer_order.Customer_ID"" to link customers with their orders. 4. Aggregation Structure: No aggregation is required, but apply ORDER BY in descending order of ""customer_order.Quantity"" to sort the results as specified.",1.0
799,Show all book isbns and the total amount ordered for each.,NON-NESTED,book_1,"[Books_Order.ISBN, Books_Order.amount, Book.ISBN = Books_Order.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
","SELECT Books_Order.ISBN, SUM(Books_Order.amount) AS total_amount FROM Book JOIN Books_Order ON Book.ISBN = Books_Order.ISBN GROUP BY Books_Order.ISBN;","SELECT isbn ,  sum(amount) FROM Books_Order GROUP BY isbn","1. Sequential Structure: Start with the SELECT clause to retrieve ""Books_Order.ISBN"" and the total amount ordered for each ISBN. Use the SUM function on ""Books_Order.amount"" to calculate the total amount ordered. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Book"" and ""Books_Order"" tables based on the shared ""ISBN"" field to link each book with its order details. 4. Aggregation Structure: Use SUM to aggregate the ""Books_Order.amount"" for each ISBN and GROUP BY ""Books_Order.ISBN"" to group the results by ISBN.",1.0
800,Find the number of students living in each city.,NON-NESTED,address_1,"[Student.city_code,City.city_code,City.city_name,Student.city_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.city_name, COUNT(Student.id) AS student_count FROM Student JOIN City ON Student.city_code = City.city_code GROUP BY City.city_name;","SELECT T1.city_name ,  count(*) FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.city_code","1. Sequential Structure: Start with the SELECT clause to retrieve the city name and the count of students living in each city. Use ""City.city_name"" and COUNT(Student.id) for this purpose. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Student"" and ""City"" tables based on the relationship ""Student.city_code = City.city_code"" to associate students with their respective cities. 4. Aggregation Structure: Use COUNT to count the number of students for each city and GROUP BY ""City.city_name"" to group the results by city.",0.0
801,Show the first name and the last name for students living in state MD.,NON-NESTED,address_1,"[Student.Fname, Student.LName, Student.city_code = City.city_code, City.state, MD]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT Student.Fname, Student.LName FROM Student JOIN City ON Student.city_code = City.city_code WHERE City.state = 'MD';","SELECT T2.Fname ,  T2.Lname FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE T1.state  =  ""MD""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Student.Fname"" and ""Student.LName."" 2. Condition Structure: Use a WHERE clause to filter for students living in the state ""MD."" This requires checking the ""City.state"" field for the value ""MD."" 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the shared key ""Student.city_code = City.city_code"" to associate each student with their city information. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without any summarization.",1.0
802,Show the book title corresponding to the book with the most number of orders.,NON-NESTED,book_1,"[Book.Title,Books_Order.ISBN,Books_Order.amount,Books_Order.ISBN = Book.ISBN]","Table Author, columns = [*,idAuthor,Name]
Table Author_Book, columns = [*,ISBN,Author]
Table Book, columns = [*,ISBN,Title,Author,PurchasePrice,SalePrice]
Table Books_Order, columns = [*,ISBN,IdOrder,amount]
Table Client, columns = [*,IdClient,Name,Address,NumCC]
Table Orders, columns = [*,IdOrder,IdClient,DateOrder,DateExped]
","Foreign_keys = [Author_Book.ISBN = Book.ISBN,Books_Order.IdOrder = Orders.IdOrder,Books_Order.ISBN = Book.ISBN]
",SELECT Book.Title FROM Book JOIN Books_Order ON Books_Order.ISBN = Book.ISBN GROUP BY Book.ISBN ORDER BY SUM(Books_Order.amount) DESC LIMIT 1;,SELECT T2.title FROM Books_Order AS T1 JOIN Book AS T2 ON T1.isbn  =  T2.isbn GROUP BY T1.isbn ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Book.Title"" corresponding to the book with the most number of orders. Use an aggregate function (SUM) on ""Books_Order.amount"" to calculate the total number of orders for each book. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the book with the highest number of orders. 3. Join Structure: Use a JOIN between the ""Book"" and ""Books_Order"" tables based on the ""ISBN"" field to link each book with its order details. 4. Aggregation Structure: Use SUM to calculate the total number of orders for each book, then use ORDER BY in descending order on the aggregated value to rank books by the number of orders. Use LIMIT 1 to select the book with the highest number of orders.",1.0
803,How many students live in each country?,NON-NESTED,address_1,"[Student.city_code, City.country, Student.city_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.country, COUNT(Student.city_code) AS student_count FROM Student JOIN City ON Student.city_code = City.city_code GROUP BY City.country;","SELECT T1.country ,  count(*) FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.country","1. Sequential Structure: Start with the SELECT clause to retrieve the country and the count of students living in each country. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to associate each student with their respective country. 4. Aggregation Structure: Use COUNT to count the number of students for each country and GROUP BY the ""City.country"" field to group the results by country.",1.0
804,Find the number of reservations for each boat with id greater than 50.,NON-NESTED,boat_1,"[Boats.bid,Reserves.bid,Reserves.bid = Boats.bid,50]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Boats.bid, COUNT(Reserves.bid) AS reservation_count FROM Boats JOIN Reserves ON Boats.bid = Reserves.bid WHERE Boats.bid > 50 GROUP BY Boats.bid;","SELECT bid ,  count(*) FROM Reserves GROUP BY bid HAVING bid  >  50","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Boats.bid"" and the count of reservations for each boat. Use COUNT on ""Reserves.bid"" to count the number of reservations. 2. Condition Structure: Apply a WHERE clause to filter for boats with an ID greater than 50. 3. Join Structure: Use a JOIN between the ""Boats"" and ""Reserves"" tables based on the shared ""bid"" field to associate each boat with its reservations. 4. Aggregation Structure: Use GROUP BY on ""Boats.bid"" to group the results by each boat ID and apply COUNT to calculate the number of reservations for each boat.",1.0
805,Find the number of reservations by sailors with id greater than 1 for each boat.,NON-NESTED,boat_1,"[Sailors.sid, Reserves.sid, Reserves.bid, Boats.bid, Reserves.day, Sailors.sid > 1]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Reserves.bid, COUNT(Reserves.sid) AS reservation_count FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid WHERE Sailors.sid > 1 GROUP BY Reserves.bid;","SELECT bid ,  count(*) FROM Reserves WHERE sid  >  1 GROUP BY bid","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Reserves.bid"" (boat ID) and the count of reservations for each boat. Use COUNT to count the number of reservations. 2. Condition Structure: Apply a WHERE clause to filter for sailors with ""Sailors.sid > 1."" 3. Join Structure: Use a JOIN between the ""Sailors"" and ""Reserves"" tables on ""Sailors.sid = Reserves.sid"" to associate sailors with their reservations. 4. Aggregation Structure: Use COUNT to count the number of reservations for each boat and GROUP BY ""Reserves.bid"" to group the results by boat ID.",1.0
806,How many sailors exist?,EASY,boat_1,[Sailors.sid],"Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT COUNT(Sailors.sid) AS total_sailors FROM Sailors;,SELECT COUNT(*) FROM Sailors,"1. Sequential Structure: Start with the SELECT clause to count the number of sailors. 2. Aggregation Structure: Use the COUNT function to calculate the total number of sailors. 3. Join Structure: No JOIN is required since all necessary data is within the ""Sailors"" table. 4. Condition Structure: No specific filtering condition is needed as we want the total count of all sailors.",1.0
807,What is the name and id of every sailor who reserved one or more boats?,NON-NESTED,boat_1,"[Sailors.sid, Sailors.name, Reserves.sid = Sailors.sid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT DISTINCT Sailors.name, Sailors.sid FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid;","SELECT DISTINCT T1.name ,  T1.sid FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.name"" and ""Sailors.sid"" fields. 2. Condition Structure: No specific filtering condition is required since we are interested in all sailors who reserved one or more boats. 3. Join Structure: Use a JOIN between the ""Sailors"" and ""Reserves"" tables based on the shared key ""Sailors.sid = Reserves.sid"" to link sailors with their reservations. 4. Aggregation Structure: Use DISTINCT to ensure that each sailor is listed only once, even if they reserved multiple boats.",1.0
808,Find the name and number of citations of the author who has most citations among all authors?,NON-NESTED,aan_1,"[Author.name, Citation.paper_id, Citation.cited_paper_id = Paper.paper_id, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Author.name, COUNT(Citation.cited_paper_id) AS total_citations FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id JOIN Citation ON Citation.cited_paper_id = Paper.paper_id GROUP BY Author.name ORDER BY total_citations DESC LIMIT 1;","SELECT T3.name ,  count(*) FROM Citation AS T1 JOIN Author_list AS T2 ON T1.cited_paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id GROUP BY T2.author_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Author.name"" and the total number of citations. Use an aggregate function (COUNT) to calculate the total citations for each author. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the author with the most citations. 3. Join Structure: Use JOINs to connect the ""Author"" table with the ""Author_list"" table on ""Author.author_id"" and ""Author_list.author_id,"" then connect ""Author_list"" with the ""Paper"" table on ""Author_list.paper_id"" and ""Paper.paper_id."" Finally, connect the ""Citation"" table with the ""Paper"" table on ""Citation.cited_paper_id = Paper.paper_id"" to count the citations for each author's papers. 4. Aggregation Structure: Use COUNT to calculate the total number of citations for each author, then use ORDER BY in descending order to rank authors by their citation count. Use LIMIT 1 to select the author with the most citations.",1.0
809,What are the names of sailors who reserved a boat with the name Melon?,NON-NESTED,boat_1,"[Sailors.name, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, Boats.name, Melon]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Sailors.name FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Boats.name = 'Melon';,SELECT T1.name FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid JOIN Boats AS T3 ON T3.bid  =  T2.bid WHERE T3.name  =  'Melon',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of sailors (""Sailors.name""). 2. Condition Structure: Use a WHERE clause to filter for boats with the name ""Melon."" 3. Join Structure: Use JOINs to connect the ""Sailors,"" ""Reserves,"" and ""Boats"" tables. Join ""Sailors"" with ""Reserves"" on ""Sailors.sid = Reserves.sid"" and ""Reserves"" with ""Boats"" on ""Reserves.bid = Boats.bid"" to link sailors with the boats they reserved. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of sailors.",1.0
810,What are the states with more than 5 students?,NON-NESTED,address_1,"[Student.city_code, City.state, Student.StuID, Student.city_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.state FROM Student JOIN City ON Student.city_code = City.city_code GROUP BY City.state HAVING COUNT(Student.StuID) > 5;,SELECT T1.state FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code GROUP BY T1.state HAVING count(*)  >  5,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.state"" field. Since we are interested in states with more than 5 students, we will use an aggregation function (COUNT) on ""Student.StuID"" to count the number of students per state. 2. Condition Structure: Use a HAVING clause to filter states where the count of students is greater than 5. 3. Join Structure: Use an INNER JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to associate each student with their respective state. 4. Aggregation Structure: Use COUNT on ""Student.StuID"" to count the number of students per state, and GROUP BY ""City.state"" to group the results by state.",1.0
811,Count the number of papers in NAACL 2000.,EASY,aan_1,"[Paper.paper_id, Paper.venue, Paper.year]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Paper.paper_id) FROM Paper WHERE Paper.venue = 'NAACL' AND Paper.year = 2000;,"SELECT count(*) FROM Paper WHERE venue  =  ""NAACL"" AND YEAR  =  2000","1. Sequential Structure: Start with the SELECT clause to count the number of papers, using the COUNT function on ""Paper.paper_id"". 2. Condition Structure: Use a WHERE clause to filter papers where the ""Paper.venue"" is 'NAACL' and the ""Paper.year"" is 2000. 3. Join Structure: No JOIN is required since all necessary information is in the ""Paper"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of papers that meet the specified conditions.",1.0
812,"Count the number of collaborators that Mckeown , Kathleen has had .",NON-NESTED,aan_1,"[Author.name, Author.author_id, Author_list.author_id, Author_list.paper_id, Author_list.affiliation_id, Paper.paper_id, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT COUNT(DISTINCT A2.author_id) FROM Author AS A1 JOIN Author_list AS AL1 ON A1.author_id = AL1.author_id JOIN Author_list AS AL2 ON AL1.paper_id = AL2.paper_id JOIN Author AS A2 ON AL2.author_id = A2.author_id WHERE A1.name = 'Mckeown, Kathleen' AND A1.author_id != A2.author_id;","select count (distinct t2.author_id) from author_list as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id and t1.author_id != t2.author_id join author as t3 on t1.author_id  =  t3.author_id where t3.name = ""mckeown ,  kathleen""","1. Sequential Structure: Start with the SELECT clause to count the distinct collaborators of the author ""Mckeown, Kathleen."" Use COUNT with DISTINCT on ""Author_list.author_id"" to ensure unique collaborators are counted. 2. Condition Structure: Use a WHERE clause to filter for the specific author ""Mckeown, Kathleen"" by matching ""Author.name."" Exclude the author themselves from the count by ensuring the collaborator's ""author_id"" is not the same as the author's ""author_id."" 3. Join Structure: Use JOINs to connect the ""Author"" table with the ""Author_list"" table on ""Author.author_id = Author_list.author_id"" and the ""Author_list"" table with itself on ""Author_list.paper_id"" to find all collaborators on the same papers. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique collaborators for the specified author.",1.0
813,Give the title of the paper with the most authors.,NON-NESTED,aan_1,"[Paper.title, Author_list.paper_id, Author_list.author_id, Author_list.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Paper.title FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id GROUP BY Paper.paper_id ORDER BY COUNT(Author_list.author_id) DESC LIMIT 1;,SELECT T2.title FROM Author_list AS T1 JOIN Paper AS T2 ON T1.paper_id  =  T2.paper_id GROUP BY T2.paper_id ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paper.title."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in the paper with the most authors. 3. Join Structure: Use a JOIN between the ""Paper"" and ""Author_list"" tables based on ""paper_id"" to associate each paper with its authors. 4. Aggregation Structure: Use COUNT on ""Author_list.author_id"" to count the number of authors per paper. Use ORDER BY in descending order to rank papers by the number of authors, and LIMIT 1 to select the paper with the most authors.",1.0
814,Find all papers with titles and paper IDs collaborated by Stanford University and Columbia University.,NON-NESTED,aan_1,"[Paper.paper_id, Paper.title, Author_list.paper_id = Paper.paper_id, Author_list.affiliation_id = Affiliation.affiliation_id, Affiliation.name, 'Stanford University', 'Columbia University']","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.title, Paper.paper_id FROM Paper JOIN Author_list ON Author_list.paper_id = Paper.paper_id JOIN Affiliation ON Author_list.affiliation_id = Affiliation.affiliation_id WHERE Affiliation.name IN ('Stanford University', 'Columbia University') GROUP BY Paper.paper_id, Paper.title HAVING COUNT(DISTINCT Affiliation.name) = 2;","SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T3.name LIKE ""Stanford University"" INTERSECT SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T3.name LIKE ""Columbia University""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Paper.title"" and ""Paper.paper_id."" 2. Condition Structure: Use a WHERE clause to filter for papers where the affiliations include both ""Stanford University"" and ""Columbia University."" 3. Join Structure: Use JOINs to connect ""Paper"" with ""Author_list"" on ""Author_list.paper_id = Paper.paper_id"" and ""Author_list"" with ""Affiliation"" on ""Author_list.affiliation_id = Affiliation.affiliation_id"" to link papers with their respective affiliations. 4. Aggregation Structure: Use GROUP BY on ""Paper.paper_id"" and ""Paper.title"" to group results by paper, and apply a HAVING clause to ensure that both affiliations (""Stanford University"" and ""Columbia University"") are present for each paper.",1.0
815,"Which headphone classes have both headphones with ""Bowls"" and headphones with ""Comfort Pads"" earpads?",NESTED,headphone_store,"[headphone.Class, headphone.Earpads]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Class FROM headphone WHERE headphone.Earpads IN ('Bowls', 'Comfort Pads') GROUP BY headphone.Class HAVING COUNT(DISTINCT headphone.Earpads) = 2;",SELECT CLASS FROM headphone WHERE earpads  =  'Bowls' INTERSECT SELECT CLASS FROM headphone WHERE earpads  =  'Comfort Pads',"1. Sequential Structure: Start with the SELECT clause to retrieve the headphone classes. Use the FROM clause to specify the headphone table. Apply a WHERE clause to filter for classes that have both ""Bowls"" and ""Comfort Pads"" earpads. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the headphone class has both ""Bowls"" and ""Comfort Pads"" earpads. This can be achieved by grouping by the headphone class and filtering for classes that meet both conditions. 3. Join Structure: Not required, as all data is available within the headphone table. 4. Aggregation Structure: Use GROUP BY to group records by headphone class and HAVING to ensure that both ""Bowls"" and ""Comfort Pads"" earpads exist for the class.",1.0
816,Which headphone model has the largest quantity of stock across all the stores?,NON-NESTED,headphone_store,"[headphone.Model, stock.Quantity, stock.Headphone_ID = headphone.Headphone_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Model, SUM(stock.Quantity) AS Total_Stock FROM headphone JOIN stock ON headphone.Headphone_ID = stock.Headphone_ID GROUP BY headphone.Model ORDER BY Total_Stock DESC LIMIT 1;",SELECT t1.model FROM headphone AS t1 JOIN stock AS t2 ON t1.headphone_id  =  t2.headphone_id GROUP BY t1.model ORDER BY sum(t2.quantity) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""headphone.Model"" and the total stock quantity. Use an aggregate function (SUM) on ""stock.Quantity"" to calculate the total stock for each headphone model. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the headphone model with the largest total stock across all stores. 3. Join Structure: Use a JOIN between the ""headphone"" and ""stock"" tables based on the shared key ""headphone.Headphone_ID = stock.Headphone_ID"" to link each headphone model with its stock information. 4. Aggregation Structure: Use SUM to calculate the total stock for each headphone model, then use ORDER BY in descending order on the total stock quantity to rank the models. Use LIMIT 1 to select the model with the largest stock.",1.0
817,What is the count of the sailors whose name starts with letter D ?,EASY,boat_1,[Sailors.name],"Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT COUNT(*) FROM Sailors WHERE Sailors.name LIKE 'D%';,select count(*) from sailors where name like 'd%',"1. Sequential Structure: Start with the SELECT clause to count the number of sailors whose names start with the letter 'D'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter sailor names that start with 'D'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Sailors"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of sailors meeting the condition.",1.0
818,"Find all papers with titles and paper IDs co-authored by Mckeown, Kathleen and Rambow, Owen.",NON-NESTED,aan_1,"[Paper.paper_id, Paper.title, Author.name, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Mckeown, Kathleen, Rambow, Owen]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.paper_id, Paper.title FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id JOIN Author ON Author_list.author_id = Author.author_id WHERE Author.name IN ('Mckeown, Kathleen', 'Rambow, Owen') GROUP BY Paper.paper_id, Paper.title HAVING COUNT(DISTINCT Author.name) = 2;","SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id WHERE T3.name LIKE ""%Mckeown ,  Kathleen%"" INTERSECT SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id WHERE T3.name LIKE ""%Rambow ,  Owen%""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Paper.paper_id"" and ""Paper.title."" 2. Condition Structure: Use a WHERE clause to filter for papers co-authored by both ""Mckeown, Kathleen"" and ""Rambow, Owen."" This requires identifying papers where both authors are listed as co-authors. 3. Join Structure: Use JOINs to connect the ""Paper"" table with the ""Author_list"" table on ""Paper.paper_id"" and then with the ""Author"" table on ""Author_list.author_id = Author.author_id"" to link papers with their authors. 4. Aggregation Structure: Use GROUP BY on ""Paper.paper_id"" and ""Paper.title"" to group results by paper. Use a HAVING clause to ensure that only papers with both authors are included by counting distinct author names and checking for the presence of both ""Mckeown, Kathleen"" and ""Rambow, Owen.""",1.0
819,"Give the average, minimum, and maximum distances between two cities.",EASY,address_1,[Direct_distance.distance],"Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT AVG(Direct_distance.distance) AS avg_distance, MIN(Direct_distance.distance) AS min_distance, MAX(Direct_distance.distance) AS max_distance FROM Direct_distance;","SELECT avg(distance) ,  min(distance) ,  max(distance) FROM Direct_distance","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average, minimum, and maximum distances. 2. Aggregation Structure: Use AVG, MIN, and MAX functions to calculate the average, minimum, and maximum distances between two cities. 3. Join Structure: No JOIN is required since all necessary data is within the ""Direct_distance"" table. 4. Condition Structure: No specific filtering condition is required as the query asks for aggregate values across all distances.",1.0
820,How many papers are published in year 2009 by Columbia University?,NON-NESTED,aan_1,"[Paper.year, Paper.paper_id, Author_list.paper_id = Paper.paper_id, Author_list.affiliation_id, Affiliation.affiliation_id, Affiliation.name, 2009, Columbia University]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Paper.paper_id) FROM Paper JOIN Author_list ON Author_list.paper_id = Paper.paper_id JOIN Affiliation ON Author_list.affiliation_id = Affiliation.affiliation_id WHERE Paper.year = 2009 AND Affiliation.name = 'Columbia University';,"SELECT count(DISTINCT T1.paper_id) FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T3.name LIKE ""Columbia University"" AND T1.year  =  2009","1. Sequential Structure: Start with the SELECT clause to count the number of papers published in the year 2009. Use COUNT on ""Paper.paper_id"" to get the total number of papers. 2. Condition Structure: Use a WHERE clause to filter for papers published in the year 2009 and where the affiliation name is ""Columbia University."" 3. Join Structure: Use JOINs to connect the ""Paper"" table with the ""Author_list"" table on ""paper_id"" and then connect the ""Author_list"" table with the ""Affiliation"" table on ""affiliation_id"" to link papers with their respective affiliations. 4. Aggregation Structure: Use COUNT to aggregate the total number of papers that meet the specified conditions.",0.0
821,Find all earpads that do not use plastic construction.,NESTED,headphone_store,"[headphone.Earpads, headphone.Construction]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT Earpads FROM headphone WHERE Construction != 'plastic';,SELECT earpads FROM headphone EXCEPT SELECT earpads FROM headphone WHERE construction  =  'Plastic',"1. Sequential Structure: Start with the SELECT clause to retrieve the earpads from the headphone table. Use the FROM clause to specify the headphone table. Apply a WHERE clause to filter out earpads that use plastic construction. 2. Condition Structure: Use the WHERE clause to exclude rows where the construction is 'plastic'. 3. Join Structure: Not required, as all data is available within the headphone table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
822,Find the neighborhood where no headphones are in stock.,NESTED,headphone_store,"[store.Neighborhood,stock.Quantity,stock.Store_ID = store.Store_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT store.Neighborhood FROM store JOIN stock ON stock.Store_ID = store.Store_ID WHERE stock.Quantity = 0 AND stock.Item = 'Headphones';,SELECT Neighborhood FROM store EXCEPT SELECT t1.Neighborhood FROM store AS t1 JOIN stock AS t2 ON t1.store_id  =  t2.store_id,"1. Sequential Structure: Start with the SELECT clause to retrieve the neighborhood where no headphones are in stock. Use the FROM clause to specify the store table and JOIN it with the stock table to connect neighborhoods with stock information. Apply a WHERE clause to filter for headphones and ensure their quantity is zero. 2. Condition Structure: Use the WHERE clause to filter for items that are headphones and have a quantity of zero. 3. Join Structure: Use an INNER JOIN between the store and stock tables based on the Store_ID to link neighborhoods with stock data. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
823,What are the ids and titles for papers that have never been cited?,NESTED,aan_1,"[Paper.paper_id, Paper.title, Citation.cited_paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.paper_id, Paper.title FROM Paper WHERE Paper.paper_id NOT IN (SELECT Citation.cited_paper_id FROM Citation);","SELECT paper_id ,  title FROM Paper WHERE paper_id NOT IN (SELECT cited_paper_id FROM Citation)","1. Sequential Structure: Start with the SELECT clause to retrieve the paper IDs and titles. Use the FROM clause to specify the Paper table. Apply a WHERE clause to filter papers that have never been cited by ensuring their paper_id is not present in the cited_paper_id column of the Citation table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude papers whose paper_id appears in the cited_paper_id column of the Citation table, meaning they have been cited. 3. Join Structure: Not required, as we only need to filter based on the absence of matching paper_id entries in the Citation table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
824,What are the names and ids of sailors who reserved red and blue boats?,NESTED,boat_1,"[Sailors.sid, Sailors.name, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, Boats.color, Boats.bid, red, blue]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.sid, Sailors.name FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Boats.color IN ('red', 'blue') GROUP BY Sailors.sid, Sailors.name HAVING COUNT(DISTINCT Boats.color) = 2;","SELECT DISTINCT T2.sid ,  T3.name FROM Boats AS T1 JOIN Reserves AS T2 ON  T1.bid  =  T2.bid JOIN Sailors AS T3 ON T2.sid  =  T3.sid WHERE T1.color  =  'red' INTERSECT SELECT DISTINCT T2.sid ,  T3.name FROM Boats AS T1 JOIN Reserves AS T2 ON  T1.bid  =  T2.bid JOIN Sailors AS T3 ON T2.sid  =  T3.sid WHERE T1.color  =  ""blue""","1. Sequential Structure: Start with the SELECT clause to retrieve the names and IDs of sailors. Use the FROM clause to specify the Sailors table and JOIN it with the Reserves and Boats tables to connect sailors with the boats they reserved. Apply a WHERE clause to filter for boats with colors 'red' and 'blue'. 2. Condition Structure: Use the WHERE clause to filter for boats with colors 'red' and 'blue'. To ensure sailors reserved both red and blue boats, use a subquery or grouping logic. 3. Join Structure: Use INNER JOINs between Sailors, Reserves, and Boats tables based on the relationships Sailors.sid = Reserves.sid and Reserves.bid = Boats.bid to connect sailors with the boats they reserved. 4. Aggregation Structure: Use GROUP BY to group records by sailor ID and name, and use a HAVING clause to ensure that each sailor reserved both red and blue boats.",1.0
825,Count the number of papers.,EASY,aan_1,[Paper.paper_id],"Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Paper.paper_id) AS paper_count FROM Paper;,SELECT count(*) FROM Paper,"1. Sequential Structure: Start with the SELECT clause to count the number of papers. 2. Aggregation Structure: Use the COUNT function on the ""Paper.paper_id"" field to calculate the total number of papers. 3. Condition Structure: No specific filtering condition is required as we want the total count of all papers. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paper"" table.",1.0
826,"Count the number of citations Mckeown , Kathleen has .",NON-NESTED,aan_1,"[Author.name, Author.author_id, Author_list.author_id = Author.author_id, Author_list.paper_id, Citation.paper_id, Citation.cited_paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT COUNT(Citation.cited_paper_id) FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id JOIN Citation ON Paper.paper_id = Citation.cited_paper_id WHERE Author.name = 'Mckeown, Kathleen';","select count(*) from citation as t1 join author_list as t2 on t1.cited_paper_id  =  t2.paper_id join author as t3 on t2.author_id  =  t3.author_id where t3.name = ""mckeown ,  kathleen""","1. Sequential Structure: Start with the SELECT clause to count the number of citations. Since we are counting citations for a specific author, we will use COUNT on ""Citation.cited_paper_id."" 2. Condition Structure: Use a WHERE clause to filter for the author ""Mckeown, Kathleen."" This requires joining the relevant tables to identify the papers authored by her and then counting the citations for those papers. 3. Join Structure: Use JOINs to connect the ""Author"" table with ""Author_list"" on ""Author.author_id,"" then connect ""Author_list"" with ""Paper"" on ""Author_list.paper_id."" Finally, connect ""Paper"" with ""Citation"" on ""Paper.paper_id = Citation.cited_paper_id"" to count the citations for the papers authored by ""Mckeown, Kathleen."" 4. Aggregation Structure: Use COUNT to aggregate the number of citations for the papers authored by the specified author.",1.0
827,What is the distance between the cities where Linda Smith and Tracy Kim live?,NON-NESTED,address_1,"[Student.LName, Student.Fname, Student.city_code, City.city_code = Student.city_code, City.city_code = Direct_distance.city1_code, City.city_code = Direct_distance.city2_code, Direct_distance.distance]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Direct_distance.distance FROM Student AS S1 JOIN City AS C1 ON S1.city_code = C1.city_code JOIN Direct_distance AS D ON C1.city_code = D.city1_code JOIN City AS C2 ON D.city2_code = C2.city_code JOIN Student AS S2 ON C2.city_code = S2.city_code WHERE S1.Fname = 'Linda' AND S1.LName = 'Smith' AND S2.Fname = 'Tracy' AND S2.LName = 'Kim';,"SELECT distance FROM Direct_distance AS T1 JOIN Student AS T2 ON T1.city1_code  =  T2.city_code JOIN Student AS T3 ON T1.city2_code  =  T3.city_code WHERE T2.Fname  =  ""Linda"" AND T2.Lname  =  ""Smith"" AND T3.Fname  =  ""Tracy"" AND T3.Lname  =  ""Kim""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Direct_distance.distance"" between the cities where Linda Smith and Tracy Kim live. 2. Condition Structure: Use a WHERE clause to filter for the specific students, ""Linda Smith"" and ""Tracy Kim,"" based on their first and last names. Match their respective city codes to the ""Direct_distance"" table. 3. Join Structure: Use JOINs to connect the ""Student"" table with the ""City"" table on ""Student.city_code = City.city_code"" and then connect the ""City"" table with the ""Direct_distance"" table on ""City.city_code = Direct_distance.city1_code"" and ""City.city_code = Direct_distance.city2_code."" 4. Aggregation Structure: No aggregation is needed, as we are retrieving a specific distance value.",0.0
828,How many conferences are there?,EASY,conference,[conference.Conference_ID],"Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT COUNT(conference.Conference_ID) AS total_conferences FROM conference;,SELECT count(*) FROM conference,"1. Sequential Structure: Start with the SELECT clause to count the number of conferences. 2. Aggregation Structure: Use the COUNT function on ""conference.Conference_ID"" to calculate the total number of conferences. 3. Condition Structure: No specific filtering condition is required as we want the total count of all conferences. 4. Join Structure: No JOIN is necessary since all required data is within the ""conference"" table.",1.0
829,Find the name and age of the oldest sailor.,EASY,boat_1,"[Sailors.name, Sailors.age]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.name, Sailors.age FROM Sailors ORDER BY Sailors.age DESC LIMIT 1;","SELECT name ,  age FROM Sailors WHERE age  =  ( SELECT max(age) FROM Sailors )","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.name"" and ""Sailors.age"" of the oldest sailor. 2. Condition Structure: No specific filtering condition is needed since we are looking for the sailor with the maximum age. 3. Join Structure: No JOIN is required as all necessary information is in the ""Sailors"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""Sailors.age"" to rank sailors by age and apply LIMIT 1 to select the oldest sailor.",1.0
830,What are the names of the boats booked by people between age 20 and 30?,NON-NESTED,boat_1,"[Boats.name, Sailors.age, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, 20, 30]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Boats.name FROM Sailors JOIN Reserves ON Reserves.sid = Sailors.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Sailors.age BETWEEN 20 AND 30;,SELECT T3.name FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid JOIN Boats AS T3 ON T3.bid  =  T2.bid WHERE T1.age BETWEEN 20 AND 30,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the boats (""Boats.name""). 2. Condition Structure: Use a WHERE clause to filter for sailors whose age is between 20 and 30. 3. Join Structure: Use JOINs to connect the ""Sailors"" table with the ""Reserves"" table on ""Reserves.sid = Sailors.sid"" and the ""Reserves"" table with the ""Boats"" table on ""Reserves.bid = Boats.bid"" to link sailors with the boats they reserved. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific boat names.",1.0
831,List the names and ages of all sailors sorted by rating in descending order.,EASY,boat_1,"[Sailors.name, Sailors.age, Sailors.rating]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.name, Sailors.age FROM Sailors ORDER BY Sailors.rating DESC;","SELECT name ,  age FROM Sailors ORDER BY rating DESC","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the names and ages of the sailors. 2. Condition Structure: No specific filtering condition is required as we want all sailors. 3. Join Structure: No JOIN is required since all necessary data is within the ""Sailors"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""Sailors.rating"" in descending order to sort the results by rating.",1.0
832,What are the names of all authors who have more than 50 papers?,NON-NESTED,aan_1,"[Author.name, Author.author_id, Author_list.author_id = Author.author_id, Author_list.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT DISTINCT Author.name FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id GROUP BY Author.author_id HAVING COUNT(Author_list.paper_id) > 50;,SELECT T1.name FROM Author AS T1 JOIN Author_list AS T2 ON T1.author_id  =  T2.author_id GROUP BY T1.author_id HAVING count(*)  >  50,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of authors. Use a GROUP BY clause to group the results by ""Author.author_id"" since we need to count the number of papers for each author. 2. Condition Structure: Use a HAVING clause to filter authors who have more than 50 papers. 3. Join Structure: Use a JOIN between the ""Author"" and ""Author_list"" tables based on ""Author.author_id"" and ""Author_list.author_id"" to associate each author with their papers. 4. Aggregation Structure: Use COUNT on ""Author_list.paper_id"" to count the number of papers for each author.",1.0
833,Give the name of the nearest city to Chicago.,NON-NESTED,address_1,"[City.city_name,City.city_code,Direct_distance.city2_code,Direct_distance.city1_code,Direct_distance.distance,Student.city_code = City.city_code,Direct_distance.city1_code = City.city_code,Direct_distance.city2_code = City.city_code,Chicago]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT C2.city_name FROM City AS C1 JOIN Direct_distance ON C1.city_code = Direct_distance.city1_code JOIN City AS C2 ON Direct_distance.city2_code = C2.city_code WHERE C1.city_name = 'Chicago' ORDER BY Direct_distance.distance ASC LIMIT 1;,"SELECT T3.city_name FROM Direct_distance AS T1 JOIN City AS T2 ON T1.city1_code  =  T2.city_code JOIN City AS T3 ON T1.city2_code  =  T3.city_code WHERE T2.city_name  =  ""Chicago"" ORDER BY distance LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.city_name"" of the nearest city to Chicago. 2. Condition Structure: Use a WHERE clause to filter for records where ""City.city_name"" is Chicago. Then, use the ""Direct_distance"" table to find the city with the smallest distance to Chicago. 3. Join Structure: Use JOINs to connect the ""City"" table with the ""Direct_distance"" table. Specifically, join ""Direct_distance.city1_code"" or ""Direct_distance.city2_code"" with ""City.city_code"" to find the relevant distances. 4. Aggregation Structure: Use ORDER BY on ""Direct_distance.distance"" in ascending order to find the nearest city. Use LIMIT 1 to select only the closest city.",1.0
834,What can you tell me about sailors who are older than age 30?,EASY,boat_1,"[Sailors.sid,Sailors.name,Sailors.rating,Sailors.age,30]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.sid, Sailors.name, Sailors.rating, Sailors.age FROM Sailors WHERE Sailors.age > 30;",SELECT * FROM Sailors WHERE age  >  30,"1. Sequential Structure: Start with the SELECT clause to retrieve all relevant information about sailors, including their ID, name, rating, and age. 2. Condition Structure: Use a WHERE clause to filter sailors whose age is greater than 30. 3. Join Structure: No JOIN is required since all necessary information is in the ""Sailors"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving details of sailors who meet the age condition.",1.0
835,What was the venue and year with the most publications?,EASY,aan_1,"[Paper.venue, Paper.year, Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.venue, Paper.year FROM Paper GROUP BY Paper.venue, Paper.year ORDER BY COUNT(Paper.paper_id) DESC LIMIT 1;","SELECT venue ,  YEAR FROM paper GROUP BY venue ,  YEAR ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the venue and year. 2. Aggregation Structure: Use COUNT to calculate the number of publications (paper_id) for each combination of venue and year. 3. Grouping Structure: Use GROUP BY on ""Paper.venue"" and ""Paper.year"" to aggregate the results by venue and year. 4. Ordering Structure: Use ORDER BY in descending order on the count of publications to rank the combinations by the number of publications. 5. Limiting Structure: Use LIMIT 1 to retrieve the venue and year with the most publications. 6. Join Structure: No JOIN is required since all necessary data is within the ""Paper"" table.",1.0
836,What is average age of all sailors who have a rating of 7?,EASY,boat_1,"[Sailors.age, Sailors.rating]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT AVG(Sailors.age) AS average_age FROM Sailors WHERE Sailors.rating = 7;,SELECT AVG(age) FROM Sailors WHERE rating  =  7,"1. Sequential Structure: Start with the SELECT clause to calculate the average age of sailors. 2. Condition Structure: Use a WHERE clause to filter sailors with a rating of 7. 3. Join Structure: No JOIN is required since all necessary data is within the ""Sailors"" table. 4. Aggregation Structure: Use the AVG function to calculate the average age of the filtered sailors.",1.0
837,Find the name and id of Sailors (sid) that reserved red or blue boat.,NON-NESTED,boat_1,"[Sailors.sid, Sailors.name, Reserves.sid = Sailors.sid, Reserves.bid, Boats.bid = Reserves.bid, Boats.color, red, blue]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.sid, Sailors.name FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid JOIN Boats ON Boats.bid = Reserves.bid WHERE Boats.color = 'red' OR Boats.color = 'blue';","SELECT DISTINCT T2.sid ,  T3.name FROM Boats AS T1 JOIN Reserves AS T2 ON  T1.bid  =  T2.bid JOIN Sailors AS T3 ON T2.sid  =  T3.sid WHERE T1.color  =  'red' OR T1.color  =  ""blue""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.sid"" and ""Sailors.name."" 2. Condition Structure: Use a WHERE clause to filter for boats that are either red or blue in color. 3. Join Structure: Use JOINs to connect the ""Sailors"" table with the ""Reserves"" table on ""Sailors.sid = Reserves.sid"" and the ""Boats"" table on ""Boats.bid = Reserves.bid"" to link sailors with the boats they reserved. 4. Aggregation Structure: No aggregation is needed, as the query only requires listing the sailors' names and IDs.",1.0
838,Return the list of distinct headphone models ordered alphabetically.,EASY,headphone_store,[headphone.Model],"Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT DISTINCT headphone.Model FROM headphone ORDER BY headphone.Model ASC;,SELECT DISTINCT model FROM headphone ORDER BY model,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the distinct headphone models. 2. Condition Structure: No specific filtering condition is required as we want all distinct headphone models. 3. Join Structure: No JOIN is required since all necessary data is within the ""headphone"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results alphabetically.",1.0
839,Find the names of sailors whose rating is larger than the rating of all sailors who booked a red boat.,NESTED,boat_1,"[Sailors.name, Sailors.rating, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, Boats.color, red]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Sailors.name FROM Sailors WHERE Sailors.rating > ALL ( SELECT Sailors.rating FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Boats.color = 'red' );,SELECT name FROM Sailors WHERE rating  >  (SELECT max(T1.rating) FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid JOIN Boats AS T3 ON T3.bid  =  T2.bid WHERE T3.color  =  'red'),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of sailors. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors whose rating is larger than the rating of all sailors who booked a red boat. 2. Condition Structure: Use a WHERE clause with a subquery to compare the rating of each sailor against the maximum rating of sailors who booked a red boat. The subquery filters sailors who reserved boats with the color 'red'. 3. Join Structure: Use INNER JOINs between the Sailors, Reserves, and Boats tables to connect sailors with the boats they reserved and filter based on the boat color. 4. Aggregation Structure: Use the subquery to find the maximum rating of sailors who booked a red boat, and compare it with the rating of other sailors in the main query.",0.0
840,"What are the model, class, and construction of the cheapest headphone?",EASY,headphone_store,"[headphone.Model, headphone.Class, headphone.Construction, headphone.Price]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Model, headphone.Class, headphone.Construction FROM headphone ORDER BY headphone.Price ASC LIMIT 1;","SELECT model ,  CLASS ,  construction FROM headphone ORDER BY price LIMIT 1","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""headphone.Model,"" ""headphone.Class,"" and ""headphone.Construction."" 2. Condition Structure: Use ORDER BY on ""headphone.Price"" in ascending order to find the cheapest headphone. 3. Limiting Structure: Use LIMIT 1 to retrieve only the cheapest headphone. 4. Join Structure: No JOIN is required since all necessary data is within the ""headphone"" table. 5. Aggregation Structure: No aggregation is needed as we are retrieving specific fields for the cheapest headphone.",1.0
841,How many papers does Stanford University have between 2000 and 2009?,NON-NESTED,aan_1,"[Affiliation.name, Paper.year, Author_list.affiliation_id = Affiliation.affiliation_id, Author_list.paper_id = Paper.paper_id, Stanford University, 2000, 2009]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Paper.paper_id) FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id JOIN Affiliation ON Author_list.affiliation_id = Affiliation.affiliation_id WHERE Affiliation.name = 'Stanford University' AND Paper.year BETWEEN 2000 AND 2009;,"SELECT count(DISTINCT T1.paper_id) FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T1.year  >=  2000 AND T1.year  <=  2009 AND T3.name LIKE ""Stanford University""","1. Sequential Structure: Start with the SELECT clause to count the number of papers. Use COUNT on ""Paper.paper_id"" to get the total number of papers. 2. Condition Structure: Use a WHERE clause to filter papers published between the years 2000 and 2009 (inclusive) and affiliated with ""Stanford University."" 3. Join Structure: Use JOINs to connect the ""Affiliation"" table with the ""Author_list"" table on ""affiliation_id,"" and the ""Author_list"" table with the ""Paper"" table on ""paper_id"" to link papers with their affiliations. 4. Aggregation Structure: Use COUNT to aggregate the total number of papers that meet the specified conditions.",0.0
842,Count the number of different earpads.,EASY,headphone_store,[headphone.Earpads],"Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT COUNT(DISTINCT headphone.Earpads) AS unique_earpads_count FROM headphone;,SELECT count(DISTINCT earpads) FROM headphone,"1. Sequential Structure: Begin with the SELECT clause to count the number of different earpads. 2. Aggregation Structure: Use COUNT with DISTINCT to count the unique earpads. 3. Join Structure: No JOIN is required since all necessary data is within the ""headphone"" table. 4. Condition Structure: No specific filtering condition is needed as we are counting all unique earpads.",1.0
843,"For each conference name, how many times has it occurred?",NON-NESTED,conference,"[conference.Conference_Name, conference.Conference_ID, conference_participation.Conference_ID = conference.Conference_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT conference.Conference_Name, COUNT(conference_participation.Conference_ID) AS occurrence_count FROM conference JOIN conference_participation ON conference.Conference_ID = conference_participation.Conference_ID GROUP BY conference.Conference_Name;","SELECT conference_name ,  count(*) FROM conference GROUP BY conference_name","1. Sequential Structure: Start with the SELECT clause to retrieve ""conference.Conference_Name"" and the count of occurrences for each conference. Use COUNT to count the occurrences. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""conference"" table and the ""conference_participation"" table on ""conference.Conference_ID"" to link each conference with its participation records. 4. Aggregation Structure: Use COUNT to count the occurrences of each conference and GROUP BY ""conference.Conference_Name"" to group the results by conference name.",1.0
844,What is the rating and average age for sailors who have reserved red boat grouped by rating?,NON-NESTED,boat_1,"[Sailors.rating, Sailors.age, Boats.color, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, red]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.rating, AVG(Sailors.age) AS average_age FROM Sailors JOIN Reserves ON Reserves.sid = Sailors.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Boats.color = 'red' GROUP BY Sailors.rating;","SELECT T1.rating ,  avg(T1.age) FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid JOIN Boats AS T3 ON T3.bid  =  T2.bid WHERE T3.color  =  'red' GROUP BY T1.rating","1. Sequential Structure: Start with the SELECT clause to retrieve ""Sailors.rating"" and the average age of sailors grouped by their rating. Use the AVG function to calculate the average age. 2. Condition Structure: Use a WHERE clause to filter for boats with the color ""red."" This requires filtering on the ""Boats.color"" field. 3. Join Structure: Use JOINs to connect the ""Sailors,"" ""Reserves,"" and ""Boats"" tables. Join ""Sailors"" with ""Reserves"" on ""Reserves.sid = Sailors.sid"" and ""Reserves"" with ""Boats"" on ""Reserves.bid = Boats.bid."" 4. Aggregation Structure: Use GROUP BY on ""Sailors.rating"" to group the results by the sailors' ratings and calculate the average age for each group.",1.0
845,Which venue has the fewest publications?,EASY,aan_1,"[Paper.venue, Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Paper.venue FROM Paper GROUP BY Paper.venue ORDER BY COUNT(Paper.paper_id) ASC LIMIT 1;,SELECT venue FROM paper GROUP BY venue ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the venue, as the question asks for the venue with the fewest publications. 2. Aggregation Structure: Use COUNT to calculate the number of publications (paper IDs) for each venue. 3. Grouping Structure: Use GROUP BY on ""Paper.venue"" to aggregate the results by each venue. 4. Ordering Structure: Use ORDER BY in ascending order on the count of publications to rank venues by the fewest publications. 5. Limiting Structure: Use LIMIT 1 to retrieve only the venue with the fewest publications. 6. Join Structure: No JOIN is required since all necessary data is within the ""Paper"" table.",1.0
846,"Find the titles and paper IDs for papers which have Mckeown, Kathleen or Rambow, Owen in author list.",NON-NESTED,aan_1,"[Paper.title, Paper.paper_id, Author.name, Author.author_id = Author_list.author_id, Author_list.paper_id = Paper.paper_id, Mckeown, Kathleen, Rambow, Owen]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.title, Paper.paper_id FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id JOIN Author ON Author.author_id = Author_list.author_id WHERE Author.name = 'Mckeown, Kathleen' OR Author.name = 'Rambow, Owen';","SELECT DISTINCT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id WHERE  T3.name LIKE ""%Mckeown ,  Kathleen%"" OR T3.name LIKE ""%Rambow ,  Owen%""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Paper.title"" and ""Paper.paper_id."" 2. Condition Structure: Use a WHERE clause to filter for papers where the authors' names are either ""Mckeown, Kathleen"" or ""Rambow, Owen."" 3. Join Structure: Use JOINs to connect the ""Paper"" table with the ""Author_list"" table on ""Paper.paper_id = Author_list.paper_id"" and the ""Author"" table on ""Author.author_id = Author_list.author_id"" to link papers with their respective authors. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields without any summarization.",1.0
847,What is the name of every sailor whose name contains the letter e?,EASY,boat_1,[Sailors.name],"Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Sailors.name FROM Sailors WHERE Sailors.name LIKE '%e%';,SELECT name FROM Sailors WHERE name LIKE '%e%',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.name"" field, as the query asks for the names of sailors. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for sailor names that contain the letter 'e'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Sailors"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving names based on a specific condition.",1.0
848,Sort all store names by store open date.,EASY,headphone_store,"[store.Name, store.Date_Opened]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT store.Name, store.Date_Opened FROM store ORDER BY store.Date_Opened;",SELECT name FROM store ORDER BY date_opened,"1. Sequential Structure: Start with the SELECT clause to retrieve the store names and their open dates. 2. Condition Structure: No specific filtering condition is required as we want all store names. 3. Join Structure: No JOIN is needed since all necessary information is available in the ""store"" table. 4. Aggregation Structure: No aggregation is needed as we are simply sorting the data. 5. Ordering Structure: Use ORDER BY on ""store.Date_Opened"" to sort the store names by their open dates.",1.0
849,Show me the distance between Boston and Newark.,NON-NESTED,address_1,"[Direct_distance.distance,City.city_name,Direct_distance.city1_code = City.city_code,Direct_distance.city2_code = City.city_code,Boston,Newark]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Direct_distance.distance FROM Direct_distance JOIN City AS City1 ON Direct_distance.city1_code = City1.city_code JOIN City AS City2 ON Direct_distance.city2_code = City2.city_code WHERE City1.city_name = 'Boston' AND City2.city_name = 'Newark';,"SELECT distance FROM Direct_distance AS T1 JOIN City AS T2 ON T1.city1_code  =  T2.city_code JOIN City AS T3 ON T1.city2_code  =  T3.city_code WHERE T2.city_name  =  ""Boston"" AND T3.city_name  =  ""Newark""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Direct_distance.distance"" field, which represents the distance between two cities. 2. Condition Structure: Use a WHERE clause to filter for the specific cities ""Boston"" and ""Newark."" This requires matching ""Direct_distance.city1_code"" and ""Direct_distance.city2_code"" with the corresponding ""City.city_code"" for ""Boston"" and ""Newark."" 3. Join Structure: Use JOINs to connect the ""Direct_distance"" table with the ""City"" table twice, once for ""city1_code"" and once for ""city2_code,"" to retrieve the city names. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single distance value.",1.0
850,How many reservations exist for each boat?,NON-NESTED,boat_1,"[Reserves.bid, Boats.bid = Reserves.bid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Reserves.bid, COUNT(Reserves.bid) AS reservation_count FROM Reserves JOIN Boats ON Boats.bid = Reserves.bid GROUP BY Reserves.bid;","SELECT bid ,  count(*) FROM Reserves GROUP BY bid","1. Sequential Structure: Start with the SELECT clause to retrieve the boat ID (""Reserves.bid"") and the count of reservations for each boat. Use COUNT to count the number of reservations. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Reserves"" and ""Boats"" tables based on the shared ""bid"" field to link reservations with boats. 4. Aggregation Structure: Use COUNT on ""Reserves.bid"" to count the number of reservations for each boat, and GROUP BY ""Reserves.bid"" to group the results by boat ID.",1.0
851,What are the ids for male students not in the USA?,NON-NESTED,address_1,"[Student.StuID, Student.Sex, Student.city_code = City.city_code, City.country, USA]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Student.StuID FROM Student JOIN City ON Student.city_code = City.city_code WHERE Student.Sex = 'Male' AND City.country != 'USA';,"SELECT StuID FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE T2.sex  =  'M' AND T1.country != ""USA""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student.StuID"" field, as the question asks for student IDs. 2. Condition Structure: Use a WHERE clause to filter for male students (""Student.Sex = 'Male'"") and students not in the USA (""City.country != 'USA'""). 3. Join Structure: Use a JOIN between the ""Student"" table and the ""City"" table on the ""Student.city_code = City.city_code"" to associate each student with their respective city and country. 4. Aggregation Structure: No aggregation is needed, as the query only retrieves individual student IDs.",0.0
852,Find the headphone class that does not contain more than two headphones.,NESTED,headphone_store,"[headphone.Class, headphone.Headphone_ID, stock.Headphone_ID = headphone.Headphone_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT headphone.Class FROM headphone JOIN stock ON stock.Headphone_ID = headphone.Headphone_ID GROUP BY headphone.Class HAVING COUNT(headphone.Headphone_ID) <= 2;,SELECT CLASS FROM headphone GROUP BY CLASS HAVING count(*)  >  2,1. Sequential Structure: Start with the SELECT clause to retrieve the headphone class. Use the FROM clause to specify the headphone table and JOIN it with the stock table to relate headphones with their stock. Use GROUP BY to group records by headphone class and count the number of headphones in each class. Apply a HAVING clause to filter classes that do not contain more than two headphones. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for headphone classes that have two or fewer headphones. 3. Join Structure: Use an INNER JOIN between the headphone and stock tables based on Headphone_ID to connect headphone classes with their stock information. 4. Aggregation Structure: Use COUNT(*) within HAVING to aggregate the number of headphones per class and filter out classes with more than two headphones.,0.0
853,How many papers has each affiliation published?,NON-NESTED,aan_1,"[Affiliation.affiliation_id, Author_list.affiliation_id, Author_list.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Affiliation.affiliation_id, COUNT(Paper.paper_id) AS paper_count FROM Affiliation JOIN Author_list ON Affiliation.affiliation_id = Author_list.affiliation_id JOIN Paper ON Author_list.paper_id = Paper.paper_id GROUP BY Affiliation.affiliation_id;","SELECT count(DISTINCT T2.paper_id) ,  T1.name FROM Affiliation AS T1 JOIN Author_list AS T2 ON T1.affiliation_id  =  T2.affiliation_id GROUP BY T1.affiliation_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""affiliation_id"" and the count of papers published by each affiliation. Use COUNT on ""paper_id"" to count the number of papers. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Affiliation"" table with the ""Author_list"" table on ""affiliation_id"" and the ""Author_list"" table with the ""Paper"" table on ""paper_id"" to link affiliations with their published papers. 4. Aggregation Structure: Use COUNT to aggregate the number of papers for each affiliation, and GROUP BY ""affiliation_id"" to group the results by each affiliation.",0.0
854,What are the different names of sailors who are older than some other sailor with a rating larger than 7?,NESTED,boat_1,"[Sailors.name, Sailors.age, Sailors.rating]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT DISTINCT Sailors.name FROM Sailors WHERE Sailors.age > ANY (SELECT Sailors.age FROM Sailors WHERE Sailors.rating > 7);,SELECT DISTINCT name FROM Sailors WHERE age  >  (SELECT min(age) FROM Sailors WHERE rating  >  7);,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct sailor names. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors who are older than at least one other sailor with a rating greater than 7. 2. Condition Structure: Use the WHERE clause with a subquery to compare the age of a sailor with the age of other sailors who have a rating greater than 7. 3. Join Structure: Not required, as all data is within the Sailors table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",0.0
855,List the names of all authors and their number of papers in descending order by number of papers.,NON-NESTED,aan_1,"[Author.name, Author.author_id, Author_list.author_id = Author.author_id, Author_list.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Author.name, COUNT(Author_list.paper_id) AS number_of_papers FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id GROUP BY Author.name ORDER BY number_of_papers DESC;","SELECT T1.name ,  count(*) FROM Author AS T1 JOIN Author_list AS T2 ON T1.author_id  =  T2.author_id GROUP BY T1.author_id ORDER BY count(*) DESC","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Author.name"" and the count of papers authored by each author. Use COUNT on ""Author_list.paper_id"" to count the number of papers for each author. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Author"" and ""Author_list"" tables based on ""Author.author_id"" and ""Author_list.author_id"" to associate each author with their papers. 4. Aggregation Structure: Use COUNT to aggregate the number of papers for each author, then GROUP BY ""Author.name"" to group results by author. Finally, use ORDER BY in descending order on the count of papers to sort the results.",1.0
856,What are the names of the sailors whose rating is larger than the rating of all sailors who booked a red boat?,NESTED,boat_1,"[Sailors.name, Sailors.rating, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, Boats.color, red]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Sailors.name FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Sailors.rating > ALL ( SELECT Sailors.rating FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Boats.color = 'red' );,SELECT name FROM Sailors WHERE rating  >  (SELECT max(T1.rating) FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid JOIN Boats AS T3 ON T3.bid  =  T2.bid WHERE T3.color  =  'red'),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of sailors. Use the FROM clause to specify the Sailors table and join it with the Reserves and Boats tables to connect sailors with the boats they reserved. Apply a WHERE clause to filter sailors whose rating is larger than the rating of all sailors who booked a red boat. 2. Condition Structure: Use the WHERE clause with a subquery to compare the rating of each sailor to the ratings of sailors who booked a red boat. The subquery filters for boats with the color 'red' and retrieves the ratings of sailors who reserved them. 3. Join Structure: Use INNER JOINs between Sailors, Reserves, and Boats tables based on the relationships sid = sid and bid = bid to connect sailors with the boats they reserved. 4. Aggregation Structure: Not required, as we are comparing individual ratings without any aggregation.",0.0
857,Show me the city code of two cities with maximum distance.,EASY,address_1,"[Direct_distance.city1_code, Direct_distance.city2_code, Direct_distance.distance]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT Direct_distance.city1_code, Direct_distance.city2_code FROM Direct_distance ORDER BY Direct_distance.distance DESC LIMIT 1;","SELECT city1_code ,  city2_code FROM Direct_distance ORDER BY distance DESC LIMIT 1","1. Sequential Structure: Begin with the SELECT clause to specify the city codes of the two cities with the maximum distance. These are ""Direct_distance.city1_code"" and ""Direct_distance.city2_code"". 2. Condition Structure: No specific filtering condition is required since we are looking for the maximum distance. 3. Join Structure: No JOIN is required as all necessary data is within the ""Direct_distance"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""Direct_distance.distance"" to rank the distances and apply LIMIT 1 to retrieve the pair of cities with the maximum distance.",1.0
858,What are the different boat ids reserved by the sailor whose id is 1?,NON-NESTED,boat_1,"[Reserves.bid, Reserves.sid, Sailors.sid = Reserves.sid, Sailors.sid, 1]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT DISTINCT Reserves.bid FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid WHERE Sailors.sid = 1;,SELECT DISTINCT bid FROM Reserves WHERE sid = 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Reserves.bid"" values, as we are interested in the different boat IDs reserved by the sailor. 2. Condition Structure: Use a WHERE clause to filter the records where ""Sailors.sid"" is equal to 1. 3. Join Structure: Use a JOIN between the ""Sailors"" and ""Reserves"" tables based on the ""Sailors.sid = Reserves.sid"" relationship to link sailors with their reservations. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique boat IDs are returned.",1.0
859,What are the city name and average distances from each city?,NON-NESTED,address_1,"[City.city_name, Direct_distance.city1_code, Direct_distance.city2_code, Direct_distance.distance, Direct_distance.city1_code = City.city_code, Direct_distance.city2_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.city_name, AVG(Direct_distance.distance) AS average_distance FROM City JOIN Direct_distance ON Direct_distance.city1_code = City.city_code GROUP BY City.city_name;","SELECT T2.city_name ,  avg(distance) FROM Direct_distance AS T1 JOIN City AS T2 ON T1.city1_code  =  T2.city_code GROUP BY T1.city1_code","1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.city_name"" and the average distance from each city. Use the AVG function to calculate the average distance. 2. Condition Structure: No specific filtering condition is required, as we need the average distance for all cities. 3. Join Structure: Use JOINs to connect the ""City"" table with the ""Direct_distance"" table. Specifically, join ""Direct_distance.city1_code"" with ""City.city_code"" to calculate distances originating from each city. 4. Aggregation Structure: Use AVG on ""Direct_distance.distance"" to calculate the average distance for each city, and GROUP BY ""City.city_name"" to group the results by city.",1.0
860,How many papers cite paper with id A00-1002?,NON-NESTED,aan_1,"[Citation.paper_id, Citation.cited_paper_id, Citation.cited_paper_id = Paper.paper_id, A00-1002]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Citation.paper_id) FROM Citation WHERE Citation.cited_paper_id = 'A00-1002';,"SELECT count(*) FROM Citation WHERE cited_paper_id  =  ""A00-1002""","1. Sequential Structure: Start with the SELECT clause to count the number of papers that cite the paper with id ""A00-1002."" 2. Condition Structure: Use a WHERE clause to filter for records where ""Citation.cited_paper_id"" matches the given paper id ""A00-1002."" 3. Join Structure: No JOIN is necessary, as the required information is available within the ""Citation"" table. 4. Aggregation Structure: Use COUNT on ""Citation.paper_id"" to count the number of papers citing the specified paper.",1.0
861,Which headphone class does have more than two headphones?,NON-NESTED,headphone_store,"[headphone.Class, headphone.Headphone_ID, stock.Headphone_ID = headphone.Headphone_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT headphone.Class FROM headphone JOIN stock ON stock.Headphone_ID = headphone.Headphone_ID GROUP BY headphone.Class HAVING COUNT(headphone.Headphone_ID) > 2;,SELECT CLASS FROM headphone GROUP BY CLASS HAVING count(*)  >  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""headphone.Class"" field. Use a GROUP BY clause to group the results by headphone class. 2. Condition Structure: Apply a HAVING clause to filter for headphone classes that have more than two headphones. 3. Join Structure: Use a JOIN between the ""headphone"" and ""stock"" tables based on the ""Headphone_ID"" field to ensure we are considering headphones that are in stock. 4. Aggregation Structure: Use COUNT on ""headphone.Headphone_ID"" to count the number of headphones in each class, and filter with HAVING to select classes with more than two headphones.",1.0
862,Return the unique boat ids (bid) of all reserved boats.,NON-NESTED,boat_1,"[Reserves.bid,Boats.bid,Reserves.bid = Boats.bid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT DISTINCT Reserves.bid FROM Reserves;,SELECT DISTINCT bid FROM Reserves,"1. Sequential Structure: Start with the SELECT clause to retrieve the unique ""bid"" values from the ""Reserves"" table, as we are interested in the boat IDs of all reserved boats. 2. Condition Structure: No specific filtering condition is required since we are looking for all reserved boats. 3. Join Structure: No JOIN is necessary because the ""bid"" information is directly available in the ""Reserves"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique boat IDs are returned.",1.0
863,Show all city codes and the total distance to all other cities.,EASY,address_1,"[Direct_distance.city1_code, Direct_distance.city2_code, Direct_distance.distance]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT Direct_distance.city1_code, SUM(Direct_distance.distance) AS total_distance FROM Direct_distance GROUP BY Direct_distance.city1_code;","SELECT city1_code ,  sum(distance) FROM Direct_distance GROUP BY city1_code","1. Sequential Structure: Begin with the SELECT clause to specify the city codes and the total distance to all other cities. 2. Aggregation Structure: Use SUM to calculate the total distance for each city code. 3. Grouping Structure: Use GROUP BY on ""Direct_distance.city1_code"" to calculate the total distance for each city. 4. Join Structure: No JOIN is required since all necessary data is within the ""Direct_distance"" table.",1.0
864,Show me the city code of two cities with a distance less than 1000.,EASY,address_1,"[Direct_distance.city1_code, Direct_distance.city2_code, Direct_distance.distance]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT Direct_distance.city1_code, Direct_distance.city2_code FROM Direct_distance WHERE Direct_distance.distance < 1000;","SELECT city1_code ,  city2_code FROM Direct_distance WHERE distance  <  1000","1. Sequential Structure: Start with the SELECT clause to retrieve the city codes of the two cities. 2. Condition Structure: Use a WHERE clause to filter for distances less than 1000. 3. Join Structure: No JOIN is required since all necessary information is in the ""Direct_distance"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving city codes based on the specified condition.",1.0
865,Find the headphone model whose total quantity in stock is the largest.,NON-NESTED,headphone_store,"[headphone.Model, stock.Quantity, stock.Headphone_ID = headphone.Headphone_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT headphone.Model FROM headphone JOIN stock ON headphone.Headphone_ID = stock.Headphone_ID GROUP BY headphone.Model ORDER BY SUM(stock.Quantity) DESC LIMIT 1;,SELECT t1.model FROM headphone AS t1 JOIN stock AS t2 ON t1.headphone_id  =  t2.headphone_id GROUP BY t1.model ORDER BY sum(t2.quantity) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""headphone.Model"" and the total quantity in stock. Use an aggregate function (SUM) on ""stock.Quantity"" to calculate the total quantity for each headphone model. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the model with the largest total quantity in stock. 3. Join Structure: Use a JOIN between the ""headphone"" and ""stock"" tables based on the shared key ""headphone.Headphone_ID = stock.Headphone_ID"" to link each headphone model with its stock information. 4. Aggregation Structure: Use SUM to calculate the total quantity in stock for each headphone model. Use ORDER BY in descending order on the total quantity and LIMIT 1 to select the model with the largest total quantity.",1.0
866,what is the name and id of every sailor who has a rating greater than 2 and reserved a boat.,NON-NESTED,boat_1,"[Sailors.sid,Sailors.name,Sailors.rating,Reserves.sid,Reserves.bid = Boats.bid,Sailors.sid = Reserves.sid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.name, Sailors.sid FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid WHERE Sailors.rating > 2;","SELECT DISTINCT T1.name ,  T1.sid FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid WHERE  T1.rating  >  2","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.name"" and ""Sailors.sid."" 2. Condition Structure: Use a WHERE clause to filter sailors with a ""rating"" greater than 2 and ensure they have reserved a boat by checking the existence of a matching record in the ""Reserves"" table. 3. Join Structure: Use an INNER JOIN between the ""Sailors"" and ""Reserves"" tables on ""Sailors.sid = Reserves.sid"" to link sailors with their reservations. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without summarization.",1.0
867,What are the top 2 earpads in terms of the number of headphones using them?,NON-NESTED,headphone_store,"[headphone.Earpads, stock.Headphone_ID = headphone.Headphone_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Earpads, COUNT(headphone.Headphone_ID) AS headphone_count FROM headphone JOIN stock ON stock.Headphone_ID = headphone.Headphone_ID GROUP BY headphone.Earpads ORDER BY headphone_count DESC LIMIT 2;",SELECT earpads FROM headphone GROUP BY earpads ORDER BY count(*) DESC LIMIT 2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""headphone.Earpads"" and the count of headphones using each earpad. Use an aggregate function (COUNT) to count the number of headphones for each earpad. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""headphone"" and ""stock"" tables based on ""headphone.Headphone_ID"" to link headphones with their stock information. 4. Aggregation Structure: Use GROUP BY on ""headphone.Earpads"" to group the results by earpad type. Use ORDER BY in descending order of the count to rank the earpads by the number of headphones using them. Use LIMIT 2 to select the top 2 earpads.",1.0
868,What are the names and ids of all sailors who have a rating of at least 3 and reserved a boat?,NON-NESTED,boat_1,"[Sailors.sid, Sailors.name, Sailors.rating, Reserves.sid = Sailors.sid, Reserves.bid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.name, Sailors.sid FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid WHERE Sailors.rating >= 3;","SELECT DISTINCT T1.name ,  T1.sid FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid WHERE  T1.rating  >  2","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.name"" and ""Sailors.sid"" fields. 2. Condition Structure: Use a WHERE clause to filter sailors with a ""rating"" of at least 3. Additionally, ensure that the sailor has reserved a boat by checking for matching ""sid"" in the ""Reserves"" table. 3. Join Structure: Use an INNER JOIN between the ""Sailors"" and ""Reserves"" tables on the ""sid"" field to link sailors with their reservations. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without summarization.",1.0
869,Show ids for all students who don't live in USA.,NON-NESTED,address_1,"[Student.StuID, Student.city_code = City.city_code, City.country, USA]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Student.StuID FROM Student JOIN City ON Student.city_code = City.city_code WHERE City.country != 'USA';,"SELECT StuID FROM Student EXCEPT SELECT StuID FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE country  =  ""USA""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student.StuID"" field, which represents the IDs of students. 2. Condition Structure: Use a WHERE clause to filter for students who do not live in the USA. This requires checking the ""City.country"" field for values not equal to 'USA.' 3. Join Structure: Use a JOIN between the ""Student"" table and the ""City"" table based on the ""city_code"" field to associate each student with their respective city and country. 4. Aggregation Structure: No aggregation is needed since the query only retrieves student IDs without any summarization.",1.0
870,What is the average distance between Boston and all other cities.,NON-NESTED,address_1,"[City.city_name, Direct_distance.city1_code, Direct_distance.city2_code, Direct_distance.distance, City.city_code = Direct_distance.city1_code, City.city_code = Direct_distance.city2_code, Boston]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT AVG(Direct_distance.distance) FROM Direct_distance JOIN City AS City1 ON City1.city_code = Direct_distance.city1_code JOIN City AS City2 ON City2.city_code = Direct_distance.city2_code WHERE City1.city_name = 'Boston' OR City2.city_name = 'Boston';,"SELECT avg(distance) FROM Direct_distance AS T1 JOIN City AS T2 ON T1.city1_code  =  T2.city_code WHERE T2.city_name  =  ""Boston""","1. Sequential Structure: Start with the SELECT clause to calculate the average distance. Use the AVG function on the ""Direct_distance.distance"" field. 2. Condition Structure: Use a WHERE clause to filter for distances where one of the cities is ""Boston."" This requires matching ""City.city_name"" to ""Boston"" and joining it with ""Direct_distance"" using ""City.city_code."" 3. Join Structure: Use JOIN to connect the ""City"" table with the ""Direct_distance"" table twice, once for ""Direct_distance.city1_code"" and once for ""Direct_distance.city2_code,"" to account for distances involving ""Boston"" as either city1 or city2. 4. Aggregation Structure: Use the AVG function to compute the average distance for all records that meet the condition.",1.0
871,What is the ids of sailors that haven’t reserved a boat?,NESTED,boat_1,"[Sailors.sid, Reserves.sid, Sailors.sid = Reserves.sid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT sid FROM Sailors WHERE sid NOT IN (SELECT sid FROM Reserves);,SELECT sid FROM Sailors EXCEPT SELECT sid FROM Reserves,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of sailors. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors who have not reserved a boat by ensuring their IDs are not present in the Reserves table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude sailors whose IDs appear in the Reserves table, meaning they have made a reservation. 3. Join Structure: Not required, as we only need to filter based on the absence of matching IDs in the Reserves table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
872,Count the number of distinct neighborhoods stores are located.,EASY,headphone_store,[store.Neighborhood],"Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT COUNT(DISTINCT store.Neighborhood) FROM store;,SELECT count(DISTINCT neighborhood) FROM store,"1. Sequential Structure: Begin with the SELECT clause to count the number of distinct neighborhoods where stores are located. 2. Condition Structure: No specific filtering condition is required as we are counting all distinct neighborhoods. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""store"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""store.Neighborhood"" to count the unique neighborhoods.",1.0
873,What are the rating and average age for sailors who reserved red boats for each rating?,NON-NESTED,boat_1,"[Sailors.rating, Sailors.age, Boats.color, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, red]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.rating, AVG(Sailors.age) AS average_age FROM Sailors JOIN Reserves ON Reserves.sid = Sailors.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Boats.color = 'red' GROUP BY Sailors.rating;","SELECT T1.rating ,  avg(T1.age) FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid JOIN Boats AS T3 ON T3.bid  =  T2.bid WHERE T3.color  =  'red' GROUP BY T1.rating","1. Sequential Structure: Start with the SELECT clause to retrieve ""Sailors.rating"" and the average age of sailors. Use the AVG function to calculate the average age. Group the results by ""Sailors.rating"" to get the average age for each rating. 2. Condition Structure: Use a WHERE clause to filter for boats with the color ""red."" 3. Join Structure: Use JOINs to connect the ""Sailors,"" ""Reserves,"" and ""Boats"" tables. Join ""Sailors"" and ""Reserves"" on ""Reserves.sid = Sailors.sid,"" and join ""Reserves"" and ""Boats"" on ""Reserves.bid = Boats.bid."" 4. Aggregation Structure: Use the AVG function to calculate the average age of sailors for each rating, and GROUP BY ""Sailors.rating"" to group the results by rating.",1.0
874,"What are the titles and paper ids which have Mckeown as an author, but not Rambow?",NESTED,aan_1,"[Paper.title, Paper.paper_id, Author.name, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Mckeown, Rambow]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.title, Paper.paper_id FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id JOIN Author ON Author_list.author_id = Author.author_id WHERE Author.name = 'Mckeown' AND Paper.paper_id NOT IN ( SELECT Paper.paper_id FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id JOIN Author ON Author_list.author_id = Author.author_id WHERE Author.name = 'Rambow' );","SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id WHERE T3.name LIKE ""%Mckeown%"" EXCEPT SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id WHERE T3.name LIKE ""%Rambow%""","1. Sequential Structure: Start with the SELECT clause to retrieve the titles and paper IDs. Use the FROM clause to specify the Paper table and join it with the Author_list and Author tables to connect papers with their authors. Apply a WHERE clause to filter for papers authored by ""Mckeown"" but not by ""Rambow"". 2. Condition Structure: Use the WHERE clause to filter for papers where the author's name is ""Mckeown"". Use a subquery to exclude papers where the author's name is ""Rambow"". 3. Join Structure: Use INNER JOINs between the Paper, Author_list, and Author tables based on their relationships (Author_list.author_id = Author.author_id and Author_list.paper_id = Paper.paper_id) to connect papers with their authors. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
875,What is the name and age of the sailor with maximum age?,EASY,boat_1,"[Sailors.name, Sailors.age]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.name, Sailors.age FROM Sailors ORDER BY Sailors.age DESC LIMIT 1;","SELECT name ,  age FROM Sailors WHERE age  =  ( SELECT max(age) FROM Sailors )","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.name"" and ""Sailors.age"" of the sailor with the maximum age. 2. Condition Structure: No specific filtering condition is needed since we are looking for the sailor with the maximum age. 3. Join Structure: No JOIN is required as all necessary information is available in the ""Sailors"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""Sailors.age"" to rank sailors by age and apply LIMIT 1 to select the sailor with the maximum age.",1.0
876,Find the id of Sailors (sid) that reserved red or blue boat.,NON-NESTED,boat_1,"[Sailors.sid, Reserves.sid, Reserves.bid, Boats.bid, Boats.color, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, red, blue]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT DISTINCT Sailors.sid FROM Sailors JOIN Reserves ON Reserves.sid = Sailors.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Boats.color = 'red' OR Boats.color = 'blue';,"SELECT DISTINCT T2.sid FROM Boats AS T1 JOIN Reserves AS T2 ON  T1.bid  =  T2.bid WHERE T1.color  =  'red' OR T1.color  =  ""blue""","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Sailors.sid"" values. 2. Condition Structure: Use a WHERE clause to filter for boats with the color ""red"" or ""blue."" 3. Join Structure: Use JOINs to connect the ""Sailors"" table with the ""Reserves"" table on ""Reserves.sid = Sailors.sid"" and the ""Reserves"" table with the ""Boats"" table on ""Reserves.bid = Boats.bid"" to link sailors with the boats they reserved. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique sailor IDs are returned.",1.0
877,Find the number of authors who did not publish any paper that is cited more than 50 times.,NESTED,aan_1,"[Author.author_id,Author_list.author_id,Author_list.paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(DISTINCT Author.author_id) FROM Author WHERE Author.author_id NOT IN ( SELECT Author_list.author_id FROM Author_list JOIN Paper ON Author_list.paper_id = Paper.paper_id JOIN Citation ON Citation.cited_paper_id = Paper.paper_id GROUP BY Author_list.author_id HAVING COUNT(Citation.paper_id) > 50 );,SELECT count(*) FROM Author WHERE Author_id NOT IN ( SELECT T2.author_id FROM Citation AS T1 JOIN Author_list AS T2 ON T1.cited_paper_id  =  T2.paper_id GROUP BY T1.cited_paper_id HAVING count(DISTINCT T1.paper_id)  >  50),"1. Sequential Structure: Start with the SELECT clause to count the number of distinct authors. Use the FROM clause to specify the Author table. Apply a WHERE clause to filter authors who did not publish any paper that is cited more than 50 times. 2. Condition Structure: Use a WHERE clause with a subquery to exclude authors whose papers are cited more than 50 times. The subquery identifies all authors whose papers have citations greater than 50. 3. Join Structure: Use JOINs between the Author, Author_list, Paper, and Citation tables to connect authors with their papers and the citations of those papers. 4. Aggregation Structure: Use COUNT to count the number of distinct authors who meet the condition.",0.0
878,"What is the name, rating, and age for every sailor? And order them by rating and age.",EASY,boat_1,"[Sailors.name, Sailors.rating, Sailors.age]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.name, Sailors.rating, Sailors.age FROM Sailors ORDER BY Sailors.rating, Sailors.age;","SELECT name ,  rating ,  age FROM Sailors ORDER BY rating ,  age","1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""Sailors.name,"" ""Sailors.rating,"" and ""Sailors.age."" 2. Condition Structure: No specific filtering condition is required as the query asks for all sailors. 3. Join Structure: No JOIN is needed since all necessary information is available in the ""Sailors"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving individual records. 5. Ordering Structure: Use ORDER BY to sort the results first by ""Sailors.rating"" and then by ""Sailors.age.""",1.0
879,"How many papers does Mckeown , Kathleen cite ?",NON-NESTED,aan_1,"[Author.name, Paper.paper_id, Citation.paper_id, Citation.cited_paper_id = Paper.paper_id, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Mckeown, Kathleen]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT COUNT(Citation.cited_paper_id) FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id JOIN Citation ON Paper.paper_id = Citation.paper_id WHERE Author.name = 'Mckeown, Kathleen';","select count(*) from citation as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id join author as t3 on t2.author_id  =  t3.author_id where t3.name = ""mckeown ,  kathleen""","1. Sequential Structure: Start with the SELECT clause to count the number of papers cited by ""Mckeown, Kathleen."" Use COUNT on ""Citation.cited_paper_id"" to determine the number of citations. 2. Condition Structure: Use a WHERE clause to filter for papers authored by ""Mckeown, Kathleen."" This involves identifying the author by name and linking their authored papers to the citations. 3. Join Structure: Use JOINs to connect the ""Author"" table with the ""Author_list"" table on ""author_id,"" then connect ""Author_list"" with the ""Paper"" table on ""paper_id."" Finally, connect the ""Paper"" table with the ""Citation"" table on ""paper_id"" to track the citations made by the author's papers. 4. Aggregation Structure: Use COUNT to aggregate the number of cited papers.",1.0
880,What is the name of the sailors who reserved boat with id 103?,NON-NESTED,boat_1,"[Sailors.name, Reserves.sid, Reserves.bid, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, 103]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Sailors.name FROM Sailors JOIN Reserves ON Reserves.sid = Sailors.sid WHERE Reserves.bid = 103;,SELECT DISTINCT T1.name FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid WHERE  T2.bid  =  103,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.name"" of sailors who reserved the boat with id 103. 2. Condition Structure: Use a WHERE clause to filter for records where ""Reserves.bid"" equals 103. 3. Join Structure: Use a JOIN between the ""Sailors"" and ""Reserves"" tables based on ""Reserves.sid = Sailors.sid"" to associate each reservation with the corresponding sailor. 4. Aggregation Structure: No aggregation is needed as we are retrieving individual sailor names.",1.0
881,What are the headphone models that cost less than the average price?,NESTED,headphone_store,"[headphone.Model, headphone.Price]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT Model FROM headphone WHERE Price < (SELECT AVG(Price) FROM headphone);,SELECT model FROM headphone WHERE price  <  (SELECT avg(price) FROM headphone),"1. Sequential Structure: Start with the SELECT clause to retrieve the headphone models. Use the FROM clause to specify the headphone table. Apply a WHERE clause to filter for models whose price is less than the average price. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average price of all headphones and filter for models with a price below this value. 3. Join Structure: Not required, as all data is in the headphone table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average price of all headphones.",1.0
882,"What are the names, years, and locations of all conferences?",EASY,conference,"[conference.Conference_Name, conference.Year, conference.Location]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT conference.Conference_Name, conference.Year, conference.Location FROM conference;","SELECT conference_name ,  YEAR ,  LOCATION FROM conference","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""conference.Conference_Name"", ""conference.Year"", and ""conference.Location"". 2. Condition Structure: No specific filtering condition is required as the query asks for all conferences. 3. Join Structure: No JOIN is required since all necessary information is available in the ""conference"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all the specified fields.",1.0
883,Find the total number of papers for each affiliation.,NON-NESTED,aan_1,"[Affiliation.affiliation_id,Author_list.affiliation_id,Author_list.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Affiliation.affiliation_id, COUNT(Author_list.paper_id) AS total_papers FROM Affiliation JOIN Author_list ON Affiliation.affiliation_id = Author_list.affiliation_id JOIN Paper ON Author_list.paper_id = Paper.paper_id GROUP BY Affiliation.affiliation_id;","SELECT count(DISTINCT T2.paper_id) ,  T1.name FROM Affiliation AS T1 JOIN Author_list AS T2 ON T1.affiliation_id  =  T2.affiliation_id GROUP BY T1.affiliation_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""affiliation_id"" and the total number of papers for each affiliation. Use COUNT on ""Author_list.paper_id"" to count the number of papers. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect ""Affiliation"" with ""Author_list"" on ""affiliation_id"" and ""Author_list"" with ""Paper"" on ""paper_id"" to link affiliations with their respective papers. 4. Aggregation Structure: Use COUNT to aggregate the number of papers for each affiliation and GROUP BY ""Affiliation.affiliation_id"" to group results by affiliation.",0.0
884,"Count the number of papers Mckeown , Kathleen has cited .",NON-NESTED,aan_1,"[Author.name, Author.author_id, Author_list.author_id = Author.author_id, Author_list.paper_id = Citation.paper_id, Citation.cited_paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT COUNT(Citation.cited_paper_id) FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Citation ON Author_list.paper_id = Citation.paper_id WHERE Author.name = 'Mckeown, Kathleen';","select count(*) from citation as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id join author as t3 on t2.author_id  =  t3.author_id where t3.name = ""mckeown ,  kathleen""","1. Sequential Structure: Start with the SELECT clause to count the number of cited papers. Use COUNT on ""Citation.cited_paper_id"" to get the total number of citations. 2. Condition Structure: Use a WHERE clause to filter for the author ""Mckeown, Kathleen."" This requires identifying the author's ""author_id"" from the ""Author"" table. 3. Join Structure: Use JOINs to connect the ""Author"" table with the ""Author_list"" table on ""author_id"" and then connect the ""Author_list"" table with the ""Citation"" table on ""paper_id"" to track the papers cited by the author. 4. Aggregation Structure: Use COUNT to aggregate the number of cited papers for the specified author.",1.0
885,What are the ids for papers with titles containing 'translation'?,EASY,aan_1,"[Paper.paper_id, Paper.title]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Paper.paper_id FROM Paper WHERE Paper.title LIKE '%translation%';,"SELECT paper_id FROM Paper WHERE title LIKE ""%translation%""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paper.paper_id"" for papers with titles containing the word 'translation'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for paper titles that contain the word 'translation'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Paper"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific paper IDs based on a condition.",1.0
886,what is the name and id of sailors who do not have a reservation of a boat?,NESTED,boat_1,"[Sailors.sid, Sailors.name, Reserves.sid = Sailors.sid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.name, Sailors.sid FROM Sailors WHERE Sailors.sid NOT IN (SELECT Reserves.sid FROM Reserves);","SELECT sid ,  name FROM Sailors EXCEPT SELECT T1.sid ,  T1.name FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid","1. Sequential Structure: Start with the SELECT clause to retrieve the name and id of sailors. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors who do not have a reservation of a boat. 2. Condition Structure: Use the WHERE clause with a subquery to exclude sailors whose sid appears in the Reserves table, meaning they have made a reservation. 3. Join Structure: Not required, as we only need to filter based on the absence of matching sid entries in the Reserves table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
887,What are the titles and paper ids for papers written by Mckeown?,NON-NESTED,aan_1,"[Paper.title, Paper.paper_id, Author.name, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Mckeown]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.title, Paper.paper_id FROM Author JOIN Author_list ON Author_list.author_id = Author.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Author.name = 'Mckeown';","SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T3.author_id  =  T2.author_id WHERE T3.name LIKE ""%Mckeown%""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Paper.title"" and ""Paper.paper_id."" 2. Condition Structure: Use a WHERE clause to filter for papers written by the author named ""Mckeown."" 3. Join Structure: Use JOINs to connect the ""Author_list"" table with the ""Author"" table on ""Author_list.author_id = Author.author_id"" and the ""Author_list"" table with the ""Paper"" table on ""Author_list.paper_id = Paper.paper_id"" to link authors with their respective papers. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without any summarization.",0.0
888,What is the venue with the least number of publications?,EASY,aan_1,"[Paper.venue, Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Paper.venue FROM Paper GROUP BY Paper.venue ORDER BY COUNT(Paper.paper_id) ASC LIMIT 1;,SELECT venue FROM paper GROUP BY venue ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the venue, as the question asks for the venue with the least number of publications. 2. Aggregation Structure: Use COUNT to calculate the number of publications (paper IDs) for each venue. 3. Grouping Structure: Use GROUP BY on ""Paper.venue"" to count the publications for each venue. 4. Ordering Structure: Use ORDER BY in ascending order on the count of publications to rank venues by the number of publications. 5. Limiting Structure: Use LIMIT 1 to retrieve the venue with the least number of publications. 6. Join Structure: No JOIN is required since all necessary data is within the ""Paper"" table.",1.0
889,What are the names and ids of sailors who reserved red or blue boats?,NON-NESTED,boat_1,"[Sailors.sid,Sailors.name,Reserves.sid,Reserves.bid,Boats.bid,Boats.color,Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid,red,blue]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.sid, Sailors.name FROM Sailors JOIN Reserves ON Reserves.sid = Sailors.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Boats.color = 'red' OR Boats.color = 'blue';","SELECT DISTINCT T2.sid ,  T3.name FROM Boats AS T1 JOIN Reserves AS T2 ON  T1.bid  =  T2.bid JOIN Sailors AS T3 ON T2.sid  =  T3.sid WHERE T1.color  =  'red' OR T1.color  =  ""blue""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.sid"" and ""Sailors.name."" 2. Condition Structure: Use a WHERE clause to filter for boats with the color ""red"" or ""blue."" 3. Join Structure: Use JOINs to connect the ""Sailors,"" ""Reserves,"" and ""Boats"" tables. First, join ""Sailors"" with ""Reserves"" on ""Reserves.sid = Sailors.sid,"" and then join ""Reserves"" with ""Boats"" on ""Reserves.bid = Boats.bid."" 4. Aggregation Structure: No aggregation is needed, as the query only requires listing the names and ids of sailors.",1.0
890,Which stores do not have any headphones in stock? Give me the store names.,NESTED,headphone_store,"[store.Name,stock.Store_ID = store.Store_ID,stock.Quantity]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT store.Name FROM store WHERE store.Store_ID NOT IN ( SELECT stock.Store_ID FROM stock WHERE stock.Quantity > 0 AND stock.Item = 'headphones' );,SELECT name FROM store WHERE store_id NOT IN (SELECT store_id FROM stock),"1. Sequential Structure: Start with the SELECT clause to retrieve the store names. Use the FROM clause to specify the store table. Apply a WHERE clause to filter stores that do not have any headphones in stock by ensuring their Store_ID is not present in the stock table with a positive quantity for headphones. 2. Condition Structure: Use the WHERE clause with a subquery to exclude stores whose Store_ID appears in the stock table with a positive quantity for headphones. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Store_ID entries in the stock table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",0.0
891,Which headphone class is the most common one?,NON-NESTED,headphone_store,"[headphone.Class, stock.Headphone_ID = headphone.Headphone_ID, stock.Quantity]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Class, SUM(stock.Quantity) AS total_quantity FROM headphone JOIN stock ON stock.Headphone_ID = headphone.Headphone_ID GROUP BY headphone.Class ORDER BY total_quantity DESC LIMIT 1;",SELECT CLASS FROM headphone GROUP BY CLASS ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""headphone.Class"" and the total quantity of each class. Use an aggregate function (SUM) on ""stock.Quantity"" to calculate the total quantity for each headphone class. 2. Condition Structure: No specific filtering condition is required, as we are interested in all headphone classes. 3. Join Structure: Use a JOIN between the ""headphone"" and ""stock"" tables based on ""headphone.Headphone_ID = stock.Headphone_ID"" to link each headphone with its stock quantity. 4. Aggregation Structure: Use GROUP BY on ""headphone.Class"" to group the results by headphone class. Use ORDER BY in descending order of the total quantity to rank the classes by their total quantity. Use LIMIT 1 to select the most common headphone class.",1.0
892,How many boats are red?,EASY,boat_1,"[Boats.color, Boats.bid, red]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT COUNT(*) FROM Boats WHERE Boats.color = 'red';,SELECT count(*) FROM Boats WHERE color  =  'red',"1. Sequential Structure: Start with the SELECT clause to count the number of boats that are red. 2. Condition Structure: Use a WHERE clause to filter boats where ""Boats.color"" is 'red'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Boats"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of red boats.",1.0
893,Which headphone models do not have any stock in any store?,NESTED,headphone_store,"[headphone.Model,stock.Headphone_ID,headphone.Headphone_ID = stock.Headphone_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT headphone.Model FROM headphone WHERE headphone.Headphone_ID NOT IN (SELECT stock.Headphone_ID FROM stock);,SELECT model FROM headphone WHERE headphone_id NOT IN (SELECT headphone_id FROM stock),"1. Sequential Structure: Start with the SELECT clause to retrieve the headphone models. Use the FROM clause to specify the headphone table. Apply a WHERE clause to filter for headphone models that do not have any stock in any store. 2. Condition Structure: Use the WHERE clause with a subquery to exclude headphone models whose Headphone_ID appears in the stock table, meaning they have stock in at least one store. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Headphone_ID entries in the stock table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
894,Show all city names and the average distance to all other cities.,NON-NESTED,address_1,"[City.city_name, Direct_distance.city1_code, Direct_distance.city2_code, Direct_distance.distance, Direct_distance.city1_code = City.city_code, Direct_distance.city2_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.city_name, AVG(Direct_distance.distance) AS average_distance FROM City JOIN Direct_distance ON Direct_distance.city1_code = City.city_code GROUP BY City.city_name;","SELECT T2.city_name ,  avg(distance) FROM Direct_distance AS T1 JOIN City AS T2 ON T1.city1_code  =  T2.city_code GROUP BY T1.city1_code","1. Sequential Structure: Start with the SELECT clause to retrieve ""City.city_name"" and the average distance to all other cities. Use an aggregate function (AVG) on ""Direct_distance.distance"" to calculate the average distance. 2. Condition Structure: No specific filtering condition is required, as we need the average distance for all cities. 3. Join Structure: Use JOINs to connect the ""City"" table with the ""Direct_distance"" table. Specifically, join ""Direct_distance.city1_code"" with ""City.city_code"" to associate each city with its distances to other cities. 4. Aggregation Structure: Use AVG on ""Direct_distance.distance"" to calculate the average distance for each city. Use GROUP BY on ""City.city_name"" to group the results by city.",1.0
895,What are the city codes of cities with distance greater than average?,NESTED,address_1,"[Direct_distance.city1_code, Direct_distance.city2_code, Direct_distance.distance]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT city1_code, city2_code FROM Direct_distance WHERE distance > (SELECT AVG(distance) FROM Direct_distance);","SELECT city1_code ,  city2_code FROM Direct_distance WHERE distance  >  (SELECT avg(distance) FROM Direct_distance)","1. Sequential Structure: Start with the SELECT clause to retrieve the city codes. Use the FROM clause to specify the Direct_distance table. Apply a WHERE clause to filter for distances greater than the average distance. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average distance and filter for rows where the distance is greater than this average. 3. Join Structure: Not required, as all data is available within the Direct_distance table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average distance, which is then used in the filtering condition.",1.0
896,List name and parking info for the stores in the Tarzana neighborhood.,EASY,headphone_store,"[store.Name, store.Parking, store.Neighborhood, Tarzana]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT store.Name, store.Parking FROM store WHERE store.Neighborhood = 'Tarzana';","SELECT name ,  parking FROM store WHERE neighborhood  =  'Tarzana'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""store.Name"" and ""store.Parking"" fields for stores in the Tarzana neighborhood. 2. Condition Structure: Use a WHERE clause to filter for stores where ""store.Neighborhood"" is equal to 'Tarzana'. 3. Join Structure: No JOIN is required since all necessary information is in the ""store"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific fields based on a condition.",1.0
897,What is the name of the city closest to Chicago?,NON-NESTED,address_1,"[City.city_name,City.city_code,City.latitude,City.longitude,Direct_distance.city1_code,Direct_distance.city2_code,Direct_distance.distance,Student.city_code = City.city_code,Direct_distance.city1_code = City.city_code,Direct_distance.city2_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT C2.city_name FROM City AS C1 JOIN Direct_distance ON C1.city_code = Direct_distance.city1_code OR C1.city_code = Direct_distance.city2_code JOIN City AS C2 ON (C2.city_code = Direct_distance.city1_code AND C2.city_code != C1.city_code) OR (C2.city_code = Direct_distance.city2_code AND C2.city_code != C1.city_code) WHERE C1.city_name = 'Chicago' ORDER BY Direct_distance.distance ASC LIMIT 1;,"SELECT T3.city_name FROM Direct_distance AS T1 JOIN City AS T2 ON T1.city1_code  =  T2.city_code JOIN City AS T3 ON T1.city2_code  =  T3.city_code WHERE T2.city_name  =  ""Chicago"" ORDER BY distance LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.city_name"" of the city closest to Chicago. Use ORDER BY to sort the distances in ascending order and LIMIT 1 to get the closest city. 2. Condition Structure: Use a WHERE clause to filter for records where ""City.city_name"" is 'Chicago' to identify the reference city. 3. Join Structure: Use JOINs to connect the ""City"" table with the ""Direct_distance"" table. Specifically, join ""Direct_distance.city1_code"" or ""Direct_distance.city2_code"" with ""City.city_code"" to find distances involving Chicago. 4. Aggregation Structure: No aggregation is needed, but ORDER BY is used to sort the distances in ascending order, and LIMIT 1 is applied to select the closest city.",1.0
898,What is the title of the paper that has most number of authors?,NON-NESTED,aan_1,"[Paper.title, Author_list.paper_id, Author_list.author_id, Author_list.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Paper.title FROM Paper JOIN Author_list ON Author_list.paper_id = Paper.paper_id GROUP BY Paper.paper_id ORDER BY COUNT(Author_list.author_id) DESC LIMIT 1;,SELECT T2.title FROM Author_list AS T1 JOIN Paper AS T2 ON T1.paper_id  =  T2.paper_id GROUP BY T2.paper_id ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paper.title"" of the paper with the most authors. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the paper with the highest number of authors. 3. Join Structure: Use a JOIN between the ""Paper"" and ""Author_list"" tables based on ""Author_list.paper_id = Paper.paper_id"" to associate each paper with its authors. 4. Aggregation Structure: Use COUNT on ""Author_list.author_id"" to count the number of authors per paper. Use ORDER BY in descending order on the count to rank papers by the number of authors, and LIMIT 1 to select the paper with the most authors.",1.0
899,"Which stores are located in the ""Tarzana"" neighborhood? Return their names and parking information.",EASY,headphone_store,"[store.Name, store.Parking, store.Neighborhood, Tarzana]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT store.Name, store.Parking FROM store WHERE store.Neighborhood = 'Tarzana';","SELECT name ,  parking FROM store WHERE neighborhood  =  'Tarzana'","1. Sequential Structure: Start with the SELECT clause to retrieve the store names and their parking information. 2. Condition Structure: Use a WHERE clause to filter for stores located in the ""Tarzana"" neighborhood. 3. Join Structure: No JOIN is required since all necessary information is in the ""store"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific fields based on a condition.",1.0
900,"Find the name, rating and age of all sailors ordered by rating and age.",EASY,boat_1,"[Sailors.name, Sailors.rating, Sailors.age]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.name, Sailors.rating, Sailors.age FROM Sailors ORDER BY Sailors.rating ASC, Sailors.age ASC;","SELECT name ,  rating ,  age FROM Sailors ORDER BY rating ,  age","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""Sailors.name,"" ""Sailors.rating,"" and ""Sailors.age."" 2. Condition Structure: No specific filtering condition is required as the query asks for all sailors. 3. Join Structure: No JOIN is required since all necessary data is within the ""Sailors"" table. 4. Ordering Structure: Use ORDER BY to sort the results first by ""Sailors.rating"" and then by ""Sailors.age"" in ascending order. 5. Aggregation Structure: No aggregation is needed as the query does not involve any summary or aggregate functions.",1.0
901,Which store has the headphones in stock? Give me the store name and the total quantity.,NON-NESTED,headphone_store,"[store.Name,stock.Quantity,stock.Store_ID = store.Store_ID,stock.Headphone_ID = headphone.Headphone_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT store.Name, SUM(stock.Quantity) AS total_quantity FROM stock JOIN store ON stock.Store_ID = store.Store_ID JOIN headphone ON stock.Headphone_ID = headphone.Headphone_ID GROUP BY store.Name;","SELECT t1.name ,  sum(t2.quantity) FROM store AS t1 JOIN stock AS t2 ON t1.store_id  =  t2.store_id GROUP BY t2.store_id ORDER BY sum(t2.quantity) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""store.Name"" and the total ""stock.Quantity"" of headphones in stock. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""stock"" table with the ""store"" table on ""stock.Store_ID = store.Store_ID"" and the ""stock"" table with the ""headphone"" table on ""stock.Headphone_ID = headphone.Headphone_ID"" to link stores with their headphone stock. 4. Aggregation Structure: Use SUM on ""stock.Quantity"" to calculate the total quantity of headphones in stock for each store, and GROUP BY ""store.Name"" to group results by store.",1.0
902,Show all locations where at least two conferences are located.,NESTED,conference,"[conference.Location, conference.Conference_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT Location FROM conference GROUP BY Location HAVING COUNT(Conference_ID) >= 2;,SELECT LOCATION FROM conference GROUP BY LOCATION HAVING count(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the location of conferences. Use the FROM clause to specify the conference table. Apply GROUP BY on the location to group records by each unique location. Use the HAVING clause to filter locations where the count of conferences is at least two. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for locations that have two or more conferences. 3. Join Structure: Not required, as all data is available within the conference table. 4. Aggregation Structure: Use COUNT(*) to count the number of conferences at each location and filter using the HAVING clause.",1.0
903,Find the name of stores which have no headphone in stock.,NESTED,headphone_store,"[store.Name,stock.Quantity,stock.Store_ID = store.Store_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT store.Name FROM store WHERE store.Store_ID NOT IN ( SELECT stock.Store_ID FROM stock WHERE stock.Quantity > 0 AND stock.Item = 'headphone' );,SELECT name FROM store WHERE store_id NOT IN (SELECT store_id FROM stock),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of stores. Use the FROM clause to specify the store table. Apply a WHERE clause to filter stores that do not have headphones in stock by ensuring that their Store_ID is not present in the stock table with a positive quantity for headphones. 2. Condition Structure: Use the WHERE clause with a subquery to exclude stores whose Store_ID appears in the stock table with a positive quantity for headphones. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Store_ID entries in the stock table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",0.0
904,What are the average rating and max age of all sailors?,EASY,boat_1,"[Sailors.rating, Sailors.age]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT AVG(Sailors.rating) AS avg_rating, MAX(Sailors.age) AS max_age FROM Sailors;","SELECT AVG(rating) ,  MAX(age) FROM Sailors","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average rating and the maximum age of all sailors. 2. Aggregation Structure: Use AVG to calculate the average rating and MAX to determine the maximum age. 3. Condition Structure: No specific filtering condition is required as the query asks for the aggregate values for all sailors. 4. Join Structure: No JOIN is required since all necessary data is within the ""Sailors"" table.",1.0
905,Find the number of papers published in different conferences each year.,EASY,aan_1,"[Paper.year, Paper.venue]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.year, Paper.venue, COUNT(*) AS paper_count FROM Paper GROUP BY Paper.year, Paper.venue;","SELECT count(*) ,  venue ,  YEAR FROM Paper GROUP BY venue ,  YEAR","1. Sequential Structure: Begin with the SELECT clause to specify the year and the count of papers published in different conferences. 2. Aggregation Structure: Use COUNT to calculate the number of papers published in each conference for each year. 3. Grouping Structure: Use GROUP BY on ""Paper.year"" and ""Paper.venue"" to group the results by year and conference. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paper"" table.",1.0
906,What are the names of all sailors with a higher rating than every sailor named Luis?,NESTED,boat_1,"[Sailors.name,Sailors.rating,Sailors.name = 'Luis']","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT name FROM Sailors WHERE rating > (SELECT MAX(rating) FROM Sailors WHERE name = 'Luis');,SELECT name FROM Sailors WHERE rating  >  (SELECT max(rating) FROM Sailors WHERE name  =  'Luis'),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of sailors. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors whose rating is higher than every sailor named 'Luis'. 2. Condition Structure: Use the WHERE clause with a subquery to compare the rating of each sailor against the maximum rating of sailors named 'Luis'. The subquery retrieves the maximum rating of sailors named 'Luis'. 3. Join Structure: Not required, as all data is in the Sailors table. 4. Aggregation Structure: Use the MAX function in the subquery to find the highest rating among sailors named 'Luis', and use this value in the filtering condition.",1.0
907,Show me the city code of two cities with a distance greater than the average.,NESTED,address_1,"[Direct_distance.city1_code, Direct_distance.city2_code, Direct_distance.distance]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT city1_code, city2_code FROM Direct_distance WHERE distance > (SELECT AVG(distance) FROM Direct_distance);","SELECT city1_code ,  city2_code FROM Direct_distance WHERE distance  >  (SELECT avg(distance) FROM Direct_distance)","1. Sequential Structure: Start with the SELECT clause to retrieve the city codes of two cities. Use the FROM clause to specify the Direct_distance table. Apply a WHERE clause to filter for distances greater than the average distance. 2. Condition Structure: Use the WHERE clause with a subquery to filter for rows where the distance is greater than the average distance. 3. Join Structure: Not required, as all data is in the Direct_distance table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average distance, which is then used in the filtering condition.",1.0
908,What the the student ids for students not living in the USA?,NESTED,address_1,"[Student.StuID, Student.city_code = City.city_code, City.country]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Student.StuID FROM Student JOIN City ON Student.city_code = City.city_code WHERE City.country != 'USA';,"SELECT StuID FROM Student EXCEPT SELECT StuID FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE country  =  ""USA""","1. Sequential Structure: Start with the SELECT clause to retrieve the student IDs. Use the FROM clause to specify the Student table and JOIN it with the City table to connect students with their city information. Apply a WHERE clause to filter for students not living in the USA. 2. Condition Structure: Use the WHERE clause to filter for cities where the country is not 'USA'. 3. Join Structure: Use an INNER JOIN between the Student and City tables based on the city_code to relate students with their respective cities. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
909,Find the number of reservations for each boat.,NON-NESTED,boat_1,"[Reserves.bid, Boats.bid = Reserves.bid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Reserves.bid, COUNT(*) AS reservation_count FROM Reserves JOIN Boats ON Boats.bid = Reserves.bid GROUP BY Reserves.bid;","SELECT bid ,  count(*) FROM Reserves GROUP BY bid","1. Sequential Structure: Start with the SELECT clause to retrieve the boat ID (""Reserves.bid"") and the count of reservations for each boat. Use COUNT to count the number of reservations. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Reserves"" and ""Boats"" tables based on the shared ""bid"" field to link reservations with boats. 4. Aggregation Structure: Use COUNT to count the number of reservations for each boat and GROUP BY ""Reserves.bid"" to group the results by boat ID.",1.0
910,List names and addresses for all affiliations.,EASY,aan_1,"[Affiliation.name, Affiliation.address]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Affiliation.name, Affiliation.address FROM Affiliation;","SELECT DISTINCT name ,  address FROM Affiliation","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""name"" and ""address"" of all affiliations. 2. Condition Structure: No specific filtering condition is required as the query asks for all affiliations. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Affiliation"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all names and addresses.",1.0
911,Find the number of headphones with a price higher than 200 for each class.,NON-NESTED,headphone_store,"[headphone.Class, headphone.Price, headphone.Headphone_ID, stock.Headphone_ID = headphone.Headphone_ID, stock.Quantity, 200]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Class, COUNT(headphone.Headphone_ID) AS NumberOfHeadphones FROM headphone JOIN stock ON stock.Headphone_ID = headphone.Headphone_ID WHERE headphone.Price > 200 GROUP BY headphone.Class;","SELECT count(*) ,  CLASS FROM headphone WHERE price  >  200 GROUP BY CLASS","1. Sequential Structure: Start with the SELECT clause to retrieve the ""headphone.Class"" and the count of headphones with a price higher than 200. Use COUNT to count the number of such headphones for each class. 2. Condition Structure: Use a WHERE clause to filter for headphones with a price greater than 200. 3. Join Structure: Use a JOIN between the ""headphone"" and ""stock"" tables based on ""headphone.Headphone_ID"" and ""stock.Headphone_ID"" to link each headphone with its stock information. 4. Aggregation Structure: Use COUNT to count the number of headphones for each class and GROUP BY ""headphone.Class"" to group the results by class.",0.0
912,How many reservations exist for each boat with an id greater than 50?,NON-NESTED,boat_1,"[Boats.bid,Reserves.bid,Reserves.sid = Sailors.sid,Reserves.bid = Boats.bid,50]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Boats.bid, COUNT(Reserves.bid) AS reservation_count FROM Boats JOIN Reserves ON Boats.bid = Reserves.bid WHERE Boats.bid > 50 GROUP BY Boats.bid;","SELECT bid ,  count(*) FROM Reserves GROUP BY bid HAVING bid  >  50","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Boats.bid"" and the count of reservations for each boat. Use COUNT on ""Reserves.bid"" to count the number of reservations. 2. Condition Structure: Use a WHERE clause to filter for boats with an id (Boats.bid) greater than 50. 3. Join Structure: Use a JOIN between the ""Boats"" and ""Reserves"" tables based on ""Boats.bid = Reserves.bid"" to associate each boat with its reservations. 4. Aggregation Structure: Use GROUP BY on ""Boats.bid"" to group the results by each boat and apply COUNT to calculate the number of reservations for each boat.",1.0
913,What is the name of all sailors whose rating is higher than all sailors named Luis?,NESTED,boat_1,"[Sailors.name, Sailors.rating, Sailors.name = 'Luis']","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT name FROM Sailors WHERE rating > (SELECT MAX(rating) FROM Sailors WHERE name = 'Luis');,SELECT name FROM Sailors WHERE rating  >  (SELECT max(rating) FROM Sailors WHERE name  =  'Luis'),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of sailors. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors whose rating is higher than all sailors named 'Luis'. 2. Condition Structure: Use the WHERE clause with a subquery to compare the rating of each sailor against the maximum rating of sailors named 'Luis'. The subquery retrieves the maximum rating of sailors named 'Luis'. 3. Join Structure: Not required, as all data is in the Sailors table. 4. Aggregation Structure: Use the MAX function in the subquery to find the highest rating among sailors named 'Luis', and use this value in the filtering condition.",1.0
914,How many red boats exist?,EASY,boat_1,"[Boats.color, Boats.bid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT COUNT(Boats.bid) FROM Boats WHERE Boats.color = 'red';,SELECT count(*) FROM Boats WHERE color  =  'red',"1. Sequential Structure: Begin with the SELECT clause to count the number of boats. 2. Condition Structure: Use a WHERE clause to filter for boats with the color ""red."" 3. Join Structure: No JOIN is required since all necessary data is within the ""Boats"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of red boats.",1.0
915,"Find the model, class, and construction of the headphone with the lowest price.",EASY,headphone_store,"[headphone.Model, headphone.Class, headphone.Construction, headphone.Price]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Model, headphone.Class, headphone.Construction, headphone.Price FROM headphone ORDER BY headphone.Price ASC LIMIT 1;","SELECT model ,  CLASS ,  construction FROM headphone ORDER BY price LIMIT 1","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""headphone.Model,"" ""headphone.Class,"" ""headphone.Construction,"" and ""headphone.Price."" 2. Condition Structure: No specific filtering condition is required since we are looking for the headphone with the lowest price. 3. Join Structure: No JOIN is required as all necessary information is in the ""headphone"" table. 4. Aggregation Structure: Use ORDER BY on ""headphone.Price"" in ascending order to find the lowest price and apply LIMIT 1 to retrieve the headphone with the lowest price.",1.0
916,List all affiliations with ascending ordered number of papers.,NON-NESTED,aan_1,"[Affiliation.affiliation_id, Author_list.affiliation_id, Author_list.paper_id, Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Affiliation.affiliation_id, COUNT(Author_list.paper_id) AS paper_count FROM Affiliation JOIN Author_list ON Affiliation.affiliation_id = Author_list.affiliation_id JOIN Paper ON Author_list.paper_id = Paper.paper_id GROUP BY Affiliation.affiliation_id ORDER BY paper_count ASC;",SELECT T1.name FROM Affiliation AS T1 JOIN Author_list AS T2 ON T1.affiliation_id  =  T2.affiliation_id GROUP BY T1.affiliation_id ORDER BY count(*) DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Affiliation.affiliation_id"" and the count of papers associated with each affiliation. Use COUNT to calculate the number of papers for each affiliation. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect ""Affiliation"" with ""Author_list"" on ""affiliation_id"" and ""Author_list"" with ""Paper"" on ""paper_id"" to link affiliations with their respective papers. 4. Aggregation Structure: Use COUNT on ""Author_list.paper_id"" to count the number of papers for each affiliation. Use GROUP BY to group results by ""Affiliation.affiliation_id"" and ORDER BY in ascending order to sort the affiliations by the number of papers.",0.0
917,How many reference papers does paper with id D12-1027 have?,NON-NESTED,aan_1,"[Citation.paper_id, Citation.cited_paper_id, Paper.paper_id = Citation.paper_id, D12-1027]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Citation.cited_paper_id) FROM Citation WHERE Citation.paper_id = 'D12-1027';,"SELECT count(*) FROM Citation WHERE paper_id  =  ""D12-1027""","1. Sequential Structure: Start with the SELECT clause to count the number of references (cited papers) for the paper with id ""D12-1027."" 2. Condition Structure: Use a WHERE clause to filter the records where ""Citation.paper_id"" matches ""D12-1027."" 3. Join Structure: No JOIN is required since the necessary information is available in the ""Citation"" table. 4. Aggregation Structure: Use COUNT on ""Citation.cited_paper_id"" to count the number of references for the specified paper.",1.0
918,What are the city codes of the cities with the maximum distance?,NESTED,address_1,"[Direct_distance.city1_code, Direct_distance.city2_code, Direct_distance.distance]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT city1_code, city2_code FROM Direct_distance WHERE distance = (SELECT MAX(distance) FROM Direct_distance);","SELECT city1_code ,  city2_code FROM Direct_distance ORDER BY distance DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the city codes. Use the FROM clause to specify the Direct_distance table. Apply a WHERE clause to filter for the maximum distance. 2. Condition Structure: Use a WHERE clause with a subquery to filter for rows where the distance is equal to the maximum distance. 3. Join Structure: Not required, as all data is in the Direct_distance table. 4. Aggregation Structure: Use MAX in a subquery to find the maximum distance, and filter rows based on this value to retrieve the corresponding city codes.",1.0
919,Find the headphone models whose price is below the average price.,NESTED,headphone_store,"[headphone.Model, headphone.Price]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT Model FROM headphone WHERE Price < (SELECT AVG(Price) FROM headphone);,SELECT model FROM headphone WHERE price  <  (SELECT avg(price) FROM headphone),"1. Sequential Structure: Start with the SELECT clause to retrieve the headphone models. Use the FROM clause to specify the headphone table. Apply a WHERE clause to filter for models whose price is below the average price. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average price of all headphones and filter for models with a price below this value. 3. Join Structure: Not required, as all data is in the headphone table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average price, which is then used in the filtering condition.",1.0
920,Find the names of sailors who reserved boat with the name Melon.,NON-NESTED,boat_1,"[Sailors.name, Boats.name, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, Melon]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Sailors.name FROM Sailors JOIN Reserves ON Reserves.sid = Sailors.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Boats.name = 'Melon';,SELECT T1.name FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid JOIN Boats AS T3 ON T3.bid  =  T2.bid WHERE T3.name  =  'Melon',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of sailors (""Sailors.name""). 2. Condition Structure: Use a WHERE clause to filter for reservations where the boat name is ""Melon."" 3. Join Structure: Use JOINs to connect the ""Sailors,"" ""Reserves,"" and ""Boats"" tables. Join ""Sailors"" with ""Reserves"" on ""Reserves.sid = Sailors.sid"" and ""Reserves"" with ""Boats"" on ""Reserves.bid = Boats.bid."" 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of sailors.",1.0
921,Which 3 affiliations had the most papers in 2009?,NESTED,aan_1,"[Affiliation.affiliation_id,Affiliation.name,Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.paper_id = Paper.paper_id,Paper.year,2009]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Affiliation.name, COUNT(Paper.paper_id) AS paper_count FROM Affiliation JOIN Author_list ON Affiliation.affiliation_id = Author_list.affiliation_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Paper.year = 2009 GROUP BY Affiliation.name ORDER BY paper_count DESC LIMIT 3;",SELECT T3.name FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T1.year  =  2009 GROUP BY T2.affiliation_id ORDER BY count(*) DESC LIMIT 3,"1. Sequential Structure: Start with the SELECT clause to retrieve the affiliation name and the count of papers. Use the FROM clause to specify the Affiliation table and join it with the Author_list and Paper tables to connect affiliations with their papers. Use the WHERE clause to filter papers published in the year 2009. Apply GROUP BY on the affiliation name to count the number of papers per affiliation. Use ORDER BY to sort the results in descending order of paper count and LIMIT to retrieve the top 3 affiliations. 2. Condition Structure: Use the WHERE clause to filter papers published in the year 2009. 3. Join Structure: Use INNER JOINs between the Affiliation, Author_list, and Paper tables based on their respective keys (affiliation_id and paper_id) to connect affiliations with their papers. 4. Aggregation Structure: Use COUNT to calculate the number of papers per affiliation and ORDER BY to sort the results in descending order. Use LIMIT to restrict the output to the top 3 affiliations.",1.0
922,"Which venues and years did Mckeown , Kathleen have papers ?",NON-NESTED,aan_1,"[Author.name, Paper.venue, Paper.year, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Mckeown, Kathleen]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.venue, Paper.year FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Author.name = 'Mckeown, Kathleen';","select distinct t1.venue ,  t1.year from paper as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id join author as t3 on t2.author_id  =  t3.author_id where t3.name = ""mckeown ,  kathleen""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paper.venue"" and ""Paper.year"" fields. 2. Condition Structure: Use a WHERE clause to filter for the author name ""Mckeown, Kathleen."" 3. Join Structure: Use JOINs to connect the ""Author"" table with the ""Author_list"" table on ""Author.author_id,"" and then connect the ""Author_list"" table with the ""Paper"" table on ""Author_list.paper_id"" to link authors with their papers. 4. Aggregation Structure: No aggregation is needed, as the query simply retrieves the venues and years for the specified author.",1.0
923,What is the name of all sailors whose rating is higher than any sailor named Luis?,NESTED,boat_1,"[Sailors.name, Sailors.rating, Sailors.name = 'Luis']","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT name FROM Sailors WHERE rating > ANY (SELECT rating FROM Sailors WHERE name = 'Luis');,SELECT name FROM Sailors WHERE rating  >  (SELECT min(rating) FROM Sailors WHERE name  =  'Luis'),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of sailors. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors whose rating is higher than any sailor named 'Luis'. 2. Condition Structure: Use the WHERE clause with a subquery to compare the rating of each sailor to the ratings of sailors named 'Luis'. The subquery retrieves the ratings of all sailors named 'Luis'. 3. Join Structure: Not required, as all data is within the Sailors table. 4. Aggregation Structure: Not needed, as we are only comparing individual ratings without any aggregation.",0.0
924,Which state does the student whose first name is Linda live in?,NON-NESTED,address_1,"[Student.Fname, Student.city_code, City.city_code = Student.city_code, City.state]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.state FROM Student JOIN City ON Student.city_code = City.city_code WHERE Student.Fname = 'Linda';,"SELECT state FROM Student AS T1 JOIN City AS T2 ON T1.city_code  =  T2.city_code WHERE T1.Fname  =  ""Linda""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.state"" field, as the question asks for the state where the student lives. 2. Condition Structure: Use a WHERE clause to filter for the student whose first name is ""Linda."" 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to link each student with their corresponding city and state. 4. Aggregation Structure: No aggregation is needed since we are retrieving a single value based on the condition.",1.0
925,List top 10 most cited papers and their numbers of citations.,NON-NESTED,aan_1,"[Paper.paper_id, Paper.title, Citation.paper_id, Citation.cited_paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.title, COUNT(Citation.cited_paper_id) AS citation_count FROM Paper JOIN Citation ON Citation.cited_paper_id = Paper.paper_id GROUP BY Paper.paper_id ORDER BY citation_count DESC LIMIT 10;","SELECT paper_id ,  count(*) FROM Citation GROUP BY cited_paper_id ORDER BY count(*) DESC LIMIT 10","1. Sequential Structure: Start with the SELECT clause to retrieve the paper title and the count of citations for each paper. Use an alias for the count of citations. 2. Condition Structure: No specific filtering condition is required, as we are interested in all papers. 3. Join Structure: Use a JOIN between the ""Paper"" and ""Citation"" tables. The ""Citation.cited_paper_id"" is linked to ""Paper.paper_id"" to count the number of times each paper is cited. 4. Aggregation Structure: Use COUNT on ""Citation.cited_paper_id"" to calculate the number of citations for each paper. Use GROUP BY on ""Paper.paper_id"" to group the results by each paper. Finally, use ORDER BY in descending order of the citation count and LIMIT 10 to retrieve the top 10 most cited papers.",1.0
926,How many conferences occur every year?,EASY,conference,"[conference.Year, conference.Conference_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT conference.Year, COUNT(conference.Conference_ID) AS conference_count FROM conference GROUP BY conference.Year;","SELECT YEAR ,  count(*) FROM conference GROUP BY YEAR","1. Sequential Structure: Begin with the SELECT clause to count the number of conferences occurring each year. 2. Aggregation Structure: Use COUNT to calculate the number of conferences for each year. 3. Grouping Structure: Use GROUP BY on ""conference.Year"" to group the results by year. 4. Join Structure: No JOIN is required since all necessary data is within the ""conference"" table.",1.0
927,What is the average age of sailors whose rating is 7?,EASY,boat_1,"[Sailors.age, Sailors.rating, 7]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT AVG(Sailors.age) AS average_age FROM Sailors WHERE Sailors.rating = 7;,SELECT AVG(age) FROM Sailors WHERE rating  =  7,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average age of sailors. 2. Condition Structure: Use a WHERE clause to filter sailors whose rating is 7. 3. Join Structure: No JOIN is required since all necessary data is within the ""Sailors"" table. 4. Aggregation Structure: Use the AVG function to calculate the average age of the filtered sailors.",1.0
928,"What is the name of the author who has co-authored the most papers with Mckeown , Kathleen ?",NON-NESTED,aan_1,"[Author.name, Author_list.author_id, Author_list.paper_id, Paper.paper_id = Author_list.paper_id, Author_list.author_id = Author.author_id, Paper.title, Author.name = 'Mckeown , Kathleen']","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT A2.name FROM Author AS A1 JOIN Author_list AS AL1 ON A1.author_id = AL1.author_id JOIN Author_list AS AL2 ON AL1.paper_id = AL2.paper_id JOIN Author AS A2 ON AL2.author_id = A2.author_id WHERE A1.name = 'Mckeown , Kathleen' AND A2.name != 'Mckeown , Kathleen' GROUP BY A2.name ORDER BY COUNT(AL2.paper_id) DESC LIMIT 1;","select t4.name from author_list as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id and t1.author_id != t2.author_id join author as t3 on t1.author_id  =  t3.author_id join author as t4 on t2.author_id  =  t4.author_id where t3.name = ""mckeown ,  kathleen"" group by t2.author_id order by count(*) desc limit 1","1. Sequential Structure: Start with the SELECT clause to retrieve the name of the author who has co-authored the most papers with ""Mckeown , Kathleen."" Use COUNT to count the number of papers co-authored by each author. 2. Condition Structure: Use a WHERE clause to filter for papers where one of the authors is ""Mckeown , Kathleen."" 3. Join Structure: Use JOINs to connect the ""Author,"" ""Author_list,"" and ""Paper"" tables. First, join ""Author"" with ""Author_list"" on ""author_id"" to get the list of authors for each paper. Then, join ""Author_list"" with ""Paper"" on ""paper_id"" to link authors to their papers. 4. Aggregation Structure: Use GROUP BY on the co-author's name to group the results by each co-author. Use ORDER BY in descending order of the count of papers to rank the co-authors, and LIMIT 1 to get the author with the highest count.",1.0
929,What are all locations that have hosted at least two conferences?,EASY,conference,"[conference.Location, conference.Conference_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT conference.Location FROM conference GROUP BY conference.Location HAVING COUNT(conference.Conference_ID) >= 2;,SELECT LOCATION FROM conference GROUP BY LOCATION HAVING count(*)  >=  2,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the location. 2. Aggregation Structure: Use COUNT to determine the number of conferences hosted at each location. 3. Grouping Structure: Use GROUP BY on ""conference.Location"" to aggregate the results by each location. 4. Condition Structure: Apply the HAVING clause to filter for locations that have hosted at least two conferences, by setting the count to be greater than or equal to 2. 5. Join Structure: No JOIN is required since all necessary data is within the ""conference"" table.",1.0
930,Find the id and title of the papers that are never cited by others.,NESTED,aan_1,"[Paper.paper_id, Paper.title, Citation.cited_paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT paper_id, title FROM Paper WHERE paper_id NOT IN (SELECT cited_paper_id FROM Citation);","SELECT paper_id ,  title FROM Paper WHERE paper_id NOT IN (SELECT cited_paper_id FROM Citation)","1. Sequential Structure: Start with the SELECT clause to retrieve the id and title of papers. Use the FROM clause to specify the Paper table. Apply a WHERE clause to filter papers that are not cited by others. 2. Condition Structure: Use the WHERE clause with a subquery to exclude papers whose paper_id appears in the cited_paper_id column of the Citation table. 3. Join Structure: Not required, as we only need to filter based on the absence of matching paper_id entries in the Citation table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
931,What is the total number of conferences?,EASY,conference,[conference.Conference_ID],"Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT COUNT(conference.Conference_ID) AS total_conferences FROM conference;,SELECT count(*) FROM conference,"1. Sequential Structure: Begin with the SELECT clause to count the total number of conferences. 2. Aggregation Structure: Use the COUNT function on ""conference.Conference_ID"" to calculate the total number of conferences. 3. Condition Structure: No specific filtering condition is required as we are counting all conferences. 4. Join Structure: No JOIN is necessary since all required data is within the ""conference"" table.",1.0
932,How far do Linda (first name) Smith (last name) and Tracy (first name) Kim (last name) live?,NON-NESTED,address_1,"[Student.Fname, Student.LName, Student.city_code, City.city_code = Student.city_code, City.city_code = Direct_distance.city1_code, City.city_code = Direct_distance.city2_code, Direct_distance.distance]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Direct_distance.distance FROM Student AS S1 JOIN City AS C1 ON S1.city_code = C1.city_code JOIN Direct_distance ON (C1.city_code = Direct_distance.city1_code OR C1.city_code = Direct_distance.city2_code) WHERE (S1.Fname = 'Linda' AND S1.LName = 'Smith') OR (S1.Fname = 'Tracy' AND S1.LName = 'Kim');,"SELECT distance FROM Direct_distance AS T1 JOIN Student AS T2 ON T1.city1_code  =  T2.city_code JOIN Student AS T3 ON T1.city2_code  =  T3.city_code WHERE T2.Fname  =  ""Linda"" AND T2.Lname  =  ""Smith"" AND T3.Fname  =  ""Tracy"" AND T3.Lname  =  ""Kim""","1. Sequential Structure: Start with the SELECT clause to retrieve the distance between the cities where Linda Smith and Tracy Kim live. The ""Direct_distance.distance"" field will provide this information. 2. Condition Structure: Use WHERE clauses to filter for the specific students, Linda Smith and Tracy Kim, based on their first and last names. Then, match their respective city codes to the ""Direct_distance"" table to find the distance between their cities. 3. Join Structure: Use JOINs to connect the ""Student"" table with the ""City"" table on ""Student.city_code = City.city_code"" to get the city codes for Linda Smith and Tracy Kim. Then, join the ""City"" table with the ""Direct_distance"" table on ""City.city_code = Direct_distance.city1_code"" and ""City.city_code = Direct_distance.city2_code"" to find the distance between the two cities. 4. Aggregation Structure: No aggregation is needed, as we are directly retrieving the distance between the two cities.",1.0
933,Count the number of papers Stanford University had between 2000 and 2009.,NON-NESTED,aan_1,"[Affiliation.name, Paper.year, Author_list.affiliation_id = Affiliation.affiliation_id, Author_list.paper_id = Paper.paper_id, Stanford University, 2000, 2009]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Paper.paper_id) FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id JOIN Affiliation ON Author_list.affiliation_id = Affiliation.affiliation_id WHERE Affiliation.name = 'Stanford University' AND Paper.year BETWEEN 2000 AND 2009;,"SELECT count(DISTINCT T1.paper_id) FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T1.year  >=  2000 AND T1.year  <=  2009 AND T3.name LIKE ""Stanford University""","1. Sequential Structure: Start with the SELECT clause to count the number of papers. Use COUNT on ""Paper.paper_id"" to get the total number of papers. 2. Condition Structure: Use a WHERE clause to filter for papers published between the years 2000 and 2009 (inclusive) and where the affiliation name is ""Stanford University."" 3. Join Structure: Use JOINs to connect the ""Affiliation"" table with the ""Author_list"" table on ""affiliation_id"" and the ""Author_list"" table with the ""Paper"" table on ""paper_id"" to link papers with their affiliations. 4. Aggregation Structure: No additional aggregation is needed beyond the COUNT function.",0.0
934,What are the names and ages of all sailors sorted by decreasing rating?,EASY,boat_1,"[Sailors.name, Sailors.age, Sailors.rating]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.name, Sailors.age FROM Sailors ORDER BY Sailors.rating DESC;","SELECT name ,  age FROM Sailors ORDER BY rating DESC","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the names and ages of the sailors. 2. Condition Structure: No specific filtering condition is required as we want all sailors. 3. Join Structure: No JOIN is required since all necessary data is within the ""Sailors"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY in descending order on ""Sailors.rating"" to sort the sailors by their rating.",1.0
935,return the unique ids of sailors who are older than any sailors.,NESTED,boat_1,"[Sailors.sid,Sailors.age]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT DISTINCT sid FROM Sailors WHERE age > ANY (SELECT age FROM Sailors);,SELECT DISTINCT sid FROM Sailors WHERE age  >  (SELECT min(age) FROM Sailors);,"1. Sequential Structure: Start with the SELECT clause to retrieve the unique IDs of sailors. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors whose age is greater than the age of any other sailor. 2. Condition Structure: Use the WHERE clause with a subquery to compare the age of each sailor with the ages of all other sailors. The subquery retrieves all ages from the Sailors table, and the main query filters sailors whose age is greater than any of these. 3. Join Structure: Not required, as all data is from the Sailors table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",0.0
936,"What is the average, minimum, maximum distance between two cities?",EASY,address_1,[Direct_distance.distance],"Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT AVG(Direct_distance.distance) AS avg_distance, MIN(Direct_distance.distance) AS min_distance, MAX(Direct_distance.distance) AS max_distance FROM Direct_distance;","SELECT avg(distance) ,  min(distance) ,  max(distance) FROM Direct_distance","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average, minimum, and maximum distances. 2. Aggregation Structure: Use the AVG, MIN, and MAX functions to calculate the average, minimum, and maximum distances between two cities. 3. Join Structure: No JOIN is required since all necessary data is within the ""Direct_distance"" table. 4. Condition Structure: No specific filtering condition is needed as the query requires calculations on all distances.",1.0
937,What are the names of authors who have not published a paper in ACL?,NESTED,aan_1,"[Author.name, Paper.venue, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, ACL]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Author.name FROM Author WHERE Author.author_id NOT IN ( SELECT Author_list.author_id FROM Author_list JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Paper.venue = 'ACL' );,"SELECT name FROM Author WHERE author_id NOT IN (SELECT T1.author_id FROM Author_list AS T1 JOIN Paper AS T2 ON T1.paper_id  =  T2.paper_id WHERE T2.venue  =  ""ACL"")","1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors. Use the FROM clause to specify the Author table. Use a WHERE clause to filter authors who have not published a paper in the ACL venue. 2. Condition Structure: Use the WHERE clause with a subquery to exclude authors whose papers are associated with the ACL venue. The subquery identifies all author IDs linked to papers published in ACL. 3. Join Structure: Use INNER JOINs between the Author, Author_list, and Paper tables to connect authors with their papers and venues. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
938,"What are the 10 most cited papers, and how many citations did each have?",NON-NESTED,aan_1,"[Citation.paper_id, COUNT(Citation.cited_paper_id), Citation.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.paper_id, COUNT(Citation.cited_paper_id) AS citation_count FROM Citation JOIN Paper ON Citation.paper_id = Paper.paper_id GROUP BY Citation.paper_id ORDER BY citation_count DESC LIMIT 10;","SELECT paper_id ,  count(*) FROM Citation GROUP BY cited_paper_id ORDER BY count(*) DESC LIMIT 10","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paper.paper_id"" and the count of citations for each paper. Use COUNT on ""Citation.cited_paper_id"" to calculate the number of citations for each paper. 2. Condition Structure: No specific filtering condition is required, as we are interested in all papers and their citation counts. 3. Join Structure: Use a JOIN between the ""Citation"" and ""Paper"" tables based on ""Citation.paper_id = Paper.paper_id"" to link each citation record to its corresponding paper. 4. Aggregation Structure: Use GROUP BY on ""Citation.paper_id"" to group the citation counts by paper. Use ORDER BY in descending order on the citation count to rank papers by the number of citations. Use LIMIT 10 to retrieve the top 10 most cited papers.",0.0
939,How many papers does Columbia University have in or before 2009 ?,NON-NESTED,aan_1,"[Affiliation.name, Author_list.affiliation_id = Affiliation.affiliation_id, Author_list.paper_id = Paper.paper_id, Paper.year, Columbia University, 2009]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Paper.paper_id) FROM Affiliation JOIN Author_list ON Affiliation.affiliation_id = Author_list.affiliation_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Affiliation.name = 'Columbia University' AND Paper.year <= 2009;,"select count(distinct t1.paper_id) from paper as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id join affiliation as t3 on t2.affiliation_id  =  t3.affiliation_id where t1.year  <=  2009 and t3.name = ""columbia university""","1. Sequential Structure: Start with the SELECT clause to count the number of papers. Use COUNT on ""Paper.paper_id"" to get the total number of papers. 2. Condition Structure: Use a WHERE clause to filter for papers published in or before the year 2009 and affiliated with ""Columbia University."" 3. Join Structure: Use JOINs to connect the ""Affiliation"" table with the ""Author_list"" table on ""affiliation_id"" and the ""Author_list"" table with the ""Paper"" table on ""paper_id"" to link papers with their affiliations. 4. Aggregation Structure: Use COUNT to aggregate the total number of papers that meet the specified conditions.",0.0
940,"Who has the most papers co-authored with Mckeown , Kathleen ?",NON-NESTED,aan_1,"[Author.name, Author.author_id, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Paper.title, Paper.paper_id = Citation.paper_id, Citation.cited_paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT A2.name FROM Author AS A1 JOIN Author_list AS AL1 ON A1.author_id = AL1.author_id JOIN Author_list AS AL2 ON AL1.paper_id = AL2.paper_id JOIN Author AS A2 ON AL2.author_id = A2.author_id WHERE A1.name = 'Mckeown, Kathleen' AND A2.name != 'Mckeown, Kathleen' GROUP BY A2.name ORDER BY COUNT(AL2.paper_id) DESC LIMIT 1;","select t4.name from author_list as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id and t1.author_id != t2.author_id join author as t3 on t1.author_id  =  t3.author_id join author as t4 on t2.author_id  =  t4.author_id where t3.name = ""mckeown ,  kathleen"" group by t2.author_id order by count(*) desc limit 1","1. Sequential Structure: Start with the SELECT clause to retrieve the name of the author who has the most co-authored papers with ""Mckeown, Kathleen."" Use COUNT to count the number of co-authored papers for each author. 2. Condition Structure: Use a WHERE clause to filter for papers where ""Mckeown, Kathleen"" is one of the authors. This requires identifying her ""author_id"" first. 3. Join Structure: Use JOINs to connect the ""Author,"" ""Author_list,"" and ""Paper"" tables. First, join ""Author"" with ""Author_list"" to get the papers authored by ""Mckeown, Kathleen."" Then, join ""Author_list"" again to find other authors who co-authored the same papers. 4. Aggregation Structure: Use COUNT to count the number of co-authored papers for each author. Use GROUP BY to group results by author and ORDER BY in descending order to find the author with the most co-authored papers. Use LIMIT 1 to get the top result.",1.0
941,Find the names of boats booked by sailors whose age is between 20 and 30.,NON-NESTED,boat_1,"[Boats.name, Sailors.age, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, 20, 30]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Boats.name FROM Sailors JOIN Reserves ON Reserves.sid = Sailors.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Sailors.age BETWEEN 20 AND 30;,SELECT T3.name FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid JOIN Boats AS T3 ON T3.bid  =  T2.bid WHERE T1.age BETWEEN 20 AND 30,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of boats (""Boats.name""). 2. Condition Structure: Use a WHERE clause to filter sailors whose age is between 20 and 30. 3. Join Structure: Use JOINs to connect the ""Sailors"" table with the ""Reserves"" table on ""Reserves.sid = Sailors.sid"" and the ""Boats"" table on ""Reserves.bid = Boats.bid"" to link sailors with the boats they reserved. 4. Aggregation Structure: No aggregation is needed as the query only requires the names of boats.",1.0
942,Find the average price for each headphone construction.,EASY,headphone_store,"[headphone.Construction, headphone.Price]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Construction, AVG(headphone.Price) AS avg_price FROM headphone GROUP BY headphone.Construction;","SELECT construction ,  avg(price) FROM headphone GROUP BY construction","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the headphone construction type and the average price. 2. Aggregation Structure: Use the AVG function to calculate the average price for each headphone construction type. 3. Grouping Structure: Use GROUP BY on ""headphone.Construction"" to calculate the average price for each construction type. 4. Join Structure: No JOIN is required since all necessary data is within the ""headphone"" table.",1.0
943,What is the venue and year with the most number of publications?,NON-NESTED,aan_1,"[Paper.venue, Paper.year, Paper.paper_id, Author_list.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.venue, Paper.year, COUNT(Paper.paper_id) AS publication_count FROM Paper GROUP BY Paper.venue, Paper.year ORDER BY publication_count DESC LIMIT 1;","SELECT venue ,  YEAR FROM paper GROUP BY venue ,  YEAR ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""Paper.venue"" and ""Paper.year."" Additionally, use COUNT on ""Paper.paper_id"" to count the number of publications. 2. Condition Structure: No specific filtering condition is required, as we are interested in finding the venue and year with the most publications. 3. Join Structure: No JOIN is necessary since all the required data is available in the ""Paper"" table. 4. Aggregation Structure: Use COUNT to count the number of publications for each combination of venue and year. Use GROUP BY to group the results by ""Paper.venue"" and ""Paper.year."" Finally, use ORDER BY in descending order on the count of publications and LIMIT 1 to get the venue and year with the most publications.",1.0
944,Count the number of authors.,EASY,aan_1,[Author.author_id],"Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(DISTINCT Author.author_id) AS author_count FROM Author;,SELECT count(*) FROM Author,"1. Sequential Structure: Begin with the SELECT clause to count the number of authors. 2. Aggregation Structure: Use the COUNT function to count the distinct ""Author.author_id"" values, as each author has a unique ID. 3. Join Structure: No JOIN is required since all necessary data is within the ""Author"" table. 4. Condition Structure: No specific filtering condition is needed, as we are counting all authors.",1.0
945,How many authors do we have?,EASY,aan_1,[Author.author_id],"Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Author.author_id) AS total_authors FROM Author;,SELECT count(*) FROM Author,"1. Sequential Structure: Start with the SELECT clause to count the number of authors. 2. Aggregation Structure: Use the COUNT function to calculate the total number of authors based on their unique ""author_id"". 3. Join Structure: No JOIN is required since all necessary data is within the ""Author"" table. 4. Condition Structure: No specific filtering condition is needed as we want the total count of all authors.",1.0
946,"What are the titles and paper ids for papers that have Mckeown, Kathleen or Rambow, Owen in their author list?",NON-NESTED,aan_1,"[Paper.title, Paper.paper_id, Author.name, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.title, Paper.paper_id FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id JOIN Author ON Author_list.author_id = Author.author_id WHERE Author.name = 'Mckeown, Kathleen' OR Author.name = 'Rambow, Owen';","SELECT DISTINCT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id WHERE  T3.name LIKE ""%Mckeown ,  Kathleen%"" OR T3.name LIKE ""%Rambow ,  Owen%""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Paper.title"" and ""Paper.paper_id."" 2. Condition Structure: Use a WHERE clause to filter for records where ""Author.name"" is either ""Mckeown, Kathleen"" or ""Rambow, Owen."" 3. Join Structure: Use JOINs to connect ""Paper"" with ""Author_list"" on ""Paper.paper_id = Author_list.paper_id"" and ""Author_list"" with ""Author"" on ""Author_list.author_id = Author.author_id"" to link papers with their respective authors. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields without any summarization.",1.0
947,What is the distance between Boston and Newark?,NON-NESTED,address_1,"[City.city_name,Direct_distance.distance,City.city_code = Direct_distance.city1_code,City.city_code = Direct_distance.city2_code,Boston,Newark]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Direct_distance.distance FROM City AS C1 JOIN Direct_distance ON C1.city_code = Direct_distance.city1_code OR C1.city_code = Direct_distance.city2_code WHERE (C1.city_name = 'Boston' AND Direct_distance.city2_code = (SELECT city_code FROM City WHERE city_name = 'Newark')) OR (C1.city_name = 'Newark' AND Direct_distance.city1_code = (SELECT city_code FROM City WHERE city_name = 'Boston'));,"SELECT distance FROM Direct_distance AS T1 JOIN City AS T2 ON T1.city1_code  =  T2.city_code JOIN City AS T3 ON T1.city2_code  =  T3.city_code WHERE T2.city_name  =  ""Boston"" AND T3.city_name  =  ""Newark""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Direct_distance.distance"" between the two cities. 2. Condition Structure: Use a WHERE clause to filter for the specific cities, ""Boston"" and ""Newark."" This requires matching the city codes of ""Boston"" and ""Newark"" with ""Direct_distance.city1_code"" and ""Direct_distance.city2_code."" 3. Join Structure: Use JOIN to connect the ""City"" table with the ""Direct_distance"" table based on ""City.city_code"" and ""Direct_distance.city1_code"" or ""Direct_distance.city2_code."" 4. Aggregation Structure: No aggregation is needed as we are retrieving a single distance value.",1.0
948,"What are the distinct venues for papers, ordered by year?",EASY,aan_1,"[Paper.venue, Paper.year]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT DISTINCT Paper.venue, Paper.year FROM Paper ORDER BY Paper.year;","SELECT DISTINCT venue ,  YEAR FROM paper ORDER BY YEAR","1. Sequential Structure: Begin with the SELECT clause to specify the distinct venues and their corresponding years. 2. Condition Structure: No specific filtering condition is required as we want all distinct venues. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Paper"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by year.",1.0
949,How many stores are there in each neighborhood?,EASY,headphone_store,"[store.Neighborhood, store.Store_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT store.Neighborhood, COUNT(store.Store_ID) AS store_count FROM store GROUP BY store.Neighborhood;","SELECT count(*) ,  neighborhood FROM store GROUP BY neighborhood","1. Sequential Structure: Start with the SELECT clause to specify the neighborhood and the count of stores. 2. Aggregation Structure: Use COUNT to calculate the number of stores in each neighborhood. 3. Grouping Structure: Use GROUP BY on ""store.Neighborhood"" to count stores for each neighborhood. 4. Join Structure: No JOIN is required since all necessary data is within the ""store"" table.",1.0
950,Find the number of reservations for each boat with more than 1 reservation.,NON-NESTED,boat_1,"[Reserves.bid, Boats.bid, Reserves.sid, Reserves.bid = Boats.bid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Reserves.bid, COUNT(Reserves.sid) AS reservation_count FROM Reserves GROUP BY Reserves.bid HAVING COUNT(Reserves.sid) > 1;","SELECT bid ,  count(*) FROM Reserves GROUP BY bid HAVING count(*)  >  1","1. Sequential Structure: Start with the SELECT clause to retrieve the boat ID (""Reserves.bid"") and the count of reservations for each boat. Use COUNT to count the number of reservations. 2. Condition Structure: Use a HAVING clause to filter boats with more than 1 reservation. 3. Join Structure: No JOIN is necessary as the required data is available in the ""Reserves"" table. 4. Aggregation Structure: Use COUNT on ""Reserves.bid"" to count the number of reservations for each boat, and GROUP BY ""Reserves.bid"" to group the results by boat ID.",1.0
951,"Find the headphone classes that contain both headphones using ""Bowls"" earpads and headphones using ""Comfort Pads"" earpads.",NESTED,headphone_store,"[headphone.Class, headphone.Earpads, stock.Headphone_ID = headphone.Headphone_ID, Bowls, Comfort Pads]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Class FROM headphone JOIN stock ON stock.Headphone_ID = headphone.Headphone_ID WHERE headphone.Earpads IN ('Bowls', 'Comfort Pads') GROUP BY headphone.Class HAVING COUNT(DISTINCT headphone.Earpads) = 2;",SELECT CLASS FROM headphone WHERE earpads  =  'Bowls' INTERSECT SELECT CLASS FROM headphone WHERE earpads  =  'Comfort Pads',"1. Sequential Structure: Start with the SELECT clause to retrieve the headphone classes. Use the FROM clause to specify the headphone table and join it with the stock table to connect headphone details with their stock information. Use a WHERE clause to filter for headphones that use ""Bowls"" earpads and ""Comfort Pads"" earpads. 2. Condition Structure: Use a WHERE clause to filter headphones based on their earpads being either ""Bowls"" or ""Comfort Pads"". Use a GROUP BY clause to group by headphone class and a HAVING clause to ensure that both types of earpads are present in the same class. 3. Join Structure: Use an INNER JOIN between the headphone and stock tables based on the Headphone_ID to connect headphone details with their stock information. 4. Aggregation Structure: Use COUNT(DISTINCT headphone.Earpads) in the HAVING clause to ensure that both ""Bowls"" and ""Comfort Pads"" earpads are present in the same headphone class.",1.0
952,What are the names of authors who have exactly 1 paper?,NESTED,aan_1,"[Author.name, Author.author_id, Author_list.author_id = Author.author_id, Author_list.paper_id, Paper.paper_id = Author_list.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Author.name FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id GROUP BY Author.author_id, Author.name HAVING COUNT(Author_list.paper_id) = 1;",SELECT T1.name FROM Author AS T1 JOIN Author_list AS T2 ON T1.author_id  =  T2.author_id GROUP BY T1.author_id HAVING count(*)  =  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors. Use the FROM clause to specify the Author table and JOIN it with the Author_list table to link authors with their papers. Use GROUP BY to group records by author_id, allowing us to count the number of papers for each author. Apply a HAVING clause to filter authors who have exactly 1 paper. 2. Condition Structure: Use the HAVING clause with COUNT(paper_id) to filter for authors who are associated with exactly 1 paper. 3. Join Structure: Use an INNER JOIN between the Author and Author_list tables based on author_id to connect authors with their papers. Additionally, use an INNER JOIN between Author_list and Paper tables based on paper_id to ensure the relationship with papers. 4. Aggregation Structure: Use COUNT(paper_id) to count the number of papers associated with each author and filter for authors with exactly 1 paper.",1.0
953,What is the total distance between city BAL and all other cities.,NON-NESTED,address_1,"[City.city_name,Direct_distance.city1_code,Direct_distance.city2_code,Direct_distance.distance,Direct_distance.city1_code = City.city_code,BAL]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT SUM(Direct_distance.distance) FROM Direct_distance JOIN City ON Direct_distance.city1_code = City.city_code OR Direct_distance.city2_code = City.city_code WHERE City.city_name = 'BAL';,"SELECT sum(distance) FROM Direct_distance WHERE city1_code  =  ""BAL""","1. Sequential Structure: Start with the SELECT clause to calculate the total distance. Use the SUM function on the ""Direct_distance.distance"" field to compute the total distance. 2. Condition Structure: Use a WHERE clause to filter for records where either ""Direct_distance.city1_code"" or ""Direct_distance.city2_code"" corresponds to the city code of ""BAL."" 3. Join Structure: Use a JOIN between the ""City"" table and the ""Direct_distance"" table to link the city name ""BAL"" with its corresponding city code. 4. Aggregation Structure: Use the SUM function to aggregate the distances between ""BAL"" and all other cities.",0.0
954,Return all details of sailors who are older than 30.,EASY,boat_1,"[Sailors.sid,Sailors.name,Sailors.rating,Sailors.age,30]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT * FROM Sailors WHERE Sailors.age > 30;,SELECT * FROM Sailors WHERE age  >  30,"1. Sequential Structure: Start with the SELECT clause to retrieve all details of sailors, as the question asks for all fields. 2. Condition Structure: Use a WHERE clause to filter sailors whose age is greater than 30. 3. Join Structure: No JOIN is required since all necessary information is in the ""Sailors"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving individual records based on a specific condition.",1.0
955,"What are the venues and years where Mckeown , Kathleen had papers ?",NON-NESTED,aan_1,"[Author.name, Paper.venue, Paper.year, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Mckeown, Kathleen]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.venue, Paper.year FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Author.name = 'Mckeown, Kathleen';","select distinct t1.venue ,  t1.year from paper as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id join author as t3 on t2.author_id  =  t3.author_id where t3.name = ""mckeown ,  kathleen""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paper.venue"" and ""Paper.year"" fields. 2. Condition Structure: Use a WHERE clause to filter for the author name ""Mckeown, Kathleen."" 3. Join Structure: Use JOINs to connect the ""Author"" table with the ""Author_list"" table on ""Author.author_id"" and then connect the ""Author_list"" table with the ""Paper"" table on ""Author_list.paper_id"" to link authors with their papers. 4. Aggregation Structure: No aggregation is needed, as the query only requires listing venues and years.",1.0
956,"Give me a list of store names, sorted by store open date.",EASY,headphone_store,"[store.Name, store.Date_Opened]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT store.Name, store.Date_Opened FROM store ORDER BY store.Date_Opened;",SELECT name FROM store ORDER BY date_opened,"1. Sequential Structure: Start with the SELECT clause to retrieve the store names and their open dates. 2. Condition Structure: No specific filtering condition is required as we want all store names and their open dates. 3. Join Structure: No JOIN is needed since all necessary information is available in the ""store"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""store.Date_Opened"" to sort the results by the store open date.",1.0
957,How many affiliations do we have?,EASY,aan_1,[Affiliation.affiliation_id],"Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Affiliation.affiliation_id) AS total_affiliations FROM Affiliation;,SELECT count(*) FROM Affiliation,"1. Sequential Structure: Start with the SELECT clause to count the number of affiliations. 2. Aggregation Structure: Use the COUNT function to calculate the total number of affiliations based on the ""Affiliation.affiliation_id"". 3. Condition Structure: No specific filtering condition is required as we want the total count of all affiliations. 4. Join Structure: No JOIN is required since all necessary data is within the ""Affiliation"" table.",1.0
958,Find the titles and paper IDs for papers written by Harvard University.,NON-NESTED,aan_1,"[Paper.title, Paper.paper_id, Author_list.affiliation_id = Affiliation.affiliation_id, Author_list.paper_id = Paper.paper_id, Affiliation.name, Harvard University]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.title, Paper.paper_id FROM Paper JOIN Author_list ON Author_list.paper_id = Paper.paper_id JOIN Affiliation ON Author_list.affiliation_id = Affiliation.affiliation_id WHERE Affiliation.name = 'Harvard University';","SELECT DISTINCT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T3.name  =  ""Harvard University""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Paper.title"" and ""Paper.paper_id."" 2. Condition Structure: Use a WHERE clause to filter for records where the ""Affiliation.name"" is ""Harvard University."" 3. Join Structure: Use JOINs to connect ""Paper"" with ""Author_list"" on ""Author_list.paper_id = Paper.paper_id"" and ""Author_list"" with ""Affiliation"" on ""Author_list.affiliation_id = Affiliation.affiliation_id"" to link papers with their affiliations. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without any summarization.",1.0
959,What is the name of the author with the most papers in 2009?,NON-NESTED,aan_1,"[Author.name,Author_list.author_id,Author_list.paper_id = Paper.paper_id,Paper.year,2009]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Author.name FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Paper.year = 2009 GROUP BY Author.author_id ORDER BY COUNT(Paper.paper_id) DESC LIMIT 1;,SELECT T3.name FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T3.author_id  =  T2.author_id WHERE T1.year  =  2009 GROUP BY T2.author_id ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Author.name"" of the author with the most papers. Use COUNT to count the number of papers for each author. 2. Condition Structure: Use a WHERE clause to filter for papers published in the year 2009. 3. Join Structure: Use JOINs to connect the ""Author_list"" table with the ""Paper"" table on ""paper_id"" and the ""Author"" table on ""author_id"" to link authors with their papers. 4. Aggregation Structure: Use COUNT to count the number of papers for each author, GROUP BY ""Author.author_id"" to group the results by author, and ORDER BY the count in descending order. Use LIMIT 1 to get the author with the most papers.",1.0
960,Find the id of the papers whose title has the key word 'translation'.,EASY,aan_1,"[Paper.paper_id, Paper.title, 'translation']","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Paper.paper_id FROM Paper WHERE Paper.title LIKE '%translation%';,"SELECT paper_id FROM Paper WHERE title LIKE ""%translation%""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paper.paper_id"" of the papers whose title contains the keyword 'translation'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for paper titles that contain the keyword 'translation'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Paper"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific paper IDs based on a condition.",1.0
961,Give the title of the paper which cites most number of papers?,NON-NESTED,aan_1,"[Paper.title, Citation.paper_id, Citation.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Paper.title FROM Paper JOIN Citation ON Citation.paper_id = Paper.paper_id GROUP BY Paper.paper_id ORDER BY COUNT(Citation.paper_id) DESC LIMIT 1;,SELECT T2.title FROM Citation AS T1 JOIN Paper AS T2 ON T2.paper_id  =  T1.paper_id GROUP BY T1.paper_id ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paper.title"" of the paper that cites the most number of other papers. Use COUNT to count the number of citations for each paper. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the paper with the highest number of citations. 3. Join Structure: Use a JOIN between the ""Paper"" and ""Citation"" tables based on ""Citation.paper_id = Paper.paper_id"" to link each paper with its citations. 4. Aggregation Structure: Use COUNT on ""Citation.paper_id"" to count the number of citations for each paper. Use ORDER BY in descending order to rank papers by the number of citations and LIMIT 1 to select the paper with the most citations.",1.0
962,Return the unique names of sailors who are older than any sailors whose rating is larger than 7.,NESTED,boat_1,"[Sailors.name, Sailors.age, Sailors.rating]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT DISTINCT Sailors.name FROM Sailors WHERE Sailors.age > ANY (SELECT Sailors.age FROM Sailors WHERE Sailors.rating > 7);,SELECT DISTINCT name FROM Sailors WHERE age  >  (SELECT min(age) FROM Sailors WHERE rating  >  7);,"1. Sequential Structure: Start with the SELECT clause to retrieve unique sailor names. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors whose age is greater than the age of any sailor with a rating larger than 7. 2. Condition Structure: Use the WHERE clause with a subquery to compare the age of sailors to the ages of sailors with a rating greater than 7. The subquery retrieves the ages of sailors with a rating larger than 7. 3. Join Structure: Not required, as all data is in the Sailors table. 4. Aggregation Structure: Not needed, as we are only filtering and retrieving specific records without any aggregation.",0.0
963,Show all conference names and the number of times each conference has.,NON-NESTED,conference,"[conference.Conference_Name, conference.Conference_ID, conference_participation.Conference_ID = conference.Conference_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT conference.Conference_Name, COUNT(conference_participation.Conference_ID) AS Participation_Count FROM conference JOIN conference_participation ON conference.Conference_ID = conference_participation.Conference_ID GROUP BY conference.Conference_Name;","SELECT conference_name ,  count(*) FROM conference GROUP BY conference_name","1. Sequential Structure: Start with the SELECT clause to retrieve ""conference.Conference_Name"" and the count of occurrences for each conference. Use COUNT to count the number of times each conference appears. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""conference"" table and the ""conference_participation"" table based on the ""Conference_ID"" field to link each conference with its participation records. 4. Aggregation Structure: Use COUNT to count the occurrences of each conference and GROUP BY ""conference.Conference_Name"" to group the results by conference name.",1.0
964,"What are the names of all affiliations, ordered by number of papers?",NON-NESTED,aan_1,"[Affiliation.name,Author_list.affiliation_id,Author_list.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Affiliation.name, COUNT(Paper.paper_id) AS paper_count FROM Affiliation JOIN Author_list ON Affiliation.affiliation_id = Author_list.affiliation_id JOIN Paper ON Author_list.paper_id = Paper.paper_id GROUP BY Affiliation.name ORDER BY paper_count DESC;",SELECT T1.name FROM Affiliation AS T1 JOIN Author_list AS T2 ON T1.affiliation_id  =  T2.affiliation_id GROUP BY T1.affiliation_id ORDER BY count(*) DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of affiliations and the count of papers associated with each affiliation. Use COUNT to count the number of papers for each affiliation. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Affiliation"" table with the ""Author_list"" table on ""affiliation_id"" and the ""Author_list"" table with the ""Paper"" table on ""paper_id"" to link affiliations with their respective papers. 4. Aggregation Structure: Use GROUP BY on ""Affiliation.name"" to group the results by affiliation name, and use ORDER BY in descending order of the paper count to sort affiliations by the number of papers.",1.0
965,What are the venues and years where Columbia University had papers ?,NESTED,aan_1,"[Affiliation.name, Paper.venue, Paper.year, Author_list.affiliation_id = Affiliation.affiliation_id, Author_list.paper_id = Paper.paper_id, Columbia University]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.venue, Paper.year FROM Affiliation JOIN Author_list ON Affiliation.affiliation_id = Author_list.affiliation_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Affiliation.name = 'Columbia University';","select distinct t1.venue ,  t1.year from paper as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id join affiliation as t3 on t2.affiliation_id  =  t3.affiliation_id where t3.name = ""columbia university""","1. Sequential Structure: Start with the SELECT clause to retrieve the venues and years where Columbia University had papers. Use the FROM clause to specify the relevant tables: Affiliation, Paper, and Author_list. 2. Condition Structure: Use the WHERE clause to filter for records where the affiliation name is 'Columbia University'. 3. Join Structure: Use INNER JOINs to connect the Affiliation table with the Author_list table on affiliation_id, and the Author_list table with the Paper table on paper_id. This ensures we link affiliations to papers. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
966,how many different earpads are there?,EASY,headphone_store,[headphone.Earpads],"Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT COUNT(DISTINCT headphone.Earpads) FROM headphone;,SELECT count(DISTINCT earpads) FROM headphone,"1. Sequential Structure: Start with the SELECT clause to count the distinct earpads. 2. Condition Structure: No specific filtering condition is required as we want to count all distinct earpads. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""headphone"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique earpads.",1.0
967,What are the names of authors who published in both NAACL and ACL in 2009?,NESTED,aan_1,"[Author.name, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Paper.venue, Paper.year, NAACL, ACL, 2009]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Author.name FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Paper.year = 2009 AND Paper.venue IN ('NAACL', 'ACL') GROUP BY Author.author_id, Author.name HAVING COUNT(DISTINCT Paper.venue) = 2;","SELECT name FROM Author WHERE author_id IN (SELECT T1.author_id FROM Author_list AS T1 JOIN Paper AS T2 ON T1.paper_id  =  T2.paper_id WHERE T2.venue  =  ""ACL"" AND T2.year  =  2009 INTERSECT SELECT T1.author_id FROM Author_list AS T1 JOIN Paper AS T2 ON T1.paper_id  =  T2.paper_id WHERE T2.venue  =  ""NAACL"" AND T2.year  =  2009)","1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors. Use the FROM clause to specify the Author table and JOIN it with the Author_list table to link authors with their papers. Further, JOIN the Paper table to access the venue and year of publication. Apply a WHERE clause to filter for papers published in NAACL and ACL in 2009. 2. Condition Structure: Use the WHERE clause to filter for papers published in the venues 'NAACL' and 'ACL' in the year 2009. Use a subquery or grouping to ensure that authors have published in both venues. 3. Join Structure: Use INNER JOINs between the Author, Author_list, and Paper tables based on their respective keys (author_id and paper_id) to connect authors with their publication details. 4. Aggregation Structure: Use GROUP BY to group records by author_id and HAVING to ensure that each author has published in both 'NAACL' and 'ACL' in 2009.",1.0
968,Count the number of papers published by Columbia University in 2009.,NON-NESTED,aan_1,"[Affiliation.name, Paper.year, Paper.paper_id = Author_list.paper_id, Author_list.affiliation_id = Affiliation.affiliation_id, Columbia University, 2009]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Paper.paper_id) FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id JOIN Affiliation ON Author_list.affiliation_id = Affiliation.affiliation_id WHERE Paper.year = 2009 AND Affiliation.name = 'Columbia University';,"SELECT count(DISTINCT T1.paper_id) FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T3.name LIKE ""Columbia University"" AND T1.year  =  2009","1. Sequential Structure: Start with the SELECT clause to count the number of papers published. Use COUNT on ""Paper.paper_id"" to get the total number of papers. 2. Condition Structure: Use a WHERE clause to filter for papers published in the year 2009 and by authors affiliated with ""Columbia University."" 3. Join Structure: Use JOINs to connect the ""Paper"" table with ""Author_list"" on ""Paper.paper_id"" and then connect ""Author_list"" with ""Affiliation"" on ""Author_list.affiliation_id"" to link papers with their respective affiliations. 4. Aggregation Structure: Use COUNT to aggregate the total number of papers that meet the specified conditions.",0.0
969,How many sailors whose name starts with letter D exist ?,EASY,boat_1,[Sailors.name],"Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT COUNT(*) FROM Sailors WHERE Sailors.name LIKE 'D%';,select count(*) from sailors where name like 'd%',"1. Sequential Structure: Start with the SELECT clause to count the number of sailors whose names start with the letter 'D'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter sailor names that start with 'D'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Sailors"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of sailors meeting the condition.",1.0
970,Find the model of the most expensive headphone.,EASY,headphone_store,"[headphone.Model, headphone.Price]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT headphone.Model FROM headphone ORDER BY headphone.Price DESC LIMIT 1;,SELECT model FROM headphone ORDER BY price DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""headphone.Model"" of the most expensive headphone. 2. Condition Structure: No specific filtering condition is needed since we are looking for the headphone with the highest price. 3. Join Structure: No JOIN is required, as all necessary information is in the ""headphone"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""headphone.Price"" to rank headphones by price and apply LIMIT 1 to select the most expensive headphone.",1.0
971,List all venues and years for papers ordered by year.,EASY,aan_1,"[Paper.venue, Paper.year]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.venue, Paper.year FROM Paper ORDER BY Paper.year ASC;","SELECT DISTINCT venue ,  YEAR FROM paper ORDER BY YEAR","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""Paper.venue"" and ""Paper.year"". 2. Condition Structure: No specific filtering condition is required as the query asks for all venues and years. 3. Join Structure: No JOIN is required since all necessary data is within the ""Paper"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves and orders the data. 5. Ordering Structure: Use ORDER BY on ""Paper.year"" to sort the results by year in ascending order.",1.0
972,How many headphones are stored in the Woodman store?,NON-NESTED,headphone_store,"[store.Name,stock.Quantity,store.Store_ID = stock.Store_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT SUM(stock.Quantity) FROM store JOIN stock ON store.Store_ID = stock.Store_ID WHERE store.Name = 'Woodman' AND stock.Product = 'headphones';,SELECT sum(t2.quantity) FROM store AS t1 JOIN stock AS t2 ON t1.store_id  =  t2.store_id WHERE t1.name  =  'Woodman',"1. Sequential Structure: Start with the SELECT clause to retrieve the total quantity of headphones stored in the Woodman store. Use SUM on ""stock.Quantity"" to calculate the total. 2. Condition Structure: Use a WHERE clause to filter for the store named ""Woodman"" and the product type ""headphones."" 3. Join Structure: Use a JOIN between the ""store"" and ""stock"" tables based on the ""Store_ID"" field to link the store information with the stock details. 4. Aggregation Structure: Use SUM to aggregate the quantity of headphones for the specified store.",0.0
973,What are the different conference names?,EASY,conference,[conference.Conference_Name],"Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT DISTINCT conference.Conference_Name FROM conference;,SELECT DISTINCT conference_name FROM conference,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct conference names. 2. Condition Structure: No specific filtering condition is required as we want all unique conference names. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""conference"" table. 4. Aggregation Structure: Use DISTINCT to ensure only unique conference names are retrieved.",1.0
974,What is the name of the affiliation which publishes the greatest number of papers among those whose address contains 'China'.,NESTED,aan_1,"[Affiliation.name, Affiliation.address, Author_list.affiliation_id = Affiliation.affiliation_id, Author_list.paper_id = Paper.paper_id, Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Affiliation.name FROM Affiliation JOIN Author_list ON Affiliation.affiliation_id = Author_list.affiliation_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Affiliation.address LIKE '%China%' GROUP BY Affiliation.name ORDER BY COUNT(Paper.paper_id) DESC LIMIT 1;,"SELECT T1.name FROM Affiliation AS T1 JOIN Author_list AS T2 ON T1.affiliation_id  =  T2.affiliation_id WHERE T1.address LIKE ""%China%"" GROUP BY T1.affiliation_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the name of the affiliation. Use the FROM clause to specify the Affiliation table and JOIN it with the Author_list and Paper tables to connect affiliations with the papers they publish. Apply a WHERE clause to filter affiliations whose address contains 'China'. Use GROUP BY to group records by affiliation name and COUNT to calculate the number of papers published by each affiliation. Finally, use ORDER BY in descending order of the count and LIMIT 1 to get the affiliation with the greatest number of papers. 2. Condition Structure: Use the WHERE clause to filter affiliations whose address contains 'China'. 3. Join Structure: Use INNER JOINs between the Affiliation, Author_list, and Paper tables based on their respective keys to connect affiliations with the papers they publish. 4. Aggregation Structure: Use COUNT to calculate the number of papers published by each affiliation and ORDER BY to sort the results in descending order. Use LIMIT 1 to retrieve the top result.",1.0
975,What is the first name and last name of the student living furthest to Linda Smith?,NON-NESTED,address_1,"[Student.Fname, Student.LName, Student.city_code = City.city_code, City.city_code = Direct_distance.city1_code, City.city_code = Direct_distance.city2_code, Direct_distance.distance, City.city_name, Student.Fname = 'Linda', Student.LName = 'Smith']","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT S.Fname, S.LName FROM Student AS S JOIN City AS C ON S.city_code = C.city_code JOIN Direct_distance AS D ON C.city_code = D.city1_code OR C.city_code = D.city2_code WHERE D.city1_code = (SELECT C1.city_code FROM Student AS S1 JOIN City AS C1 ON S1.city_code = C1.city_code WHERE S1.Fname = 'Linda' AND S1.LName = 'Smith') OR D.city2_code = (SELECT C1.city_code FROM Student AS S1 JOIN City AS C1 ON S1.city_code = C1.city_code WHERE S1.Fname = 'Linda' AND S1.LName = 'Smith') ORDER BY D.distance DESC LIMIT 1;","SELECT T3.Fname ,  T3.Lname FROM Direct_distance AS T1 JOIN Student AS T2 ON T1.city1_code  =  T2.city_code JOIN Student AS T3 ON T1.city2_code  =  T3.city_code WHERE T2.Fname  =  ""Linda"" AND T2.Lname  =  ""Smith"" ORDER BY distance DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the first name (""Student.Fname"") and last name (""Student.LName"") of the student living furthest from Linda Smith. Use a subquery to identify Linda Smith's city code. 2. Condition Structure: Use a WHERE clause to filter students based on their city code and calculate the distance from Linda Smith's city. Use ORDER BY to sort the distances in descending order and LIMIT 1 to get the student living furthest away. 3. Join Structure: Use JOINs to connect the ""Student"" table with the ""City"" table on ""Student.city_code = City.city_code"" and the ""Direct_distance"" table on ""City.city_code = Direct_distance.city1_code"" or ""Direct_distance.city2_code"" to calculate distances. 4. Aggregation Structure: No aggregation is needed, but the maximum distance is determined using ORDER BY and LIMIT 1.",0.0
976,Show ids for all male students living outside of USA.,NON-NESTED,address_1,"[Student.StuID, Student.Sex, Student.city_code = City.city_code, City.country, USA]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Student.StuID FROM Student JOIN City ON Student.city_code = City.city_code WHERE Student.Sex = 'Male' AND City.country != 'USA';,"SELECT StuID FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE T2.sex  =  'M' AND T1.country != ""USA""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student.StuID"" for all male students living outside of the USA. 2. Condition Structure: Use a WHERE clause to filter for students whose ""Student.Sex"" is 'Male' and whose ""City.country"" is not 'USA.' 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the ""Student.city_code"" and ""City.city_code"" to associate each student with their respective city and country. 4. Aggregation Structure: No aggregation is needed as the query only retrieves individual student IDs.",0.0
977,List all distinct conference names.,EASY,conference,[conference.Conference_Name],"Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT DISTINCT conference.Conference_Name FROM conference;,SELECT DISTINCT conference_name FROM conference,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct conference names. 2. Condition Structure: No specific filtering condition is required as we want all distinct conference names. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""conference"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique conference names are retrieved.",1.0
978,Give the average distance between Boston and other cities.,NON-NESTED,address_1,"[City.city_name,Direct_distance.city1_code,Direct_distance.city2_code,Direct_distance.distance,Direct_distance.city1_code = City.city_code,Direct_distance.city2_code = City.city_code,Boston]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT AVG(Direct_distance.distance) FROM Direct_distance JOIN City AS City1 ON Direct_distance.city1_code = City1.city_code JOIN City AS City2 ON Direct_distance.city2_code = City2.city_code WHERE City1.city_name = 'Boston' OR City2.city_name = 'Boston';,"SELECT avg(distance) FROM Direct_distance AS T1 JOIN City AS T2 ON T1.city1_code  =  T2.city_code WHERE T2.city_name  =  ""Boston""","1. Sequential Structure: Start with the SELECT clause to calculate the average distance. Use the AVG function on the ""Direct_distance.distance"" field. 2. Condition Structure: Use a WHERE clause to filter for distances where one of the cities is ""Boston."" This requires matching ""City.city_name"" to ""Boston"" and ensuring the city codes in ""Direct_distance"" correspond to ""Boston"" and other cities. 3. Join Structure: Use JOINs to connect the ""City"" table with the ""Direct_distance"" table twice, once for ""Direct_distance.city1_code"" and once for ""Direct_distance.city2_code,"" to retrieve the city names for both city codes. 4. Aggregation Structure: Use AVG to compute the average distance for all records that meet the condition.",1.0
979,What is highest rating between sailors?,EASY,boat_1,[Sailors.rating],"Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT MAX(Sailors.rating) AS highest_rating FROM Sailors;,SELECT max(rating) FROM Sailors,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the highest rating among sailors. 2. Aggregation Structure: Use the MAX function to calculate the highest rating from the ""Sailors.rating"" field. 3. Condition Structure: No specific filtering condition is required, as we are looking for the maximum rating across all sailors. 4. Join Structure: No JOIN is required since all necessary data is within the ""Sailors"" table.",1.0
980,How many institutions were founded between 1850 and 1900?,EASY,conference,"[institution.Founded,institution.Institution_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT COUNT(institution.Institution_ID) FROM institution WHERE institution.Founded BETWEEN 1850 AND 1900;,SELECT count(*) FROM institution WHERE founded BETWEEN 1850 AND 1900,"1. Sequential Structure: Start with the SELECT clause to count the number of institutions. 2. Condition Structure: Use a WHERE clause to filter institutions that were founded between 1850 and 1900. 3. Join Structure: No JOIN is required since all necessary information is in the ""institution"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of institutions that meet the specified condition.",1.0
981,What are the names and ids of all sailors who do not have boat reservations?,NESTED,boat_1,"[Sailors.sid, Sailors.name, Reserves.sid = Sailors.sid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.name, Sailors.sid FROM Sailors WHERE Sailors.sid NOT IN (SELECT Reserves.sid FROM Reserves);","SELECT sid ,  name FROM Sailors EXCEPT SELECT T1.sid ,  T1.name FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid","1. Sequential Structure: Start with the SELECT clause to retrieve the names and IDs of sailors. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors who do not have any boat reservations. 2. Condition Structure: Use the WHERE clause with a subquery to exclude sailors whose IDs appear in the Reserves table, indicating they have made reservations. 3. Join Structure: Not required, as we only need to filter based on the absence of matching IDs in the Reserves table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
982,How many papers are published in each venue in each year?,EASY,aan_1,"[Paper.venue, Paper.year, Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.venue, Paper.year, COUNT(Paper.paper_id) AS paper_count FROM Paper GROUP BY Paper.venue, Paper.year;","SELECT count(*) ,  venue ,  YEAR FROM Paper GROUP BY venue ,  YEAR","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the venue, year, and the count of papers. 2. Aggregation Structure: Use COUNT to calculate the number of papers published. 3. Grouping Structure: Use GROUP BY on ""Paper.venue"" and ""Paper.year"" to count papers for each venue in each year. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paper"" table.",1.0
983,What are the different names of sailors who reserved two or more boats ?,NON-NESTED,boat_1,"[Sailors.name, Reserves.sid, Reserves.bid, Reserves.sid = Sailors.sid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT DISTINCT Sailors.name FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid GROUP BY Reserves.sid HAVING COUNT(Reserves.bid) >= 2;,"select distinct t1.name ,  t1.sid from sailors as t1 join reserves as t2 on t1.sid  =  t2.sid group by t2.sid having count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of sailors. Use GROUP BY on ""Reserves.sid"" to group reservations by sailor. 2. Condition Structure: Apply a HAVING clause to filter sailors who reserved two or more boats. This is achieved by counting the distinct ""Reserves.bid"" for each sailor and ensuring the count is greater than or equal to 2. 3. Join Structure: Use a JOIN between the ""Sailors"" and ""Reserves"" tables based on ""Sailors.sid = Reserves.sid"" to associate sailors with their reservations. 4. Aggregation Structure: Use COUNT on ""Reserves.bid"" to count the number of boats reserved by each sailor.",0.0
984,How many papers do we have?,EASY,aan_1,[Paper.paper_id],"Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Paper.paper_id) AS total_papers FROM Paper;,SELECT count(*) FROM Paper,"1. Sequential Structure: Start with the SELECT clause to count the total number of papers. 2. Aggregation Structure: Use the COUNT function on the ""Paper.paper_id"" field to calculate the total number of papers. 3. Condition Structure: No specific filtering condition is required as we want the total count of all papers. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paper"" table.",1.0
985,Find the total quantity of headphones stored in the Woodman store.,NON-NESTED,headphone_store,"[store.Name,stock.Quantity,store.Store_ID = stock.Store_ID,stock.Headphone_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT SUM(stock.Quantity) FROM store JOIN stock ON store.Store_ID = stock.Store_ID WHERE store.Name = 'Woodman';,SELECT sum(t2.quantity) FROM store AS t1 JOIN stock AS t2 ON t1.store_id  =  t2.store_id WHERE t1.name  =  'Woodman',"1. Sequential Structure: Start with the SELECT clause to retrieve the total quantity of headphones. Use the SUM function on ""stock.Quantity"" to calculate the total quantity. 2. Condition Structure: Use a WHERE clause to filter for the store named ""Woodman."" 3. Join Structure: Use a JOIN between the ""store"" and ""stock"" tables based on the ""Store_ID"" field to link the store with its stock records. 4. Aggregation Structure: Use SUM to aggregate the quantity of headphones for the specified store.",1.0
986,How many reservations for each boat did the sailors with an id greater than 1 make?,NON-NESTED,boat_1,"[Sailors.sid,Reserves.sid,Reserves.bid,Boats.bid,Reserves.day,Sailors.sid > 1]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Reserves.bid, COUNT(Reserves.sid) AS reservation_count FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid WHERE Sailors.sid > 1 GROUP BY Reserves.bid;","SELECT bid ,  count(*) FROM Reserves WHERE sid  >  1 GROUP BY bid","1. Sequential Structure: Start with the SELECT clause to retrieve the boat ID (""Reserves.bid"") and the count of reservations made for each boat. Use COUNT to count the number of reservations for each boat. 2. Condition Structure: Apply a WHERE clause to filter for sailors with an ID greater than 1 (""Sailors.sid > 1""). 3. Join Structure: Use JOIN to connect the ""Sailors"" table with the ""Reserves"" table based on ""Sailors.sid = Reserves.sid"" to associate sailors with their reservations. 4. Aggregation Structure: Use GROUP BY on ""Reserves.bid"" to group the results by each boat ID and count the number of reservations for each boat.",1.0
987,List names of all authors who have only 1 paper.,NESTED,aan_1,"[Author.name, Author.author_id, Author_list.author_id, Author_list.paper_id, Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Author.name FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id GROUP BY Author.author_id, Author.name HAVING COUNT(Author_list.paper_id) = 1;",SELECT T1.name FROM Author AS T1 JOIN Author_list AS T2 ON T1.author_id  =  T2.author_id GROUP BY T1.author_id HAVING count(*)  =  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors. Use the FROM clause to specify the Author table. Join it with the Author_list table to link authors with their papers. Use GROUP BY to group records by author_id, allowing us to count the number of papers for each author. Apply a HAVING clause to filter authors who have only one paper. 2. Condition Structure: Use the HAVING clause with COUNT(paper_id) to filter for authors who are associated with exactly one paper. 3. Join Structure: Use an INNER JOIN between the Author and Author_list tables based on author_id to connect authors with their papers. 4. Aggregation Structure: Use COUNT(paper_id) within the HAVING clause to count the number of papers per author and filter for authors with only one paper.",1.0
988,Count the number of papers Columbia University had during or prior to 2009 .,NON-NESTED,aan_1,"[Affiliation.name, Author_list.affiliation_id = Affiliation.affiliation_id, Author_list.paper_id = Paper.paper_id, Paper.year, Columbia University, 2009]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Paper.paper_id) FROM Affiliation JOIN Author_list ON Affiliation.affiliation_id = Author_list.affiliation_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Affiliation.name = 'Columbia University' AND Paper.year <= 2009;,"select count(distinct t1.paper_id) from paper as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id join affiliation as t3 on t2.affiliation_id  =  t3.affiliation_id where t1.year  <=  2009 and t3.name = ""columbia university""","1. Sequential Structure: Start with the SELECT clause to count the number of papers. Use COUNT on ""Paper.paper_id"" to get the total number of papers. 2. Condition Structure: Use a WHERE clause to filter for papers published during or prior to the year 2009 and where the affiliation name is ""Columbia University."" 3. Join Structure: Use JOINs to connect the ""Affiliation"" table with the ""Author_list"" table on ""affiliation_id"" and the ""Author_list"" table with the ""Paper"" table on ""paper_id"" to link papers with their respective affiliations. 4. Aggregation Structure: Use COUNT to aggregate the total number of papers that meet the specified conditions.",0.0
989,"List all conference name, year, and location.",EASY,conference,"[conference.Conference_Name, conference.Year, conference.Location]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT conference.Conference_Name, conference.Year, conference.Location FROM conference;","SELECT conference_name ,  YEAR ,  LOCATION FROM conference","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""conference.Conference_Name,"" ""conference.Year,"" and ""conference.Location."" 2. Condition Structure: No specific filtering condition is required as the query asks for all conferences. 3. Join Structure: No JOIN is required since all necessary information is available in the ""conference"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all records from the ""conference"" table.",1.0
990,Find the average rating and largest age for the sailors,EASY,boat_1,"[Sailors.rating, Sailors.age]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT AVG(Sailors.rating) AS avg_rating, MAX(Sailors.age) AS max_age FROM Sailors;","SELECT AVG(rating) ,  MAX(age) FROM Sailors","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average rating and the largest age. 2. Aggregation Structure: Use AVG to calculate the average rating and MAX to determine the largest age among the sailors. 3. Grouping Structure: No GROUP BY is needed since the query asks for overall aggregate values for all sailors. 4. Join Structure: No JOIN is required as all necessary data is within the ""Sailors"" table.",1.0
991,Find the id of Sailors (sid) that reserved red and blue boat.,NESTED,boat_1,"[Sailors.sid, Reserves.sid, Reserves.bid, Boats.bid, Boats.color, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, red, blue]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT DISTINCT s1.sid FROM Reserves r1 JOIN Boats b1 ON r1.bid = b1.bid JOIN Sailors s1 ON r1.sid = s1.sid WHERE b1.color = 'red' AND s1.sid IN ( SELECT r2.sid FROM Reserves r2 JOIN Boats b2 ON r2.bid = b2.bid WHERE b2.color = 'blue' );,"SELECT DISTINCT T2.sid FROM Boats AS T1 JOIN Reserves AS T2 ON  T1.bid  =  T2.bid WHERE T1.color  =  'red' INTERSECT SELECT DISTINCT T2.sid FROM Boats AS T1 JOIN Reserves AS T2 ON  T1.bid  =  T2.bid WHERE T1.color  =  ""blue""","1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of sailors (sid). Use the FROM clause to specify the Sailors, Reserves, and Boats tables. Apply a WHERE clause to filter for boats with colors 'red' and 'blue' that have been reserved by the same sailor. 2. Condition Structure: Use the WHERE clause to filter for boats with colors 'red' and 'blue'. Use a subquery to ensure that the sailor has reserved both a red and a blue boat. 3. Join Structure: Use INNER JOINs between the Sailors, Reserves, and Boats tables. Join Sailors and Reserves on sid, and Reserves and Boats on bid to connect sailors with the boats they reserved. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
992,How many headphones cost more than 200 for each headphone class?,EASY,headphone_store,"[headphone.Class, headphone.Price]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Class, COUNT(*) AS headphone_count FROM headphone WHERE headphone.Price > 200 GROUP BY headphone.Class;","SELECT count(*) ,  CLASS FROM headphone WHERE price  >  200 GROUP BY CLASS","1. Sequential Structure: Begin with the SELECT clause to specify the headphone class and the count of headphones that cost more than 200. 2. Condition Structure: Use a WHERE clause to filter headphones with a price greater than 200. 3. Grouping Structure: Use GROUP BY on ""headphone.Class"" to count the number of headphones for each class. 4. Aggregation Structure: Use COUNT to calculate the number of headphones in each class that meet the price condition. 5. Join Structure: No JOIN is required since all necessary data is within the ""headphone"" table.",1.0
993,How many boats are there?,EASY,boat_1,[Boats.bid],"Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT COUNT(Boats.bid) AS total_boats FROM Boats;,SELECT count(*) FROM Boats,"1. Sequential Structure: Start with the SELECT clause to count the number of boats. 2. Aggregation Structure: Use the COUNT function to calculate the total number of boats. 3. Join Structure: No JOIN is required since all necessary data is within the ""Boats"" table. 4. Condition Structure: No specific filtering condition is needed as we are counting all boats.",1.0
994,Who reserved boat 102?,NON-NESTED,boat_1,"[Reserves.sid,Reserves.bid,Sailors.sid,Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid,102]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Sailors.name FROM Reserves JOIN Sailors ON Reserves.sid = Sailors.sid WHERE Reserves.bid = 102;,SELECT T1.name FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid WHERE T2.bid  =  102,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the sailor who reserved the boat. The ""Sailors.name"" field is required. 2. Condition Structure: Use a WHERE clause to filter for reservations where the boat ID (""Reserves.bid"") is 102. 3. Join Structure: Use JOINs to connect the ""Reserves"" table with the ""Sailors"" table on ""Reserves.sid = Sailors.sid"" to associate reservations with sailor details. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific details for a single boat reservation.",1.0
995,What are the ids of sailors who have not reserved a boat?,NESTED,boat_1,"[Sailors.sid, Reserves.sid, Sailors.sid = Reserves.sid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT sid FROM Sailors WHERE sid NOT IN (SELECT sid FROM Reserves);,SELECT sid FROM Sailors EXCEPT SELECT sid FROM Reserves,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of sailors. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors who have not reserved a boat by ensuring their IDs are not present in the Reserves table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude sailors whose IDs appear in the Reserves table, meaning they have made a reservation. 3. Join Structure: Not required, as we only need to filter based on the absence of matching IDs in the Reserves table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
996,What are the ids of all boats that are reserved by someone?,NON-NESTED,boat_1,"[Reserves.bid, Boats.bid, Reserves.bid = Boats.bid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT DISTINCT Boats.bid FROM Reserves JOIN Boats ON Reserves.bid = Boats.bid;,SELECT DISTINCT bid FROM Reserves,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Boats.bid"" values, as we are interested in the IDs of boats that are reserved. 2. Condition Structure: No specific filtering condition is required, as we are looking for all boats that have been reserved. 3. Join Structure: Use an INNER JOIN between the ""Reserves"" and ""Boats"" tables on the ""bid"" field to link reservations with boats. 4. Aggregation Structure: Use DISTINCT to ensure that each boat ID is listed only once.",1.0
997,What is the title of the paper which cites the most other papers?,NON-NESTED,aan_1,"[Paper.title, Citation.paper_id, Citation.cited_paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Paper.title FROM Citation JOIN Paper ON Citation.paper_id = Paper.paper_id GROUP BY Paper.paper_id ORDER BY COUNT(Citation.cited_paper_id) DESC LIMIT 1;,SELECT T2.title FROM Citation AS T1 JOIN Paper AS T2 ON T2.paper_id  =  T1.paper_id GROUP BY T1.paper_id ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paper.title"" of the paper that cites the most other papers. Use COUNT to count the number of citations for each paper. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the paper with the highest number of citations. 3. Join Structure: Use a JOIN between the ""Citation"" table and the ""Paper"" table on ""Citation.paper_id = Paper.paper_id"" to link each citation to its corresponding paper. 4. Aggregation Structure: Use COUNT on ""Citation.cited_paper_id"" to count the number of citations for each paper. Use ORDER BY in descending order to rank papers by the number of citations, and LIMIT 1 to select the paper with the most citations.",1.0
998,What is the name of the city furthest to Boston?,NON-NESTED,address_1,"[City.city_name,City.city_code,Direct_distance.city1_code,Direct_distance.city2_code,Direct_distance.distance,Direct_distance.city1_code = City.city_code,Boston]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.city_name FROM City JOIN Direct_distance ON City.city_code = Direct_distance.city2_code WHERE Direct_distance.city1_code = (SELECT city_code FROM City WHERE city_name = 'Boston') ORDER BY Direct_distance.distance DESC LIMIT 1;,"SELECT T3.city_name FROM Direct_distance AS T1 JOIN City AS T2 ON T1.city1_code  =  T2.city_code JOIN City AS T3 ON T1.city2_code  =  T3.city_code WHERE T2.city_name  =  ""Boston"" ORDER BY distance DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.city_name"" of the city furthest from Boston. Use the MAX function to find the maximum distance. 2. Condition Structure: Use a WHERE clause to filter for distances involving Boston. This requires matching ""Direct_distance.city1_code"" or ""Direct_distance.city2_code"" with the city code of Boston. 3. Join Structure: Use a JOIN between the ""City"" table and the ""Direct_distance"" table to link city codes with their names. Specifically, join ""Direct_distance.city1_code"" or ""Direct_distance.city2_code"" with ""City.city_code."" 4. Aggregation Structure: Use MAX on ""Direct_distance.distance"" to find the furthest distance, and retrieve the corresponding city name.",1.0
999,How many institution are founded between 1850 and 1900?,EASY,conference,"[institution.Founded, institution.Institution_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT COUNT(institution.Institution_ID) FROM institution WHERE institution.Founded BETWEEN 1850 AND 1900;,SELECT count(*) FROM institution WHERE founded BETWEEN 1850 AND 1900,"1. Sequential Structure: Start with the SELECT clause to count the number of institutions. 2. Condition Structure: Use a WHERE clause to filter institutions founded between 1850 and 1900. 3. Join Structure: No JOIN is required since all necessary information is in the ""institution"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of institutions that meet the specified condition.",1.0
1000,What is the name and age of every sailor who is younger than age 30?,EASY,boat_1,"[Sailors.name, Sailors.age]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.name, Sailors.age FROM Sailors WHERE Sailors.age < 30;","SELECT name ,  age FROM Sailors WHERE age  <  30","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the sailor's name and age. 2. Condition Structure: Use a WHERE clause to filter sailors who are younger than 30 years old. 3. Join Structure: No JOIN is required since all necessary data is within the ""Sailors"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the name and age of sailors who meet the specified condition.",1.0
1001,Give the city name of the city with greatest distance from Boston.,NON-NESTED,address_1,"[City.city_name,City.city_code,Direct_distance.city2_code,Direct_distance.city1_code,Direct_distance.distance,Direct_distance.city1_code = City.city_code,Boston]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.city_name FROM City JOIN Direct_distance ON City.city_code = Direct_distance.city2_code WHERE Direct_distance.city1_code = 'Boston' ORDER BY Direct_distance.distance DESC LIMIT 1;,"SELECT T3.city_name FROM Direct_distance AS T1 JOIN City AS T2 ON T1.city1_code  =  T2.city_code JOIN City AS T3 ON T1.city2_code  =  T3.city_code WHERE T2.city_name  =  ""Boston"" ORDER BY distance DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.city_name"" of the city with the greatest distance from Boston. 2. Condition Structure: Use a WHERE clause to filter for records where ""Direct_distance.city1_code"" corresponds to Boston's city code. 3. Join Structure: Use a JOIN between the ""City"" table and the ""Direct_distance"" table on ""City.city_code"" and ""Direct_distance.city2_code"" to link each city with its distance from Boston. 4. Aggregation Structure: Use ORDER BY in descending order on ""Direct_distance.distance"" to rank cities by distance from Boston, and use LIMIT 1 to select the city with the greatest distance.",0.0
1002,What year had the fewest conferences?,EASY,conference,[conference.Year],"Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT conference.Year FROM conference GROUP BY conference.Year ORDER BY COUNT(*) ASC LIMIT 1;,SELECT YEAR FROM conference GROUP BY YEAR ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the year, as the question asks for the year with the fewest conferences. 2. Aggregation Structure: Use COUNT to calculate the number of conferences for each year. 3. Grouping Structure: Use GROUP BY on ""conference.Year"" to group the data by year. 4. Ordering Structure: Use ORDER BY in ascending order on the count of conferences to rank years by the number of conferences. 5. Limiting Structure: Use LIMIT 1 to retrieve the year with the fewest conferences. 6. Join Structure: No JOIN is required since all necessary data is within the ""conference"" table.",1.0
1003,how many sailors in total?,EASY,boat_1,[Sailors.sid],"Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT COUNT(Sailors.sid) AS total_sailors FROM Sailors;,SELECT COUNT(*) FROM Sailors,"1. Sequential Structure: Begin with the SELECT clause to count the total number of sailors. 2. Aggregation Structure: Use the COUNT function to calculate the total number of sailors based on their unique IDs (""Sailors.sid""). 3. Join Structure: No JOIN is required since all necessary data is within the ""Sailors"" table. 4. Condition Structure: No specific filtering condition is needed as we are counting all sailors.",1.0
1004,Give the id and the number of citations of the most cited paper.,NESTED,aan_1,"[Citation.paper_id, COUNT(Citation.cited_paper_id), Citation.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Citation.paper_id, COUNT(Citation.cited_paper_id) AS num_citations FROM Citation GROUP BY Citation.paper_id ORDER BY num_citations DESC LIMIT 1;","SELECT paper_id ,  count(*) FROM Citation GROUP BY cited_paper_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the paper ID and the count of citations. Use the FROM clause to specify the Citation table. Apply GROUP BY on paper_id to count the number of citations for each paper. Use ORDER BY to sort the papers by the number of citations in descending order and LIMIT to retrieve the most cited paper. 2. Condition Structure: No specific filtering condition is required, as we are interested in the paper with the highest citation count. 3. Join Structure: Not required, as all necessary data is available in the Citation table. 4. Aggregation Structure: Use COUNT to calculate the number of citations for each paper and ORDER BY to sort by the count in descending order.",0.0
1005,Which headphone class contains the most headphones?,NON-NESTED,headphone_store,"[headphone.Class, stock.Headphone_ID, stock.Quantity, stock.Headphone_ID = headphone.Headphone_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Class, SUM(stock.Quantity) AS Total_Quantity FROM headphone JOIN stock ON headphone.Headphone_ID = stock.Headphone_ID GROUP BY headphone.Class ORDER BY Total_Quantity DESC LIMIT 1;",SELECT CLASS FROM headphone GROUP BY CLASS ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""headphone.Class"" and the total quantity of headphones in each class. Use an aggregate function (SUM) on ""stock.Quantity"" to calculate the total number of headphones for each class. 2. Condition Structure: No specific filtering condition is required, as we are interested in all headphone classes. 3. Join Structure: Use a JOIN between the ""headphone"" and ""stock"" tables based on the shared key ""headphone.Headphone_ID = stock.Headphone_ID"" to link each headphone with its stock information. 4. Aggregation Structure: Use GROUP BY on ""headphone.Class"" to group the results by headphone class. Use ORDER BY in descending order on the total quantity (SUM(stock.Quantity)) to rank the classes by the number of headphones. Use LIMIT 1 to select the class with the most headphones.",1.0
1006,What is the different id of every sailor who is not the youngest?,NESTED,boat_1,"[Sailors.sid, Sailors.age]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT DISTINCT sid FROM Sailors WHERE age > (SELECT MIN(age) FROM Sailors);,SELECT DISTINCT sid FROM Sailors WHERE age  >  (SELECT min(age) FROM Sailors);,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct sailor IDs. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter out the youngest sailor(s) based on their age. 2. Condition Structure: Use the WHERE clause with a subquery to exclude sailors whose age is equal to the minimum age in the Sailors table. 3. Join Structure: Not required, as all data is from the Sailors table. 4. Aggregation Structure: Use the MIN function in a subquery to find the youngest age, which is then used in the filtering condition.",1.0
1007,What is the name of the sailor who reserved boat 102?,NON-NESTED,boat_1,"[Sailors.name, Reserves.sid, Reserves.bid, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, Boats.bid, 102]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Sailors.name FROM Sailors JOIN Reserves ON Reserves.sid = Sailors.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Reserves.bid = 102;,SELECT T1.name FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid WHERE T2.bid  =  102,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.name"" of the sailor who reserved the specified boat. 2. Condition Structure: Use a WHERE clause to filter for records where ""Reserves.bid"" equals 102. 3. Join Structure: Use JOINs to connect the ""Sailors"" table with the ""Reserves"" table on ""Reserves.sid = Sailors.sid"" and the ""Reserves"" table with the ""Boats"" table on ""Reserves.bid = Boats.bid"" to link sailors, reservations, and boats. 4. Aggregation Structure: No aggregation is needed as we are retrieving a specific sailor's name.",1.0
1008,find the number of stores in each neighborhood.,EASY,headphone_store,"[store.Neighborhood, store.Store_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT store.Neighborhood, COUNT(store.Store_ID) AS store_count FROM store GROUP BY store.Neighborhood;","SELECT count(*) ,  neighborhood FROM store GROUP BY neighborhood","1. Sequential Structure: Begin with the SELECT clause to specify the neighborhood and the count of stores. 2. Aggregation Structure: Use COUNT to calculate the number of stores in each neighborhood. 3. Grouping Structure: Use GROUP BY on ""store.Neighborhood"" to group the results by each neighborhood. 4. Join Structure: No JOIN is required since all necessary data is within the ""store"" table.",1.0
1009,"What are the titles and paper ids co-authored by Mckeown, Kathleen and Rambow, Owen?",NON-NESTED,aan_1,"[Author.name, Author.author_id, Author_list.author_id = Author.author_id, Author_list.paper_id, Paper.paper_id = Author_list.paper_id, Paper.title, Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.title, Paper.paper_id FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Author.name IN ('Mckeown, Kathleen', 'Rambow, Owen') GROUP BY Paper.paper_id HAVING COUNT(DISTINCT Author.name) = 2;","SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id WHERE T3.name LIKE ""%Mckeown ,  Kathleen%"" INTERSECT SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id WHERE T3.name LIKE ""%Rambow ,  Owen%""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Paper.title"" and ""Paper.paper_id."" 2. Condition Structure: Use a WHERE clause to filter for papers co-authored by both ""Mckeown, Kathleen"" and ""Rambow, Owen."" This requires identifying papers associated with both authors. 3. Join Structure: Use JOINs to connect the ""Author"" table with the ""Author_list"" table on ""Author.author_id,"" and then connect the ""Author_list"" table with the ""Paper"" table on ""Author_list.paper_id."" This links authors to their respective papers. 4. Aggregation Structure: Use GROUP BY on ""Paper.paper_id"" to group results by paper, and apply a HAVING clause to ensure that only papers with both authors are included. Use COUNT(DISTINCT Author.name) to verify the presence of both authors.",1.0
1010,Find the names of authors who published some paper on NAACL and ACL in the year 2009.,NESTED,aan_1,"[Author.name, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Paper.venue, Paper.year, NAACL, ACL, 2009]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT DISTINCT Author.name FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Paper.year = 2009 AND Paper.venue = 'NAACL' AND EXISTS ( SELECT 1 FROM Author_list AS al2 JOIN Paper AS p2 ON al2.paper_id = p2.paper_id WHERE al2.author_id = Author.author_id AND p2.venue = 'ACL' AND p2.year = 2009 );,"SELECT name FROM Author WHERE author_id IN (SELECT T1.author_id FROM Author_list AS T1 JOIN Paper AS T2 ON T1.paper_id  =  T2.paper_id WHERE T2.venue  =  ""ACL"" AND T2.year  =  2009 INTERSECT SELECT T1.author_id FROM Author_list AS T1 JOIN Paper AS T2 ON T1.paper_id  =  T2.paper_id WHERE T2.venue  =  ""NAACL"" AND T2.year  =  2009)","1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors. Use the FROM clause to specify the Author table and JOIN it with the Author_list table to link authors with their papers. Further, JOIN the Author_list table with the Paper table to access paper details. Apply a WHERE clause to filter papers published in the venues 'NAACL' and 'ACL' in the year 2009. 2. Condition Structure: Use the WHERE clause to filter for papers published in the venues 'NAACL' and 'ACL' in the year 2009. Use an EXISTS clause to ensure that the author has published papers in both venues. 3. Join Structure: Use INNER JOINs between the Author, Author_list, and Paper tables based on their respective keys (author_id and paper_id) to connect authors with their papers and venues. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1011,What are the titles and paper ids for papers written in affiliation with Harvard University?,NON-NESTED,aan_1,"[Paper.title, Paper.paper_id, Author_list.affiliation_id = Affiliation.affiliation_id, Author_list.paper_id = Paper.paper_id, Affiliation.name, Harvard University]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.title, Paper.paper_id FROM Paper JOIN Author_list ON Author_list.paper_id = Paper.paper_id JOIN Affiliation ON Author_list.affiliation_id = Affiliation.affiliation_id WHERE Affiliation.name = 'Harvard University';","SELECT DISTINCT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T3.name  =  ""Harvard University""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Paper.title"" and ""Paper.paper_id."" 2. Condition Structure: Use a WHERE clause to filter for records where the ""Affiliation.name"" is ""Harvard University."" 3. Join Structure: Use JOINs to connect ""Paper"" with ""Author_list"" on ""Author_list.paper_id = Paper.paper_id"" and ""Author_list"" with ""Affiliation"" on ""Author_list.affiliation_id = Affiliation.affiliation_id"" to link papers with their affiliations. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without summarization.",1.0
1012,How many papers do we have in NAACL 2000?,EASY,aan_1,"[Paper.title, Paper.year, Paper.venue]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(*) AS paper_count FROM Paper WHERE Paper.venue = 'NAACL' AND Paper.year = 2000;,"SELECT count(*) FROM Paper WHERE venue  =  ""NAACL"" AND YEAR  =  2000","1. Sequential Structure: Begin with the SELECT clause to count the number of papers, as the question asks for the total count. 2. Condition Structure: Use a WHERE clause to filter papers where the ""Paper.venue"" is 'NAACL' and the ""Paper.year"" is 2000. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Paper"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of papers that meet the specified conditions.",1.0
1013,What are the student ids for female students in the state of PA?,NON-NESTED,address_1,"[Student.StuID, Student.Sex, City.state, Student.city_code = City.city_code, PA, female]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Student.StuID FROM Student JOIN City ON Student.city_code = City.city_code WHERE Student.Sex = 'female' AND City.state = 'PA';,"SELECT StuID FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE T1.state  =  ""PA""  AND T2.sex  =  'F'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student.StuID"" for female students in the state of PA. 2. Condition Structure: Use a WHERE clause to filter for students whose ""Student.Sex"" is 'female' and whose ""City.state"" is 'PA'. 3. Join Structure: Use a JOIN between the ""Student"" table and the ""City"" table based on the ""Student.city_code"" and ""City.city_code"" to associate each student with their respective city and state. 4. Aggregation Structure: No aggregation is needed as we are only retrieving specific student IDs.",0.0
1014,How many reservations exist for each boat that has more than 1 reservation already?,NESTED,boat_1,"[Reserves.bid, Boats.bid, Reserves.sid, Reserves.bid = Boats.bid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Reserves.bid, COUNT(*) AS reservation_count FROM Reserves JOIN Boats ON Reserves.bid = Boats.bid GROUP BY Reserves.bid HAVING COUNT(*) > 1;","SELECT bid ,  count(*) FROM Reserves GROUP BY bid HAVING count(*)  >  1","1. Sequential Structure: Start with the SELECT clause to retrieve the boat ID and the count of reservations for each boat. Use the FROM clause to specify the Reserves table and JOIN it with the Boats table to connect reservations with boats. Apply a GROUP BY clause to group reservations by boat ID, and use the HAVING clause to filter boats with more than one reservation. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for boats that have more than one reservation. 3. Join Structure: Use an INNER JOIN between the Reserves and Boats tables based on the boat ID (bid) to link reservations to boats. 4. Aggregation Structure: Use COUNT(*) to calculate the number of reservations for each boat and filter based on this count.",1.0
1015,"How many papers did each author publish, ordered by number of papers?",NON-NESTED,aan_1,"[Author.author_id, Author_list.author_id, Author_list.paper_id, Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Author.author_id, COUNT(Author_list.paper_id) AS paper_count FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id GROUP BY Author.author_id ORDER BY paper_count DESC;","SELECT T1.name ,  count(*) FROM Author AS T1 JOIN Author_list AS T2 ON T1.author_id  =  T2.author_id GROUP BY T1.author_id ORDER BY count(*) DESC","1. Sequential Structure: Start with the SELECT clause to retrieve the ""author_id"" and the count of papers published by each author. Use COUNT on ""Author_list.paper_id"" to count the number of papers for each author. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Author"" and ""Author_list"" tables on ""Author.author_id = Author_list.author_id"" to associate authors with their papers. Additionally, join ""Author_list"" with ""Paper"" on ""Author_list.paper_id = Paper.paper_id"" to ensure the papers are correctly linked. 4. Aggregation Structure: Use GROUP BY on ""Author.author_id"" to group the results by each author. Apply ORDER BY in descending order of the count of papers to sort the results by the number of papers published.",0.0
1016,Find boats reserved by Sailor with id 1.,NON-NESTED,boat_1,"[Reserves.sid, Reserves.bid, Boats.bid, Sailors.sid = Reserves.sid, Reserves.bid = Boats.bid, 1]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Boats.* FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Sailors.sid = 1;,SELECT DISTINCT bid FROM Reserves WHERE sid = 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the details of boats reserved by the sailor. Since the question does not specify which details of the boats are required, we will select all columns from the ""Boats"" table. 2. Condition Structure: Use a WHERE clause to filter for reservations made by the sailor with ""Sailors.sid = 1."" 3. Join Structure: Use JOINs to connect the ""Reserves"" table with the ""Boats"" table based on ""Reserves.bid = Boats.bid"" and to connect the ""Sailors"" table with the ""Reserves"" table based on ""Sailors.sid = Reserves.sid."" 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving specific records without summarization.",1.0
1017,Find the id and name of the sailors who reserved more than one boat.,NON-NESTED,boat_1,"[Sailors.sid,Sailors.name,Reserves.sid,Reserves.bid,Reserves.sid = Sailors.sid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.sid, Sailors.name FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid GROUP BY Reserves.sid HAVING COUNT(Reserves.bid) > 1;","SELECT DISTINCT T1.name ,  T1.sid FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid GROUP BY T2.sid HAVING COUNT(*)  >  1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.sid"" and ""Sailors.name"" of sailors who meet the condition. Use GROUP BY to group the results by ""Reserves.sid"" to count the number of boats reserved by each sailor. 2. Condition Structure: Use a HAVING clause to filter for sailors who reserved more than one boat. This is determined by counting the occurrences of ""Reserves.bid"" for each sailor. 3. Join Structure: Use an INNER JOIN between the ""Sailors"" and ""Reserves"" tables on ""Sailors.sid = Reserves.sid"" to link sailors with their reservations. 4. Aggregation Structure: Use COUNT on ""Reserves.bid"" to count the number of boats reserved by each sailor, and apply the HAVING clause to filter for counts greater than one.",1.0
1018,Which venues and years did Columbia University have papers ?,NON-NESTED,aan_1,"[Affiliation.name, Paper.venue, Paper.year, Author_list.affiliation_id = Affiliation.affiliation_id, Author_list.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT DISTINCT Paper.venue, Paper.year FROM Author_list JOIN Affiliation ON Author_list.affiliation_id = Affiliation.affiliation_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Affiliation.name = 'Columbia University';","select distinct t1.venue ,  t1.year from paper as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id join affiliation as t3 on t2.affiliation_id  =  t3.affiliation_id where t3.name = ""columbia university""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paper.venue"" and ""Paper.year"" fields. 2. Condition Structure: Use a WHERE clause to filter for records where the ""Affiliation.name"" is ""Columbia University."" 3. Join Structure: Use JOINs to connect the ""Author_list"" table with the ""Affiliation"" table on ""Author_list.affiliation_id = Affiliation.affiliation_id"" and the ""Author_list"" table with the ""Paper"" table on ""Author_list.paper_id = Paper.paper_id"" to link affiliations with their respective papers. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique combinations of venues and years are returned.",1.0
1019,What are the names and addresses for all affiliations?,EASY,aan_1,"[Affiliation.name, Affiliation.address]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Affiliation.name, Affiliation.address FROM Affiliation;","SELECT DISTINCT name ,  address FROM Affiliation","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""Affiliation.name"" and ""Affiliation.address"". 2. Condition Structure: No specific filtering condition is required as the query asks for all affiliations. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Affiliation"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all names and addresses.",1.0
1020,What is the sum of distances between BAL and other cities?,NON-NESTED,address_1,"[Direct_distance.distance,Direct_distance.city1_code,Direct_distance.city2_code,City.city_code,City.city_name,Direct_distance.city1_code = City.city_code,Direct_distance.city2_code = City.city_code,BAL]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT SUM(Direct_distance.distance) FROM Direct_distance JOIN City AS City1 ON Direct_distance.city1_code = City1.city_code JOIN City AS City2 ON Direct_distance.city2_code = City2.city_code WHERE City1.city_name = 'BAL' OR City2.city_name = 'BAL';,"SELECT sum(distance) FROM Direct_distance WHERE city1_code  =  ""BAL""","1. Sequential Structure: Start with the SELECT clause to calculate the sum of distances. Use the SUM function on the ""Direct_distance.distance"" field. 2. Condition Structure: Use a WHERE clause to filter for rows where either ""Direct_distance.city1_code"" or ""Direct_distance.city2_code"" corresponds to the city code for ""BAL."" 3. Join Structure: Use JOINs to connect the ""Direct_distance"" table with the ""City"" table twice, once for ""city1_code"" and once for ""city2_code,"" to ensure we can match city codes with their names. 4. Aggregation Structure: Use the SUM function to calculate the total distance for all rows that meet the condition.",0.0
1021,How much does headphones cost on average for each headphone construction?,EASY,headphone_store,"[headphone.Construction, headphone.Price]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Construction, AVG(headphone.Price) AS avg_price FROM headphone GROUP BY headphone.Construction;","SELECT construction ,  avg(price) FROM headphone GROUP BY construction","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the headphone construction type and the average price. 2. Aggregation Structure: Use the AVG function to calculate the average price for each headphone construction type. 3. Grouping Structure: Use GROUP BY on ""headphone.Construction"" to calculate the average price for each construction type. 4. Join Structure: No JOIN is required since all necessary data is within the ""headphone"" table.",1.0
1022,Count the number of papers which cited a paper with id A00-1002.,NON-NESTED,aan_1,"[Citation.paper_id, Citation.cited_paper_id, Citation.cited_paper_id = Paper.paper_id, Paper.paper_id = 'A00-1002']","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Citation.paper_id) FROM Citation WHERE Citation.cited_paper_id = 'A00-1002';,"SELECT count(*) FROM Citation WHERE cited_paper_id  =  ""A00-1002""","1. Sequential Structure: Start with the SELECT clause to count the number of papers that cited the paper with id 'A00-1002.' 2. Condition Structure: Use a WHERE clause to filter for records where ""Citation.cited_paper_id"" matches the paper id 'A00-1002.' 3. Join Structure: No JOIN is required since the necessary information is available in the ""Citation"" table. 4. Aggregation Structure: Use COUNT to count the number of records that meet the condition.",1.0
1023,What is the name and number of citations of the author with the greatest number of citations among authors?,NON-NESTED,aan_1,"[Author.name, Citation.paper_id, Citation.cited_paper_id = Paper.paper_id, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Author.name, SUM(Citation.paper_id) AS total_citations FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id JOIN Citation ON Citation.cited_paper_id = Paper.paper_id GROUP BY Author.name ORDER BY total_citations DESC LIMIT 1;","SELECT T3.name ,  count(*) FROM Citation AS T1 JOIN Author_list AS T2 ON T1.cited_paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id GROUP BY T2.author_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Author.name"" and the total number of citations for the author with the greatest number of citations. Use an aggregate function (SUM) to calculate the total number of citations for each author. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the author with the greatest number of citations. 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""Author_list"" with ""Author"" on ""author_id"" to associate authors with their IDs. Then, join ""Author_list"" with ""Paper"" on ""paper_id"" to link authors to their papers. Finally, join ""Citation"" with ""Paper"" on ""cited_paper_id"" to count the citations for each paper. 4. Aggregation Structure: Use SUM to calculate the total number of citations for each author. Use ORDER BY in descending order on the total citations and LIMIT 1 to select the author with the greatest number of citations.",0.0
1024,Find the name of the sailors who reserved boat with id 103.,NON-NESTED,boat_1,"[Sailors.name,Reserves.sid = Sailors.sid,Reserves.bid,103]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Sailors.name FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid WHERE Reserves.bid = 103;,SELECT DISTINCT T1.name FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid WHERE  T2.bid  =  103,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.name."" 2. Condition Structure: Use a WHERE clause to filter for records where ""Reserves.bid"" is 103. 3. Join Structure: Use a JOIN between the ""Sailors"" and ""Reserves"" tables based on the shared key ""Sailors.sid = Reserves.sid"" to associate sailors with their reservations. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of sailors who meet the condition.",1.0
1025,Find the total number of boats.,EASY,boat_1,[Boats.bid],"Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT COUNT(Boats.bid) AS total_boats FROM Boats;,SELECT count(*) FROM Boats,"1. Sequential Structure: Begin with the SELECT clause to count the total number of boats. 2. Aggregation Structure: Use the COUNT function to calculate the total number of boats based on their unique IDs (""Boats.bid""). 3. Join Structure: No JOIN is required since all necessary data is within the ""Boats"" table. 4. Condition Structure: No specific filtering condition is needed as we are counting all boats.",1.0
1026,show all years and the number of conferences in each year.,EASY,conference,"[conference.Year, conference.Conference_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT conference.Year, COUNT(conference.Conference_ID) AS number_of_conferences FROM conference GROUP BY conference.Year;","SELECT YEAR ,  count(*) FROM conference GROUP BY YEAR","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the year and the count of conferences. 2. Aggregation Structure: Use COUNT to calculate the number of conferences in each year. 3. Grouping Structure: Use GROUP BY on ""conference.Year"" to count the conferences for each year. 4. Join Structure: No JOIN is required since all necessary data is within the ""conference"" table.",1.0
1027,Count the number of affiliations.,EASY,aan_1,[Affiliation.affiliation_id],"Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Affiliation.affiliation_id) AS affiliation_count FROM Affiliation;,SELECT count(*) FROM Affiliation,"1. Sequential Structure: Begin with the SELECT clause to count the number of affiliations. 2. Aggregation Structure: Use the COUNT function to count the number of unique affiliation IDs. 3. Join Structure: No JOIN is required since all necessary data is within the ""Affiliation"" table. 4. Condition Structure: No specific filtering condition is needed as we are counting all affiliations.",1.0
1028,Find the name of the affiliation whose address contains 'China' and publishes the greatest number of papers.,NESTED,aan_1,"[Affiliation.name,Affiliation.address,Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.paper_id = Paper.paper_id,Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Affiliation.name FROM Affiliation JOIN Author_list ON Author_list.affiliation_id = Affiliation.affiliation_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Affiliation.address LIKE '%China%' GROUP BY Affiliation.name ORDER BY COUNT(Paper.paper_id) DESC LIMIT 1;,"SELECT T1.name FROM Affiliation AS T1 JOIN Author_list AS T2 ON T1.affiliation_id  =  T2.affiliation_id WHERE T1.address LIKE ""%China%"" GROUP BY T1.affiliation_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the name of the affiliation. Use the FROM clause to specify the Affiliation table. Join it with the Author_list table to connect affiliations with papers, and then join the Author_list table with the Paper table to count the number of papers published by each affiliation. Apply a WHERE clause to filter affiliations whose address contains 'China'. Use GROUP BY to group records by affiliation and COUNT to calculate the number of papers published. Finally, use ORDER BY in descending order of the paper count and LIMIT 1 to get the affiliation with the greatest number of papers. 2. Condition Structure: Use the WHERE clause to filter affiliations whose address contains 'China'. 3. Join Structure: Use INNER JOINs between the Affiliation, Author_list, and Paper tables to connect affiliations with their published papers. 4. Aggregation Structure: Use COUNT to calculate the number of papers published by each affiliation and ORDER BY to sort by the count in descending order. Use LIMIT 1 to retrieve the top result.",1.0
1029,which year has least number of conferences?,EASY,conference,"[conference.Year, conference.Conference_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT conference.Year FROM conference GROUP BY conference.Year ORDER BY COUNT(conference.Conference_ID) ASC LIMIT 1;,SELECT YEAR FROM conference GROUP BY YEAR ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the year, as the question asks for the year with the least number of conferences. 2. Aggregation Structure: Use COUNT to calculate the number of conferences for each year. 3. Grouping Structure: Use GROUP BY on ""conference.Year"" to group the results by year. 4. Ordering Structure: Use ORDER BY in ascending order on the count of conferences to find the year with the least number of conferences. 5. Limiting Structure: Use LIMIT 1 to retrieve only the year with the least number of conferences. 6. Join Structure: No JOIN is required since all necessary data is within the ""conference"" table.",1.0
1030,What are the names of the top 3 affiliations that have the most papers in year 2009?,NON-NESTED,aan_1,"[Affiliation.name,Author_list.affiliation_id,Author_list.paper_id = Paper.paper_id,Paper.year,2009]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Affiliation.name, COUNT(Paper.paper_id) AS paper_count FROM Affiliation JOIN Author_list ON Affiliation.affiliation_id = Author_list.affiliation_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Paper.year = 2009 GROUP BY Affiliation.name ORDER BY paper_count DESC LIMIT 3;",SELECT T3.name FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T1.year  =  2009 GROUP BY T2.affiliation_id ORDER BY count(*) DESC LIMIT 3,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of affiliations and the count of papers they are associated with. Use COUNT to count the number of papers for each affiliation. 2. Condition Structure: Use a WHERE clause to filter for papers published in the year 2009. 3. Join Structure: Use JOINs to connect the ""Affiliation"" table with the ""Author_list"" table on ""affiliation_id"" and the ""Author_list"" table with the ""Paper"" table on ""paper_id"" to link affiliations with their respective papers. 4. Aggregation Structure: Use GROUP BY on ""Affiliation.name"" to group the results by affiliation. Use ORDER BY in descending order of the paper count to rank affiliations by the number of papers, and LIMIT 3 to select the top 3 affiliations.",1.0
1031,What are the sids for sailors who reserved red or blue boats?,NESTED,boat_1,"[Sailors.sid, Reserves.sid, Reserves.bid, Boats.bid, Boats.color, Reserves.bid = Boats.bid, Reserves.sid = Sailors.sid, red, blue]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT DISTINCT Sailors.sid FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Boats.color IN ('red', 'blue');","SELECT DISTINCT T2.sid FROM Boats AS T1 JOIN Reserves AS T2 ON  T1.bid  =  T2.bid WHERE T1.color  =  'red' OR T1.color  =  ""blue""","1. Sequential Structure: Start with the SELECT clause to retrieve the sailor IDs (sids). Use the FROM clause to specify the Sailors, Reserves, and Boats tables. Apply a WHERE clause to filter for boats that are either red or blue in color. 2. Condition Structure: Use the WHERE clause to filter for boats with the color 'red' or 'blue'. 3. Join Structure: Use INNER JOINs to connect the Sailors, Reserves, and Boats tables. Join Reserves and Boats on the bid field, and Reserves and Sailors on the sid field to link sailors with the boats they reserved. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1032,What are the city codes corresponding to cities with distances less than 1000?,EASY,address_1,"[Direct_distance.city1_code, Direct_distance.city2_code, Direct_distance.distance]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT Direct_distance.city1_code, Direct_distance.city2_code FROM Direct_distance WHERE Direct_distance.distance < 1000;","SELECT city1_code ,  city2_code FROM Direct_distance WHERE distance  <  1000","1. Sequential Structure: Start with the SELECT clause to specify the city codes corresponding to cities with distances less than 1000. Both ""Direct_distance.city1_code"" and ""Direct_distance.city2_code"" need to be considered. 2. Condition Structure: Use a WHERE clause to filter rows where ""Direct_distance.distance"" is less than 1000. 3. Join Structure: No JOIN is required since all necessary information is in the ""Direct_distance"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving city codes that meet the specified distance condition.",1.0
1033,Give the distance between BAL and CHI?,NON-NESTED,address_1,"[Direct_distance.distance,City.city_name,Direct_distance.city1_code = City.city_code,Direct_distance.city2_code = City.city_code,BAL,CHI]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Direct_distance.distance FROM Direct_distance JOIN City AS City1 ON Direct_distance.city1_code = City1.city_code JOIN City AS City2 ON Direct_distance.city2_code = City2.city_code WHERE City1.city_name = 'BAL' AND City2.city_name = 'CHI';,"SELECT distance FROM Direct_distance WHERE city1_code  =  ""BAL"" AND city2_code  =  ""CHI""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Direct_distance.distance"" field, which represents the distance between two cities. 2. Condition Structure: Use a WHERE clause to filter for the specific cities ""BAL"" and ""CHI."" This requires matching ""Direct_distance.city1_code"" and ""Direct_distance.city2_code"" with the corresponding ""City.city_code"" for ""BAL"" and ""CHI."" 3. Join Structure: Use JOINs to connect the ""Direct_distance"" table with the ""City"" table twice, once for ""city1_code"" and once for ""city2_code,"" to get the city names for both codes. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single distance value.",0.0
1034,Find the top 2 earpads that are mostly used.,NON-NESTED,headphone_store,"[headphone.Earpads, stock.Headphone_ID = headphone.Headphone_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT headphone.Earpads, COUNT(*) AS usage_count FROM headphone JOIN stock ON stock.Headphone_ID = headphone.Headphone_ID GROUP BY headphone.Earpads ORDER BY usage_count DESC LIMIT 2;",SELECT earpads FROM headphone GROUP BY earpads ORDER BY count(*) DESC LIMIT 2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""headphone.Earpads"" and the count of their usage. Use COUNT to count the occurrences of each earpad type. 2. Condition Structure: No specific filtering condition is required, as we are interested in all earpads. 3. Join Structure: Use a JOIN between the ""headphone"" and ""stock"" tables based on ""headphone.Headphone_ID"" and ""stock.Headphone_ID"" to link each headphone with its stock records. 4. Aggregation Structure: Use GROUP BY on ""headphone.Earpads"" to group the results by earpad type. Use COUNT to calculate the frequency of each earpad type and ORDER BY in descending order to rank them by usage. Use LIMIT 2 to select the top 2 most used earpads.",1.0
1035,"How many citations does Mckeown , Kathleen have ?",NON-NESTED,aan_1,"[Author.name, Author.author_id, Author_list.author_id = Author.author_id, Author_list.paper_id, Citation.paper_id = Paper.paper_id, Citation.cited_paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT COUNT(Citation.cited_paper_id) FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id JOIN Citation ON Citation.paper_id = Paper.paper_id WHERE Author.name = 'Mckeown, Kathleen';","select count(*) from citation as t1 join author_list as t2 on t1.cited_paper_id  =  t2.paper_id join author as t3 on t2.author_id  =  t3.author_id where t3.name = ""mckeown ,  kathleen""","1. Sequential Structure: Start with the SELECT clause to count the number of citations for the author ""Mckeown, Kathleen."" Use COUNT on ""Citation.cited_paper_id"" to calculate the total number of citations. 2. Condition Structure: Use a WHERE clause to filter for the author ""Mckeown, Kathleen"" by matching ""Author.name."" Then, ensure that the citations are counted for papers authored by this individual. 3. Join Structure: Use JOINs to connect the ""Author"" table with the ""Author_list"" table on ""Author.author_id,"" then connect ""Author_list"" with the ""Paper"" table on ""Author_list.paper_id."" Finally, connect the ""Paper"" table with the ""Citation"" table on ""Citation.paper_id"" to count the citations for the author's papers. 4. Aggregation Structure: Use COUNT to aggregate the total number of citations for the specified author.",1.0
1036,Which earpads never use plastic construction?,NESTED,headphone_store,"[headphone.Earpads, headphone.Construction]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT Earpads FROM headphone WHERE Construction NOT LIKE '%plastic%';,SELECT earpads FROM headphone EXCEPT SELECT earpads FROM headphone WHERE construction  =  'Plastic',"1. Sequential Structure: Start with the SELECT clause to retrieve the earpads from the headphone table. Use the FROM clause to specify the headphone table. Apply a WHERE clause to filter for earpads that do not use plastic in their construction. 2. Condition Structure: Use the WHERE clause to filter rows where the ""Construction"" column does not include ""plastic"". 3. Join Structure: Not required, as all data is available within the headphone table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1037,Show ids for all female (sex is F) students living in state PA.,NON-NESTED,address_1,"[Student.StuID, Student.Sex, Student.city_code = City.city_code, City.state, F, PA]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Student.StuID FROM Student JOIN City ON Student.city_code = City.city_code WHERE Student.Sex = 'F' AND City.state = 'PA';,"SELECT StuID FROM City AS T1 JOIN Student AS T2 ON T1.city_code  =  T2.city_code WHERE T1.state  =  ""PA""  AND T2.sex  =  'F'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student.StuID"" field, as the question asks for student IDs. 2. Condition Structure: Use a WHERE clause to filter for students whose ""Student.Sex"" is 'F' and who live in a state with the code 'PA'. This requires filtering on both the ""Student"" and ""City"" tables. 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to associate each student with their respective city and state. 4. Aggregation Structure: No aggregation is needed, as the query only retrieves individual student IDs.",1.0
1038,"How many collaborators has Mckeown , Kathleen had ?",NESTED,aan_1,"[Author.name, Author.author_id, Author_list.author_id = Author.author_id, Author_list.paper_id, Paper.paper_id = Author_list.paper_id, Paper.paper_id = Citation.paper_id, Citation.cited_paper_id = Author_list.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT COUNT(DISTINCT other_authors.author_id) AS collaborator_count FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id JOIN Author_list AS other_authors ON Paper.paper_id = other_authors.paper_id WHERE Author.name = 'Mckeown, Kathleen' AND other_authors.author_id != Author.author_id;","select count (distinct t2.author_id) from author_list as t1 join author_list as t2 on t1.paper_id  =  t2.paper_id and t1.author_id != t2.author_id join author as t3 on t1.author_id  =  t3.author_id where t3.name = ""mckeown ,  kathleen""","1. Sequential Structure: Start with the SELECT clause to count the number of distinct collaborators. Use the FROM clause to specify the relevant tables (Author, Author_list, and Paper). Use JOINs to connect these tables based on their relationships. Apply a WHERE clause to filter for the author named ""Mckeown, Kathleen"". 2. Condition Structure: Use the WHERE clause to filter for the specific author by their name. Exclude the author themselves from the count of collaborators. 3. Join Structure: Use INNER JOINs to connect the Author table with the Author_list table on author_id, and the Author_list table with the Paper table on paper_id. This allows us to identify all authors who collaborated on the same papers as ""Mckeown, Kathleen"". 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique collaborators for the specified author.",1.0
1039,What is the distance between BAL and CHI?,NON-NESTED,address_1,"[Direct_distance.distance,City.city_name,Direct_distance.city1_code = City.city_code,Direct_distance.city2_code = City.city_code,BAL,CHI]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT Direct_distance.distance FROM Direct_distance JOIN City AS City1 ON Direct_distance.city1_code = City1.city_code JOIN City AS City2 ON Direct_distance.city2_code = City2.city_code WHERE City1.city_name = 'BAL' AND City2.city_name = 'CHI';,"SELECT distance FROM Direct_distance WHERE city1_code  =  ""BAL"" AND city2_code  =  ""CHI""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Direct_distance.distance"" between the two cities. 2. Condition Structure: Use a WHERE clause to filter for the specific cities ""BAL"" and ""CHI."" This requires matching ""Direct_distance.city1_code"" and ""Direct_distance.city2_code"" with the corresponding ""City.city_code"" for ""BAL"" and ""CHI."" 3. Join Structure: Use JOINs to connect the ""Direct_distance"" table with the ""City"" table twice, once for ""city1_code"" and once for ""city2_code,"" to get the city names for both codes. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single distance value.",0.0
1040,What are the titles for papers with more than 50 citations?,NON-NESTED,aan_1,"[Paper.title, Citation.paper_id, Citation.cited_paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Paper.title FROM Paper JOIN Citation ON Citation.cited_paper_id = Paper.paper_id GROUP BY Paper.paper_id HAVING COUNT(Citation.cited_paper_id) > 50;,SELECT T2.title FROM Citation AS T1 JOIN Paper AS T2 ON T1.cited_paper_id  =  T2.paper_id GROUP BY T1.cited_paper_id HAVING count(*)  >  50,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Paper.title."" 2. Condition Structure: Use a HAVING clause to filter for papers with more than 50 citations. 3. Join Structure: Use a JOIN between the ""Paper"" and ""Citation"" tables based on ""Citation.cited_paper_id = Paper.paper_id"" to link each paper with its citation records. 4. Aggregation Structure: Use COUNT on ""Citation.cited_paper_id"" to count the number of citations for each paper, then filter with HAVING to select papers with more than 50 citations.",1.0
1041,Find id for the sailors who do not have a reservation of a boat?,NESTED,boat_1,"[Sailors.sid, Reserves.sid, Sailors.sid = Reserves.sid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT sid FROM Sailors WHERE sid NOT IN (SELECT sid FROM Reserves);,SELECT sid FROM Sailors EXCEPT SELECT T1.sid FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of sailors. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors who do not have a reservation of a boat by ensuring their IDs are not present in the Reserves table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude sailors whose IDs appear in the Reserves table, meaning they have made a reservation. 3. Join Structure: Not required, as we only need to filter based on the absence of matching IDs in the Reserves table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1042,What is the id and the number of citations of the most cited paper?,NON-NESTED,aan_1,"[Paper.paper_id, Citation.paper_id, Citation.cited_paper_id = Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Citation.cited_paper_id AS paper_id, COUNT(Citation.cited_paper_id) AS number_of_citations FROM Citation JOIN Paper ON Citation.cited_paper_id = Paper.paper_id GROUP BY Citation.cited_paper_id ORDER BY COUNT(Citation.cited_paper_id) DESC LIMIT 1;","SELECT paper_id ,  count(*) FROM Citation GROUP BY cited_paper_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""paper_id"" and the count of citations for the most cited paper. Use COUNT on ""Citation.cited_paper_id"" to count the number of citations for each paper. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the paper with the highest number of citations. 3. Join Structure: Use a JOIN between the ""Paper"" and ""Citation"" tables, linking ""Citation.cited_paper_id"" with ""Paper.paper_id"" to associate each paper with its citations. 4. Aggregation Structure: Use GROUP BY on ""Citation.cited_paper_id"" to group citations by paper. Use ORDER BY in descending order on the count of citations and LIMIT 1 to select the most cited paper.",0.0
1043,What are the titles and paper ids for papers which were affiliated with both Stanford and Columbia University?,NESTED,aan_1,"[Paper.title, Paper.paper_id, Author_list.affiliation_id = Affiliation.affiliation_id, Author_list.paper_id = Paper.paper_id, Affiliation.name, Stanford, Columbia University]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.title, Paper.paper_id FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id JOIN Affiliation ON Author_list.affiliation_id = Affiliation.affiliation_id WHERE Paper.paper_id IN ( SELECT Author_list.paper_id FROM Author_list JOIN Affiliation ON Author_list.affiliation_id = Affiliation.affiliation_id WHERE Affiliation.name = 'Stanford' ) AND Paper.paper_id IN ( SELECT Author_list.paper_id FROM Author_list JOIN Affiliation ON Author_list.affiliation_id = Affiliation.affiliation_id WHERE Affiliation.name = 'Columbia University' );","SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T3.name LIKE ""Stanford University"" INTERSECT SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Affiliation AS T3 ON T2.affiliation_id  =  T3.affiliation_id WHERE T3.name LIKE ""Columbia University""","1. Sequential Structure: Start with the SELECT clause to retrieve the titles and paper IDs of papers. Use the FROM clause to specify the Paper table and join it with the Author_list and Affiliation tables to connect papers with their affiliations. Apply a WHERE clause to filter for papers affiliated with both Stanford and Columbia University. 2. Condition Structure: Use the WHERE clause with subqueries to ensure that the paper IDs are associated with both Stanford and Columbia University in the Affiliation table. 3. Join Structure: Use INNER JOINs between the Paper, Author_list, and Affiliation tables based on their respective relationships (Author_list.paper_id = Paper.paper_id and Author_list.affiliation_id = Affiliation.affiliation_id) to connect papers with their affiliations. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1044,Which neighborhood does not have any headphone in stock?,NESTED,headphone_store,"[store.Neighborhood,stock.Quantity,store.Store_ID = stock.Store_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT store.Neighborhood FROM store LEFT JOIN stock ON store.Store_ID = stock.Store_ID WHERE stock.Quantity IS NULL OR stock.Quantity = 0;,SELECT Neighborhood FROM store EXCEPT SELECT t1.Neighborhood FROM store AS t1 JOIN stock AS t2 ON t1.store_id  =  t2.store_id,"1. Sequential Structure: Begin with the SELECT clause to retrieve the neighborhood names. Use the FROM clause to specify the store table and JOIN it with the stock table on Store_ID to connect neighborhoods with their stock information. Apply a WHERE clause to filter neighborhoods that do not have any headphones in stock. 2. Condition Structure: Use the WHERE clause with a subquery to exclude neighborhoods where the stock contains headphones (Quantity > 0 for headphones). 3. Join Structure: Use an INNER JOIN between the store and stock tables based on Store_ID to link neighborhoods with their stock data. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1045,Find the name of the store which has the most headphones in stock. List the number of headphones as well.,NON-NESTED,headphone_store,"[store.Name,stock.Quantity,stock.Store_ID = store.Store_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
","SELECT store.Name, SUM(stock.Quantity) AS Total_Headphones FROM store JOIN stock ON store.Store_ID = stock.Store_ID GROUP BY store.Name ORDER BY Total_Headphones DESC LIMIT 1;","SELECT t1.name ,  sum(t2.quantity) FROM store AS t1 JOIN stock AS t2 ON t1.store_id  =  t2.store_id GROUP BY t2.store_id ORDER BY sum(t2.quantity) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""store.Name"" and the total ""stock.Quantity"" of headphones. Use an aggregation function (SUM) on ""stock.Quantity"" to calculate the total number of headphones in stock for each store. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the store with the most headphones in stock. 3. Join Structure: Use a JOIN between the ""store"" and ""stock"" tables based on the ""store.Store_ID"" and ""stock.Store_ID"" to link each store with its stock information. 4. Aggregation Structure: Use SUM to calculate the total quantity of headphones for each store, then use ORDER BY in descending order on the total quantity to rank stores by the number of headphones. Use LIMIT 1 to select the store with the most headphones.",1.0
1046,Which headphone model has the highest price?,EASY,headphone_store,"[headphone.Model, headphone.Price]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT headphone.Model FROM headphone ORDER BY headphone.Price DESC LIMIT 1;,SELECT model FROM headphone ORDER BY price DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""headphone.Model"" of the headphone with the highest price. 2. Condition Structure: No specific filtering condition is needed since we are looking for the headphone with the highest price. 3. Join Structure: No JOIN is required, as all necessary information is in the ""headphone"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""headphone.Price"" to rank headphones by price and apply LIMIT 1 to select the headphone model with the highest price.",1.0
1047,Which author had the most papers in the year 2009?,NON-NESTED,aan_1,"[Author.name, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Paper.year, 2009]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Author.name, COUNT(Paper.paper_id) AS paper_count FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Paper.year = 2009 GROUP BY Author.author_id ORDER BY paper_count DESC LIMIT 1;",SELECT T3.name FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T3.author_id  =  T2.author_id WHERE T1.year  =  2009 GROUP BY T2.author_id ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Author.name"" and the count of papers authored. Use an aggregate function (COUNT) to count the number of papers for each author. 2. Condition Structure: Use a WHERE clause to filter for papers published in the year 2009. 3. Join Structure: Use JOINs to connect the ""Author_list"" table with the ""Author"" table on ""author_id"" and the ""Author_list"" table with the ""Paper"" table on ""paper_id"" to link authors with their papers. 4. Aggregation Structure: Use COUNT to count the number of papers for each author, GROUP BY ""Author.author_id"" to group results by author, and ORDER BY the count in descending order to find the author with the most papers. Use LIMIT 1 to return only the top result.",1.0
1048,How many different neighborhoods are there for all stores?,EASY,headphone_store,[store.Neighborhood],"Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT COUNT(DISTINCT store.Neighborhood) FROM store;,SELECT count(DISTINCT neighborhood) FROM store,"1. Sequential Structure: Begin with the SELECT clause to count the distinct neighborhoods, as the question asks for the number of different neighborhoods. 2. Condition Structure: No specific filtering condition is required since we want to consider all neighborhoods. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""store"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""store.Neighborhood"" to count the unique neighborhoods.",1.0
1049,Count the number of references the paper with id D12-1027 has.,EASY,aan_1,"[Citation.paper_id, Citation.cited_paper_id, Paper.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(Citation.cited_paper_id) AS reference_count FROM Citation WHERE Citation.paper_id = 'D12-1027';,"SELECT count(*) FROM Citation WHERE paper_id  =  ""D12-1027""","1. Sequential Structure: Begin with the SELECT clause to count the number of references for the paper with ID ""D12-1027"". 2. Condition Structure: Use a WHERE clause to filter the records where ""Citation.paper_id"" matches the given paper ID ""D12-1027"". 3. Join Structure: No JOIN is required since all necessary information is available in the ""Citation"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of references for the specified paper.",1.0
1050,Find the titles and paper IDs for papers which have Mckeown but not Rambow in author list.,NESTED,aan_1,"[Paper.title, Paper.paper_id, Author.name, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Mckeown, Rambow]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.title, Paper.paper_id FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id JOIN Author ON Author_list.author_id = Author.author_id WHERE Author.name = 'Mckeown' AND Paper.paper_id NOT IN ( SELECT Paper.paper_id FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id JOIN Author ON Author_list.author_id = Author.author_id WHERE Author.name = 'Rambow' );","SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id WHERE T3.name LIKE ""%Mckeown%"" EXCEPT SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T2.author_id  =  T3.author_id WHERE T3.name LIKE ""%Rambow%""","1. Sequential Structure: Start with the SELECT clause to retrieve the titles and paper IDs of papers. Use the FROM clause to specify the Paper table. Join it with the Author_list table to associate papers with their authors, and then join the Author table to get author names. Apply a WHERE clause to filter papers that have ""Mckeown"" in the author list but not ""Rambow"". 2. Condition Structure: Use the WHERE clause to filter for papers where ""Mckeown"" is in the author list. Use a subquery to exclude papers where ""Rambow"" is in the author list. 3. Join Structure: Use INNER JOINs between the Paper, Author_list, and Author tables to connect papers with their authors and filter based on author names. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1051,What are the ids of sailors who reserved red and blue boats?,NESTED,boat_1,"[Sailors.sid, Reserves.sid, Reserves.bid, Boats.bid, Boats.color, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, red, blue]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.sid FROM Sailors JOIN Reserves ON Reserves.sid = Sailors.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE Boats.color IN ('red', 'blue') GROUP BY Sailors.sid HAVING COUNT(DISTINCT Boats.color) = 2;","SELECT DISTINCT T2.sid FROM Boats AS T1 JOIN Reserves AS T2 ON  T1.bid  =  T2.bid WHERE T1.color  =  'red' INTERSECT SELECT DISTINCT T2.sid FROM Boats AS T1 JOIN Reserves AS T2 ON  T1.bid  =  T2.bid WHERE T1.color  =  ""blue""","1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of sailors. Use the FROM clause to specify the Sailors, Reserves, and Boats tables. Apply a WHERE clause to filter for boats that are either red or blue. Use a GROUP BY clause to group by sailor IDs and a HAVING clause to ensure that each sailor has reserved both red and blue boats. 2. Condition Structure: Use the WHERE clause to filter for boats with colors 'red' or 'blue'. Use the HAVING clause to ensure that each sailor has reserved at least one red boat and one blue boat. 3. Join Structure: Use INNER JOINs between the Sailors, Reserves, and Boats tables based on the relationships between their respective IDs (Reserves.sid = Sailors.sid and Reserves.bid = Boats.bid). 4. Aggregation Structure: Use COUNT(DISTINCT Boats.color) in the HAVING clause to ensure that each sailor has reserved boats of both colors.",1.0
1052,Find the headphone models that are not in stock in any store.,NESTED,headphone_store,"[headphone.Model,stock.Headphone_ID,headphone.Headphone_ID = stock.Headphone_ID]","Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT headphone.Model FROM headphone WHERE headphone.Headphone_ID NOT IN (SELECT stock.Headphone_ID FROM stock);,SELECT model FROM headphone WHERE headphone_id NOT IN (SELECT headphone_id FROM stock),"1. Sequential Structure: Start with the SELECT clause to retrieve the headphone models. Use the FROM clause to specify the headphone table. Apply a WHERE clause to filter for headphone models that are not in stock in any store. 2. Condition Structure: Use the WHERE clause with a subquery to exclude headphone models whose Headphone_ID appears in the stock table, meaning they are in stock. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Headphone_ID entries in the stock table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1053,List all different headphone models in the alphabetical order.,EASY,headphone_store,[headphone.Model],"Table headphone, columns = [*,Headphone_ID,Model,Class,Driver-matched_dB,Construction,Earpads,Price]
Table stock, columns = [*,Store_ID,Headphone_ID,Quantity]
Table store, columns = [*,Store_ID,Name,Neighborhood,Parking,Date_Opened]
","Foreign_keys = [stock.Headphone_ID = headphone.Headphone_ID,stock.Store_ID = store.Store_ID]
",SELECT DISTINCT headphone.Model FROM headphone ORDER BY headphone.Model ASC;,SELECT DISTINCT model FROM headphone ORDER BY model,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the headphone model. 2. Condition Structure: No specific filtering condition is required as we want all headphone models. 3. Join Structure: No JOIN is required since all necessary data is within the ""headphone"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all distinct headphone models. 5. Ordering Structure: Use ORDER BY in ascending order to list the headphone models alphabetically.",1.0
1054,Find all papers with titles and paper IDs written by Mckeown.,NON-NESTED,aan_1,"[Paper.paper_id, Paper.title, Author.name, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Mckeown]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Paper.title, Paper.paper_id FROM Paper JOIN Author_list ON Paper.paper_id = Author_list.paper_id JOIN Author ON Author_list.author_id = Author.author_id WHERE Author.name = 'Mckeown';","SELECT T1.title ,  T1.paper_id FROM Paper AS T1 JOIN Author_list AS T2 ON T1.paper_id  =  T2.paper_id JOIN Author AS T3 ON T3.author_id  =  T2.author_id WHERE T3.name LIKE ""%Mckeown%""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Paper.title"" and ""Paper.paper_id."" 2. Condition Structure: Use a WHERE clause to filter for records where the author's name is ""Mckeown."" 3. Join Structure: Use JOINs to connect the ""Paper"" table with the ""Author_list"" table on ""Paper.paper_id"" and ""Author_list.paper_id,"" and then connect the ""Author_list"" table with the ""Author"" table on ""Author_list.author_id"" and ""Author.author_id"" to link papers with their respective authors. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without summarization.",0.0
1055,List names of all authors who have more than 50 papers.,NON-NESTED,aan_1,"[Author.name, Author.author_id, Author_list.author_id = Author.author_id, Author_list.paper_id, Paper.paper_id = Author_list.paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
","SELECT Author.name FROM Author JOIN Author_list ON Author.author_id = Author_list.author_id JOIN Paper ON Author_list.paper_id = Paper.paper_id GROUP BY Author.author_id, Author.name HAVING COUNT(Author_list.paper_id) > 50;",SELECT T1.name FROM Author AS T1 JOIN Author_list AS T2 ON T1.author_id  =  T2.author_id GROUP BY T1.author_id HAVING count(*)  >  50,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of authors. Use a GROUP BY clause to group the results by ""Author.author_id"" and ""Author.name."" 2. Condition Structure: Use a HAVING clause to filter authors who have more than 50 papers. 3. Join Structure: Use JOINs to connect the ""Author"" table with the ""Author_list"" table on ""Author.author_id"" and then connect the ""Author_list"" table with the ""Paper"" table on ""Author_list.paper_id"" to associate authors with their papers. 4. Aggregation Structure: Use COUNT on ""Author_list.paper_id"" to count the number of papers for each author, and filter with HAVING to include only those with more than 50 papers.",1.0
1056,Find the name and id of the sailors who reserved at least one boat?,NON-NESTED,boat_1,"[Sailors.sid,Sailors.name,Reserves.sid = Sailors.sid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT DISTINCT Sailors.name, Sailors.sid FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid;","SELECT DISTINCT T1.name ,  T1.sid FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.name"" and ""Sailors.sid."" 2. Condition Structure: No specific filtering condition is required, as we are looking for all sailors who have made at least one reservation. 3. Join Structure: Use a JOIN between the ""Sailors"" and ""Reserves"" tables based on the shared key ""Sailors.sid = Reserves.sid"" to link sailors with their reservations. 4. Aggregation Structure: Use DISTINCT to ensure that each sailor is listed only once, even if they have made multiple reservations.",1.0
1057,Give the state that the student with first name Linda lives in.,NON-NESTED,address_1,"[Student.Fname, Student.city_code, City.city_code = Student.city_code, City.state, Linda]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
",SELECT City.state FROM Student JOIN City ON Student.city_code = City.city_code WHERE Student.Fname = 'Linda';,"SELECT state FROM Student AS T1 JOIN City AS T2 ON T1.city_code  =  T2.city_code WHERE T1.Fname  =  ""Linda""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.state"" where the student with the first name ""Linda"" resides. 2. Condition Structure: Use a WHERE clause to filter for students whose first name is ""Linda."" 3. Join Structure: Use a JOIN between the ""Student"" and ""City"" tables based on the ""city_code"" field to link each student with their corresponding city and state. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single value.",1.0
1058,What is id about sailors who do not have boat reservations?,NESTED,boat_1,"[Sailors.sid, Reserves.sid, Sailors.sid = Reserves.sid]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT sid FROM Sailors WHERE sid NOT IN (SELECT sid FROM Reserves);,SELECT sid FROM Sailors EXCEPT SELECT T1.sid FROM Sailors AS T1 JOIN Reserves AS T2 ON T1.sid  =  T2.sid,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of sailors. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors who do not have any boat reservations. 2. Condition Structure: Use the WHERE clause with a subquery to exclude sailors whose IDs appear in the Reserves table, indicating they have reservations. 3. Join Structure: Not required, as we only need to filter based on the absence of matching IDs in the Reserves table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1059,Find the name and id of Sailors (sid) that reserved red and blue boat.,NESTED,boat_1,"[Sailors.sid, Sailors.name, Reserves.sid = Sailors.sid, Reserves.bid = Boats.bid, Boats.color, red, blue]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT DISTINCT Sailors.sid, Sailors.name FROM Sailors JOIN Reserves ON Sailors.sid = Reserves.sid JOIN Boats ON Reserves.bid = Boats.bid WHERE EXISTS ( SELECT 1 FROM Reserves r1 JOIN Boats b1 ON r1.bid = b1.bid WHERE r1.sid = Sailors.sid AND b1.color = 'red' ) AND EXISTS ( SELECT 1 FROM Reserves r2 JOIN Boats b2 ON r2.bid = b2.bid WHERE r2.sid = Sailors.sid AND b2.color = 'blue' );","SELECT DISTINCT T2.sid ,  T3.name FROM Boats AS T1 JOIN Reserves AS T2 ON  T1.bid  =  T2.bid JOIN Sailors AS T3 ON T2.sid  =  T3.sid WHERE T1.color  =  'red' INTERSECT SELECT DISTINCT T2.sid ,  T3.name FROM Boats AS T1 JOIN Reserves AS T2 ON  T1.bid  =  T2.bid JOIN Sailors AS T3 ON T2.sid  =  T3.sid WHERE T1.color  =  ""blue""","1. Sequential Structure: Start with the SELECT clause to retrieve the name and id (sid) of sailors. Use the FROM clause to specify the Sailors table and JOIN it with the Reserves and Boats tables to connect sailors with the boats they reserved. Apply a WHERE clause to filter for boats with colors 'red' and 'blue'. 2. Condition Structure: Use the WHERE clause to filter for sailors who reserved both red and blue boats. This can be achieved by using EXISTS subqueries to check for the existence of reservations for both colors. 3. Join Structure: Use INNER JOINs between Sailors, Reserves, and Boats tables based on the relationships sid = sid and bid = bid to connect sailors with their reservations and the boats they reserved. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1060,Find the name of authors who have never published a paper in ACL.,NESTED,aan_1,"[Author.name, Author_list.author_id = Author.author_id, Author_list.paper_id = Paper.paper_id, Paper.venue, ACL]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Author.name FROM Author WHERE Author.author_id NOT IN ( SELECT Author_list.author_id FROM Author_list JOIN Paper ON Author_list.paper_id = Paper.paper_id WHERE Paper.venue = 'ACL' );,"SELECT name FROM Author WHERE author_id NOT IN (SELECT T1.author_id FROM Author_list AS T1 JOIN Paper AS T2 ON T1.paper_id  =  T2.paper_id WHERE T2.venue  =  ""ACL"")","1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors. Use the FROM clause to specify the Author table. Apply a WHERE clause to filter authors who have never published a paper in the ACL venue. 2. Condition Structure: Use a WHERE clause with a subquery to exclude authors whose author_id is associated with papers published in the ACL venue. The subquery identifies all author_ids linked to papers in the ACL venue. 3. Join Structure: Use INNER JOINs between the Author, Author_list, and Paper tables to connect authors with their papers and venues. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1061,"Show the institution name, location and founded year of all institutions.",EASY,conference,"[institution.Institution_Name, institution.Location, institution.Founded]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT institution.Institution_Name, institution.Location, institution.Founded FROM institution;","SELECT institution_name ,  LOCATION ,  founded FROM institution","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""institution.Institution_Name,"" ""institution.Location,"" and ""institution.Founded."" 2. Condition Structure: No specific filtering condition is required as the query asks for all institutions. 3. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the specified fields for all institutions.",1.0
1062,Find the titles of papers that have more than 50 citations.,NON-NESTED,aan_1,"[Paper.title, Citation.paper_id, Citation.cited_paper_id = Paper.paper_id, 50]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT Paper.title FROM Paper JOIN Citation ON Citation.cited_paper_id = Paper.paper_id GROUP BY Paper.paper_id HAVING COUNT(Citation.cited_paper_id) > 50;,SELECT T2.title FROM Citation AS T1 JOIN Paper AS T2 ON T1.cited_paper_id  =  T2.paper_id GROUP BY T1.cited_paper_id HAVING count(*)  >  50,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Paper.title."" 2. Condition Structure: Use a HAVING clause to filter for papers that have more than 50 citations. 3. Join Structure: Use a JOIN between the ""Paper"" and ""Citation"" tables based on ""Citation.cited_paper_id = Paper.paper_id"" to link each paper with its citations. 4. Aggregation Structure: Use COUNT on ""Citation.cited_paper_id"" to count the number of citations for each paper, then filter with HAVING to select papers with more than 50 citations.",1.0
1063,"What are the names, locations, and founding years for all institutions?",EASY,conference,"[institution.Institution_Name, institution.Location, institution.Founded]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT institution.Institution_Name, institution.Location, institution.Founded FROM institution;","SELECT institution_name ,  LOCATION ,  founded FROM institution","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the institution name, location, and founding year. 2. Condition Structure: No specific filtering condition is required as the query asks for all institutions. 3. Join Structure: No JOIN is required since all necessary information is available in the ""institution"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all institutions.",1.0
1064,What is the full name of the student who lives furthest from Linda Smith?,NON-NESTED,address_1,"[Student.Fname, Student.LName, Student.city_code = City.city_code, City.city_code = Direct_distance.city1_code, City.city_code = Direct_distance.city2_code, Direct_distance.distance]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT S.Fname, S.LName FROM Student AS S JOIN City AS C ON S.city_code = C.city_code JOIN Direct_distance AS D ON C.city_code = D.city1_code OR C.city_code = D.city2_code WHERE (SELECT city_code FROM Student WHERE Fname = 'Linda' AND LName = 'Smith') IN (D.city1_code, D.city2_code) ORDER BY D.distance DESC LIMIT 1;","SELECT T3.Fname ,  T3.Lname FROM Direct_distance AS T1 JOIN Student AS T2 ON T1.city1_code  =  T2.city_code JOIN Student AS T3 ON T1.city2_code  =  T3.city_code WHERE T2.Fname  =  ""Linda"" AND T2.Lname  =  ""Smith"" ORDER BY distance DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the full name of the student, which includes ""Student.Fname"" and ""Student.LName."" 2. Condition Structure: Use a WHERE clause to filter for the specific reference point, ""Linda Smith,"" by matching her name in the ""Student"" table. Additionally, identify the city she resides in using the ""Student.city_code."" 3. Join Structure: Use JOINs to connect the ""Student"" table with the ""City"" table on ""Student.city_code = City.city_code"" and the ""Direct_distance"" table on ""City.city_code = Direct_distance.city1_code"" or ""City.city_code = Direct_distance.city2_code"" to calculate distances. 4. Aggregation Structure: Use ORDER BY in descending order on the ""Direct_distance.distance"" to rank students by their distance from Linda Smith. Use LIMIT 1 to select the student who lives the furthest.",0.0
1065,Show the institution name and location of institution that is most recently founded.,EASY,conference,"[institution.Institution_Name, institution.Location, institution.Founded]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT institution.Institution_Name, institution.Location FROM institution ORDER BY institution.Founded DESC LIMIT 1;","SELECT institution_name ,  LOCATION FROM institution ORDER BY founded DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""institution.Institution_Name"" and ""institution.Location"" of the institution that is most recently founded. 2. Condition Structure: No specific filtering condition is required since we are looking for the institution with the most recent founding year. 3. Join Structure: No JOIN is necessary as all the required information is available in the ""institution"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""institution.Founded"" to rank institutions by their founding year. Apply LIMIT 1 to select the most recently founded institution.",1.0
1066,Return name and age for sailors who are younger than 30.,EASY,boat_1,"[Sailors.name, Sailors.age]","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
","SELECT Sailors.name, Sailors.age FROM Sailors WHERE Sailors.age < 30;","SELECT name ,  age FROM Sailors WHERE age  <  30","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Sailors.name"" and ""Sailors.age"". 2. Condition Structure: Use a WHERE clause to filter sailors whose age is less than 30. 3. Join Structure: No JOIN is required since all necessary data is within the ""Sailors"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and ages of sailors who meet the specified condition.",1.0
1067,"What are the sailors' names, the ones whose rating is higher than any sailor named Luis?",NESTED,boat_1,"[Sailors.name, Sailors.rating, Sailors.name = 'Luis']","Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT name FROM Sailors WHERE rating > ANY (SELECT rating FROM Sailors WHERE name = 'Luis');,SELECT name FROM Sailors WHERE rating  >  (SELECT min(rating) FROM Sailors WHERE name  =  'Luis'),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of sailors. Use the FROM clause to specify the Sailors table. Apply a WHERE clause to filter sailors whose rating is higher than any sailor named 'Luis'. 2. Condition Structure: Use the WHERE clause with a subquery to compare the rating of each sailor to the rating of sailors named 'Luis'. The subquery retrieves the ratings of all sailors named 'Luis'. 3. Join Structure: Not required, as all data is in the Sailors table. 4. Aggregation Structure: Use the ANY operator in the WHERE clause to compare the rating of each sailor to the ratings of sailors named 'Luis'.",0.0
1068,"For each city, what is the the city code and sum of distances from each?",NON-NESTED,address_1,"[City.city_code,Direct_distance.city1_code,Direct_distance.distance,Direct_distance.city1_code = City.city_code]","Table City, columns = [*,city_code,city_name,state,country,latitude,longitude]
Table Direct_distance, columns = [*,city1_code,city2_code,distance]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Student.city_code = City.city_code,Direct_distance.city2_code = City.city_code,Direct_distance.city1_code = City.city_code]
","SELECT City.city_code, SUM(Direct_distance.distance) AS total_distance FROM City JOIN Direct_distance ON Direct_distance.city1_code = City.city_code GROUP BY City.city_code;","SELECT city1_code ,  sum(distance) FROM Direct_distance GROUP BY city1_code","1. Sequential Structure: Start with the SELECT clause to retrieve the ""City.city_code"" and the sum of distances. Use the SUM function to calculate the total distance for each city. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""City"" table with the ""Direct_distance"" table based on the relationship ""Direct_distance.city1_code = City.city_code."" 4. Aggregation Structure: Use the SUM function to aggregate the ""Direct_distance.distance"" values for each city, and GROUP BY ""City.city_code"" to group the results by city.",1.0
1069,What is the maximum rating for sailors?,EASY,boat_1,[Sailors.rating],"Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT MAX(Sailors.rating) AS max_rating FROM Sailors;,SELECT max(rating) FROM Sailors,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the maximum rating. 2. Aggregation Structure: Use the MAX function to calculate the maximum rating among sailors. 3. Condition Structure: No specific filtering condition is required as we are looking for the maximum rating across all sailors. 4. Join Structure: No JOIN is required since all necessary data is within the ""Sailors"" table.",1.0
1070,What is the name of sailors whose names contain letter e?,EASY,boat_1,[Sailors.name],"Table Boats, columns = [*,bid,name,color]
Table Reserves, columns = [*,sid,bid,day]
Table Sailors, columns = [*,sid,name,rating,age]
","Foreign_keys = [Reserves.bid = Boats.bid,Reserves.sid = Sailors.sid]
",SELECT Sailors.name FROM Sailors WHERE Sailors.name LIKE '%e%';,SELECT name FROM Sailors WHERE name LIKE '%e%',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sailors.name"" of sailors whose names contain the letter 'e'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for sailor names that contain the letter 'e'. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Sailors"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
1071,How many authors have not published a paper with more than 50 citations?,NESTED,aan_1,"[Author.author_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Paper.paper_id,Citation.paper_id,Citation.cited_paper_id]","Table Affiliation, columns = [*,affiliation_id,name,address]
Table Author, columns = [*,author_id,name,email]
Table Author_list, columns = [*,paper_id,author_id,affiliation_id]
Table Citation, columns = [*,paper_id,cited_paper_id]
Table Paper, columns = [*,paper_id,title,venue,year]
","Foreign_keys = [Author_list.affiliation_id = Affiliation.affiliation_id,Author_list.author_id = Author.author_id,Author_list.paper_id = Paper.paper_id,Citation.cited_paper_id = Paper.paper_id,Citation.paper_id = Paper.paper_id]
",SELECT COUNT(DISTINCT Author.author_id) AS num_authors FROM Author WHERE Author.author_id NOT IN ( SELECT DISTINCT Author_list.author_id FROM Author_list JOIN Paper ON Author_list.paper_id = Paper.paper_id JOIN Citation ON Citation.paper_id = Paper.paper_id GROUP BY Paper.paper_id HAVING COUNT(Citation.cited_paper_id) > 50 );,SELECT count(*) FROM Author WHERE Author_id NOT IN ( SELECT T2.author_id FROM Citation AS T1 JOIN Author_list AS T2 ON T1.cited_paper_id  =  T2.paper_id GROUP BY T1.cited_paper_id HAVING count(DISTINCT T1.paper_id)  >  50),"1. Sequential Structure: Start with the SELECT clause to count the number of authors. Use the FROM clause to specify the Author table. Apply a WHERE clause to filter authors who have not published a paper with more than 50 citations. 2. Condition Structure: Use a subquery in the WHERE clause to identify papers with more than 50 citations. Exclude authors whose papers are in this set. 3. Join Structure: Use JOINs between the Author, Author_list, Paper, and Citation tables to connect authors with their papers and the citation counts of those papers. 4. Aggregation Structure: Use COUNT to calculate the total number of authors who meet the specified condition.",0.0
1072,What are the names of all the conferences that has staff from Canada attending?,NON-NESTED,conference,"[conference.Conference_Name,staff.Nationality,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID,Canada]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT DISTINCT conference.Conference_Name FROM conference JOIN conference_participation ON conference.Conference_ID = conference_participation.Conference_ID JOIN staff ON conference_participation.staff_ID = staff.staff_ID WHERE staff.Nationality = 'Canada';,"SELECT T1.conference_name FROM conference AS T1 JOIN conference_participation AS T2 ON T1.conference_id = T2.conference_id JOIN staff AS T3 ON T2.staff_id  =  T3.staff_id WHERE T3.nationality  =  ""Canada""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""conference.Conference_Name."" 2. Condition Structure: Use a WHERE clause to filter for staff members whose ""staff.Nationality"" is 'Canada.' 3. Join Structure: Use JOINs to connect the ""conference"" table with the ""conference_participation"" table on ""conference.Conference_ID"" and then connect ""conference_participation"" with the ""staff"" table on ""conference_participation.staff_ID."" 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of conferences.",1.0
1073,What are the names of races in which drivers 26 or older took part?,NON-NESTED,car_road_race,"[race.Race_Name,driver.Age,race.Driver_ID = driver.Driver_ID,26]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT DISTINCT race.Race_Name FROM race JOIN driver ON race.Driver_ID = driver.Driver_ID WHERE driver.Age >= 26;,SELECT T2.Race_Name FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID WHERE T1.Age  >=  26,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""race.Race_Name"" field, as we are interested in the names of races. 2. Condition Structure: Use a WHERE clause to filter for drivers who are 26 years old or older. This condition will be applied to the ""driver.Age"" field. 3. Join Structure: Use a JOIN between the ""race"" and ""driver"" tables based on the relationship ""race.Driver_ID = driver.Driver_ID"" to associate races with their respective drivers. 4. Aggregation Structure: No aggregation is needed, as the query only requires the names of races without any summarization.",1.0
1074,Who is the oldest spokesman?,EASY,district_spokesman,"[spokesman.Name, spokesman.Age]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
",SELECT spokesman.Name FROM spokesman ORDER BY spokesman.Age DESC LIMIT 1;,SELECT name FROM spokesman ORDER BY age DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""spokesman.Name"" of the oldest spokesman. 2. Condition Structure: No specific filtering condition is needed, as we are looking for the spokesman with the maximum age. 3. Join Structure: No JOIN is required since all necessary information is in the ""spokesman"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""spokesman.Age"" to rank spokesmen by age and apply LIMIT 1 to select the oldest spokesman.",1.0
1075,"List the painting id, location and title of the medium oil paintings ordered by year.",EASY,art_1,"[Paintings.paintingID, Paintings.location, Paintings.title, Paintings.medium, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.paintingID, Paintings.location, Paintings.title FROM Paintings WHERE Paintings.medium = 'oil' ORDER BY Paintings.year;","SELECT paintingID ,  title ,  LOCATION FROM paintings WHERE medium  =  ""oil"" ORDER BY YEAR","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""Paintings.paintingID"", ""Paintings.location"", and ""Paintings.title"". 2. Condition Structure: Use a WHERE clause to filter for paintings where the medium is ""oil"". 3. Ordering Structure: Use ORDER BY on ""Paintings.year"" to sort the results by year. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table. 5. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition and ordering them.",1.0
1076,How many pilots are younger than all pilots who own the F-14 Fighter?,NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name, F-14 Fighter]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(*) FROM PilotSkills WHERE age < ALL ( SELECT age FROM PilotSkills WHERE plane_name = 'F-14 Fighter' );,SELECT count(*) FROM pilotskills WHERE age  <  (SELECT min(age) FROM pilotskills WHERE plane_name  =  'F-14 Fighter'),"1. Sequential Structure: Start with the SELECT clause to count the number of pilots. Use the FROM clause to specify the PilotSkills table. Apply a WHERE clause to filter pilots whose age is less than the age of all pilots who own the ""F-14 Fighter"". 2. Condition Structure: Use a WHERE clause with a subquery to identify the ages of pilots who own the ""F-14 Fighter"". The main query filters pilots whose age is less than all these ages. 3. Join Structure: Not required, as all relevant data is in the PilotSkills table, and the relationship with the Hangar table is not necessary for this query. 4. Aggregation Structure: Use COUNT to count the number of pilots satisfying the condition.",0.0
1077,What is the total number of paintings exhibited in gallery 240?,EASY,art_1,"[Paintings.location, Paintings.paintingID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT COUNT(Paintings.paintingID) AS total_paintings FROM Paintings WHERE Paintings.location = '240';,"SELECT count(*) FROM paintings WHERE LOCATION  =  ""Gallery 240""","1. Sequential Structure: Start with the SELECT clause to calculate the total number of paintings exhibited in gallery 240. 2. Condition Structure: Use a WHERE clause to filter for paintings located in gallery 240. 3. Join Structure: No JOIN is required since all necessary information is in the ""Paintings"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of paintings in the specified location.",0.0
1078,What are the names of both paintings and sculptures created between 1900 and 1950?,NESTED,art_1,"[Paintings.title,Paintings.year,Sculptures.title,Sculptures.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT title FROM Paintings WHERE year BETWEEN 1900 AND 1950 UNION SELECT title FROM Sculptures WHERE year BETWEEN 1900 AND 1950;,SELECT title FROM paintings WHERE YEAR BETWEEN 1900 AND 1950 UNION SELECT title FROM sculptures WHERE YEAR BETWEEN 1900 AND 1950,"1. Sequential Structure: Start with the SELECT clause to retrieve the names (titles) of both paintings and sculptures. Use the FROM clause to specify the Paintings and Sculptures tables. Apply a WHERE clause to filter records for the year range between 1900 and 1950. 2. Condition Structure: Use the WHERE clause to filter for entries where the year is between 1900 and 1950 for both paintings and sculptures. 3. Join Structure: Not required, as the data is retrieved independently from the Paintings and Sculptures tables. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1079,List the ids of all paintings that are taller than the longest painting created after 1900.,NESTED,art_1,"[Paintings.paintingID, Paintings.height_mm, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT paintingID FROM Paintings WHERE height_mm > (SELECT MAX(height_mm) FROM Paintings WHERE year > 1900);,SELECT paintingID FROM paintings WHERE height_mm  >   (SELECT max(height_mm) FROM paintings WHERE YEAR  >  1900),"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of paintings. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter paintings that are taller than the tallest painting created after 1900. 2. Condition Structure: Use the WHERE clause with a subquery to compare the height of each painting to the maximum height of paintings created after 1900. 3. Join Structure: Not required, as all data is in the Paintings table. 4. Aggregation Structure: Use the MAX function in a subquery to find the tallest painting created after 1900, and use this value in the filtering condition.",1.0
1080,Find the names of the districts which have had both spokesman with rank position 1 and 2.,NESTED,district_spokesman,"[district.Name, spokesman.Rank_position, spokesman.Spokesman_ID = spokesman_district.Spokesman_ID, spokesman_district.District_ID = district.District_ID]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
","SELECT district.Name FROM district JOIN spokesman_district ON district.District_ID = spokesman_district.District_ID JOIN spokesman ON spokesman.Spokesman_ID = spokesman_district.Spokesman_ID WHERE spokesman.Rank_position IN (1, 2) GROUP BY district.Name HAVING COUNT(DISTINCT spokesman.Rank_position) = 2;",SELECT t3.name FROM spokesman AS t1 JOIN spokesman_district AS t2 ON t1.Spokesman_ID  =  t2.Spokesman_ID JOIN district AS t3 ON t3.district_id  =  t2.district_id WHERE t1.rank_position  =  1 INTERSECT SELECT t3.name FROM spokesman AS t1 JOIN spokesman_district AS t2 ON t1.Spokesman_ID  =  t2.Spokesman_ID JOIN district AS t3 ON t3.district_id  =  t2.district_id WHERE t1.rank_position  =  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of districts. Use the FROM clause to specify the district table and join it with the spokesman and spokesman_district tables to connect districts with their spokesmen. Apply a WHERE clause to filter districts that have spokesmen with both rank positions 1 and 2. 2. Condition Structure: Use the WHERE clause to filter for districts that have spokesmen with rank positions 1 and 2. This can be achieved by using a subquery or grouping and filtering with HAVING. 3. Join Structure: Use INNER JOINs between the district, spokesman_district, and spokesman tables based on their respective keys (District_ID and Spokesman_ID) to connect districts with their spokesmen and their rank positions. 4. Aggregation Structure: Use GROUP BY to group records by district and HAVING to ensure that each district has spokesmen with both rank positions 1 and 2.",1.0
1081,List all names of drivers in descending alphabetical order.,EASY,car_road_race,[driver.Driver_Name],"Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Driver_Name FROM driver ORDER BY driver.Driver_Name DESC;,SELECT Driver_Name FROM driver ORDER BY Driver_Name DESC,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""driver.Driver_Name"". 2. Condition Structure: No specific filtering condition is required as we want all driver names. 3. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the names. 5. Ordering Structure: Use ORDER BY in descending alphabetical order on ""driver.Driver_Name"".",1.0
1082,What are the names of all staff members who are older than average?,NESTED,conference,"[staff.name, staff.Age]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT name FROM staff WHERE Age > (SELECT AVG(Age) FROM staff);,SELECT name FROM staff WHERE age  >  (SELECT avg(age) FROM staff),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of staff members. Use the FROM clause to specify the staff table. Apply a WHERE clause to filter staff members whose age is greater than the average age of all staff members. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average age of all staff members and filter for those whose age is greater than this value. 3. Join Structure: Not required, as all data is in the staff table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average age of all staff members, which is then used in the filtering condition.",1.0
1083,What are the distinct ids of every painting that is older than some painting in gallery 240?,NESTED,art_1,"[Paintings.paintingID, Paintings.year, Paintings.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT paintingID FROM Paintings WHERE year < ANY (SELECT year FROM Paintings WHERE location = 240);,"SELECT paintingID FROM paintings WHERE YEAR  <  (SELECT max(YEAR) FROM paintings WHERE LOCATION  =  ""Gallery 240"")","1. Sequential Structure: Start with the SELECT clause to retrieve distinct painting IDs. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter paintings that are older than at least one painting located in gallery 240. 2. Condition Structure: Use the WHERE clause with a subquery to compare the year of each painting with the years of paintings in gallery 240. The subquery retrieves the years of paintings in gallery 240, and the main query filters for paintings with a year less than any of these. 3. Join Structure: Not required, as all data is in the Paintings table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",0.0
1084,Count the number of different locations of hangars.,EASY,pilot_1,[Hangar.location],"Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(DISTINCT Hangar.location) FROM Hangar;,SELECT count(DISTINCT LOCATION) FROM hangar,"1. Sequential Structure: Start with the SELECT clause to count the distinct locations of hangars. 2. Condition Structure: No specific filtering condition is required as we want to count all distinct locations. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Hangar"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the number of unique hangar locations.",1.0
1085,What is the total population of the districts whose areas are in the top 3?,NESTED,district_spokesman,"[district.Area_km, district.Population]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
",SELECT SUM(Population) AS total_population FROM district WHERE Area_km IN ( SELECT Area_km FROM district ORDER BY Area_km DESC LIMIT 3 );,SELECT sum(population) FROM district ORDER BY area_km DESC LIMIT 3,"1. Sequential Structure: Start with the SELECT clause to calculate the total population. Use the FROM clause to specify the district table. Apply a WHERE clause to filter districts whose areas are in the top 3. 2. Condition Structure: Use the WHERE clause with a subquery to identify the top 3 areas. The subquery will sort the districts by area in descending order and limit the result to the top 3. 3. Join Structure: Not required, as all data is in the district table. 4. Aggregation Structure: Use the SUM function to calculate the total population of the filtered districts.",0.0
1086,What are the average height and width of paintings grouped by painters and ordered by name?,NON-NESTED,art_1,"[Paintings.height_mm, Paintings.width_mm, Paintings.painterID, Artists.artistID, Artists.lname, Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.lname, AVG(Paintings.height_mm) AS avg_height, AVG(Paintings.width_mm) AS avg_width FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID GROUP BY Artists.lname ORDER BY Artists.lname ASC;","SELECT avg(height_mm) ,  avg(width_mm) ,  painterID FROM paintings GROUP BY painterID ORDER BY title","1. Sequential Structure: Start with the SELECT clause to retrieve the average height and width of paintings, grouped by painters. Also include the painter's last name (""Artists.lname"") in the SELECT clause to group results by painter and order them by name. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Paintings"" and ""Artists"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to link each painting with its respective painter. 4. Aggregation Structure: Use AVG on ""Paintings.height_mm"" and ""Paintings.width_mm"" to calculate the average height and width of paintings for each painter. Use GROUP BY ""Artists.lname"" to group results by painter, and ORDER BY ""Artists.lname"" to sort the results alphabetically by painter's last name.",1.0
1087,List all distinct types of planes owned by all pilots in alphabetic order?,NON-NESTED,pilot_1,"[PilotSkills.plane_name, Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT DISTINCT PilotSkills.plane_name FROM PilotSkills ORDER BY PilotSkills.plane_name ASC;,SELECT DISTINCT plane_name FROM pilotskills ORDER BY plane_name,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct ""PilotSkills.plane_name"" since we are interested in unique plane types. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: No JOIN is required as the relevant data is only in the ""PilotSkills"" table. 4. Aggregation Structure: Use DISTINCT to ensure unique plane types are listed, and apply ORDER BY to sort the results alphabetically.",1.0
1088,Which artists have the most paintings in oil?,NON-NESTED,art_1,"[Paintings.medium, Paintings.painterID, Artists.artistID = Paintings.painterID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.artistID, COUNT(Paintings.painterID) AS painting_count FROM Artists JOIN Paintings ON Artists.artistID = Paintings.painterID WHERE Paintings.medium = 'oil' GROUP BY Paintings.painterID ORDER BY painting_count DESC LIMIT 1;","SELECT T1.lname ,  T1.fname FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T2.medium  =  ""oil"" GROUP BY T2.painterID ORDER BY count(*) DESC LIMIT 3","1. Sequential Structure: Start with the SELECT clause to retrieve the names or identifiers of artists. Since we are looking for the artists with the most paintings in oil, we will also need to count the number of paintings for each artist. Use an aggregate function (COUNT) on ""Paintings.painterID"" and group the results by ""Paintings.painterID."" 2. Condition Structure: Use a WHERE clause to filter for paintings where the medium is ""oil."" 3. Join Structure: Use a JOIN between the ""Artists"" and ""Paintings"" tables based on the relationship ""Artists.artistID = Paintings.painterID"" to associate each painting with its respective artist. 4. Aggregation Structure: Use COUNT to count the number of paintings for each artist, and use ORDER BY in descending order to rank artists by the number of paintings. Use LIMIT 1 to select the artist with the most paintings in oil.",0.0
1089,Find the names of spokesmen who have served some district before 2004.,NON-NESTED,district_spokesman,"[spokesman.Name, spokesman_district.Start_year, spokesman.Spokesman_ID = spokesman_district.Spokesman_ID, spokesman_district.District_ID]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
",SELECT DISTINCT spokesman.Name FROM spokesman JOIN spokesman_district ON spokesman.Spokesman_ID = spokesman_district.Spokesman_ID WHERE spokesman_district.Start_year < 2004;,SELECT t1.name FROM spokesman AS t1 JOIN spokesman_district AS t2 ON t1.Spokesman_ID  =  t2.Spokesman_ID WHERE t2.start_year  <  2004,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of spokesmen. 2. Condition Structure: Use a WHERE clause to filter for records where the ""spokesman_district.Start_year"" is before 2004. 3. Join Structure: Use a JOIN between the ""spokesman"" and ""spokesman_district"" tables based on ""spokesman.Spokesman_ID = spokesman_district.Spokesman_ID"" to associate each spokesman with their district records. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique spokesman names are returned.",1.0
1090,What are largest height and width dimensions for paintings in each year?,EASY,art_1,"[Paintings.year, Paintings.height_mm, Paintings.width_mm]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.year, MAX(Paintings.height_mm) AS max_height, MAX(Paintings.width_mm) AS max_width FROM Paintings GROUP BY Paintings.year;","SELECT max(height_mm) ,  max(width_mm) ,  YEAR FROM paintings GROUP BY YEAR ORDER BY YEAR","1. Sequential Structure: Begin with the SELECT clause to specify the year and the required aggregate values, which are the largest height and width dimensions. 2. Aggregation Structure: Use MAX functions to calculate the largest height and width dimensions for paintings in each year. 3. Grouping Structure: Use GROUP BY on ""Paintings.year"" to calculate these aggregate values for each year. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table.",1.0
1091,Give the full names of artists who have created paintings and sculptures.,NON-NESTED,art_1,"[Artists.artistID,Artists.lname,Artists.fname,Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT DISTINCT Artists.fname, Artists.lname FROM Artists JOIN Paintings ON Paintings.painterID = Artists.artistID JOIN Sculptures ON Sculptures.sculptorID = Artists.artistID;","SELECT T1.lname ,  T1.fname FROM artists AS T1 JOIN sculptures AS T2 ON T1.artistID  =  T2.sculptorID INTERSECT SELECT T3.lname ,  T3.fname FROM artists AS T3 JOIN paintings AS T4 ON T3.artistID  =  T4.painterID","1. Sequential Structure: Start with the SELECT clause to retrieve the full names of artists, which are ""Artists.fname"" and ""Artists.lname."" 2. Condition Structure: Use a WHERE clause to filter for artists who have created both paintings and sculptures. This requires checking that an artist's ID exists in both the ""Paintings"" and ""Sculptures"" tables. 3. Join Structure: Use JOINs to connect the ""Artists"" table with both the ""Paintings"" and ""Sculptures"" tables based on the relationships ""Paintings.painterID = Artists.artistID"" and ""Sculptures.sculptorID = Artists.artistID."" 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique artist names are returned.",1.0
1092,Find the number of all pilots whose age is older than some pilot who has plane Piper Cub.,NESTED,pilot_1,"[PilotSkills.age, PilotSkills.plane_name, PilotSkills.pilot_name, Hangar.plane_name, Hangar.plane_name = PilotSkills.plane_name, Piper Cub]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(*) FROM PilotSkills WHERE age > ANY (SELECT age FROM PilotSkills WHERE plane_name = 'Piper Cub');,SELECT count(pilot_name) FROM pilotskills WHERE age  >  (SELECT min(age) FROM pilotskills WHERE plane_name  =  'Piper Cub'),"1. Sequential Structure: Start with the SELECT clause to count the number of pilots. Use the FROM clause to specify the PilotSkills table. Apply a WHERE clause to filter pilots whose age is greater than the age of at least one pilot who has flown the plane named ""Piper Cub"". 2. Condition Structure: Use the WHERE clause with a subquery to identify pilots whose age is greater than the age of any pilot associated with the plane ""Piper Cub"". The subquery retrieves the ages of pilots who have flown ""Piper Cub"". 3. Join Structure: Not required, as all relevant data is in the PilotSkills table. 4. Aggregation Structure: Use COUNT to count the number of pilots satisfying the condition.",0.0
1093,What are the titles of all paintings and sculpture works made by the artist whose id is 222?,NON-NESTED,art_1,"[Paintings.title, Sculptures.title, Paintings.painterID = Artists.artistID, Sculptures.sculptorID = Artists.artistID, Artists.artistID, 222]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.title FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID WHERE Artists.artistID = 222 UNION SELECT Sculptures.title FROM Sculptures JOIN Artists ON Sculptures.sculptorID = Artists.artistID WHERE Artists.artistID = 222;,SELECT T2.title FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T1.artistID  =  222 UNION SELECT T4.title FROM artists AS T3 JOIN sculptures AS T4 ON T3.artistID  =  T4.sculptorID WHERE T3.artistID  =  222,"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of paintings and sculptures. Since the titles are in two separate tables (""Paintings"" and ""Sculptures""), we will need to combine the results using a UNION. 2. Condition Structure: Use a WHERE clause to filter for records where the artist's ID matches 222. This condition will be applied to both the ""Paintings"" and ""Sculptures"" tables. 3. Join Structure: Use JOINs to connect the ""Paintings"" table with the ""Artists"" table on ""Paintings.painterID = Artists.artistID"" and the ""Sculptures"" table with the ""Artists"" table on ""Sculptures.sculptorID = Artists.artistID."" 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving the titles of works.",1.0
1094,"List the year, location and title of paintings whose height is longer than 1000 ordered by title.",EASY,art_1,"[Paintings.year, Paintings.location, Paintings.title, Paintings.height_mm, 1000]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.year, Paintings.location, Paintings.title FROM Paintings WHERE Paintings.height_mm > 1000 ORDER BY Paintings.title;","SELECT title ,  LOCATION ,  YEAR FROM paintings WHERE height_mm  >  1000 ORDER BY title","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Paintings.year"", ""Paintings.location"", and ""Paintings.title"". 2. Condition Structure: Use a WHERE clause to filter paintings where ""Paintings.height_mm"" is greater than 1000. 3. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data. 5. Ordering Structure: Use ORDER BY on ""Paintings.title"" to sort the results alphabetically by title.",1.0
1095,What are the names of pilots who have either the Piper Cub or the F-14 Fighter?,NON-NESTED,pilot_1,"[PilotSkills.pilot_name,PilotSkills.plane_name,PilotSkills.plane_name = Hangar.plane_name,Hangar.plane_name,Piper Cub,F-14 Fighter]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT DISTINCT PilotSkills.pilot_name FROM PilotSkills WHERE PilotSkills.plane_name = 'Piper Cub' OR PilotSkills.plane_name = 'F-14 Fighter';,SELECT pilot_name FROM pilotskills WHERE plane_name  =  'Piper Cub' OR plane_name  =  'F-14 Fighter',"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of pilots (""PilotSkills.pilot_name"") who are associated with the specified planes (""Piper Cub"" or ""F-14 Fighter""). 2. Condition Structure: Use a WHERE clause to filter for records where ""PilotSkills.plane_name"" matches either ""Piper Cub"" or ""F-14 Fighter."" 3. Join Structure: No JOIN is necessary as the required information is available within the ""PilotSkills"" table. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique pilot names are returned.",1.0
1096,"What are the names of pilots between the ages of 30 and 40, ordered by age ascending?",EASY,pilot_1,"[PilotSkills.pilot_name,PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.pilot_name, PilotSkills.age FROM PilotSkills WHERE PilotSkills.age BETWEEN 30 AND 40 ORDER BY PilotSkills.age ASC;",SELECT pilot_name FROM pilotskills WHERE age BETWEEN 30 AND 40 ORDER BY age,"1. Sequential Structure: Start with the SELECT clause to retrieve the names and ages of pilots. 2. Condition Structure: Use a WHERE clause to filter pilots whose ages are between 30 and 40. 3. Join Structure: No JOIN is required since all necessary information is in the ""PilotSkills"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by age in ascending order.",1.0
1097,What is the name of the oldest pilot?,EASY,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT PilotSkills.pilot_name FROM PilotSkills ORDER BY PilotSkills.age DESC LIMIT 1;,SELECT pilot_name FROM PilotSkills ORDER BY age DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""PilotSkills.pilot_name"" of the oldest pilot. 2. Condition Structure: No specific filtering condition is needed since we are looking for the pilot with the maximum age. 3. Join Structure: No JOIN is required, as all necessary information is available in the ""PilotSkills"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""PilotSkills.age"" to rank pilots by age and apply LIMIT 1 to select the oldest pilot.",1.0
1098,Find all different planes whose names contain substring 'Bomber'.,EASY,pilot_1,[PilotSkills.plane_name],"Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT DISTINCT PilotSkills.plane_name FROM PilotSkills WHERE PilotSkills.plane_name LIKE '%Bomber%';,SELECT DISTINCT plane_name FROM pilotskills WHERE plane_name LIKE '%Bomber%',"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct plane names that contain the substring 'Bomber'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for plane names that contain the substring 'Bomber'. 3. Join Structure: No JOIN is required since all necessary information is in the ""PilotSkills"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct plane names based on a specific condition.",1.0
1099,List all pilot names sorted by their ages in the descending order.,EASY,pilot_1,"[PilotSkills.pilot_name,PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.pilot_name, PilotSkills.age FROM PilotSkills ORDER BY PilotSkills.age DESC;",SELECT pilot_name FROM pilotskills ORDER BY age DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the pilot name and their age. 2. Condition Structure: No specific filtering condition is required as we want all pilot names. 3. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY in descending order on the ""PilotSkills.age"" field to sort the pilots by their ages.",1.0
1100,What is all the information about pilots who are younger than 30 ?,EASY,pilot_1,"[PilotSkills.pilot_name,PilotSkills.plane_name,PilotSkills.age,30]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT * FROM PilotSkills WHERE PilotSkills.age < 30;,select * from pilotskills where age  <  30,"1. Sequential Structure: Begin with the SELECT clause to retrieve all the information about pilots, as the question asks for all details. 2. Condition Structure: Use a WHERE clause to filter pilots whose age is less than 30. 3. Join Structure: No JOIN is required since all necessary information is available in the ""PilotSkills"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving detailed information without summarization.",1.0
1101,What are the medium types of the painting with id = 80,EASY,art_1,"[Paintings.medium, Paintings.paintingID, 80]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.medium FROM Paintings WHERE Paintings.paintingID = 80;,SELECT medium FROM paintings WHERE paintingID  =  80,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the ""medium"" of the painting. 2. Condition Structure: Use a WHERE clause to filter for the painting with ""paintingID"" equal to 80. 3. Join Structure: No JOIN is required since all necessary information is in the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a specific field based on a condition.",1.0
1102,Find the number of pilots for the plane types with average pilot age below 35.,NESTED,pilot_1,"[PilotSkills.plane_name, PilotSkills.age, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.plane_name, COUNT(PilotSkills.plane_name) AS num_pilots FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name GROUP BY PilotSkills.plane_name HAVING AVG(PilotSkills.age) < 35;","SELECT count(*) ,  plane_name FROM pilotskills GROUP BY plane_name HAVING avg(age)  <  35",1. Sequential Structure: Start with the SELECT clause to count the number of pilots for each plane type. Use the FROM clause to specify the PilotSkills table and JOIN it with the Hangar table to connect pilots with their respective plane types. Use GROUP BY to group data by plane type and calculate the average age of pilots for each plane type. Apply a HAVING clause to filter plane types with an average pilot age below 35. 2. Condition Structure: Use the HAVING clause to filter plane types where the average pilot age is less than 35. 3. Join Structure: Use an INNER JOIN between the PilotSkills and Hangar tables based on the plane_name field to connect pilots with their respective planes. 4. Aggregation Structure: Use COUNT to count the number of pilots for each plane type and AVG to calculate the average age of pilots for each plane type.,1.0
1103,What are the titles of paintings that have a width less than 600 or a height taller taller than 800?,EASY,art_1,"[Paintings.title, Paintings.width_mm, Paintings.height_mm]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.title FROM Paintings WHERE Paintings.width_mm < 600 OR Paintings.height_mm > 800;,SELECT title FROM paintings WHERE width_mm  <  600 OR height_mm  >  800,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the title of the paintings. 2. Condition Structure: Use a WHERE clause to filter paintings where the width is less than 600 or the height is greater than 800. 3. Join Structure: No JOIN is required since all necessary information is in the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving titles based on specific conditions.",1.0
1104,What is the average height and width of paintings that are oil medium in gallery 241?,EASY,art_1,"[Paintings.height_mm, Paintings.width_mm, Paintings.medium, Paintings.location, oil, 241]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT AVG(Paintings.height_mm) AS avg_height, AVG(Paintings.width_mm) AS avg_width FROM Paintings WHERE Paintings.medium = 'oil' AND Paintings.location = '241';","SELECT avg(height_mm) ,  avg(width_mm) FROM paintings WHERE medium  =  ""oil"" AND LOCATION  =  ""Gallery 241""","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the average height and average width of paintings. 2. Condition Structure: Use a WHERE clause to filter for paintings that have the medium as ""oil"" and are located in gallery ""241"". 3. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table. 4. Aggregation Structure: Use AVG to calculate the average height and average width of the filtered paintings.",0.0
1105,Find the average points and average ages of all spokesmen whose rank position is 1.,EASY,district_spokesman,"[spokesman.Points, spokesman.Age, spokesman.Rank_position]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
","SELECT AVG(spokesman.Points) AS avg_points, AVG(spokesman.Age) AS avg_age FROM spokesman WHERE spokesman.Rank_position = 1;","SELECT avg(points) ,  avg(age) FROM spokesman WHERE rank_position  =  1","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the average points and average ages of spokesmen. 2. Condition Structure: Use a WHERE clause to filter for spokesmen whose ""Rank_position"" is 1. 3. Aggregation Structure: Use the AVG function to calculate the average points and average ages of the filtered spokesmen. 4. Join Structure: No JOIN is required since all necessary data is within the ""spokesman"" table.",1.0
1106,Give the different entrant types for drivers at least 20 years old.,EASY,car_road_race,"[driver.Entrant, driver.Age]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT DISTINCT driver.Entrant FROM driver WHERE driver.Age >= 20;,SELECT DISTINCT Entrant FROM driver WHERE Age  >=  20,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct entrant types from the ""driver"" table. 2. Condition Structure: Use a WHERE clause to filter for drivers who are at least 20 years old. 3. Join Structure: No JOIN is required since all necessary information is in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct entrant types based on the specified condition.",1.0
1107,What is the id of the oldest painting?,EASY,art_1,"[Paintings.paintingID, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.paintingID FROM Paintings ORDER BY Paintings.year ASC LIMIT 1;,SELECT paintingID FROM paintings ORDER BY YEAR LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paintings.paintingID"" of the oldest painting. 2. Condition Structure: No specific filtering condition is needed since we are looking for the painting with the earliest year. 3. Join Structure: No JOIN is required as all necessary information is in the ""Paintings"" table. 4. Aggregation Structure: Use ORDER BY on ""Paintings.year"" in ascending order to find the oldest painting and apply LIMIT 1 to retrieve only the ID of the oldest painting.",1.0
1108,Find the names of districts whose government links use a 'gov' domain.,EASY,district_spokesman,"[district.Name, district.Government_website]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
",SELECT district.Name FROM district WHERE district.Government_website LIKE '%.gov%';,"SELECT name FROM district WHERE Government_website LIKE ""%gov%""","1. Sequential Structure: Start with the SELECT clause to retrieve the names of districts. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for government websites that contain the '.gov' domain. 3. Join Structure: No JOIN is required since all necessary information is in the ""district"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving district names based on a specific condition.",1.0
1109,What are the maximum height and width of paintings for each year?,EASY,art_1,"[Paintings.year, Paintings.height_mm, Paintings.width_mm]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.year, MAX(Paintings.height_mm) AS max_height, MAX(Paintings.width_mm) AS max_width FROM Paintings GROUP BY Paintings.year;","SELECT max(height_mm) ,  max(width_mm) ,  YEAR FROM paintings GROUP BY YEAR ORDER BY YEAR","1. Sequential Structure: Begin with the SELECT clause to specify the year and the required aggregate values, which are the maximum height and width of paintings. 2. Aggregation Structure: Use MAX functions to calculate the maximum height and maximum width for paintings in each year. 3. Grouping Structure: Use GROUP BY on ""Paintings.year"" to calculate these aggregate values for each year. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table.",1.0
1110,"What are the different hangar locations and how many pilots correspond to each. Also, what are their average ages?",NON-NESTED,pilot_1,"[Hangar.location, PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT Hangar.location, COUNT(PilotSkills.pilot_name) AS num_pilots, AVG(PilotSkills.age) AS avg_age FROM Hangar JOIN PilotSkills ON PilotSkills.plane_name = Hangar.plane_name GROUP BY Hangar.location;","SELECT count(T1.pilot_name) ,  avg(T1.age) ,  T2.location FROM pilotskills AS T1 JOIN hangar AS T2 ON T1.plane_name  =  T2.plane_name GROUP BY T2.location","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct hangar locations, the count of pilots corresponding to each location, and the average age of pilots. Use ""Hangar.location"" for the hangar locations, COUNT for the number of pilots, and AVG for the average age of pilots. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Hangar"" and ""PilotSkills"" tables based on the relationship ""PilotSkills.plane_name = Hangar.plane_name"" to associate pilots with their respective hangar locations. 4. Aggregation Structure: Use COUNT to calculate the number of pilots and AVG to compute the average age of pilots for each hangar location. Use GROUP BY on ""Hangar.location"" to group the results by hangar location.",1.0
1111,How many pilots are older than the youngest pilot who has Piper Cub?,NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name, Piper Cub]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(*) FROM PilotSkills WHERE age > (SELECT MIN(age) FROM PilotSkills WHERE plane_name = 'Piper Cub');,SELECT count(pilot_name) FROM pilotskills WHERE age  >  (SELECT min(age) FROM pilotskills WHERE plane_name  =  'Piper Cub'),"1. Sequential Structure: Start with the SELECT clause to count the number of pilots. Use the FROM clause to specify the PilotSkills table. Apply a WHERE clause to filter pilots whose age is greater than the age of the youngest pilot who has a ""Piper Cub"". 2. Condition Structure: Use a subquery in the WHERE clause to find the age of the youngest pilot who has a ""Piper Cub"". The subquery filters for pilots with the plane_name ""Piper Cub"" and retrieves the minimum age. 3. Join Structure: Not required, as all necessary data is available in the PilotSkills table. 4. Aggregation Structure: Use the COUNT function to count the number of pilots who satisfy the age condition.",1.0
1112,Please show the age of the driver who participated in the most number of races.,NON-NESTED,car_road_race,"[driver.Age, race.Driver_ID, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Age FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID GROUP BY race.Driver_ID ORDER BY COUNT(race.Driver_ID) DESC LIMIT 1;,SELECT T1.Age FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID GROUP BY T1.Driver_ID ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Age"" of the driver who participated in the most races. Use COUNT to count the number of races each driver participated in. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the driver with the maximum number of races. 3. Join Structure: Use a JOIN between the ""driver"" and ""race"" tables based on ""Driver_ID"" to associate each driver with their race records. 4. Aggregation Structure: Use COUNT to count the number of races for each driver, GROUP BY ""race.Driver_ID"" to group the counts by driver, and ORDER BY the count in descending order to find the driver with the most races. Use LIMIT 1 to select the top result.",1.0
1113,Which locations have paintings created before 1885 or after 1930?,EASY,art_1,"[Paintings.location, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.location FROM Paintings WHERE Paintings.year < 1885 OR Paintings.year > 1930;,SELECT DISTINCT LOCATION FROM paintings WHERE YEAR  < 1885 OR YEAR  >  1930,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the location of the paintings. 2. Condition Structure: Use a WHERE clause to filter paintings created before 1885 or after 1930 based on the ""Paintings.year"" field. 3. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving locations that meet the specified year conditions.",1.0
1114,What are the locations that have paintings in the mediums of on panels and on canvas?,NESTED,art_1,"[Paintings.location, Paintings.medium, on panels, on canvas]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT DISTINCT location FROM Paintings WHERE medium IN ('ON panels', 'ON canvas');","SELECT DISTINCT LOCATION FROM paintings WHERE mediumOn  =  ""panel"" INTERSECT SELECT DISTINCT LOCATION FROM paintings WHERE mediumOn  =  ""canvas""","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct locations. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter for paintings with mediums ""on panels"" or ""on canvas"". 2. Condition Structure: Use the WHERE clause with conditions to filter for paintings where the medium is either ""on panels"" or ""on canvas"". 3. Join Structure: Not required, as all the necessary data is available in the Paintings table. 4. Aggregation Structure: Not required, as we are retrieving distinct locations without any aggregation.",0.0
1115,"Return the different constructors of drivers, ordered by age ascending.",EASY,car_road_race,"[driver.Constructor, driver.Age]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT DISTINCT driver.Constructor FROM driver ORDER BY driver.Age ASC;,SELECT DISTINCT CONSTRUCTOR FROM driver ORDER BY Age ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the distinct constructors of drivers. 2. Condition Structure: No specific filtering condition is required as we want all constructors. 3. Join Structure: No JOIN is needed since all necessary information is available in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by ""driver.Age"" in ascending order.",1.0
1116,Count the number of pilots with age greater than 40.,EASY,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(PilotSkills.pilot_name) FROM PilotSkills WHERE PilotSkills.age > 40;,SELECT count(*) FROM pilotskills WHERE age  >  40,"1. Sequential Structure: Start with the SELECT clause to count the number of pilots. 2. Condition Structure: Use a WHERE clause to filter pilots whose age is greater than 40. 3. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table. 4. Aggregation Structure: Use COUNT to calculate the number of pilots meeting the age condition.",1.0
1117,What are the first and last names of the artists who did not sculpt but could paint.,NESTED,art_1,"[Artists.artistID,Artists.lname,Artists.fname,Paintings.painterID,Paintings.painterID = Artists.artistID,Sculptures.sculptorID,Sculptures.sculptorID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.fname, Artists.lname FROM Artists WHERE Artists.artistID IN (SELECT painterID FROM Paintings) AND Artists.artistID NOT IN (SELECT sculptorID FROM Sculptures);","SELECT T1.lname ,  T1.fname FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID EXCEPT SELECT T3.lname ,  T3.fname FROM artists AS T3 JOIN sculptures AS T4 ON T3.artistID  =  T4.sculptorID","1. Sequential Structure: Start with the SELECT clause to retrieve the first and last names of artists. Use the FROM clause to specify the Artists table. Apply a WHERE clause to filter for artists who did not sculpt but could paint. 2. Condition Structure: Use the WHERE clause with a subquery to exclude artists whose artistID appears in the Sculptures table (indicating they sculpted). Additionally, ensure the artistID appears in the Paintings table (indicating they could paint). 3. Join Structure: Not required, as the filtering conditions can be applied using subqueries on the Paintings and Sculptures tables. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1118,Return the names of planes owned by the pilot whose name is Smith and is 41 years old.,NON-NESTED,pilot_1,"[PilotSkills.plane_name, PilotSkills.pilot_name, PilotSkills.age, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT Hangar.plane_name FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE PilotSkills.pilot_name = 'Smith' AND PilotSkills.age = 41;,SELECT plane_name FROM pilotskills WHERE pilot_name  =  'Smith' AND age  =  41,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""plane_name"" from the relevant tables. 2. Condition Structure: Use a WHERE clause to filter for the pilot whose name is ""Smith"" and age is 41. 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the shared ""plane_name"" field to link planes with their respective pilots. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific plane names.",1.0
1119,Find the locations that have paintings before 1885 and no work with medium on canvas?,NESTED,art_1,"[Paintings.location, Paintings.year, Paintings.medium, Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT location FROM Paintings WHERE year < 1885 AND location NOT IN ( SELECT DISTINCT location FROM Paintings WHERE medium = 'canvas' );,"SELECT DISTINCT LOCATION FROM paintings WHERE YEAR  <  1885 AND mediumOn != ""canvas""","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct locations from the Paintings table. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter for paintings created before 1885 and exclude locations that have any painting with the medium ""canvas"". 2. Condition Structure: Use the WHERE clause to filter for paintings with a year before 1885. Additionally, use a subquery to exclude locations that have any painting with the medium ""canvas"". 3. Join Structure: Not required, as all necessary data is available in the Paintings table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1120,How many different engines are used by drivers with age older than 30 or younger than 20?,EASY,car_road_race,"[driver.Engine, driver.Age]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT COUNT(DISTINCT driver.Engine) FROM driver WHERE driver.Age > 30 OR driver.Age < 20;,SELECT count(DISTINCT Engine) FROM driver WHERE Age  >  30 OR Age  <  20,"1. Sequential Structure: Begin with the SELECT clause to count the distinct engines used by drivers. 2. Condition Structure: Use a WHERE clause to filter for drivers whose age is either greater than 30 or less than 20. 3. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""driver.Engine"" to count the unique engines used by the filtered drivers.",1.0
1121,What are the planes owned by pilot Smith with age 41?,NON-NESTED,pilot_1,"[PilotSkills.plane_name, PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT PilotSkills.plane_name FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE PilotSkills.pilot_name = 'Smith' AND PilotSkills.age = 41;,SELECT plane_name FROM pilotskills WHERE pilot_name  =  'Smith' AND age  =  41,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""plane_name"" of planes owned by the pilot. 2. Condition Structure: Use a WHERE clause to filter for records where the ""pilot_name"" is 'Smith' and the ""age"" is 41. 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the ""plane_name"" field to link pilots with the planes they own. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific plane names.",1.0
1122,"For each city, find the number and average age of pilots who have a plane.",NON-NESTED,pilot_1,"[Hangar.location, PilotSkills.age, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT Hangar.location, COUNT(PilotSkills.age) AS number_of_pilots, AVG(PilotSkills.age) AS average_age FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name GROUP BY Hangar.location;","SELECT count(T1.pilot_name) ,  avg(T1.age) ,  T2.location FROM pilotskills AS T1 JOIN hangar AS T2 ON T1.plane_name  =  T2.plane_name GROUP BY T2.location","1. Sequential Structure: Start with the SELECT clause to retrieve the city (Hangar.location), the count of pilots, and the average age of pilots. Use COUNT and AVG for the number and average age of pilots, respectively. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the relationship ""PilotSkills.plane_name = Hangar.plane_name"" to associate pilots with the planes they have and the corresponding city. 4. Aggregation Structure: Use COUNT to count the number of pilots and AVG to calculate the average age of pilots. Group the results by ""Hangar.location"" to get the data for each city.",1.0
1123,What are the names of everbody who has participated in both the ACL and NACCL conferences?,NESTED,conference,"[staff.name, conference.Conference_Name, conference_participation.Conference_ID = conference.Conference_ID, conference_participation.staff_ID = staff.staff_ID, ACL, NACCL]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT staff.name FROM staff JOIN conference_participation ON staff.staff_ID = conference_participation.staff_ID JOIN conference ON conference_participation.Conference_ID = conference.Conference_ID WHERE conference.Conference_Name IN ('ACL', 'NACCL') GROUP BY staff.staff_ID, staff.name HAVING COUNT(DISTINCT conference.Conference_Name) = 2;",SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 JOIN Conference AS T3 ON T1.staff_id  =  T2.staff_id AND T2.conference_id  =  T3.conference_id WHERE T3.Conference_name  =  'ACL' INTERSECT SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 JOIN conference AS T3 ON T1.staff_id  =  T2.staff_id AND T2.conference_id  =  T3.conference_id WHERE T3.Conference_name  =  'Naccl',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of staff members. Use the FROM clause to specify the staff table and JOIN it with the conference_participation table to link staff members with their conference participation. Further, JOIN the conference table to identify the specific conferences (ACL and NACCL). Use a WHERE clause to filter for staff members who participated in both ACL and NACCL conferences. 2. Condition Structure: Use the WHERE clause to filter for conference names 'ACL' and 'NACCL'. Use a subquery or grouping to ensure that only staff members who participated in both conferences are selected. 3. Join Structure: Use INNER JOINs between the staff, conference_participation, and conference tables based on their respective keys (staff_ID and Conference_ID) to connect staff members with their conference participation and the conference details. 4. Aggregation Structure: Use GROUP BY on staff_ID and HAVING COUNT(DISTINCT conference.Conference_Name) = 2 to ensure that only staff members who participated in both conferences are included.",0.0
1124,Select the area and government website of the district with the smallest population.,NESTED,district_spokesman,"[district.Area_km, district.Government_website, district.Population]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
","SELECT Area_km, Government_website FROM district WHERE Population = (SELECT MIN(Population) FROM district);","SELECT area_km ,  Government_website FROM district ORDER BY Population LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the area and government website of the district. Use the FROM clause to specify the district table. Apply a WHERE clause to filter for the district with the smallest population. 2. Condition Structure: Use the WHERE clause with a subquery to identify the district with the smallest population. The subquery calculates the minimum population from the district table. 3. Join Structure: Not required, as all data is available within the district table. 4. Aggregation Structure: Use the MIN function in a subquery to find the smallest population, which is then used in the filtering condition.",1.0
1125,What are the unique first names of the artists who had medium oil paintings located in gallery 241?,NON-NESTED,art_1,"[Artists.fname,Paintings.medium,Paintings.location,Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT Artists.fname FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID WHERE Paintings.medium = 'oil' AND Paintings.location = 'gallery 241';,"SELECT DISTINCT T1.fname FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T2.medium  =  ""oil"" AND LOCATION  =  ""Gallery 241""","1. Sequential Structure: Start with the SELECT clause to retrieve the unique first names of artists, i.e., ""Artists.fname."" 2. Condition Structure: Use a WHERE clause to filter for paintings with the medium ""oil"" and located in ""gallery 241."" 3. Join Structure: Use a JOIN between the ""Paintings"" and ""Artists"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to link paintings with their respective artists. 4. Aggregation Structure: Use DISTINCT to ensure that only unique first names of artists are returned.",0.0
1126,Give the full name of the artist who lived the longest.,EASY,art_1,"[Artists.lname, Artists.fname, Artists.birthYear, Artists.deathYear]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Artists.fname || ' ' || Artists.lname AS full_name FROM Artists ORDER BY (Artists.deathYear - Artists.birthYear) DESC LIMIT 1;,"SELECT lname ,  fname FROM artists ORDER BY deathYear - birthYear DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the full name of the artist, which includes ""Artists.fname"" and ""Artists.lname"". 2. Condition Structure: No specific filtering condition is required, as we are looking for the artist who lived the longest. 3. Join Structure: No JOIN is required since all necessary information is in the ""Artists"" table. 4. Aggregation Structure: Calculate the lifespan of each artist by subtracting ""Artists.birthYear"" from ""Artists.deathYear"". Use ORDER BY in descending order on the calculated lifespan and apply LIMIT 1 to select the artist who lived the longest.",1.0
1127,Show all names who have been in both ACL and Naccl.,NESTED,conference,"[staff.name, conference.Conference_Name, conference_participation.Conference_ID = conference.Conference_ID, conference_participation.staff_ID = staff.staff_ID, ACL, Naccl]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT staff.name FROM staff JOIN conference_participation ON staff.staff_ID = conference_participation.staff_ID JOIN conference ON conference_participation.Conference_ID = conference.Conference_ID WHERE 'ACL' IN (SELECT Conference_Name FROM conference WHERE conference.Conference_ID = conference_participation.Conference_ID) AND 'Naccl' IN (SELECT Conference_Name FROM conference WHERE conference.Conference_ID = conference_participation.Conference_ID);,SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 JOIN Conference AS T3 ON T1.staff_id  =  T2.staff_id AND T2.conference_id  =  T3.conference_id WHERE T3.Conference_name  =  'ACL' INTERSECT SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 JOIN conference AS T3 ON T1.staff_id  =  T2.staff_id AND T2.conference_id  =  T3.conference_id WHERE T3.Conference_name  =  'Naccl',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of staff members. Use the FROM clause to specify the staff table and JOIN it with the conference_participation table to link staff members with their conference participations. Further, JOIN the conference table to get the conference names. Use a WHERE clause to filter for staff members who participated in both ""ACL"" and ""Naccl"". 2. Condition Structure: Use a WHERE clause with subqueries to ensure that the staff member's ID is associated with both ""ACL"" and ""Naccl"" in the conference table. 3. Join Structure: Use INNER JOINs between the staff, conference_participation, and conference tables based on their respective keys (staff_ID and Conference_ID) to connect staff members with their conference participations and conference names. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1128,Find the names and years of all sculptures that are not located in gallery 226.,NESTED,art_1,"[Sculptures.title, Sculptures.year, Sculptures.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT title, year FROM Sculptures WHERE location != '226';","SELECT title ,  YEAR FROM sculptures WHERE LOCATION != ""Gallery 226""","1. Sequential Structure: Start with the SELECT clause to retrieve the names (titles) and years of sculptures. Use the FROM clause to specify the Sculptures table. Apply a WHERE clause to filter out sculptures that are located in gallery 226. 2. Condition Structure: Use the WHERE clause to exclude sculptures whose location is '226'. 3. Join Structure: Not required, as all data is available within the Sculptures table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1129,Count the number of entries for each plane name.,EASY,pilot_1,[PilotSkills.plane_name],"Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.plane_name, COUNT(*) AS entry_count FROM PilotSkills GROUP BY PilotSkills.plane_name;","SELECT count(*) ,  plane_name FROM pilotskills GROUP BY plane_name","1. Sequential Structure: Begin with the SELECT clause to specify the plane name and the count of entries for each plane. 2. Aggregation Structure: Use COUNT to calculate the number of entries for each plane name. 3. Grouping Structure: Use GROUP BY on ""PilotSkills.plane_name"" to group the results by each plane name. 4. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table.",1.0
1130,What are the names of the staff members who have been both a speaker and a sponsor at some conference?,NESTED,conference,"[staff.name, conference_participation.role, conference_participation.staff_ID = staff.staff_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT staff.name FROM staff JOIN conference_participation ON staff.staff_ID = conference_participation.staff_ID WHERE staff.staff_ID IN ( SELECT staff_ID FROM conference_participation WHERE role = 'Speaker' ) AND staff.staff_ID IN ( SELECT staff_ID FROM conference_participation WHERE role = 'Sponsor' );,SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.role  =  'Speaker' INTERSECT SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.role  =  'Sponsor',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of staff members. Use the FROM clause to specify the staff table and JOIN it with the conference_participation table to link staff members with their roles in conferences. Use a WHERE clause to filter for staff members who have been both a speaker and a sponsor. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the staff member's ID appears in the conference_participation table with both roles ('Speaker' and 'Sponsor'). 3. Join Structure: Use an INNER JOIN between the staff and conference_participation tables based on the staff_ID to connect staff members with their conference roles. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1131,List the title and location of all paintings.,EASY,art_1,"[Paintings.title, Paintings.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.title, Paintings.location FROM Paintings;","SELECT title ,  LOCATION FROM paintings","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""title"" and ""location"" of the paintings. 2. Condition Structure: No specific filtering condition is required as the query asks for all paintings. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the title and location of all paintings.",1.0
1132,Find the total and average population of the districts which have some spokesman.,NON-NESTED,district_spokesman,"[district.Population, spokesman_district.District_ID = district.District_ID, spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
","SELECT SUM(district.Population) AS Total_Population, AVG(district.Population) AS Average_Population FROM district JOIN spokesman_district ON district.District_ID = spokesman_district.District_ID JOIN spokesman ON spokesman_district.Spokesman_ID = spokesman.Spokesman_ID;","SELECT sum(population) ,  avg(population) FROM district WHERE district_id IN (SELECT district_id FROM spokesman_district)","1. Sequential Structure: Start with the SELECT clause to retrieve the total and average population of districts. Use SUM and AVG aggregate functions on the ""district.Population"" field. 2. Condition Structure: Use a WHERE clause to filter districts that have a spokesman. This can be determined by checking the existence of a relationship between ""spokesman_district"" and ""spokesman"" tables. 3. Join Structure: Use JOINs to connect ""district"" with ""spokesman_district"" on ""District_ID"" and ""spokesman_district"" with ""spokesman"" on ""Spokesman_ID"" to ensure only districts with spokesmen are considered. 4. Aggregation Structure: Use SUM and AVG to calculate the total and average population of the filtered districts.",0.0
1133,Find the names of all sculptures located in gallery 226.,EASY,art_1,"[Sculptures.title,Sculptures.location,226]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Sculptures.title FROM Sculptures WHERE Sculptures.location = 226;,"SELECT title FROM sculptures WHERE LOCATION  =  ""Gallery 226""","1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the name of the sculptures. 2. Condition Structure: Use a WHERE clause to filter sculptures located in gallery 226. 3. Join Structure: No JOIN is required since all necessary information is in the ""Sculptures"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of sculptures based on a specific condition.",0.0
1134,What are the distinct entrant types of drivers aged 20 or older?,EASY,car_road_race,"[driver.Entrant, driver.Age]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT DISTINCT driver.Entrant FROM driver WHERE driver.Age >= 20;,SELECT DISTINCT Entrant FROM driver WHERE Age  >=  20,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct entrant types from the ""driver"" table. 2. Condition Structure: Use a WHERE clause to filter for drivers aged 20 or older. 3. Join Structure: No JOIN is required since all necessary information is in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct entrant types based on the specified condition.",1.0
1135,How many works are there in each medium?,NON-NESTED,art_1,"[Paintings.medium, Sculptures.medium]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT medium, COUNT(*) AS work_count FROM Paintings GROUP BY medium UNION SELECT medium, COUNT(*) AS work_count FROM Sculptures GROUP BY medium;","SELECT count(*) ,  medium FROM paintings GROUP BY medium","1. Sequential Structure: Start with the SELECT clause to retrieve the ""medium"" and the count of works for each medium. Use COUNT to count the number of works grouped by medium. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: No JOIN is required since the mediums are in separate tables (""Paintings"" and ""Sculptures""). We can use a UNION to combine the results from both tables. 4. Aggregation Structure: Use COUNT to aggregate the number of works for each medium and GROUP BY ""medium"" to group the results by medium.",1.0
1136,In what locations and on what mediums are the paintings created by the artist with the first name Pablo?,NON-NESTED,art_1,"[Artists.fname, Paintings.location, Paintings.medium, Paintings.painterID = Artists.artistID, Pablo]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.location, Paintings.medium FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID WHERE Artists.fname = 'Pablo';","SELECT T2.location ,   T2.medium FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T1.fname  =  ""Pablo""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paintings.location"" and ""Paintings.medium"" fields, as the question asks for the locations and mediums of paintings. 2. Condition Structure: Use a WHERE clause to filter for the artist with the first name ""Pablo."" This requires filtering on the ""Artists.fname"" field. 3. Join Structure: Use a JOIN between the ""Paintings"" and ""Artists"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to link paintings to their respective artists. 4. Aggregation Structure: No aggregation is needed, as the question does not require any summarization or grouping of data.",1.0
1137,How many different places have some plane?,NON-NESTED,pilot_1,"[Hangar.location,Hangar.plane_name,PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(DISTINCT Hangar.location) FROM Hangar JOIN PilotSkills ON PilotSkills.plane_name = Hangar.plane_name;,SELECT count(DISTINCT LOCATION) FROM hangar,"1. Sequential Structure: Start with the SELECT clause to count the distinct locations where planes are present. Use COUNT with DISTINCT on ""Hangar.location."" 2. Condition Structure: No specific filtering condition is required since the question asks for all locations with planes. 3. Join Structure: Use a JOIN between the ""Hangar"" and ""PilotSkills"" tables based on the ""plane_name"" field to ensure that only planes listed in both tables are considered. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique locations where planes are present.",1.0
1138,What are the first and last names of the artists who have not only medium oil paintings but also paintings with the lithographic medium?,NESTED,art_1,"[Artists.lname, Artists.fname, Paintings.medium, Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.fname, Artists.lname FROM Artists JOIN Paintings ON Paintings.painterID = Artists.artistID WHERE Paintings.medium IN ('oil', 'lithographic') GROUP BY Artists.artistID, Artists.fname, Artists.lname HAVING COUNT(DISTINCT Paintings.medium) = 2;","SELECT T1.lname ,  T1.fname FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T2.medium  =  ""oil"" INTERSECT SELECT T3.lname ,  T3.fname FROM artists AS T3 JOIN paintings AS T4 ON T3.artistID  =  T4.painterID WHERE T4.medium  =  ""lithograph""","1. Sequential Structure: Start with the SELECT clause to retrieve the first and last names of the artists. Use the FROM clause to specify the Artists table and JOIN it with the Paintings table to connect artists with their paintings. Apply a WHERE clause to filter for artists who have paintings in both ""oil"" and ""lithographic"" mediums. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the artist has paintings in both ""oil"" and ""lithographic"" mediums. This can be achieved by grouping the paintings by the artist and checking for the presence of both mediums. 3. Join Structure: Use an INNER JOIN between the Artists and Paintings tables based on the relationship between painterID and artistID to link artists with their paintings. 4. Aggregation Structure: Use GROUP BY to group paintings by artistID and HAVING to ensure that the count of distinct mediums includes both ""oil"" and ""lithographic"".",0.0
1139,Find the name of the district which has the largest area.,EASY,district_spokesman,"[district.Name, district.Area_km]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
",SELECT district.Name FROM district ORDER BY district.Area_km DESC LIMIT 1;,SELECT name FROM district ORDER BY Area_km DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""district.Name"" of the district with the largest area. 2. Condition Structure: No specific filtering condition is needed since we are looking for the district with the maximum area. 3. Join Structure: No JOIN is required, as all necessary information is available in the ""district"" table. 4. Aggregation Structure: Use MAX to find the largest area and ORDER BY in descending order on ""district.Area_km"" to rank districts by area. Apply LIMIT 1 to select the district with the largest area.",1.0
1140,What are the different plane names that contain the word Bomber?,EASY,pilot_1,[PilotSkills.plane_name],"Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT DISTINCT PilotSkills.plane_name FROM PilotSkills WHERE PilotSkills.plane_name LIKE '%Bomber%';,SELECT DISTINCT plane_name FROM pilotskills WHERE plane_name LIKE '%Bomber%',"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct plane names that contain the word ""Bomber"". 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for plane names that contain the word ""Bomber"". 3. Join Structure: No JOIN is required since all necessary information is in the ""PilotSkills"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct plane names based on a specific condition.",1.0
1141,What are the maximum height and id of paintings painted before 1900?,EASY,art_1,"[Paintings.height_mm, Paintings.paintingID, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT MAX(Paintings.height_mm) AS max_height, Paintings.paintingID FROM Paintings WHERE Paintings.year < 1900;","SELECT max(height_mm) ,  paintingID FROM paintings WHERE YEAR  <  1900","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the maximum height and the ID of the paintings. 2. Condition Structure: Use a WHERE clause to filter for paintings that were painted before the year 1900. 3. Aggregation Structure: Use the MAX function to calculate the maximum height of the paintings that meet the condition. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table.",1.0
1142,When did the artist who made the fewest sculptures die?,NESTED,art_1,"[Sculptures.sculptureID, Sculptures.sculptorID, Artists.artistID = Sculptures.sculptorID, Artists.deathYear]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.deathYear FROM Artists JOIN Sculptures ON Artists.artistID = Sculptures.sculptorID GROUP BY Artists.artistID, Artists.deathYear ORDER BY COUNT(Sculptures.sculptureID) ASC LIMIT 1;",SELECT T1.deathYear FROM artists AS T1 JOIN sculptures AS T2 ON T1.artistID  =  T2.sculptorID GROUP BY T2.sculptorID ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the death year of the artist. Use the FROM clause to specify the Artists table and JOIN it with the Sculptures table to connect artists with their sculptures. Use GROUP BY to group sculptures by artist and COUNT to determine the number of sculptures made by each artist. Use ORDER BY to sort the artists by the number of sculptures in ascending order and LIMIT to select the artist with the fewest sculptures. 2. Condition Structure: No specific WHERE clause is needed, as we are interested in all artists and their sculpture counts. 3. Join Structure: Use an INNER JOIN between the Artists and Sculptures tables based on the sculptorID and artistID to link artists with their sculptures. 4. Aggregation Structure: Use COUNT to calculate the number of sculptures per artist and ORDER BY to sort by this count in ascending order. Use LIMIT 1 to select the artist with the fewest sculptures.",1.0
1143,"Return the names and ages of pilors who have flown Piper Cub and are older than 35, or have flown the F-14 Fighter and are younger than 30.",NON-NESTED,pilot_1,"[PilotSkills.pilot_name,PilotSkills.age,PilotSkills.plane_name,Hangar.plane_name,PilotSkills.plane_name = Hangar.plane_name,Piper Cub,F-14 Fighter,35,30]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.pilot_name, PilotSkills.age FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE (PilotSkills.plane_name = 'Piper Cub' AND PilotSkills.age > 35) OR (PilotSkills.plane_name = 'F-14 Fighter' AND PilotSkills.age < 30);","SELECT pilot_name ,  age FROM pilotskills WHERE plane_name  =  'Piper Cub' AND age  >  35 UNION SELECT pilot_name ,  age FROM pilotskills WHERE plane_name  =  'F-14 Fighter' AND age  <  30","1. Sequential Structure: Start with the SELECT clause to retrieve the ""PilotSkills.pilot_name"" and ""PilotSkills.age."" 2. Condition Structure: Use a WHERE clause to filter pilots based on the conditions: (a) they have flown the ""Piper Cub"" and are older than 35, or (b) they have flown the ""F-14 Fighter"" and are younger than 30. 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the shared key ""PilotSkills.plane_name = Hangar.plane_name"" to ensure we are considering only valid plane records. 4. Aggregation Structure: No aggregation is needed as the query focuses on individual pilot records.",1.0
1144,Which spokesman has lower points than the average?,NESTED,district_spokesman,[spokesman.Points],"Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
",SELECT * FROM spokesman WHERE Points < (SELECT AVG(Points) FROM spokesman);,SELECT name FROM spokesman WHERE points  <  (SELECT avg(points) FROM spokesman),"1. Sequential Structure: Start with the SELECT clause to retrieve the spokesman's details (e.g., name or identifier). Use the FROM clause to specify the spokesman table. Apply a WHERE clause to filter for spokesmen whose points are below the average. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average points of all spokesmen and filter for those with points below this value. 3. Join Structure: Not required, as all data is in the spokesman table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average points, which is then used in the filtering condition.",1.0
1145,Count the number of different engines used by drivers who had an age either over 30 or under 20.,NON-NESTED,car_road_race,"[driver.Engine, driver.Age, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT COUNT(DISTINCT driver.Engine) FROM driver WHERE driver.Age > 30 OR driver.Age < 20;,SELECT count(DISTINCT Engine) FROM driver WHERE Age  >  30 OR Age  <  20,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""driver.Engine"" values. 2. Condition Structure: Use a WHERE clause to filter for drivers whose age is either over 30 or under 20. 3. Join Structure: No JOIN is necessary here, as the required information is available in the ""driver"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique engine types used by the filtered drivers.",1.0
1146,Find the number of planes for each type.,NON-NESTED,pilot_1,"[PilotSkills.plane_name, Hangar.plane_name = PilotSkills.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.plane_name, COUNT(*) AS plane_count FROM PilotSkills GROUP BY PilotSkills.plane_name;","SELECT count(*) ,  plane_name FROM pilotskills GROUP BY plane_name","1. Sequential Structure: Start with the SELECT clause to retrieve the ""plane_name"" and the count of planes for each type. Use COUNT to count the number of planes. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: No JOIN is necessary since the query only involves the ""PilotSkills"" table. 4. Aggregation Structure: Use COUNT to count the number of planes for each type and GROUP BY ""plane_name"" to group the results by plane type.",1.0
1147,What is the id of the artist who has the highest number of painting works before 1900?,NON-NESTED,art_1,"[Artists.artistID, Paintings.painterID, Paintings.year, Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Artists.artistID FROM Artists JOIN Paintings ON Paintings.painterID = Artists.artistID WHERE Paintings.year < 1900 GROUP BY Paintings.painterID ORDER BY COUNT(Paintings.painterID) DESC LIMIT 1;,SELECT T1.artistID FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T2.year  <  1900 GROUP BY T1.artistID ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Artists.artistID"" of the artist with the highest number of painting works before 1900. Use COUNT to count the number of paintings for each artist. 2. Condition Structure: Use a WHERE clause to filter for paintings created before the year 1900. 3. Join Structure: Use a JOIN between the ""Artists"" and ""Paintings"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to associate paintings with their respective artists. 4. Aggregation Structure: Use COUNT to count the number of paintings for each artist, GROUP BY ""Paintings.painterID"" to group the results by artist, and ORDER BY the count in descending order. Use LIMIT 1 to select the artist with the highest count.",1.0
1148,Count the number of pilots with age greater than 40 or less than 30.,EASY,pilot_1,"[PilotSkills.age,PilotSkills.pilot_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(PilotSkills.pilot_name) FROM PilotSkills WHERE PilotSkills.age > 40 OR PilotSkills.age < 30;,SELECT count(pilot_name) FROM pilotskills ORDER BY age  >  40 OR age  <  30,"1. Sequential Structure: Start with the SELECT clause to count the number of pilots. 2. Condition Structure: Use a WHERE clause to filter pilots whose age is greater than 40 or less than 30. 3. Join Structure: No JOIN is required since all necessary information is in the ""PilotSkills"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of pilots meeting the specified age conditions.",0.0
1149,Return the average age of pilots for each plane name.,EASY,pilot_1,"[PilotSkills.age, PilotSkills.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.plane_name, AVG(PilotSkills.age) AS avg_age FROM PilotSkills GROUP BY PilotSkills.plane_name;","SELECT avg(age) ,  plane_name FROM pilotskills GROUP BY plane_name","1. Sequential Structure: Begin with the SELECT clause to specify the plane name and the average age of pilots. 2. Aggregation Structure: Use the AVG function to calculate the average age of pilots for each plane name. 3. Grouping Structure: Use GROUP BY on ""PilotSkills.plane_name"" to calculate the average age for each plane name. 4. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table.",1.0
1150,What are the distinct titles of every painting that has a greater height than some painting on canvas?,NESTED,art_1,"[Paintings.title, Paintings.height_mm, Paintings.medium]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT Paintings.title FROM Paintings WHERE Paintings.height_mm > ANY (SELECT Paintings.height_mm FROM Paintings WHERE Paintings.medium = 'canvas');,"SELECT DISTINCT title FROM paintings WHERE height_mm  >  (SELECT min(height_mm) FROM paintings WHERE mediumOn  =  ""canvas"")","1. Sequential Structure: Start with the SELECT clause to retrieve distinct titles of paintings. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter paintings with a height greater than some painting on canvas. 2. Condition Structure: Use the WHERE clause with a subquery to compare the height of paintings to the height of paintings with the medium 'canvas'. The subquery retrieves the heights of all paintings on canvas. 3. Join Structure: Not required, as all data is in the Paintings table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",0.0
1151,Find the average height and width of paintings grouped by painters and ordered by name,NON-NESTED,art_1,"[Paintings.height_mm, Paintings.width_mm, Paintings.painterID, Artists.artistID, Artists.lname, Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.lname, AVG(Paintings.height_mm) AS avg_height, AVG(Paintings.width_mm) AS avg_width FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID GROUP BY Artists.lname ORDER BY Artists.lname ASC;","SELECT avg(height_mm) ,  avg(width_mm) ,  painterID FROM paintings GROUP BY painterID ORDER BY title","1. Sequential Structure: Start with the SELECT clause to retrieve the average height and width of paintings, grouped by painters. Include the painter's last name (""Artists.lname"") in the SELECT clause for grouping and ordering purposes. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Paintings"" and ""Artists"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to associate each painting with its respective painter. 4. Aggregation Structure: Use AVG on ""Paintings.height_mm"" and ""Paintings.width_mm"" to calculate the average height and width of paintings. Use GROUP BY on ""Artists.lname"" to group the results by painter, and ORDER BY to sort the results alphabetically by the painter's last name.",1.0
1152,Find the name of the district which has greatest number of spokesmen.,NON-NESTED,district_spokesman,"[district.Name, spokesman_district.District_ID = district.District_ID, spokesman_district.Spokesman_ID]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
",SELECT district.Name FROM district JOIN spokesman_district ON district.District_ID = spokesman_district.District_ID GROUP BY district.District_ID ORDER BY COUNT(spokesman_district.Spokesman_ID) DESC LIMIT 1;,SELECT t1.name FROM district AS t1 JOIN spokesman_district AS t2 ON t1.District_ID  =  t2.District_ID GROUP BY t2.District_ID ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""district.Name"" since we need the name of the district. Use COUNT to count the number of spokesmen associated with each district. Use ORDER BY in descending order to rank districts by the number of spokesmen and LIMIT 1 to get the district with the greatest number. 2. Condition Structure: No specific filtering condition is required as we are considering all districts. 3. Join Structure: Use a JOIN between ""district"" and ""spokesman_district"" tables based on ""District_ID"" to associate each district with its spokesmen. 4. Aggregation Structure: Use COUNT on ""spokesman_district.Spokesman_ID"" to count the number of spokesmen for each district, and GROUP BY ""district.District_ID"" to group the results by district.",1.0
1153,What are the numbers of works for different medium type?,NON-NESTED,art_1,"[Paintings.medium, Sculptures.medium]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT medium, COUNT(*) AS num_works FROM Paintings GROUP BY medium UNION SELECT medium, COUNT(*) AS num_works FROM Sculptures GROUP BY medium;","SELECT count(*) ,  medium FROM paintings GROUP BY medium","1. Sequential Structure: Start with the SELECT clause to retrieve the ""medium"" and the count of works for each medium type. Use COUNT to calculate the number of works for each medium type. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: No JOIN is required since the data is distributed across two separate tables, ""Paintings"" and ""Sculptures."" We will use a UNION to combine the results from both tables. 4. Aggregation Structure: Use GROUP BY on the ""medium"" field to group the results by medium type and apply COUNT to calculate the number of works for each medium type.",1.0
1154,Which plane does the pilot Jones with age 32 has?,EASY,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT PilotSkills.plane_name FROM PilotSkills WHERE PilotSkills.pilot_name = 'Jones' AND PilotSkills.age = 32;,SELECT plane_name FROM pilotskills WHERE pilot_name  =  'Jones'  AND age  =  32,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""PilotSkills.plane_name"" for the pilot named ""Jones"" with age 32. 2. Condition Structure: Use a WHERE clause to filter for the pilot whose ""PilotSkills.pilot_name"" is ""Jones"" and ""PilotSkills.age"" is 32. 3. Join Structure: No JOIN is required since all necessary information is in the ""PilotSkills"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on specific conditions.",1.0
1155,What is the location of the plane that was flown by the pilot with the lowest age?,NESTED,pilot_1,"[PilotSkills.age, PilotSkills.plane_name, Hangar.location, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT Hangar.location FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE PilotSkills.age = (SELECT MIN(age) FROM PilotSkills);,SELECT T2.location FROM pilotskills AS T1 JOIN hangar AS T2 ON T1.plane_name  =  T2.plane_name WHERE T1.age  =  (SELECT min(age) FROM pilotskills),"1. Sequential Structure: Start with the SELECT clause to retrieve the location of the plane. Use the FROM clause to specify the PilotSkills and Hangar tables. Apply a WHERE clause to filter for the plane flown by the pilot with the lowest age. 2. Condition Structure: Use a WHERE clause with a subquery to find the pilot with the lowest age and retrieve the corresponding plane name. Then, use this plane name to find the location in the Hangar table. 3. Join Structure: Use an INNER JOIN between the PilotSkills and Hangar tables based on the plane_name to connect the pilot's plane with its location. 4. Aggregation Structure: Use the MIN function in a subquery to find the lowest age of the pilots.",1.0
1156,What are the average height and width of paintings that are oil medium in the place of gallery 241?,EASY,art_1,"[Paintings.height_mm, Paintings.width_mm, Paintings.medium, Paintings.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT AVG(Paintings.height_mm) AS avg_height, AVG(Paintings.width_mm) AS avg_width FROM Paintings WHERE Paintings.medium = 'oil' AND Paintings.location = 'gallery 241';","SELECT avg(height_mm) ,  avg(width_mm) FROM paintings WHERE medium  =  ""oil"" AND LOCATION  =  ""Gallery 241""","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the average height and average width of paintings. 2. Condition Structure: Use a WHERE clause to filter for paintings that have the medium as ""oil"" and are located in ""gallery 241"". 3. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table. 4. Aggregation Structure: Use AVG to calculate the average height and average width of the filtered paintings.",0.0
1157,"What are the winning drivers and teams of races, ordered alphabetically by team?",EASY,car_road_race,"[race.Winning_driver, race.Winning_team]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT race.Winning_driver, race.Winning_team FROM race ORDER BY race.Winning_team ASC;","SELECT Winning_driver ,  Winning_team FROM race ORDER BY Winning_team ASC","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the winning drivers and their corresponding teams. 2. Condition Structure: No specific filtering condition is required as the query asks for all winning drivers and teams. 3. Join Structure: No JOIN is required since all necessary data is within the ""race"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data. 5. Ordering Structure: Use ORDER BY on ""race.Winning_team"" to sort the results alphabetically by team.",1.0
1158,Find the first and last names of all artists who were born after 1850.,EASY,art_1,"[Artists.lname, Artists.fname, Artists.birthYear]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.fname, Artists.lname FROM Artists WHERE Artists.birthYear > 1850;","SELECT lname ,  fname FROM artists WHERE birthYear  >  1850","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the first name (""Artists.fname"") and last name (""Artists.lname"") of the artists. 2. Condition Structure: Use a WHERE clause to filter for artists whose ""Artists.birthYear"" is greater than 1850. 3. Join Structure: No JOIN is required since all necessary data is within the ""Artists"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of artists based on a specific condition.",1.0
1159,List the names of all distinct paintings in alphabetical order.,EASY,art_1,[Paintings.title],"Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT Paintings.title FROM Paintings ORDER BY Paintings.title ASC;,SELECT DISTINCT title FROM paintings ORDER BY title,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the title of the paintings. 2. Condition Structure: No specific filtering condition is required as we want all distinct painting titles. 3. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table. 4. Aggregation Structure: Use DISTINCT to ensure only unique painting titles are retrieved. 5. Ordering Structure: Use ORDER BY in ascending order to sort the painting titles alphabetically.",1.0
1160,Show all staff name who are above the average age.,NESTED,conference,"[staff.name, staff.Age]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT name FROM staff WHERE Age > (SELECT AVG(Age) FROM staff);,SELECT name FROM staff WHERE age  >  (SELECT avg(age) FROM staff),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of staff members. Use the FROM clause to specify the staff table. Apply a WHERE clause to filter staff members whose age is above the average age. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average age of all staff members and filter those whose age is greater than this value. 3. Join Structure: Not required, as all data is in the staff table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average age of all staff members, which is then used in the filtering condition.",1.0
1161,What are the names and locations of the universities that did not have any staff participating in any conferences in 2004?,NESTED,conference,"[institution.Institution_Name, institution.Location, institution.Institution_ID, staff.Institution_ID = institution.Institution_ID, staff.staff_ID = conference_participation.staff_ID, conference_participation.Conference_ID = conference.Conference_ID, conference.Year, 2004]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT institution.Institution_Name, institution.Location FROM institution WHERE institution.Institution_ID NOT IN ( SELECT staff.Institution_ID FROM staff JOIN conference_participation ON staff.staff_ID = conference_participation.staff_ID JOIN conference ON conference_participation.Conference_ID = conference.Conference_ID WHERE conference.Year = 2004 );","SELECT T1.Institution_Name ,  T1.location FROM institution AS T1 JOIN staff AS T2 ON T1.institution_id  =  T2.institution_id WHERE T2.staff_id NOT IN (SELECT T4.staff_id FROM Conference AS T3 JOIN Conference_participation AS T4 ON T3.conference_id  =  T4.conference_id WHERE T3.year  =  2004)","1. Sequential Structure: Start with the SELECT clause to retrieve the names and locations of universities. Use the FROM clause to specify the institution table. Apply a WHERE clause to filter universities that did not have any staff participating in conferences in 2004. 2. Condition Structure: Use a WHERE clause with a subquery to exclude universities whose staff participated in conferences in 2004. The subquery identifies all Institution_IDs linked to staff who participated in conferences in 2004. 3. Join Structure: Use JOINs to connect the institution table with the staff table, the conference_participation table, and the conference table to trace the relationship between universities and conferences. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1162,What are the names of paintings whose width is less than 600 or height is larger than 800?,EASY,art_1,"[Paintings.title, Paintings.width_mm, Paintings.height_mm]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.title FROM Paintings WHERE Paintings.width_mm < 600 OR Paintings.height_mm > 800;,SELECT title FROM paintings WHERE width_mm  <  600 OR height_mm  >  800,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the title of the paintings. 2. Condition Structure: Use a WHERE clause to filter paintings where the width is less than 600 or the height is larger than 800. 3. Join Structure: No JOIN is required since all necessary information is in the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the titles of paintings that meet the specified conditions.",1.0
1163,What are the first name and age of the artist who had the longest life?,NESTED,art_1,"[Artists.fname, Artists.birthYear, Artists.deathYear]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT fname, (deathYear - birthYear) AS age FROM Artists ORDER BY age DESC LIMIT 1;","SELECT fname  ,  deathYear - birthYear FROM artists ORDER BY deathYear - birthYear DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the first name and age of the artist. Use the FROM clause to specify the Artists table. Calculate the age of each artist as the difference between deathYear and birthYear. Use the ORDER BY clause to sort the artists by their age in descending order and LIMIT 1 to get the artist with the longest life. 2. Condition Structure: No specific filtering condition (WHERE clause) is needed, as we are considering all artists. 3. Join Structure: Not required, as all data is available within the Artists table. 4. Aggregation Structure: Use a calculated field (deathYear - birthYear) to determine the age of each artist and sort by this value to find the maximum.",1.0
1164,What is the title of the sculpture that was created in the most recent year ?,EASY,art_1,"[Sculptures.title,Sculptures.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Sculptures.title FROM Sculptures WHERE Sculptures.year = (SELECT MAX(Sculptures.year) FROM Sculptures);,select title from sculptures order by year desc limit 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the title of the sculpture. 2. Condition Structure: No specific filtering condition is required, as we are looking for the sculpture created in the most recent year. 3. Aggregation Structure: Use MAX to determine the most recent year from the ""Sculptures.year"" column. 4. Join Structure: No JOIN is required since all necessary data is within the ""Sculptures"" table. 5. Limiting Structure: Use a subquery to find the maximum year and filter the sculpture(s) created in that year.",1.0
1165,What is the first name of the sculptor with the greatest number of works?,NON-NESTED,art_1,"[Sculptures.sculptorID,Artists.fname,Sculptures.sculptorID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Artists.fname FROM Sculptures JOIN Artists ON Sculptures.sculptorID = Artists.artistID GROUP BY Sculptures.sculptorID ORDER BY COUNT(Sculptures.sculptorID) DESC LIMIT 1;,SELECT T1.fname FROM artists AS T1 JOIN sculptures AS T2 ON T1.artistID  =  T2.sculptorID GROUP BY T2.sculptorID ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the first name of the sculptor (""Artists.fname""). 2. Condition Structure: No specific filtering condition is needed, but we need to identify the sculptor with the greatest number of works. This requires counting the number of works for each sculptor and selecting the maximum. 3. Join Structure: Use a JOIN between the ""Sculptures"" table and the ""Artists"" table based on the relationship ""Sculptures.sculptorID = Artists.artistID"" to link each sculpture to its sculptor. 4. Aggregation Structure: Use COUNT to count the number of works for each sculptor, GROUP BY ""Sculptures.sculptorID"" to group the counts by sculptor, and ORDER BY the count in descending order to find the sculptor with the greatest number of works. Use LIMIT 1 to select the top result.",1.0
1166,Please show the names and ages of the drivers who participated in at least two races.,NESTED,car_road_race,"[driver.Driver_Name, driver.Age, race.Driver_ID, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT driver.Driver_Name, driver.Age FROM driver JOIN race ON driver.Driver_ID = race.Driver_ID GROUP BY driver.Driver_ID, driver.Driver_Name, driver.Age HAVING COUNT(race.Driver_ID) >= 2;","SELECT T1.Driver_Name ,  T1.Age FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID GROUP BY T1.Driver_ID HAVING COUNT(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve the names and ages of drivers. Use the FROM clause to specify the driver table and JOIN it with the race table to link drivers with their race participation. Use GROUP BY to group records by driver ID, allowing us to count the number of races each driver participated in. Apply a HAVING clause to filter for drivers who participated in at least two races. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for drivers who participated in two or more races. 3. Join Structure: Use an INNER JOIN between the driver and race tables based on Driver_ID to connect driver details with their race participation. 4. Aggregation Structure: Use COUNT(*) within HAVING to aggregate the number of races per driver and filter out drivers with fewer than two races.",1.0
1167,"List the year, location, and name of all paintings that are taller than 1000 in alphabetical order.",EASY,art_1,"[Paintings.year, Paintings.location, Paintings.title, Paintings.height_mm]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.year, Paintings.location, Paintings.title FROM Paintings WHERE Paintings.height_mm > 1000 ORDER BY Paintings.title ASC;","SELECT title ,  LOCATION ,  YEAR FROM paintings WHERE height_mm  >  1000 ORDER BY title","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the year, location, and title of the paintings. 2. Condition Structure: Use a WHERE clause to filter paintings with a height greater than 1000 mm. 3. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table. 4. Ordering Structure: Use ORDER BY on the ""Paintings.title"" field in ascending alphabetical order. 5. Aggregation Structure: No aggregation is needed as we are retrieving individual records that meet the specified condition.",1.0
1168,Return the location of the hangar in which F-14 Fighter is located.,NON-NESTED,pilot_1,"[Hangar.location,Hangar.plane_name,PilotSkills.plane_name = Hangar.plane_name,F-14 Fighter]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT Hangar.location FROM Hangar WHERE Hangar.plane_name = 'F-14 Fighter';,SELECT LOCATION FROM hangar WHERE plane_name  =  'F-14 Fighter',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Hangar.location"" where the F-14 Fighter is located. 2. Condition Structure: Use a WHERE clause to filter for the specific plane name, ""F-14 Fighter."" 3. Join Structure: No JOIN is required since the necessary information is available in the ""Hangar"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a specific value.",1.0
1169,List the winning drivers and winning teams of races in ascending alphabetical order of winning team.,EASY,car_road_race,"[race.Winning_driver, race.Winning_team]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT race.Winning_driver, race.Winning_team FROM race ORDER BY race.Winning_team ASC;","SELECT Winning_driver ,  Winning_team FROM race ORDER BY Winning_team ASC","1. Sequential Structure: Start with the SELECT clause to retrieve the ""race.Winning_driver"" and ""race.Winning_team"" fields. 2. Condition Structure: No specific filtering condition is required as we want all winning drivers and their corresponding winning teams. 3. Join Structure: No JOIN is required since all necessary information is available in the ""race"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""race.Winning_team"" in ascending alphabetical order to sort the results.",1.0
1170,What is the first name of the artist who has the highest number of sculptures?,NON-NESTED,art_1,"[Artists.fname, Sculptures.sculptorID, Sculptures.sculptorID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Artists.fname FROM Sculptures JOIN Artists ON Sculptures.sculptorID = Artists.artistID GROUP BY Artists.artistID ORDER BY COUNT(Sculptures.sculptorID) DESC LIMIT 1;,SELECT T1.fname FROM artists AS T1 JOIN sculptures AS T2 ON T1.artistID  =  T2.sculptorID GROUP BY T2.sculptorID ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the first name of the artist (""Artists.fname""). 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the artist with the highest number of sculptures. 3. Join Structure: Use a JOIN between the ""Sculptures"" and ""Artists"" tables based on the relationship ""Sculptures.sculptorID = Artists.artistID"" to link sculptures to their respective artists. 4. Aggregation Structure: Use COUNT to count the number of sculptures for each artist, GROUP BY ""Artists.artistID"" to group the counts by artist, and ORDER BY the count in descending order to rank artists by the number of sculptures. Use LIMIT 1 to select the artist with the highest count.",1.0
1171,Show all conference names which the staff from Canada attends.,NON-NESTED,conference,"[conference.Conference_Name,staff.Nationality,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID,Canada]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT conference.Conference_Name FROM conference_participation JOIN conference ON conference_participation.Conference_ID = conference.Conference_ID JOIN staff ON conference_participation.staff_ID = staff.staff_ID WHERE staff.Nationality = 'Canada';,"SELECT T1.conference_name FROM conference AS T1 JOIN conference_participation AS T2 ON T1.conference_id = T2.conference_id JOIN staff AS T3 ON T2.staff_id  =  T3.staff_id WHERE T3.nationality  =  ""Canada""","1. Sequential Structure: Start with the SELECT clause to retrieve ""conference.Conference_Name."" 2. Condition Structure: Use a WHERE clause to filter for staff members whose ""staff.Nationality"" is ""Canada."" 3. Join Structure: Use JOINs to connect ""conference_participation"" with ""conference"" on ""conference.Conference_ID"" and with ""staff"" on ""conference_participation.staff_ID = staff.staff_ID"" to link conferences with the staff attending them. 4. Aggregation Structure: No aggregation is needed as we are simply listing all conference names.",1.0
1172,What is the maximum and minimum age of all staff from the United States?,EASY,conference,"[staff.Age, staff.Nationality]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT MAX(staff.Age) AS max_age, MIN(staff.Age) AS min_age FROM staff WHERE staff.Nationality = 'United States';","SELECT max(age) ,  min(age) FROM staff","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum ages of staff. 2. Condition Structure: Use a WHERE clause to filter staff whose nationality is ""United States."" 3. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum ages of the filtered staff. 4. Join Structure: No JOIN is required since all necessary data is within the ""staff"" table.",0.0
1173,What is the first and last name of each distinct artists who made a sculpture before 1900?,NON-NESTED,art_1,"[Artists.lname, Artists.fname, Sculptures.year, Sculptures.sculptorID = Artists.artistID, 1900]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT DISTINCT Artists.fname, Artists.lname FROM Sculptures JOIN Artists ON Sculptures.sculptorID = Artists.artistID WHERE Sculptures.year < 1900;","SELECT DISTINCT T1.lname ,  T1.fname FROM artists AS T1 JOIN sculptures AS T2 ON T1.artistID  =  T2.sculptorID WHERE T2.year  <  1900","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct first and last names of artists. Use DISTINCT to ensure unique artist names are returned. 2. Condition Structure: Use a WHERE clause to filter for sculptures made before the year 1900. 3. Join Structure: Use a JOIN between the ""Sculptures"" and ""Artists"" tables based on the relationship ""Sculptures.sculptorID = Artists.artistID"" to link sculptures with their respective artists. 4. Aggregation Structure: No aggregation is needed as we are only retrieving distinct artist names.",1.0
1174,What are the average and smallest ages of all pilots?,EASY,pilot_1,[PilotSkills.age],"Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT AVG(PilotSkills.age) AS average_age, MIN(PilotSkills.age) AS smallest_age FROM PilotSkills;","SELECT avg(age) ,  min(age) FROM pilotskills","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average and smallest ages of all pilots. 2. Aggregation Structure: Use AVG to calculate the average age and MIN to find the smallest age of pilots. 3. Condition Structure: No specific filtering condition is required as the query involves all pilots. 4. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table.",1.0
1175,How many distinct planes are owned across all pilots?,EASY,pilot_1,[PilotSkills.plane_name],"Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(DISTINCT PilotSkills.plane_name) FROM PilotSkills;,SELECT count(DISTINCT plane_name) FROM pilotskills,"1. Sequential Structure: Begin with the SELECT clause to count the distinct planes owned across all pilots. 2. Condition Structure: No specific filtering condition is required as we are interested in all planes. 3. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""PilotSkills.plane_name"" to count the unique planes.",1.0
1176,Find the first names and number of works of all artists who have at least two paintings?,NESTED,art_1,"[Artists.fname, Paintings.painterID, Artists.artistID = Paintings.painterID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.fname, COUNT(Paintings.painterID) AS number_of_works FROM Artists JOIN Paintings ON Artists.artistID = Paintings.painterID GROUP BY Artists.artistID, Artists.fname HAVING COUNT(Paintings.painterID) >= 2;","SELECT T1.fname ,  count(*) FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID GROUP BY T2.painterID HAVING count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve the first names of artists and the count of their works. Use the FROM clause to specify the Artists table and JOIN it with the Paintings table to link artists with their paintings. Use GROUP BY to group records by artistID, allowing us to count the number of paintings for each artist. Apply a HAVING clause to filter artists with at least two paintings. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for artists who have at least two paintings. 3. Join Structure: Use an INNER JOIN between the Artists and Paintings tables based on the relationship between artistID and painterID to connect artists with their paintings. 4. Aggregation Structure: Use COUNT(*) to calculate the number of paintings for each artist and filter those with at least two paintings using the HAVING clause.",1.0
1177,Give me the biggest and average areas of all districts.,EASY,district_spokesman,[district.Area_km],"Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
","SELECT MAX(district.Area_km) AS biggest_area, AVG(district.Area_km) AS average_area FROM district;","SELECT max(area_km) ,  avg(area_km) FROM district","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and average areas of all districts. 2. Aggregation Structure: Use MAX and AVG functions to calculate the biggest and average areas of the districts. 3. Grouping Structure: No GROUP BY is needed since the query asks for the overall biggest and average areas across all districts. 4. Join Structure: No JOIN is required as all necessary data is within the ""district"" table.",1.0
1178,What are the paintings called and where are they located?,EASY,art_1,"[Paintings.title, Paintings.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.title, Paintings.location FROM Paintings;","SELECT title ,  LOCATION FROM paintings","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the title of the paintings and their location. 2. Condition Structure: No specific filtering condition is required as the query asks for all paintings and their locations. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the titles and locations of all paintings.",1.0
1179,What is the name of the plane that is flown the least often?,NESTED,pilot_1,[PilotSkills.plane_name],"Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT plane_name FROM PilotSkills GROUP BY plane_name ORDER BY COUNT(*) ASC LIMIT 1;,SELECT plane_name FROM pilotskills GROUP BY plane_name ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the plane. Use the FROM clause to specify the PilotSkills table. Apply a GROUP BY clause to group records by plane_name and use an ORDER BY clause to sort the planes by the count of their occurrences in ascending order. Use the LIMIT clause to retrieve only the plane that is flown the least often. 2. Condition Structure: No specific filtering condition is required, as we are interested in the plane with the minimum count of occurrences. 3. Join Structure: Not required, as all data is available within the PilotSkills table. 4. Aggregation Structure: Use COUNT to calculate the number of times each plane is flown and sort the results to find the least flown plane.",1.0
1180,Where is the plane F-14 Fighter located?,NON-NESTED,pilot_1,"[Hangar.location,Hangar.plane_name,PilotSkills.plane_name = Hangar.plane_name,F-14 Fighter]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT Hangar.location FROM Hangar WHERE Hangar.plane_name = 'F-14 Fighter';,SELECT LOCATION FROM hangar WHERE plane_name  =  'F-14 Fighter',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Hangar.location"" where the plane is located. 2. Condition Structure: Use a WHERE clause to filter for the specific plane name, ""F-14 Fighter."" 3. Join Structure: No JOIN is necessary as the required information is available in the ""Hangar"" table. 4. Aggregation Structure: No aggregation is needed since we are retrieving a specific location for a single plane.",1.0
1181,Find pilots who own plane Piper Cub but not B-52 Bomber.,NESTED,pilot_1,"[PilotSkills.pilot_name,PilotSkills.plane_name,Hangar.plane_name = PilotSkills.plane_name,Piper Cub,B-52 Bomber]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT pilot_name FROM PilotSkills WHERE plane_name = 'Piper Cub' AND pilot_name NOT IN (SELECT pilot_name FROM PilotSkills WHERE plane_name = 'B-52 Bomber');,SELECT pilot_name FROM pilotskills WHERE plane_name  =  'Piper Cub' EXCEPT SELECT pilot_name FROM pilotskills WHERE plane_name  =  'B-52 Bomber',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of pilots. Use the FROM clause to specify the PilotSkills table. Apply a WHERE clause to filter pilots who own the plane ""Piper Cub"" but not ""B-52 Bomber"". 2. Condition Structure: Use the WHERE clause to filter for pilots who own ""Piper Cub"". Use a subquery with NOT IN to exclude pilots who own ""B-52 Bomber"". 3. Join Structure: Not required, as all necessary data is available in the PilotSkills table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1182,What is the name of the least popular plane?,NON-NESTED,pilot_1,"[PilotSkills.plane_name, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT PilotSkills.plane_name FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name GROUP BY PilotSkills.plane_name ORDER BY COUNT(PilotSkills.plane_name) ASC LIMIT 1;,SELECT plane_name FROM pilotskills GROUP BY plane_name ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""plane_name"" of the least popular plane. Since ""least popular"" implies the plane with the fewest occurrences, we will use COUNT to determine the popularity of each plane. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all planes. 3. Join Structure: Use a JOIN between ""PilotSkills"" and ""Hangar"" tables based on the shared key ""plane_name"" to ensure we account for all planes across both tables. 4. Aggregation Structure: Use COUNT to count the occurrences of each ""plane_name"" and ORDER BY in ascending order to rank planes by popularity. Use LIMIT 1 to select the least popular plane.",0.0
1183,List the names of all distinct paintings from shortest to longest in height.,EASY,art_1,"[Paintings.title, Paintings.height_mm]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT Paintings.title FROM Paintings ORDER BY Paintings.height_mm ASC;,SELECT DISTINCT title FROM paintings ORDER BY height_mm,"1. Sequential Structure: Begin with the SELECT clause to specify the field needed, which is the title of the paintings. 2. Condition Structure: No specific filtering condition is required as we want all paintings. 3. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique painting titles are retrieved. Use ORDER BY to sort the results in ascending order based on the height of the paintings.",1.0
1184,Find the name and age of pilots who have a plane in Austin.,NON-NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name = Hangar.plane_name, Hangar.location, Austin]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.pilot_name, PilotSkills.age FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE Hangar.location = 'Austin';","SELECT T1.pilot_name ,  T1.age FROM pilotskills AS T1 JOIN hangar AS T2 ON T1.plane_name  =  T2.plane_name WHERE T2.location  =  ""Austin""","1. Sequential Structure: Start with the SELECT clause to retrieve ""PilotSkills.pilot_name"" and ""PilotSkills.age."" 2. Condition Structure: Use a WHERE clause to filter for records where the ""Hangar.location"" is ""Austin."" 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the shared key ""plane_name"" to associate pilots with their planes and locations. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without summarization.",1.0
1185,What are the names of drivers and the names of the races they took part in?,NON-NESTED,car_road_race,"[driver.Driver_Name, race.Race_Name, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT driver.Driver_Name, race.Race_Name FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID;","SELECT T1.Driver_Name ,  T2.Race_Name FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""driver.Driver_Name"" and ""race.Race_Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""driver"" and ""race"" tables based on the relationship ""race.Driver_ID = driver.Driver_ID"" to link each driver with the races they participated in. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the names of drivers and the races they took part in.",1.0
1186,Find the names of all pilots with age between 30 and 40 sorted by their ages in ascending order.,EASY,pilot_1,"[PilotSkills.pilot_name,PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.pilot_name, PilotSkills.age FROM PilotSkills WHERE PilotSkills.age BETWEEN 30 AND 40 ORDER BY PilotSkills.age ASC;",SELECT pilot_name FROM pilotskills WHERE age BETWEEN 30 AND 40 ORDER BY age,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of pilots and their ages. 2. Condition Structure: Use a WHERE clause to filter pilots whose ages are between 30 and 40. 3. Join Structure: No JOIN is required since all necessary information is in the ""PilotSkills"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY to sort the results by age in ascending order.",1.0
1187,Count the number of planes flown by pilots older than 40.,NON-NESTED,pilot_1,"[PilotSkills.plane_name, PilotSkills.age, Hangar.plane_name = PilotSkills.plane_name, 40]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(PilotSkills.plane_name) FROM PilotSkills JOIN Hangar ON Hangar.plane_name = PilotSkills.plane_name WHERE PilotSkills.age > 40;,SELECT count(plane_name) FROM pilotskills WHERE age  >  40,"1. Sequential Structure: Start with the SELECT clause to count the number of planes flown by pilots. Use COUNT on ""PilotSkills.plane_name"" to get the total number of planes. 2. Condition Structure: Use a WHERE clause to filter for pilots older than 40 by checking the ""PilotSkills.age"" field. 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the ""plane_name"" field to ensure we are counting planes that are in the hangar and flown by pilots. 4. Aggregation Structure: Use COUNT to aggregate the number of planes flown by pilots meeting the age condition.",1.0
1188,What are the numbers of paintings created before 1900 in different places?,EASY,art_1,"[Paintings.year, Paintings.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.location, COUNT(*) AS painting_count FROM Paintings WHERE Paintings.year < 1900 GROUP BY Paintings.location;","SELECT count(*) ,  LOCATION FROM paintings WHERE YEAR  <  1900 GROUP BY LOCATION","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the location and the count of paintings. 2. Condition Structure: Apply a WHERE clause to filter paintings created before the year 1900. 3. Grouping Structure: Use GROUP BY on ""Paintings.location"" to count paintings for each location. 4. Aggregation Structure: Use COUNT to calculate the number of paintings created before 1900 in each location. 5. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table.",1.0
1189,What is the id of the artist with the most paintings before 1900?,NON-NESTED,art_1,"[Artists.artistID, Paintings.painterID, Paintings.year, Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Artists.artistID FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID WHERE Paintings.year < 1900 GROUP BY Paintings.painterID ORDER BY COUNT(Paintings.painterID) DESC LIMIT 1;,SELECT T1.artistID FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T2.year  <  1900 GROUP BY T1.artistID ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""artistID"" of the artist with the most paintings before 1900. Use COUNT to count the number of paintings for each artist. 2. Condition Structure: Use a WHERE clause to filter paintings with a year before 1900. 3. Join Structure: Use a JOIN between the ""Paintings"" and ""Artists"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to associate paintings with their respective artists. 4. Aggregation Structure: Use COUNT to count the number of paintings for each artist, GROUP BY ""Paintings.painterID"" to group the results by artist, and ORDER BY the count in descending order to find the artist with the most paintings. Use LIMIT 1 to select the top result.",1.0
1190,Show the conference name and year and the number of participants for each conference.,NON-NESTED,conference,"[conference.Conference_Name, conference.Year, conference.Conference_ID = conference_participation.Conference_ID, conference_participation.staff_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT conference.Conference_Name, conference.Year, COUNT(conference_participation.staff_ID) AS Number_of_Participants FROM conference JOIN conference_participation ON conference.Conference_ID = conference_participation.Conference_ID GROUP BY conference.Conference_Name, conference.Year;","SELECT T1.conference_name ,  T1.year ,  count(*) FROM Conference AS T1 JOIN Conference_participation AS T2 ON T1.conference_id  =  T2.conference_id GROUP BY T2.conference_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""conference.Conference_Name,"" ""conference.Year,"" and the count of participants for each conference. Use COUNT on ""conference_participation.staff_ID"" to count the number of participants. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""conference"" table and the ""conference_participation"" table based on ""conference.Conference_ID"" to link each conference with its participants. 4. Aggregation Structure: Use COUNT to count the number of participants for each conference and GROUP BY ""conference.Conference_Name"" and ""conference.Year"" to group results by each conference and its year.",1.0
1191,What is the birth year of each distinct artists who created sculptures after 1920?,NON-NESTED,art_1,"[Artists.birthYear, Sculptures.year, Sculptures.sculptorID = Artists.artistID, 1920]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT Artists.birthYear FROM Sculptures JOIN Artists ON Sculptures.sculptorID = Artists.artistID WHERE Sculptures.year > 1920;,SELECT DISTINCT T1.birthYear FROM artists AS T1 JOIN sculptures AS T2 ON T1.artistID  =  T2.sculptorID WHERE T2.year  >  1920,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct birth years of artists who created sculptures. Include ""Artists.birthYear"" in the SELECT clause. 2. Condition Structure: Use a WHERE clause to filter for sculptures created after the year 1920. 3. Join Structure: Use a JOIN between the ""Sculptures"" and ""Artists"" tables based on the relationship ""Sculptures.sculptorID = Artists.artistID"" to link sculptures with their respective artists. 4. Aggregation Structure: Use DISTINCT to ensure that only unique birth years of artists are returned.",1.0
1192,What are the maximum and minimum ages for all staff?,EASY,conference,[staff.Age],"Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT MAX(staff.Age) AS max_age, MIN(staff.Age) AS min_age FROM staff;","SELECT max(age) ,  min(age) FROM staff","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum ages. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum ages of all staff. 3. Grouping Structure: No GROUP BY is required since the query asks for the overall maximum and minimum ages, not grouped by any category. 4. Join Structure: No JOIN is required as all necessary data is within the ""staff"" table.",1.0
1193,How old is the artist who lived the shortest life?,NESTED,art_1,"[Artists.artistID, Artists.birthYear, Artists.deathYear]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT (deathYear - birthYear) AS age FROM Artists WHERE (deathYear - birthYear) = (SELECT MIN(deathYear - birthYear) FROM Artists);,SELECT deathYear - birthYear FROM artists ORDER BY deathYear - birthYear LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to calculate the age of artists and retrieve the age of the artist who lived the shortest life. Use the FROM clause to specify the Artists table. Use a subquery to calculate the minimum lifespan. 2. Condition Structure: Use the WHERE clause to filter for the artist whose lifespan (deathYear - birthYear) is equal to the minimum lifespan calculated in the subquery. 3. Join Structure: Not required, as all data is in the Artists table. 4. Aggregation Structure: Use MIN in a subquery to calculate the shortest lifespan (deathYear - birthYear) among all artists.",1.0
1194,What are the sculptures called and where are they located?,EASY,art_1,"[Sculptures.title, Sculptures.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Sculptures.title, Sculptures.location FROM Sculptures;","SELECT title ,  LOCATION FROM sculptures","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the sculpture title and its location. 2. Condition Structure: No specific filtering condition is required as the query asks for all sculptures and their locations. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Sculptures"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the titles and locations of all sculptures.",1.0
1195,What are the locations that have works painted before 1885 and after 1930?,NESTED,art_1,"[Paintings.location, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT location FROM Paintings WHERE year < 1885 OR year > 1930;,SELECT DISTINCT LOCATION FROM paintings WHERE YEAR  <  1885 INTERSECT SELECT DISTINCT LOCATION FROM paintings WHERE YEAR  >  1930,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct locations from the Paintings table. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter for paintings created before 1885 and after 1930. 2. Condition Structure: Use the WHERE clause with conditions to filter for paintings where the year is either less than 1885 or greater than 1930. 3. Join Structure: Not required, as all data is available within the Paintings table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1196,What is the age of the artist who had the shortest life?,NESTED,art_1,"[Artists.birthYear, Artists.deathYear, Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT (deathYear - birthYear) AS age FROM Artists ORDER BY age ASC LIMIT 1;,SELECT deathYear - birthYear FROM artists ORDER BY deathYear - birthYear LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to calculate the age of the artist who had the shortest life. Use the FROM clause to specify the Artists table. Calculate the age by subtracting the birthYear from the deathYear. Use the ORDER BY clause to sort the artists by their age in ascending order and LIMIT 1 to get the shortest life. 2. Condition Structure: No specific filtering condition is required, as we are considering all artists. 3. Join Structure: Not required, as all data is available within the Artists table. 4. Aggregation Structure: Use subtraction (deathYear - birthYear) to calculate the age of each artist and sort to find the shortest life.",1.0
1197,In what year was the artist who created a painting in 1884 born?,NON-NESTED,art_1,"[Paintings.year, Paintings.painterID, Artists.artistID = Paintings.painterID, Artists.birthYear]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Artists.birthYear FROM Paintings JOIN Artists ON Artists.artistID = Paintings.painterID WHERE Paintings.year = 1884;,"SELECT T1.birthYear FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T2.year  =  1884 AND mediumOn  =  ""canvas""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Artists.birthYear"" of the artist who created a painting in 1884. 2. Condition Structure: Use a WHERE clause to filter for paintings created in the year 1884. 3. Join Structure: Use a JOIN between the ""Paintings"" and ""Artists"" tables based on the relationship ""Artists.artistID = Paintings.painterID"" to link each painting with its respective artist. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single value.",1.0
1198,What is the unique id of every painter who had a medium oil painting displayed at gallery 240?,NON-NESTED,art_1,"[Paintings.painterID,Paintings.medium,Paintings.location,Artists.artistID,Paintings.painterID = Artists.artistID,oil,240]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT Paintings.painterID FROM Paintings WHERE Paintings.medium = 'oil' AND Paintings.location = 240;,"SELECT DISTINCT painterID FROM paintings WHERE medium  =  ""oil"" AND LOCATION  =  ""Gallery 240""","1. Sequential Structure: Start with the SELECT clause to retrieve the unique ""Paintings.painterID"" of painters who meet the specified conditions. 2. Condition Structure: Use a WHERE clause to filter for paintings with the medium ""oil"" and location ""240."" 3. Join Structure: No JOIN is necessary since the required information is available in the ""Paintings"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique painter IDs are returned.",0.0
1199,What is the name and year of each painting created by the artist whose first name is Mary?,NON-NESTED,art_1,"[Artists.fname, Artists.artistID, Paintings.painterID = Artists.artistID, Paintings.title, Paintings.year, Mary]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.title, Paintings.year FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID WHERE Artists.fname = 'Mary';","SELECT T2.title ,   T2.year FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T1.fname  =  ""Mary""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paintings.title"" and ""Paintings.year"" for the paintings created by the artist whose first name is ""Mary."" 2. Condition Structure: Use a WHERE clause to filter for artists whose ""Artists.fname"" is ""Mary."" 3. Join Structure: Use a JOIN between the ""Paintings"" and ""Artists"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to link each painting with its respective artist. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without any summarization.",1.0
1200,Find the locations that have paintings created before 1885 and after 1930?,EASY,art_1,"[Paintings.location, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.location FROM Paintings WHERE Paintings.year < 1885 OR Paintings.year > 1930;,SELECT DISTINCT LOCATION FROM paintings WHERE YEAR  <  1885 INTERSECT SELECT DISTINCT LOCATION FROM paintings WHERE YEAR  >  1930,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""Paintings.location"". 2. Condition Structure: Use a WHERE clause to filter paintings that were created before 1885 or after 1930 based on the ""Paintings.year"". 3. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving locations that meet the specified year conditions.",1.0
1201,Show institution name which there is no staff in our record.,NESTED,conference,"[institution.Institution_Name,staff.Institution_ID = institution.Institution_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT Institution_Name FROM institution WHERE Institution_ID NOT IN (SELECT Institution_ID FROM staff);,SELECT institution_name FROM institution WHERE institution_id NOT IN (SELECT institution_id FROM staff),"1. Sequential Structure: Start with the SELECT clause to retrieve the institution name. Use the FROM clause to specify the institution table. Apply a WHERE clause to filter institutions that do not have any staff in the records. 2. Condition Structure: Use the WHERE clause with a subquery to exclude institutions whose Institution_ID appears in the staff table, meaning they have staff. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Institution_ID entries in the staff table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1202,What is the name of the institution with no staff in the records?,NESTED,conference,"[institution.Institution_Name,staff.Institution_ID = institution.Institution_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT Institution_Name FROM institution WHERE Institution_ID NOT IN (SELECT Institution_ID FROM staff);,SELECT institution_name FROM institution WHERE institution_id NOT IN (SELECT institution_id FROM staff),"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the institution. Use the FROM clause to specify the institution table. Apply a WHERE clause to filter institutions that have no staff in the records. 2. Condition Structure: Use the WHERE clause with a subquery to exclude institutions whose Institution_ID appears in the staff table, meaning they have staff records. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Institution_ID entries in the staff table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1203,"List the ids, names, and government websites of all districts sorted by population.",EASY,district_spokesman,"[district.District_ID, district.Name, district.Government_website, district.Population]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
","SELECT district.District_ID, district.Name, district.Government_website, district.Population FROM district ORDER BY district.Population ASC;","SELECT name ,  Government_website ,  district_id FROM district ORDER BY Population","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""district.District_ID"", ""district.Name"", ""district.Government_website"", and ""district.Population"". 2. Condition Structure: No specific filtering condition is required as the query asks for all districts. 3. Join Structure: No JOIN is required since all necessary data is within the ""district"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""district.Population"" in ascending order to sort the districts by their population.",1.0
1204,"Return the names of the different planes, as well as the names of the oldest pilots who flew each.",NON-NESTED,pilot_1,"[PilotSkills.plane_name, PilotSkills.pilot_name, PilotSkills.age, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.plane_name, PilotSkills.pilot_name FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE PilotSkills.age = (SELECT MAX(PilotSkills.age) FROM PilotSkills AS SubQuery WHERE SubQuery.plane_name = PilotSkills.plane_name);","SELECT pilot_name ,  plane_name ,  max(age) FROM pilotskills GROUP BY plane_name","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""plane_name"" and the ""pilot_name"" of the oldest pilot for each plane. Use MAX on the ""age"" field to identify the oldest pilot. 2. Condition Structure: No specific filtering condition is required, as we are interested in all planes and their oldest pilots. 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the ""plane_name"" field to link planes with their respective pilots. 4. Aggregation Structure: Use GROUP BY on ""plane_name"" to group results by each plane and apply MAX on ""age"" to find the oldest pilot for each plane.",0.0
1205,What are the names of pilots who have planes in both Austin and Boston?,NESTED,pilot_1,"[PilotSkills.pilot_name,Hangar.location,PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT DISTINCT PilotSkills.pilot_name FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE 'Austin' IN (SELECT location FROM Hangar WHERE Hangar.plane_name = PilotSkills.plane_name) AND 'Boston' IN (SELECT location FROM Hangar WHERE Hangar.plane_name = PilotSkills.plane_name);,"SELECT T1.pilot_name FROM pilotskills AS T1 JOIN hangar AS T2 ON T1.plane_name  =  T2.plane_name WHERE T2.location  =  ""Austin"" INTERSECT SELECT T1.pilot_name FROM pilotskills AS T1 JOIN hangar AS T2 ON T1.plane_name  =  T2.plane_name WHERE T2.LOCATION  =  ""Boston""","1. Sequential Structure: Start with the SELECT clause to retrieve the names of pilots. Use the FROM clause to specify the PilotSkills table and JOIN it with the Hangar table to connect pilots with the locations of their planes. Apply a WHERE clause to filter for pilots who have planes in both Austin and Boston. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the pilot has planes in both locations. The subquery checks for the distinct locations associated with each pilot's planes. 3. Join Structure: Use an INNER JOIN between the PilotSkills and Hangar tables based on the plane_name to link pilots with the locations of their planes. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1206,"Return the names of pilots who are older than any pilot who has flown Piper Cub, ordered alphabetically.",NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT pilot_name FROM PilotSkills WHERE age > ANY (SELECT age FROM PilotSkills WHERE plane_name = 'Piper Cub') ORDER BY pilot_name;,SELECT pilot_name FROM pilotskills WHERE age  >  (SELECT min(age) FROM pilotskills WHERE plane_name  =  'Piper Cub') ORDER BY pilot_name,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of pilots. Use the FROM clause to specify the PilotSkills table. Apply a WHERE clause to filter for pilots whose age is greater than the age of any pilot who has flown the Piper Cub. Use the ORDER BY clause to sort the results alphabetically by pilot name. 2. Condition Structure: Use the WHERE clause with a subquery to compare the age of pilots to the age of pilots who have flown the Piper Cub. The subquery retrieves the ages of pilots who have flown the Piper Cub. 3. Join Structure: Not required, as all relevant data is in the PilotSkills table. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1207,What are the names and nationalities of the people who did not participate in any ACL conferences?,NESTED,conference,"[staff.name, staff.Nationality, conference.Conference_Name, conference_participation.Conference_ID = conference.Conference_ID, conference_participation.staff_ID = staff.staff_ID, ACL]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT staff.name, staff.Nationality FROM staff WHERE staff.staff_ID NOT IN ( SELECT conference_participation.staff_ID FROM conference_participation JOIN conference ON conference_participation.Conference_ID = conference.Conference_ID WHERE conference.Conference_Name = 'ACL' );","SELECT name ,  nationality FROM staff WHERE staff_id NOT IN (SELECT T2.staff_id FROM Conference AS T1 JOIN Conference_participation AS T2 ON T1.conference_id  =  T2.conference_id WHERE T1.Conference_Name  =  ""ACL"")","1. Sequential Structure: Start with the SELECT clause to retrieve the names and nationalities of staff members. Use the FROM clause to specify the staff table. Apply a WHERE clause to filter for staff members who did not participate in any ACL conferences. 2. Condition Structure: Use the WHERE clause with a subquery to exclude staff members whose staff_ID appears in the conference_participation table for conferences with the name 'ACL'. 3. Join Structure: Use the conference and conference_participation tables to identify staff members who participated in ACL conferences. The conference_participation table links staff_ID with Conference_ID, and the conference table provides the conference name. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1208,"What are the different plane names of planes with an average pilot age of below 35, and how many pilots have flown each of them?",NESTED,pilot_1,"[PilotSkills.plane_name, PilotSkills.age, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.plane_name, COUNT(PilotSkills.age) AS num_pilots FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name GROUP BY PilotSkills.plane_name HAVING AVG(PilotSkills.age) < 35;","SELECT count(*) ,  plane_name FROM pilotskills GROUP BY plane_name HAVING avg(age)  <  35",1. Sequential Structure: Start with the SELECT clause to retrieve the distinct plane names and the count of pilots who have flown each plane. Use the FROM clause to specify the PilotSkills table and JOIN it with the Hangar table to connect planes with their pilots. Apply a WHERE clause to filter for planes with an average pilot age below 35. Use GROUP BY to group records by plane name and COUNT to calculate the number of pilots for each plane. 2. Condition Structure: Use the HAVING clause to filter planes where the average age of pilots is below 35. The average age is calculated using the AVG function. 3. Join Structure: Use an INNER JOIN between the PilotSkills and Hangar tables based on the plane_name field to connect pilot data with plane data. 4. Aggregation Structure: Use AVG to calculate the average age of pilots for each plane and COUNT to determine the number of pilots who have flown each plane.,1.0
1209,What is the name of the plane that is flown the most often?,EASY,pilot_1,[PilotSkills.plane_name],"Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT PilotSkills.plane_name FROM PilotSkills GROUP BY PilotSkills.plane_name ORDER BY COUNT(*) DESC LIMIT 1;,SELECT plane_name FROM pilotskills GROUP BY plane_name ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the plane name. 2. Aggregation Structure: Use COUNT to determine how often each plane is flown. 3. Grouping Structure: Use GROUP BY on ""PilotSkills.plane_name"" to aggregate the results by each plane name. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank planes by how often they are flown. 5. Limiting Structure: Use LIMIT 1 to retrieve the name of the plane that is flown the most often. 6. Join Structure: No JOIN is required since we are only interested in the ""PilotSkills"" table.",1.0
1210,What locations have works painted before 1885 or after 1930?,EASY,art_1,"[Paintings.location, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.location FROM Paintings WHERE Paintings.year < 1885 OR Paintings.year > 1930;,SELECT DISTINCT LOCATION FROM paintings WHERE YEAR  < 1885 OR YEAR  >  1930,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the location of the paintings. 2. Condition Structure: Use a WHERE clause to filter paintings that were painted either before 1885 or after 1930. 3. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving locations based on the specified condition.",1.0
1211,What are the first and last names of all distinct artists who made sculptures before 1900?,NON-NESTED,art_1,"[Artists.lname, Artists.fname, Sculptures.year, Sculptures.sculptorID = Artists.artistID, 1900]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT DISTINCT Artists.fname, Artists.lname FROM Sculptures JOIN Artists ON Sculptures.sculptorID = Artists.artistID WHERE Sculptures.year < 1900;","SELECT DISTINCT T1.lname ,  T1.fname FROM artists AS T1 JOIN sculptures AS T2 ON T1.artistID  =  T2.sculptorID WHERE T2.year  <  1900","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct first and last names of artists. Use DISTINCT to ensure unique results. 2. Condition Structure: Use a WHERE clause to filter for sculptures made before the year 1900. 3. Join Structure: Use a JOIN between the ""Sculptures"" and ""Artists"" tables based on the relationship ""Sculptures.sculptorID = Artists.artistID"" to link sculptures with their respective artists. 4. Aggregation Structure: No aggregation is needed as the query only requires distinct artist names.",1.0
1212,What are the first and last name of the artist who had a sculpture work whose title has the word “female” in it?,NON-NESTED,art_1,"[Artists.lname, Artists.fname, Sculptures.title, Sculptures.sculptorID = Artists.artistID, female]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.fname, Artists.lname FROM Sculptures JOIN Artists ON Sculptures.sculptorID = Artists.artistID WHERE Sculptures.title LIKE '%female%';","SELECT T1.lname ,  T1.fname FROM artists AS T1 JOIN sculptures AS T2 ON T1.artistID  =  T2.sculptorID WHERE T2.title LIKE ""%female%""","1. Sequential Structure: Start with the SELECT clause to retrieve the first name (""Artists.fname"") and last name (""Artists.lname"") of the artist. 2. Condition Structure: Use a WHERE clause to filter for sculptures whose title contains the word ""female."" 3. Join Structure: Use a JOIN between the ""Sculptures"" table and the ""Artists"" table based on the relationship ""Sculptures.sculptorID = Artists.artistID"" to link sculptures with their respective artists. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific details about the artist.",1.0
1213,Find the first and last names of the artists who have both works of paintings and sculptures?,NESTED,art_1,"[Artists.lname, Artists.fname, Paintings.painterID = Artists.artistID, Sculptures.sculptorID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.fname, Artists.lname FROM Artists JOIN Paintings ON Paintings.painterID = Artists.artistID JOIN Sculptures ON Sculptures.sculptorID = Artists.artistID;","SELECT T1.lname ,  T1.fname FROM artists AS T1 JOIN sculptures AS T2 ON T1.artistID  =  T2.sculptorID INTERSECT SELECT T3.lname ,  T3.fname FROM artists AS T3 JOIN paintings AS T4 ON T3.artistID  =  T4.painterID","1. Sequential Structure: Start with the SELECT clause to retrieve the first and last names of the artists. Use the FROM clause to specify the Artists table. Use JOINs to connect the Artists table with the Paintings and Sculptures tables to identify artists who have both paintings and sculptures. 2. Condition Structure: Use WHERE or filtering logic to ensure that only artists who appear in both the Paintings and Sculptures tables are selected. 3. Join Structure: Use INNER JOINs to connect the Artists table with the Paintings table on painterID = artistID and the Sculptures table on sculptorID = artistID. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1214,Count the number of planes Smith owns.,EASY,pilot_1,"[PilotSkills.pilot_name, PilotSkills.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(PilotSkills.plane_name) FROM PilotSkills WHERE PilotSkills.pilot_name = 'Smith';,SELECT count(plane_name) FROM pilotskills WHERE pilot_name  =  'Smith',"1. Sequential Structure: Start with the SELECT clause to count the number of planes owned by Smith. 2. Condition Structure: Use a WHERE clause to filter for records where the pilot's name is ""Smith."" 3. Join Structure: No JOIN is required since all necessary information is in the ""PilotSkills"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of planes owned by Smith.",1.0
1215,What are the ids of the paintings created before all of the paintings in gallery 240?,NESTED,art_1,"[Paintings.paintingID, Paintings.year, Paintings.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT paintingID FROM Paintings WHERE year < (SELECT MIN(year) FROM Paintings WHERE location = 240);,SELECT paintingID FROM paintings WHERE YEAR  <   (SELECT min(YEAR) FROM paintings WHERE LOCATION  =  'Gallery 240'),"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of paintings. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter paintings created before all paintings in gallery 240. 2. Condition Structure: Use the WHERE clause with a subquery to compare the year of creation of paintings with the minimum year of paintings in gallery 240. The subquery calculates the minimum year of paintings in gallery 240. 3. Join Structure: Not required, as all data is in the Paintings table. 4. Aggregation Structure: Use the MIN function in the subquery to find the earliest year of paintings in gallery 240, which is then used in the filtering condition.",0.0
1216,What is the painting count of the artist with the longest life ?,NESTED,art_1,"[Artists.artistID, Artists.birthYear, Artists.deathYear, Paintings.painterID, Paintings.paintingID, Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT COUNT(Paintings.paintingID) AS painting_count FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID WHERE Artists.artistID = ( SELECT artistID FROM Artists WHERE (deathYear - birthYear) = ( SELECT MAX(deathYear - birthYear) FROM Artists ) );,select count(*) from artists as t1 join paintings as t2 on t1.artistid  =  t2.painterid group by t2.painterid order by t1.deathyear - t1.birthyear desc limit 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the count of paintings. Use the FROM clause to specify the Paintings table and JOIN it with the Artists table to link paintings to their respective artists. Use a subquery to identify the artist with the longest life span by calculating the difference between deathYear and birthYear. 2. Condition Structure: Use a WHERE clause to filter for the artist with the longest life span, determined by the subquery. 3. Join Structure: Use an INNER JOIN between the Paintings and Artists tables based on the relationship between painterID and artistID to connect paintings with their respective artists. 4. Aggregation Structure: Use COUNT to calculate the total number of paintings for the artist with the longest life span.",1.0
1217,"Return the names of pilots who are younger than average, ordered by age ascending.",NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT pilot_name FROM PilotSkills WHERE age < (SELECT AVG(age) FROM PilotSkills) ORDER BY age ASC;,SELECT pilot_name FROM PilotSkills WHERE age  <  (SELECT avg(age) FROM PilotSkills) ORDER BY age,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of pilots. Use the FROM clause to specify the PilotSkills table. Apply a WHERE clause to filter for pilots whose age is less than the average age. Use the ORDER BY clause to sort the results by age in ascending order. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average age of all pilots and filter for those younger than this average. 3. Join Structure: Not required, as all data is in the PilotSkills table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average age of pilots, which is then used in the filtering condition.",1.0
1218,Find the names of all pilots who have a plane named Piper Cub and is under 35.,NON-NESTED,pilot_1,"[PilotSkills.pilot_name,PilotSkills.plane_name,PilotSkills.age,Hangar.plane_name,PilotSkills.plane_name = Hangar.plane_name,Piper Cub,35]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT PilotSkills.pilot_name FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE PilotSkills.age < 35 AND Hangar.plane_name = 'Piper Cub';,SELECT pilot_name FROM PilotSkills WHERE age  <  35 AND plane_name  =  'Piper Cub',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""PilotSkills.pilot_name"" field, as we are looking for the names of pilots. 2. Condition Structure: Use a WHERE clause to filter for pilots who are under 35 years old and have a plane named ""Piper Cub."" 3. Join Structure: Use an INNER JOIN between the ""PilotSkills"" and ""Hangar"" tables on the ""plane_name"" field to associate pilots with their respective planes. 4. Aggregation Structure: No aggregation is needed since we are retrieving individual pilot names based on the specified conditions.",1.0
1219,Show all staff names who attend a conference in 2003 or 2004.,NON-NESTED,conference,"[staff.name, conference.Year, conference_participation.Conference_ID = conference.Conference_ID, conference_participation.staff_ID = staff.staff_ID, 2003, 2004]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT DISTINCT staff.name FROM staff JOIN conference_participation ON conference_participation.staff_ID = staff.staff_ID JOIN conference ON conference_participation.Conference_ID = conference.Conference_ID WHERE conference.Year = 2003 OR conference.Year = 2004;,SELECT DISTINCT T1.name FROM staff AS T1 JOIN conference_participation AS T2 JOIN Conference AS T3 ON T1.staff_id  =  T2.staff_id AND T2.conference_id  =  T3.conference_id WHERE T3.year  =  2003 OR T3.year  =  2004,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of staff members who attended a conference. 2. Condition Structure: Use a WHERE clause to filter for records where ""conference.Year"" is either 2003 or 2004. 3. Join Structure: Use JOINs to connect ""conference_participation"" with ""conference"" on ""conference.Conference_ID"" and ""conference_participation"" with ""staff"" on ""conference_participation.staff_ID"" to link each staff member with their conference participation records. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique staff names are returned.",1.0
1220,Find the location of the plane that is owned by the youngest pilot.,NESTED,pilot_1,"[PilotSkills.age, PilotSkills.plane_name, Hangar.location, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT Hangar.location FROM Hangar JOIN PilotSkills ON PilotSkills.plane_name = Hangar.plane_name WHERE PilotSkills.age = (SELECT MIN(age) FROM PilotSkills);,SELECT T2.location FROM pilotskills AS T1 JOIN hangar AS T2 ON T1.plane_name  =  T2.plane_name WHERE T1.age  =  (SELECT min(age) FROM pilotskills),"1. Sequential Structure: Start with the SELECT clause to retrieve the location of the plane. Use the FROM clause to specify the Hangar table and JOIN it with the PilotSkills table on the plane_name field to connect planes with their respective pilots. Apply a WHERE clause to filter for the youngest pilot. 2. Condition Structure: Use the WHERE clause with a subquery to identify the youngest pilot by finding the minimum age in the PilotSkills table. 3. Join Structure: Use an INNER JOIN between the PilotSkills and Hangar tables based on the plane_name field to link the plane's location with the pilot's details. 4. Aggregation Structure: Use the MIN function in a subquery to find the youngest pilot's age, which is then used in the filtering condition.",1.0
1221,What is the title and location of the oldest painting ?,EASY,art_1,"[Paintings.title, Paintings.location, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.title, Paintings.location FROM Paintings ORDER BY Paintings.year ASC LIMIT 1;","select title ,  location from paintings order by year limit 1","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the title and location of the painting. 2. Condition Structure: No specific filtering condition is required, as we are looking for the oldest painting. 3. Aggregation Structure: Use ORDER BY on the ""Paintings.year"" field in ascending order to identify the oldest painting. 4. Limiting Structure: Use LIMIT 1 to retrieve only the oldest painting. 5. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table.",1.0
1222,"For each conference id, what are their names, year, and number of participants?",NON-NESTED,conference,"[conference.Conference_ID,conference.Conference_Name,conference.Year,conference_participation.Conference_ID,conference_participation.staff_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT conference.Conference_ID, conference.Conference_Name, conference.Year, COUNT(conference_participation.staff_ID) AS Number_of_Participants FROM conference JOIN conference_participation ON conference.Conference_ID = conference_participation.Conference_ID GROUP BY conference.Conference_ID;","SELECT T1.conference_name ,  T1.year ,  count(*) FROM Conference AS T1 JOIN Conference_participation AS T2 ON T1.conference_id  =  T2.conference_id GROUP BY T2.conference_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""conference.Conference_ID,"" ""conference.Conference_Name,"" ""conference.Year,"" and the count of participants (using COUNT on ""conference_participation.staff_ID""). 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""conference"" and ""conference_participation"" tables based on the shared key ""Conference_ID"" to link each conference with its participants. 4. Aggregation Structure: Use COUNT on ""conference_participation.staff_ID"" to count the number of participants for each conference, and GROUP BY ""conference.Conference_ID"" to group results by each conference.",1.0
1223,"What are the different pilot names, and what are the maximum ages of pilots for each?",EASY,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.pilot_name, MAX(PilotSkills.age) AS max_age FROM PilotSkills GROUP BY PilotSkills.pilot_name;","SELECT max(age) ,  pilot_name FROM pilotskills GROUP BY pilot_name","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the pilot names and the maximum ages of pilots. 2. Aggregation Structure: Use the MAX function to calculate the maximum age for each pilot. 3. Grouping Structure: Use GROUP BY on ""PilotSkills.pilot_name"" to calculate the maximum age for each pilot. 4. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table.",1.0
1224,What are the maximum and minimum age of driver?,EASY,car_road_race,[driver.Age],"Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT MAX(driver.Age) AS max_age, MIN(driver.Age) AS min_age FROM driver;","SELECT max(Age) ,  min(Age) FROM driver","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum ages of drivers. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum age of drivers. 3. Grouping Structure: No GROUP BY is required since we are calculating the aggregate values for all drivers. 4. Join Structure: No JOIN is required as all necessary data is within the ""driver"" table.",1.0
1225,How many paintings were created before 1900 in different locations?,EASY,art_1,"[Paintings.year, Paintings.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.location, COUNT(*) AS painting_count FROM Paintings WHERE Paintings.year < 1900 GROUP BY Paintings.location;","SELECT count(*) ,  LOCATION FROM paintings WHERE YEAR  <  1900 GROUP BY LOCATION","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the location and the count of paintings. 2. Condition Structure: Use a WHERE clause to filter for paintings created before the year 1900. 3. Grouping Structure: Use GROUP BY on ""Paintings.location"" to count the number of paintings for each location. 4. Aggregation Structure: Use COUNT to calculate the number of paintings created before 1900 in each location. 5. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table.",1.0
1226,Who are the constructors of drivers sorted by drivers' age in ascending order?,NON-NESTED,car_road_race,"[driver.Constructor, driver.Age, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT driver.Constructor, driver.Age FROM driver ORDER BY driver.Age ASC;",SELECT DISTINCT CONSTRUCTOR FROM driver ORDER BY Age ASC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Constructor"" and ""driver.Age"" fields. Since the question asks for sorting by drivers' age, include an ORDER BY clause to sort the results in ascending order of ""driver.Age."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: No JOIN is required as all the necessary information is available in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed as the query does not involve any summarization or grouping.",1.0
1227,What are the first and last names of the artist who lived the longest?,EASY,art_1,"[Artists.lname, Artists.fname, Artists.birthYear, Artists.deathYear]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.fname, Artists.lname FROM Artists ORDER BY (Artists.deathYear - Artists.birthYear) DESC LIMIT 1;","SELECT lname ,  fname FROM artists ORDER BY deathYear - birthYear DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the first and last names of the artist who lived the longest. 2. Condition Structure: Calculate the lifespan of each artist by subtracting ""Artists.birthYear"" from ""Artists.deathYear"". No specific filtering condition is required as we are looking for the artist with the maximum lifespan. 3. Aggregation Structure: Use ORDER BY in descending order on the calculated lifespan to rank artists by their lifespan. Apply LIMIT 1 to select the artist with the longest lifespan. 4. Join Structure: No JOIN is required since all necessary information is in the ""Artists"" table.",1.0
1228,Find the death year of all artists who have at most 3 paintings?,NESTED,art_1,"[Artists.deathYear,Paintings.painterID,Artists.artistID,Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.deathYear FROM Artists JOIN Paintings ON Paintings.painterID = Artists.artistID GROUP BY Artists.artistID, Artists.deathYear HAVING COUNT(Paintings.painterID) <= 3;",SELECT T1.deathYear FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID GROUP BY T2.painterID HAVING count(*)  <=  3,"1. Sequential Structure: Start with the SELECT clause to retrieve the death year of artists. Use the FROM clause to specify the Artists table and JOIN it with the Paintings table to connect artists with their paintings. Use GROUP BY to group records by artist ID, allowing us to count the number of paintings for each artist. Apply a HAVING clause to filter for artists with at most 3 paintings. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for artists who have 3 or fewer paintings. 3. Join Structure: Use an INNER JOIN between the Artists and Paintings tables based on the relationship between painterID and artistID to connect artists with their paintings. 4. Aggregation Structure: Use COUNT(*) within HAVING to count the number of paintings for each artist and filter out those with more than 3 paintings.",1.0
1229,What are the ids of paintings that are taller than 500 and shorter than 2000?,EASY,art_1,"[Paintings.paintingID, Paintings.height_mm, 500, 2000]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.paintingID FROM Paintings WHERE Paintings.height_mm > 500 AND Paintings.height_mm < 2000;,SELECT paintingID FROM paintings WHERE height_mm  >  500 AND height_mm  <  2000,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""Paintings.paintingID"". 2. Condition Structure: Use a WHERE clause to filter paintings where the ""Paintings.height_mm"" is greater than 500 and less than 2000. 3. Join Structure: No JOIN is required since all necessary information is in the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving painting IDs that meet the specified height condition.",1.0
1230,What are the names of all sculptures in gallery 226?,EASY,art_1,"[Sculptures.title,Sculptures.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Sculptures.title FROM Sculptures WHERE Sculptures.location = '226';,"SELECT title FROM sculptures WHERE LOCATION  =  ""Gallery 226""","1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the title of the sculptures. 2. Condition Structure: Use a WHERE clause to filter for sculptures located in gallery 226. 3. Join Structure: No JOIN is required since all necessary data is within the ""Sculptures"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the titles of sculptures based on a specific condition.",0.0
1231,What are the names and dates created for all sculptures not located in gallery 226?,NON-NESTED,art_1,"[Sculptures.title, Sculptures.year, Sculptures.location, Sculptures.sculptorID = Artists.artistID, Artists.lname, Artists.fname]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Sculptures.title, Sculptures.year FROM Sculptures WHERE Sculptures.location != '226';","SELECT title ,  YEAR FROM sculptures WHERE LOCATION != ""Gallery 226""","1. Sequential Structure: Start with the SELECT clause to retrieve the names (""Sculptures.title"") and creation dates (""Sculptures.year"") of sculptures. 2. Condition Structure: Use a WHERE clause to filter out sculptures located in gallery 226 by checking the ""Sculptures.location"" field. 3. Join Structure: No JOIN is required since the question only involves the ""Sculptures"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves specific fields without any summarization.",1.0
1232,"Order all of the oil paintings by date of creation and list their ids, locations, and titles.",EASY,art_1,"[Paintings.paintingID, Paintings.location, Paintings.title, Paintings.year, Paintings.medium]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.paintingID, Paintings.location, Paintings.title FROM Paintings WHERE Paintings.medium = 'oil' ORDER BY Paintings.year ASC;","SELECT paintingID ,  title ,  LOCATION FROM paintings WHERE medium  =  ""oil"" ORDER BY YEAR","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the painting ID, location, and title. Additionally, include the year for ordering purposes. 2. Condition Structure: Use a WHERE clause to filter for paintings where the medium is 'oil'. 3. Ordering Structure: Use ORDER BY on the year of creation in ascending order to list the paintings by their creation date. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data.",1.0
1233,How many planes are controlled by the pilots whose age is older than 40?,NON-NESTED,pilot_1,"[PilotSkills.plane_name, PilotSkills.age, Hangar.plane_name = PilotSkills.plane_name, 40]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(DISTINCT PilotSkills.plane_name) FROM PilotSkills JOIN Hangar ON Hangar.plane_name = PilotSkills.plane_name WHERE PilotSkills.age > 40;,SELECT count(plane_name) FROM pilotskills WHERE age  >  40,"1. Sequential Structure: Start with the SELECT clause to count the number of planes controlled by pilots. Use COUNT on ""PilotSkills.plane_name"" to get the total number of planes. 2. Condition Structure: Use a WHERE clause to filter for pilots whose age is greater than 40. 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the ""plane_name"" field to link planes with their respective pilots. 4. Aggregation Structure: Use COUNT to aggregate the number of planes controlled by pilots meeting the age condition.",0.0
1234,Find the pilots who have either plane Piper Cub or plane F-14 Fighter.,EASY,pilot_1,"[PilotSkills.pilot_name,PilotSkills.plane_name,Piper Cub,F-14 Fighter]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT PilotSkills.pilot_name FROM PilotSkills WHERE PilotSkills.plane_name = 'Piper Cub' OR PilotSkills.plane_name = 'F-14 Fighter';,SELECT pilot_name FROM pilotskills WHERE plane_name  =  'Piper Cub' OR plane_name  =  'F-14 Fighter',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""PilotSkills.pilot_name"" of pilots who have either the plane ""Piper Cub"" or ""F-14 Fighter"". 2. Condition Structure: Use a WHERE clause to filter for pilots whose ""PilotSkills.plane_name"" is either ""Piper Cub"" or ""F-14 Fighter"". 3. Join Structure: No JOIN is required since all necessary information is in the ""PilotSkills"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving pilot names based on the specified condition.",1.0
1235,Find the top 3 artists who have the biggest number of painting works whose medium is oil?,NON-NESTED,art_1,"[Artists.artistID, Paintings.painterID, Paintings.medium, Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.artistID, COUNT(Paintings.painterID) AS painting_count FROM Artists JOIN Paintings ON Paintings.painterID = Artists.artistID WHERE Paintings.medium = 'oil' GROUP BY Artists.artistID ORDER BY painting_count DESC LIMIT 3;","SELECT T1.lname ,  T1.fname FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T2.medium  =  ""oil"" GROUP BY T2.painterID ORDER BY count(*) DESC LIMIT 3","1. Sequential Structure: Start with the SELECT clause to retrieve the artist's ID and the count of their painting works. Since we are interested in the top 3 artists, use ORDER BY to sort the results in descending order of the number of painting works and LIMIT 3 to get the top 3. 2. Condition Structure: Use a WHERE clause to filter for paintings where the medium is ""oil."" 3. Join Structure: Use a JOIN between the ""Artists"" and ""Paintings"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to associate each painting with its respective artist. 4. Aggregation Structure: Use COUNT to calculate the number of painting works for each artist, and GROUP BY ""Artists.artistID"" to group the results by artist.",0.0
1236,"What are the different plane names, ordered alphabetically?",EASY,pilot_1,[PilotSkills.plane_name],"Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT DISTINCT PilotSkills.plane_name FROM PilotSkills ORDER BY PilotSkills.plane_name ASC;,SELECT DISTINCT plane_name FROM pilotskills ORDER BY plane_name,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""plane_name"". 2. Condition Structure: No specific filtering condition is required as we want all distinct plane names. 3. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table. 4. Aggregation Structure: Use DISTINCT to ensure only unique plane names are retrieved. 5. Ordering Structure: Use ORDER BY in ascending order to sort the plane names alphabetically.",1.0
1237,Give the names of pilots who have planes in Austin and Boston.,NESTED,pilot_1,"[PilotSkills.pilot_name,Hangar.location,PilotSkills.plane_name = Hangar.plane_name,Austin,Boston]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.pilot_name FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE Hangar.location IN ('Austin', 'Boston') GROUP BY PilotSkills.pilot_name HAVING COUNT(DISTINCT Hangar.location) = 2;","SELECT T1.pilot_name FROM pilotskills AS T1 JOIN hangar AS T2 ON T1.plane_name  =  T2.plane_name WHERE T2.location  =  ""Austin"" INTERSECT SELECT T1.pilot_name FROM pilotskills AS T1 JOIN hangar AS T2 ON T1.plane_name  =  T2.plane_name WHERE T2.LOCATION  =  ""Boston""",1. Sequential Structure: Start with the SELECT clause to retrieve the names of pilots. Use the FROM clause to specify the PilotSkills table and JOIN it with the Hangar table to connect pilots with the locations of their planes. Apply a WHERE clause to filter for planes located in both Austin and Boston. 2. Condition Structure: Use the WHERE clause to filter for planes that are located in both Austin and Boston. This can be achieved by grouping the data by pilot_name and ensuring that the count of distinct locations (Austin and Boston) for each pilot is 2. 3. Join Structure: Use an INNER JOIN between the PilotSkills and Hangar tables based on the plane_name to connect pilots with the locations of their planes. 4. Aggregation Structure: Use GROUP BY to group records by pilot_name and HAVING to ensure that each pilot has planes in both Austin and Boston.,1.0
1238,Find the titles of paintings and sculpture works made by the artist whose id is 222?,NON-NESTED,art_1,"[Paintings.title,Paintings.painterID,Artists.artistID = Paintings.painterID,Sculptures.title,Sculptures.sculptorID,Artists.artistID = Sculptures.sculptorID,Artists.artistID,222]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.title FROM Paintings WHERE Paintings.painterID = 222 UNION SELECT Sculptures.title FROM Sculptures WHERE Sculptures.sculptorID = 222;,SELECT T2.title FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T1.artistID  =  222 UNION SELECT T4.title FROM artists AS T3 JOIN sculptures AS T4 ON T3.artistID  =  T4.sculptorID WHERE T3.artistID  =  222,"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of paintings and sculpture works. Since the titles are in two different tables (""Paintings"" and ""Sculptures""), we will need to combine the results using a UNION. 2. Condition Structure: Use a WHERE clause to filter for works created by the artist with ID 222. This condition will be applied to both the ""Paintings"" and ""Sculptures"" tables. 3. Join Structure: No explicit JOIN is required because the artist ID is directly available in both the ""Paintings"" and ""Sculptures"" tables. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving the titles of works.",1.0
1239,What is the average height of paintings for different medium types?,EASY,art_1,"[Paintings.height_mm, Paintings.medium]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.medium, AVG(Paintings.height_mm) AS avg_height FROM Paintings GROUP BY Paintings.medium;","SELECT avg(height_mm) ,  medium FROM paintings GROUP BY medium","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the medium type and the average height of paintings. 2. Aggregation Structure: Use the AVG function to calculate the average height of paintings for each medium type. 3. Grouping Structure: Use GROUP BY on ""Paintings.medium"" to calculate the average height for each medium type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table.",1.0
1240,Please list the names of races with drivers aged 26 or older participating.,NON-NESTED,car_road_race,"[race.Race_Name,driver.Age,race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT DISTINCT race.Race_Name FROM race JOIN driver ON race.Driver_ID = driver.Driver_ID WHERE driver.Age >= 26;,SELECT T2.Race_Name FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID WHERE T1.Age  >=  26,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""race.Race_Name"" field, as we are interested in the names of races. 2. Condition Structure: Use a WHERE clause to filter for drivers aged 26 or older by checking the ""driver.Age"" field. 3. Join Structure: Use a JOIN between the ""race"" and ""driver"" tables based on the relationship ""race.Driver_ID = driver.Driver_ID"" to associate races with their respective drivers. 4. Aggregation Structure: No aggregation is needed, as we are simply listing the race names.",1.0
1241,List the title and location of all sculptures.,EASY,art_1,"[Sculptures.title, Sculptures.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Sculptures.title, Sculptures.location FROM Sculptures;","SELECT title ,  LOCATION FROM sculptures","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the title and location of sculptures. 2. Condition Structure: No specific filtering condition is required as we want all sculptures. 3. Join Structure: No JOIN is required since all necessary information is in the ""Sculptures"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the title and location of all sculptures.",1.0
1242,How many paintings are exhibited at gallery 240?,EASY,art_1,"[Paintings.location, Paintings.paintingID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT COUNT(Paintings.paintingID) FROM Paintings WHERE Paintings.location = 240;,"SELECT count(*) FROM paintings WHERE LOCATION  =  ""Gallery 240""","1. Sequential Structure: Start with the SELECT clause to count the number of paintings exhibited at gallery 240. 2. Condition Structure: Use a WHERE clause to filter for paintings where the ""Paintings.location"" is 240. 3. Join Structure: No JOIN is required since all necessary information is in the ""Paintings"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of paintings that meet the specified condition.",0.0
1243,What are the names of pilots who are younger than 35 and have a plane named Piper Cub?,NON-NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name, 35, Piper Cub]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT PilotSkills.pilot_name FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE PilotSkills.age < 35 AND Hangar.plane_name = 'Piper Cub';,SELECT pilot_name FROM PilotSkills WHERE age  <  35 AND plane_name  =  'Piper Cub',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of pilots (""PilotSkills.pilot_name""). 2. Condition Structure: Use a WHERE clause to filter for pilots who are younger than 35 (""PilotSkills.age < 35"") and have a plane named ""Piper Cub"" (""Hangar.plane_name = 'Piper Cub'""). 3. Join Structure: Use an INNER JOIN between the ""PilotSkills"" and ""Hangar"" tables on the shared key ""PilotSkills.plane_name = Hangar.plane_name"" to associate pilots with their planes. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific pilot names based on the conditions.",1.0
1244,Return the average and minimum ages across all pilots.,EASY,pilot_1,[PilotSkills.age],"Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT AVG(PilotSkills.age) AS average_age, MIN(PilotSkills.age) AS minimum_age FROM PilotSkills;","SELECT avg(age) ,  min(age) FROM pilotskills","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average and minimum ages. 2. Aggregation Structure: Use AVG and MIN functions to calculate the average and minimum ages across all pilots. 3. Grouping Structure: No GROUP BY is needed since the query asks for aggregate values across all pilots. 4. Join Structure: No JOIN is required as all necessary data is within the ""PilotSkills"" table.",1.0
1245,What are the staff names who participated in conferences between 2003 or 2004?,NESTED,conference,"[staff.name, conference.Year, conference_participation.Conference_ID = conference.Conference_ID, conference_participation.staff_ID = staff.staff_ID, 2003, 2004]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT staff.name FROM staff JOIN conference_participation ON staff.staff_ID = conference_participation.staff_ID JOIN conference ON conference_participation.Conference_ID = conference.Conference_ID WHERE conference.Year IN (2003, 2004);",SELECT DISTINCT T1.name FROM staff AS T1 JOIN conference_participation AS T2 JOIN Conference AS T3 ON T1.staff_id  =  T2.staff_id AND T2.conference_id  =  T3.conference_id WHERE T3.year  =  2003 OR T3.year  =  2004,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of staff members. Use the FROM clause to specify the staff table and join it with the conference_participation and conference tables to link staff members with the conferences they participated in. Apply a WHERE clause to filter for conferences held in the years 2003 or 2004. 2. Condition Structure: Use the WHERE clause to filter for conferences where the year is either 2003 or 2004. 3. Join Structure: Use INNER JOINs between the staff, conference_participation, and conference tables. The staff table is joined with conference_participation on staff_ID, and conference_participation is joined with conference on Conference_ID. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1246,What is the name of the scuplture that was created most recently ?,EASY,art_1,"[Sculptures.title, Sculptures.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Sculptures.title FROM Sculptures ORDER BY Sculptures.year DESC LIMIT 1;,select title from sculptures order by year desc limit 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sculptures.title"" of the sculpture created most recently. 2. Condition Structure: No specific filtering condition is needed since we are looking for the most recent sculpture. 3. Join Structure: No JOIN is required as all necessary information is in the ""Sculptures"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""Sculptures.year"" to rank sculptures by their creation year. Apply LIMIT 1 to select the most recent sculpture.",1.0
1247,How many pilots who are older than 40 or younger than 30?,EASY,pilot_1,"[PilotSkills.pilot_name,PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(*) FROM PilotSkills WHERE PilotSkills.age > 40 OR PilotSkills.age < 30;,SELECT count(pilot_name) FROM pilotskills ORDER BY age  >  40 OR age  <  30,"1. Sequential Structure: Begin with the SELECT clause to count the number of pilots who meet the age criteria. 2. Condition Structure: Use a WHERE clause to filter pilots whose age is either greater than 40 or less than 30. 3. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of pilots who satisfy the age condition.",0.0
1248,Please show the names of drivers and the names of races they participate in.,NON-NESTED,car_road_race,"[driver.Driver_Name, race.Race_Name, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT driver.Driver_Name, race.Race_Name FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID;","SELECT T1.Driver_Name ,  T2.Race_Name FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""driver.Driver_Name"" and ""race.Race_Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""driver"" and ""race"" tables based on the relationship ""race.Driver_ID = driver.Driver_ID"" to link each driver with the races they participate in. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the names of drivers and the races they participate in.",1.0
1249,What are the names of  paintings and scupltures created between 1900 and 1950?,NESTED,art_1,"[Paintings.title,Paintings.year,Sculptures.title,Sculptures.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT title FROM Paintings WHERE year BETWEEN 1900 AND 1950 UNION SELECT title FROM Sculptures WHERE year BETWEEN 1900 AND 1950;,SELECT title FROM paintings WHERE YEAR BETWEEN 1900 AND 1950 UNION SELECT title FROM sculptures WHERE YEAR BETWEEN 1900 AND 1950,"1. Sequential Structure: Start with the SELECT clause to retrieve the names (titles) of paintings and sculptures. Use the FROM clause to specify the Paintings and Sculptures tables. Apply a WHERE clause to filter records for the year range between 1900 and 1950. 2. Condition Structure: Use the WHERE clause to filter for entries where the year is between 1900 and 1950 for both paintings and sculptures. 3. Join Structure: Not required, as the data is retrieved independently from the Paintings and Sculptures tables. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1250,Find all spokesman's names and speech titles.,EASY,district_spokesman,"[spokesman.Name, spokesman.Speach_title]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
","SELECT spokesman.Name, spokesman.Speach_title FROM spokesman;","SELECT name ,  speach_title FROM spokesman","1. Sequential Structure: Start with the SELECT clause to retrieve the spokesman's names and their speech titles. 2. Condition Structure: No specific filtering condition is required as the query asks for all spokesman names and their speech titles. 3. Join Structure: No JOIN is required since all necessary information is available in the ""spokesman"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and speech titles.",1.0
1251,Find the names of districts which have more than one spokesman.,NON-NESTED,district_spokesman,"[district.Name, spokesman_district.District_ID, spokesman_district.Spokesman_ID, spokesman_district.District_ID = district.District_ID]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
",SELECT district.Name FROM district JOIN spokesman_district ON district.District_ID = spokesman_district.District_ID GROUP BY district.Name HAVING COUNT(spokesman_district.Spokesman_ID) > 1;,SELECT t1.name FROM district AS t1 JOIN spokesman_district AS t2 ON t1.District_ID  =  t2.District_ID GROUP BY t2.District_ID HAVING count(*)  >  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of districts. Use a GROUP BY clause to group the results by district. 2. Condition Structure: Apply a HAVING clause to filter districts that have more than one spokesman. 3. Join Structure: Use a JOIN between the ""district"" table and the ""spokesman_district"" table based on the ""District_ID"" field to associate each district with its spokesmen. 4. Aggregation Structure: Use COUNT on ""spokesman_district.Spokesman_ID"" to count the number of spokesmen per district, then filter with HAVING to select districts with more than one spokesman.",1.0
1252,"For each institution id , how many staff members does each institution have that was founded after 1800 ? return their names .",NON-NESTED,conference,"[institution.Institution_ID, institution.Founded, staff.Institution_ID = institution.Institution_ID, staff.name]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT institution.Institution_ID, COUNT(staff.name) AS staff_count, staff.name FROM institution JOIN staff ON institution.Institution_ID = staff.Institution_ID WHERE institution.Founded > 1800 GROUP BY institution.Institution_ID, staff.name;","select t1.institution_name ,  count(*) from institution as t1 join staff as t2 on t1.institution_id  =  t2.institution_id where t1.founded  >  1800 group by t2.institution_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""institution.Institution_ID"" and the count of staff members for each institution. Also include ""staff.name"" to return their names. 2. Condition Structure: Use a WHERE clause to filter institutions that were founded after 1800. 3. Join Structure: Use a JOIN between the ""institution"" and ""staff"" tables based on ""institution.Institution_ID"" and ""staff.Institution_ID"" to associate staff members with their respective institutions. 4. Aggregation Structure: Use COUNT to count the number of staff members for each institution. Use GROUP BY to group results by ""institution.Institution_ID.""",0.0
1253,What are the names and locations of the most recently-founded institution?,EASY,conference,"[institution.Institution_Name, institution.Location, institution.Founded]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT institution.Institution_Name, institution.Location FROM institution ORDER BY institution.Founded DESC LIMIT 1;","SELECT institution_name ,  LOCATION FROM institution ORDER BY founded DESC LIMIT 1","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""institution.Institution_Name"" and ""institution.Location"". 2. Condition Structure: No specific filtering condition is required, as we are looking for the institution with the most recent founding year. 3. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""institution.Founded"" to rank institutions by their founding year. Apply LIMIT 1 to retrieve the most recently-founded institution.",1.0
1254,Find the unique id of the painters who had medium oil paintings exhibited at gallery 240?,NON-NESTED,art_1,"[Paintings.painterID, Paintings.medium, Paintings.location, Artists.artistID, Paintings.painterID = Artists.artistID, oil, 240]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT Paintings.painterID FROM Paintings WHERE Paintings.medium = 'oil' AND Paintings.location = 240;,"SELECT DISTINCT painterID FROM paintings WHERE medium  =  ""oil"" AND LOCATION  =  ""Gallery 240""","1. Sequential Structure: Start with the SELECT clause to retrieve the unique ""Paintings.painterID"" of painters who meet the specified conditions. 2. Condition Structure: Use a WHERE clause to filter for paintings with the medium ""oil"" and location ""240."" 3. Join Structure: No JOIN is necessary since the required information is available in the ""Paintings"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique painter IDs are returned.",0.0
1255,Please show the names of drivers and the number of races they participate in.,NON-NESTED,car_road_race,"[driver.Driver_Name, race.Driver_ID, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT driver.Driver_Name, COUNT(race.Driver_ID) AS Number_of_Races FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID GROUP BY driver.Driver_Name;","SELECT T1.Driver_Name ,  COUNT(*) FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID GROUP BY T1.Driver_ID","1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Driver_Name"" and the count of races each driver participates in. Use COUNT on ""race.Driver_ID"" to calculate the number of races for each driver. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""driver"" and ""race"" tables based on the relationship ""race.Driver_ID = driver.Driver_ID"" to associate each driver with their races. 4. Aggregation Structure: Use COUNT to count the number of races for each driver and GROUP BY ""driver.Driver_Name"" to group the results by driver.",1.0
1256,Find the birth years of all distinct artists who made sculptures after 1920?,NON-NESTED,art_1,"[Artists.birthYear,Sculptures.year,Sculptures.sculptorID = Artists.artistID,1920]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT Artists.birthYear FROM Sculptures JOIN Artists ON Sculptures.sculptorID = Artists.artistID WHERE Sculptures.year > 1920;,SELECT DISTINCT T1.birthYear FROM artists AS T1 JOIN sculptures AS T2 ON T1.artistID  =  T2.sculptorID WHERE T2.year  >  1920,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Artists.birthYear."" 2. Condition Structure: Use a WHERE clause to filter for sculptures made after the year 1920. 3. Join Structure: Use a JOIN between the ""Sculptures"" and ""Artists"" tables based on the relationship ""Sculptures.sculptorID = Artists.artistID"" to link sculptures with their respective artists. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique birth years of artists are returned.",1.0
1257,Find the distinct titles of all the paintings that have a longer height than some painting on canvas?,NESTED,art_1,"[Paintings.title, Paintings.height_mm, Paintings.medium]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT Paintings.title FROM Paintings WHERE Paintings.height_mm > ANY (SELECT Paintings.height_mm FROM Paintings WHERE Paintings.medium = 'canvas');,"SELECT DISTINCT title FROM paintings WHERE height_mm  >  (SELECT min(height_mm) FROM paintings WHERE mediumOn  =  ""canvas"")","1. Sequential Structure: Start with the SELECT clause to retrieve distinct titles of paintings. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter paintings with a height greater than some painting on canvas. 2. Condition Structure: Use the WHERE clause with a subquery to compare the height of paintings to the height of paintings with the medium 'canvas'. The subquery retrieves the heights of all paintings on canvas. 3. Join Structure: Not required, as all data is within the Paintings table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",0.0
1258,What are the names and points of spokesmen who are younger than 40?,EASY,district_spokesman,"[spokesman.Name, spokesman.Points, spokesman.Age]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
","SELECT spokesman.Name, spokesman.Points FROM spokesman WHERE spokesman.Age < 40;","SELECT name ,  points FROM spokesman WHERE age  <  40","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the names and points of the spokesmen. 2. Condition Structure: Use a WHERE clause to filter for spokesmen whose age is less than 40. 3. Join Structure: No JOIN is required since all necessary data is within the ""spokesman"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific fields based on a condition.",1.0
1259,Which locations have paintings in the mediums of on panel and on canvas?,NESTED,art_1,"[Paintings.location, Paintings.medium]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT DISTINCT location FROM Paintings WHERE medium IN ('ON panel', 'ON canvas');","SELECT DISTINCT LOCATION FROM paintings WHERE mediumOn  =  ""panel"" INTERSECT SELECT DISTINCT LOCATION FROM paintings WHERE mediumOn  =  ""canvas""","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct locations. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter for paintings with mediums ""on panel"" and ""on canvas"". 2. Condition Structure: Use the WHERE clause to filter for paintings where the medium is either ""on panel"" or ""on canvas"". 3. Join Structure: Not required, as all data is available within the Paintings table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",0.0
1260,List the names of all distinct paintings ordered by length.,EASY,art_1,"[Paintings.title, Paintings.height_mm, Paintings.width_mm]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT Paintings.title FROM Paintings ORDER BY Paintings.height_mm;,SELECT DISTINCT title FROM paintings ORDER BY height_mm,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the distinct painting titles. 2. Aggregation Structure: No aggregation is needed since we are retrieving distinct painting titles. 3. Ordering Structure: Use ORDER BY to sort the paintings by their length. The length can be calculated as the height in millimeters. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table.",1.0
1261,Find the death year of the artist who made the least number of sculptures?,NON-NESTED,art_1,"[Artists.deathYear, Sculptures.sculptorID, Sculptures.sculptorID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Artists.deathYear FROM Sculptures JOIN Artists ON Sculptures.sculptorID = Artists.artistID GROUP BY Artists.artistID ORDER BY COUNT(Sculptures.sculptorID) ASC LIMIT 1;,SELECT T1.deathYear FROM artists AS T1 JOIN sculptures AS T2 ON T1.artistID  =  T2.sculptorID GROUP BY T2.sculptorID ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Artists.deathYear"" of the artist. Use an aggregation function (COUNT) to count the number of sculptures made by each artist. Use ORDER BY to sort the artists by the number of sculptures in ascending order and LIMIT 1 to get the artist with the least number of sculptures. 2. Condition Structure: No specific filtering condition is required, as we are considering all artists and their sculptures. 3. Join Structure: Use a JOIN between the ""Sculptures"" and ""Artists"" tables based on the relationship ""Sculptures.sculptorID = Artists.artistID"" to link sculptures to their respective artists. 4. Aggregation Structure: Use COUNT to count the number of sculptures for each artist, and then use ORDER BY and LIMIT to find the artist with the least number of sculptures.",1.0
1262,When did each artist who created less than 4 paintings die ?,NESTED,art_1,"[Artists.artistID, Artists.deathYear, Paintings.painterID, Paintings.paintingID, Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.deathYear FROM Artists JOIN Paintings ON Paintings.painterID = Artists.artistID GROUP BY Artists.artistID, Artists.deathYear HAVING COUNT(Paintings.paintingID) < 4;",select t1.deathyear from artists as t1 join paintings as t2 on t1.artistid  =  t2.painterid group by t2.painterid having count(*)  <  4,1. Sequential Structure: Start with the SELECT clause to retrieve the death year of each artist. Use the FROM clause to specify the Artists table and JOIN it with the Paintings table to link artists with their paintings. Use GROUP BY to group records by artistID to count the number of paintings created by each artist. Apply a HAVING clause to filter artists who created less than 4 paintings. 2. Condition Structure: Use the HAVING clause with COUNT(Paintings.paintingID) to filter for artists who created fewer than 4 paintings. 3. Join Structure: Use an INNER JOIN between the Artists and Paintings tables based on the relationship between artistID and painterID to connect artists with their paintings. 4. Aggregation Structure: Use COUNT(Paintings.paintingID) to count the number of paintings created by each artist and filter based on this count.,1.0
1263,Tell me the height and id number of the widest painting in gallery 240.,NESTED,art_1,"[Paintings.height_mm, Paintings.paintingID, Paintings.width_mm, Paintings.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT height_mm, paintingID FROM Paintings WHERE location = 240 AND width_mm = (SELECT MAX(width_mm) FROM Paintings WHERE location = 240);","SELECT paintingID ,  height_mm FROM paintings WHERE LOCATION  =  'Gallery 240' ORDER BY width_mm DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the height and id number of the painting. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter for paintings located in gallery 240 and having the maximum width. 2. Condition Structure: Use the WHERE clause to filter for paintings in gallery 240 and use a subquery to find the painting with the maximum width in that gallery. 3. Join Structure: Not required, as all data is available within the Paintings table. 4. Aggregation Structure: Use MAX in a subquery to find the maximum width of paintings in gallery 240, and filter the main query based on this value.",0.0
1264,"What are the names of drivers, ordered descending alphabetically?",EASY,car_road_race,[driver.Driver_Name],"Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Driver_Name FROM driver ORDER BY driver.Driver_Name DESC;,SELECT Driver_Name FROM driver ORDER BY Driver_Name DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""driver.Driver_Name"". 2. Condition Structure: No specific filtering condition is required as we want all driver names. 3. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the driver names. 5. Ordering Structure: Use ORDER BY in descending alphabetical order on ""driver.Driver_Name"".",1.0
1265,What are the titles of paintings that are created after 1910 and whose medium is oil?,EASY,art_1,"[Paintings.title, Paintings.year, Paintings.medium]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.title FROM Paintings WHERE Paintings.year > 1910 AND Paintings.medium = 'oil';,"SELECT title FROM paintings WHERE YEAR  >  1910 AND medium  =  ""oil""","1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the title of the paintings. 2. Condition Structure: Use a WHERE clause to filter paintings that were created after 1910 and have the medium ""oil"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the titles of paintings that meet the specified conditions.",1.0
1266,What are the names of pilots who have flown Piper Cub but not the B-52 Bomber?,NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.plane_name, PilotSkills.plane_name = Hangar.plane_name, Piper Cub, B-52 Bomber]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT DISTINCT pilot_name FROM PilotSkills WHERE plane_name = 'Piper Cub' AND pilot_name NOT IN ( SELECT pilot_name FROM PilotSkills WHERE plane_name = 'B-52 Bomber' );,SELECT pilot_name FROM pilotskills WHERE plane_name  =  'Piper Cub' EXCEPT SELECT pilot_name FROM pilotskills WHERE plane_name  =  'B-52 Bomber',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of pilots. Use the FROM clause to specify the PilotSkills table. Apply a WHERE clause to filter pilots who have flown the ""Piper Cub"" and exclude those who have flown the ""B-52 Bomber"". 2. Condition Structure: Use the WHERE clause to filter for pilots who have flown the ""Piper Cub"". Use a subquery in the WHERE clause to exclude pilots who have flown the ""B-52 Bomber"". 3. Join Structure: Not required, as all necessary data is available in the PilotSkills table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1267,How many plane B-52 Bomber owned by the pilot who is under 35?,NON-NESTED,pilot_1,"[PilotSkills.plane_name, PilotSkills.age, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name, B-52 Bomber, 35]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(*) FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE PilotSkills.age < 35 AND Hangar.plane_name = 'B-52 Bomber';,SELECT count(*) FROM pilotskills WHERE age  <  35 AND plane_name  =  'B-52 Bomber',"1. Sequential Structure: Start with the SELECT clause to count the number of ""B-52 Bomber"" planes owned by pilots. Use COUNT to aggregate the results. 2. Condition Structure: Use a WHERE clause to filter for pilots under the age of 35 and for planes with the name ""B-52 Bomber."" 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the shared ""plane_name"" field to associate pilots with the planes they own. 4. Aggregation Structure: Use COUNT to calculate the total number of ""B-52 Bomber"" planes owned by pilots under the specified age.",1.0
1268,Show all staff names who have been both speaker and sponsor in some conference.,NESTED,conference,"[staff.name, conference_participation.role, conference_participation.staff_ID = staff.staff_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT staff.name FROM staff JOIN conference_participation ON staff.staff_ID = conference_participation.staff_ID WHERE EXISTS ( SELECT 1 FROM conference_participation cp1 WHERE cp1.staff_ID = staff.staff_ID AND cp1.role = 'speaker' ) AND EXISTS ( SELECT 1 FROM conference_participation cp2 WHERE cp2.staff_ID = staff.staff_ID AND cp2.role = 'sponsor' );,SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.role  =  'Speaker' INTERSECT SELECT T1.name FROM staff AS T1 JOIN conference_participation AS T2 ON T1.staff_id  =  T2.staff_id WHERE T2.role  =  'Sponsor',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of staff members. Use the FROM clause to specify the staff table and JOIN it with the conference_participation table to link staff members with their roles in conferences. Use a WHERE clause to filter staff members who have been both a speaker and a sponsor in some conference. 2. Condition Structure: Use the WHERE clause with EXISTS subqueries to check if a staff member has the role of 'speaker' and also the role of 'sponsor' in the conference_participation table. 3. Join Structure: Use an INNER JOIN between the staff and conference_participation tables based on staff_ID to connect staff details with their conference roles. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1269,"What are the first names of all artists who have at least two paintings, and how many works did each create?",NON-NESTED,art_1,"[Artists.fname, Paintings.painterID, Artists.artistID = Paintings.painterID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.fname, COUNT(Paintings.painterID) AS num_paintings FROM Artists JOIN Paintings ON Artists.artistID = Paintings.painterID GROUP BY Artists.artistID HAVING COUNT(Paintings.painterID) >= 2;","SELECT T1.fname ,  count(*) FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID GROUP BY T2.painterID HAVING count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve the first names of artists (""Artists.fname"") and the count of their paintings. Use COUNT to calculate the number of paintings for each artist. 2. Condition Structure: Use a HAVING clause to filter for artists who have created at least two paintings. 3. Join Structure: Use an INNER JOIN to connect the ""Artists"" table with the ""Paintings"" table based on the relationship ""Artists.artistID = Paintings.painterID."" 4. Aggregation Structure: Use COUNT to count the number of paintings for each artist, and GROUP BY ""Artists.artistID"" to group the results by each artist.",1.0
1270,How many races did each driver participate in?,NON-NESTED,car_road_race,"[race.Driver_ID, driver.Driver_ID = race.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT driver.Driver_ID, COUNT(race.Driver_ID) AS race_count FROM race GROUP BY race.Driver_ID;","SELECT T1.Driver_Name ,  COUNT(*) FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID GROUP BY T1.Driver_ID","1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Driver_ID"" and the count of races each driver participated in. Use COUNT to count the number of races for each driver. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: No JOIN is necessary since the relevant data is already linked through the ""race.Driver_ID"" and ""driver.Driver_ID."" 4. Aggregation Structure: Use COUNT to count the number of races for each driver and GROUP BY ""driver.Driver_ID"" to group the results by each driver.",0.0
1271,Count the number of pilots who have planes in Chicago.,NON-NESTED,pilot_1,"[PilotSkills.pilot_name,Hangar.location,PilotSkills.plane_name = Hangar.plane_name,Chicago]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(DISTINCT PilotSkills.pilot_name) FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE Hangar.location = 'Chicago';,SELECT 	count(DISTINCT T1.pilot_name) FROM pilotskills AS T1 JOIN hangar AS T2 ON T1.plane_name  =  T2.plane_name WHERE T2.location  =  'Chicago',"1. Sequential Structure: Start with the SELECT clause to count the number of distinct pilots (""PilotSkills.pilot_name"") who have planes in Chicago. 2. Condition Structure: Use a WHERE clause to filter for records where ""Hangar.location"" is Chicago. 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the relationship ""PilotSkills.plane_name = Hangar.plane_name"" to associate pilots with their planes and their locations. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique pilots who meet the condition.",1.0
1272,Return the maximum and minimum age across drivers.,EASY,car_road_race,[driver.Age],"Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT MAX(driver.Age) AS max_age, MIN(driver.Age) AS min_age FROM driver;","SELECT max(Age) ,  min(Age) FROM driver","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum ages. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum age across all drivers. 3. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table. 4. Condition Structure: No specific filtering condition is needed as we are calculating the aggregate values for all drivers.",1.0
1273,Find the max age for each group of pilots with the same name.,EASY,pilot_1,"[PilotSkills.pilot_name,PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.pilot_name, MAX(PilotSkills.age) AS max_age FROM PilotSkills GROUP BY PilotSkills.pilot_name;","SELECT max(age) ,  pilot_name FROM pilotskills GROUP BY pilot_name","1. Sequential Structure: Begin with the SELECT clause to specify the pilot name and the maximum age for each group of pilots with the same name. 2. Aggregation Structure: Use the MAX function to calculate the maximum age for each group of pilots. 3. Grouping Structure: Use GROUP BY on ""PilotSkills.pilot_name"" to group pilots by their names. 4. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table.",1.0
1274,"Find the name of the oldest pilot for each type of plane, and order the results by plane name.",NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.plane_name, PilotSkills.age, Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT plane_name, pilot_name, MAX(age) AS oldest_age FROM PilotSkills GROUP BY plane_name ORDER BY plane_name;","SELECT pilot_name ,  plane_name ,  max(age) FROM pilotskills GROUP BY plane_name ORDER BY plane_name","1. Sequential Structure: Start with the SELECT clause to retrieve the pilot name, plane name, and age. Use the FROM clause to specify the PilotSkills table. Use GROUP BY to group records by plane name to find the oldest pilot for each type of plane. Use ORDER BY to sort the results by plane name. 2. Condition Structure: Use the HAVING clause to filter for the oldest pilot for each plane type by using the MAX function on the age column. 3. Join Structure: No JOIN is required as all necessary data is available in the PilotSkills table. 4. Aggregation Structure: Use the MAX function to determine the oldest pilot for each plane type.",1.0
1275,What mediums were used for the painting with id 80 ?,EASY,art_1,"[Paintings.medium, Paintings.paintingID, 80]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.medium FROM Paintings WHERE Paintings.paintingID = 80;,select medium from paintings where paintingid  =  80,"1. Sequential Structure: Start with the SELECT clause to specify the medium used for the painting. 2. Condition Structure: Use a WHERE clause to filter for the painting with the ID of 80. 3. Join Structure: No JOIN is required since all necessary information is in the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific information about a single painting.",1.0
1276,What is the id of every painting created before the oldest painting in gallery 240?,NESTED,art_1,"[Paintings.paintingID, Paintings.year, Paintings.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT paintingID FROM Paintings WHERE year < (SELECT MIN(year) FROM Paintings WHERE location = 240);,SELECT paintingID FROM paintings WHERE YEAR  <   (SELECT min(YEAR) FROM paintings WHERE LOCATION  =  'Gallery 240'),"1. Sequential Structure: Start with the SELECT clause to retrieve the painting IDs. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter for paintings created before the year of the oldest painting in gallery 240. 2. Condition Structure: Use the WHERE clause with a subquery to find the year of the oldest painting in gallery 240. The subquery calculates the minimum year for paintings in gallery 240, and the main query filters for paintings created before this year. 3. Join Structure: Not required, as all data is in the Paintings table. 4. Aggregation Structure: Use the MIN function in a subquery to find the oldest painting year in gallery 240.",0.0
1277,What are the average height of paintings for different medium types?,EASY,art_1,"[Paintings.height_mm, Paintings.medium]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.medium, AVG(Paintings.height_mm) AS avg_height FROM Paintings GROUP BY Paintings.medium;","SELECT avg(height_mm) ,  medium FROM paintings GROUP BY medium","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the medium type and the average height of paintings. 2. Aggregation Structure: Use the AVG function to calculate the average height of paintings for each medium type. 3. Grouping Structure: Use GROUP BY on ""Paintings.medium"" to calculate the average height for each medium type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table.",1.0
1278,Find the name and nationality of the people who did not participate in any ACL conference.,NESTED,conference,"[staff.name, staff.Nationality, conference.Conference_Name, conference_participation.Conference_ID = conference.Conference_ID, conference_participation.staff_ID = staff.staff_ID, ACL]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT staff.name, staff.Nationality FROM staff WHERE staff.staff_ID NOT IN ( SELECT conference_participation.staff_ID FROM conference_participation JOIN conference ON conference_participation.Conference_ID = conference.Conference_ID WHERE conference.Conference_Name = 'ACL' );","SELECT name ,  nationality FROM staff WHERE staff_id NOT IN (SELECT T2.staff_id FROM Conference AS T1 JOIN Conference_participation AS T2 ON T1.conference_id  =  T2.conference_id WHERE T1.Conference_Name  =  ""ACL"")","1. Sequential Structure: Start with the SELECT clause to retrieve the name and nationality of staff members. Use the FROM clause to specify the staff table. Apply a WHERE clause to filter for staff members who did not participate in any ACL conference. 2. Condition Structure: Use the WHERE clause with a subquery to exclude staff members whose staff_ID appears in the conference_participation table for conferences with the name 'ACL'. 3. Join Structure: Use the conference and conference_participation tables to identify staff members who participated in ACL conferences. The conference_participation table links staff_ID with Conference_ID, and the conference table provides the conference name. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1279,How many planes are owned by the pilot whose name is Smith?,EASY,pilot_1,"[PilotSkills.pilot_name, PilotSkills.plane_name, PilotSkills.pilot_name = 'Smith']","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(PilotSkills.plane_name) FROM PilotSkills WHERE PilotSkills.pilot_name = 'Smith';,SELECT count(plane_name) FROM pilotskills WHERE pilot_name  =  'Smith',"1. Sequential Structure: Start with the SELECT clause to count the number of planes owned by the pilot named 'Smith'. 2. Condition Structure: Use a WHERE clause to filter for the pilot whose name is 'Smith'. 3. Join Structure: No JOIN is required since all necessary information is in the ""PilotSkills"" table. 4. Aggregation Structure: Use COUNT to calculate the number of planes associated with the pilot named 'Smith'.",1.0
1280,Count the number of different plane names across all pilots.,EASY,pilot_1,[PilotSkills.plane_name],"Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(DISTINCT PilotSkills.plane_name) AS unique_plane_count FROM PilotSkills;,SELECT count(DISTINCT plane_name) FROM pilotskills,"1. Sequential Structure: Begin with the SELECT clause to count the distinct plane names across all pilots. 2. Condition Structure: No specific filtering condition is required as we are counting all distinct plane names. 3. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the number of unique plane names.",1.0
1281,What are the names and ages of pilots who have planes located in Austin?,NON-NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name, Hangar.plane_name, Hangar.location, PilotSkills.plane_name = Hangar.plane_name, Austin]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.pilot_name, PilotSkills.age FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE Hangar.location = 'Austin';","SELECT T1.pilot_name ,  T1.age FROM pilotskills AS T1 JOIN hangar AS T2 ON T1.plane_name  =  T2.plane_name WHERE T2.location  =  ""Austin""","1. Sequential Structure: Start with the SELECT clause to retrieve ""PilotSkills.pilot_name"" and ""PilotSkills.age."" 2. Condition Structure: Use a WHERE clause to filter for records where ""Hangar.location"" is ""Austin."" 3. Join Structure: Use an INNER JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the shared key ""plane_name"" to associate pilots with the locations of their planes. 4. Aggregation Structure: No aggregation is needed as the query only requires individual pilot details.",1.0
1282,What are the names of oldest pilots for each type of plane?,NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.plane_name, PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT pilot_name, plane_name FROM PilotSkills WHERE age IN ( SELECT MAX(age) FROM PilotSkills GROUP BY plane_name );","SELECT pilot_name ,  plane_name ,  max(age) FROM pilotskills GROUP BY plane_name","1. Sequential Structure: Start with the SELECT clause to retrieve the pilot name and plane type (plane_name). Use the FROM clause to specify the PilotSkills table. Apply a GROUP BY clause to group records by plane type, as we want the oldest pilot for each type of plane. Use the MAX function to find the maximum age for each plane type. 2. Condition Structure: Use the HAVING clause to filter for the oldest pilot for each plane type by matching the maximum age within each group. 3. Join Structure: Not required, as all data is available within the PilotSkills table. 4. Aggregation Structure: Use the MAX function to determine the maximum age for each plane type and retrieve the corresponding pilot name.",0.0
1283,What is the birth year of the artist who created a painting in 1884 that is on canvas?,NON-NESTED,art_1,"[Artists.birthYear,Paintings.year,Paintings.medium,Paintings.painterID = Artists.artistID,1884,canvas]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Artists.birthYear FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID WHERE Paintings.year = 1884 AND Paintings.medium = 'canvas';,"SELECT T1.birthYear FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T2.year  =  1884 AND mediumOn  =  ""canvas""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Artists.birthYear"" of the artist. 2. Condition Structure: Use a WHERE clause to filter for paintings created in the year 1884 and with the medium ""canvas."" 3. Join Structure: Use a JOIN between the ""Paintings"" and ""Artists"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to link each painting with its respective artist. 4. Aggregation Structure: No aggregation is needed as we are retrieving a specific attribute of the artist.",0.0
1284,What are the location and medium type of paintings that are created by the artist whose first name is Pablo?,NON-NESTED,art_1,"[Paintings.location, Paintings.medium, Artists.fname, Paintings.painterID = Artists.artistID, Pablo]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.location, Paintings.medium FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID WHERE Artists.fname = 'Pablo';","SELECT T2.location ,   T2.medium FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T1.fname  =  ""Pablo""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paintings.location"" and ""Paintings.medium"" fields. 2. Condition Structure: Use a WHERE clause to filter for the artist whose first name is ""Pablo."" This requires filtering on the ""Artists.fname"" field. 3. Join Structure: Use a JOIN between the ""Paintings"" and ""Artists"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to link paintings with their respective artists. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without any summarization.",1.0
1285,What is the name of the oldest painting and where is it located?,EASY,art_1,"[Paintings.title, Paintings.year, Paintings.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.title, Paintings.location FROM Paintings ORDER BY Paintings.year ASC LIMIT 1;","SELECT title ,  LOCATION ,  YEAR FROM paintings ORDER BY YEAR LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paintings.title"" and ""Paintings.location"" of the oldest painting. 2. Condition Structure: No specific filtering condition is required, as we are looking for the painting with the earliest year. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""Paintings"" table. 4. Aggregation Structure: Use ORDER BY on ""Paintings.year"" in ascending order to find the oldest painting. Apply LIMIT 1 to select only the oldest painting.",0.0
1286,What is the average age of pilots for different types of planes?,EASY,pilot_1,"[PilotSkills.age, PilotSkills.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.plane_name, AVG(PilotSkills.age) AS avg_age FROM PilotSkills GROUP BY PilotSkills.plane_name;","SELECT avg(age) ,  plane_name FROM pilotskills GROUP BY plane_name","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the plane type (plane_name) and the average age of pilots. 2. Aggregation Structure: Use the AVG function to calculate the average age of pilots for each type of plane. 3. Grouping Structure: Use GROUP BY on ""PilotSkills.plane_name"" to calculate the average age for each plane type. 4. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table.",1.0
1287,Find the name and location of the universities that did not have any staff participated in any conference in 2004.,NESTED,conference,"[institution.Institution_Name, institution.Location, staff.Institution_ID = institution.Institution_ID, conference_participation.staff_ID = staff.staff_ID, conference_participation.Conference_ID = conference.Conference_ID, conference.Year, 2004]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT institution.Institution_Name, institution.Location FROM institution WHERE institution.Institution_ID NOT IN ( SELECT staff.Institution_ID FROM staff JOIN conference_participation ON staff.staff_ID = conference_participation.staff_ID JOIN conference ON conference_participation.Conference_ID = conference.Conference_ID WHERE conference.Year = 2004 );","SELECT T1.Institution_Name ,  T1.location FROM institution AS T1 JOIN staff AS T2 ON T1.institution_id  =  T2.institution_id WHERE T2.staff_id NOT IN (SELECT T4.staff_id FROM Conference AS T3 JOIN Conference_participation AS T4 ON T3.conference_id  =  T4.conference_id WHERE T3.year  =  2004)","1. Sequential Structure: Start with the SELECT clause to retrieve the name and location of universities. Use the FROM clause to specify the institution table. Apply a WHERE clause to filter universities that did not have any staff participate in any conference in 2004. 2. Condition Structure: Use the WHERE clause with a subquery to exclude universities whose staff participated in conferences in 2004. The subquery identifies staff IDs linked to conferences in 2004, and the main query ensures that the institution IDs of these staff members are not included. 3. Join Structure: Use JOINs to connect the institution table with the staff table and the conference_participation table, and further link it to the conference table to filter by year. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1288,What are the names of planes that the pilot Jones who is 32 has?,NON-NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT Hangar.plane_name FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE PilotSkills.pilot_name = 'Jones' AND PilotSkills.age = 32;,SELECT plane_name FROM pilotskills WHERE pilot_name  =  'Jones'  AND age  =  32,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""plane_name"" of the planes associated with the pilot named ""Jones"" who is 32 years old. 2. Condition Structure: Use a WHERE clause to filter for the pilot with the name ""Jones"" and age 32. 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the shared ""plane_name"" field to link the planes with the pilot's skills. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific plane names.",1.0
1289,How many pilots who are older than 40?,EASY,pilot_1,"[PilotSkills.pilot_name,PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(*) FROM PilotSkills WHERE PilotSkills.age > 40;,SELECT count(*) FROM pilotskills WHERE age  >  40,"1. Sequential Structure: Start with the SELECT clause to count the number of pilots. 2. Condition Structure: Use a WHERE clause to filter pilots who are older than 40 by checking the ""PilotSkills.age"" field. 3. Join Structure: No JOIN is required since all necessary information is in the ""PilotSkills"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of pilots meeting the age condition.",1.0
1290,What are the first and last names of artists who have painted using both oil and lithographic mediums?,NESTED,art_1,"[Artists.lname, Artists.fname, Paintings.medium, Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT DISTINCT Artists.fname, Artists.lname FROM Artists JOIN Paintings ON Paintings.painterID = Artists.artistID WHERE Artists.artistID IN ( SELECT painterID FROM Paintings WHERE medium = 'oil' ) AND Artists.artistID IN ( SELECT painterID FROM Paintings WHERE medium = 'lithographic' );","SELECT T1.lname ,  T1.fname FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T2.medium  =  ""oil"" INTERSECT SELECT T3.lname ,  T3.fname FROM artists AS T3 JOIN paintings AS T4 ON T3.artistID  =  T4.painterID WHERE T4.medium  =  ""lithograph""","1. Sequential Structure: Start with the SELECT clause to retrieve the first and last names of artists. Use the FROM clause to specify the Artists table and JOIN it with the Paintings table to connect artists with their paintings. Apply a WHERE clause to filter for artists who have used both ""oil"" and ""lithographic"" mediums. 2. Condition Structure: Use the WHERE clause with a subquery to identify artists who have painted using both mediums. The subquery checks for the existence of both ""oil"" and ""lithographic"" mediums for the same artist. 3. Join Structure: Use an INNER JOIN between the Artists and Paintings tables based on the relationship between painterID and artistID to link artists with their paintings. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1291,"What are the names of pilots, ordered by age descending?",EASY,pilot_1,"[PilotSkills.pilot_name,PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.pilot_name, PilotSkills.age FROM PilotSkills ORDER BY PilotSkills.age DESC;",SELECT pilot_name FROM pilotskills ORDER BY age DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the pilot's name and age. 2. Condition Structure: No specific filtering condition is required as we want all pilots. 3. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data. 5. Ordering Structure: Use ORDER BY in descending order on the ""PilotSkills.age"" field to sort the pilots by age.",1.0
1292,Count the number of races.,EASY,car_road_race,[race.Race_Name],"Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT COUNT(race.Race_Name) AS race_count FROM race;,SELECT count(*) FROM race,"1. Sequential Structure: Begin with the SELECT clause to count the number of races. 2. Aggregation Structure: Use the COUNT function to calculate the total number of races. 3. Condition Structure: No specific filtering condition is required as we want to count all races. 4. Join Structure: No JOIN is necessary since all required data is within the ""race"" table.",1.0
1293,Find the names and populations of the districts whose area is greater than the average area.,NESTED,district_spokesman,"[district.Name, district.Population, district.Area_km]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
","SELECT Name, Population FROM district WHERE Area_km > (SELECT AVG(Area_km) FROM district);","SELECT name ,  population FROM district WHERE area_km  >  (SELECT avg(area_km) FROM district)","1. Sequential Structure: Start with the SELECT clause to retrieve the names and populations of districts. Use the FROM clause to specify the district table. Apply a WHERE clause to filter districts whose area is greater than the average area. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average area of all districts and filter districts whose area is greater than this value. 3. Join Structure: Not required, as all data is available within the district table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average area, which is then used in the filtering condition.",1.0
1294,Find all locations of planes sorted by the plane name.,EASY,pilot_1,"[Hangar.location, Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT Hangar.location, Hangar.plane_name FROM Hangar ORDER BY Hangar.plane_name;",SELECT LOCATION FROM hangar ORDER BY plane_name,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""Hangar.location"" and ""Hangar.plane_name"". 2. Condition Structure: No specific filtering condition is required as the query asks for all locations of planes. 3. Join Structure: No JOIN is required since all necessary data is within the ""Hangar"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""Hangar.plane_name"" to sort the results by the plane name.",1.0
1295,What is the name of every distinct painting in alphabetical order?,EASY,art_1,[Paintings.title],"Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT Paintings.title FROM Paintings ORDER BY Paintings.title ASC;,SELECT DISTINCT title FROM paintings ORDER BY title,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the title of the paintings. 2. Condition Structure: No specific filtering condition is required as we want all distinct painting titles. 3. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique painting titles are retrieved. 5. Ordering Structure: Use ORDER BY in ascending order to sort the painting titles alphabetically.",1.0
1296,Find pilots who own planes Piper Cub and B-52 Bomber.,NESTED,pilot_1,"[PilotSkills.pilot_name,PilotSkills.plane_name,Hangar.plane_name = PilotSkills.plane_name,PilotSkills.plane_name,Piper Cub,B-52 Bomber]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT pilot_name FROM PilotSkills WHERE plane_name IN ('Piper Cub', 'B-52 Bomber') GROUP BY pilot_name HAVING COUNT(DISTINCT plane_name) = 2;",SELECT pilot_name FROM pilotskills WHERE plane_name  =  'Piper Cub' INTERSECT SELECT pilot_name FROM pilotskills WHERE plane_name  =  'B-52 Bomber',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of pilots. Use the FROM clause to specify the PilotSkills table. Apply a WHERE clause to filter for pilots who own both planes, ""Piper Cub"" and ""B-52 Bomber"". 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the pilot's name appears for both ""Piper Cub"" and ""B-52 Bomber"" in the PilotSkills table. 3. Join Structure: Not required, as all necessary data is available in the PilotSkills table. 4. Aggregation Structure: Use a GROUP BY clause to group by pilot_name and a HAVING clause to ensure that the count of distinct planes owned by the pilot matches the two specified planes.",1.0
1297,How many races are there?,EASY,car_road_race,[race.Race_Name],"Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT COUNT(race.Race_Name) AS total_races FROM race;,SELECT count(*) FROM race,"1. Sequential Structure: Start with the SELECT clause to count the number of races. 2. Aggregation Structure: Use the COUNT function to calculate the total number of races. 3. Join Structure: No JOIN is required since all necessary data is within the ""race"" table. 4. Condition Structure: No specific filtering condition is needed as we want the total count of all races.",1.0
1298,"What are the names and ages of pilots who own plane Piper Cub and are older than 35, or have F-14 Fighter and are younger than 30?",NON-NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name, Hangar.plane_name, Piper Cub, F-14 Fighter, 35, 30, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.pilot_name, PilotSkills.age FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE (PilotSkills.plane_name = 'Piper Cub' AND PilotSkills.age > 35) OR (PilotSkills.plane_name = 'F-14 Fighter' AND PilotSkills.age < 30);","SELECT pilot_name ,  age FROM pilotskills WHERE plane_name  =  'Piper Cub' AND age  >  35 UNION SELECT pilot_name ,  age FROM pilotskills WHERE plane_name  =  'F-14 Fighter' AND age  <  30","1. Sequential Structure: Start with the SELECT clause to retrieve the ""PilotSkills.pilot_name"" and ""PilotSkills.age."" 2. Condition Structure: Use a WHERE clause to filter pilots based on the conditions: (a) they own a ""Piper Cub"" and are older than 35, or (b) they own an ""F-14 Fighter"" and are younger than 30. 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the shared key ""plane_name"" to associate pilots with the planes they own. 4. Aggregation Structure: No aggregation is needed as the query focuses on filtering and retrieving specific pilot details.",1.0
1299,Return the winning drivers of races who did not have the pole position of Junior Strous.,NESTED,car_road_race,"[race.Winning_driver, race.Pole_Position, driver.Driver_Name, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Driver_Name FROM race JOIN driver ON race.Winning_driver = driver.Driver_ID WHERE race.Pole_Position != (SELECT driver.Driver_ID FROM driver WHERE driver.Driver_Name = 'Junior Strous');,SELECT Winning_driver FROM race WHERE Pole_Position != 'Junior Strous',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of winning drivers. Use the FROM clause to specify the race and driver tables. Apply a WHERE clause to filter for races where the winning driver did not have the pole position of Junior Strous. 2. Condition Structure: Use the WHERE clause to exclude races where the pole position driver is Junior Strous. This can be achieved by identifying the Driver_ID of Junior Strous and ensuring it does not match the Pole_Position field in the race table. 3. Join Structure: Use an INNER JOIN between the race and driver tables based on Driver_ID to connect race details with driver names. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1300,What are the names of the conferences that have the top 2 most people attending?,NESTED,conference,"[conference.Conference_Name,conference.Conference_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT conference.Conference_Name FROM conference JOIN conference_participation ON conference.Conference_ID = conference_participation.Conference_ID GROUP BY conference.Conference_ID, conference.Conference_Name ORDER BY COUNT(conference_participation.staff_ID) DESC LIMIT 2;",SELECT T1.conference_name FROM Conference AS T1 JOIN Conference_participation AS T2 ON T1.conference_id  =  T2.conference_id GROUP BY T2.conference_id ORDER BY count(*) DESC LIMIT 2,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the conferences. Use the FROM clause to specify the conference table and JOIN it with the conference_participation table to link conferences with their participation data. Use GROUP BY to group records by conference ID and name, and apply ORDER BY to sort the conferences by the number of participants in descending order. Use LIMIT to restrict the result to the top 2 conferences. 2. Condition Structure: No specific filtering condition is required, as we are interested in all conferences but only need the top 2 based on attendance. 3. Join Structure: Use an INNER JOIN between the conference and conference_participation tables based on the Conference_ID to connect conference details with participation data. 4. Aggregation Structure: Use COUNT to calculate the number of participants for each conference and sort them in descending order to identify the top 2.",1.0
1301,Find all information of on pilots whose age is less than 30.,EASY,pilot_1,"[PilotSkills.pilot_name,PilotSkills.plane_name,PilotSkills.age,30]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT * FROM PilotSkills WHERE PilotSkills.age < 30;,SELECT * FROM PilotSkills WHERE age  <  30,"1. Sequential Structure: Start with the SELECT clause to retrieve all fields from the ""PilotSkills"" table, as the question asks for all information about pilots. 2. Condition Structure: Use a WHERE clause to filter pilots whose age is less than 30. 3. Join Structure: No JOIN is required since all necessary information is in the ""PilotSkills"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving all information for pilots meeting the specified condition.",1.0
1302,What is the height and id of the tallest painting created before 1900?,EASY,art_1,"[Paintings.height_mm, Paintings.paintingID, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.height_mm, Paintings.paintingID FROM Paintings WHERE Paintings.year < 1900 ORDER BY Paintings.height_mm DESC LIMIT 1;","SELECT max(height_mm) ,  paintingID FROM paintings WHERE YEAR  <  1900","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the height and ID of the painting. 2. Condition Structure: Use a WHERE clause to filter for paintings created before the year 1900. 3. Aggregation Structure: Use ORDER BY in descending order on the height to rank the paintings by their height. 4. Limiting Structure: Use LIMIT 1 to retrieve only the tallest painting that meets the condition. 5. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table.",1.0
1303,Return the name of the oldest pilot.,EASY,pilot_1,"[PilotSkills.pilot_name,PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT PilotSkills.pilot_name FROM PilotSkills ORDER BY PilotSkills.age DESC LIMIT 1;,SELECT pilot_name FROM PilotSkills ORDER BY age DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""PilotSkills.pilot_name"" of the oldest pilot. 2. Condition Structure: No specific filtering condition is needed since we are looking for the pilot with the maximum age. 3. Join Structure: No JOIN is required as all necessary information is in the ""PilotSkills"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""PilotSkills.age"" to rank pilots by age and apply LIMIT 1 to select the oldest pilot.",1.0
1304,"What are the locations of the different planes, ordered by plane name?",NON-NESTED,pilot_1,"[Hangar.location, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT Hangar.plane_name, Hangar.location FROM Hangar ORDER BY Hangar.plane_name ASC;",SELECT LOCATION FROM hangar ORDER BY plane_name,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Hangar.location"" and ""Hangar.plane_name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: No JOIN is required since the necessary information is available in the ""Hangar"" table. 4. Aggregation Structure: No aggregation is needed, but apply ORDER BY to list the results in alphabetical order by ""Hangar.plane_name.""",1.0
1305,Show the institution name and the number of staff for each institution founded after 1800.,NON-NESTED,conference,"[institution.Institution_Name, institution.Founded, staff.Institution_ID = institution.Institution_ID, staff.staff_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
","SELECT institution.Institution_Name, COUNT(staff.staff_ID) AS Number_of_Staff FROM institution JOIN staff ON institution.Institution_ID = staff.Institution_ID WHERE institution.Founded > 1800 GROUP BY institution.Institution_Name;","SELECT T1.institution_name ,  count(*) FROM institution AS T1 JOIN staff AS T2 ON T1.institution_id  =  T2.institution_id WHERE T1.founded  >  1800 GROUP BY T2.institution_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""institution.Institution_Name"" and the count of ""staff.staff_ID"" for each institution. Use COUNT to calculate the number of staff members. 2. Condition Structure: Use a WHERE clause to filter institutions founded after 1800 by checking the ""institution.Founded"" field. 3. Join Structure: Use a JOIN between the ""institution"" and ""staff"" tables based on ""institution.Institution_ID"" and ""staff.Institution_ID"" to associate staff members with their respective institutions. 4. Aggregation Structure: Use COUNT to count the number of staff members for each institution and GROUP BY ""institution.Institution_Name"" to group the results by institution.",1.0
1306,Find the name of spokesmen who do not speak for any district.,NESTED,district_spokesman,"[spokesman.Name, spokesman.Spokesman_ID, spokesman.Spokesman_ID = spokesman_district.Spokesman_ID]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
",SELECT Name FROM spokesman WHERE Spokesman_ID NOT IN (SELECT Spokesman_ID FROM spokesman_district);,SELECT name FROM spokesman WHERE Spokesman_ID NOT IN (SELECT Spokesman_ID FROM spokesman_district),"1. Sequential Structure: Begin with the SELECT clause to retrieve the names of spokesmen. Use the FROM clause to specify the spokesman table. Apply a WHERE clause to filter spokesmen who do not speak for any district by ensuring their Spokesman_ID is not present in the spokesman_district table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude spokesmen whose Spokesman_ID appears in the spokesman_district table, meaning they speak for at least one district. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Spokesman_ID entries in the spokesman_district table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1307,How wide were the paintings by the artist who was born prior to 1850?,NON-NESTED,art_1,"[Paintings.width_mm, Paintings.painterID = Artists.artistID, Artists.birthYear, Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.width_mm FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID WHERE Artists.birthYear < 1850;,SELECT T2.width_mm FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T1.birthYear  <  1850,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paintings.width_mm"" field, as the question asks for the width of the paintings. 2. Condition Structure: Use a WHERE clause to filter for artists who were born prior to 1850. This condition will be applied to the ""Artists.birthYear"" field. 3. Join Structure: Use a JOIN between the ""Paintings"" and ""Artists"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to link each painting with its respective artist. 4. Aggregation Structure: No aggregation is needed, as the question does not require any summarization or grouping of data.",1.0
1308,Count the number of B-52 Bombers owned by pilots under 35.,NON-NESTED,pilot_1,"[PilotSkills.plane_name, PilotSkills.age, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(*) FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE PilotSkills.age < 35 AND PilotSkills.plane_name = 'B-52 Bombers';,SELECT count(*) FROM pilotskills WHERE age  <  35 AND plane_name  =  'B-52 Bomber',"1. Sequential Structure: Start with the SELECT clause to count the number of ""B-52 Bombers"" owned by pilots. Use COUNT to aggregate the results. 2. Condition Structure: Use a WHERE clause to filter for pilots under the age of 35 and for the specific plane name ""B-52 Bombers."" 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the shared key ""plane_name"" to link pilots with the planes they own. 4. Aggregation Structure: Use COUNT to count the number of ""B-52 Bombers"" owned by pilots under 35.",0.0
1309,Return the name of the youngest pilot to fly Piper Cub.,NON-NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name, PilotSkills.plane_name = Hangar.plane_name, Hangar.plane_name, Piper Cub]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT PilotSkills.pilot_name FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE Hangar.plane_name = 'Piper Cub' ORDER BY PilotSkills.age ASC LIMIT 1;,SELECT pilot_name FROM pilotskills WHERE plane_name  =  'Piper Cub' ORDER BY age LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""PilotSkills.pilot_name"" of the youngest pilot. Use the MIN function on ""PilotSkills.age"" to find the youngest age. 2. Condition Structure: Use a WHERE clause to filter for pilots who have flown the ""Piper Cub."" This requires matching the ""PilotSkills.plane_name"" with ""Hangar.plane_name"" and ensuring the plane name is ""Piper Cub."" 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the shared ""plane_name"" field to link pilots with the planes they have flown. 4. Aggregation Structure: Use MIN to find the youngest age, and then filter the pilot corresponding to that age.",1.0
1310,Find the first and last name of artists who have painting but no sculpture work.,NESTED,art_1,"[Artists.lname, Artists.fname, Paintings.painterID = Artists.artistID, Sculptures.sculptorID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.fname, Artists.lname FROM Artists WHERE Artists.artistID IN (SELECT painterID FROM Paintings) AND Artists.artistID NOT IN (SELECT sculptorID FROM Sculptures);","SELECT T1.lname ,  T1.fname FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID EXCEPT SELECT T3.lname ,  T3.fname FROM artists AS T3 JOIN sculptures AS T4 ON T3.artistID  =  T4.sculptorID","1. Sequential Structure: Start with the SELECT clause to retrieve the first and last names of artists. Use the FROM clause to specify the Artists table. Apply a WHERE clause to filter artists who have painting work but no sculpture work. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the artist has entries in the Paintings table (indicating they have painting work) and does not have entries in the Sculptures table (indicating they have no sculpture work). 3. Join Structure: Not required, as the filtering is based on subqueries that check the presence or absence of artist IDs in the Paintings and Sculptures tables. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1311,What is the first name and age of the artist who lived the longest?,NESTED,art_1,"[Artists.fname, Artists.birthYear, Artists.deathYear]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT fname, (deathYear - birthYear) AS age FROM Artists ORDER BY age DESC LIMIT 1;","SELECT fname  ,  deathYear - birthYear FROM artists ORDER BY deathYear - birthYear DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the first name and age of the artist. Use the FROM clause to specify the Artists table. Calculate the age of each artist as the difference between deathYear and birthYear. Use the ORDER BY clause to sort the artists by age in descending order and LIMIT 1 to get the artist who lived the longest. 2. Condition Structure: No specific filtering condition is required, as we are calculating the age for all artists and selecting the one with the maximum age. 3. Join Structure: Not required, as all data is available within the Artists table. 4. Aggregation Structure: Use a calculated field (deathYear - birthYear) to determine the age of each artist and sort by this value to find the maximum.",1.0
1312,What are the names of pilots who own both Piper Cub and the B-52 Bomber?,NESTED,pilot_1,"[PilotSkills.pilot_name,PilotSkills.plane_name,Hangar.plane_name,PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT pilot_name FROM PilotSkills WHERE plane_name = 'Piper Cub' AND pilot_name IN ( SELECT pilot_name FROM PilotSkills WHERE plane_name = 'B-52 Bomber' );,SELECT pilot_name FROM pilotskills WHERE plane_name  =  'Piper Cub' INTERSECT SELECT pilot_name FROM pilotskills WHERE plane_name  =  'B-52 Bomber',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of pilots. Use the FROM clause to specify the PilotSkills table, as it contains the pilot_name and plane_name. Apply a WHERE clause to filter pilots who own both ""Piper Cub"" and ""B-52 Bomber"". 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the pilot_name appears for both ""Piper Cub"" and ""B-52 Bomber"" in the PilotSkills table. 3. Join Structure: Not required, as all necessary data is available in the PilotSkills table. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1313,Give the names of all oil paintings created after 1910.,NON-NESTED,art_1,"[Paintings.title,Paintings.medium,Paintings.year,Paintings.painterID = Artists.artistID,Artists.lname,Artists.fname]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.title FROM Paintings WHERE Paintings.medium = 'oil' AND Paintings.year > 1910;,"SELECT title FROM paintings WHERE YEAR  >  1910 AND medium  =  ""oil""","1. Sequential Structure: Start with the SELECT clause to retrieve the names of oil paintings. Since the names of paintings are stored in ""Paintings.title,"" this field will be selected. 2. Condition Structure: Use a WHERE clause to filter for paintings where the ""Paintings.medium"" is 'oil' and the ""Paintings.year"" is greater than 1910. 3. Join Structure: No JOIN is required as the question only asks for the names of paintings, and all relevant information is in the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed since the query is retrieving individual records without summarization.",1.0
1314,How many paintings did the artist with the longest life make ?,NESTED,art_1,"[Artists.artistID, Artists.birthYear, Artists.deathYear, Paintings.painterID, Paintings.paintingID, Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT COUNT(Paintings.paintingID) AS painting_count FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID WHERE Artists.artistID = ( SELECT artistID FROM Artists WHERE (deathYear - birthYear) = ( SELECT MAX(deathYear - birthYear) FROM Artists ) );,select count(*) from artists as t1 join paintings as t2 on t1.artistid  =  t2.painterid group by t2.painterid order by t1.deathyear - t1.birthyear desc limit 1,1. Sequential Structure: Start with the SELECT clause to count the number of paintings made by the artist. Use the FROM clause to specify the Paintings table and JOIN it with the Artists table to link paintings to their respective artists. Apply a WHERE clause to filter for the artist with the longest life span. 2. Condition Structure: Use the WHERE clause to identify the artist with the longest life span by calculating the difference between deathYear and birthYear. Use a subquery to find the artistID of the artist with the maximum life span. 3. Join Structure: Use an INNER JOIN between the Paintings and Artists tables based on the relationship between painterID and artistID to connect paintings with their respective artists. 4. Aggregation Structure: Use COUNT to count the number of paintings made by the artist with the longest life span.,1.0
1315,"Find the number of spokesmen for each district, and the show district names as well.",NON-NESTED,district_spokesman,"[district.Name, spokesman_district.District_ID, spokesman_district.Spokesman_ID, spokesman_district.District_ID = district.District_ID]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
","SELECT district.Name, COUNT(spokesman_district.Spokesman_ID) AS NumberOfSpokesmen FROM district JOIN spokesman_district ON spokesman_district.District_ID = district.District_ID GROUP BY district.Name;","SELECT t1.name ,  count(*) FROM district AS t1 JOIN spokesman_district AS t2 ON t1.District_ID  =  t2.District_ID GROUP BY t2.District_ID","1. Sequential Structure: Start with the SELECT clause to retrieve the district name and the count of spokesmen for each district. Use ""district.Name"" and COUNT on ""spokesman_district.Spokesman_ID."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""district"" table with the ""spokesman_district"" table based on the relationship ""spokesman_district.District_ID = district.District_ID."" 4. Aggregation Structure: Use COUNT to count the number of spokesmen for each district and GROUP BY ""district.Name"" to group the results by district.",1.0
1316,Find the id of the oldest painting.,EASY,art_1,"[Paintings.paintingID, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.paintingID FROM Paintings ORDER BY Paintings.year ASC LIMIT 1;,SELECT paintingID FROM paintings ORDER BY YEAR LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the painting ID. 2. Condition Structure: No specific filtering condition is required, as we are looking for the oldest painting. 3. Aggregation Structure: Use ORDER BY on the ""Paintings.year"" in ascending order to find the oldest painting. Apply LIMIT 1 to retrieve only the ID of the oldest painting. 4. Join Structure: No JOIN is required since all necessary data is within the ""Paintings"" table.",1.0
1317,"What is the full name of the artist with a sculpture whose title includes the word ""female""?",NON-NESTED,art_1,"[Sculptures.title, Sculptures.sculptorID, Artists.artistID = Sculptures.sculptorID, Artists.lname, Artists.fname]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.fname, Artists.lname FROM Sculptures JOIN Artists ON Artists.artistID = Sculptures.sculptorID WHERE Sculptures.title LIKE '%female%';","SELECT T1.lname ,  T1.fname FROM artists AS T1 JOIN sculptures AS T2 ON T1.artistID  =  T2.sculptorID WHERE T2.title LIKE ""%female%""","1. Sequential Structure: Start with the SELECT clause to retrieve the full name of the artist, which includes ""Artists.fname"" and ""Artists.lname."" 2. Condition Structure: Use a WHERE clause to filter for sculptures whose title includes the word ""female."" This can be achieved using the LIKE operator with a wildcard. 3. Join Structure: Use a JOIN between the ""Sculptures"" and ""Artists"" tables based on the relationship ""Artists.artistID = Sculptures.sculptorID"" to link each sculpture with its sculptor. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific information about the artist.",1.0
1318,How many pilots whose planes are in Chicago?,NON-NESTED,pilot_1,"[PilotSkills.pilot_name,Hangar.location,PilotSkills.plane_name = Hangar.plane_name,Chicago]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(PilotSkills.pilot_name) FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE Hangar.location = 'Chicago';,SELECT 	count(DISTINCT T1.pilot_name) FROM pilotskills AS T1 JOIN hangar AS T2 ON T1.plane_name  =  T2.plane_name WHERE T2.location  =  'Chicago',"1. Sequential Structure: Start with the SELECT clause to count the number of pilots whose planes are in Chicago. Use COUNT on ""PilotSkills.pilot_name"" to get the total number of such pilots. 2. Condition Structure: Use a WHERE clause to filter for records where the ""Hangar.location"" is Chicago. 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the relationship ""PilotSkills.plane_name = Hangar.plane_name"" to associate pilots with the locations of their planes. 4. Aggregation Structure: Use COUNT to aggregate the number of pilots whose planes are located in Chicago.",1.0
1319,Find the number of pilots whose age is younger than all pilots whose plane is F-14 Fighter.,NESTED,pilot_1,"[PilotSkills.age, PilotSkills.plane_name, Hangar.plane_name, Hangar.plane_name = PilotSkills.plane_name, F-14 Fighter]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT COUNT(*) FROM PilotSkills WHERE age < ALL ( SELECT age FROM PilotSkills WHERE plane_name = 'F-14 Fighter' );,SELECT count(*) FROM pilotskills WHERE age  <  (SELECT min(age) FROM pilotskills WHERE plane_name  =  'F-14 Fighter'),"1. Sequential Structure: Start with the SELECT clause to count the number of pilots. Use the FROM clause to specify the PilotSkills table. Apply a WHERE clause to filter for pilots whose age is younger than all pilots associated with the plane ""F-14 Fighter."" 2. Condition Structure: Use the WHERE clause with a subquery to compare the age of pilots to the minimum age of pilots associated with the ""F-14 Fighter"" plane. The subquery retrieves the ages of pilots whose plane is ""F-14 Fighter."" 3. Join Structure: Not required, as all necessary data is available in the PilotSkills table. 4. Aggregation Structure: Use COUNT to count the number of pilots meeting the specified condition.",0.0
1320,What are the full names of artists born after 1850?,EASY,art_1,"[Artists.lname, Artists.fname, Artists.birthYear]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Artists.fname, Artists.lname FROM Artists WHERE Artists.birthYear > 1850;","SELECT lname ,  fname FROM artists WHERE birthYear  >  1850","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the first name (""Artists.fname"") and last name (""Artists.lname"") of the artists. 2. Condition Structure: Use a WHERE clause to filter for artists whose ""Artists.birthYear"" is greater than 1850. 3. Join Structure: No JOIN is required since all necessary data is within the ""Artists"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of artists based on a specific condition.",1.0
1321,List in alphabetic order the names of pilots whose age is greater than some pilots having plane Piper Cub.,NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name, Hangar.plane_name, Hangar.plane_name = PilotSkills.plane_name, Piper Cub]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT DISTINCT pilot_name FROM PilotSkills WHERE age > ANY (SELECT age FROM PilotSkills WHERE plane_name = 'Piper Cub') ORDER BY pilot_name ASC;,SELECT pilot_name FROM pilotskills WHERE age  >  (SELECT min(age) FROM pilotskills WHERE plane_name  =  'Piper Cub') ORDER BY pilot_name,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of pilots. Use the FROM clause to specify the PilotSkills table. Apply a WHERE clause to filter pilots whose age is greater than the age of some pilots who have the plane ""Piper Cub"". Use the ORDER BY clause to sort the names alphabetically. 2. Condition Structure: Use the WHERE clause with a subquery to filter pilots whose age is greater than the age of at least one pilot associated with the plane ""Piper Cub"". The subquery retrieves the ages of pilots who have the plane ""Piper Cub"". 3. Join Structure: Not required, as all necessary data is in the PilotSkills table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",0.0
1322,What is the name of the most popular plane?,EASY,pilot_1,[PilotSkills.plane_name],"Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
",SELECT PilotSkills.plane_name FROM PilotSkills GROUP BY PilotSkills.plane_name ORDER BY COUNT(*) DESC LIMIT 1;,SELECT plane_name FROM pilotskills GROUP BY plane_name ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the plane name. 2. Aggregation Structure: Use COUNT to determine the number of pilots associated with each plane. 3. Grouping Structure: Use GROUP BY on ""PilotSkills.plane_name"" to aggregate the results by each plane name. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank planes by popularity. 5. Limiting Structure: Use LIMIT 1 to retrieve the name of the most popular plane. 6. Join Structure: No JOIN is required since all necessary data is within the ""PilotSkills"" table.",1.0
1323,What are the names and ages of drivers who raced in two or more races?,NESTED,car_road_race,"[driver.Driver_Name, driver.Age, race.Driver_ID, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT driver.Driver_Name, driver.Age FROM driver JOIN race ON driver.Driver_ID = race.Driver_ID GROUP BY driver.Driver_ID, driver.Driver_Name, driver.Age HAVING COUNT(race.Driver_ID) >= 2;","SELECT T1.Driver_Name ,  T1.Age FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID GROUP BY T1.Driver_ID HAVING COUNT(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve the names and ages of drivers. Use the FROM clause to specify the driver table and JOIN it with the race table to connect drivers with their race records. Use GROUP BY to group records by driver ID, allowing us to count the number of races for each driver. Apply a HAVING clause to filter drivers who participated in two or more races. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for drivers who participated in two or more races. 3. Join Structure: Use an INNER JOIN between the driver and race tables based on Driver_ID to link drivers with their race participation. 4. Aggregation Structure: Use COUNT(*) within HAVING to aggregate the number of races per driver and filter out drivers with fewer than two races.",1.0
1324,What are the id and height of the painting with the longest width in gallery 240?,NESTED,art_1,"[Paintings.paintingID, Paintings.height_mm, Paintings.width_mm, Paintings.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT paintingID, height_mm FROM Paintings WHERE location = 240 AND width_mm = (SELECT MAX(width_mm) FROM Paintings WHERE location = 240);","SELECT paintingID ,  height_mm FROM paintings WHERE LOCATION  =  'Gallery 240' ORDER BY width_mm DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the painting ID and height of the painting. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter for paintings located in gallery 240 and having the longest width. 2. Condition Structure: Use the WHERE clause to filter for paintings in gallery 240 and with the maximum width. A subquery is used to find the maximum width among paintings in gallery 240. 3. Join Structure: Not required, as all data is available within the Paintings table. 4. Aggregation Structure: Use MAX in a subquery to find the longest width among paintings in gallery 240.",0.0
1325,Give me a list of names and years of paintings that were created by the artist whose first name is Mary.,NON-NESTED,art_1,"[Artists.fname, Artists.artistID = Paintings.painterID, Paintings.title, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
","SELECT Paintings.title, Paintings.year FROM Artists JOIN Paintings ON Artists.artistID = Paintings.painterID WHERE Artists.fname = 'Mary';","SELECT T2.title ,   T2.year FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T1.fname  =  ""Mary""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paintings.title"" and ""Paintings.year"" fields. 2. Condition Structure: Use a WHERE clause to filter for artists whose first name (""Artists.fname"") is ""Mary."" 3. Join Structure: Use a JOIN between the ""Artists"" and ""Paintings"" tables based on the relationship ""Artists.artistID = Paintings.painterID"" to link each painting with its respective artist. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without any summarization.",1.0
1326,"Which winning drivers of races had pole position that is not ""Junior Strous""?",NESTED,car_road_race,"[race.Winning_driver, race.Pole_Position, driver.Driver_Name, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Driver_Name FROM race JOIN driver ON race.Driver_ID = driver.Driver_ID WHERE race.Pole_Position != 'Junior Strous';,SELECT Winning_driver FROM race WHERE Pole_Position != 'Junior Strous',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of winning drivers. Use the FROM clause to specify the race table and JOIN it with the driver table to get the driver names. Apply a WHERE clause to filter for races where the pole position is not ""Junior Strous"". 2. Condition Structure: Use the WHERE clause to exclude races where the pole position is ""Junior Strous"". 3. Join Structure: Use an INNER JOIN between the race and driver tables based on the Driver_ID to connect race details with driver names. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1327,Find the number of districts which have no spokesmen.,NESTED,district_spokesman,"[district.District_ID, spokesman_district.District_ID, spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
",SELECT COUNT(*) FROM district WHERE District_ID NOT IN (SELECT District_ID FROM spokesman_district);,SELECT count(*) FROM district WHERE district_id NOT IN (SELECT district_id FROM spokesman_district),"1. Sequential Structure: Start with the SELECT clause to count the number of districts. Use the FROM clause to specify the district table. Apply a WHERE clause to filter districts that do not have any spokesmen by ensuring their District_ID is not present in the spokesman_district table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude districts whose District_ID appears in the spokesman_district table, meaning they have spokesmen. 3. Join Structure: Not required, as we only need to filter based on the absence of matching District_ID entries in the spokesman_district table. 4. Aggregation Structure: Use COUNT to calculate the total number of districts that meet the condition of having no spokesmen.",1.0
1328,Where do you have paintings that were created before 1885 that are not on canvas?,NESTED,art_1,"[Paintings.location, Paintings.year, Paintings.medium, 1885]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT location FROM Paintings WHERE year < 1885 AND medium != 'canvas';,"SELECT DISTINCT LOCATION FROM paintings WHERE YEAR  <  1885 AND mediumOn != ""canvas""","1. Sequential Structure: Start with the SELECT clause to retrieve the location of paintings. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter for paintings created before the year 1885 and exclude those with the medium 'canvas'. 2. Condition Structure: Use the WHERE clause to filter for paintings with a year less than 1885 and a medium not equal to 'canvas'. 3. Join Structure: Not required, as all data is available within the Paintings table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1329,"What are the different plane names, and what are the names of the oldest pilot who has each, ordered by plane name?",NON-NESTED,pilot_1,"[PilotSkills.plane_name, PilotSkills.pilot_name, PilotSkills.age, Hangar.plane_name, PilotSkills.plane_name = Hangar.plane_name]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.plane_name, PilotSkills.pilot_name FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name GROUP BY PilotSkills.plane_name HAVING MAX(PilotSkills.age) ORDER BY PilotSkills.plane_name ASC;","SELECT pilot_name ,  plane_name ,  max(age) FROM pilotskills GROUP BY plane_name ORDER BY plane_name","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""plane_name"" and the ""pilot_name"" of the oldest pilot for each plane. Use MAX on ""age"" to identify the oldest pilot. 2. Condition Structure: No specific filtering condition is required, as we are interested in all planes and their oldest pilots. 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the ""plane_name"" field to ensure we are working with valid plane names. 4. Aggregation Structure: Use GROUP BY on ""plane_name"" to group results by each plane, and apply MAX on ""age"" to find the oldest pilot for each plane. Finally, use ORDER BY to sort the results alphabetically by ""plane_name.""",0.0
1330,Who is the youngest pilot to fly the plane Piper Cub?,NON-NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age, PilotSkills.plane_name, PilotSkills.plane_name = Hangar.plane_name, Hangar.plane_name, Piper Cub]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT PilotSkills.pilot_name, PilotSkills.age FROM PilotSkills JOIN Hangar ON PilotSkills.plane_name = Hangar.plane_name WHERE Hangar.plane_name = 'Piper Cub' ORDER BY PilotSkills.age ASC LIMIT 1;",SELECT pilot_name FROM pilotskills WHERE plane_name  =  'Piper Cub' ORDER BY age LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""PilotSkills.pilot_name"" and ""PilotSkills.age"" of the youngest pilot. Use ORDER BY on ""PilotSkills.age"" in ascending order to find the youngest pilot. 2. Condition Structure: Use a WHERE clause to filter for the specific plane ""Piper Cub."" 3. Join Structure: Use a JOIN between the ""PilotSkills"" and ""Hangar"" tables based on the shared ""plane_name"" field to ensure the correct association between pilots and planes. 4. Aggregation Structure: Use LIMIT 1 to select only the youngest pilot after ordering by age.",1.0
1331,Find the ids of paintings whose height is bigger than 500 and less than 2000?,EASY,art_1,"[Paintings.paintingID, Paintings.height_mm, 500, 2000]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.paintingID FROM Paintings WHERE Paintings.height_mm > 500 AND Paintings.height_mm < 2000;,SELECT paintingID FROM paintings WHERE height_mm  >  500 AND height_mm  <  2000,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""Paintings.paintingID"". 2. Condition Structure: Use a WHERE clause to filter paintings where the ""Paintings.height_mm"" is greater than 500 and less than 2000. 3. Join Structure: No JOIN is required since all necessary information is in the ""Paintings"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving painting IDs that meet the specified height condition.",1.0
1332,What are the widths of the paintings that were created by the artist who was born before 1850?,NON-NESTED,art_1,"[Paintings.width_mm,Artists.birthYear,Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Paintings.width_mm FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID WHERE Artists.birthYear < 1850;,SELECT T2.width_mm FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T1.birthYear  <  1850,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paintings.width_mm"" field, as the question asks for the widths of the paintings. 2. Condition Structure: Use a WHERE clause to filter for artists who were born before 1850. This condition will be applied to the ""Artists.birthYear"" field. 3. Join Structure: Use a JOIN between the ""Paintings"" and ""Artists"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to link each painting with its respective artist. 4. Aggregation Structure: No aggregation is needed, as the question does not require any summarization or grouping of data.",1.0
1333,Return the ids and names of the districts whose population is larger than 4000 or area bigger than 3000.,EASY,district_spokesman,"[district.District_ID, district.Name, district.Population, district.Area_km]","Table district, columns = [*,District_ID,Name,Area_km,Population,Density_km,Government_website]
Table spokesman, columns = [*,Spokesman_ID,Name,Age,Speach_title,Rank_position,Points]
Table spokesman_district, columns = [*,Spokesman_ID,District_ID,Start_year]
","Foreign_keys = [spokesman_district.District_ID = district.District_ID,spokesman_district.Spokesman_ID = spokesman.Spokesman_ID]
","SELECT district.District_ID, district.Name FROM district WHERE district.Population > 4000 OR district.Area_km > 3000;","SELECT district_id ,  name FROM district WHERE area_km  >  3000 OR population  >  4000","1. Sequential Structure: Start with the SELECT clause to retrieve the ""district.District_ID"" and ""district.Name"" of districts that meet the specified conditions. 2. Condition Structure: Use a WHERE clause to filter districts where the ""district.Population"" is greater than 4000 or the ""district.Area_km"" is greater than 3000. 3. Join Structure: No JOIN is required since all necessary information is in the ""district"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving district IDs and names based on the specified conditions.",1.0
1334,Find the name of the conferences that have the top 2 most number of attendants.,NON-NESTED,conference,"[conference.Conference_Name,conference.Conference_ID = conference_participation.Conference_ID,conference_participation.staff_ID]","Table conference, columns = [*,Conference_ID,Conference_Name,Year,Location]
Table conference_participation, columns = [*,Conference_ID,staff_ID,role]
Table institution, columns = [*,Institution_ID,Institution_Name,Location,Founded]
Table staff, columns = [*,staff_ID,name,Age,Nationality,Institution_ID]
","Foreign_keys = [staff.Institution_ID = institution.Institution_ID,conference_participation.Conference_ID = conference.Conference_ID,conference_participation.staff_ID = staff.staff_ID]
",SELECT conference.Conference_Name FROM conference JOIN conference_participation ON conference.Conference_ID = conference_participation.Conference_ID GROUP BY conference.Conference_ID ORDER BY COUNT(conference_participation.staff_ID) DESC LIMIT 2;,SELECT T1.conference_name FROM Conference AS T1 JOIN Conference_participation AS T2 ON T1.conference_id  =  T2.conference_id GROUP BY T2.conference_id ORDER BY count(*) DESC LIMIT 2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""conference.Conference_Name."" Use COUNT to calculate the number of attendants for each conference. Use ORDER BY in descending order to rank conferences by the number of attendants and LIMIT 2 to get the top 2 conferences. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all conferences. 3. Join Structure: Use a JOIN between the ""conference"" and ""conference_participation"" tables based on ""conference.Conference_ID"" and ""conference_participation.Conference_ID"" to link each conference with its attendants. 4. Aggregation Structure: Use COUNT on ""conference_participation.staff_ID"" to count the number of attendants for each conference, then GROUP BY ""conference.Conference_ID"" to group results by each conference.",1.0
1335,What are first names of the artists with oil paintings in gallery 241?,NON-NESTED,art_1,"[Artists.fname,Paintings.medium,Paintings.location,Paintings.painterID = Artists.artistID]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT Artists.fname FROM Paintings JOIN Artists ON Paintings.painterID = Artists.artistID WHERE Paintings.medium = 'oil' AND Paintings.location = '241';,"SELECT DISTINCT T1.fname FROM artists AS T1 JOIN paintings AS T2 ON T1.artistID  =  T2.painterID WHERE T2.medium  =  ""oil"" AND LOCATION  =  ""Gallery 241""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Artists.fname"" field, which represents the first names of the artists. 2. Condition Structure: Use a WHERE clause to filter for paintings with the medium ""oil"" and location ""241."" 3. Join Structure: Use a JOIN between the ""Paintings"" and ""Artists"" tables based on the relationship ""Paintings.painterID = Artists.artistID"" to link paintings with their respective artists. 4. Aggregation Structure: No aggregation is needed as the query only requires the first names of the artists.",0.0
1336,What are the ids of the paintings whose height is longer than the height of all paintings created after 1900?,NESTED,art_1,"[Paintings.paintingID, Paintings.height_mm, Paintings.year]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT paintingID FROM Paintings WHERE height_mm > ALL (SELECT height_mm FROM Paintings WHERE year > 1900);,SELECT paintingID FROM paintings WHERE height_mm  >   (SELECT max(height_mm) FROM paintings WHERE YEAR  >  1900),"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of paintings. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter paintings whose height is greater than the height of all paintings created after 1900. 2. Condition Structure: Use the WHERE clause with a subquery to compare the height of each painting to the maximum height of paintings created after 1900. The subquery filters paintings created after 1900 and retrieves their heights. 3. Join Structure: Not required, as all data is available within the Paintings table. 4. Aggregation Structure: Use a subquery to calculate the maximum height of paintings created after 1900, and compare this value to the height of each painting in the main query.",0.0
1337,"What are the names of pilots whose age is below the average age, ordered by age?",NESTED,pilot_1,"[PilotSkills.pilot_name, PilotSkills.age]","Table Hangar, columns = [*,plane_name,location]
Table PilotSkills, columns = [*,pilot_name,plane_name,age]
","Foreign_keys = [PilotSkills.plane_name = Hangar.plane_name]
","SELECT pilot_name, age FROM PilotSkills WHERE age < (SELECT AVG(age) FROM PilotSkills) ORDER BY age;",SELECT pilot_name FROM PilotSkills WHERE age  <  (SELECT avg(age) FROM PilotSkills) ORDER BY age,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of pilots and their ages. Use the FROM clause to specify the PilotSkills table. Apply a WHERE clause to filter pilots whose age is below the average age. Use the ORDER BY clause to sort the results by age in ascending order. 2. Condition Structure: Use the WHERE clause with a subquery to filter for pilots whose age is less than the average age. The subquery calculates the average age from the PilotSkills table. 3. Join Structure: Not required, as all data is available within the PilotSkills table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average age, which is then used in the filtering condition.",1.0
1338,What is the age of the driver who raced in the most races?,NON-NESTED,car_road_race,"[driver.Age, race.Driver_ID, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Age FROM race JOIN driver ON race.Driver_ID = driver.Driver_ID GROUP BY race.Driver_ID ORDER BY COUNT(race.Driver_ID) DESC LIMIT 1;,SELECT T1.Age FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID GROUP BY T1.Driver_ID ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Age"" of the driver who participated in the most races. Use COUNT to count the number of races each driver participated in. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the driver with the maximum number of races. 3. Join Structure: Use a JOIN between the ""race"" and ""driver"" tables based on ""Driver_ID"" to associate each race with its respective driver. 4. Aggregation Structure: Use COUNT to count the number of races for each driver, GROUP BY ""race.Driver_ID"" to group the counts by driver, and ORDER BY the count in descending order to find the driver with the most races. Use LIMIT 1 to select the top result.",1.0
1339,Find the distinct ids of all paintings that are older than some painting at location gallery 240.,NESTED,art_1,"[Paintings.paintingID, Paintings.year, Paintings.location]","Table Artists, columns = [*,artistID,lname,fname,birthYear,deathYear]
Table Paintings, columns = [*,paintingID,title,year,height_mm,width_mm,medium,mediumOn,location,painterID]
Table Sculptures, columns = [*,sculptureID,title,year,medium,location,sculptorID]
","Foreign_keys = [Paintings.painterID = Artists.artistID,Sculptures.sculptorID = Artists.artistID]
",SELECT DISTINCT paintingID FROM Paintings WHERE year < ANY (SELECT year FROM Paintings WHERE location = 'gallery 240');,"SELECT paintingID FROM paintings WHERE YEAR  <  (SELECT max(YEAR) FROM paintings WHERE LOCATION  =  ""Gallery 240"")","1. Sequential Structure: Start with the SELECT clause to retrieve distinct painting IDs. Use the FROM clause to specify the Paintings table. Apply a WHERE clause to filter paintings that are older than at least one painting located in gallery 240. 2. Condition Structure: Use the WHERE clause with a subquery to compare the year of paintings with the year of paintings located in gallery 240. The subquery retrieves the years of paintings at location 'gallery 240'. 3. Join Structure: Not required, as all data is in the Paintings table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",0.0
1340,What are the distinct product names of bikes owned by cyclists from 'Russia' or cyclists from 'Great Britain'?,NON-NESTED,bike_racing,"[bike.product_name,cyclist.nation,cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id,'Russia','Great Britain']","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
",SELECT DISTINCT bike.product_name FROM cyclist JOIN cyclists_own_bikes ON cyclist.id = cyclists_own_bikes.cyclist_id JOIN bike ON cyclists_own_bikes.bike_id = bike.id WHERE cyclist.nation = 'Russia' OR cyclist.nation = 'Great Britain';,SELECT DISTINCT T3.product_name FROM cyclist AS T1 JOIN cyclists_own_bikes AS T2 ON T1.id  =  T2.cyclist_id JOIN bike AS T3 ON T2.bike_id  =  T3.id WHERE T1.nation  =  'Russia' OR T1.nation  =  'Great Britain',"1. Sequential Structure: Start with the SELECT clause to retrieve distinct ""bike.product_name."" 2. Condition Structure: Use a WHERE clause to filter for cyclists whose ""cyclist.nation"" is either 'Russia' or 'Great Britain.' 3. Join Structure: Use JOINs to connect the ""cyclist"" table with ""cyclists_own_bikes"" on ""cyclist.id"" and then connect ""cyclists_own_bikes"" with ""bike"" on ""bike.id"" to link cyclists with the bikes they own. 4. Aggregation Structure: Use DISTINCT to ensure that only unique product names are returned.",1.0
1341,Show the official languages spoken by at least two countries.,NON-NESTED,country_language,"[languages.name, official_languages.language_id, official_languages.country_id, countries.id = official_languages.country_id, official_languages.language_id = languages.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT languages.name FROM languages JOIN official_languages ON languages.id = official_languages.language_id JOIN countries ON countries.id = official_languages.country_id GROUP BY official_languages.language_id HAVING COUNT(official_languages.country_id) >= 2;,SELECT T2.name FROM official_languages AS T1 JOIN languages AS T2 ON T1.language_id  =  T2.id GROUP BY T2.id HAVING COUNT(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of official languages. Use GROUP BY to group by the language ID to count the number of countries speaking each language. 2. Condition Structure: Use a HAVING clause to filter for languages spoken by at least two countries. 3. Join Structure: Use JOINs to connect the ""languages"" table with the ""official_languages"" table on ""languages.id = official_languages.language_id"" and the ""official_languages"" table with the ""countries"" table on ""countries.id = official_languages.country_id."" 4. Aggregation Structure: Use COUNT on ""official_languages.country_id"" to count the number of countries for each language, and filter with HAVING to include only those with a count of at least two.",1.0
1342,What is the cheapest good with cheese flavor?,NESTED,bakery_1,"[goods.Flavor, goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT Food FROM goods WHERE Flavor = 'cheese' ORDER BY Price ASC LIMIT 1;,"SELECT min(price) FROM goods WHERE flavor  =  ""Cheese""","1. Sequential Structure: Start with the SELECT clause to retrieve the name of the food item. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter for goods with the flavor 'cheese'. Use ORDER BY to sort the results by price in ascending order and LIMIT 1 to get the cheapest good. 2. Condition Structure: Use the WHERE clause to filter for goods where the flavor is 'cheese'. 3. Join Structure: Not required, as all data is in the goods table. 4. Aggregation Structure: Not required, as we are only retrieving the cheapest good without any aggregation.",0.0
1343,What is the age range category of the user who made the first search?,NON-NESTED,real_estate_rentals,"[User_Searches.user_id,User_Searches.search_datetime,Users.user_id = User_Searches.user_id,Users.age_category_code,Ref_Age_Categories.age_category_code = Users.age_category_code,Ref_Age_Categories.age_category_description]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Ref_Age_Categories.age_category_description FROM User_Searches JOIN Users ON User_Searches.user_id = Users.user_id JOIN Ref_Age_Categories ON Users.age_category_code = Ref_Age_Categories.age_category_code ORDER BY User_Searches.search_datetime ASC LIMIT 1;,SELECT T1.age_category_code FROM Users AS T1 JOIN User_Searches AS T2 ON T1.user_id  =  T2.user_id ORDER BY T2.search_datetime LIMIT 1;,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Ref_Age_Categories.age_category_description,"" which represents the age range category. Use ORDER BY on ""User_Searches.search_datetime"" in ascending order to identify the first search. Use LIMIT 1 to select only the first record. 2. Condition Structure: No specific filtering condition is required since we are only interested in the first search. 3. Join Structure: Use JOINs to connect the ""User_Searches"" table with the ""Users"" table on ""User_Searches.user_id = Users.user_id"" and then connect the ""Users"" table with the ""Ref_Age_Categories"" table on ""Users.age_category_code = Ref_Age_Categories.age_category_code"" to retrieve the age range category. 4. Aggregation Structure: No aggregation is needed as we are only retrieving a single record.",1.0
1344,How many bikes does each cyclist own? Order by cyclist id.,NON-NESTED,bike_racing,"[cyclist.id,cyclists_own_bikes.cyclist_id,cyclists_own_bikes.bike_id]","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
","SELECT cyclist.id, COUNT(cyclists_own_bikes.bike_id) AS bike_count FROM cyclist JOIN cyclists_own_bikes ON cyclist.id = cyclists_own_bikes.cyclist_id GROUP BY cyclist.id ORDER BY cyclist.id;","SELECT cyclist_id ,  count(*) FROM cyclists_own_bikes GROUP BY cyclist_id ORDER BY cyclist_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""cyclist.id"" and the count of bikes owned by each cyclist. Use COUNT on ""cyclists_own_bikes.bike_id"" to count the number of bikes for each cyclist. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""cyclist"" table and the ""cyclists_own_bikes"" table on ""cyclist.id"" and ""cyclists_own_bikes.cyclist_id"" to associate each cyclist with their owned bikes. 4. Aggregation Structure: Use COUNT to aggregate the number of bikes per cyclist and GROUP BY ""cyclist.id"" to group the results by each cyclist. Apply ORDER BY on ""cyclist.id"" to sort the results by cyclist ID.",1.0
1345,List the name and price of the bike that is owned by both the cyclists named 'Bradley Wiggins' and the cyclist named 'Antonio Tauler'.,NESTED,bike_racing,"[cyclist.name, cyclist.id, cyclists_own_bikes.cyclist_id = cyclist.id, cyclists_own_bikes.bike_id, bike.id = cyclists_own_bikes.bike_id, bike.product_name, bike.price, 'Bradley Wiggins', 'Antonio Tauler']","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
","SELECT bike.product_name, bike.price FROM bike JOIN cyclists_own_bikes ON bike.id = cyclists_own_bikes.bike_id JOIN cyclist ON cyclists_own_bikes.cyclist_id = cyclist.id WHERE bike.id IN ( SELECT bike_id FROM cyclists_own_bikes WHERE cyclist_id = (SELECT id FROM cyclist WHERE name = 'Bradley Wiggins') ) AND bike.id IN ( SELECT bike_id FROM cyclists_own_bikes WHERE cyclist_id = (SELECT id FROM cyclist WHERE name = 'Antonio Tauler') );","SELECT T3.product_name ,  T3.price FROM cyclist AS T1 JOIN cyclists_own_bikes AS T2 ON T1.id  =  T2.cyclist_id JOIN bike AS T3 ON T2.bike_id  =  T3.id WHERE T1.name  =  'Bradley Wiggins' INTERSECT SELECT T3.product_name ,  T3.price FROM cyclist AS T1 JOIN cyclists_own_bikes AS T2 ON T1.id  =  T2.cyclist_id JOIN bike AS T3 ON T2.bike_id  =  T3.id WHERE T1.name  =  'Antonio Tauler'","1. Sequential Structure: Start with the SELECT clause to retrieve the name and price of the bike. Use the FROM clause to specify the bike table and JOIN it with the cyclists_own_bikes and cyclist tables to connect bikes with their owners. Apply a WHERE clause to filter for bikes owned by both 'Bradley Wiggins' and 'Antonio Tauler'. 2. Condition Structure: Use the WHERE clause with a subquery to identify bikes owned by both cyclists. The subquery retrieves bike IDs for each cyclist, and the main query filters for bikes that appear in both sets. 3. Join Structure: Use INNER JOINs between the cyclist, cyclists_own_bikes, and bike tables to connect cyclist names to the bikes they own. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1346,List all the flavors of Croissant available in this bakery.,EASY,bakery_1,"[goods.Flavor,goods.Food]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Flavor FROM goods WHERE goods.Food = 'Croissant';,"SELECT flavor FROM goods WHERE food  =  ""Croissant""","1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""goods.Flavor"". 2. Condition Structure: Use a WHERE clause to filter for items where ""goods.Food"" is 'Croissant'. 3. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the flavors of Croissant.",1.0
1347,List different constructors and the number of drivers that use each constructor.,NON-NESTED,car_road_race,"[driver.Constructor, driver.Driver_ID, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT driver.Constructor, COUNT(driver.Driver_ID) AS num_drivers FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID GROUP BY driver.Constructor;","SELECT CONSTRUCTOR ,  COUNT(*) FROM driver GROUP BY CONSTRUCTOR","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct constructors and the count of drivers associated with each constructor. Use ""driver.Constructor"" and COUNT(""driver.Driver_ID""). 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""race"" and ""driver"" tables based on ""race.Driver_ID = driver.Driver_ID"" to associate drivers with their constructors. 4. Aggregation Structure: Use COUNT to count the number of drivers for each constructor and GROUP BY ""driver.Constructor"" to group the results by constructor.",0.0
1348,How many drivers have points smaller than 150?,EASY,car_racing,"[driver.Driver_ID, driver.Points, 150]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT COUNT(driver.Driver_ID) FROM driver WHERE driver.Points < 150;,SELECT count(*) FROM driver WHERE Points  <  150,"1. Sequential Structure: Start with the SELECT clause to count the number of drivers. 2. Condition Structure: Use a WHERE clause to filter drivers whose ""driver.Points"" are less than 150. 3. Join Structure: No JOIN is required since all necessary information is in the ""driver"" table. 4. Aggregation Structure: Use COUNT to calculate the number of drivers meeting the specified condition.",1.0
1349,"For each date, return how many distinct customers visited on that day.",NON-NESTED,bakery_1,"[receipts.Date, receipts.CustomerId, customers.Id = receipts.CustomerId]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT receipts.Date, COUNT(DISTINCT receipts.CustomerId) AS DistinctCustomerCount FROM receipts GROUP BY receipts.Date;","SELECT date ,  COUNT (DISTINCT CustomerId) FROM receipts GROUP BY date","1. Sequential Structure: Start with the SELECT clause to retrieve the ""receipts.Date"" and the count of distinct ""receipts.CustomerId"" for each date. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: No JOIN is necessary since the required data is available in the ""receipts"" table, and the relationship with ""customers"" is not needed for this query. 4. Aggregation Structure: Use COUNT with DISTINCT on ""receipts.CustomerId"" to count the unique customers for each date, and GROUP BY ""receipts.Date"" to group the results by each date.",1.0
1350,List the most common type of engine used by drivers.,NON-NESTED,car_road_race,"[driver.Engine, driver.Driver_ID, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT driver.Engine, COUNT(driver.Engine) AS engine_count FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID GROUP BY driver.Engine ORDER BY engine_count DESC LIMIT 1;",SELECT Engine FROM driver GROUP BY Engine ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Engine"" field. Use COUNT to determine the frequency of each engine type and identify the most common one. 2. Condition Structure: No specific filtering condition is required, as we are analyzing all drivers. 3. Join Structure: Use a JOIN between the ""driver"" and ""race"" tables based on ""Driver_ID"" to ensure we are considering only valid driver records. 4. Aggregation Structure: Use COUNT to count the occurrences of each engine type, GROUP BY ""driver.Engine"" to group results by engine type, and ORDER BY the count in descending order to find the most common engine type. Use LIMIT 1 to select the top result.",1.0
1351,What are the receipt numbers for instances where both cakes and cookies were purchased?,NESTED,bakery_1,"[items.Item,goods.Food,receipts.ReceiptNumber,items.Receipt = receipts.ReceiptNumber,items.Item = goods.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT receipts.ReceiptNumber FROM items JOIN goods ON items.Item = goods.Id JOIN receipts ON items.Receipt = receipts.ReceiptNumber WHERE goods.Food IN ('cake', 'cookie') GROUP BY receipts.ReceiptNumber HAVING COUNT(DISTINCT goods.Food) = 2;","SELECT T1.receipt FROM items AS T1 JOIN goods AS T2 ON T1.item  =  T2.id WHERE T2.food  =  ""Cake"" INTERSECT SELECT T1.receipt FROM items AS T1 JOIN goods AS T2 ON T1.item  =  T2.id WHERE T2.food  =  ""Cookie""","1. Sequential Structure: Start with the SELECT clause to retrieve the receipt numbers. Use the FROM clause to specify the items table and join it with the goods and receipts tables to connect items with their corresponding receipt numbers and food types. Use a WHERE clause to filter for instances where both cakes and cookies were purchased. 2. Condition Structure: Use a WHERE clause to filter for receipts that include both cakes and cookies. This can be achieved by grouping by receipt numbers and using a HAVING clause to ensure that both items are present in the same receipt. 3. Join Structure: Use JOINs between the items, goods, and receipts tables based on the relationships provided in the schema (items.Receipt = receipts.ReceiptNumber and items.Item = goods.Id). 4. Aggregation Structure: Use GROUP BY on receipt numbers and a HAVING clause to ensure that both cakes and cookies are present in the grouped items for each receipt.",0.0
1352,What are the age categories for users whose description contains the string Mother?,NON-NESTED,real_estate_rentals,"[Users.user_category_code,Users.other_user_details,Users.age_category_code = Ref_Age_Categories.age_category_code,Mother]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Ref_Age_Categories.age_category_code FROM Users JOIN Ref_Age_Categories ON Users.age_category_code = Ref_Age_Categories.age_category_code WHERE Users.other_user_details LIKE '%Mother%';,"SELECT T2.age_category_code FROM Ref_User_Categories AS T1 JOIN Users AS T2 ON T1.user_category_code  =  T2.user_category_code WHERE T1.User_category_description LIKE ""%Mother"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Ref_Age_Categories.age_category_code"" or its corresponding description, as we are interested in the age categories. 2. Condition Structure: Use a WHERE clause to filter for users whose ""Users.other_user_details"" contains the string ""Mother."" 3. Join Structure: Use a JOIN between the ""Users"" table and the ""Ref_Age_Categories"" table on the ""Users.age_category_code"" and ""Ref_Age_Categories.age_category_code"" to link users with their respective age categories. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving the age categories for the filtered users.",0.0
1353,Find the id of customers who shopped at the bakery at least 15 times.,NON-NESTED,bakery_1,"[receipts.CustomerId,receipts.ReceiptNumber,items.Receipt = receipts.ReceiptNumber,customers.Id = receipts.CustomerId]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT customers.Id FROM customers JOIN receipts ON customers.Id = receipts.CustomerId JOIN items ON items.Receipt = receipts.ReceiptNumber GROUP BY customers.Id HAVING COUNT(receipts.ReceiptNumber) >= 15;,SELECT CustomerId FROM receipts GROUP BY CustomerId HAVING count(*)  >=  15,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""customers.Id"" of customers who meet the condition. Use GROUP BY to group the data by ""customers.Id"" and apply a HAVING clause to filter customers who shopped at the bakery at least 15 times. 2. Condition Structure: Use a HAVING clause to filter for customers whose count of receipts (indicating shopping instances) is greater than or equal to 15. 3. Join Structure: Use JOINs to connect the ""receipts"" table with the ""items"" table on ""items.Receipt = receipts.ReceiptNumber"" and the ""customers"" table on ""customers.Id = receipts.CustomerId"" to link customers with their shopping records. 4. Aggregation Structure: Use COUNT on ""receipts.ReceiptNumber"" to count the number of shopping instances for each customer, then filter with HAVING to select customers with at least 15 shopping instances.",1.0
1354,"What are the id and price for the good with ""70"" in its id?",EASY,bakery_1,"[goods.Id, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Id, goods.Price FROM goods WHERE goods.Id LIKE '%70%';","SELECT id ,  price FROM goods WHERE id LIKE ""%70%""","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""goods.Id"" and ""goods.Price"". 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for goods where the ""goods.Id"" contains ""70"". 3. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
1355,What are the distinct ids and product names of the bikes that are purchased after year 2015?,NON-NESTED,bike_racing,"[bike.id, bike.product_name, cyclists_own_bikes.bike_id = bike.id, cyclists_own_bikes.purchase_year, 2015]","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
","SELECT DISTINCT bike.id, bike.product_name FROM bike JOIN cyclists_own_bikes ON cyclists_own_bikes.bike_id = bike.id WHERE cyclists_own_bikes.purchase_year > 2015;","SELECT DISTINCT T1.id ,  T1.product_name FROM bike AS T1 JOIN cyclists_own_bikes AS T2 ON T1.id  =  T2.bike_id WHERE T2.purchase_year  >  2015","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""bike.id"" and ""bike.product_name."" 2. Condition Structure: Use a WHERE clause to filter for bikes that were purchased after the year 2015. This condition will be applied on the ""cyclists_own_bikes.purchase_year"" field. 3. Join Structure: Use a JOIN between the ""bike"" table and the ""cyclists_own_bikes"" table based on the relationship ""cyclists_own_bikes.bike_id = bike.id"" to link each bike with its purchase details. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique combinations of bike IDs and product names are returned.",1.0
1356,What are the name and result of the cyclists not from 'Russia' ?,EASY,bike_racing,"[cyclist.name, cyclist.result, cyclist.nation]","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
","SELECT cyclist.name, cyclist.result FROM cyclist WHERE cyclist.nation != 'Russia';","SELECT name ,  RESULT FROM cyclist WHERE nation != 'Russia'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""cyclist.name"" and ""cyclist.result"" fields. 2. Condition Structure: Use a WHERE clause to filter out cyclists whose nation is 'Russia'. 3. Join Structure: No JOIN is required since all necessary information is in the ""cyclist"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific fields based on a condition.",1.0
1357,What is the average age of drivers for each make? Return the average age and make.,EASY,car_racing,"[driver.Age, driver.Make]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT driver.Make, AVG(driver.Age) AS average_age FROM driver GROUP BY driver.Make;","SELECT avg(age) ,  Make FROM driver GROUP BY make","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the make and the average age of drivers. 2. Aggregation Structure: Use the AVG function to calculate the average age of drivers for each make. 3. Grouping Structure: Use GROUP BY on ""driver.Make"" to calculate the average age for each make. 4. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table.",1.0
1358,List the name of languages in ascending alphabetical order.,EASY,country_language,[languages.name],"Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT languages.name FROM languages ORDER BY languages.name ASC;,SELECT name FROM languages ORDER BY name ASC,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""languages.name"". 2. Condition Structure: No specific filtering condition is required as we want all language names. 3. Join Structure: No JOIN is required since all necessary information is in the ""languages"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the language names. 5. Ordering Structure: Use ORDER BY in ascending order to sort the language names alphabetically.",1.0
1359,In which states are each of the the properties located?,NON-NESTED,real_estate_rentals,"[Properties.property_address_id, Addresses.county_state_province, Properties.property_address_id = Addresses.address_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Properties.property_address_id, Addresses.county_state_province FROM Properties JOIN Addresses ON Properties.property_address_id = Addresses.address_id;",SELECT DISTINCT T1.county_state_province FROM Addresses AS T1 JOIN Properties AS T2 ON T1.address_id  =  T2.property_address_id;,"1. Sequential Structure: Start with the SELECT clause to retrieve the state information (""Addresses.county_state_province"") and the property identifier (""Properties.property_address_id""). 2. Condition Structure: No specific filtering condition is required, as the question asks for all properties and their states. 3. Join Structure: Use a JOIN between the ""Properties"" table and the ""Addresses"" table based on the relationship ""Properties.property_address_id = Addresses.address_id"" to link each property with its corresponding address. 4. Aggregation Structure: No aggregation is needed since the query only retrieves the property and state information.",1.0
1360,How many photos does each property have?,NON-NESTED,real_estate_rentals,"[Property_Photos.property_id, Property_Photos.photo_seq, Property_Photos.property_id = Properties.property_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Property_Photos.property_id, COUNT(Property_Photos.photo_seq) AS photo_count FROM Property_Photos JOIN Properties ON Property_Photos.property_id = Properties.property_id GROUP BY Property_Photos.property_id;","SELECT count(*) ,  property_id FROM Property_Photos GROUP BY property_id;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""property_id"" and the count of photos for each property. Use COUNT on ""Property_Photos.photo_seq"" to count the number of photos. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between ""Property_Photos"" and ""Properties"" tables based on ""property_id"" to associate photos with their respective properties. 4. Aggregation Structure: Use COUNT to aggregate the number of photos for each property and GROUP BY ""Property_Photos.property_id"" to group the results by property.",1.0
1361,"What are all the ids of goods with an id which contains ""APP""?",EASY,bakery_1,[goods.Id],"Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Id FROM goods WHERE goods.Id LIKE '%APP%';,"SELECT id FROM goods WHERE id LIKE ""%APP%""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""goods.Id"" field, as the question asks for all IDs of goods. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for IDs that contain the substring ""APP"". 3. Join Structure: No JOIN is required since all necessary information is in the ""goods"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving IDs based on a specific condition.",1.0
1362,Give the distinct ids for goods that cost less than any Tart.,NESTED,bakery_1,"[goods.Id, goods.Price, goods.Food]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT DISTINCT goods.Id FROM goods WHERE goods.Price < (SELECT MIN(goods.Price) FROM goods WHERE goods.Food = 'Tart');,"SELECT DISTINCT id FROM goods WHERE price  <  (SELECT max(price) FROM goods WHERE food  =  ""Tart"")","1. Sequential Structure: Start with the SELECT clause to retrieve distinct IDs of goods. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter goods whose price is less than the price of any item categorized as ""Tart."" 2. Condition Structure: Use the WHERE clause with a subquery to compare the price of goods with the minimum price of items categorized as ""Tart."" 3. Join Structure: Not required, as all data is in the goods table. 4. Aggregation Structure: Use a subquery to find the minimum price of items categorized as ""Tart"" and compare it with the price of other goods.",0.0
1363,What are the ids with apple flavor?,EASY,bakery_1,"[goods.Id,goods.Flavor]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Id FROM goods WHERE goods.Flavor = 'apple';,"SELECT id FROM goods WHERE flavor  =  ""Apple""","1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the ""goods.Id"". 2. Condition Structure: Use a WHERE clause to filter for rows where the ""goods.Flavor"" is 'apple'. 3. Join Structure: No JOIN is required since all necessary information is in the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving IDs based on a specific condition.",0.0
1364,What is the minimum number of rooms in a property?,EASY,real_estate_rentals,"[Rooms.room_number, Rooms.property_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT MIN(room_count) AS min_rooms FROM ( SELECT Rooms.property_id, COUNT(Rooms.room_number) AS room_count FROM Rooms GROUP BY Rooms.property_id ) AS property_rooms;",SELECT min(room_count) FROM Properties;,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the minimum number of rooms in a property. 2. Aggregation Structure: Use the MIN function to calculate the minimum number of rooms. 3. Grouping Structure: Use GROUP BY on ""Rooms.property_id"" to calculate the number of rooms for each property. 4. Join Structure: No JOIN is required since all necessary data is within the ""Rooms"" table.",0.0
1365,What is the cheapest cookie and its flavor?,NESTED,bakery_1,"[goods.Food, goods.Flavor, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT Food, Flavor, Price FROM goods WHERE Price = (SELECT MIN(Price) FROM goods);","SELECT id ,  flavor FROM goods WHERE food  =  ""Cookie"" ORDER BY price LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the food (cookie) name, its flavor, and price. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter for the cookie with the minimum price. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the minimum price in the goods table. 3. Join Structure: Not required, as all data is available within the goods table. 4. Aggregation Structure: Use the MIN function in a subquery to find the lowest price, which is then used in the filtering condition.",0.0
1366,What are the distinct ids of customers who bought lemon flavored cake?,NON-NESTED,bakery_1,"[customers.Id,goods.Flavor,goods.Food,items.Item = goods.Id,receipts.CustomerId = customers.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT DISTINCT customers.Id FROM customers JOIN receipts ON receipts.CustomerId = customers.Id JOIN items ON items.Id = receipts.Id JOIN goods ON items.Item = goods.Id WHERE goods.Flavor = 'lemon' AND goods.Food = 'cake';,"SELECT DISTINCT T3.CustomerId FROM goods AS T1 JOIN items AS T2 ON T1.Id  =  T2.Item JOIN receipts AS T3 ON T2.Receipt  =  T3.ReceiptNumber WHERE T1.Flavor  =  ""Lemon"" AND T1.Food  =  ""Cake""","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""customers.Id"" of customers who bought lemon-flavored cake. 2. Condition Structure: Use a WHERE clause to filter for records where the ""goods.Flavor"" is 'lemon' and the ""goods.Food"" is 'cake.' 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""items"" with ""goods"" on ""items.Item = goods.Id"" to link items with their corresponding goods. Then, join ""receipts"" with ""customers"" on ""receipts.CustomerId = customers.Id"" to link receipts with customers. Finally, connect ""items"" with ""receipts"" to associate items with the customers who purchased them. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique customer IDs are returned.",0.0
1367,Find the ids of customers who have spent more than 150 dollars in total.,NON-NESTED,bakery_1,"[customers.Id,receipts.CustomerId,goods.Price,items.Item = goods.Id,items.Receipt = receipts.ReceiptNumber,receipts.CustomerId = customers.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT customers.Id FROM customers JOIN receipts ON customers.Id = receipts.CustomerId JOIN items ON receipts.ReceiptNumber = items.Receipt JOIN goods ON items.Item = goods.Id GROUP BY customers.Id HAVING SUM(goods.Price) > 150;,SELECT T3.CustomerId FROM goods AS T1 JOIN items AS T2 ON T1.id  =  T2.item JOIN receipts AS T3 ON T2.receipt  =  T3.ReceiptNumber GROUP BY T3.CustomerId HAVING sum(T1.price)  >  150,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""customers.Id"" of customers who meet the spending condition. Use SUM to calculate the total spending of each customer. 2. Condition Structure: Apply a HAVING clause to filter customers whose total spending exceeds 150 dollars. 3. Join Structure: Use multiple JOINs to connect the ""customers,"" ""receipts,"" ""items,"" and ""goods"" tables. Specifically, join ""customers.Id"" with ""receipts.CustomerId,"" ""receipts.ReceiptNumber"" with ""items.Receipt,"" and ""items.Item"" with ""goods.Id"" to link customers to their purchases and the prices of the goods they bought. 4. Aggregation Structure: Use SUM on ""goods.Price"" to calculate the total spending for each customer, and GROUP BY ""customers.Id"" to group the spending by customer.",1.0
1368,What is the most expensive cake and its flavor?,EASY,bakery_1,"[goods.Food, goods.Flavor, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Food, goods.Flavor FROM goods WHERE goods.Food LIKE '%cake%' ORDER BY goods.Price DESC LIMIT 1;","SELECT id ,  flavor FROM goods WHERE food  =  ""Cake"" ORDER BY price DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""goods.Food"" and ""goods.Flavor"" of the most expensive cake. 2. Condition Structure: Use a WHERE clause to filter for items that are cakes. 3. Aggregation Structure: Use ORDER BY in descending order on ""goods.Price"" to rank the cakes by their price. 4. Limiting Structure: Use LIMIT 1 to select the most expensive cake. 5. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table.",0.0
1369,Which customer shopped most often? How many times?,NON-NESTED,bakery_1,"[receipts.CustomerId, customers.Id, receipts.ReceiptNumber]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT customers.Id, COUNT(receipts.ReceiptNumber) AS shopping_count FROM receipts JOIN customers ON receipts.CustomerId = customers.Id GROUP BY customers.Id ORDER BY shopping_count DESC LIMIT 1;","SELECT CustomerId ,  count(*) FROM receipts GROUP BY CustomerId ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the customer name or ID and the count of their shopping occurrences. Use COUNT on ""receipts.ReceiptNumber"" to count the number of times each customer shopped. 2. Condition Structure: No specific filtering condition is required, as we are interested in all customers. 3. Join Structure: Use a JOIN between the ""receipts"" and ""customers"" tables based on ""receipts.CustomerId"" and ""customers.Id"" to associate each receipt with the corresponding customer. 4. Aggregation Structure: Use GROUP BY on ""customers.Id"" to group the data by customer. Use ORDER BY in descending order of the count to rank customers by the number of shopping occurrences. Use LIMIT 1 to get the customer who shopped the most.",1.0
1370,How many properties are there with at least 2 features?,NON-NESTED,real_estate_rentals,"[Properties.property_id, Property_Features.property_id, Property_Features.feature_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT COUNT(DISTINCT Properties.property_id) FROM Properties JOIN Property_Features ON Properties.property_id = Property_Features.property_id GROUP BY Properties.property_id HAVING COUNT(Property_Features.feature_id) >= 2;,SELECT count(*) FROM Properties GROUP BY property_id HAVING count(*)  >= 2;,"1. Sequential Structure: Start with the SELECT clause to count the number of properties that have at least 2 features. Use COUNT DISTINCT on ""Properties.property_id"" to count unique properties. 2. Condition Structure: Use a HAVING clause to filter properties that have 2 or more features. 3. Join Structure: Use a JOIN between ""Properties"" and ""Property_Features"" on ""property_id"" to associate each property with its features. 4. Aggregation Structure: Use COUNT on ""Property_Features.feature_id"" to count the number of features for each property, then filter with HAVING to select properties with at least 2 features.",1.0
1371,"Return the date stamp and property name for each property history event, sorted by date stamp.",NON-NESTED,real_estate_rentals,"[User_Property_History.datestamp, Properties.property_name, User_Property_History.property_id = Properties.property_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT User_Property_History.datestamp, Properties.property_name FROM User_Property_History JOIN Properties ON User_Property_History.property_id = Properties.property_id ORDER BY User_Property_History.datestamp ASC;","SELECT T1.datestamp ,  T2.property_name FROM User_Property_History AS T1 JOIN Properties AS T2 ON T1.property_id  =  T2.property_id ORDER BY datestamp;","1. Sequential Structure: Start with the SELECT clause to retrieve ""User_Property_History.datestamp"" and ""Properties.property_name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between ""User_Property_History"" and ""Properties"" tables based on the relationship ""User_Property_History.property_id = Properties.property_id"" to link property history events with their respective property names. 4. Aggregation Structure: No aggregation is required, but apply ORDER BY on ""User_Property_History.datestamp"" to sort the results by date stamp.",1.0
1372,What are the ids of cakes that are at least as expensive as the average Tart?,NESTED,bakery_1,"[goods.Id, goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT Id FROM goods WHERE Food = 'Cake' AND Price >= (SELECT AVG(Price) FROM goods WHERE Food = 'Tart');,"SELECT id FROM goods WHERE food  =  ""Cake"" AND price  >=  (SELECT avg(price) FROM goods WHERE food  =  ""Tart"")","1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of cakes. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter for cakes whose price is at least as expensive as the average price of Tarts. 2. Condition Structure: Use the WHERE clause to filter for rows where the food type is 'Cake' and the price is greater than or equal to the average price of Tarts. Use a subquery to calculate the average price of Tarts. 3. Join Structure: Not required, as all data is in the goods table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average price of Tarts, which is then used in the filtering condition.",1.0
1373,Which date corresponds to when a customer purchased a good costing over 15 dollars?,NON-NESTED,bakery_1,"[receipts.Date,goods.Price,items.Item = goods.Id,items.Receipt = receipts.ReceiptNumber]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT receipts.Date FROM goods JOIN items ON items.Item = goods.Id JOIN receipts ON items.Receipt = receipts.ReceiptNumber WHERE goods.Price > 15;,SELECT DISTINCT T1.date FROM receipts AS T1 JOIN items AS T2 ON T1.ReceiptNumber  =  T2.receipt JOIN goods AS T3 ON T2.item  =  T3.id WHERE T3.price  >  15,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""receipts.Date"" field, which corresponds to the date of purchase. 2. Condition Structure: Use a WHERE clause to filter for goods with a price greater than 15 dollars. 3. Join Structure: Use JOINs to connect the ""goods"" table with the ""items"" table on ""items.Item = goods.Id"" and the ""items"" table with the ""receipts"" table on ""items.Receipt = receipts.ReceiptNumber"" to link goods, items, and receipts. 4. Aggregation Structure: No aggregation is needed as the query only retrieves the date of purchase for specific goods.",1.0
1374,List the average room count of the properties with gardens.,NON-NESTED,real_estate_rentals,"[Properties.room_count,Property_Features.feature_value,Property_Features.property_id = Properties.property_id,Features.feature_id,Features.feature_name]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT AVG(Properties.room_count) FROM Properties JOIN Property_Features ON Properties.property_id = Property_Features.property_id JOIN Features ON Property_Features.feature_id = Features.feature_id WHERE Features.feature_name = 'garden' AND Property_Features.feature_value = 'yes';,SELECT avg(T3.room_count) FROM Property_Features AS T1 JOIN Features AS T2 ON T1.feature_id  =  T2.feature_id JOIN Properties AS T3 ON T1.property_id  =  T3.property_id WHERE T2.feature_name  =  'garden';,"1. Sequential Structure: Start with the SELECT clause to calculate the average room count of properties. Use the AVG function on ""Properties.room_count."" 2. Condition Structure: Use a WHERE clause to filter properties that have gardens. This requires checking the ""feature_name"" field for ""garden"" and ensuring the ""feature_value"" indicates the presence of a garden. 3. Join Structure: Use JOINs to connect the ""Properties"" table with the ""Property_Features"" table on ""property_id"" and the ""Features"" table on ""feature_id"" to link properties with their features. 4. Aggregation Structure: Use the AVG function to calculate the average room count for the filtered properties.",0.0
1375,Show the official language spoken by the most number of countries.,NON-NESTED,country_language,"[languages.name, official_languages.language_id, official_languages.country_id = countries.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT languages.name FROM official_languages JOIN languages ON official_languages.language_id = languages.language_id JOIN countries ON official_languages.country_id = countries.id GROUP BY languages.name ORDER BY COUNT(countries.id) DESC LIMIT 1;,SELECT T2.name FROM official_languages AS T1 JOIN languages AS T2 ON T1.language_id  =  T2.id GROUP BY T2.id ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the official language. Use COUNT to determine the number of countries where each language is spoken. 2. Condition Structure: No specific filtering condition is required, as we are interested in all official languages. 3. Join Structure: Use a JOIN between ""official_languages"" and ""languages"" on ""language_id"" to link each language with its name. Additionally, join ""official_languages"" with ""countries"" on ""country_id"" to associate languages with countries. 4. Aggregation Structure: Use COUNT to count the number of countries for each language. Use ORDER BY in descending order to rank languages by the number of countries, and LIMIT 1 to select the language spoken by the most countries.",0.0
1376,Give the ids for goods that have Apricot flavor and have a price lower than 5 dollars.,EASY,bakery_1,"[goods.Id,goods.Flavor,goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Id FROM goods WHERE goods.Flavor = 'Apricot' AND goods.Price < 5;,"SELECT id FROM goods WHERE flavor  =  ""Apricot"" AND price  <  5","1. Sequential Structure: Start with the SELECT clause to retrieve the ""goods.Id"" for goods that meet the specified conditions. 2. Condition Structure: Use a WHERE clause to filter goods that have the flavor ""Apricot"" and a price lower than 5 dollars. 3. Join Structure: No JOIN is required since all necessary information is in the ""goods"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving IDs based on specific conditions.",1.0
1377,Give the id and flavor of the most expensive cake.,EASY,bakery_1,"[goods.Id, goods.Flavor, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Id, goods.Flavor FROM goods ORDER BY goods.Price DESC LIMIT 1;","SELECT id ,  flavor FROM goods WHERE food  =  ""Cake"" ORDER BY price DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""goods.Id"" and ""goods.Flavor"" of the most expensive cake. 2. Condition Structure: No specific filtering condition is required, as we are looking for the cake with the highest price. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""goods"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""goods.Price"" to rank cakes by price and apply LIMIT 1 to select the most expensive cake.",1.0
1378,Compute the average laps of drivers under the age of 20.,EASY,car_racing,"[driver.Age, driver.Laps]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT AVG(driver.Laps) AS avg_laps FROM driver WHERE driver.Age < 20;,SELECT avg(Laps) FROM driver WHERE age  <  20,"1. Sequential Structure: Begin with the SELECT clause to compute the average laps of drivers. 2. Condition Structure: Use a WHERE clause to filter drivers who are under the age of 20. 3. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table. 4. Aggregation Structure: Use the AVG function to calculate the average laps for the filtered drivers.",1.0
1379,"Find the names of drivers who were in both ""James Hinchcliffe"" and ""Carl Skerlong"" pole positions before.",NESTED,car_road_race,"[driver.Driver_Name, race.Pole_Position, race.Driver_ID = driver.Driver_ID, James Hinchcliffe, Carl Skerlong]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Driver_Name FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID WHERE race.Pole_Position = 'James Hinchcliffe' INTERSECT SELECT driver.Driver_Name FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID WHERE race.Pole_Position = 'Carl Skerlong';,"SELECT T1.Driver_Name FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID WHERE Pole_Position  =  ""Carl Skerlong"" INTERSECT SELECT T1.Driver_Name FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID WHERE Pole_Position  =  ""James Hinchcliffe""","1. Sequential Structure: Start with the SELECT clause to retrieve the names of drivers. Use the FROM clause to specify the driver and race tables. Apply a WHERE clause to filter for drivers who were in pole positions for both ""James Hinchcliffe"" and ""Carl Skerlong"". 2. Condition Structure: Use the WHERE clause with a subquery to identify drivers who were in pole positions for ""James Hinchcliffe"" and another subquery for ""Carl Skerlong"". Use an INTERSECT operation to find drivers common to both conditions. 3. Join Structure: Use an INNER JOIN between the driver and race tables based on the Driver_ID to connect driver names with their pole positions. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1380,Find the average age of drivers for each make.,EASY,car_racing,"[driver.Age, driver.Make]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT driver.Make, AVG(driver.Age) AS avg_age FROM driver GROUP BY driver.Make;","SELECT avg(age) ,  Make FROM driver GROUP BY make","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the make of the driver and the average age. 2. Aggregation Structure: Use the AVG function to calculate the average age of drivers for each make. 3. Grouping Structure: Use GROUP BY on ""driver.Make"" to calculate the average age for each make. 4. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table.",1.0
1381,Give me a list of all the distinct items bought by the customer number 15.,NON-NESTED,bakery_1,"[items.Item,goods.Id,goods.Flavor,receipts.CustomerId,customers.Id,receipts.ReceiptNumber = items.Receipt,receipts.CustomerId = customers.Id,items.Item = goods.Id,customers.Id = 15]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT DISTINCT items.Item FROM receipts JOIN customers ON receipts.CustomerId = customers.Id JOIN items ON receipts.ReceiptNumber = items.Receipt JOIN goods ON items.Item = goods.Id WHERE customers.Id = 15;,SELECT DISTINCT T1.item FROM items AS T1 JOIN receipts AS T2 ON T1.receipt  =  T2.ReceiptNumber WHERE T2.CustomerId  =  15,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""items.Item"" that were bought by the customer. 2. Condition Structure: Use a WHERE clause to filter for records where ""customers.Id"" is 15. 3. Join Structure: Use JOINs to connect the ""receipts"" table with the ""customers"" table on ""receipts.CustomerId = customers.Id,"" and the ""items"" table with the ""receipts"" table on ""receipts.ReceiptNumber = items.Receipt."" Additionally, join the ""items"" table with the ""goods"" table on ""items.Item = goods.Id"" to ensure the item details are correctly linked. 4. Aggregation Structure: Use DISTINCT to ensure that only unique items are returned in the result.",1.0
1382,Show the official languages and the number of countries speaking each language.,NON-NESTED,country_language,"[languages.name, official_languages.language_id = languages.id, official_languages.country_id = countries.id, countries.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
","SELECT languages.name, COUNT(countries.id) AS num_countries FROM languages JOIN official_languages ON languages.id = official_languages.language_id JOIN countries ON official_languages.country_id = countries.id GROUP BY languages.name;","SELECT T2.name ,  COUNT(*) FROM official_languages AS T1 JOIN languages AS T2 ON T1.language_id  =  T2.id GROUP BY T2.name","1. Sequential Structure: Start with the SELECT clause to retrieve the ""languages.name"" and the count of countries speaking each language. Use COUNT to count the number of countries for each language. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""languages"" table with the ""official_languages"" table on ""languages.id = official_languages.language_id"" and the ""official_languages"" table with the ""countries"" table on ""official_languages.country_id = countries.id."" 4. Aggregation Structure: Use COUNT to count the number of countries for each language and GROUP BY ""languages.name"" to group the results by language.",1.0
1383,"What are the user ids of property owners who have property photos, and how many do each of them have?",NON-NESTED,real_estate_rentals,"[Properties.owner_user_id,Property_Photos.property_id,Properties.property_id = Property_Photos.property_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Properties.owner_user_id, COUNT(Property_Photos.property_id) AS photo_count FROM Properties JOIN Property_Photos ON Properties.property_id = Property_Photos.property_id GROUP BY Properties.owner_user_id;","SELECT T1.owner_user_id ,  count(*) FROM Properties AS T1 JOIN Property_Photos AS T2 ON T1.property_id  =  T2.property_id GROUP BY T1.owner_user_id;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Properties.owner_user_id"" and the count of photos for each owner. Use COUNT to count the number of photos for each owner. 2. Condition Structure: No specific filtering condition is required, as we are interested in all property owners who have property photos. 3. Join Structure: Use a JOIN between the ""Properties"" table and the ""Property_Photos"" table based on the ""property_id"" field to link properties with their photos. 4. Aggregation Structure: Use COUNT to count the number of photos for each owner and GROUP BY ""Properties.owner_user_id"" to group the results by each property owner.",1.0
1384,What is the average price of the bikes made of material 'Carbon CC'?,EASY,bike_racing,"[bike.price, bike.material, 'Carbon CC']","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
",SELECT AVG(bike.price) AS avg_price FROM bike WHERE bike.material = 'Carbon CC';,SELECT avg(price) FROM bike WHERE material  =  'Carbon CC',"1. Sequential Structure: Start with the SELECT clause to calculate the average price of bikes. 2. Condition Structure: Use a WHERE clause to filter bikes made of the material 'Carbon CC'. 3. Join Structure: No JOIN is required since all necessary information is in the ""bike"" table. 4. Aggregation Structure: Use the AVG function to calculate the average price of the filtered bikes.",1.0
1385,What is the official language that is most common?,NON-NESTED,country_language,"[languages.name, official_languages.language_id = languages.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT languages.name FROM official_languages JOIN languages ON official_languages.language_id = languages.id GROUP BY languages.name ORDER BY COUNT(official_languages.language_id) DESC LIMIT 1;,SELECT T2.name FROM official_languages AS T1 JOIN languages AS T2 ON T1.language_id  =  T2.id GROUP BY T2.id ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the official language. Use COUNT to determine the frequency of each language and ORDER BY to rank them by frequency in descending order. Use LIMIT 1 to get the most common language. 2. Condition Structure: No specific filtering condition is required since we are looking for the most common official language across all records. 3. Join Structure: Use a JOIN between the ""official_languages"" table and the ""languages"" table based on the relationship ""official_languages.language_id = languages.id"" to link each official language with its name. 4. Aggregation Structure: Use COUNT to count the occurrences of each language in the ""official_languages"" table, then use ORDER BY to sort by the count in descending order and LIMIT 1 to select the most common language.",1.0
1386,Give the flavors of Cakes that are not available for Tart.,NESTED,bakery_1,"[goods.Flavor, goods.Food, goods.Id = items.Item]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT Flavor FROM goods WHERE Food = 'Cake' AND Id NOT IN (SELECT Id FROM goods WHERE Food = 'Tart');,"SELECT DISTINCT flavor FROM goods WHERE food  =  ""Cake"" EXCEPT SELECT DISTINCT flavor FROM goods WHERE food  =  ""Tart""","1. Sequential Structure: Start with the SELECT clause to retrieve the flavors of cakes. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter for items that are cakes but not available for tarts. 2. Condition Structure: Use the WHERE clause to filter for rows where the food type is 'Cake' and exclude rows where the food type is 'Tart' using a subquery. 3. Join Structure: Not required, as all data is available within the goods table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1387,How many different levels of heat are there for the cyclists?,EASY,bike_racing,[cyclist.heat],"Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
",SELECT COUNT(DISTINCT cyclist.heat) FROM cyclist;,SELECT count(DISTINCT heat) FROM cyclist,"1. Sequential Structure: Begin with the SELECT clause to count the distinct levels of heat for cyclists. 2. Condition Structure: No specific filtering condition is required as we are interested in all distinct heat levels. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""cyclist"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique heat levels.",1.0
1388,"What are the names of the countries, ordered descending by overall score?",EASY,country_language,"[countries.name, countries.overall_score]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
","SELECT countries.name, countries.overall_score FROM countries ORDER BY countries.overall_score DESC;",SELECT name FROM countries ORDER BY overall_score DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the country names and their overall scores. 2. Condition Structure: No specific filtering condition is required as we want all countries and their scores. 3. Join Structure: No JOIN is required since all necessary information is available in the ""countries"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data. 5. Ordering Structure: Use ORDER BY in descending order on ""countries.overall_score"" to sort the results by overall score.",1.0
1389,What are the names of the three official languages spoken in the most countries?,NON-NESTED,country_language,"[languages.name, official_languages.language_id, official_languages.country_id, official_languages.language_id = languages.id, official_languages.country_id = countries.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
","SELECT languages.name, COUNT(official_languages.country_id) AS country_count FROM official_languages JOIN languages ON official_languages.language_id = languages.id JOIN countries ON official_languages.country_id = countries.id GROUP BY languages.name ORDER BY country_count DESC LIMIT 3;",SELECT T2.name FROM official_languages AS T1 JOIN languages AS T2 ON T1.language_id  =  T2.id GROUP BY T2.id ORDER BY COUNT(*) DESC LIMIT 3,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the languages. Use COUNT to count the number of countries where each language is official. Use ORDER BY in descending order to rank languages by the number of countries they are spoken in. Use LIMIT 3 to get the top three languages. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all official languages. 3. Join Structure: Use JOINs to connect ""official_languages"" with ""languages"" on ""official_languages.language_id = languages.id"" and ""official_languages"" with ""countries"" on ""official_languages.country_id = countries.id"" to link languages with the countries where they are official. 4. Aggregation Structure: Use COUNT to aggregate the number of countries for each language, then GROUP BY ""languages.name"" to group results by language.",0.0
1390,What are the ids of Cookies whose price is lower than any Croissant?,NESTED,bakery_1,"[goods.Id, goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT Id FROM goods WHERE Food = 'Cookie' AND Price < ANY (SELECT Price FROM goods WHERE Food = 'Croissant');,"SELECT id FROM goods WHERE food  =  ""Cookie"" AND price  <  (SELECT min(price) FROM goods WHERE food  =  'Croissant')","1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of goods that are Cookies. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter for goods that are Cookies and have a price lower than any Croissant. 2. Condition Structure: Use the WHERE clause to filter for goods where the Food is 'Cookie' and the price is less than any price of goods where the Food is 'Croissant'. Use a subquery to retrieve the prices of Croissants. 3. Join Structure: Not required, as all data is in the goods table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",0.0
1391,Count the number of goods for each food type.,EASY,bakery_1,"[goods.Food, goods.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Food, COUNT(goods.Id) AS goods_count FROM goods GROUP BY goods.Food;","SELECT count(*) ,  food FROM goods GROUP BY food","1. Sequential Structure: Begin with the SELECT clause to specify the food type and the count of goods for each food type. 2. Aggregation Structure: Use COUNT to calculate the number of goods for each food type. 3. Grouping Structure: Use GROUP BY on ""goods.Food"" to group the results by each food type. 4. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table.",1.0
1392,What are the ids and names of racing bikes that are purchased by at least 4 cyclists?,NON-NESTED,bike_racing,"[bike.id, bike.product_name, cyclists_own_bikes.bike_id, cyclists_own_bikes.cyclist_id = cyclist.id]","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
","SELECT bike.id, bike.product_name FROM bike JOIN cyclists_own_bikes ON bike.id = cyclists_own_bikes.bike_id WHERE bike.product_name LIKE '%racing%' GROUP BY bike.id, bike.product_name HAVING COUNT(cyclists_own_bikes.cyclist_id) >= 4;","SELECT T1.id ,  T1.product_name FROM bike AS T1 JOIN cyclists_own_bikes AS T2 ON T1.id  =  T2.bike_id GROUP BY T1.id HAVING count(*)  >=  4","1. Sequential Structure: Start with the SELECT clause to retrieve the ""bike.id"" and ""bike.product_name"" for racing bikes. Use a GROUP BY clause to group by ""bike.id"" and ""bike.product_name"" to count the number of cyclists who purchased each bike. Apply a HAVING clause to filter for bikes purchased by at least 4 cyclists. 2. Condition Structure: Use a WHERE clause to filter for bikes that are racing bikes based on the ""bike.product_name"" containing the term ""racing."" 3. Join Structure: Use a JOIN between the ""bike"" table and the ""cyclists_own_bikes"" table on ""bike.id = cyclists_own_bikes.bike_id"" to associate bikes with their owners. 4. Aggregation Structure: Use COUNT on ""cyclists_own_bikes.cyclist_id"" to count the number of cyclists who purchased each bike, and filter with HAVING to select bikes purchased by at least 4 cyclists.",0.0
1393,Find all receipts in which either apple flavor pie was bought or customer id 12 shopped.,NESTED,bakery_1,"[goods.Flavor, goods.Food, items.Item = goods.Id, receipts.ReceiptNumber, receipts.CustomerId, customers.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT receipts.ReceiptNumber FROM receipts JOIN items ON receipts.ReceiptNumber = items.ReceiptNumber JOIN goods ON items.Item = goods.Id WHERE (goods.Flavor = 'apple' AND goods.Food = 'pie') OR receipts.CustomerId = 12;,"SELECT T1.receipt FROM items AS T1 JOIN goods AS T2 ON T1.item  =  T2.id WHERE T2.flavor  =  ""Apple"" AND T2.food  =  ""Pie"" UNION SELECT ReceiptNumber FROM receipts WHERE CustomerId  =  12","1. Sequential Structure: Start with the SELECT clause to retrieve all receipt numbers. Use the FROM clause to specify the receipts table. Join it with the items and goods tables to identify receipts where an apple flavor pie was bought. Additionally, include a condition to filter receipts where the customer ID is 12. 2. Condition Structure: Use the WHERE clause to filter for receipts where either the flavor is 'apple' and the food is 'pie', or the customer ID is 12. 3. Join Structure: Use JOINs between the receipts, items, and goods tables to connect receipt numbers with the goods purchased. Also, use the relationship between receipts and customers to filter by customer ID. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1394,Which property had the lowest price requested by the vendor? List the id and the price.,EASY,real_estate_rentals,"[Properties.property_id, Properties.vendor_requested_price]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Properties.property_id, Properties.vendor_requested_price FROM Properties ORDER BY Properties.vendor_requested_price ASC LIMIT 1;","SELECT property_id ,  vendor_requested_price FROM Properties ORDER BY vendor_requested_price LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Properties.property_id"" and ""Properties.vendor_requested_price"" of the property with the lowest price requested by the vendor. 2. Condition Structure: No specific filtering condition is required since we are looking for the property with the minimum requested price. 3. Join Structure: No JOIN is necessary as all the required data is available in the ""Properties"" table. 4. Aggregation Structure: Use ORDER BY in ascending order on ""Properties.vendor_requested_price"" to rank properties by price and apply LIMIT 1 to select the property with the lowest requested price.",1.0
1395,"Return the ids of users who have performed two or more searches, as well as their search sequence.",EASY,real_estate_rentals,"[User_Searches.user_id, User_Searches.search_seq]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT User_Searches.user_id, User_Searches.search_seq FROM User_Searches GROUP BY User_Searches.user_id HAVING COUNT(User_Searches.search_seq) >= 2;","SELECT search_seq ,  user_id FROM User_Searches GROUP BY user_id HAVING count(*) >= 2;","1. Sequential Structure: Start with the SELECT clause to retrieve the user IDs and their search sequences. 2. Aggregation Structure: Use COUNT to count the number of searches performed by each user. 3. Grouping Structure: Use GROUP BY on ""User_Searches.user_id"" to group searches by each user. 4. Condition Structure: Apply the HAVING clause to filter for users who have performed two or more searches. 5. Join Structure: No JOIN is required since all necessary data is within the ""User_Searches"" table.",1.0
1396,How many different official languages are there?,NON-NESTED,country_language,"[languages.id, official_languages.language_id = languages.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT COUNT(DISTINCT languages.id) FROM official_languages JOIN languages ON official_languages.language_id = languages.id;,SELECT count(DISTINCT language_id) FROM official_languages,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""languages.id"" since we are interested in the number of different official languages. 2. Condition Structure: No specific filtering condition is needed as we are counting all official languages. 3. Join Structure: Use a JOIN between the ""official_languages"" table and the ""languages"" table based on ""official_languages.language_id = languages.id"" to link official languages with their corresponding language details. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique ""languages.id"" values.",1.0
1397,List the types of engines that are used by at least two drivers.,NON-NESTED,car_road_race,"[driver.Engine, driver.Driver_ID, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Engine FROM driver GROUP BY driver.Engine HAVING COUNT(driver.Driver_ID) >= 2;,SELECT Engine FROM driver GROUP BY Engine HAVING COUNT(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct types of engines used by drivers. Use GROUP BY to group the results by engine type. 2. Condition Structure: Apply a HAVING clause to filter for engine types that are used by at least two drivers. 3. Join Structure: No JOIN is necessary since the required information is available within the ""driver"" table. 4. Aggregation Structure: Use COUNT on ""driver.Driver_ID"" to count the number of drivers using each engine type, and filter with HAVING to select engine types used by at least two drivers.",1.0
1398,Show the official languages sorted in descending order by the average overall scores among countries speaking them.,NON-NESTED,country_language,"[languages.name, countries.overall_score, official_languages.language_id = languages.id, official_languages.country_id = countries.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
","SELECT languages.name, AVG(countries.overall_score) AS avg_score FROM official_languages JOIN languages ON official_languages.language_id = languages.id JOIN countries ON official_languages.country_id = countries.id GROUP BY languages.name ORDER BY avg_score DESC;",SELECT T3.name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id GROUP BY T3.id ORDER BY avg(T1.overall_score) DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""languages.name"" and the average ""countries.overall_score."" Use an aggregate function (AVG) to calculate the average overall score for each language. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""official_languages"" table with ""languages"" on ""official_languages.language_id = languages.id"" and with ""countries"" on ""official_languages.country_id = countries.id"" to link languages with their respective countries and scores. 4. Aggregation Structure: Use GROUP BY on ""languages.name"" to calculate the average overall score for each language. Apply ORDER BY in descending order on the average score to sort the results as specified.",1.0
1399,What are the countries and cities for each address?,EASY,real_estate_rentals,"[Addresses.country, Addresses.town_city]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Addresses.country, Addresses.town_city FROM Addresses;","SELECT country ,  town_city FROM Addresses;","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Addresses.country"" and ""Addresses.town_city"". 2. Condition Structure: No specific filtering condition is required as the query asks for all countries and cities for each address. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Addresses"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the country and city for each address.",1.0
1400,What search strings were entered by users who do not own any properties?,NESTED,real_estate_rentals,"[User_Searches.search_string, Users.user_id, Properties.owner_user_id = Users.user_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT User_Searches.search_string FROM User_Searches JOIN Users ON User_Searches.user_id = Users.user_id WHERE Users.user_id NOT IN (SELECT owner_user_id FROM Properties);,SELECT search_string FROM User_Searches EXCEPT SELECT T1.search_string FROM User_Searches AS T1 JOIN Properties AS T2 ON T1.user_id  =  T2.owner_user_id;,"1. Sequential Structure: Start with the SELECT clause to retrieve the search strings from the User_Searches table. Use the FROM clause to specify the User_Searches table and JOIN it with the Users table to link search strings to users. Apply a WHERE clause to filter users who do not own any properties. 2. Condition Structure: Use the WHERE clause with a subquery to exclude users whose user_id appears as an owner_user_id in the Properties table, indicating they own properties. 3. Join Structure: Use an INNER JOIN between the User_Searches and Users tables based on user_id to connect search strings with users. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1401,"What is the receipt number with the latest date, and what is that date?",EASY,bakery_1,"[receipts.ReceiptNumber, receipts.Date]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT receipts.ReceiptNumber, receipts.Date FROM receipts ORDER BY receipts.Date DESC LIMIT 1;","SELECT ReceiptNumber ,  date FROM receipts WHERE date  =  (SELECT date FROM receipts ORDER BY date DESC LIMIT 1)","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the receipt number and the date. 2. Condition Structure: No specific filtering condition is required, as we are looking for the latest date. 3. Aggregation Structure: Use ORDER BY on the ""receipts.Date"" field in descending order to sort the receipts by date, with the latest date appearing first. 4. Limiting Structure: Use LIMIT 1 to retrieve only the receipt with the latest date. 5. Join Structure: No JOIN is required since all necessary data is within the ""receipts"" table.",0.0
1402,What are the names of distinct racing bikes that are purchased by the cyclists with better results than '4:21.558' ?,NESTED,bike_racing,"[cyclist.name,cyclist.result,bike.product_name,cyclists_own_bikes.cyclist_id = cyclist.id,cyclists_own_bikes.bike_id = bike.id,4:21.558]","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
",SELECT DISTINCT bike.product_name FROM bike JOIN cyclists_own_bikes ON cyclists_own_bikes.bike_id = bike.id JOIN cyclist ON cyclists_own_bikes.cyclist_id = cyclist.id WHERE cyclist.result < '4:21.558';,SELECT DISTINCT T3.product_name FROM cyclist AS T1 JOIN cyclists_own_bikes AS T2 ON T1.id  =  T2.cyclist_id JOIN bike AS T3 ON T2.bike_id  =  T3.id WHERE T1.result  <  '4:21.558',"1. Sequential Structure: Start with the SELECT clause to retrieve distinct product names of racing bikes. Use the FROM clause to specify the bike table and JOIN it with the cyclists_own_bikes table to link bikes with cyclists. Further, JOIN the cyclist table to access their results. Apply a WHERE clause to filter cyclists with results better than '4:21.558'. 2. Condition Structure: Use the WHERE clause to filter for cyclists whose result is better (numerically less) than '4:21.558'. 3. Join Structure: Use INNER JOINs between the cyclist, cyclists_own_bikes, and bike tables based on cyclist_id and bike_id to connect cyclists with their owned bikes and the bike details. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1403,How many photos does each owner has of his or her properties? List user id and number of photos.,NON-NESTED,real_estate_rentals,"[Users.user_id,Property_Photos.property_id,Properties.owner_user_id = Users.user_id,Property_Photos.property_id = Properties.property_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Users.user_id, COUNT(Property_Photos.property_id) AS number_of_photos FROM Users JOIN Properties ON Users.user_id = Properties.owner_user_id JOIN Property_Photos ON Properties.property_id = Property_Photos.property_id GROUP BY Users.user_id;","SELECT T1.owner_user_id ,  count(*) FROM Properties AS T1 JOIN Property_Photos AS T2 ON T1.property_id  =  T2.property_id GROUP BY T1.owner_user_id;","1. Sequential Structure: Start with the SELECT clause to retrieve ""Users.user_id"" and the count of photos for each user. Use COUNT on ""Property_Photos.property_id"" to count the number of photos. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect ""Users"" with ""Properties"" on ""Users.user_id = Properties.owner_user_id"" and ""Properties"" with ""Property_Photos"" on ""Properties.property_id = Property_Photos.property_id"" to link users with their property photos. 4. Aggregation Structure: Use COUNT to aggregate the number of photos for each user and GROUP BY ""Users.user_id"" to group the results by user.",1.0
1404,"What are the ids of users who have searched at least twice, and what did they search?",EASY,real_estate_rentals,"[User_Searches.user_id, User_Searches.search_seq, User_Searches.search_string]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT User_Searches.user_id, User_Searches.search_string FROM User_Searches GROUP BY User_Searches.user_id, User_Searches.search_string HAVING COUNT(User_Searches.search_seq) >= 2;","SELECT search_seq ,  user_id FROM User_Searches GROUP BY user_id HAVING count(*) >= 2;","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the user IDs and their search strings. 2. Aggregation Structure: Use COUNT to determine the number of searches performed by each user. 3. Grouping Structure: Use GROUP BY on ""User_Searches.user_id"" to aggregate the results by each user. 4. Condition Structure: Apply the HAVING clause to filter for users who have searched at least twice, by setting the count to be greater than or equal to 2. 5. Join Structure: No JOIN is required since all necessary data is within the ""User_Searches"" table.",0.0
1405,"List the names of drivers whose constructor is not ""Bugatti"".",EASY,car_road_race,"[driver.Driver_Name, driver.Constructor]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Driver_Name FROM driver WHERE driver.Constructor != 'Bugatti';,"SELECT Driver_Name FROM driver WHERE CONSTRUCTOR != ""Bugatti""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Driver_Name"" of drivers whose constructor is not ""Bugatti"". 2. Condition Structure: Use a WHERE clause to filter out drivers whose ""driver.Constructor"" is ""Bugatti"". 3. Join Structure: No JOIN is required since all necessary information is in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving driver names based on a specific condition.",1.0
1406,"What are the date stamps and property names for each item of property history, ordered by date stamp?",NON-NESTED,real_estate_rentals,"[User_Property_History.datestamp, Properties.property_name, User_Property_History.property_id = Properties.property_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT User_Property_History.datestamp, Properties.property_name FROM User_Property_History JOIN Properties ON User_Property_History.property_id = Properties.property_id ORDER BY User_Property_History.datestamp ASC;","SELECT T1.datestamp ,  T2.property_name FROM User_Property_History AS T1 JOIN Properties AS T2 ON T1.property_id  =  T2.property_id ORDER BY datestamp;","1. Sequential Structure: Start with the SELECT clause to retrieve ""User_Property_History.datestamp"" and ""Properties.property_name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between ""User_Property_History"" and ""Properties"" tables based on the relationship ""User_Property_History.property_id = Properties.property_id"" to link property history with property names. 4. Aggregation Structure: No aggregation is required, but apply ORDER BY on ""User_Property_History.datestamp"" to order the results by date stamp.",1.0
1407,Find all the receipt numbers in which customer with last name LOGAN purchased Croissant.,NON-NESTED,bakery_1,"[receipts.ReceiptNumber,customers.LastName,goods.Food,items.Item = goods.Id,receipts.CustomerId = customers.Id,items.Receipt = receipts.ReceiptNumber,LOGAN,Croissant]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT receipts.ReceiptNumber FROM receipts JOIN customers ON receipts.CustomerId = customers.Id JOIN items ON items.Receipt = receipts.ReceiptNumber JOIN goods ON items.Item = goods.Id WHERE customers.LastName = 'LOGAN' AND goods.Food = 'Croissant';,"SELECT T1.ReceiptNumber FROM receipts AS T1 JOIN items AS T2 ON T1.ReceiptNumber  =  T2.receipt JOIN goods AS T3 ON T2.item  =  T3.id JOIN customers AS T4 ON T4.Id  =  T1.CustomerId WHERE T3.food  =  ""Croissant"" AND T4.LastName  =  'LOGAN'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""receipts.ReceiptNumber."" 2. Condition Structure: Use a WHERE clause to filter for records where the customer's last name is ""LOGAN"" and the purchased food item is ""Croissant."" 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""receipts"" with ""customers"" on ""receipts.CustomerId = customers.Id"" to link receipts with customer information. Then, join ""items"" with ""receipts"" on ""items.Receipt = receipts.ReceiptNumber"" to link items with their respective receipts. Finally, join ""goods"" with ""items"" on ""items.Item = goods.Id"" to link items with their corresponding food details. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific receipt numbers.",1.0
1408,What is the id and flavor of the cheapest cookie?,NESTED,bakery_1,"[goods.Id, goods.Flavor, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT Id, Flavor FROM goods WHERE Price = (SELECT MIN(Price) FROM goods);","SELECT id ,  flavor FROM goods WHERE food  =  ""Cookie"" ORDER BY price LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the id and flavor of the cookie. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter for the cookie with the minimum price. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the cookie with the minimum price by comparing the price to the result of a subquery that calculates the minimum price. 3. Join Structure: Not required, as all data is in the goods table. 4. Aggregation Structure: Use the MIN function in a subquery to find the minimum price, which is then used in the filtering condition.",1.0
1409,"What are the ids, flavors, and food types of goods, ordered by price?",EASY,bakery_1,"[goods.Id, goods.Flavor, goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Id, goods.Flavor, goods.Food, goods.Price FROM goods ORDER BY goods.Price;","SELECT id ,  flavor ,  food FROM goods ORDER BY price","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""goods.Id"", ""goods.Flavor"", ""goods.Food"", and ""goods.Price"". 2. Condition Structure: No specific filtering condition is required as the query asks for all goods. 3. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 4. Ordering Structure: Use ORDER BY on ""goods.Price"" to sort the results by price. 5. Aggregation Structure: No aggregation is needed as the query does not involve any summary or aggregate functions.",1.0
1410,When was the time of the latest search by a user?,EASY,real_estate_rentals,[User_Searches.search_datetime],"Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT MAX(User_Searches.search_datetime) AS latest_search_time FROM User_Searches;,SELECT max(search_datetime) FROM User_Searches;,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the latest search time. 2. Aggregation Structure: Use the MAX function to find the latest search time from the ""User_Searches.search_datetime"" field. 3. Join Structure: No JOIN is required since all necessary data is within the ""User_Searches"" table. 4. Condition Structure: No specific filtering condition is needed as we are looking for the maximum value in the ""search_datetime"" field.",1.0
1411,"What are the minimum and maximum prices of food goods, ordered by food?",EASY,bakery_1,"[goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Food, MIN(goods.Price) AS min_price, MAX(goods.Price) AS max_price FROM goods GROUP BY goods.Food ORDER BY goods.Food;","SELECT min(price) ,  max(price) ,  food FROM goods GROUP BY food ORDER BY food","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the food name and the minimum and maximum prices. 2. Aggregation Structure: Use MIN and MAX functions to calculate the minimum and maximum prices for each food item. 3. Grouping Structure: Use GROUP BY on ""goods.Food"" to calculate these aggregate values for each food item. 4. Ordering Structure: Use ORDER BY on ""goods.Food"" to sort the results by food name. 5. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table.",1.0
1412,Count the number of property photos each property has by id.,EASY,real_estate_rentals,"[Property_Photos.property_id, COUNT(Property_Photos.photo_seq]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Property_Photos.property_id, COUNT(Property_Photos.photo_seq) AS photo_count FROM Property_Photos GROUP BY Property_Photos.property_id;","SELECT count(*) ,  property_id FROM Property_Photos GROUP BY property_id;","1. Sequential Structure: Begin with the SELECT clause to specify the property ID and the count of photos for each property. 2. Aggregation Structure: Use COUNT to calculate the number of photos for each property. 3. Grouping Structure: Use GROUP BY on ""Property_Photos.property_id"" to count the photos for each property. 4. Join Structure: No JOIN is required since all necessary data is within the ""Property_Photos"" table.",1.0
1413,What are the customer ids of customers who have at least 15 receipts?,NON-NESTED,bakery_1,"[receipts.CustomerId,receipts.ReceiptNumber,customers.Id = receipts.CustomerId]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT receipts.CustomerId FROM receipts GROUP BY receipts.CustomerId HAVING COUNT(receipts.ReceiptNumber) >= 15;,SELECT CustomerId FROM receipts GROUP BY CustomerId HAVING count(*)  >=  15,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""receipts.CustomerId"" of customers who meet the condition. Use GROUP BY to group receipts by ""receipts.CustomerId."" 2. Condition Structure: Use a HAVING clause to filter for customers who have at least 15 receipts. This is achieved by counting the number of ""receipts.ReceiptNumber"" for each customer. 3. Join Structure: No JOIN is required since the necessary data is available in the ""receipts"" table, and the relationship to ""customers"" is not directly needed for this query. 4. Aggregation Structure: Use COUNT on ""receipts.ReceiptNumber"" to count the number of receipts for each customer, and apply the HAVING clause to filter for counts greater than or equal to 15.",1.0
1414,Which teams won more than 1 race?,EASY,car_road_race,"[race.Winning_team, race.Race_Name]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT race.Winning_team FROM race GROUP BY race.Winning_team HAVING COUNT(race.Race_Name) > 1;,SELECT Winning_team FROM race GROUP BY Winning_team HAVING count(*)  >  1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""race.Winning_team"". 2. Aggregation Structure: Use COUNT to determine the number of races won by each team. 3. Grouping Structure: Use GROUP BY on ""race.Winning_team"" to aggregate the results by each team. 4. Condition Structure: Apply the HAVING clause to filter for teams that have won more than 1 race, by setting the count to be greater than 1. 5. Join Structure: No JOIN is required since we are only interested in the ""race"" table.",1.0
1415,What are all the distinct items bought by customer 15?,NON-NESTED,bakery_1,"[customers.Id,receipts.CustomerId,receipts.ReceiptNumber,items.Receipt,items.Item,goods.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT DISTINCT items.Item FROM customers JOIN receipts ON customers.Id = receipts.CustomerId JOIN items ON receipts.ReceiptNumber = items.Receipt WHERE receipts.CustomerId = 15;,SELECT DISTINCT T1.item FROM items AS T1 JOIN receipts AS T2 ON T1.receipt  =  T2.ReceiptNumber WHERE T2.CustomerId  =  15,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct items bought by the customer. Use DISTINCT on the ""items.Item"" field to ensure unique results. 2. Condition Structure: Use a WHERE clause to filter for records where the ""receipts.CustomerId"" is 15. 3. Join Structure: Use JOINs to connect the ""customers"" table with the ""receipts"" table on ""customers.Id = receipts.CustomerId,"" and then connect the ""receipts"" table with the ""items"" table on ""receipts.ReceiptNumber = items.Receipt"" to link customers to their purchased items. 4. Aggregation Structure: No aggregation is needed since we are only retrieving distinct items.",1.0
1416,What are the names of countries that do not have an official language?,NESTED,country_language,"[countries.name,official_languages.country_id = countries.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT countries.name FROM countries WHERE countries.id NOT IN (SELECT country_id FROM official_languages);,SELECT name FROM countries WHERE id NOT IN (SELECT country_id FROM official_languages),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries. Use the FROM clause to specify the countries table. Apply a WHERE clause to filter countries that do not have an official language by ensuring their IDs are not present in the official_languages table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude countries whose IDs appear in the official_languages table, meaning they have official languages. 3. Join Structure: Not required, as we only need to filter based on the absence of matching country IDs in the official_languages table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1417,Return a list of the id and flavor for Cakes ordered by flavor.,NON-NESTED,bakery_1,"[goods.Id, goods.Flavor, goods.Food, items.Item = goods.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Id, goods.Flavor FROM goods WHERE goods.Food = 'Cake' ORDER BY goods.Flavor ASC;","SELECT id ,  flavor FROM goods WHERE food  =  ""Cake"" ORDER BY flavor","1. Sequential Structure: Start with the SELECT clause to retrieve the ""goods.Id"" and ""goods.Flavor"" fields. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: No JOIN is required as the relevant fields (""Id"" and ""Flavor"") are both in the ""goods"" table. 4. Aggregation Structure: Use ORDER BY to sort the results by ""goods.Flavor"" in ascending order.",1.0
1418,Which item was bought the fewest times?,NON-NESTED,bakery_1,"[items.Item, items.Receipt, goods.Id = items.Item]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT items.Item, COUNT(items.Receipt) AS purchase_count FROM goods JOIN items ON goods.Id = items.Item GROUP BY items.Item ORDER BY purchase_count ASC LIMIT 1;",SELECT item FROM items GROUP BY item ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""items.Item"" and the count of times it was bought. Use COUNT to calculate the number of times each item appears in the ""items.Receipt"" field. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all items. 3. Join Structure: Use a JOIN between the ""goods"" and ""items"" tables based on ""goods.Id = items.Item"" to link each item with its corresponding receipt data. 4. Aggregation Structure: Use GROUP BY on ""items.Item"" to group the data by each item. Use ORDER BY in ascending order on the count of purchases and LIMIT 1 to find the item bought the fewest times.",1.0
1419,Return the age category for the user who made the earliest search.,NON-NESTED,real_estate_rentals,"[Users.age_category_code, User_Searches.user_id, User_Searches.search_datetime, Users.user_id = User_Searches.user_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Users.age_category_code FROM Users JOIN User_Searches ON Users.user_id = User_Searches.user_id WHERE User_Searches.search_datetime = (SELECT MIN(User_Searches.search_datetime) FROM User_Searches);,SELECT T1.age_category_code FROM Users AS T1 JOIN User_Searches AS T2 ON T1.user_id  =  T2.user_id ORDER BY T2.search_datetime LIMIT 1;,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Users.age_category_code"" for the user who made the earliest search. Use MIN on ""User_Searches.search_datetime"" to find the earliest search. 2. Condition Structure: Use a WHERE clause to filter the user associated with the earliest search. 3. Join Structure: Use a JOIN between the ""Users"" and ""User_Searches"" tables based on ""Users.user_id = User_Searches.user_id"" to link users with their search records. 4. Aggregation Structure: Use MIN to find the earliest search datetime and filter the corresponding user.",1.0
1420,List the search content of the users who do not own a single property.,NESTED,real_estate_rentals,"[User_Searches.search_string,Users.user_id,Properties.owner_user_id = Users.user_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT User_Searches.search_string FROM User_Searches WHERE User_Searches.user_id NOT IN (SELECT owner_user_id FROM Properties);,SELECT search_string FROM User_Searches EXCEPT SELECT T1.search_string FROM User_Searches AS T1 JOIN Properties AS T2 ON T1.user_id  =  T2.owner_user_id;,"1. Sequential Structure: Start with the SELECT clause to retrieve the search content (search_string) from the User_Searches table. Use the FROM clause to specify the User_Searches table. Apply a WHERE clause to filter users who do not own any property. 2. Condition Structure: Use the WHERE clause with a subquery to filter out users whose user_id appears as an owner_user_id in the Properties table, ensuring we only include users who do not own any property. 3. Join Structure: Not required, as the filtering is based on the absence of matching user_id entries in the Properties table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1421,Return the lowest and highest prices of goods grouped and ordered by food type.,EASY,bakery_1,"[goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Food, MIN(goods.Price) AS lowest_price, MAX(goods.Price) AS highest_price FROM goods GROUP BY goods.Food ORDER BY goods.Food;","SELECT min(price) ,  max(price) ,  food FROM goods GROUP BY food ORDER BY food","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the food type and the lowest and highest prices. 2. Aggregation Structure: Use MIN and MAX functions to calculate the lowest and highest prices for each food type. 3. Grouping Structure: Use GROUP BY on ""goods.Food"" to calculate these aggregate values for each food type. 4. Ordering Structure: Use ORDER BY on ""goods.Food"" to sort the results by food type. 5. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table.",1.0
1422,On which day did the bakery sell more than 100 dollars in total.,NON-NESTED,bakery_1,"[receipts.Date,items.Receipt,items.Item = goods.Id,goods.Price,items.Receipt = receipts.ReceiptNumber]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT receipts.Date FROM receipts JOIN items ON items.Receipt = receipts.ReceiptNumber JOIN goods ON items.Item = goods.Id GROUP BY receipts.Date HAVING SUM(goods.Price) > 100;,SELECT T3.date FROM goods AS T1 JOIN items AS T2 ON T1.id  =  T2.item JOIN receipts AS T3 ON T2.receipt  =  T3.ReceiptNumber GROUP BY T3.date HAVING sum(T1.price)  >  100,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""receipts.Date"" field, as the question asks for the day. Use a GROUP BY clause to group sales by date. 2. Condition Structure: Use a HAVING clause to filter for dates where the total sales exceeded 100 dollars. 3. Join Structure: Use JOINs to connect the ""receipts"" table with the ""items"" table on ""items.Receipt = receipts.ReceiptNumber"" and the ""items"" table with the ""goods"" table on ""items.Item = goods.Id"" to link receipts with their corresponding items and prices. 4. Aggregation Structure: Use SUM on ""goods.Price"" to calculate the total sales for each day, then filter with HAVING to select days where the total exceeds 100 dollars.",1.0
1423,Find the login names of all senior citizen users ordered by their first names.,NON-NESTED,real_estate_rentals,"[Users.login_name, Users.first_name, Users.age_category_code, Ref_Age_Categories.age_category_code, Ref_Age_Categories.age_category_description, Users.age_category_code = Ref_Age_Categories.age_category_code, senior citizen]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Users.login_name FROM Users JOIN Ref_Age_Categories ON Users.age_category_code = Ref_Age_Categories.age_category_code WHERE Ref_Age_Categories.age_category_description = 'senior citizen' ORDER BY Users.first_name ASC;,SELECT login_name FROM Users WHERE user_category_code  =  'Senior Citizen' ORDER BY first_name,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Users.login_name"" and order the results by ""Users.first_name."" 2. Condition Structure: Use a WHERE clause to filter for users whose ""age_category_code"" corresponds to the ""senior citizen"" age category. This requires joining with the ""Ref_Age_Categories"" table to match the ""age_category_description"" with ""senior citizen."" 3. Join Structure: Use an INNER JOIN between the ""Users"" table and the ""Ref_Age_Categories"" table on the ""age_category_code"" field to link users with their respective age categories. 4. Aggregation Structure: No aggregation is needed, but apply ORDER BY to sort the results alphabetically by ""Users.first_name.""",0.0
1424,Count the number of types of cake this bakery sells.,EASY,bakery_1,"[goods.Food, goods.Flavor]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT COUNT(DISTINCT goods.Flavor) AS cake_types FROM goods WHERE goods.Food = 'Cake';,"SELECT count(*) FROM goods WHERE food  =  ""Cake""","1. Sequential Structure: Begin with the SELECT clause to count the distinct types of cakes sold by the bakery. 2. Condition Structure: Use a WHERE clause to filter for items in the ""goods"" table where the ""Food"" column indicates ""Cake"". 3. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on the ""Flavor"" column to count the unique types of cakes.",1.0
1425,"For each type of food, tell me how many customers have ever bought it.",NON-NESTED,bakery_1,"[goods.Food, items.Item = goods.Id, receipts.CustomerId = customers.Id, items.Receipt = receipts.ReceiptNumber]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Food, COUNT(DISTINCT receipts.CustomerId) AS CustomerCount FROM goods JOIN items ON items.Item = goods.Id JOIN receipts ON items.Receipt = receipts.ReceiptNumber JOIN customers ON receipts.CustomerId = customers.Id GROUP BY goods.Food;","SELECT T1.food ,  count(DISTINCT T3.CustomerId) FROM goods AS T1 JOIN items AS T2 ON T1.Id  =  T2.Item JOIN receipts AS T3 ON T2.Receipt  =  T3.ReceiptNumber GROUP BY T1.food","1. Sequential Structure: Start with the SELECT clause to retrieve the type of food (""goods.Food"") and the count of distinct customers who have bought it. Use COUNT with DISTINCT on ""receipts.CustomerId"" to count unique customers. 2. Condition Structure: No specific filtering condition is required, as we are interested in all types of food and their respective customer counts. 3. Join Structure: Use JOINs to connect the ""goods"" table with the ""items"" table on ""goods.Id = items.Item,"" then connect ""items"" with ""receipts"" on ""items.Receipt = receipts.ReceiptNumber,"" and finally connect ""receipts"" with ""customers"" on ""receipts.CustomerId = customers.Id."" 4. Aggregation Structure: Use GROUP BY on ""goods.Food"" to group the results by each type of food and calculate the count of distinct customers for each group.",1.0
1426,What are the distinct ids of all goods that are cheaper than some goods of type Tart?,NESTED,bakery_1,"[goods.Id, goods.Price, goods.Food]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT DISTINCT goods.Id FROM goods WHERE goods.Price < ANY (SELECT goods.Price FROM goods WHERE goods.Food = 'Tart');,"SELECT DISTINCT id FROM goods WHERE price  <  (SELECT max(price) FROM goods WHERE food  =  ""Tart"")","1. Sequential Structure: Start with the SELECT clause to retrieve distinct IDs of goods. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter goods whose price is less than the price of any goods of type 'Tart'. 2. Condition Structure: Use the WHERE clause with a subquery to compare the price of goods with the prices of goods of type 'Tart'. The subquery retrieves the prices of goods where the Food type is 'Tart'. 3. Join Structure: Not required, as all data is in the goods table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",0.0
1427,Show the name of the country that has the greatest number of official languages.,NON-NESTED,country_language,"[countries.name,official_languages.country_id,official_languages.language_id,official_languages.country_id = countries.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT countries.name FROM countries JOIN official_languages ON official_languages.country_id = countries.id GROUP BY countries.name ORDER BY COUNT(official_languages.language_id) DESC LIMIT 1;,SELECT T1.Name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id GROUP BY T1.id ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the country. Use COUNT to count the number of official languages for each country. Use ORDER BY in descending order to rank countries by the number of official languages and LIMIT 1 to get the country with the greatest number. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all countries. 3. Join Structure: Use a JOIN between the ""countries"" table and the ""official_languages"" table based on ""official_languages.country_id = countries.id"" to associate each country with its official languages. 4. Aggregation Structure: Use COUNT on ""official_languages.language_id"" to count the number of official languages for each country, then GROUP BY ""countries.name"" to group results by country.",1.0
1428,How many drivers use each constructor?,NON-NESTED,car_road_race,"[driver.Constructor, driver.Driver_ID, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT driver.Constructor, COUNT(driver.Driver_ID) AS driver_count FROM driver GROUP BY driver.Constructor;","SELECT CONSTRUCTOR ,  COUNT(*) FROM driver GROUP BY CONSTRUCTOR","1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Constructor"" and the count of drivers for each constructor. Use COUNT to count the number of drivers. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: No JOIN is necessary since all the required data is available in the ""driver"" table. 4. Aggregation Structure: Use COUNT to count the number of drivers for each constructor and GROUP BY ""driver.Constructor"" to group the results by constructor.",1.0
1429,What are the items with chocolate flavor that were purchased at most 10 times.,NON-NESTED,bakery_1,"[goods.Flavor, goods.Id = items.Item, goods.Food, items.Receipt, receipts.ReceiptNumber = items.Receipt]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Food FROM goods JOIN items ON goods.Id = items.Item JOIN receipts ON receipts.ReceiptNumber = items.Receipt WHERE goods.Flavor = 'chocolate' GROUP BY goods.Food HAVING COUNT(items.Item) <= 10;,"SELECT DISTINCT T1.item FROM items AS T1 JOIN goods AS T2 ON T1.item  =  T2.id WHERE T2.flavor  =  ""Chocolate"" GROUP BY item HAVING count(*)  <=  10","1. Sequential Structure: Start with the SELECT clause to retrieve the names of items with a chocolate flavor. Use the ""goods.Food"" field to get the item names. 2. Condition Structure: Use a WHERE clause to filter for items with the flavor ""chocolate."" Additionally, use a HAVING clause to filter items that were purchased at most 10 times. 3. Join Structure: Use JOINs to connect the ""goods"" table with the ""items"" table on ""goods.Id = items.Item"" and the ""items"" table with the ""receipts"" table on ""receipts.ReceiptNumber = items.Receipt"" to link items with their purchase records. 4. Aggregation Structure: Use COUNT on ""items.Item"" to count the number of times each item was purchased, then filter with HAVING to select items purchased at most 10 times.",0.0
1430,What are the last names of the customers in alphabetical order?,EASY,bakery_1,[customers.LastName],"Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT customers.LastName FROM customers ORDER BY customers.LastName ASC;,SELECT DISTINCT LastName FROM customers ORDER BY LastName,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""LastName"" of the customers. 2. Condition Structure: No specific filtering condition is required as we want all customer last names. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""customers"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the last names. 5. Ordering Structure: Use ORDER BY to sort the last names in alphabetical order.",1.0
1431,Count the number of different official languages.,NON-NESTED,country_language,"[languages.id, official_languages.language_id = languages.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT COUNT(DISTINCT languages.id) FROM official_languages JOIN languages ON official_languages.language_id = languages.id;,SELECT count(DISTINCT language_id) FROM official_languages,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""languages.id"" since we are interested in the number of different official languages. 2. Condition Structure: No specific filtering condition is required as we are counting all official languages. 3. Join Structure: Use a JOIN between the ""official_languages"" and ""languages"" tables based on ""official_languages.language_id = languages.id"" to link official languages with their corresponding language details. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique ""languages.id"" values.",1.0
1432,List the last names of all customers in an alphabetical order.,EASY,bakery_1,[customers.LastName],"Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT customers.LastName FROM customers ORDER BY customers.LastName ASC;,SELECT DISTINCT LastName FROM customers ORDER BY LastName,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""LastName"" of customers. 2. Condition Structure: No specific filtering condition is required as we want all customer last names. 3. Join Structure: No JOIN is required since all necessary data is within the ""customers"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the last names. 5. Ordering Structure: Use ORDER BY to sort the results in alphabetical order based on ""customers.LastName"".",1.0
1433,Which countries and cities are included in addresses?,EASY,real_estate_rentals,"[Addresses.country, Addresses.town_city]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT DISTINCT Addresses.country, Addresses.town_city FROM Addresses;","SELECT country ,  town_city FROM Addresses;","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Addresses.country"" and ""Addresses.town_city"". 2. Condition Structure: No specific filtering condition is required as the query aims to retrieve all countries and cities included in addresses. 3. Join Structure: No JOIN is required since all necessary data is within the ""Addresses"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct combinations of countries and cities.",1.0
1434,What are the names od drivers who did not have the constructor Bugatti?,NESTED,car_road_race,"[driver.Driver_Name, driver.Constructor, race.Driver_ID = driver.Driver_ID, Bugatti]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Driver_Name FROM driver WHERE driver.Driver_ID NOT IN ( SELECT race.Driver_ID FROM race JOIN driver ON race.Driver_ID = driver.Driver_ID WHERE driver.Constructor = 'Bugatti' );,"SELECT Driver_Name FROM driver WHERE CONSTRUCTOR != ""Bugatti""","1. Sequential Structure: Start with the SELECT clause to retrieve the names of drivers. Use the FROM clause to specify the driver table. Apply a WHERE clause to filter out drivers associated with the constructor ""Bugatti"". 2. Condition Structure: Use the WHERE clause with a subquery to exclude drivers whose constructor is ""Bugatti"". The subquery identifies all driver IDs associated with ""Bugatti"", and the main query ensures these IDs are not included. 3. Join Structure: Use an INNER JOIN between the race and driver tables based on Driver_ID to connect race data with driver details. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1435,"For each type of food, what are the average, maximum and minimum price?",EASY,bakery_1,"[goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Food, AVG(goods.Price) AS avg_price, MAX(goods.Price) AS max_price, MIN(goods.Price) AS min_price FROM goods GROUP BY goods.Food;","SELECT food ,  avg(price) ,  max(price) ,  min(price) FROM goods GROUP BY food","1. Sequential Structure: Begin with the SELECT clause to specify the type of food and the required aggregate values, which are the average, maximum, and minimum prices. 2. Aggregation Structure: Use AVG, MAX, and MIN functions to calculate the average, maximum, and minimum prices for each type of food. 3. Grouping Structure: Use GROUP BY on ""goods.Food"" to calculate these aggregate values for each type of food. 4. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table.",1.0
1436,"What are the different room sizes, and how many of each are there?",EASY,real_estate_rentals,"[Rooms.room_size, Rooms.room_number]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Rooms.room_size, COUNT(*) AS room_count FROM Rooms GROUP BY Rooms.room_size;","SELECT room_size ,  count(*) FROM Rooms GROUP BY room_size","1. Sequential Structure: Start with the SELECT clause to specify the room sizes and the count of each size. 2. Aggregation Structure: Use COUNT to calculate the number of rooms for each room size. 3. Grouping Structure: Use GROUP BY on ""Rooms.room_size"" to group the results by each room size. 4. Join Structure: No JOIN is required since all necessary data is within the ""Rooms"" table.",1.0
1437,How many cyclists did not purchase any bike after year 2015?,NESTED,bike_racing,"[cyclist.id,cyclists_own_bikes.cyclist_id,cyclists_own_bikes.purchase_year,cyclists_own_bikes.cyclist_id = cyclist.id]","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
",SELECT COUNT(*) FROM cyclist WHERE id NOT IN ( SELECT cyclist_id FROM cyclists_own_bikes WHERE purchase_year > 2015 );,SELECT count(*) FROM cyclist WHERE id NOT IN ( SELECT cyclist_id FROM cyclists_own_bikes WHERE purchase_year  >  2015 ),"1. Sequential Structure: Start with the SELECT clause to count the number of cyclists. Use the FROM clause to specify the cyclist table. Apply a WHERE clause to filter cyclists who did not purchase any bike after the year 2015. 2. Condition Structure: Use the WHERE clause with a subquery to exclude cyclists whose IDs appear in the cyclists_own_bikes table with a purchase_year greater than 2015. 3. Join Structure: Not required, as the filtering is done using a subquery and no direct joining of tables is necessary. 4. Aggregation Structure: Use COUNT to count the number of cyclists who meet the specified condition.",1.0
1438,Give the ids of cookes that are cheaper than any croissant.,NESTED,bakery_1,"[goods.Id, goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT Id FROM goods WHERE Food = 'Cookie' AND Price < (SELECT MIN(Price) FROM goods WHERE Food = 'Croissant');,"SELECT id FROM goods WHERE food  =  ""Cookie"" AND price  <  (SELECT min(price) FROM goods WHERE food  =  'Croissant')","1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of goods that are cookies. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter for cookies whose price is less than the price of any croissant. 2. Condition Structure: Use the WHERE clause to filter for goods where the Food is 'Cookie' and the price is less than the minimum price of any croissant. Use a subquery to identify the prices of croissants. 3. Join Structure: Not required, as all data is in the goods table. 4. Aggregation Structure: Not required, as we are comparing individual prices without any aggregation.",1.0
1439,"What are the average, minimum and maximum prices for each food?",EASY,bakery_1,"[goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Food, AVG(goods.Price) AS avg_price, MIN(goods.Price) AS min_price, MAX(goods.Price) AS max_price FROM goods GROUP BY goods.Food;","SELECT food ,  avg(price) ,  max(price) ,  min(price) FROM goods GROUP BY food","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the food name and the aggregate values (average, minimum, and maximum prices). 2. Aggregation Structure: Use AVG, MIN, and MAX functions to calculate the average, minimum, and maximum prices for each food. 3. Grouping Structure: Use GROUP BY on ""goods.Food"" to calculate these aggregate values for each food. 4. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table.",1.0
1440,"What are the names of languages that contain the word ""ish""?",EASY,country_language,[languages.name],"Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT languages.name FROM languages WHERE languages.name LIKE '%ish%';,"SELECT name FROM languages WHERE name LIKE ""%ish%""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""languages.name"" field, as the question asks for the names of languages. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for language names that contain the word ""ish"". 3. Join Structure: No JOIN is required since all necessary information is in the ""languages"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving language names based on a specific condition.",1.0
1441,What are names of drivers who did not take part in a race?,NESTED,car_road_race,"[driver.Driver_ID, race.Driver_ID, driver.Driver_Name, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Driver_Name FROM driver WHERE driver.Driver_ID NOT IN (SELECT race.Driver_ID FROM race);,SELECT Driver_Name FROM driver WHERE Driver_ID NOT IN (SELECT Driver_ID FROM race),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of drivers. Use the FROM clause to specify the driver table. Apply a WHERE clause to filter for drivers who did not take part in any race by ensuring their Driver_ID is not present in the race table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude drivers whose Driver_ID appears in the race table, meaning they participated in a race. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Driver_ID entries in the race table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1442,List the last names and ids of users who have at least 2 properties and searched at most twice.,NESTED,real_estate_rentals,"[Users.last_name, Users.user_id, Properties.owner_user_id = Users.user_id, User_Searches.user_id = Users.user_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Users.last_name, Users.user_id FROM Users JOIN Properties ON Properties.owner_user_id = Users.user_id JOIN User_Searches ON User_Searches.user_id = Users.user_id GROUP BY Users.last_name, Users.user_id HAVING COUNT(Properties.owner_user_id) >= 2 AND COUNT(User_Searches.user_id) <= 2;","SELECT T1.last_name ,  T1.user_id FROM Users AS T1 JOIN User_Searches AS T2 ON T1.user_id  =  T2.user_id GROUP BY T1.user_id HAVING count(*)  <=  2 INTERSECT SELECT T3.last_name ,  T3.user_id FROM Users AS T3 JOIN Properties AS T4 ON T3.user_id  =  T4.owner_user_id GROUP BY T3.user_id HAVING count(*)  >=  2;","1. Sequential Structure: Start with the SELECT clause to retrieve the last names and IDs of users. Use the FROM clause to specify the Users table. Join it with the Properties table to count the number of properties owned by each user and with the User_Searches table to count the number of searches made by each user. Apply GROUP BY to group data by user ID and last name. Use the HAVING clause to filter users who own at least 2 properties and have searched at most twice. 2. Condition Structure: Use the HAVING clause to filter users with COUNT(Properties.owner_user_id) >= 2 and COUNT(User_Searches.user_id) <= 2. 3. Join Structure: Use INNER JOINs between the Users table, Properties table, and User_Searches table based on user_id to connect user details with their properties and searches. 4. Aggregation Structure: Use COUNT to calculate the number of properties owned and the number of searches made by each user, and apply these counts in the HAVING clause for filtering.",0.0
1443,Show the constructors that are used both by drivers with age lower than 20 and drivers with age over than 30.,NESTED,car_road_race,"[driver.Constructor, driver.Age, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Constructor FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID WHERE driver.Age < 20 INTERSECT SELECT driver.Constructor FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID WHERE driver.Age > 30;,SELECT CONSTRUCTOR FROM driver WHERE Age  <  20 INTERSECT SELECT CONSTRUCTOR FROM driver WHERE Age  >  30,"1. Sequential Structure: Start with the SELECT clause to retrieve the constructors. Use the FROM clause to specify the driver table and join it with the race table to connect drivers with their constructors. Use a WHERE clause to filter drivers based on their age (less than 20 and over 30). Use INTERSECT to find constructors used by both groups of drivers. 2. Condition Structure: Use two separate WHERE clauses to filter drivers with age less than 20 and age over 30. Use INTERSECT to find common constructors between these two groups. 3. Join Structure: Use a JOIN between the driver and race tables based on Driver_ID to connect drivers with their constructors. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1444,"Which good has ""70"" in its id? And what is its price?",EASY,bakery_1,"[goods.Id, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Id, goods.Price FROM goods WHERE goods.Id LIKE '%70%';","SELECT id ,  price FROM goods WHERE id LIKE ""%70%""","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""goods.Id"" and ""goods.Price"". 2. Condition Structure: Use a WHERE clause to filter for goods where the ""goods.Id"" contains ""70"". 3. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
1445,"List the heat, name, and nation for all the cyclists.",EASY,bike_racing,"[cyclist.heat, cyclist.name, cyclist.nation]","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
","SELECT cyclist.heat, cyclist.name, cyclist.nation FROM cyclist;","SELECT heat ,  name ,  nation FROM cyclist","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""cyclist.heat"", ""cyclist.name"", and ""cyclist.nation"". 2. Condition Structure: No specific filtering condition is required as the query asks for all cyclists. 3. Join Structure: No JOIN is required since all necessary data is within the ""cyclist"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the specified fields for all cyclists.",1.0
1446,What are the managers and sponsors of teams? Sort the results by Car Owners.,EASY,car_racing,"[team.Manager, team.Sponsor, team.Car_Owner]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT team.Manager, team.Sponsor, team.Car_Owner FROM team ORDER BY team.Car_Owner;","SELECT Manager ,  Sponsor FROM team ORDER BY Car_Owner","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are ""team.Manager,"" ""team.Sponsor,"" and ""team.Car_Owner."" 2. Condition Structure: No specific filtering condition is required as the query asks for all managers and sponsors of teams. 3. Join Structure: No JOIN is required since all necessary data is within the ""team"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves and sorts the data. 5. Ordering Structure: Use ORDER BY on ""team.Car_Owner"" to sort the results by car owners.",1.0
1447,"What are the buildings, streets, and cities corresponding to the addresses of senior citizens?",NON-NESTED,real_estate_rentals,"[Addresses.line_1_number_building, Addresses.line_2_number_street, Addresses.town_city, Users.user_address_id = Addresses.address_id, Users.age_category_code = Ref_Age_Categories.age_category_code, Ref_Age_Categories.age_category_description, senior citizens]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Addresses.line_1_number_building, Addresses.line_2_number_street, Addresses.town_city FROM Users JOIN Addresses ON Users.user_address_id = Addresses.address_id JOIN Ref_Age_Categories ON Users.age_category_code = Ref_Age_Categories.age_category_code WHERE Ref_Age_Categories.age_category_description = 'senior citizens';","SELECT T1.line_1_number_building ,  T1.line_2_number_street ,  T1.town_city FROM Addresses AS T1 JOIN Users AS T2 ON T1.address_id  =  T2.user_address_id WHERE T2.user_category_code  =  'Senior Citizen';","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Addresses.line_1_number_building,"" ""Addresses.line_2_number_street,"" and ""Addresses.town_city."" 2. Condition Structure: Use a WHERE clause to filter for users whose age category description is ""senior citizens."" 3. Join Structure: Use JOINs to connect the ""Users"" table with the ""Addresses"" table on ""Users.user_address_id = Addresses.address_id"" and the ""Users"" table with the ""Ref_Age_Categories"" table on ""Users.age_category_code = Ref_Age_Categories.age_category_code"" to link users with their age categories and addresses. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields for senior citizens.",0.0
1448,How many drivers are there?,EASY,car_racing,[driver.Driver_ID],"Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT COUNT(driver.Driver_ID) AS total_drivers FROM driver;,SELECT count(*) FROM driver,"1. Sequential Structure: Start with the SELECT clause to count the number of drivers. 2. Aggregation Structure: Use the COUNT function to calculate the total number of drivers based on their unique ""Driver_ID"". 3. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table. 4. Condition Structure: No specific filtering condition is needed as we are counting all drivers.",1.0
1449,"Find the make of the team whose car owner is ""Buddy Arrington"".",EASY,car_racing,"[team.Make, team.Car_Owner, team.Car_Owner = ""Buddy Arrington""]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT team.Make FROM team WHERE team.Car_Owner = ""Buddy Arrington"";","SELECT Make FROM team WHERE Car_Owner  =  ""Buddy Arrington""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""team.Make"" of the team whose car owner is ""Buddy Arrington"". 2. Condition Structure: Use a WHERE clause to filter for records where ""team.Car_Owner"" is equal to ""Buddy Arrington"". 3. Join Structure: No JOIN is required since all necessary information is in the ""team"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
1450,What is the average price for each food type?,EASY,bakery_1,"[goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Food, AVG(goods.Price) AS avg_price FROM goods GROUP BY goods.Food;","SELECT avg(price) ,  food FROM goods GROUP BY food","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the food type and the average price. 2. Aggregation Structure: Use the AVG function to calculate the average price for each food type. 3. Grouping Structure: Use GROUP BY on ""goods.Food"" to calculate the average price for each food type. 4. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table.",1.0
1451,"What are the names of the countries, as well as the names of their official langauges?",NON-NESTED,country_language,"[countries.name, languages.name, official_languages.country_id = countries.id, official_languages.language_id = languages.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
","SELECT countries.name, languages.name FROM countries JOIN official_languages ON countries.id = official_languages.country_id JOIN languages ON official_languages.language_id = languages.id;","SELECT T1.name ,  T3.name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id","1. Sequential Structure: Start with the SELECT clause to retrieve the names of the countries and their official languages, i.e., ""countries.name"" and ""languages.name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""countries"" table with the ""official_languages"" table on ""countries.id = official_languages.country_id"" and the ""languages"" table on ""official_languages.language_id = languages.id"" to link each country with its official languages. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the names of countries and their official languages.",1.0
1452,Return the cities in which there exist properties that have swimming pools.,NON-NESTED,real_estate_rentals,"[Addresses.town_city,Properties.property_address_id = Addresses.address_id,Property_Features.property_id = Properties.property_id,Features.feature_id = Property_Features.feature_id,Features.feature_name,swimming pools]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT DISTINCT Addresses.town_city FROM Properties JOIN Addresses ON Properties.property_address_id = Addresses.address_id JOIN Property_Features ON Properties.property_id = Property_Features.property_id JOIN Features ON Property_Features.feature_id = Features.feature_id WHERE Features.feature_name = 'swimming pools';,SELECT T2.town_city FROM Properties AS T1 JOIN Addresses AS T2 ON T1.property_address_id  =  T2.address_id JOIN Property_Features AS T3 ON T1.property_id  =  T3.property_id JOIN Features AS T4 ON T4.feature_id  =  T3.feature_id WHERE T4.feature_name  =  'swimming pool';,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct ""Addresses.town_city"" since we are interested in the cities where properties with swimming pools exist. 2. Condition Structure: Use a WHERE clause to filter for properties that have the feature ""swimming pools."" 3. Join Structure: Use multiple JOINs to connect the relevant tables. First, join ""Properties"" with ""Addresses"" on ""Properties.property_address_id = Addresses.address_id"" to link properties with their cities. Then, join ""Properties"" with ""Property_Features"" on ""Properties.property_id = Property_Features.property_id"" to associate properties with their features. Finally, join ""Property_Features"" with ""Features"" on ""Property_Features.feature_id = Features.feature_id"" to filter for the specific feature ""swimming pools."" 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique city names are returned.",0.0
1453,List the names of countries that do not have any official language.,NESTED,country_language,"[countries.name, countries.id, official_languages.country_id = countries.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT countries.name FROM countries WHERE countries.id NOT IN (SELECT country_id FROM official_languages);,SELECT name FROM countries WHERE id NOT IN (SELECT country_id FROM official_languages),"1. Sequential Structure: Begin with the SELECT clause to retrieve the names of countries. Use the FROM clause to specify the countries table. Apply a WHERE clause to filter countries that do not have any official language by ensuring that their ID is not present in the official_languages table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude countries whose ID appears in the official_languages table, meaning they have official languages. 3. Join Structure: Not required, as we only need to filter based on the absence of matching country_id entries in the official_languages table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1454,Show the names of countries and their official languages.,NON-NESTED,country_language,"[countries.name, languages.name, official_languages.country_id = countries.id, official_languages.language_id = languages.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
","SELECT countries.name, languages.name FROM countries JOIN official_languages ON countries.id = official_languages.country_id JOIN languages ON official_languages.language_id = languages.id;","SELECT T1.name ,  T3.name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id","1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries and their official languages, i.e., ""countries.name"" and ""languages.name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""countries"" table with the ""official_languages"" table on ""countries.id = official_languages.country_id"" and the ""languages"" table on ""official_languages.language_id = languages.id"" to link countries with their official languages. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the names of countries and their official languages.",1.0
1455,How many languages are there?,EASY,country_language,[languages.id],"Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT COUNT(DISTINCT languages.id) AS language_count FROM languages;,SELECT count(*) FROM languages,"1. Sequential Structure: Start with the SELECT clause to count the number of languages. 2. Aggregation Structure: Use the COUNT function to count the distinct ""languages.id"" values, as each language is uniquely identified by its ID. 3. Join Structure: No JOIN is required since all necessary information is in the ""languages"" table. 4. Condition Structure: No specific filtering condition is needed, as we are counting all languages.",1.0
1456,"Show the average overall scores of countries whose official language is ""English"".",NON-NESTED,country_language,"[countries.overall_score,official_languages.language_id = languages.id,official_languages.country_id = countries.id,languages.name,English]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT AVG(countries.overall_score) FROM countries JOIN official_languages ON countries.id = official_languages.country_id JOIN languages ON official_languages.language_id = languages.id WHERE languages.name = 'English';,"SELECT avg(T1.overall_score) FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id WHERE T3.name  =  ""English""","1. Sequential Structure: Start with the SELECT clause to calculate the average overall score of countries. Use the AVG function on ""countries.overall_score."" 2. Condition Structure: Use a WHERE clause to filter for countries where the official language is ""English."" This requires checking the ""languages.name"" field for the value ""English."" 3. Join Structure: Use JOINs to connect the ""countries"" table with the ""official_languages"" table on ""countries.id = official_languages.country_id"" and the ""official_languages"" table with the ""languages"" table on ""official_languages.language_id = languages.id."" 4. Aggregation Structure: Use the AVG function to compute the average overall score for the filtered countries.",1.0
1457,Find the number of drivers whose points are greater than 150 for each make.,EASY,car_racing,"[driver.Make, driver.Points, driver.Driver_ID, driver.Points > 150]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT driver.Make, COUNT(driver.Driver_ID) AS driver_count FROM driver WHERE driver.Points > 150 GROUP BY driver.Make;","SELECT make ,  count(*) FROM driver WHERE points  >  150 GROUP BY make","1. Sequential Structure: Begin with the SELECT clause to specify the make and the count of drivers whose points are greater than 150. 2. Condition Structure: Use a WHERE clause to filter drivers with points greater than 150. 3. Grouping Structure: Use GROUP BY on ""driver.Make"" to count drivers for each make. 4. Aggregation Structure: Use COUNT to calculate the number of drivers meeting the points condition for each make. 5. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table.",1.0
1458,Return the cheapest price for goods with cheese flavor.,EASY,bakery_1,"[goods.Price, goods.Flavor]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT MIN(goods.Price) AS cheapest_price FROM goods WHERE goods.Flavor = 'cheese';,"SELECT min(price) FROM goods WHERE flavor  =  ""Cheese""","1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the minimum price of goods. 2. Condition Structure: Use a WHERE clause to filter for goods with the flavor ""cheese."" 3. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 4. Aggregation Structure: Use the MIN function to find the cheapest price among the filtered goods.",0.0
1459,"What are the names of the countries, ordered descending by education score?",EASY,country_language,"[countries.name, countries.education_score]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
","SELECT countries.name, countries.education_score FROM countries ORDER BY countries.education_score DESC;",SELECT name FROM countries ORDER BY education_score DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the country names and their education scores. 2. Condition Structure: No specific filtering condition is required as we want all countries and their education scores. 3. Join Structure: No JOIN is needed since all necessary information is available in the ""countries"" table. 4. Aggregation Structure: No aggregation function is needed here, but use ORDER BY to sort the results in descending order based on ""countries.education_score"".",1.0
1460,Give the states or provinces corresponding to each property.,NON-NESTED,real_estate_rentals,"[Properties.property_address_id, Addresses.county_state_province, Properties.property_address_id = Addresses.address_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Addresses.county_state_province FROM Properties JOIN Addresses ON Properties.property_address_id = Addresses.address_id;,SELECT DISTINCT T1.county_state_province FROM Addresses AS T1 JOIN Properties AS T2 ON T1.address_id  =  T2.property_address_id;,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Addresses.county_state_province"" and the corresponding property information. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Properties"" and ""Addresses"" tables based on the relationship ""Properties.property_address_id = Addresses.address_id"" to link each property with its state or province. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the corresponding states or provinces for each property.",1.0
1461,Return the number of rooms with each different room size.,EASY,real_estate_rentals,"[Rooms.room_size, Rooms.room_number]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Rooms.room_size, COUNT(*) AS room_count FROM Rooms GROUP BY Rooms.room_size;","SELECT room_size ,  count(*) FROM Rooms GROUP BY room_size","1. Sequential Structure: Begin with the SELECT clause to specify the room size and the count of rooms for each size. 2. Aggregation Structure: Use COUNT to calculate the number of rooms for each room size. 3. Grouping Structure: Use GROUP BY on ""Rooms.room_size"" to group the results by each unique room size. 4. Join Structure: No JOIN is required since all necessary data is within the ""Rooms"" table.",1.0
1462,Count the number of languages.,EASY,country_language,[languages.id],"Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT COUNT(DISTINCT languages.id) AS language_count FROM languages;,SELECT count(*) FROM languages,"1. Sequential Structure: Start with the SELECT clause to count the number of languages. 2. Aggregation Structure: Use the COUNT function to count the distinct ""languages.id"" since each language is uniquely identified by its ID. 3. Join Structure: No JOIN is required as the information is contained within the ""languages"" table. 4. Condition Structure: No specific filtering condition is needed as we are counting all languages.",1.0
1463,Return the zip codes for properties not belonging to users who own two or fewer properties.,NESTED,real_estate_rentals,"[Addresses.zip_postcode,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Users.user_id,Properties.property_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Addresses.zip_postcode FROM Properties JOIN Addresses ON Properties.property_address_id = Addresses.address_id JOIN Users ON Properties.owner_user_id = Users.user_id WHERE Properties.owner_user_id NOT IN ( SELECT owner_user_id FROM Properties GROUP BY owner_user_id HAVING COUNT(property_id) <= 2 );,SELECT T1.zip_postcode FROM Addresses AS T1 JOIN Properties AS T2 ON T1.address_id  =  T2.property_address_id WHERE T2.owner_user_id NOT IN ( SELECT owner_user_id FROM Properties GROUP BY owner_user_id HAVING count(*)  <=  2 );,"1. Sequential Structure: Start with the SELECT clause to retrieve the zip codes of properties. Use the FROM clause to specify the Addresses table and join it with the Properties and Users tables to connect properties with their owners and addresses. Apply a WHERE clause to filter out properties belonging to users who own two or fewer properties. 2. Condition Structure: Use the WHERE clause with a subquery to exclude users who own two or fewer properties. The subquery will count the number of properties owned by each user and filter for users with more than two properties. 3. Join Structure: Use JOINs between the Addresses, Properties, and Users tables based on the relationships provided in the schema (property_address_id = address_id and owner_user_id = user_id) to connect properties with their owners and addresses. 4. Aggregation Structure: Use COUNT in the subquery to calculate the number of properties owned by each user and filter for users owning more than two properties.",1.0
1464,Find flavor of cakes that cost more than 10 dollars.,EASY,bakery_1,"[goods.Flavor, goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Flavor FROM goods WHERE goods.Food = 'cake' AND goods.Price > 10;,"SELECT flavor FROM goods WHERE food  =  ""Cake"" AND price  >  10","1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the flavor of cakes. 2. Condition Structure: Use a WHERE clause to filter for goods where the ""Food"" is 'cake' and the ""Price"" is greater than 10 dollars. 3. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the flavors of cakes that meet the specified price condition.",0.0
1465,"Return the search strings and corresonding time stamps for all user searches, sorted by search string descending.",EASY,real_estate_rentals,"[User_Searches.search_string, User_Searches.search_datetime]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT User_Searches.search_string, User_Searches.search_datetime FROM User_Searches ORDER BY User_Searches.search_string DESC;","SELECT search_datetime ,  search_string FROM User_Searches ORDER BY search_string DESC;","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""User_Searches.search_string"" and ""User_Searches.search_datetime"". 2. Condition Structure: No specific filtering condition is required as we want all user searches. 3. Join Structure: No JOIN is required since all necessary data is within the ""User_Searches"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY in descending order on ""User_Searches.search_string"" to sort the results.",1.0
1466,"Give the customer id of the customer that made the most purchases, as well as the number of purchases made.",NON-NESTED,bakery_1,"[receipts.CustomerId, items.Receipt, receipts.ReceiptNumber, items.Item = goods.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT receipts.CustomerId, COUNT(items.Receipt) AS NumberOfPurchases FROM receipts JOIN items ON receipts.ReceiptNumber = items.Receipt GROUP BY receipts.CustomerId ORDER BY NumberOfPurchases DESC LIMIT 1;","SELECT CustomerId ,  count(*) FROM receipts GROUP BY CustomerId ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""receipts.CustomerId"" and the count of purchases made. Use COUNT to count the number of purchases for each customer. 2. Condition Structure: No specific filtering condition is required, as we are interested in all customers to determine the one with the most purchases. 3. Join Structure: Use a JOIN between the ""receipts"" and ""items"" tables based on the ""receipts.ReceiptNumber"" and ""items.Receipt"" to link each receipt with its items. 4. Aggregation Structure: Use GROUP BY on ""receipts.CustomerId"" to group the data by customer. Use ORDER BY in descending order on the count of purchases to rank customers by the number of purchases. Use LIMIT 1 to select the customer with the most purchases.",0.0
1467,Find the ids of goods that have apple flavor.,EASY,bakery_1,"[goods.Id, goods.Flavor, apple]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Id FROM goods WHERE goods.Flavor = 'apple';,"SELECT id FROM goods WHERE flavor  =  ""Apple""","1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the ""goods.Id"". 2. Condition Structure: Use a WHERE clause to filter for goods that have the flavor ""apple"". 3. Join Structure: No JOIN is required since all necessary information is in the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the IDs of goods that meet the specified condition.",0.0
1468,Return the description of the feature 'rooftop'.,EASY,real_estate_rentals,"[Features.feature_description, Features.feature_name, 'rooftop']","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Features.feature_description FROM Features WHERE Features.feature_name = 'rooftop';,SELECT feature_description FROM Features WHERE feature_name  =  'rooftop';,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Features.feature_description"" for the feature named 'rooftop'. 2. Condition Structure: Use a WHERE clause to filter for the feature where ""Features.feature_name"" is 'rooftop'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Features"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
1469,List the name of the country with the biggest score in politics.,EASY,country_language,"[countries.name, countries.politics_score]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT countries.name FROM countries ORDER BY countries.politics_score DESC LIMIT 1;,SELECT name FROM countries ORDER BY politics_score DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countries.name"" of the country with the highest politics score. 2. Condition Structure: No specific filtering condition is needed since we are looking for the country with the maximum politics score. 3. Join Structure: No JOIN is required, as all necessary information is in the ""countries"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""countries.politics_score"" to rank countries by their politics score and apply LIMIT 1 to select the country with the highest score.",1.0
1470,"What are the makes of the teams with car owner ""Buddy Arrington""?",NON-NESTED,car_racing,"[team.Make, team.Car_Owner, team_driver.Team_ID = team.Team_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT team.Make FROM team WHERE team.Car_Owner = 'Buddy Arrington';,"SELECT Make FROM team WHERE Car_Owner  =  ""Buddy Arrington""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""team.Make"" field, as the question asks for the makes of the teams. 2. Condition Structure: Use a WHERE clause to filter for teams where the ""team.Car_Owner"" is ""Buddy Arrington."" 3. Join Structure: No JOIN is necessary here, as the required information is available within the ""team"" table. 4. Aggregation Structure: No aggregation is needed since the query only retrieves specific rows based on the condition.",1.0
1471,How many searches do buyers make in total?,NON-NESTED,real_estate_rentals,"[Users.user_id,Users.is_buyer,User_Searches.user_id,User_Searches.search_seq,User_Searches.user_id = Users.user_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT COUNT(User_Searches.search_seq) FROM Users JOIN User_Searches ON Users.user_id = User_Searches.user_id WHERE Users.is_buyer = 1;,SELECT count(*) FROM Users AS T1 JOIN User_Searches AS T2 ON T1.user_id  =  T2.user_id WHERE T1.is_buyer  =  1;,"1. Sequential Structure: Start with the SELECT clause to count the total number of searches made by buyers. Use the COUNT function on ""User_Searches.search_seq"" to calculate the total number of searches. 2. Condition Structure: Use a WHERE clause to filter for users who are buyers, i.e., ""Users.is_buyer = 1."" 3. Join Structure: Use an INNER JOIN between the ""Users"" table and the ""User_Searches"" table on the common key ""Users.user_id = User_Searches.user_id"" to associate searches with buyers. 4. Aggregation Structure: Use COUNT to aggregate the total number of searches made by buyers.",1.0
1472,Return the country in which the user with first name Robbie lives.,NON-NESTED,real_estate_rentals,"[Users.first_name, Users.user_address_id, Addresses.country, Users.user_address_id = Addresses.address_id, Robbie]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Addresses.country FROM Users JOIN Addresses ON Users.user_address_id = Addresses.address_id WHERE Users.first_name = 'Robbie';,SELECT T1.country FROM Addresses AS T1 JOIN Users AS T2 ON T1.address_id  =  T2.user_address_id WHERE T2.first_name  =  'Robbie';,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Addresses.country"" field, as we need to find the country where the user lives. 2. Condition Structure: Use a WHERE clause to filter for the user with the first name ""Robbie."" 3. Join Structure: Use a JOIN between the ""Users"" table and the ""Addresses"" table based on the relationship ""Users.user_address_id = Addresses.address_id"" to link users with their respective addresses. 4. Aggregation Structure: No aggregation is needed, as we are retrieving a single value based on the specified condition.",1.0
1473,Find the highest and lowest points of drivers.,EASY,car_racing,[driver.Points],"Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT MAX(driver.Points) AS highest_points, MIN(driver.Points) AS lowest_points FROM driver;","SELECT max(Points) ,  min(Points) FROM driver","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the highest and lowest points of drivers. 2. Aggregation Structure: Use the MAX function to find the highest points and the MIN function to find the lowest points among drivers. 3. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table. 4. Condition Structure: No specific filtering condition is needed as we are calculating the overall highest and lowest points.",1.0
1474,What are the flavors of cakes that cost more than 10 dollars?,EASY,bakery_1,"[goods.Flavor, goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Flavor FROM goods WHERE goods.Food = 'Cake' AND goods.Price > 10;,"SELECT flavor FROM goods WHERE food  =  ""Cake"" AND price  >  10","1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""goods.Flavor"" of cakes. 2. Condition Structure: Use a WHERE clause to filter for items where ""goods.Food"" is 'Cake' and ""goods.Price"" is greater than 10. 3. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the flavors of cakes that meet the specified price condition.",1.0
1475,"What are the maximum, minimum, and average prices of goods of each flavor, ordered by flavor?",EASY,bakery_1,"[goods.Flavor, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Flavor, MAX(goods.Price) AS max_price, MIN(goods.Price) AS min_price, AVG(goods.Price) AS avg_price FROM goods GROUP BY goods.Flavor ORDER BY goods.Flavor;","SELECT max(price) ,  min(price) ,  avg(price) ,  flavor FROM goods GROUP BY flavor ORDER BY flavor","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the flavor and the aggregate values (maximum, minimum, and average prices). 2. Aggregation Structure: Use MAX, MIN, and AVG functions to calculate the maximum, minimum, and average prices for goods of each flavor. 3. Grouping Structure: Use GROUP BY on ""goods.Flavor"" to calculate these aggregate values for each flavor. 4. Ordering Structure: Use ORDER BY on ""goods.Flavor"" to sort the results by flavor. 5. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table.",1.0
1476,"List the first name, middle name and last name, and log in name of all the seller users, whose seller value is 1.",EASY,real_estate_rentals,"[Users.first_name, Users.middle_name, Users.last_name, Users.login_name, Users.is_seller]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Users.first_name, Users.middle_name, Users.last_name, Users.login_name FROM Users WHERE Users.is_seller = 1;","SELECT first_name ,  middle_name ,  last_name ,  login_name FROM Users WHERE is_seller  =  1;","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Users.first_name,"" ""Users.middle_name,"" ""Users.last_name,"" and ""Users.login_name."" 2. Condition Structure: Use a WHERE clause to filter for users where ""Users.is_seller"" equals 1. 3. Join Structure: No JOIN is required since all necessary data is within the ""Users"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific fields based on a condition.",1.0
1477,What is the receipt number and date corresponding to the receipt for which the most expensive item was purchased?,NESTED,bakery_1,"[goods.Price,items.Item = goods.Id,items.Receipt,receipts.ReceiptNumber,receipts.Date]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT receipts.ReceiptNumber, receipts.Date FROM receipts JOIN items ON receipts.ReceiptNumber = items.Receipt JOIN goods ON items.Item = goods.Id WHERE goods.Price = (SELECT MAX(Price) FROM goods);","SELECT T1.ReceiptNumber ,  T1.Date FROM receipts AS T1 JOIN items AS T2 ON T1.ReceiptNumber  =  T2.receipt JOIN goods AS T3 ON T2.item  =  T3.id ORDER BY T3.price DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the receipt number and date. Use the FROM clause to specify the receipts table. Join it with the items table to link receipts with purchased items, and then join the items table with the goods table to access item prices. Use a WHERE clause to filter for the most expensive item. 2. Condition Structure: Use a WHERE clause with a subquery to identify the maximum price from the goods table and filter for the receipt corresponding to this price. 3. Join Structure: Use JOINs between receipts, items, and goods tables. The items table connects receipts to goods through the item and receipt fields. 4. Aggregation Structure: Use MAX in a subquery to find the most expensive item's price, which is then used in the filtering condition.",1.0
1478,Find the make that has more than one team.,NON-NESTED,car_racing,"[team.Make, team.Team_ID, team_driver.Team_ID = team.Team_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT team.Make FROM team GROUP BY team.Make HAVING COUNT(team.Team_ID) > 1;,SELECT make FROM team GROUP BY team HAVING count(*)  >  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""team.Make"" field. Use GROUP BY to group results by ""team.Make"" to count the number of teams for each make. 2. Condition Structure: Apply a HAVING clause to filter makes that have more than one team. 3. Join Structure: No JOIN is required since all the necessary data is in the ""team"" table. 4. Aggregation Structure: Use COUNT on ""team.Team_ID"" to count the number of teams for each make, and filter with HAVING to select makes with more than one team.",1.0
1479,What is the last name of the customers who shopped at the bakery more than 10 times?,NON-NESTED,bakery_1,"[customers.LastName,receipts.CustomerId,customers.Id = receipts.CustomerId,receipts.ReceiptNumber,items.Receipt = receipts.ReceiptNumber,items.Item]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT customers.LastName FROM customers JOIN receipts ON customers.Id = receipts.CustomerId JOIN items ON items.Receipt = receipts.ReceiptNumber WHERE items.Item = 'bakery' GROUP BY customers.LastName HAVING COUNT(receipts.ReceiptNumber) > 10;,SELECT T2.LastName FROM receipts AS T1 JOIN customers AS T2 ON T1.CustomerId  =  T2.id GROUP BY T2.id HAVING count(*)  >  10,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""customers.LastName."" 2. Condition Structure: Use a WHERE clause to filter for receipts where the associated items include ""bakery"" and a HAVING clause to filter customers who shopped more than 10 times. 3. Join Structure: Use JOINs to connect ""customers"" with ""receipts"" on ""customers.Id = receipts.CustomerId"" and ""receipts"" with ""items"" on ""items.Receipt = receipts.ReceiptNumber"" to link customers with their purchased items. 4. Aggregation Structure: Use COUNT on ""receipts.ReceiptNumber"" to count the number of times each customer shopped at the bakery, then filter with HAVING to select customers with more than 10 purchases.",0.0
1480,What are the names of drivers except for those who had the pole position James Hinchcliffe?,NESTED,car_road_race,"[driver.Driver_Name, race.Pole_Position, race.Driver_ID = driver.Driver_ID, James Hinchcliffe]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Driver_Name FROM driver WHERE driver.Driver_ID NOT IN ( SELECT race.Pole_Position FROM race WHERE race.Pole_Position = (SELECT driver.Driver_ID FROM driver WHERE driver.Driver_Name = 'James Hinchcliffe') );,"SELECT Driver_Name FROM driver EXCEPT SELECT T1.Driver_Name FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID WHERE Pole_Position  =  ""James Hinchcliffe""","1. Sequential Structure: Start with the SELECT clause to retrieve the names of drivers. Use the FROM clause to specify the driver table. Apply a WHERE clause to exclude drivers who had the pole position for James Hinchcliffe. 2. Condition Structure: Use the WHERE clause with a subquery to filter out drivers whose Driver_ID matches the Pole_Position of James Hinchcliffe. 3. Join Structure: Use a JOIN between the driver and race tables based on Driver_ID to connect driver names with their pole position data. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1481,Show the names of languages that are the official language for both countries with overall score greater than 95 and countries with overall score less than than 90.,NESTED,country_language,"[languages.name,official_languages.language_id = languages.id,official_languages.country_id = countries.id,countries.overall_score,95,90]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT languages.name FROM languages JOIN official_languages ON official_languages.language_id = languages.id JOIN countries ON official_languages.country_id = countries.id WHERE languages.id IN ( SELECT official_languages.language_id FROM official_languages JOIN countries ON official_languages.country_id = countries.id WHERE countries.overall_score > 95 ) AND languages.id IN ( SELECT official_languages.language_id FROM official_languages JOIN countries ON official_languages.country_id = countries.id WHERE countries.overall_score < 90 );,SELECT T3.name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id WHERE T1.overall_score  >  95 INTERSECT SELECT T3.name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id WHERE T1.overall_score  <  90,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of languages. Use the FROM clause to specify the languages table and join it with the official_languages and countries tables to connect languages with countries. Apply a WHERE clause to filter for countries with an overall score greater than 95 and countries with an overall score less than 90. 2. Condition Structure: Use the WHERE clause to filter for countries with overall scores greater than 95 and less than 90. Use a subquery to identify languages that are official in both types of countries. 3. Join Structure: Use INNER JOINs between the languages, official_languages, and countries tables based on their respective IDs to connect languages with countries and their scores. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1482,List the names of drivers that do not participate in any race.,NESTED,car_road_race,"[driver.Driver_ID, race.Driver_ID, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.name FROM driver WHERE driver.Driver_ID NOT IN (SELECT race.Driver_ID FROM race);,SELECT Driver_Name FROM driver WHERE Driver_ID NOT IN (SELECT Driver_ID FROM race),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of drivers. Use the FROM clause to specify the driver table. Apply a WHERE clause to filter drivers who do not participate in any race by ensuring their Driver_ID is not present in the race table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude drivers whose Driver_ID appears in the race table, meaning they participate in races. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Driver_ID entries in the race table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",0.0
1483,What is average price of goods whose flavor is blackberry or blueberry?,EASY,bakery_1,"[goods.Price, goods.Flavor]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT AVG(goods.Price) AS average_price FROM goods WHERE goods.Flavor = 'blackberry' OR goods.Flavor = 'blueberry';,"SELECT avg(price) FROM goods WHERE flavor  =  ""Blackberry"" OR flavor  =  ""Blueberry""","1. Sequential Structure: Begin with the SELECT clause to calculate the average price of goods. 2. Condition Structure: Use a WHERE clause to filter goods whose flavor is either ""blackberry"" or ""blueberry"". 3. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 4. Aggregation Structure: Use the AVG function to calculate the average price of the filtered goods.",0.0
1484,Find all receipts which has the latest date. Also tell me that date.,NESTED,bakery_1,"[receipts.ReceiptNumber,receipts.Date]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT ReceiptNumber, Date FROM receipts WHERE Date = (SELECT MAX(Date) FROM receipts);","SELECT ReceiptNumber ,  date FROM receipts WHERE date  =  (SELECT date FROM receipts ORDER BY date DESC LIMIT 1)","1. Sequential Structure: Start with the SELECT clause to retrieve the receipt numbers and the date. Use the FROM clause to specify the receipts table. Apply a WHERE clause to filter for receipts with the latest date. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the maximum date in the receipts table. 3. Join Structure: Not required, as all data is in the receipts table. 4. Aggregation Structure: Use MAX in a subquery to find the latest date, which is then used in the filtering condition.",1.0
1485,"What are the last names and ids of users who have searched two or fewer times, and own two or more properties?",NESTED,real_estate_rentals,"[Users.last_name, Users.user_id, User_Searches.user_id, User_Searches.search_seq, Properties.owner_user_id, Properties.property_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Users.last_name, Users.user_id FROM Users LEFT JOIN User_Searches ON Users.user_id = User_Searches.user_id LEFT JOIN Properties ON Users.user_id = Properties.owner_user_id GROUP BY Users.user_id, Users.last_name HAVING COUNT(DISTINCT User_Searches.search_seq) <= 2 AND COUNT(DISTINCT Properties.property_id) >= 2;","SELECT T1.last_name ,  T1.user_id FROM Users AS T1 JOIN User_Searches AS T2 ON T1.user_id  =  T2.user_id GROUP BY T1.user_id HAVING count(*)  <=  2 INTERSECT SELECT T3.last_name ,  T3.user_id FROM Users AS T3 JOIN Properties AS T4 ON T3.user_id  =  T4.owner_user_id GROUP BY T3.user_id HAVING count(*)  >=  2;","1. Sequential Structure: Start with the SELECT clause to retrieve the last names and IDs of users. Use the FROM clause to specify the Users table. Join it with the User_Searches table to count the number of searches per user and with the Properties table to count the number of properties owned by each user. Apply GROUP BY to group by user_id and last_name. Use the HAVING clause to filter users who have searched two or fewer times and own two or more properties. 2. Condition Structure: Use the HAVING clause to filter users based on two conditions: (1) the count of searches is less than or equal to 2, and (2) the count of properties owned is greater than or equal to 2. 3. Join Structure: Use INNER JOIN between Users and User_Searches on user_id to count searches, and another INNER JOIN between Users and Properties on user_id to count properties owned. 4. Aggregation Structure: Use COUNT to calculate the number of searches and properties owned for each user, and apply the conditions in the HAVING clause.",1.0
1486,How many cusomters visited on each date?,NON-NESTED,bakery_1,"[receipts.Date, receipts.CustomerId, customers.Id = receipts.CustomerId]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT receipts.Date, COUNT(receipts.CustomerId) AS CustomerCount FROM receipts JOIN customers ON customers.Id = receipts.CustomerId GROUP BY receipts.Date;","SELECT date ,  COUNT (DISTINCT CustomerId) FROM receipts GROUP BY date","1. Sequential Structure: Start with the SELECT clause to retrieve the date and the count of customers who visited on each date. Use COUNT to count the number of customers. 2. Condition Structure: No specific filtering condition is required, as we need data for all dates. 3. Join Structure: Use a JOIN between the ""receipts"" and ""customers"" tables based on ""CustomerId"" to associate each receipt with its respective customer. 4. Aggregation Structure: Use COUNT on ""receipts.CustomerId"" to count the number of customers for each date, and GROUP BY ""receipts.Date"" to group the results by date.",1.0
1487,What are the distinct ids and prices for goods that cost less than the average good?,NESTED,bakery_1,"[goods.Id, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT DISTINCT Id, Price FROM goods WHERE Price < (SELECT AVG(Price) FROM goods);","SELECT DISTINCT id ,  price FROM goods WHERE price  <  (SELECT avg(price) FROM goods)","1. Sequential Structure: Start with the SELECT clause to retrieve distinct IDs and prices of goods. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter goods whose prices are less than the average price of all goods. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average price of all goods and filter goods with prices below this value. 3. Join Structure: Not required, as all data is in the goods table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average price of goods, which is then used in the filtering condition.",1.0
1488,"What are the names of the different official languages, as well as the number of countries that speak each?",NON-NESTED,country_language,"[languages.name, official_languages.language_id = languages.id, official_languages.country_id = countries.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
","SELECT languages.name, COUNT(countries.id) AS num_countries FROM languages JOIN official_languages ON official_languages.language_id = languages.id JOIN countries ON official_languages.country_id = countries.id GROUP BY languages.name;","SELECT T2.name ,  COUNT(*) FROM official_languages AS T1 JOIN languages AS T2 ON T1.language_id  =  T2.id GROUP BY T2.name","1. Sequential Structure: Start with the SELECT clause to retrieve the names of the official languages and the count of countries that speak each language. Use COUNT to count the number of countries for each language. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""languages"" table with the ""official_languages"" table on ""languages.id = official_languages.language_id"" and the ""official_languages"" table with the ""countries"" table on ""official_languages.country_id = countries.id."" 4. Aggregation Structure: Use GROUP BY on ""languages.name"" to group the results by each language, and apply COUNT to count the number of countries for each language.",1.0
1489,List the names of languages that are not the official language of any countries.,NESTED,country_language,"[languages.name, official_languages.language_id, languages.id = official_languages.language_id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT languages.name FROM languages WHERE languages.id NOT IN (SELECT language_id FROM official_languages);,SELECT name FROM languages WHERE id NOT IN (SELECT language_id FROM official_languages),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of languages. Use the FROM clause to specify the languages table. Apply a WHERE clause to filter languages that are not the official language of any country. 2. Condition Structure: Use the WHERE clause with a subquery to exclude languages whose IDs appear in the official_languages table, as these are official languages of some countries. 3. Join Structure: Not required, as we only need to filter based on the absence of matching language IDs in the official_languages table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1490,Give the ids of Cookies or Cakes that cost between 3 and 7 dollars.,EASY,bakery_1,"[goods.Id, goods.Food, goods.Price, Cookies, Cakes, 3, 7]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Id FROM goods WHERE (goods.Food = 'Cookies' OR goods.Food = 'Cakes') AND goods.Price BETWEEN 3 AND 7;,"SELECT id FROM goods WHERE food  =  ""Cookie"" OR food  =  ""Cake"" AND price BETWEEN 3 AND 7","1. Sequential Structure: Start with the SELECT clause to retrieve the ""goods.Id"" of items that match the specified conditions. 2. Condition Structure: Use a WHERE clause to filter for items where ""goods.Food"" is either 'Cookies' or 'Cakes' and ""goods.Price"" is between 3 and 7 dollars. 3. Join Structure: No JOIN is required since all necessary information is in the ""goods"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving IDs based on specific conditions.",0.0
1491,How many kinds of room sizes are listed?,EASY,real_estate_rentals,[Rooms.room_size],"Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT COUNT(DISTINCT Rooms.room_size) FROM Rooms;,SELECT count(DISTINCT room_size) FROM Rooms;,"1. Sequential Structure: Begin with the SELECT clause to count the distinct room sizes, as the question asks for the number of unique room sizes. 2. Condition Structure: No specific filtering condition is required since we are interested in all room sizes. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Rooms"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Rooms.room_size"" to count the unique room sizes.",1.0
1492,How many drivers receive points greater than 150 for each make? Show the make and the count.,NON-NESTED,car_racing,"[driver.Make, driver.Points, team_driver.Driver_ID = driver.Driver_ID, 150]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT driver.Make, COUNT(driver.Driver_ID) AS driver_count FROM driver WHERE driver.Points > 150 GROUP BY driver.Make;","SELECT make ,  count(*) FROM driver WHERE points  >  150 GROUP BY make","1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Make"" and the count of drivers. Use COUNT to count the number of drivers for each make. 2. Condition Structure: Use a WHERE clause to filter drivers whose ""Points"" are greater than 150. 3. Join Structure: No JOIN is necessary as the required data is available in the ""driver"" table. 4. Aggregation Structure: Use GROUP BY on ""driver.Make"" to group the results by each make and apply COUNT to count the number of drivers for each make.",1.0
1493,What is the lowest room count across all the properties?,EASY,real_estate_rentals,[Properties.room_count],"Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT MIN(Properties.room_count) AS lowest_room_count FROM Properties;,SELECT min(room_count) FROM Properties;,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the lowest room count. 2. Aggregation Structure: Use the MIN function to calculate the minimum room count across all properties. 3. Condition Structure: No specific filtering condition is required as we are calculating the minimum value across all records. 4. Join Structure: No JOIN is required since all necessary data is within the ""Properties"" table.",1.0
1494,What are the receipt numbers for a customer with the last name Logan who purchased a croissant?,NON-NESTED,bakery_1,"[customers.LastName,customers.Id = receipts.CustomerId,receipts.ReceiptNumber,goods.Food,goods.Id = items.Item,items.Receipt,Logan,croissant]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT receipts.ReceiptNumber FROM customers JOIN receipts ON customers.Id = receipts.CustomerId JOIN items ON receipts.ReceiptNumber = items.Receipt JOIN goods ON goods.Id = items.Item WHERE customers.LastName = 'Logan' AND goods.Food = 'croissant';,"SELECT T1.ReceiptNumber FROM receipts AS T1 JOIN items AS T2 ON T1.ReceiptNumber  =  T2.receipt JOIN goods AS T3 ON T2.item  =  T3.id JOIN customers AS T4 ON T4.Id  =  T1.CustomerId WHERE T3.food  =  ""Croissant"" AND T4.LastName  =  'LOGAN'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""receipts.ReceiptNumber"" for the specified customer and item. 2. Condition Structure: Use a WHERE clause to filter for customers with the last name ""Logan"" and for receipts that include the item ""croissant."" 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""customers"" with ""receipts"" on ""customers.Id = receipts.CustomerId"" to link customers with their receipts. Then, join ""receipts"" with ""items"" on ""receipts.ReceiptNumber = items.Receipt"" to link receipts with their items. Finally, join ""items"" with ""goods"" on ""goods.Id = items.Item"" to identify the specific item purchased. 4. Aggregation Structure: No aggregation is needed, as we are retrieving specific receipt numbers.",0.0
1495,Which country has the greatest number of official languages?,NON-NESTED,country_language,"[countries.id, countries.name, official_languages.country_id = countries.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT countries.name FROM countries JOIN official_languages ON countries.id = official_languages.country_id GROUP BY countries.id ORDER BY COUNT(official_languages.country_id) DESC LIMIT 1;,SELECT T1.Name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id GROUP BY T1.id ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the country. Use COUNT to determine the number of official languages for each country. Use ORDER BY in descending order to rank countries by the number of official languages and LIMIT 1 to get the country with the greatest number. 2. Condition Structure: No specific filtering condition is required, as we are considering all countries. 3. Join Structure: Use a JOIN between the ""countries"" table and the ""official_languages"" table based on ""countries.id"" and ""official_languages.country_id"" to associate each country with its official languages. 4. Aggregation Structure: Use COUNT to count the number of official languages for each country, then GROUP BY ""countries.id"" to group the results by country.",1.0
1496,Give me the first name and last name of customers who have bought apple flavor Tart.,NON-NESTED,bakery_1,"[customers.FirstName, customers.LastName, goods.Flavor, goods.Food, items.Item = goods.Id, receipts.CustomerId = customers.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT customers.FirstName, customers.LastName FROM customers JOIN receipts ON receipts.CustomerId = customers.Id JOIN items ON receipts.Id = items.ReceiptId JOIN goods ON items.Item = goods.Id WHERE goods.Flavor = 'apple' AND goods.Food = 'Tart';","SELECT DISTINCT T4.FirstName ,  T4.LastName FROM goods AS T1 JOIN items AS T2 ON T1.id  =  T2.item JOIN receipts AS T3 ON T2.receipt  =  T3.ReceiptNumber JOIN customers AS T4 ON T3.CustomerId  =  T4.id WHERE T1.flavor  =  ""Apple"" AND T1.food  =  ""Tart""","1. Sequential Structure: Start with the SELECT clause to retrieve ""customers.FirstName"" and ""customers.LastName."" 2. Condition Structure: Use a WHERE clause to filter for records where the ""goods.Flavor"" is 'apple' and the ""goods.Food"" is 'Tart.' 3. Join Structure: Use JOINs to connect the ""customers,"" ""receipts,"" ""items,"" and ""goods"" tables. Specifically, join ""receipts.CustomerId"" with ""customers.Id,"" ""items.Item"" with ""goods.Id,"" and ensure the relationship between ""receipts"" and ""items"" is maintained. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific customer details.",0.0
1497,What are all the receipt numbers that have a good with a price above 10 or have the earliest date?,NESTED,bakery_1,"[receipts.ReceiptNumber,receipts.Date,goods.Price,items.Item = goods.Id,items.Receipt = receipts.ReceiptNumber]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT DISTINCT receipts.ReceiptNumber FROM receipts JOIN items ON receipts.ReceiptNumber = items.Receipt JOIN goods ON items.Item = goods.Id WHERE goods.Price > 10 OR receipts.Date = (SELECT MIN(Date) FROM receipts);,SELECT T1.Receipt FROM items AS T1 JOIN goods AS T2 ON T1.item  =  T2.id WHERE T2.price  >  10 UNION SELECT ReceiptNumber FROM receipts WHERE date  =  (SELECT date FROM receipts ORDER BY date LIMIT 1),"1. Sequential Structure: Start with the SELECT clause to retrieve the receipt numbers. Use the FROM clause to specify the receipts table. Join it with the items table to link receipts with goods through the goods table. Apply a WHERE clause to filter for receipts that either have a good with a price above 10 or have the earliest date. 2. Condition Structure: Use the WHERE clause with two conditions: one to check if the price of a good is greater than 10, and another to check if the receipt date is the earliest. Use an OR operator to combine these conditions. 3. Join Structure: Use JOINs between receipts, items, and goods tables. The items table connects receipts to goods through the ReceiptNumber and Id fields. 4. Aggregation Structure: Use MIN to find the earliest date in the receipts table, which is used in the filtering condition.",1.0
1498,What are the constructors who are used by both drivers who are younger than 20 and drivers older than 30?,NESTED,car_road_race,"[driver.Constructor, driver.Age, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Constructor FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID WHERE driver.Age < 20 INTERSECT SELECT driver.Constructor FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID WHERE driver.Age > 30;,SELECT CONSTRUCTOR FROM driver WHERE Age  <  20 INTERSECT SELECT CONSTRUCTOR FROM driver WHERE Age  >  30,"1. Sequential Structure: Start with the SELECT clause to retrieve the constructors used by drivers. Use the FROM clause to specify the driver table and JOIN it with the race table to connect drivers with their constructors. Apply a WHERE clause to filter drivers based on their age (younger than 20 and older than 30). Use INTERSECT to find constructors used by both groups of drivers. 2. Condition Structure: Use the WHERE clause to filter drivers younger than 20 in one query and drivers older than 30 in another query. Use INTERSECT to find common constructors between these two groups. 3. Join Structure: Use an INNER JOIN between the driver and race tables based on Driver_ID to connect drivers with their constructors. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1499,Find the ids of customers whose average spending for each good is above 5.,NESTED,bakery_1,"[customers.Id,receipts.CustomerId,goods.Id,items.Item,items.Receipt = receipts.ReceiptNumber,goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT customers.Id FROM customers JOIN receipts ON customers.Id = receipts.CustomerId JOIN items ON receipts.ReceiptNumber = items.Receipt JOIN goods ON items.Item = goods.Id GROUP BY customers.Id, goods.Id HAVING AVG(goods.Price) > 5;",SELECT T3.CustomerId FROM goods AS T1 JOIN items AS T2 ON T1.id  =  T2.item JOIN receipts AS T3 ON T2.receipt  =  T3.ReceiptNumber GROUP BY T3.CustomerId HAVING avg(T1.price)  >  5,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of customers. Use the FROM clause to specify the relevant tables. Use GROUP BY to group data by customer ID and goods ID to calculate the average spending for each good. Apply a HAVING clause to filter customers whose average spending for each good is above 5. 2. Condition Structure: Use the HAVING clause to filter groups where the average spending (calculated as the sum of goods prices divided by the count of items) is greater than 5. 3. Join Structure: Use JOINs to connect the customers, receipts, items, and goods tables. The receipts table is joined with customers on CustomerId, items on ReceiptNumber, and goods on Item. 4. Aggregation Structure: Use AVG or SUM/COUNT to calculate the average spending for each good by each customer and filter based on the condition.",1.0
1500,"Return the names of langauges that contain the substring ""ish"".",EASY,country_language,[languages.name],"Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT languages.name FROM languages WHERE languages.name LIKE '%ish%';,"SELECT name FROM languages WHERE name LIKE ""%ish%""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""languages.name"" field, as the query asks for the names of languages. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for language names that contain the substring ""ish"". 3. Join Structure: No JOIN is required since all necessary information is in the ""languages"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving language names based on a specific condition.",1.0
1501,What are all the flavors of croissant?,EASY,bakery_1,"[goods.Flavor, goods.Food]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Flavor FROM goods WHERE goods.Food = 'croissant';,"SELECT flavor FROM goods WHERE food  =  ""Croissant""","1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""goods.Flavor"" since the question asks for all flavors of croissant. 2. Condition Structure: Use a WHERE clause to filter for rows where ""goods.Food"" is 'croissant'. 3. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all flavors of croissant.",0.0
1502,Give the last names of customers who have been to the bakery more than 10 times?,NON-NESTED,bakery_1,"[customers.LastName, receipts.CustomerId, receipts.ReceiptNumber, items.Receipt, receipts.ReceiptNumber, items.Item]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT customers.LastName FROM customers JOIN receipts ON customers.CustomerId = receipts.CustomerId GROUP BY customers.LastName HAVING COUNT(receipts.ReceiptNumber) > 10;,SELECT T2.LastName FROM receipts AS T1 JOIN customers AS T2 ON T1.CustomerId  =  T2.id GROUP BY T2.id HAVING count(*)  >  10,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""customers.LastName."" 2. Condition Structure: Use a HAVING clause to filter customers who have been to the bakery more than 10 times. This requires counting the number of receipts associated with each customer. 3. Join Structure: Use a JOIN between the ""customers"" and ""receipts"" tables based on ""customers.CustomerId"" and ""receipts.CustomerId"" to link each customer with their receipts. 4. Aggregation Structure: Use COUNT on ""receipts.ReceiptNumber"" to count the number of visits (receipts) per customer, then filter with HAVING to select customers with more than 10 visits.",0.0
1503,Give the average price for each food type.,EASY,bakery_1,"[goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Food, AVG(goods.Price) AS avg_price FROM goods GROUP BY goods.Food;","SELECT avg(price) ,  food FROM goods GROUP BY food","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the food type and the average price. 2. Aggregation Structure: Use the AVG function to calculate the average price for each food type. 3. Grouping Structure: Use GROUP BY on ""goods.Food"" to calculate the average price for each food type. 4. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table.",1.0
1504,Return the number of different room sizes.,EASY,real_estate_rentals,[Rooms.room_size],"Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT COUNT(DISTINCT Rooms.room_size) FROM Rooms;,SELECT count(DISTINCT room_size) FROM Rooms;,"1. Sequential Structure: Begin with the SELECT clause to count the number of distinct room sizes. 2. Condition Structure: No specific filtering condition is required since we are interested in all room sizes. 3. Join Structure: No JOIN is necessary as the required information is available within the ""Rooms"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique room sizes.",1.0
1505,What was the time of the most recent search?,EASY,real_estate_rentals,[User_Searches.search_datetime],"Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT MAX(User_Searches.search_datetime) AS most_recent_search FROM User_Searches;,SELECT max(search_datetime) FROM User_Searches;,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the most recent search time. 2. Aggregation Structure: Use the MAX function to find the most recent search time from the ""User_Searches.search_datetime"" field. 3. Condition Structure: No specific filtering condition is required since we are looking for the most recent search time across all records. 4. Join Structure: No JOIN is required as all necessary data is within the ""User_Searches"" table.",1.0
1506,What are the ids of goods whose price is above twice the average price of all goods?,NESTED,bakery_1,"[goods.Id, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT Id FROM goods WHERE Price > 2 * (SELECT AVG(Price) FROM goods);,SELECT id FROM goods WHERE price  >  (SELECT avg(price) FROM goods),"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of goods. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter goods whose price is above twice the average price of all goods. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average price of all goods, and filter for goods whose price is greater than twice this average. 3. Join Structure: Not required, as all data is in the goods table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average price of all goods, and use this value in the filtering condition.",0.0
1507,What is the detailed description of the age category code 'Over 60'?,EASY,real_estate_rentals,"[Ref_Age_Categories.age_category_code, Ref_Age_Categories.age_category_description, 'Over 60']","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Ref_Age_Categories.age_category_description FROM Ref_Age_Categories WHERE Ref_Age_Categories.age_category_code = 'Over 60';,SELECT age_category_description FROM Ref_Age_Categories WHERE age_category_code  =  'Over 60';,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Ref_Age_Categories.age_category_description"" for the age category code 'Over 60'. 2. Condition Structure: Use a WHERE clause to filter for the specific age category code 'Over 60'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Ref_Age_Categories"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
1508,Give the average justice scores across all countries.,EASY,country_language,[countries.justice_score],"Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT AVG(countries.justice_score) AS avg_justice_score FROM countries;,SELECT avg(justice_score) FROM countries,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average justice score. 2. Aggregation Structure: Use the AVG function to calculate the average justice score across all countries. 3. Condition Structure: No specific filtering condition is required as the query involves all countries. 4. Join Structure: No JOIN is required since all necessary data is within the ""countries"" table.",1.0
1509,"What are the names of languages, in alphabetical order?",EASY,country_language,[languages.name],"Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT languages.name FROM languages ORDER BY languages.name ASC;,SELECT name FROM languages ORDER BY name ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the language name. 2. Condition Structure: No specific filtering condition is required as we want all language names. 3. Join Structure: No JOIN is required since all necessary data is within the ""languages"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the language names. 5. Ordering Structure: Use ORDER BY in ascending order to sort the language names alphabetically.",1.0
1510,What is the average number of rooms in a property?,NON-NESTED,real_estate_rentals,"[Rooms.room_number, Rooms.property_id, Properties.property_id = Rooms.property_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT AVG(room_count) AS average_rooms FROM ( SELECT COUNT(Rooms.room_number) AS room_count FROM Rooms JOIN Properties ON Properties.property_id = Rooms.property_id GROUP BY Properties.property_id ) AS subquery;,SELECT avg(room_count) FROM Properties;,"1. Sequential Structure: Start with the SELECT clause to calculate the average number of rooms in a property. Use the AVG function to compute the average. 2. Condition Structure: No specific filtering condition is required, as the question asks for the average across all properties. 3. Join Structure: Use a JOIN between the ""Rooms"" and ""Properties"" tables based on the shared key ""property_id"" to associate rooms with their respective properties. 4. Aggregation Structure: Use the AVG function on the count of ""Rooms.room_number"" grouped by ""Properties.property_id"" to calculate the average number of rooms per property.",0.0
1511,What are all the user searches time and content? Sort the result descending by content.,EASY,real_estate_rentals,"[User_Searches.search_datetime, User_Searches.search_string]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT User_Searches.search_datetime, User_Searches.search_string FROM User_Searches ORDER BY User_Searches.search_string DESC;","SELECT search_datetime ,  search_string FROM User_Searches ORDER BY search_string DESC;","1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""User_Searches.search_datetime"" and ""User_Searches.search_string"" as the question asks for all user searches' time and content. 2. Condition Structure: No specific filtering condition is required since the query asks for all user searches. 3. Join Structure: No JOIN is required as all necessary information is in the ""User_Searches"" table. 4. Aggregation Structure: No aggregation is needed as the query does not involve any summarization or grouping. 5. Ordering Structure: Use ORDER BY in descending order on ""User_Searches.search_string"" to sort the results by content.",1.0
1512,Count the number of properties that have 1 parking lot or 1 garage.,EASY,real_estate_rentals,"[Properties.parking_lots, Properties.garage_yn]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT COUNT(*) FROM Properties WHERE Properties.parking_lots = 1 OR Properties.garage_yn = 1;,SELECT count(*) FROM Properties WHERE parking_lots  =  1 OR garage_yn  =  1;,"1. Sequential Structure: Start with the SELECT clause to count the number of properties that meet the specified conditions. 2. Condition Structure: Use a WHERE clause to filter properties that have either 1 parking lot or 1 garage. 3. Join Structure: No JOIN is required since all necessary information is in the ""Properties"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of properties that satisfy the conditions.",1.0
1513,"What are highest, lowest, and average prices of goods, grouped and ordered by flavor?",EASY,bakery_1,"[goods.Flavor, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Flavor, MAX(goods.Price) AS highest_price, MIN(goods.Price) AS lowest_price, AVG(goods.Price) AS average_price FROM goods GROUP BY goods.Flavor ORDER BY goods.Flavor;","SELECT max(price) ,  min(price) ,  avg(price) ,  flavor FROM goods GROUP BY flavor ORDER BY flavor","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the flavor and the aggregate values (highest, lowest, and average prices). 2. Aggregation Structure: Use MAX, MIN, and AVG functions to calculate the highest, lowest, and average prices for goods grouped by flavor. 3. Grouping Structure: Use GROUP BY on ""goods.Flavor"" to calculate these aggregate values for each flavor. 4. Ordering Structure: Use ORDER BY on ""goods.Flavor"" to sort the results by flavor. 5. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table.",1.0
1514,What is the item that was bought the least number of times?,NON-NESTED,bakery_1,"[items.Item, items.Receipt, goods.Id = items.Item]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT items.Item FROM items JOIN goods ON goods.Id = items.Item GROUP BY items.Item ORDER BY COUNT(items.Item) ASC LIMIT 1;,SELECT item FROM items GROUP BY item ORDER BY count(*) LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""items.Item"" field, which represents the item name. Use an aggregate function (COUNT) to count the number of times each item was bought. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all items. 3. Join Structure: Use a JOIN between the ""goods"" and ""items"" tables based on the relationship ""goods.Id = items.Item"" to link each item with its purchase records. 4. Aggregation Structure: Use COUNT to count the occurrences of each item in the ""items"" table. Use ORDER BY in ascending order on the count to rank items by the number of times they were bought. Use LIMIT 1 to select the item with the least number of purchases.",1.0
1515,Return the full names of users who live in properties that they own.,NON-NESTED,real_estate_rentals,"[Users.first_name, Users.middle_name, Users.last_name, Users.user_id, Properties.owner_user_id, Properties.property_address_id = Addresses.address_id, Users.user_address_id = Addresses.address_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Users.first_name, Users.middle_name, Users.last_name FROM Users JOIN Addresses ON Users.user_address_id = Addresses.address_id JOIN Properties ON Properties.property_address_id = Addresses.address_id WHERE Users.user_id = Properties.owner_user_id;","SELECT first_name ,  middle_name ,  last_name FROM Properties AS T1 JOIN Users AS T2 ON T1.owner_user_id  =  T2.user_id WHERE T1.property_address_id  =  T2.user_address_id;","1. Sequential Structure: Start with the SELECT clause to retrieve the full names of users, which include ""Users.first_name,"" ""Users.middle_name,"" and ""Users.last_name."" 2. Condition Structure: Use a WHERE clause to filter for users who live in properties that they own. This requires matching ""Users.user_id"" with ""Properties.owner_user_id"" and ensuring that the user's address matches the property's address by comparing ""Users.user_address_id"" with ""Addresses.address_id"" and ""Properties.property_address_id"" with ""Addresses.address_id."" 3. Join Structure: Use JOINs to connect the ""Users,"" ""Properties,"" and ""Addresses"" tables. Join ""Users"" with ""Addresses"" on ""Users.user_address_id = Addresses.address_id"" and ""Properties"" with ""Addresses"" on ""Properties.property_address_id = Addresses.address_id."" 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving individual user details.",1.0
1516,What was the registration date for the user whose login name is ratione?,EASY,real_estate_rentals,"[Users.date_registered, Users.login_name]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Users.date_registered FROM Users WHERE Users.login_name = 'ratione';,SELECT date_registered FROM Users WHERE login_name  =  'ratione';,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Users.date_registered"" for the user whose login name is ""ratione"". 2. Condition Structure: Use a WHERE clause to filter for the specific login name ""ratione"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Users"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
1517,How is the feature rooftop described?,EASY,real_estate_rentals,"[Features.feature_name, Features.feature_description]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Features.feature_description FROM Features WHERE Features.feature_name = 'rooftop';,SELECT feature_description FROM Features WHERE feature_name  =  'rooftop';,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Features.feature_description"" for the feature named ""rooftop."" 2. Condition Structure: Use a WHERE clause to filter for the feature where ""Features.feature_name"" is ""rooftop."" 3. Join Structure: No JOIN is required since all necessary information is in the ""Features"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a specific description based on a condition.",1.0
1518,Show the names of countries in descending order of overall scores.,EASY,country_language,"[countries.name, countries.overall_score]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT countries.name FROM countries ORDER BY countries.overall_score DESC;,SELECT name FROM countries ORDER BY overall_score DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the country name. Include the overall score for sorting purposes. 2. Condition Structure: No specific filtering condition is required as we want all countries. 3. Join Structure: No JOIN is required since all necessary data is within the ""countries"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in descending order based on ""countries.overall_score"".",1.0
1519,What are the feature name and description of the most commonly seen feature across properties?,NON-NESTED,real_estate_rentals,"[Features.feature_name, Features.feature_description, Property_Features.feature_id, Property_Features.property_id, Property_Features.feature_id = Features.feature_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Features.feature_name, Features.feature_description FROM Features JOIN Property_Features ON Property_Features.feature_id = Features.feature_id GROUP BY Features.feature_id ORDER BY COUNT(Property_Features.feature_id) DESC LIMIT 1;","SELECT T1.feature_name ,  T1.feature_description FROM Features AS T1 JOIN Property_Features AS T2 ON T1.feature_id  =  T2.feature_id GROUP BY T1.feature_name ORDER BY count(*) DESC LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve ""Features.feature_name"" and ""Features.feature_description."" 2. Condition Structure: No specific filtering condition is needed, as we are looking for the most commonly seen feature across all properties. 3. Join Structure: Use a JOIN between the ""Features"" table and the ""Property_Features"" table on ""Property_Features.feature_id = Features.feature_id"" to link features with their occurrences in properties. 4. Aggregation Structure: Use COUNT on ""Property_Features.feature_id"" to count the occurrences of each feature across properties. Use ORDER BY in descending order to rank features by their count and LIMIT 1 to select the most commonly seen feature.",1.0
1520,Give the category description of the age category 'Over 60'.,EASY,real_estate_rentals,"[Ref_Age_Categories.age_category_description, Ref_Age_Categories.age_category_code, Over 60]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Ref_Age_Categories.age_category_description FROM Ref_Age_Categories WHERE Ref_Age_Categories.age_category_code = 'Over 60';,SELECT age_category_description FROM Ref_Age_Categories WHERE age_category_code  =  'Over 60';,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Ref_Age_Categories.age_category_description"" for the age category 'Over 60'. 2. Condition Structure: Use a WHERE clause to filter for the specific ""Ref_Age_Categories.age_category_code"" that matches 'Over 60'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Ref_Age_Categories"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
1521,"What are the names of the official languages, sorted descending by the average overall scores across the countries that correspond to each?",NON-NESTED,country_language,"[languages.name, countries.overall_score, official_languages.language_id = languages.id, official_languages.country_id = countries.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
","SELECT languages.name, AVG(countries.overall_score) AS average_score FROM languages JOIN official_languages ON official_languages.language_id = languages.id JOIN countries ON official_languages.country_id = countries.id GROUP BY languages.name ORDER BY average_score DESC;",SELECT T3.name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id GROUP BY T3.id ORDER BY avg(T1.overall_score) DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the official languages. Additionally, calculate the average overall scores across the countries for each language using the AVG function. 2. Condition Structure: No specific filtering condition is required, as we are interested in all official languages and their corresponding average scores. 3. Join Structure: Use JOINs to connect the ""languages"" table with the ""official_languages"" table on ""languages.id = official_languages.language_id"" and the ""official_languages"" table with the ""countries"" table on ""official_languages.country_id = countries.id"" to link languages with their respective countries and scores. 4. Aggregation Structure: Use AVG to calculate the average overall score for each language, and GROUP BY the language name to ensure the aggregation is performed for each language. Finally, use ORDER BY in descending order to sort the results by the average overall scores.",1.0
1522,What are the average laps of all the drivers who are younger than 20?,EASY,car_racing,"[driver.Laps, driver.Age]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT AVG(driver.Laps) AS average_laps FROM driver WHERE driver.Age < 20;,SELECT avg(Laps) FROM driver WHERE age  <  20,"1. Sequential Structure: Begin with the SELECT clause to calculate the average laps of drivers. 2. Condition Structure: Use a WHERE clause to filter for drivers who are younger than 20 years old. 3. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table. 4. Aggregation Structure: Use the AVG function to calculate the average laps for the filtered drivers.",1.0
1523,Give the ids of goods that cost less than 3 dollars.,EASY,bakery_1,"[goods.Id, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Id FROM goods WHERE goods.Price < 3;,SELECT id FROM goods WHERE price  <  3,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""goods.Id"". 2. Condition Structure: Use a WHERE clause to filter goods where the ""goods.Price"" is less than 3 dollars. 3. Join Structure: No JOIN is required since all necessary information is in the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the IDs of goods that meet the specified price condition.",1.0
1524,"What are the ids of users who have only made one search, and what are their category codes?",NESTED,real_estate_rentals,"[User_Searches.user_id,User_Searches.search_seq,Users.user_id,Users.user_category_code,User_Searches.user_id = Users.user_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT User_Searches.user_id, Users.user_category_code FROM User_Searches JOIN Users ON User_Searches.user_id = Users.user_id GROUP BY User_Searches.user_id, Users.user_category_code HAVING COUNT(User_Searches.search_seq) = 1;","SELECT T1.user_category_code ,  T1.user_id FROM Users AS T1 JOIN User_Searches AS T2 ON T1.user_id  =  T2.user_id GROUP BY T1.user_id HAVING count(*)  =  1;",1. Sequential Structure: Start with the SELECT clause to retrieve the user IDs and their category codes. Use the FROM clause to specify the User_Searches and Users tables. Apply a GROUP BY clause on user_id to count the number of searches made by each user. Use the HAVING clause to filter users who have made only one search. 2. Condition Structure: Use the HAVING clause with COUNT(search_seq) = 1 to filter users who have made exactly one search. 3. Join Structure: Use an INNER JOIN between the User_Searches and Users tables based on user_id to connect user search data with user category codes. 4. Aggregation Structure: Use COUNT(search_seq) to count the number of searches made by each user and filter for users with only one search.,1.0
1525,What is the receipt number and date of the receipt in which the most expensive item was bought?,NESTED,bakery_1,"[goods.Price,goods.Id = items.Item,items.Receipt,receipts.ReceiptNumber,receipts.Date]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT receipts.ReceiptNumber, receipts.Date FROM receipts JOIN items ON receipts.ReceiptNumber = items.Receipt JOIN goods ON goods.Id = items.Item WHERE goods.Price = (SELECT MAX(Price) FROM goods);","SELECT T1.ReceiptNumber ,  T1.Date FROM receipts AS T1 JOIN items AS T2 ON T1.ReceiptNumber  =  T2.receipt JOIN goods AS T3 ON T2.item  =  T3.id ORDER BY T3.price DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the receipt number and date. Use the FROM clause to specify the receipts table and join it with the items and goods tables to connect receipts with the items and their prices. Apply a WHERE clause to filter for the receipt containing the most expensive item. 2. Condition Structure: Use a WHERE clause with a subquery to filter for the item with the maximum price. 3. Join Structure: Use JOINs between goods, items, and receipts tables based on the relationships goods.Id = items.Item and items.Receipt = receipts.ReceiptNumber to connect the price of items to their respective receipts. 4. Aggregation Structure: Use MAX to find the maximum price of an item and filter based on this value to retrieve the relevant receipt details.",1.0
1526,In which country does the user with first name Robbie live?,NON-NESTED,real_estate_rentals,"[Users.first_name,Users.user_address_id,Addresses.country,Users.first_name = 'Robbie',Users.user_address_id = Addresses.address_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Addresses.country FROM Users JOIN Addresses ON Users.user_address_id = Addresses.address_id WHERE Users.first_name = 'Robbie';,SELECT T1.country FROM Addresses AS T1 JOIN Users AS T2 ON T1.address_id  =  T2.user_address_id WHERE T2.first_name  =  'Robbie';,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Addresses.country"" field, as the question asks for the country where the user lives. 2. Condition Structure: Use a WHERE clause to filter for the user whose ""Users.first_name"" is 'Robbie.' 3. Join Structure: Use a JOIN between the ""Users"" table and the ""Addresses"" table based on the relationship ""Users.user_address_id = Addresses.address_id"" to link each user with their corresponding address. 4. Aggregation Structure: No aggregation is needed since we are retrieving a single value based on the specified condition.",1.0
1527,What are the zip codes of properties which do not belong to users who own at most 2 properties?,NESTED,real_estate_rentals,"[Properties.property_id,Users.user_id,Properties.owner_user_id = Users.user_id,Properties.property_address_id = Addresses.address_id,Addresses.zip_postcode]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Addresses.zip_postcode FROM Properties JOIN Addresses ON Properties.property_address_id = Addresses.address_id WHERE Properties.owner_user_id NOT IN ( SELECT owner_user_id FROM Properties GROUP BY owner_user_id HAVING COUNT(property_id) <= 2 );,SELECT T1.zip_postcode FROM Addresses AS T1 JOIN Properties AS T2 ON T1.address_id  =  T2.property_address_id WHERE T2.owner_user_id NOT IN ( SELECT owner_user_id FROM Properties GROUP BY owner_user_id HAVING count(*)  <=  2 );,1. Sequential Structure: Start with the SELECT clause to retrieve the zip codes of properties. Use the FROM clause to specify the Properties and Addresses tables. Join these tables to connect property details with their zip codes. Use a WHERE clause to filter out properties owned by users who own at most 2 properties. 2. Condition Structure: Use a subquery in the WHERE clause to identify users who own more than 2 properties. Exclude properties owned by these users by ensuring the owner_user_id is not in the result of the subquery. 3. Join Structure: Use INNER JOIN between the Properties and Addresses tables based on property_address_id to link properties with their zip codes. 4. Aggregation Structure: Use COUNT in the subquery to count the number of properties owned by each user and filter for users owning at most 2 properties.,1.0
1528,"On average, how many rooms does a property have?",NON-NESTED,real_estate_rentals,"[Rooms.property_id, Rooms.room_number, Properties.property_id = Rooms.property_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT AVG(room_count) AS average_rooms FROM ( SELECT COUNT(Rooms.room_number) AS room_count FROM Rooms JOIN Properties ON Properties.property_id = Rooms.property_id GROUP BY Properties.property_id ) AS room_counts;,SELECT avg(room_count) FROM Properties;,"1. Sequential Structure: Start with the SELECT clause to calculate the average number of rooms per property. Use the AVG function to compute the average. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Rooms"" and ""Properties"" tables based on the shared ""property_id"" field to associate rooms with their respective properties. 4. Aggregation Structure: Use COUNT to count the number of rooms for each property, and then use AVG to calculate the average number of rooms across all properties.",0.0
1529,List the distinct ids of all customers who bought a cake with lemon flavor?,NON-NESTED,bakery_1,"[customers.Id,goods.Food,goods.Flavor,items.Item = goods.Id,receipts.CustomerId = customers.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT DISTINCT customers.Id FROM customers JOIN receipts ON receipts.CustomerId = customers.Id JOIN items ON receipts.Id = items.ReceiptId JOIN goods ON items.Item = goods.Id WHERE goods.Food = 'cake' AND goods.Flavor = 'lemon';,"SELECT DISTINCT T3.CustomerId FROM goods AS T1 JOIN items AS T2 ON T1.Id  =  T2.Item JOIN receipts AS T3 ON T2.Receipt  =  T3.ReceiptNumber WHERE T1.Flavor  =  ""Lemon"" AND T1.Food  =  ""Cake""","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""customers.Id"" of all customers who bought a cake with lemon flavor. 2. Condition Structure: Use a WHERE clause to filter for records where ""goods.Food"" is 'cake' and ""goods.Flavor"" is 'lemon.' 3. Join Structure: Use JOINs to connect the ""goods"" table with the ""items"" table on ""items.Item = goods.Id,"" and then connect the ""receipts"" table with the ""customers"" table on ""receipts.CustomerId = customers.Id."" This ensures we can trace the purchase of specific goods back to the customers. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique customer IDs are returned.",0.0
1530,Find the first name and last name of a customer who visited on the earliest date.,NON-NESTED,bakery_1,"[customers.FirstName, customers.LastName, receipts.Date, receipts.CustomerId = customers.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT customers.FirstName, customers.LastName FROM customers JOIN receipts ON receipts.CustomerId = customers.Id WHERE receipts.Date = (SELECT MIN(receipts.Date) FROM receipts);","SELECT T1.FirstName ,  T1.LastName FROM customers AS T1 JOIN receipts AS T2 ON T1.id  =  T2.CustomerId ORDER BY T2.date LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""customers.FirstName"" and ""customers.LastName."" 2. Condition Structure: Use a WHERE clause to filter for the record with the earliest date. To find the earliest date, use a subquery to get the minimum value of ""receipts.Date."" 3. Join Structure: Use a JOIN between the ""customers"" and ""receipts"" tables based on ""receipts.CustomerId = customers.Id"" to associate each receipt with the corresponding customer. 4. Aggregation Structure: Use MIN in a subquery to find the earliest date, and filter the main query using this value.",1.0
1531,Which official languages are spoken in two or more countries?,NON-NESTED,country_language,"[languages.name, official_languages.language_id, official_languages.country_id, countries.id = official_languages.country_id, languages.id = official_languages.language_id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT languages.name FROM languages JOIN official_languages ON languages.id = official_languages.language_id JOIN countries ON countries.id = official_languages.country_id GROUP BY languages.name HAVING COUNT(official_languages.country_id) >= 2;,SELECT T2.name FROM official_languages AS T1 JOIN languages AS T2 ON T1.language_id  =  T2.id GROUP BY T2.id HAVING COUNT(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of official languages. Use GROUP BY to group by the language name. 2. Condition Structure: Apply a HAVING clause to filter for languages that are spoken in two or more countries. 3. Join Structure: Use JOINs to connect the ""languages"" table with the ""official_languages"" table on ""languages.id = official_languages.language_id"" and the ""countries"" table on ""countries.id = official_languages.country_id"" to link languages with the countries where they are spoken. 4. Aggregation Structure: Use COUNT on ""official_languages.country_id"" to count the number of countries where each language is spoken, and filter with HAVING to select languages spoken in two or more countries.",1.0
1532,What is the full name of the customer who visited on the earliest date?,NON-NESTED,bakery_1,"[customers.Id, customers.LastName, customers.FirstName, receipts.CustomerId, receipts.Date, receipts.CustomerId = customers.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT customers.FirstName || ' ' || customers.LastName AS FullName FROM customers JOIN receipts ON receipts.CustomerId = customers.Id WHERE receipts.Date = (SELECT MIN(receipts.Date) FROM receipts);,"SELECT T1.FirstName ,  T1.LastName FROM customers AS T1 JOIN receipts AS T2 ON T1.id  =  T2.CustomerId ORDER BY T2.date LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the full name of the customer, which can be constructed by concatenating ""customers.FirstName"" and ""customers.LastName."" 2. Condition Structure: Use a WHERE clause to filter for the record with the earliest date. This can be achieved by using a subquery to find the minimum date in the ""receipts.Date"" column. 3. Join Structure: Use an INNER JOIN between the ""customers"" table and the ""receipts"" table on the condition ""receipts.CustomerId = customers.Id"" to link each receipt to its corresponding customer. 4. Aggregation Structure: Use MIN in a subquery to find the earliest date, and filter the main query using this value.",1.0
1533,What is the name of the country with the highest politics score?,EASY,country_language,"[countries.name, countries.politics_score]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT countries.name FROM countries ORDER BY countries.politics_score DESC LIMIT 1;,SELECT name FROM countries ORDER BY politics_score DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countries.name"" of the country with the highest politics score. 2. Condition Structure: No specific filtering condition is needed since we are looking for the country with the highest politics score. 3. Join Structure: No JOIN is required, as the information is available in the ""countries"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""countries.politics_score"" to rank countries by their politics score and apply LIMIT 1 to select the country with the highest score.",1.0
1534,What is the average overall score across countries with English as their official language?,NON-NESTED,country_language,"[countries.overall_score,official_languages.language_id = languages.id,official_languages.country_id = countries.id,languages.name,English]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT AVG(countries.overall_score) FROM countries JOIN official_languages ON countries.id = official_languages.country_id JOIN languages ON official_languages.language_id = languages.id WHERE languages.name = 'English';,"SELECT avg(T1.overall_score) FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id WHERE T3.name  =  ""English""","1. Sequential Structure: Start with the SELECT clause to calculate the average of ""countries.overall_score."" 2. Condition Structure: Use a WHERE clause to filter for countries where the official language is English. This requires checking the ""languages.name"" field for the value 'English.' 3. Join Structure: Use JOINs to connect the ""countries"" table with ""official_languages"" on ""countries.id = official_languages.country_id"" and ""official_languages"" with ""languages"" on ""official_languages.language_id = languages.id"" to link countries with their official languages. 4. Aggregation Structure: Use the AVG function to compute the average overall score for the filtered countries.",1.0
1535,How many types of Cake does this bakery sell?,EASY,bakery_1,"[goods.Food, goods.Flavor]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT COUNT(DISTINCT goods.Flavor) FROM goods WHERE goods.Food = 'Cake';,"SELECT count(*) FROM goods WHERE food  =  ""Cake""","1. Sequential Structure: Begin with the SELECT clause to count the distinct types of cakes sold by the bakery. 2. Condition Structure: Use a WHERE clause to filter for items in the ""goods"" table where the ""Food"" column indicates ""Cake"". 3. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on the ""Flavor"" column to count the unique types of cakes.",1.0
1536,List distinct receipt numbers for which someone bought a good that costs more than 13 dollars.,NON-NESTED,bakery_1,"[receipts.ReceiptNumber,items.Receipt,items.Item = goods.Id,goods.Price,13]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT DISTINCT receipts.ReceiptNumber FROM receipts JOIN items ON receipts.ReceiptNumber = items.Receipt JOIN goods ON items.Item = goods.Id WHERE goods.Price > 13;,SELECT DISTINCT T1.ReceiptNumber FROM receipts AS T1 JOIN items AS T2 ON T1.ReceiptNumber  =  T2.receipt JOIN goods AS T3 ON T2.item  =  T3.id WHERE T3.price  >  13,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct ""receipts.ReceiptNumber."" 2. Condition Structure: Use a WHERE clause to filter for goods with a price greater than 13 dollars. 3. Join Structure: Use JOINs to connect the ""receipts"" table with the ""items"" table on ""receipts.ReceiptNumber = items.Receipt"" and the ""items"" table with the ""goods"" table on ""items.Item = goods.Id"" to link receipts with the goods purchased. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique receipt numbers are returned.",1.0
1537,How many goods are available for each food type?,EASY,bakery_1,"[goods.Food, goods.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Food, COUNT(goods.Id) AS goods_count FROM goods GROUP BY goods.Food;","SELECT count(*) ,  food FROM goods GROUP BY food","1. Sequential Structure: Begin with the SELECT clause to specify the food type and the count of goods available for each food type. 2. Aggregation Structure: Use COUNT to calculate the number of goods for each food type. 3. Grouping Structure: Use GROUP BY on ""goods.Food"" to aggregate the results by each food type. 4. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table.",1.0
1538,"Where do the Senior Citizens live? List building, street, and the city.",NON-NESTED,real_estate_rentals,"[Users.user_id,Users.age_category_code,Ref_Age_Categories.age_category_code,Ref_Age_Categories.age_category_description,Users.user_address_id,Addresses.address_id,Addresses.line_1_number_building,Addresses.line_2_number_street,Addresses.town_city,Senior Citizens]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Addresses.line_1_number_building, Addresses.line_2_number_street, Addresses.town_city FROM Users JOIN Ref_Age_Categories ON Users.age_category_code = Ref_Age_Categories.age_category_code JOIN Addresses ON Users.user_address_id = Addresses.address_id WHERE Ref_Age_Categories.age_category_description = 'Senior Citizens';","SELECT T1.line_1_number_building ,  T1.line_2_number_street ,  T1.town_city FROM Addresses AS T1 JOIN Users AS T2 ON T1.address_id  =  T2.user_address_id WHERE T2.user_category_code  =  'Senior Citizen';","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Addresses.line_1_number_building,"" ""Addresses.line_2_number_street,"" and ""Addresses.town_city."" 2. Condition Structure: Use a WHERE clause to filter for users who are categorized as ""Senior Citizens."" This requires matching the ""Users.age_category_code"" with ""Ref_Age_Categories.age_category_code"" and filtering where ""Ref_Age_Categories.age_category_description"" is ""Senior Citizens."" 3. Join Structure: Use JOINs to connect the ""Users"" table with ""Ref_Age_Categories"" on ""Users.age_category_code = Ref_Age_Categories.age_category_code"" and the ""Users"" table with ""Addresses"" on ""Users.user_address_id = Addresses.address_id"" to retrieve the address details of the users. 4. Aggregation Structure: No aggregation is needed as the query is retrieving specific details for each senior citizen.",0.0
1539,What are the maximum and minimum weight of all bikes?,EASY,bike_racing,[bike.weight],"Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
","SELECT MAX(bike.weight) AS max_weight, MIN(bike.weight) AS min_weight FROM bike;","SELECT max(weight) ,  min(weight) FROM bike","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum weights of all bikes. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum weight of bikes. 3. Condition Structure: No specific filtering condition is required as the query involves all bikes. 4. Join Structure: No JOIN is required since all necessary data is within the ""bike"" table.",1.0
1540,"For users whose description contain the string 'Mother', which age categories are they in?",NON-NESTED,real_estate_rentals,"[Users.user_category_code,Users.other_user_details,Users.age_category_code,Users.user_category_code = Ref_User_Categories.user_category_code,Ref_Age_Categories.age_category_code]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT DISTINCT Users.age_category_code FROM Users WHERE Users.other_user_details LIKE '%Mother%';,"SELECT T2.age_category_code FROM Ref_User_Categories AS T1 JOIN Users AS T2 ON T1.user_category_code  =  T2.user_category_code WHERE T1.User_category_description LIKE ""%Mother"";","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct age categories for users whose description contains the string 'Mother'. This involves selecting ""Users.age_category_code"". 2. Condition Structure: Use a WHERE clause to filter users whose ""Users.other_user_details"" contains the string 'Mother'. 3. Join Structure: No JOIN is required to retrieve the age categories since the necessary information is already in the ""Users"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique age categories are returned.",0.0
1541,"What are the maximum and minimum health scores among countries that are not ""Norway"".",NESTED,country_language,"[countries.health_score, countries.name]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
","SELECT MAX(health_score) AS max_health_score, MIN(health_score) AS min_health_score FROM countries WHERE name != 'Norway';","SELECT max(health_score) ,  min(health_score) FROM countries WHERE name != ""Norway""","1. Sequential Structure: Start with the SELECT clause to retrieve the maximum and minimum health scores. Use the FROM clause to specify the countries table. Apply a WHERE clause to exclude the country ""Norway"". 2. Condition Structure: Use the WHERE clause to filter out the country ""Norway"" by ensuring the name is not equal to ""Norway"". 3. Join Structure: Not required, as all data is in the countries table. 4. Aggregation Structure: Use the MAX and MIN functions to calculate the maximum and minimum health scores among the filtered countries.",1.0
1542,"What are the names of languages that are the official language not only for countries that have an overall score of above 95, but also for countries that have an overall score below 90?",NESTED,country_language,"[languages.name, countries.overall_score, official_languages.language_id = languages.id, official_languages.country_id = countries.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT DISTINCT languages.name FROM languages JOIN official_languages ON official_languages.language_id = languages.id JOIN countries ON official_languages.country_id = countries.id WHERE EXISTS ( SELECT 1 FROM countries AS c1 JOIN official_languages AS ol1 ON ol1.country_id = c1.id WHERE ol1.language_id = languages.id AND c1.overall_score > 95 ) AND EXISTS ( SELECT 1 FROM countries AS c2 JOIN official_languages AS ol2 ON ol2.country_id = c2.id WHERE ol2.language_id = languages.id AND c2.overall_score < 90 );,SELECT T3.name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id WHERE T1.overall_score  >  95 INTERSECT SELECT T3.name FROM countries AS T1 JOIN official_languages AS T2 ON T1.id  =  T2.country_id JOIN languages AS T3 ON T2.language_id  =  T3.id WHERE T1.overall_score  <  90,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of languages. Use the FROM clause to specify the languages table and JOIN it with the official_languages and countries tables to connect languages with their respective countries. Apply a WHERE clause to filter for countries with an overall score above 95 and countries with an overall score below 90. 2. Condition Structure: Use the WHERE clause to filter for countries with an overall score above 95 and countries with an overall score below 90. Use EXISTS subqueries to ensure that the language is the official language for both types of countries. 3. Join Structure: Use INNER JOINs between the languages, official_languages, and countries tables based on their respective keys (language_id and country_id) to connect the data. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1543,Give the three most purchased items at this bakery.,NON-NESTED,bakery_1,"[items.Item, items.Receipt, goods.Id, goods.Food, items.Item = goods.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Food, COUNT(items.Receipt) AS purchase_count FROM items JOIN goods ON items.Item = goods.Id GROUP BY goods.Food ORDER BY purchase_count DESC LIMIT 3;",SELECT item FROM items GROUP BY item ORDER BY COUNT (*) DESC LIMIT 3,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""goods.Food"" and the count of purchases for each item. Use an alias for the count to make it more readable. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all items. 3. Join Structure: Use a JOIN between the ""items"" and ""goods"" tables based on ""items.Item = goods.Id"" to link each item with its corresponding food name. 4. Aggregation Structure: Use COUNT on ""items.Receipt"" to count the number of purchases for each item. Use GROUP BY to group the results by ""goods.Food."" Finally, use ORDER BY in descending order of the count to rank items by popularity and LIMIT 3 to get the top three most purchased items.",0.0
1544,What are the names of the bikes that have substring 'fiber' in their material?,EASY,bike_racing,"[bike.product_name, bike.material]","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
",SELECT bike.product_name FROM bike WHERE bike.material LIKE '%fiber%';,"SELECT product_name FROM bike WHERE material LIKE ""%fiber%""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""bike.product_name"" of bikes whose material contains the substring 'fiber'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for materials that contain the substring 'fiber'. 3. Join Structure: No JOIN is required since all necessary information is in the ""bike"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific bike names based on a condition.",1.0
1545,What are the names of languages that are not the official language of any country?,NESTED,country_language,"[languages.name, official_languages.language_id, languages.id = official_languages.language_id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT languages.name FROM languages WHERE languages.id NOT IN (SELECT language_id FROM official_languages);,SELECT name FROM languages WHERE id NOT IN (SELECT language_id FROM official_languages),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of languages. Use the FROM clause to specify the languages table. Apply a WHERE clause to filter languages that are not the official language of any country by ensuring their IDs are not present in the official_languages table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude languages whose IDs appear in the official_languages table, meaning they are official languages of some country. 3. Join Structure: Not required, as we only need to filter based on the absence of matching IDs in the official_languages table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1546,What are the users making only one search? List both category and user id.,NESTED,real_estate_rentals,"[Users.user_id,Users.user_category_code,User_Searches.user_id,User_Searches.search_seq]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Users.user_category_code, Users.user_id FROM Users JOIN User_Searches ON Users.user_id = User_Searches.user_id GROUP BY Users.user_id, Users.user_category_code HAVING COUNT(User_Searches.search_seq) = 1;","SELECT T1.user_category_code ,  T1.user_id FROM Users AS T1 JOIN User_Searches AS T2 ON T1.user_id  =  T2.user_id GROUP BY T1.user_id HAVING count(*)  =  1;",1. Sequential Structure: Start with the SELECT clause to retrieve the user category and user ID. Use the FROM clause to specify the Users table and JOIN it with the User_Searches table to link users with their search data. Apply GROUP BY on user_id to count the number of searches per user and filter for users making only one search. 2. Condition Structure: Use the HAVING clause with COUNT(search_seq) to filter for users who have made exactly one search. 3. Join Structure: Use an INNER JOIN between the Users and User_Searches tables based on user_id to connect user details with their search data. 4. Aggregation Structure: Use COUNT(search_seq) within HAVING to aggregate the number of searches per user and filter out users with more than one search.,1.0
1547,Which make has more than one team?,NON-NESTED,car_racing,"[team.Make, team.Team_ID, team_driver.Team_ID = team.Team_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT team.Make FROM team JOIN team_driver ON team.Team_ID = team_driver.Team_ID GROUP BY team.Make HAVING COUNT(team.Team_ID) > 1;,SELECT make FROM team GROUP BY team HAVING count(*)  >  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""team.Make"" field. Use GROUP BY to group the results by ""team.Make"" and HAVING to filter makes with more than one team. 2. Condition Structure: Use a HAVING clause to filter for makes that have more than one team. 3. Join Structure: Use a JOIN between the ""team"" and ""team_driver"" tables based on ""team.Team_ID"" to ensure the relationship between teams and their drivers is considered. 4. Aggregation Structure: Use COUNT on ""team.Team_ID"" to count the number of teams for each make, and filter with HAVING to include only those makes with more than one team.",1.0
1548,List the product names and weights of the bikes in ascending order of price.,EASY,bike_racing,"[bike.product_name, bike.weight, bike.price]","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
","SELECT bike.product_name, bike.weight FROM bike ORDER BY bike.price ASC;","SELECT product_name ,  weight FROM bike ORDER BY price ASC","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""bike.product_name"" and ""bike.weight"". 2. Condition Structure: No specific filtering condition is required as we want all bikes. 3. Join Structure: No JOIN is required since all necessary data is within the ""bike"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""bike.price"" in ascending order to sort the results by price.",1.0
1549,What are the maximum and minimum points of drivers.,EASY,car_racing,[driver.Points],"Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT MAX(driver.Points) AS max_points, MIN(driver.Points) AS min_points FROM driver;","SELECT max(Points) ,  min(Points) FROM driver","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum points of drivers. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum points respectively. 3. Grouping Structure: No GROUP BY is needed since we are calculating the aggregate values for all drivers collectively. 4. Join Structure: No JOIN is required as all necessary data is within the ""driver"" table.",1.0
1550,What are the flavors available for Cake but not for Tart?,NESTED,bakery_1,"[goods.Flavor, goods.Food]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT DISTINCT Flavor FROM goods WHERE Food = 'Cake' AND Flavor NOT IN (SELECT Flavor FROM goods WHERE Food = 'Tart');,"SELECT DISTINCT flavor FROM goods WHERE food  =  ""Cake"" EXCEPT SELECT DISTINCT flavor FROM goods WHERE food  =  ""Tart""","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct flavors. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter for flavors associated with ""Cake"" but not with ""Tart"". 2. Condition Structure: Use the WHERE clause with a subquery to exclude flavors that are associated with ""Tart"". The main query filters for flavors associated with ""Cake"". 3. Join Structure: Not required, as all data is available within the goods table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1551,How many properties have 1 parking lot or 1 garage?,EASY,real_estate_rentals,"[Properties.parking_lots, Properties.garage_yn]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT COUNT(*) FROM Properties WHERE Properties.parking_lots = 1 OR Properties.garage_yn = 1;,SELECT count(*) FROM Properties WHERE parking_lots  =  1 OR garage_yn  =  1;,"1. Sequential Structure: Start with the SELECT clause to count the number of properties that meet the specified conditions. 2. Condition Structure: Use a WHERE clause to filter properties that have either 1 parking lot or 1 garage. 3. Join Structure: No JOIN is required since all necessary information is in the ""Properties"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of properties that satisfy the conditions.",1.0
1552,"What is the most common property type, and what is its description.",NON-NESTED,real_estate_rentals,"[Properties.property_type_code, Ref_Property_Types.property_type_code, Ref_Property_Types.property_type_description]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Ref_Property_Types.property_type_code, Ref_Property_Types.property_type_description FROM Properties JOIN Ref_Property_Types ON Properties.property_type_code = Ref_Property_Types.property_type_code GROUP BY Ref_Property_Types.property_type_code, Ref_Property_Types.property_type_description ORDER BY COUNT(Properties.property_type_code) DESC LIMIT 1;","SELECT T1.property_type_description ,  T1.property_type_code FROM Ref_Property_Types AS T1 JOIN Properties AS T2 ON T1.property_type_code  =  T2.property_type_code GROUP BY T1.property_type_code ORDER BY count(*) DESC LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""property_type_code"" and its corresponding ""property_type_description."" Use COUNT to determine the frequency of each property type. 2. Condition Structure: No specific filtering condition is required, as we are interested in finding the most common property type. 3. Join Structure: Use a JOIN between the ""Properties"" table and the ""Ref_Property_Types"" table on ""property_type_code"" to link each property type with its description. 4. Aggregation Structure: Use COUNT to count the occurrences of each property type, GROUP BY ""property_type_code"" to group the results by property type, and ORDER BY the count in descending order to find the most common property type. Use LIMIT 1 to select the top result.",1.0
1553,What is the total max price of the properties owned by single mothers or students?,NON-NESTED,real_estate_rentals,"[Properties.price_max,Properties.owner_user_id,Users.user_id,Users.user_category_code,Ref_User_Categories.user_category_code,Ref_User_Categories.user_category_description,single mothers,students]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT SUM(Properties.price_max) FROM Properties JOIN Users ON Properties.owner_user_id = Users.user_id JOIN Ref_User_Categories ON Users.user_category_code = Ref_User_Categories.user_category_code WHERE Ref_User_Categories.user_category_description = 'single mothers' OR Ref_User_Categories.user_category_description = 'students';,SELECT sum(T1.price_max) FROM Properties AS T1 JOIN Users AS T2 ON T1.owner_user_id  =  T2.user_id WHERE T2.user_category_code  =  'Single Mother' OR T2.user_category_code  =  'Student';,"1. Sequential Structure: Start with the SELECT clause to calculate the total maximum price of properties. Use the SUM function on ""Properties.price_max"" to aggregate the total maximum price. 2. Condition Structure: Use a WHERE clause to filter properties owned by users who are either single mothers or students. This requires filtering based on the ""Users.user_category_code"" that matches the descriptions ""single mothers"" or ""students"" in the ""Ref_User_Categories"" table. 3. Join Structure: Use JOINs to connect the ""Properties"" table with the ""Users"" table on ""Properties.owner_user_id = Users.user_id"" and the ""Users"" table with the ""Ref_User_Categories"" table on ""Users.user_category_code = Ref_User_Categories.user_category_code."" 4. Aggregation Structure: Use SUM to calculate the total maximum price of the filtered properties.",0.0
1554,Find the manager and sponsor for each team and order them by the car owner.,EASY,car_racing,"[team.Manager, team.Sponsor, team.Car_Owner]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT team.Manager, team.Sponsor, team.Car_Owner FROM team ORDER BY team.Car_Owner;","SELECT Manager ,  Sponsor FROM team ORDER BY Car_Owner","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the manager, sponsor, and car owner for each team. 2. Condition Structure: No specific filtering condition is required as the query asks for all teams. 3. Join Structure: No JOIN is required since all necessary information is available in the ""team"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data. 5. Ordering Structure: Use ORDER BY on ""team.Car_Owner"" to sort the results by the car owner.",1.0
1555,Find the total number of drivers.,EASY,car_racing,[driver.Driver_ID],"Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT COUNT(driver.Driver_ID) AS total_drivers FROM driver;,SELECT count(*) FROM driver,"1. Sequential Structure: Start with the SELECT clause to count the total number of drivers. 2. Aggregation Structure: Use the COUNT function to calculate the total number of drivers based on the ""driver.Driver_ID"" field. 3. Condition Structure: No specific filtering condition is required as we want the total count of all drivers. 4. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table.",1.0
1556,"What is the id of the property that had the lowest requested price from the vendor, and what was that price?",NESTED,real_estate_rentals,"[Properties.property_id, Properties.vendor_requested_price]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT property_id, vendor_requested_price FROM Properties WHERE vendor_requested_price = (SELECT MIN(vendor_requested_price) FROM Properties);","SELECT property_id ,  vendor_requested_price FROM Properties ORDER BY vendor_requested_price LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the property ID and the vendor requested price. Use the FROM clause to specify the Properties table. Apply a WHERE clause to filter for the property with the lowest vendor requested price. 2. Condition Structure: Use the WHERE clause with a subquery to identify the lowest vendor requested price from the Properties table. 3. Join Structure: Not required, as all data is in the Properties table. 4. Aggregation Structure: Use the MIN function in a subquery to find the lowest vendor requested price, which is then used in the filtering condition.",1.0
1557,Order the distinct good ids.,EASY,bakery_1,"[goods.Id,items.Item = goods.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT DISTINCT goods.Id FROM goods ORDER BY goods.Id ASC;,SELECT DISTINCT id FROM goods ORDER BY id,"1. Sequential Structure: Begin with the SELECT clause to retrieve the distinct good IDs. 2. Condition Structure: No specific filtering condition is required as the query simply asks to order the distinct good IDs. 3. Join Structure: No JOIN is required since the query only involves the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are only retrieving and ordering distinct IDs. 5. Ordering Structure: Use ORDER BY to sort the distinct good IDs in ascending order.",1.0
1558,When did the user with login name ratione register?,EASY,real_estate_rentals,"[Users.login_name, Users.date_registered]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Users.date_registered FROM Users WHERE Users.login_name = 'ratione';,SELECT date_registered FROM Users WHERE login_name  =  'ratione';,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Users.date_registered"" for the user with the specified login name. 2. Condition Structure: Use a WHERE clause to filter for the user whose ""Users.login_name"" matches 'ratione'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Users"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
1559,In which cities are there any properties equipped with a swimming pool?,NON-NESTED,real_estate_rentals,"[Addresses.town_city, Properties.property_id = Property_Features.property_id, Property_Features.feature_id = Features.feature_id, Features.feature_name, swimming pool]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT DISTINCT Addresses.town_city FROM Properties JOIN Property_Features ON Properties.property_id = Property_Features.property_id JOIN Features ON Property_Features.feature_id = Features.feature_id JOIN Addresses ON Properties.property_id = Addresses.property_id WHERE Features.feature_name = 'swimming pool';,SELECT T2.town_city FROM Properties AS T1 JOIN Addresses AS T2 ON T1.property_address_id  =  T2.address_id JOIN Property_Features AS T3 ON T1.property_id  =  T3.property_id JOIN Features AS T4 ON T4.feature_id  =  T3.feature_id WHERE T4.feature_name  =  'swimming pool';,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct cities (""Addresses.town_city"") where properties with a swimming pool are located. 2. Condition Structure: Use a WHERE clause to filter for properties that have the feature ""swimming pool."" 3. Join Structure: Use JOINs to connect the ""Properties"" table with ""Property_Features"" on ""property_id,"" then ""Property_Features"" with ""Features"" on ""feature_id,"" and finally ""Properties"" with ""Addresses"" to get the city information. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique city names are returned.",0.0
1560,Show the three official languages that are most commonly spoken.,NON-NESTED,country_language,"[languages.name, official_languages.language_id, official_languages.language_id = languages.id]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
","SELECT languages.name, COUNT(official_languages.language_id) AS COUNT FROM official_languages JOIN languages ON official_languages.language_id = languages.id GROUP BY languages.name ORDER BY COUNT DESC LIMIT 3;",SELECT T2.name FROM official_languages AS T1 JOIN languages AS T2 ON T1.language_id  =  T2.id GROUP BY T2.id ORDER BY COUNT(*) DESC LIMIT 3,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the official languages. Use COUNT to determine how many times each language is spoken. Since we need the top three most commonly spoken languages, use ORDER BY in descending order of the count and LIMIT 3. 2. Condition Structure: No specific filtering condition is required, as we are considering all official languages. 3. Join Structure: Use a JOIN between the ""official_languages"" table and the ""languages"" table based on the relationship ""official_languages.language_id = languages.id"" to link each official language with its name. 4. Aggregation Structure: Use COUNT to count the occurrences of each language in the ""official_languages"" table, then group by ""languages.name"" to aggregate the counts for each language.",0.0
1561,What are the ids of goods that cost less than 3 dollars?,EASY,bakery_1,"[goods.Id, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Id FROM goods WHERE goods.Price < 3;,SELECT id FROM goods WHERE price  <  3,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the ""goods.Id"". 2. Condition Structure: Use a WHERE clause to filter goods where the ""goods.Price"" is less than 3 dollars. 3. Join Structure: No JOIN is required since all necessary information is in the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the IDs of goods that meet the specified price condition.",1.0
1562,Find the receipt numbers where both Cake and Cookie were bought.,NESTED,bakery_1,"[items.Item, goods.Food, items.Receipt, goods.Id = items.Item]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT items.Receipt FROM items JOIN goods ON goods.Id = items.Item WHERE goods.Food IN ('Cake', 'Cookie') GROUP BY items.Receipt HAVING COUNT(DISTINCT goods.Food) = 2;","SELECT T1.receipt FROM items AS T1 JOIN goods AS T2 ON T1.item  =  T2.id WHERE T2.food  =  ""Cake"" INTERSECT SELECT T1.receipt FROM items AS T1 JOIN goods AS T2 ON T1.item  =  T2.id WHERE T2.food  =  ""Cookie""","1. Sequential Structure: Start with the SELECT clause to retrieve the receipt numbers. Use the FROM clause to specify the items and goods tables. Apply a WHERE clause to filter for receipts where both ""Cake"" and ""Cookie"" were bought. 2. Condition Structure: Use the WHERE clause to filter for items that correspond to ""Cake"" and ""Cookie"" in the goods table. Use a subquery or grouping to ensure both items are present in the same receipt. 3. Join Structure: Use an INNER JOIN between the items and goods tables based on the relationship between goods.Id and items.Item to connect item details with their corresponding food names. 4. Aggregation Structure: Use GROUP BY on the receipt numbers to group items by receipt and apply a HAVING clause to ensure that both ""Cake"" and ""Cookie"" are present in the same receipt.",1.0
1563,"What are the login names of all senior citizens, sorted by first name?",NON-NESTED,real_estate_rentals,"[Users.login_name, Users.first_name, Users.age_category_code, Ref_Age_Categories.age_category_code, Ref_Age_Categories.age_category_description, Users.age_category_code = Ref_Age_Categories.age_category_code, senior citizens]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Users.login_name, Users.first_name FROM Users JOIN Ref_Age_Categories ON Users.age_category_code = Ref_Age_Categories.age_category_code WHERE Ref_Age_Categories.age_category_description = 'senior citizens' ORDER BY Users.first_name ASC;",SELECT login_name FROM Users WHERE user_category_code  =  'Senior Citizen' ORDER BY first_name,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Users.login_name"" and ""Users.first_name."" Since the question asks for sorting by first name, include an ORDER BY clause to sort the results alphabetically by ""Users.first_name."" 2. Condition Structure: Use a WHERE clause to filter for users who are senior citizens. This requires checking the ""Ref_Age_Categories.age_category_description"" for the value ""senior citizens."" 3. Join Structure: Use a JOIN between the ""Users"" table and the ""Ref_Age_Categories"" table on the ""age_category_code"" field to link users with their respective age category descriptions. 4. Aggregation Structure: No aggregation is needed as the query only retrieves and filters data without summarization.",0.0
1564,What are the ids of Cookie and Cake that cost between 3 and 7 dollars.,EASY,bakery_1,"[goods.Id, goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Id FROM goods WHERE goods.Food IN ('Cookie', 'Cake') AND goods.Price BETWEEN 3 AND 7;","SELECT id FROM goods WHERE food  =  ""Cookie"" OR food  =  ""Cake"" AND price BETWEEN 3 AND 7","1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the ""goods.Id"". 2. Condition Structure: Use a WHERE clause to filter for items where ""goods.Food"" is either 'Cookie' or 'Cake' and ""goods.Price"" is between 3 and 7 dollars. 3. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the IDs of items that meet the specified conditions.",0.0
1565,What are the receipt numbers for which either an apple flavor pie was purchased or the customer with id 12 shopped?,NESTED,bakery_1,"[goods.Flavor, goods.Food, items.Item = goods.Id, items.Receipt, receipts.ReceiptNumber, receipts.CustomerId, customers.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT receipts.ReceiptNumber FROM receipts JOIN items ON receipts.ReceiptNumber = items.Receipt JOIN goods ON items.Item = goods.Id WHERE (goods.Flavor = 'apple' AND goods.Food = 'pie') OR receipts.CustomerId = 12;,"SELECT T1.receipt FROM items AS T1 JOIN goods AS T2 ON T1.item  =  T2.id WHERE T2.flavor  =  ""Apple"" AND T2.food  =  ""Pie"" UNION SELECT ReceiptNumber FROM receipts WHERE CustomerId  =  12","1. Sequential Structure: Start with the SELECT clause to retrieve the receipt numbers. Use the FROM clause to specify the relevant tables (goods, items, and receipts). Apply a WHERE clause to filter for either an apple flavor pie purchase or a customer with ID 12. 2. Condition Structure: Use the WHERE clause with an OR condition to filter for receipts where the flavor is 'apple' and the food is 'pie', or where the customer ID is 12. 3. Join Structure: Use JOINs to connect the goods table with the items table on the item ID, and the items table with the receipts table on the receipt ID. This ensures we can access the necessary fields for filtering. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1566,What are the engine types that are used by two or more drivers?,NON-NESTED,car_road_race,"[driver.Engine, driver.Driver_ID, race.Driver_ID = driver.Driver_ID]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Engine FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID GROUP BY driver.Engine HAVING COUNT(driver.Driver_ID) >= 2;,SELECT Engine FROM driver GROUP BY Engine HAVING COUNT(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""driver.Engine"" types. Use GROUP BY to group results by engine type. 2. Condition Structure: Apply a HAVING clause to filter for engine types that are used by two or more drivers. 3. Join Structure: Use a JOIN between the ""race"" and ""driver"" tables based on ""Driver_ID"" to associate each race with its respective driver and their engine type. 4. Aggregation Structure: Use COUNT on ""driver.Driver_ID"" to count the number of drivers using each engine type, then filter with HAVING to select engine types used by two or more drivers.",1.0
1567,What are the id and name of the cyclist who owns the most bikes?,NON-NESTED,bike_racing,"[cyclist.id,cyclist.name,cyclists_own_bikes.cyclist_id = cyclist.id,cyclists_own_bikes.bike_id]","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
","SELECT cyclist.id, cyclist.name FROM cyclist JOIN cyclists_own_bikes ON cyclists_own_bikes.cyclist_id = cyclist.id GROUP BY cyclist.id, cyclist.name ORDER BY COUNT(cyclists_own_bikes.bike_id) DESC LIMIT 1;","SELECT T1.id ,  T1.name FROM cyclist AS T1 JOIN cyclists_own_bikes AS T2 ON T1.id  =  T2.cyclist_id GROUP BY T1.id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""cyclist.id"" and ""cyclist.name"" of the cyclist who owns the most bikes. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the cyclist with the maximum number of bikes. 3. Join Structure: Use a JOIN between the ""cyclist"" table and the ""cyclists_own_bikes"" table on ""cyclists_own_bikes.cyclist_id = cyclist.id"" to associate each cyclist with their owned bikes. 4. Aggregation Structure: Use COUNT on ""cyclists_own_bikes.bike_id"" to count the number of bikes owned by each cyclist. Use GROUP BY on ""cyclist.id"" and ""cyclist.name"" to group the results by cyclist. Use ORDER BY in descending order on the count and LIMIT 1 to select the cyclist with the most bikes.",1.0
1568,Give the feature name and description for the most common feature across all properties.,NON-NESTED,real_estate_rentals,"[Features.feature_name, Features.feature_description, Property_Features.feature_id, Property_Features.property_id, Property_Features.feature_id = Features.feature_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Features.feature_name, Features.feature_description FROM Features JOIN Property_Features ON Property_Features.feature_id = Features.feature_id GROUP BY Features.feature_id ORDER BY COUNT(Property_Features.feature_id) DESC LIMIT 1;","SELECT T1.feature_name ,  T1.feature_description FROM Features AS T1 JOIN Property_Features AS T2 ON T1.feature_id  =  T2.feature_id GROUP BY T1.feature_name ORDER BY count(*) DESC LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve ""Features.feature_name"" and ""Features.feature_description."" 2. Condition Structure: No specific filtering condition is needed, as we are looking for the most common feature across all properties. 3. Join Structure: Use a JOIN between the ""Features"" table and the ""Property_Features"" table on ""Property_Features.feature_id = Features.feature_id"" to link features with their associated properties. 4. Aggregation Structure: Use COUNT on ""Property_Features.feature_id"" to count the occurrences of each feature across all properties. Use ORDER BY in descending order to rank features by their count and LIMIT 1 to select the most common feature.",1.0
1569,How many bikes are heavier than 780 grams?,EASY,bike_racing,"[bike.weight, bike.id, 780]","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
",SELECT COUNT(bike.id) FROM bike WHERE bike.weight > 780;,SELECT count(*) FROM bike WHERE weight  >  780,"1. Sequential Structure: Start with the SELECT clause to count the number of bikes that meet the weight condition. 2. Condition Structure: Use a WHERE clause to filter bikes where ""bike.weight"" is greater than 780 grams. 3. Join Structure: No JOIN is required since all necessary information is in the ""bike"" table. 4. Aggregation Structure: Use COUNT to calculate the number of bikes that satisfy the weight condition.",1.0
1570,Find all the items that have chocolate flavor but were not bought more than 10 times.,NESTED,bakery_1,"[goods.Flavor, goods.Id, items.Item = goods.Id, items.Item, items.Receipt, receipts.ReceiptNumber, receipts.CustomerId]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT items.Item FROM goods JOIN items ON goods.Id = items.Item JOIN receipts ON items.Receipt = receipts.ReceiptNumber WHERE goods.Flavor = 'chocolate' GROUP BY items.Item HAVING COUNT(items.Receipt) <= 10;,"SELECT DISTINCT T1.item FROM items AS T1 JOIN goods AS T2 ON T1.item  =  T2.id WHERE T2.flavor  =  ""Chocolate"" GROUP BY item HAVING count(*)  <=  10","1. Sequential Structure: Start with the SELECT clause to retrieve the items that have a chocolate flavor. Use the FROM clause to specify the goods and items tables. Join these tables to connect items with their flavor. Additionally, join the items table with the receipts table to count the number of times an item was bought. Apply a GROUP BY clause to group by item ID and use a HAVING clause to filter items that were not bought more than 10 times. 2. Condition Structure: Use the WHERE clause to filter for items with the flavor 'chocolate'. Use the HAVING clause to ensure that the count of purchases for each item is less than or equal to 10. 3. Join Structure: Use INNER JOINs between the goods and items tables on the goods.Id and items.Item fields, and between the items and receipts tables on the items.Receipt and receipts.ReceiptNumber fields, to connect items with their purchase records and flavor. 4. Aggregation Structure: Use COUNT to calculate the number of times each item was bought and filter using the HAVING clause to exclude items bought more than 10 times.",0.0
1571,On which date did some customer buy a good that costs more than 15 dollars?,NON-NESTED,bakery_1,"[receipts.Date,goods.Price,items.Item = goods.Id,items.Receipt = receipts.ReceiptNumber]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT receipts.Date FROM items JOIN goods ON items.Item = goods.Id JOIN receipts ON items.Receipt = receipts.ReceiptNumber WHERE goods.Price > 15;,SELECT DISTINCT T1.date FROM receipts AS T1 JOIN items AS T2 ON T1.ReceiptNumber  =  T2.receipt JOIN goods AS T3 ON T2.item  =  T3.id WHERE T3.price  >  15,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""receipts.Date"" field, as the question asks for the date of the purchase. 2. Condition Structure: Use a WHERE clause to filter for goods with a price greater than 15 dollars. 3. Join Structure: Use JOINs to connect the ""items"" table with the ""goods"" table on ""items.Item = goods.Id"" and the ""items"" table with the ""receipts"" table on ""items.Receipt = receipts.ReceiptNumber"" to link the goods and their prices to the corresponding receipts and dates. 4. Aggregation Structure: No aggregation is needed, as the query only requires the date of the purchase.",1.0
1572,"List the id, flavor and type of food of goods ordered by price.",EASY,bakery_1,"[goods.Id, goods.Flavor, goods.Food, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Id, goods.Flavor, goods.Food, goods.Price FROM goods ORDER BY goods.Price;","SELECT id ,  flavor ,  food FROM goods ORDER BY price","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""goods.Id"", ""goods.Flavor"", ""goods.Food"", and ""goods.Price"". 2. Condition Structure: No specific filtering condition is required as the query asks for all goods. 3. Ordering Structure: Use ORDER BY on ""goods.Price"" to sort the results by price. 4. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table. 5. Aggregation Structure: No aggregation is needed as the query does not involve any summary or grouping.",1.0
1573,What are ids of the goods that have Apricot flavor and are cheaper than 5 dollars?,EASY,bakery_1,"[goods.Id, goods.Flavor, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Id FROM goods WHERE goods.Flavor = 'Apricot' AND goods.Price < 5;,"SELECT id FROM goods WHERE flavor  =  ""Apricot"" AND price  <  5","1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the ""goods.Id"". 2. Condition Structure: Use a WHERE clause to filter goods that have the flavor ""Apricot"" and are priced less than 5 dollars. 3. Join Structure: No JOIN is required since all necessary information is in the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the IDs of goods that meet the specified conditions.",1.0
1574,What are the full names of customers who bought apple flavored Tarts?,NON-NESTED,bakery_1,"[customers.FirstName, customers.LastName, receipts.CustomerId = customers.Id, items.Item = goods.Id, goods.Flavor, goods.Food, goods.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT customers.FirstName, customers.LastName FROM customers JOIN receipts ON receipts.CustomerId = customers.Id JOIN items ON receipts.Id = items.ReceiptId JOIN goods ON items.Item = goods.Id WHERE goods.Flavor = 'apple' AND goods.Food = 'Tarts';","SELECT DISTINCT T4.FirstName ,  T4.LastName FROM goods AS T1 JOIN items AS T2 ON T1.id  =  T2.item JOIN receipts AS T3 ON T2.receipt  =  T3.ReceiptNumber JOIN customers AS T4 ON T3.CustomerId  =  T4.id WHERE T1.flavor  =  ""Apple"" AND T1.food  =  ""Tart""","1. Sequential Structure: Start with the SELECT clause to retrieve the full names of customers, which are ""customers.FirstName"" and ""customers.LastName."" 2. Condition Structure: Use a WHERE clause to filter for goods that are apple-flavored Tarts. This requires checking ""goods.Flavor"" for 'apple' and ""goods.Food"" for 'Tarts.' 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""receipts"" with ""customers"" on ""receipts.CustomerId = customers.Id"" to link purchases to customers. Then, join ""receipts"" with ""items"" on ""receipts.Id = items.ReceiptId"" to link purchases to items. Finally, join ""items"" with ""goods"" on ""items.Item = goods.Id"" to get the details of the purchased goods. 4. Aggregation Structure: No aggregation is needed, as the query only requires retrieving customer names.",0.0
1575,Return the first name of the user who owns the most properties.,NON-NESTED,real_estate_rentals,"[Users.first_name,Properties.owner_user_id,Users.user_id = Properties.owner_user_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Users.first_name FROM Users JOIN Properties ON Users.user_id = Properties.owner_user_id GROUP BY Users.user_id ORDER BY COUNT(Properties.owner_user_id) DESC LIMIT 1;,SELECT T1.first_name FROM Users AS T1 JOIN Properties AS T2 ON T2.owner_user_id  =  T1.User_id GROUP BY T1.User_id ORDER BY count(*) DESC LIMIT 1;,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Users.first_name"" of the user who owns the most properties. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the user with the maximum number of properties. 3. Join Structure: Use a JOIN between the ""Users"" and ""Properties"" tables based on the relationship ""Users.user_id = Properties.owner_user_id"" to associate each user with their properties. 4. Aggregation Structure: Use COUNT to count the number of properties owned by each user, GROUP BY ""Users.user_id"" to group the results by user, and ORDER BY the count in descending order. Use LIMIT 1 to select the user with the most properties.",1.0
1576,What are the three dates for which the most receipts were given?,EASY,bakery_1,"[receipts.Date, receipts.ReceiptNumber]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT receipts.Date, COUNT(receipts.ReceiptNumber) AS receipt_count FROM receipts GROUP BY receipts.Date ORDER BY receipt_count DESC LIMIT 3;",SELECT date FROM receipts GROUP BY date ORDER BY count(*) DESC LIMIT 3,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the date. Since the question asks for the top three dates, we also need to count the number of receipts for each date. 2. Aggregation Structure: Use COUNT to calculate the number of receipts for each date. 3. Grouping Structure: Use GROUP BY on ""receipts.Date"" to aggregate the results by each date. 4. Ordering Structure: Use ORDER BY in descending order on the count of receipts to rank the dates by the number of receipts given. 5. Limiting Structure: Use LIMIT 3 to retrieve only the top three dates with the most receipts. 6. Join Structure: No JOIN is required since all necessary data is within the ""receipts"" table.",1.0
1577,What are the ids of customers who spend more than 5 on average for each good?,NESTED,bakery_1,"[customers.Id, goods.Id, goods.Price, items.Item = goods.Id, receipts.CustomerId = customers.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT customers.Id FROM customers JOIN receipts ON receipts.CustomerId = customers.Id JOIN items ON items.Id = receipts.Id JOIN goods ON goods.Id = items.Item GROUP BY customers.Id HAVING AVG(goods.Price) > 5;,SELECT T3.CustomerId FROM goods AS T1 JOIN items AS T2 ON T1.id  =  T2.item JOIN receipts AS T3 ON T2.receipt  =  T3.ReceiptNumber GROUP BY T3.CustomerId HAVING avg(T1.price)  >  5,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of customers. Use the FROM clause to specify the relevant tables (customers, goods, items, and receipts). Use JOINs to connect these tables based on their relationships. Apply a GROUP BY clause to group data by customer ID and calculate the average spending per good. Use the HAVING clause to filter customers whose average spending per good is greater than 5. 2. Condition Structure: Use the HAVING clause to filter for customers whose average spending on goods exceeds 5. 3. Join Structure: Use JOINs to connect the customers table with the receipts table on CustomerId, the receipts table with the items table, and the items table with the goods table on their respective IDs. 4. Aggregation Structure: Use the AVG function to calculate the average spending per good for each customer and filter based on this value using the HAVING clause.",0.0
1578,What are the names of drivers who had both the pole position James Hinchcliffe and the pole position Carl Skerlong?,NESTED,car_road_race,"[driver.Driver_Name, race.Pole_Position, race.Driver_ID = driver.Driver_ID, James Hinchcliffe, Carl Skerlong]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
","SELECT driver.Driver_Name FROM driver JOIN race ON race.Driver_ID = driver.Driver_ID WHERE race.Pole_Position IN ('James Hinchcliffe', 'Carl Skerlong') GROUP BY driver.Driver_ID, driver.Driver_Name HAVING COUNT(DISTINCT race.Pole_Position) = 2;","SELECT T1.Driver_Name FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID WHERE Pole_Position  =  ""Carl Skerlong"" INTERSECT SELECT T1.Driver_Name FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID WHERE Pole_Position  =  ""James Hinchcliffe""",1. Sequential Structure: Start with the SELECT clause to retrieve the names of drivers. Use the FROM clause to specify the driver table and JOIN it with the race table on the Driver_ID field to connect drivers with their race records. Apply a WHERE clause to filter for races where the Pole_Position is either 'James Hinchcliffe' or 'Carl Skerlong'. 2. Condition Structure: Use the WHERE clause to filter for drivers who had both 'James Hinchcliffe' and 'Carl Skerlong' as Pole_Position. This requires grouping by Driver_ID and using a HAVING clause to ensure both conditions are met. 3. Join Structure: Use an INNER JOIN between the driver and race tables based on Driver_ID to link driver names with their race records. 4. Aggregation Structure: Use GROUP BY to group records by Driver_ID and HAVING to ensure that the driver has both 'James Hinchcliffe' and 'Carl Skerlong' as Pole_Position.,1.0
1579,Find the teams that won more than once.,EASY,car_road_race,[race.Winning_team],"Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT race.Winning_team FROM race GROUP BY race.Winning_team HAVING COUNT(*) > 1;,SELECT Winning_team FROM race GROUP BY Winning_team HAVING count(*)  >  1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""race.Winning_team"". 2. Aggregation Structure: Use COUNT to determine the number of times each team has won. 3. Grouping Structure: Use GROUP BY on ""race.Winning_team"" to aggregate the results by each team. 4. Condition Structure: Apply the HAVING clause to filter for teams that have won more than once, by setting the count to be greater than 1. 5. Join Structure: No JOIN is required since we are only interested in the ""race"" table.",1.0
1580,Return the ordered list of all good ids.,NON-NESTED,bakery_1,"[items.Item, goods.Id = items.Item]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Id FROM goods JOIN items ON goods.Id = items.Item ORDER BY goods.Id ASC;,SELECT DISTINCT id FROM goods ORDER BY id,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""goods.Id"" field. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""goods"" and ""items"" tables based on the relationship ""goods.Id = items.Item"" to link goods with their corresponding items. 4. Aggregation Structure: No aggregation is required, but apply ORDER BY to return the list of ""goods.Id"" in an ordered manner.",1.0
1581,What are the average prices of goods with blackberry or blueberry flavor?,EASY,bakery_1,"[goods.Price, goods.Flavor]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT AVG(goods.Price) AS average_price FROM goods WHERE goods.Flavor LIKE '%blackberry%' OR goods.Flavor LIKE '%blueberry%';,"SELECT avg(price) FROM goods WHERE flavor  =  ""Blackberry"" OR flavor  =  ""Blueberry""","1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average price of goods. 2. Condition Structure: Use a WHERE clause to filter goods that have a flavor containing ""blackberry"" or ""blueberry"". 3. Aggregation Structure: Use the AVG function to calculate the average price of the filtered goods. 4. Join Structure: No JOIN is required since all necessary data is within the ""goods"" table.",1.0
1582,What is the most common type of engine?,EASY,car_road_race,[driver.Engine],"Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Engine FROM driver GROUP BY driver.Engine ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Engine FROM driver GROUP BY Engine ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the engine type, as we are looking for the most common type of engine. 2. Aggregation Structure: Use COUNT to calculate the frequency of each engine type. 3. Grouping Structure: Use GROUP BY on ""driver.Engine"" to group the results by each engine type. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank engine types by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common engine type. 6. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table.",1.0
1583,What is the average justice scores among countries?,EASY,country_language,[countries.justice_score],"Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT AVG(countries.justice_score) AS avg_justice_score FROM countries;,SELECT avg(justice_score) FROM countries,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average justice score. 2. Aggregation Structure: Use the AVG function to calculate the average justice score across all countries. 3. Condition Structure: No specific filtering condition is required as the query aims to calculate the average for all countries. 4. Join Structure: No JOIN is required since all necessary data is within the ""countries"" table.",1.0
1584,On what dates did the bakery sell more than 100 dollars worth of goods in total?,NON-NESTED,bakery_1,"[receipts.Date, items.Receipt, items.Item = goods.Id, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT receipts.Date FROM receipts JOIN items ON receipts.Receipt = items.Receipt JOIN goods ON items.Item = goods.Id GROUP BY receipts.Date HAVING SUM(goods.Price) > 100;,SELECT T3.date FROM goods AS T1 JOIN items AS T2 ON T1.id  =  T2.item JOIN receipts AS T3 ON T2.receipt  =  T3.ReceiptNumber GROUP BY T3.date HAVING sum(T1.price)  >  100,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""receipts.Date"" field. Since the question asks for dates where the total sales exceeded 100 dollars, we will use an aggregation function (SUM) on the ""goods.Price"" field. 2. Condition Structure: Use a HAVING clause to filter for dates where the total sales (SUM of ""goods.Price"") exceeded 100 dollars. 3. Join Structure: Use JOINs to connect the ""receipts"" table with the ""items"" table on ""items.Receipt"" and then connect the ""items"" table with the ""goods"" table on ""items.Item = goods.Id"" to link receipts with their corresponding goods and prices. 4. Aggregation Structure: Use SUM on ""goods.Price"" to calculate the total sales for each date, and GROUP BY ""receipts.Date"" to group the results by date.",0.0
1585,Give the ids of goods that are more than twice as expensive as the average good.,NESTED,bakery_1,"[goods.Id, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT Id FROM goods WHERE Price > 2 * (SELECT AVG(Price) FROM goods);,SELECT id FROM goods WHERE price  >  (SELECT avg(price) FROM goods),"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of goods. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter goods whose price is more than twice the average price of all goods. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average price of goods and filter for goods whose price is greater than twice this average. 3. Join Structure: Not required, as all data is in the goods table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average price of goods, and use this value in the filtering condition to identify goods that meet the criteria.",0.0
1586,Find all receipts which either has the earliest date or has a good with price above 10.,NESTED,bakery_1,"[receipts.ReceiptNumber,receipts.Date,goods.Price,items.Item = goods.Id,items.Receipt = receipts.ReceiptNumber]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT receipts.ReceiptNumber FROM receipts LEFT JOIN items ON receipts.ReceiptNumber = items.Receipt LEFT JOIN goods ON items.Item = goods.Id WHERE receipts.Date = (SELECT MIN(Date) FROM receipts) OR goods.Price > 10;,SELECT T1.Receipt FROM items AS T1 JOIN goods AS T2 ON T1.item  =  T2.id WHERE T2.price  >  10 UNION SELECT ReceiptNumber FROM receipts WHERE date  =  (SELECT date FROM receipts ORDER BY date LIMIT 1),1. Sequential Structure: Start with the SELECT clause to retrieve all receipt numbers. Use the FROM clause to specify the receipts table. Use JOINs to connect the receipts table with the items and goods tables to access the price of goods. Apply a WHERE clause to filter for receipts that either have the earliest date or include a good with a price above 10. 2. Condition Structure: Use the WHERE clause with two conditions combined using OR. The first condition checks for the earliest date using a subquery to find the minimum date. The second condition checks for goods with a price above 10. 3. Join Structure: Use JOINs to connect the receipts table with the items table on ReceiptNumber and the items table with the goods table on the Item field to access the price of goods. 4. Aggregation Structure: Use MIN in a subquery to find the earliest date for filtering receipts.,1.0
1587,Give me the distinct id and price for all goods whose price is below the average of all goods?,NESTED,bakery_1,"[goods.Id, goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT DISTINCT Id, Price FROM goods WHERE Price < (SELECT AVG(Price) FROM goods);","SELECT DISTINCT id ,  price FROM goods WHERE price  <  (SELECT avg(price) FROM goods)","1. Sequential Structure: Start with the SELECT clause to retrieve distinct IDs and prices of goods. Use the FROM clause to specify the goods table. Apply a WHERE clause to filter goods whose price is below the average price of all goods. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average price of all goods and filter goods whose price is less than this value. 3. Join Structure: Not required, as all data is in the goods table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average price of all goods, which is then used in the filtering condition.",1.0
1588,"On average, how many rooms do properties with garden features have?",NON-NESTED,real_estate_rentals,"[Property_Features.feature_id,Features.feature_name,Property_Features.property_id = Properties.property_id,Rooms.property_id = Properties.property_id,Rooms.room_number]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT AVG(room_count) AS average_rooms FROM ( SELECT COUNT(Rooms.room_number) AS room_count FROM Features JOIN Property_Features ON Features.feature_id = Property_Features.feature_id JOIN Properties ON Property_Features.property_id = Properties.property_id JOIN Rooms ON Properties.property_id = Rooms.property_id WHERE Features.feature_name = 'garden' GROUP BY Properties.property_id ) AS subquery;,SELECT avg(T3.room_count) FROM Property_Features AS T1 JOIN Features AS T2 ON T1.feature_id  =  T2.feature_id JOIN Properties AS T3 ON T1.property_id  =  T3.property_id WHERE T2.feature_name  =  'garden';,"1. Sequential Structure: Start with the SELECT clause to calculate the average number of rooms for properties with garden features. Use the AVG function on the count of ""Rooms.room_number."" 2. Condition Structure: Use a WHERE clause to filter properties that have the ""garden"" feature. This requires joining the ""Features"" table to identify the feature name ""garden."" 3. Join Structure: Use JOINs to connect the ""Features"" table with ""Property_Features"" on ""feature_id,"" then connect ""Property_Features"" with ""Properties"" on ""property_id,"" and finally connect ""Properties"" with ""Rooms"" on ""property_id."" 4. Aggregation Structure: Use COUNT to count the number of rooms for each property and then calculate the average using AVG.",0.0
1589,What is the three most popular goods in this bakery?,NON-NESTED,bakery_1,"[goods.Id, goods.Flavor, items.Item, items.Item = goods.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Id, goods.Flavor, COUNT(items.Item) AS popularity FROM goods JOIN items ON items.Item = goods.Id GROUP BY goods.Id, goods.Flavor ORDER BY popularity DESC LIMIT 3;",SELECT item FROM items GROUP BY item ORDER BY COUNT (*) DESC LIMIT 3,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""goods.Id"" or ""goods.Flavor"" and the count of each good's popularity. Use COUNT to determine the popularity of each good. 2. Condition Structure: No specific filtering condition is required, as we are interested in all goods. 3. Join Structure: Use a JOIN between the ""goods"" and ""items"" tables based on ""items.Item = goods.Id"" to link each item with its corresponding good. 4. Aggregation Structure: Use COUNT to count the occurrences of each good in the ""items"" table. Use ORDER BY in descending order to rank goods by popularity and LIMIT 3 to select the top three most popular goods.",0.0
1590,List names of countries in descending order of education_score.,EASY,country_language,"[countries.name, countries.education_score]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
",SELECT countries.name FROM countries ORDER BY countries.education_score DESC;,SELECT name FROM countries ORDER BY education_score DESC,"1. Sequential Structure: Start with the SELECT clause to specify the field ""countries.name"" as we need the names of the countries. 2. Condition Structure: No specific filtering condition is required since we want all countries. 3. Join Structure: No JOIN is required as all necessary information is in the ""countries"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in descending order based on ""countries.education_score"".",1.0
1591,What distinct receipt numbers correspond to someone who bought a good that costs more than 13 dollars?,NON-NESTED,bakery_1,"[receipts.ReceiptNumber,items.Receipt,items.Item = goods.Id,goods.Price,13]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT DISTINCT receipts.ReceiptNumber FROM receipts JOIN items ON receipts.ReceiptNumber = items.Receipt JOIN goods ON items.Item = goods.Id WHERE goods.Price > 13;,SELECT DISTINCT T1.ReceiptNumber FROM receipts AS T1 JOIN items AS T2 ON T1.ReceiptNumber  =  T2.receipt JOIN goods AS T3 ON T2.item  =  T3.id WHERE T3.price  >  13,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct ""receipts.ReceiptNumber."" 2. Condition Structure: Use a WHERE clause to filter for goods with a price greater than 13 dollars. 3. Join Structure: Use JOINs to connect the ""receipts"" table with the ""items"" table on ""receipts.ReceiptNumber = items.Receipt"" and the ""items"" table with the ""goods"" table on ""items.Item = goods.Id"" to link receipts to the goods purchased. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique receipt numbers are returned.",1.0
1592,"What are the ids and flavors of cakes, ordered by flavor?",EASY,bakery_1,"[goods.Id, goods.Flavor, goods.Food, items.Item = goods.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Id, goods.Flavor FROM goods WHERE goods.Food = 'cake' ORDER BY goods.Flavor ASC;","SELECT id ,  flavor FROM goods WHERE food  =  ""Cake"" ORDER BY flavor","1. Sequential Structure: Start with the SELECT clause to retrieve the ""goods.Id"" and ""goods.Flavor"" fields, as the question asks for the IDs and flavors of cakes. 2. Condition Structure: Use a WHERE clause to filter for items where ""goods.Food"" is 'cake', as we are only interested in cakes. 3. Join Structure: No JOIN is required since all necessary information is in the ""goods"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by ""goods.Flavor"" in ascending order.",0.0
1593,Return the maximum and minimum health scores across all countries other than Norway.,NESTED,country_language,"[countries.health_score, countries.name]","Table countries, columns = [*,id,name,overall_score,justice_score,health_score,education_score,economics_score,politics_score]
Table languages, columns = [*,id,name]
Table official_languages, columns = [*,language_id,country_id]
","Foreign_keys = [official_languages.country_id = countries.id,official_languages.language_id = languages.id]
","SELECT MAX(health_score) AS max_health_score, MIN(health_score) AS min_health_score FROM countries WHERE name != 'Norway';","SELECT max(health_score) ,  min(health_score) FROM countries WHERE name != ""Norway""","1. Sequential Structure: Start with the SELECT clause to retrieve the maximum and minimum health scores. Use the FROM clause to specify the countries table. Apply a WHERE clause to exclude the country ""Norway"" from the results. 2. Condition Structure: Use the WHERE clause to filter out records where the country name is ""Norway"". 3. Join Structure: Not required, as all data is in the countries table. 4. Aggregation Structure: Use the MAX and MIN functions to calculate the maximum and minimum health scores across the filtered records.",1.0
1594,What is the description of the most common property type? List the description and code.,NON-NESTED,real_estate_rentals,"[Ref_Property_Types.property_type_description, Ref_Property_Types.property_type_code, Properties.property_type_code, Properties.property_type_code = Ref_Property_Types.property_type_code]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Ref_Property_Types.property_type_description, Ref_Property_Types.property_type_code FROM Properties JOIN Ref_Property_Types ON Properties.property_type_code = Ref_Property_Types.property_type_code GROUP BY Ref_Property_Types.property_type_description, Ref_Property_Types.property_type_code ORDER BY COUNT(Properties.property_type_code) DESC LIMIT 1;","SELECT T1.property_type_description ,  T1.property_type_code FROM Ref_Property_Types AS T1 JOIN Properties AS T2 ON T1.property_type_code  =  T2.property_type_code GROUP BY T1.property_type_code ORDER BY count(*) DESC LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve ""Ref_Property_Types.property_type_description"" and ""Ref_Property_Types.property_type_code."" 2. Condition Structure: No specific filtering condition is needed, as we are looking for the most common property type. 3. Join Structure: Use a JOIN between ""Properties"" and ""Ref_Property_Types"" tables based on the shared key ""property_type_code"" to link property records with their descriptions and codes. 4. Aggregation Structure: Use COUNT on ""Properties.property_type_code"" to count the occurrences of each property type. Use ORDER BY in descending order to rank property types by their frequency and LIMIT 1 to select the most common property type.",1.0
1595,What is the first name of the user who owns the greatest number of properties?,NON-NESTED,real_estate_rentals,"[Users.first_name,Properties.owner_user_id,Users.user_id = Properties.owner_user_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT Users.first_name FROM Users JOIN Properties ON Users.user_id = Properties.owner_user_id GROUP BY Users.user_id ORDER BY COUNT(Properties.owner_user_id) DESC LIMIT 1;,SELECT T1.first_name FROM Users AS T1 JOIN Properties AS T2 ON T2.owner_user_id  =  T1.User_id GROUP BY T1.User_id ORDER BY count(*) DESC LIMIT 1;,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Users.first_name"" of the user who owns the greatest number of properties. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the user with the maximum count of properties. 3. Join Structure: Use a JOIN between the ""Users"" and ""Properties"" tables based on the relationship ""Users.user_id = Properties.owner_user_id"" to associate each user with their properties. 4. Aggregation Structure: Use COUNT to count the number of properties owned by each user, GROUP BY ""Users.user_id"" to group the counts by user, and ORDER BY the count in descending order. Use LIMIT 1 to select the user with the greatest number of properties.",1.0
1596,"What are the first, middle, last, and login names for all users who are sellers?",EASY,real_estate_rentals,"[Users.first_name, Users.middle_name, Users.last_name, Users.login_name, Users.is_seller]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Users.first_name, Users.middle_name, Users.last_name, Users.login_name FROM Users WHERE Users.is_seller = 1;","SELECT first_name ,  middle_name ,  last_name ,  login_name FROM Users WHERE is_seller  =  1;","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Users.first_name,"" ""Users.middle_name,"" ""Users.last_name,"" and ""Users.login_name."" 2. Condition Structure: Use a WHERE clause to filter for users who are sellers, i.e., where ""Users.is_seller"" is true. 3. Join Structure: No JOIN is required since all necessary data is within the ""Users"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific fields for users who meet the condition.",1.0
1597,"What are the first, middle and last names of users who own the property they live in?",NON-NESTED,real_estate_rentals,"[Users.first_name, Users.middle_name, Users.last_name, Users.user_id, Properties.owner_user_id, Properties.property_address_id = Users.user_address_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT Users.first_name, Users.middle_name, Users.last_name FROM Users JOIN Properties ON Properties.owner_user_id = Users.user_id AND Properties.property_address_id = Users.user_address_id;","SELECT first_name ,  middle_name ,  last_name FROM Properties AS T1 JOIN Users AS T2 ON T1.owner_user_id  =  T2.user_id WHERE T1.property_address_id  =  T2.user_address_id;","1. Sequential Structure: Start with the SELECT clause to retrieve ""Users.first_name,"" ""Users.middle_name,"" and ""Users.last_name."" 2. Condition Structure: Use a WHERE clause to filter for users where the ""Properties.owner_user_id"" matches the ""Users.user_id"" and the ""Properties.property_address_id"" matches the ""Users.user_address_id,"" indicating that the user owns the property they live in. 3. Join Structure: Use a JOIN between the ""Users"" and ""Properties"" tables based on the relationships ""Properties.owner_user_id = Users.user_id"" and ""Properties.property_address_id = Users.user_address_id."" 4. Aggregation Structure: No aggregation is needed as the query is retrieving individual user details.",1.0
1598,How many customers have bought each food?,NON-NESTED,bakery_1,"[customers.Id, receipts.CustomerId, goods.Food, items.Item, items.Item = goods.Id, receipts.CustomerId = customers.Id]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT goods.Food, COUNT(DISTINCT customers.Id) AS CustomerCount FROM receipts JOIN customers ON receipts.CustomerId = customers.Id JOIN items ON receipts.Id = items.ReceiptId JOIN goods ON items.Item = goods.Id GROUP BY goods.Food;","SELECT T1.food ,  count(DISTINCT T3.CustomerId) FROM goods AS T1 JOIN items AS T2 ON T1.Id  =  T2.Item JOIN receipts AS T3 ON T2.Receipt  =  T3.ReceiptNumber GROUP BY T1.food","1. Sequential Structure: Start with the SELECT clause to retrieve the ""goods.Food"" and the count of distinct ""customers.Id"" for each food item. Use COUNT to calculate the number of customers who bought each food. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the tables. First, join ""receipts"" with ""customers"" on ""receipts.CustomerId = customers.Id"" to associate receipts with customers. Then, join ""items"" with ""goods"" on ""items.Item = goods.Id"" to associate items with food. Finally, join ""receipts"" with ""items"" to link receipts with the purchased items. 4. Aggregation Structure: Use COUNT with DISTINCT on ""customers.Id"" to count the unique customers for each food item. Group the results by ""goods.Food"" to get the count for each food.",0.0
1599,Find the top three dates with the most receipts.,EASY,bakery_1,"[receipts.Date, receipts.ReceiptNumber]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
","SELECT receipts.Date, COUNT(receipts.ReceiptNumber) AS receipt_count FROM receipts GROUP BY receipts.Date ORDER BY receipt_count DESC LIMIT 3;",SELECT date FROM receipts GROUP BY date ORDER BY count(*) DESC LIMIT 3,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the date. 2. Aggregation Structure: Use COUNT to calculate the number of receipts for each date. 3. Grouping Structure: Use GROUP BY on ""receipts.Date"" to aggregate the results by each date. 4. Ordering Structure: Use ORDER BY in descending order on the count of receipts to rank the dates by the number of receipts. 5. Limiting Structure: Use LIMIT 3 to retrieve only the top three dates with the most receipts. 6. Join Structure: No JOIN is required since all necessary data is within the ""receipts"" table.",1.0
1600,Give the total max price corresponding to any properties owned by single mothers or students.,NON-NESTED,real_estate_rentals,"[Properties.price_max,Properties.owner_user_id,Users.user_id = Properties.owner_user_id,Users.user_category_code,Ref_User_Categories.user_category_code,Ref_User_Categories.user_category_description,Users.user_category_code = Ref_User_Categories.user_category_code,single mothers,students]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
","SELECT SUM(Properties.price_max) AS total_max_price FROM Properties JOIN Users ON Properties.owner_user_id = Users.user_id JOIN Ref_User_Categories ON Users.user_category_code = Ref_User_Categories.user_category_code WHERE Ref_User_Categories.user_category_description IN ('single mothers', 'students');",SELECT sum(T1.price_max) FROM Properties AS T1 JOIN Users AS T2 ON T1.owner_user_id  =  T2.user_id WHERE T2.user_category_code  =  'Single Mother' OR T2.user_category_code  =  'Student';,"1. Sequential Structure: Start with the SELECT clause to calculate the total maximum price of properties. Use the SUM function on ""Properties.price_max"" to aggregate the total price. 2. Condition Structure: Use a WHERE clause to filter properties owned by users who are either ""single mothers"" or ""students."" This requires filtering based on the ""user_category_description"" field in the ""Ref_User_Categories"" table. 3. Join Structure: Use JOINs to connect the ""Properties"" table with the ""Users"" table on ""Properties.owner_user_id = Users.user_id"" and the ""Users"" table with the ""Ref_User_Categories"" table on ""Users.user_category_code = Ref_User_Categories.user_category_code."" 4. Aggregation Structure: Use the SUM function to calculate the total maximum price of properties owned by the specified user categories.",0.0
1601,Count the number of searches made by buyers.,NON-NESTED,real_estate_rentals,"[Users.user_id,Users.is_buyer,User_Searches.user_id,User_Searches.search_seq,Users.user_id = User_Searches.user_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT COUNT(User_Searches.search_seq) FROM Users JOIN User_Searches ON Users.user_id = User_Searches.user_id WHERE Users.is_buyer = 1;,SELECT count(*) FROM Users AS T1 JOIN User_Searches AS T2 ON T1.user_id  =  T2.user_id WHERE T1.is_buyer  =  1;,"1. Sequential Structure: Start with the SELECT clause to count the number of searches made by buyers. Use COUNT on ""User_Searches.search_seq"" to count the searches. 2. Condition Structure: Use a WHERE clause to filter for users who are buyers, i.e., ""Users.is_buyer = 1."" 3. Join Structure: Use an INNER JOIN between the ""Users"" table and the ""User_Searches"" table on ""Users.user_id = User_Searches.user_id"" to associate buyers with their searches. 4. Aggregation Structure: Use COUNT to aggregate the total number of searches made by buyers.",1.0
1602,Count the number of properties with at least two features.,NON-NESTED,real_estate_rentals,"[Properties.property_id, Property_Features.property_id, COUNT(Property_Features.feature_id]","Table Addresses, columns = [*,address_id,line_1_number_building,line_2_number_street,line_3_area_locality,town_city,zip_postcode,county_state_province,country,other_address_details]
Table Features, columns = [*,feature_id,feature_name,feature_description]
Table Properties, columns = [*,property_id,property_address_id,owner_user_id,property_type_code,date_on_market,date_off_market,property_name,property_description,garage_yn,parking_lots,room_count,vendor_requested_price,price_min,price_max,other_property_details]
Table Property_Features, columns = [*,property_id,feature_id,feature_value,property_feature_description]
Table Property_Photos, columns = [*,property_id,photo_seq,photo_title,photo_description,photo_filename]
Table Ref_Age_Categories, columns = [*,age_category_code,age_category_description]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
Table Ref_Room_Types, columns = [*,room_type_code,room_type_description]
Table Ref_User_Categories, columns = [*,user_category_code,user_category_description]
Table Rooms, columns = [*,property_id,room_number,room_type_code,room_size,other_room_details]
Table User_Property_History, columns = [*,user_id,property_id,datestamp]
Table User_Searches, columns = [*,user_id,search_seq,search_datetime,search_string]
Table Users, columns = [*,user_id,age_category_code,user_category_code,user_address_id,is_buyer,is_seller,login_name,password,date_registered,first_name,middle_name,last_name,other_user_details]
","Foreign_keys = [Properties.property_type_code = Ref_Property_Types.property_type_code,Properties.property_address_id = Addresses.address_id,Properties.owner_user_id = Users.user_id,Property_Features.property_id = Properties.property_id,Property_Features.feature_id = Features.feature_id,Property_Photos.property_id = Properties.property_id,Rooms.room_type_code = Ref_Room_Types.room_type_code,Rooms.property_id = Properties.property_id,User_Property_History.property_id = Properties.property_id,User_Property_History.user_id = Users.user_id,User_Searches.user_id = Users.user_id]
",SELECT COUNT(Properties.property_id) FROM Properties JOIN Property_Features ON Properties.property_id = Property_Features.property_id GROUP BY Properties.property_id HAVING COUNT(Property_Features.feature_id) >= 2;,SELECT count(*) FROM Properties GROUP BY property_id HAVING count(*)  >= 2;,"1. Sequential Structure: Start with the SELECT clause to count the number of properties. Use COUNT on ""Properties.property_id"" to get the total count of properties that meet the condition. 2. Condition Structure: Use a HAVING clause to filter properties that have at least two features. This requires counting the number of features for each property and applying the condition "">= 2."" 3. Join Structure: Use a JOIN between the ""Properties"" table and the ""Property_Features"" table on ""Properties.property_id"" to associate each property with its features. 4. Aggregation Structure: Use COUNT on ""Property_Features.feature_id"" to count the number of features for each property, then group by ""Properties.property_id"" to ensure the count is calculated per property.",1.0
1603,"Give me the list of ids of all goods whose id has ""APP"".",EASY,bakery_1,[goods.Id],"Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT goods.Id FROM goods WHERE goods.Id LIKE '%APP%';,"SELECT id FROM goods WHERE id LIKE ""%APP%""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""goods.Id"" of all goods whose ID contains ""APP"". 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for goods IDs that contain the substring ""APP"". 3. Join Structure: No JOIN is required since all necessary information is in the ""goods"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving IDs based on a specific condition.",1.0
1604,Give me the ids of Cakes whose price is at least as much as the average price of Tart?,NESTED,bakery_1,"[goods.Id, goods.Price, goods.Food]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT Id FROM goods WHERE Food = 'Cake' AND Price >= (SELECT AVG(Price) FROM goods WHERE Food = 'Tart');,"SELECT id FROM goods WHERE food  =  ""Cake"" AND price  >=  (SELECT avg(price) FROM goods WHERE food  =  ""Tart"")","1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of goods that are categorized as ""Cake"". Use the FROM clause to specify the goods table. Apply a WHERE clause to filter for goods whose price is at least as much as the average price of goods categorized as ""Tart"". 2. Condition Structure: Use the WHERE clause to filter for goods with the ""Food"" value as ""Cake"" and whose price is greater than or equal to the average price of goods with the ""Food"" value as ""Tart"". Use a subquery to calculate the average price of ""Tart"". 3. Join Structure: Not required, as all data is available within the goods table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average price of ""Tart"", which is then used in the filtering condition.",1.0
1605,What are the ids of customers who have spent over 150 dollars in total?,NON-NESTED,bakery_1,"[customers.Id,receipts.CustomerId = customers.Id,receipts.ReceiptNumber,items.Receipt = receipts.ReceiptNumber,items.Item,goods.Id = items.Item,goods.Price]","Table customers, columns = [*,Id,LastName,FirstName]
Table goods, columns = [*,Id,Flavor,Food,Price]
Table items, columns = [*,Receipt,Ordinal,Item]
Table receipts, columns = [*,ReceiptNumber,Date,CustomerId]
","Foreign_keys = [items.Item = goods.Id,receipts.CustomerId = customers.Id]
",SELECT customers.Id FROM customers JOIN receipts ON receipts.CustomerId = customers.Id JOIN items ON items.Receipt = receipts.ReceiptNumber JOIN goods ON goods.Id = items.Item GROUP BY customers.Id HAVING SUM(goods.Price) > 150;,SELECT T3.CustomerId FROM goods AS T1 JOIN items AS T2 ON T1.id  =  T2.item JOIN receipts AS T3 ON T2.receipt  =  T3.ReceiptNumber GROUP BY T3.CustomerId HAVING sum(T1.price)  >  150,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""customers.Id"" of customers who have spent over 150 dollars in total. Use SUM to calculate the total spending of each customer. 2. Condition Structure: Apply a HAVING clause to filter customers whose total spending exceeds 150 dollars. 3. Join Structure: Use multiple JOINs to connect the tables: ""customers"" with ""receipts"" on ""customers.Id = receipts.CustomerId,"" ""receipts"" with ""items"" on ""receipts.ReceiptNumber = items.Receipt,"" and ""items"" with ""goods"" on ""goods.Id = items.Item."" 4. Aggregation Structure: Use SUM on ""goods.Price"" to calculate the total spending for each customer, and GROUP BY ""customers.Id"" to group the results by customer.",1.0
1606,"Show the name, nation and result for the cyclists who did not purchase any racing bike.",NESTED,bike_racing,"[cyclist.name, cyclist.nation, cyclist.result, cyclists_own_bikes.cyclist_id = cyclist.id, cyclists_own_bikes.bike_id]","Table bike, columns = [*,id,product_name,weight,price,material]
Table cyclist, columns = [*,id,heat,name,nation,result]
Table cyclists_own_bikes, columns = [*,cyclist_id,bike_id,purchase_year]
","Foreign_keys = [cyclists_own_bikes.bike_id = bike.id,cyclists_own_bikes.cyclist_id = cyclist.id]
","SELECT cyclist.name, cyclist.nation, cyclist.result FROM cyclist WHERE cyclist.id NOT IN (SELECT cyclist_id FROM cyclists_own_bikes);","SELECT name ,  nation ,  RESULT FROM cyclist EXCEPT SELECT T1.name ,  T1.nation ,  T1.result FROM cyclist AS T1 JOIN cyclists_own_bikes AS T2 ON T1.id  =  T2.cyclist_id","1. Sequential Structure: Start with the SELECT clause to retrieve the name, nation, and result of cyclists. Use the FROM clause to specify the cyclist table. Apply a WHERE clause to filter cyclists who did not purchase any racing bike by ensuring their IDs are not present in the cyclists_own_bikes table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude cyclists whose IDs appear in the cyclists_own_bikes table, indicating they own a bike. 3. Join Structure: Not required, as the filtering is based on the absence of matching cyclist IDs in the cyclists_own_bikes table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1607,"find the name of drivers who were never in ""James Hinchcliffe"" pole position before.",NESTED,car_road_race,"[driver.Driver_Name, race.Pole_Position, race.Driver_ID = driver.Driver_ID, James Hinchcliffe]","Table driver, columns = [*,Driver_ID,Driver_Name,Entrant,Constructor,Chassis,Engine,Age]
Table race, columns = [*,Road,Driver_ID,Race_Name,Pole_Position,Fastest_Lap,Winning_driver,Winning_team,Report]
","Foreign_keys = [race.Driver_ID = driver.Driver_ID]
",SELECT driver.Driver_Name FROM driver WHERE driver.Driver_ID NOT IN ( SELECT race.Driver_ID FROM race WHERE race.Pole_Position = 'James Hinchcliffe' );,"SELECT Driver_Name FROM driver EXCEPT SELECT T1.Driver_Name FROM driver AS T1 JOIN race AS T2 ON T1.Driver_ID  =  T2.Driver_ID WHERE Pole_Position  =  ""James Hinchcliffe""","1. Sequential Structure: Start with the SELECT clause to retrieve the names of drivers. Use the FROM clause to specify the driver table. Apply a WHERE clause to filter for drivers who were never in a race where ""James Hinchcliffe"" was in the pole position. 2. Condition Structure: Use a WHERE clause with a subquery to exclude drivers whose Driver_ID appears in races where the Pole_Position corresponds to ""James Hinchcliffe"". 3. Join Structure: Use an INNER JOIN between the driver and race tables based on Driver_ID to connect driver names with race details. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1608,Find the number of boxes saved in each warehouse.,NON-NESTED,warehouse_1,"[Boxes.Warehouse, Warehouses.Code, Boxes.Code = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Code, COUNT(Boxes.Code) AS NumberOfBoxes FROM Boxes JOIN Warehouses ON Boxes.Code = Warehouses.Code GROUP BY Warehouses.Code;","SELECT count(*) ,  warehouse FROM boxes GROUP BY warehouse","1. Sequential Structure: Start with the SELECT clause to retrieve the warehouse code and the count of boxes saved in each warehouse. 2. Condition Structure: No specific filtering condition is required, as we need the count of all boxes grouped by warehouse. 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the shared ""Code"" field to associate each box with its respective warehouse. 4. Aggregation Structure: Use COUNT to count the number of boxes for each warehouse, and GROUP BY the warehouse code to group the results by each warehouse.",0.0
1609,"What is the maximum, average, and minimum enrollment for all universities?",EASY,university_rank,[university.Enrollment],"Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT MAX(university.Enrollment) AS max_enrollment, AVG(university.Enrollment) AS avg_enrollment, MIN(university.Enrollment) AS min_enrollment FROM university;","SELECT max(enrollment) ,  avg(enrollment) ,  min(enrollment) FROM University","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum, average, and minimum enrollments. 2. Aggregation Structure: Use MAX, AVG, and MIN functions to calculate the maximum, average, and minimum enrollment values across all universities. 3. Grouping Structure: No GROUP BY is required since the query asks for aggregate values across all universities. 4. Join Structure: No JOIN is required as all necessary data is within the ""university"" table.",1.0
1610,Return the maximum and minimum enrollment across all institutions.,EASY,institution_sports,[institution.Enrollment],"Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT MAX(institution.Enrollment) AS max_enrollment, MIN(institution.Enrollment) AS min_enrollment FROM institution;","SELECT max(Enrollment) ,  min(Enrollment) FROM institution","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum enrollments. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum enrollment across all institutions. 3. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table. 4. Condition Structure: No specific filtering condition is needed as the query is aggregating data across all institutions.",1.0
1611,Select the codes of all warehouses that are above capacity.,NON-NESTED,warehouse_1,"[Warehouses.Code, Warehouses.Capacity, Boxes.Warehouse, Boxes.Value, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Warehouses.Code FROM Warehouses JOIN Boxes ON Boxes.Warehouse = Warehouses.Code GROUP BY Warehouses.Code HAVING SUM(Boxes.Value) > Warehouses.Capacity;,SELECT T2.code FROM boxes AS T1 JOIN Warehouses AS T2 ON T1.warehouse  =  T2.code GROUP BY T2.code HAVING count(*)  >  T2.capacity,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Warehouses.Code"" for warehouses that are above capacity. 2. Condition Structure: Use a WHERE clause to filter warehouses where the total value of boxes stored exceeds the warehouse's capacity. 3. Join Structure: Use a JOIN between the ""Warehouses"" and ""Boxes"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to link each warehouse with its stored boxes. 4. Aggregation Structure: Use SUM on ""Boxes.Value"" to calculate the total value of boxes stored in each warehouse, then compare this sum with ""Warehouses.Capacity"" in the HAVING clause to filter warehouses above capacity.",1.0
1612,What is the nickname of the institution with the smallest enrollment?,NESTED,institution_sports,"[institution.Enrollment, institution.Institution_ID = Championship.Institution_ID, Championship.Nickname]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT Championship.Nickname FROM institution JOIN Championship ON institution.Institution_ID = Championship.Institution_ID WHERE institution.Enrollment = (SELECT MIN(Enrollment) FROM institution);,SELECT T1.Nickname FROM championship AS T1 JOIN institution AS T2 ON T1.Institution_ID  =  T2.Institution_ID ORDER BY T2.Enrollment ASC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the nickname of the institution. Use the FROM clause to specify the institution and Championship tables. Apply a WHERE clause to filter for the institution with the smallest enrollment. 2. Condition Structure: Use a WHERE clause with a subquery to filter for the institution with the smallest enrollment by comparing the enrollment value to the minimum enrollment. 3. Join Structure: Use an INNER JOIN between the institution and Championship tables based on Institution_ID to connect the enrollment data with the nickname. 4. Aggregation Structure: Use MIN in a subquery to find the smallest enrollment value, which is then used in the filtering condition.",0.0
1613,Which conference has the least number of total enrollment?,EASY,university_rank,"[university.Home_Conference, university.Enrollment]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT university.Home_Conference, SUM(university.Enrollment) AS total_enrollment FROM university GROUP BY university.Home_Conference ORDER BY total_enrollment ASC LIMIT 1;",SELECT home_conference FROM University GROUP BY home_conference ORDER BY sum(enrollment) LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the conference name and the total enrollment. 2. Aggregation Structure: Use SUM to calculate the total enrollment for each conference. 3. Grouping Structure: Use GROUP BY on ""university.Home_Conference"" to calculate the total enrollment for each conference. 4. Ordering Structure: Use ORDER BY in ascending order on the total enrollment to rank conferences by the least number of total enrollments. 5. Limiting Structure: Use LIMIT 1 to retrieve the conference with the least total enrollment. 6. Join Structure: No JOIN is required since all necessary data is within the ""university"" table.",1.0
1614,"Show name, city, and state for all universities in  alphabetical order of university name.",EASY,university_rank,"[university.University_Name, university.City, university.State]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT university.University_Name, university.City, university.State FROM university ORDER BY university.University_Name ASC;","SELECT university_name ,  city ,  state FROM University ORDER BY university_name","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""university.University_Name"", ""university.City"", and ""university.State"". 2. Condition Structure: No specific filtering condition is required as we want all universities. 3. Join Structure: No JOIN is required since all necessary information is in the ""university"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""university.University_Name"" in ascending order to display the universities alphabetically.",1.0
1615,What are the average and maximum values for each type of content in boxes?,EASY,warehouse_1,"[Boxes.Contents, Boxes.Value]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Contents, AVG(Boxes.Value) AS avg_value, MAX(Boxes.Value) AS max_value FROM Boxes GROUP BY Boxes.Contents;","SELECT avg(value) ,  max(value) ,  CONTENTS FROM boxes GROUP BY CONTENTS","1. Sequential Structure: Begin with the SELECT clause to specify the content type and the required aggregate values, which are the average and maximum values. 2. Aggregation Structure: Use AVG and MAX functions to calculate the average and maximum values for each type of content. 3. Grouping Structure: Use GROUP BY on ""Boxes.Contents"" to calculate these aggregate values for each type of content. 4. Join Structure: No JOIN is required since all necessary data is within the ""Boxes"" table.",1.0
1616,Find the total value and number of boxes for each content type.,EASY,warehouse_1,"[Boxes.Contents, Boxes.Value, Boxes.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Contents, SUM(Boxes.Value) AS total_value, COUNT(Boxes.Code) AS number_of_boxes FROM Boxes GROUP BY Boxes.Contents;","SELECT sum(value) ,  count(*) ,  CONTENTS FROM boxes GROUP BY CONTENTS","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the content type (""Boxes.Contents""), the total value, and the number of boxes. 2. Aggregation Structure: Use SUM to calculate the total value of boxes for each content type and COUNT to calculate the number of boxes for each content type. 3. Grouping Structure: Use GROUP BY on ""Boxes.Contents"" to aggregate the results by each content type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Boxes"" table.",1.0
1617,What are the codes of boxes for which the value is greater than the value of any box that contains Rocks?,NESTED,warehouse_1,"[Boxes.Code, Boxes.Value, Boxes.Contents]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Code FROM Boxes WHERE Value > ANY (SELECT Value FROM Boxes WHERE Contents = 'Rocks');,SELECT code FROM boxes WHERE value  >  (SELECT min(value) FROM boxes WHERE CONTENTS  =  'Rocks'),"1. Sequential Structure: Start with the SELECT clause to retrieve the codes of boxes. Use the FROM clause to specify the Boxes table. Apply a WHERE clause to filter boxes whose value is greater than the value of any box that contains ""Rocks"". 2. Condition Structure: Use the WHERE clause with a subquery to compare the value of each box against the values of boxes containing ""Rocks"". The subquery retrieves the values of all boxes with ""Rocks"" in their contents. 3. Join Structure: Not required, as all data is within the Boxes table. 4. Aggregation Structure: Not needed, as we are comparing individual values without any aggregation.",0.0
1618,Select the codes of all the boxes located in Chicago.,NON-NESTED,warehouse_1,"[Boxes.Code,Warehouses.Location,Boxes.Warehouse = Warehouses.Code,Chicago]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Boxes.Code FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location = 'Chicago';,SELECT T1.code FROM boxes AS T1 JOIN Warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'Chicago',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Boxes.Code"" field, as the question asks for the codes of the boxes. 2. Condition Structure: Use a WHERE clause to filter for warehouses located in ""Chicago."" 3. Join Structure: Use a JOIN between the ""Boxes"" table and the ""Warehouses"" table based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to link each box with its corresponding warehouse. 4. Aggregation Structure: No aggregation is needed since the query only retrieves specific box codes.",1.0
1619,"For each driver, return his or her name and country.",EASY,car_racing,"[driver.Driver, driver.Country]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT driver.Driver, driver.Country FROM driver;","SELECT T2.Driver ,  T1.Country FROM country AS T1 JOIN driver AS T2 ON T1.Country_ID  =  T2.Country","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the driver's name and country. 2. Condition Structure: No specific filtering condition is required as we want to retrieve all drivers and their countries. 3. Join Structure: No JOIN is required since all necessary information is available in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the name and country for each driver.",0.0
1620,List the nicknames of institutions in descending order of capacity.,NON-NESTED,institution_sports,"[institution.Capacity, institution.Institution_ID = Championship.Institution_ID, Championship.Nickname]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT Championship.Nickname FROM institution JOIN Championship ON institution.Institution_ID = Championship.Institution_ID ORDER BY institution.Capacity DESC;,SELECT T1.Nickname FROM championship AS T1 JOIN institution AS T2 ON T1.Institution_ID  =  T2.Institution_ID ORDER BY T2.Capacity DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Championship.Nickname"" and ""institution.Capacity."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""institution"" and ""Championship"" tables based on the shared key ""Institution_ID"" to link institutions with their nicknames. 4. Aggregation Structure: No aggregation is needed, but apply ORDER BY in descending order of ""institution.Capacity"" to sort the results.",1.0
1621,Find the total value of boxes stored in the warehouse with the largest capacity.,NESTED,warehouse_1,"[Warehouses.Capacity, Warehouses.Code, Boxes.Value, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT SUM(Boxes.Value) AS total_value FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Capacity = (SELECT MAX(Capacity) FROM Warehouses);,SELECT sum(T1.value) FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code ORDER BY T2.capacity DESC LIMIT 1,1. Sequential Structure: Start with the SELECT clause to calculate the total value of boxes stored in a specific warehouse. Use the FROM clause to specify the Boxes table and join it with the Warehouses table to link boxes to their respective warehouses. Apply a WHERE clause to filter for the warehouse with the largest capacity. 2. Condition Structure: Use a WHERE clause with a subquery to filter for the warehouse with the maximum capacity. 3. Join Structure: Use an INNER JOIN between the Boxes and Warehouses tables based on the warehouse code to connect the boxes with their respective warehouses. 4. Aggregation Structure: Use the SUM function to calculate the total value of boxes stored in the warehouse with the largest capacity.,0.0
1622,Find the titles of movies that don’t have any rating.,NESTED,movie_2,"[Movies.Title, Movies.Rating]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Title FROM Movies WHERE Rating IS NULL;,SELECT title FROM movies WHERE rating  =  'null',"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of movies. Use the FROM clause to specify the Movies table. Apply a WHERE clause to filter movies that do not have any rating. 2. Condition Structure: Use the WHERE clause to check for movies where the Rating field is NULL, as this indicates that the movie does not have any rating. 3. Join Structure: Not required, as all the necessary data is in the Movies table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1623,What are the states that have more than 2 universities with an enrollment less than 3000?,NESTED,university_rank,"[university.State, university.Enrollment, university.University_ID, overall_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.State FROM university WHERE university.Enrollment < 3000 GROUP BY university.State HAVING COUNT(university.University_ID) > 2;,SELECT state FROM university WHERE enrollment  <  3000 GROUP BY state HAVING count(*)  >  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the states. Use the FROM clause to specify the university table. Apply a WHERE clause to filter universities with an enrollment of less than 3000. Use GROUP BY to group the results by state and HAVING to filter states with more than 2 universities meeting the condition. 2. Condition Structure: Use the WHERE clause to filter universities with an enrollment of less than 3000. Then, use the HAVING clause to ensure that only states with more than 2 such universities are included. 3. Join Structure: No JOIN is required, as all the necessary data is available in the university table. 4. Aggregation Structure: Use COUNT(*) to count the number of universities in each state that meet the enrollment condition, and filter states with a count greater than 2 using the HAVING clause.",1.0
1624,How many distinct provinces are the institutions in?,EASY,institution_sports,[institution.Province],"Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT COUNT(DISTINCT institution.Province) FROM institution;,SELECT count(DISTINCT Province) FROM institution,"1. Sequential Structure: Begin with the SELECT clause to count the distinct provinces from the ""institution"" table. 2. Condition Structure: No specific filtering condition is required as we are interested in all provinces. 3. Join Structure: No JOIN is necessary since all required data is within the ""institution"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique provinces.",1.0
1625,What are the ranks and names of all majors at Augustana College?,NON-NESTED,university_rank,"[major_ranking.Rank,major.Major_Name,university.University_Name,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID,university.University_Name = 'Augustana College']","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT major_ranking.Rank, major.Major_Name FROM major_ranking JOIN major ON major_ranking.Major_ID = major.Major_ID JOIN university ON major_ranking.University_ID = university.University_ID WHERE university.University_Name = 'Augustana College';","SELECT T1.rank ,  T3.major_name FROM Major_Ranking AS T1 JOIN University AS T2 JOIN Major AS T3 ON T1.university_id  =  T2.university_id AND T1.major_id  =  T3.major_id WHERE T2.university_name  =  'Augustana College'","1. Sequential Structure: Start with the SELECT clause to retrieve the ""major_ranking.Rank"" and ""major.Major_Name"" fields. 2. Condition Structure: Use a WHERE clause to filter for records where ""university.University_Name"" is 'Augustana College.' 3. Join Structure: Use JOINs to connect the ""major_ranking"" table with the ""major"" table on ""major_ranking.Major_ID = major.Major_ID"" and the ""university"" table on ""major_ranking.University_ID = university.University_ID"" to link the rankings and majors to the specific university. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without summarization.",1.0
1626,Give the stadium of the institution which is the greatest enrollment.,NESTED,institution_sports,"[institution.Stadium, institution.Enrollment]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT Stadium FROM institution WHERE Enrollment = (SELECT MAX(Enrollment) FROM institution);,SELECT Stadium FROM institution ORDER BY Enrollment DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the stadium of the institution. Use the FROM clause to specify the institution table. Apply a WHERE clause to filter for the institution with the greatest enrollment. 2. Condition Structure: Use a WHERE clause with a subquery to filter for the institution with the maximum enrollment. 3. Join Structure: Not required, as all data is in the institution table. 4. Aggregation Structure: Use MAX in a subquery to find the maximum enrollment and filter based on this value to retrieve the relevant stadium.",1.0
1627,Return the most common type of affiliation across all institutions.,EASY,institution_sports,[institution.Affiliation],"Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT institution.Affiliation FROM institution GROUP BY institution.Affiliation ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Affiliation FROM institution GROUP BY Affiliation ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the type of affiliation. 2. Aggregation Structure: Use COUNT to determine the frequency of each type of affiliation. 3. Grouping Structure: Use GROUP BY on ""institution.Affiliation"" to aggregate the results by each affiliation type. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank affiliations by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common type of affiliation. 6. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table.",1.0
1628,Find the code of boxes that are stored at the warehouses located at Chicago or New York.,NON-NESTED,warehouse_1,"[Boxes.Code, Warehouses.Location, Boxes.Warehouse = Warehouses.Code, Chicago, New York]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Boxes.Code FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location = 'Chicago' OR Warehouses.Location = 'New York';,SELECT T1.code FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'Chicago' OR T2.location  =  'New York',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Boxes.Code."" 2. Condition Structure: Use a WHERE clause to filter for warehouses located in ""Chicago"" or ""New York."" 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to associate each box with its respective warehouse. 4. Aggregation Structure: No aggregation is needed as the query only requires the codes of the boxes.",1.0
1629,What are the codes of boxes stored in warehouses in Chicago?,NON-NESTED,warehouse_1,"[Boxes.Code, Warehouses.Location, Boxes.Warehouse = Warehouses.Code, Chicago]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Boxes.Code FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location = 'Chicago';,SELECT T1.code FROM boxes AS T1 JOIN Warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'Chicago',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Boxes.Code"" field, as the question asks for the codes of boxes. 2. Condition Structure: Use a WHERE clause to filter for warehouses located in ""Chicago."" 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to associate each box with its respective warehouse. 4. Aggregation Structure: No aggregation is needed since the query only retrieves specific box codes.",1.0
1630,List the names of institutions in ascending alphabetical order.,EASY,institution_sports,[institution.Name],"Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT institution.Name FROM institution ORDER BY institution.Name ASC;,SELECT Name FROM institution ORDER BY Name ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the institution name. 2. Condition Structure: No specific filtering condition is required as we want all institution names. 3. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the institution names. 5. Ordering Structure: Use ORDER BY in ascending alphabetical order on ""institution.Name"".",1.0
1631,Select the title of all movies.,EASY,movie_2,[Movies.Title],"Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies;,SELECT title FROM movies,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""Movies.Title"". 2. Condition Structure: No specific filtering condition is required as the query asks for all movie titles. 3. Join Structure: No JOIN is required since all necessary data is within the ""Movies"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all movie titles.",1.0
1632,"For each location, what are the total, average, and maximum capacities of warehouses?",EASY,warehouse_1,"[Warehouses.Location, Warehouses.Capacity]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Location, SUM(Warehouses.Capacity) AS total_capacity, AVG(Warehouses.Capacity) AS average_capacity, MAX(Warehouses.Capacity) AS maximum_capacity FROM Warehouses GROUP BY Warehouses.Location;","SELECT sum(capacity) ,  avg(capacity) ,  max(capacity) ,  LOCATION FROM warehouses GROUP BY LOCATION","1. Sequential Structure: Begin with the SELECT clause to specify the location and the required aggregate values, which are the total, average, and maximum capacities. 2. Aggregation Structure: Use SUM, AVG, and MAX functions to calculate the total, average, and maximum capacities for warehouses at each location. 3. Grouping Structure: Use GROUP BY on ""Warehouses.Location"" to calculate these aggregate values for each location. 4. Join Structure: No JOIN is required since all necessary data is within the ""Warehouses"" table.",1.0
1633,What is the total value of boxes kept in the warehouse with the greatest capacity?,NESTED,warehouse_1,"[Warehouses.Capacity, Warehouses.Code, Boxes.Value, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT SUM(Boxes.Value) AS total_value FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Capacity = (SELECT MAX(Capacity) FROM Warehouses);,SELECT sum(T1.value) FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code ORDER BY T2.capacity DESC LIMIT 1,1. Sequential Structure: Start with the SELECT clause to calculate the total value of boxes. Use the FROM clause to specify the Boxes table and join it with the Warehouses table to link boxes to their respective warehouses. Apply a WHERE clause to filter for the warehouse with the greatest capacity. 2. Condition Structure: Use a WHERE clause with a subquery to filter for the warehouse with the maximum capacity. 3. Join Structure: Use an INNER JOIN between the Boxes and Warehouses tables based on the warehouse code to connect box values with their respective warehouses. 4. Aggregation Structure: Use SUM to calculate the total value of boxes in the warehouse with the greatest capacity.,0.0
1634,What is the total value of boxes contained in any location but Chicago?,NESTED,warehouse_1,"[Boxes.Value, Warehouses.Location, Boxes.Warehouse = Warehouses.Code, Chicago]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT SUM(Boxes.Value) AS total_value FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location != 'Chicago';,SELECT sum(T1.value) FROM boxes AS T1 JOIN Warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location != 'Chicago',1. Sequential Structure: Start with the SELECT clause to calculate the total value of boxes. Use the FROM clause to specify the Boxes table and JOIN it with the Warehouses table to link boxes with their respective warehouse locations. Apply a WHERE clause to exclude warehouses located in Chicago. 2. Condition Structure: Use the WHERE clause to filter out records where the location is Chicago. 3. Join Structure: Use an INNER JOIN between the Boxes and Warehouses tables based on the warehouse code to connect box values with their respective warehouse locations. 4. Aggregation Structure: Use the SUM function to calculate the total value of boxes for warehouses not located in Chicago.,1.0
1635,Find all the countries where some drivers have points above 150.,NON-NESTED,car_racing,"[driver.Country, driver.Points, team_driver.Driver_ID = driver.Driver_ID, 150]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT DISTINCT driver.Country FROM driver WHERE driver.Points > 150;,SELECT T1.Country FROM country AS T1 JOIN driver AS T2 ON T1.Country_ID  =  T2.Country WHERE T2.Points  >  150,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""driver.Country"" where drivers have points above 150. 2. Condition Structure: Use a WHERE clause to filter for drivers whose ""driver.Points"" are greater than 150. 3. Join Structure: No JOIN is necessary here, as the required information is available in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique countries are returned.",0.0
1636,What is the average salary of all intern jobs?,EASY,planet_1,"[Employee.Salary, Employee.Position]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT AVG(Employee.Salary) AS avg_salary FROM Employee WHERE Employee.Position = 'Intern';,"SELECT avg(Salary) FROM Employee WHERE POSITION  =  ""Intern"";","1. Sequential Structure: Begin with the SELECT clause to calculate the average salary for all intern jobs. 2. Condition Structure: Use a WHERE clause to filter for employees whose position is 'Intern'. 3. Join Structure: No JOIN is required since all necessary data is within the ""Employee"" table. 4. Aggregation Structure: Use the AVG function to calculate the average salary for the filtered records.",1.0
1637,Find the number of movies whose rating is not null.,EASY,movie_2,[Movies.Rating],"Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT COUNT(*) FROM Movies WHERE Movies.Rating IS NOT NULL;,"SELECT count(*) ,  rating FROM movies WHERE rating != 'null' GROUP BY rating","1. Sequential Structure: Start with the SELECT clause to count the number of movies. 2. Condition Structure: Use a WHERE clause to filter out movies where the ""Movies.Rating"" is null. 3. Join Structure: No JOIN is required since all necessary information is in the ""Movies"" table. 4. Aggregation Structure: Use COUNT to calculate the number of movies with a non-null rating.",0.0
1638,Find the names of movies that are played in any theater and the name of the corresponding theater.,NON-NESTED,movie_2,"[Movies.Title, MovieTheaters.Name, MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
","SELECT Movies.Title, MovieTheaters.Name FROM Movies JOIN MovieTheaters ON MovieTheaters.Movie = Movies.Code;","SELECT T1.title ,  T2.name FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie","1. Sequential Structure: Start with the SELECT clause to retrieve the names of movies (""Movies.Title"") and the names of theaters (""MovieTheaters.Name""). 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Movies"" and ""MovieTheaters"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to link movies with the theaters where they are played. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the names of movies and theaters.",1.0
1639,Find the code and content of all boxes whose value is higher than the value of all boxes with Scissors as content.,NESTED,warehouse_1,"[Boxes.Code, Boxes.Contents, Boxes.Value, Warehouses.Code = Boxes.Warehouse]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Code, Boxes.Contents FROM Boxes WHERE Boxes.Value > ALL (SELECT Boxes.Value FROM Boxes WHERE Boxes.Contents = 'Scissors');","SELECT code ,  CONTENTS FROM boxes WHERE value  >  (SELECT max(value) FROM boxes WHERE CONTENTS  =  'Scissors')","1. Sequential Structure: Start with the SELECT clause to retrieve the code and content of the boxes. Use the FROM clause to specify the Boxes table. Apply a WHERE clause to filter boxes whose value is higher than the value of all boxes with ""Scissors"" as content. 2. Condition Structure: Use the WHERE clause with a subquery to compare the value of each box to the maximum value of boxes with ""Scissors"" as content. The subquery retrieves the maximum value of boxes where the content is ""Scissors"". 3. Join Structure: Not required, as all the necessary data is within the Boxes table. 4. Aggregation Structure: Use a subquery with the MAX function to find the maximum value of boxes with ""Scissors"" as content, and compare this value in the main query.",0.0
1640,What is the list of drivers ordered by points in descending order?,EASY,car_racing,"[driver.Driver, driver.Points]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT driver.Driver, driver.Points FROM driver ORDER BY driver.Points DESC;",SELECT Driver FROM driver ORDER BY Points DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the driver names and their points. 2. Condition Structure: No specific filtering condition is required as we want the list of all drivers. 3. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in descending order based on ""driver.Points"".",1.0
1641,Find the team with two or more drivers and return the the manager and car owner of the team.,NON-NESTED,car_racing,"[team.Manager, team.Car_Owner, team_driver.Team_ID = team.Team_ID, team_driver.Driver_ID, driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT team.Manager, team.Car_Owner FROM team JOIN team_driver ON team.Team_ID = team_driver.Team_ID GROUP BY team.Team_ID HAVING COUNT(team_driver.Driver_ID) >= 2;","SELECT t1.manager ,  t1.car_owner FROM team AS t1 JOIN team_driver AS t2 ON t1.team_id  =  t2.team_id GROUP BY t2.team_id HAVING count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve the ""team.Manager"" and ""team.Car_Owner"" fields. 2. Condition Structure: Use a HAVING clause to filter for teams that have two or more drivers. 3. Join Structure: Use a JOIN between the ""team"" and ""team_driver"" tables based on ""team.Team_ID"" and ""team_driver.Team_ID"" to associate teams with their drivers. 4. Aggregation Structure: Use COUNT on ""team_driver.Driver_ID"" to count the number of drivers per team, then filter with HAVING to select teams with two or more drivers.",1.0
1642,Select the average value of all the boxes.,EASY,warehouse_1,[Boxes.Value],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT AVG(Boxes.Value) AS average_value FROM Boxes;,SELECT avg(value) FROM boxes,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average value of all the boxes. 2. Aggregation Structure: Use the AVG function to calculate the average value of the ""Boxes.Value"" field. 3. Condition Structure: No specific filtering condition is required as the query asks for the average value of all boxes. 4. Join Structure: No JOIN is required since all necessary data is within the ""Boxes"" table.",1.0
1643,What is the total value of boxes located in Chicago or New York?,NON-NESTED,warehouse_1,"[Boxes.Value,Boxes.Warehouse,Warehouses.Location,Boxes.Warehouse = Warehouses.Code,Chicago,New York]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT SUM(Boxes.Value) FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location = 'Chicago' OR Warehouses.Location = 'New York';,SELECT sum(T1.value) FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'Chicago' OR T2.location  =  'New York',"1. Sequential Structure: Start with the SELECT clause to calculate the total value of boxes. Use the SUM function on the ""Boxes.Value"" field. 2. Condition Structure: Use a WHERE clause to filter for warehouses located in ""Chicago"" or ""New York."" 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to associate each box with its warehouse location. 4. Aggregation Structure: Use the SUM function to calculate the total value of boxes that meet the specified location condition.",1.0
1644,Return the affiliations of instituions that are not in the city of Vancouver.,NESTED,institution_sports,"[institution.Affiliation, institution.City, institution.Institution_ID = Championship.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT Affiliation FROM institution WHERE City != 'Vancouver';,"SELECT Affiliation FROM institution WHERE City != ""Vancouver""","1. Sequential Structure: Start with the SELECT clause to retrieve the affiliations of institutions. Use the FROM clause to specify the institution table. Apply a WHERE clause to filter out institutions located in the city of Vancouver. 2. Condition Structure: Use the WHERE clause to exclude institutions where the city is 'Vancouver'. 3. Join Structure: Not required, as the data needed is available within the institution table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1645,List all university names in ascending order of their reputation points.,NON-NESTED,university_rank,"[university.University_Name, overall_ranking.Reputation_point, overall_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.University_Name FROM university JOIN overall_ranking ON overall_ranking.University_ID = university.University_ID ORDER BY overall_ranking.Reputation_point ASC;,SELECT T1.university_name FROM University AS T1 JOIN Overall_ranking AS T2 ON T1.university_id  =  T2.university_id ORDER BY T2.reputation_point,"1. Sequential Structure: Start with the SELECT clause to retrieve ""university.University_Name."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""university"" table and the ""overall_ranking"" table based on the shared key ""University_ID"" to link each university with its reputation points. 4. Aggregation Structure: No aggregation is needed, but apply ORDER BY on ""overall_ranking.Reputation_point"" in ascending order to sort the results.",1.0
1646,List the driver makes that are associated with at least three drivers.,NON-NESTED,car_racing,"[driver.Make, driver.Driver_ID, team_driver.Driver_ID = driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT driver.Make FROM driver JOIN team_driver ON team_driver.Driver_ID = driver.Driver_ID GROUP BY driver.Make HAVING COUNT(team_driver.Driver_ID) >= 3;,SELECT Make FROM driver GROUP BY Make HAVING COUNT(*)  >=  3,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""driver.Make"" values. 2. Condition Structure: Use a HAVING clause to filter for makes that are associated with at least three drivers. 3. Join Structure: Use a JOIN between the ""driver"" and ""team_driver"" tables based on ""Driver_ID"" to associate each driver with their respective team. 4. Aggregation Structure: Use COUNT on ""team_driver.Driver_ID"" to count the number of drivers associated with each make, then filter with HAVING to select makes with at least three drivers.",1.0
1647,Select all distinct contents in all the boxes.,EASY,warehouse_1,[Boxes.Contents],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Boxes.Contents FROM Boxes;,SELECT DISTINCT CONTENTS FROM boxes,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct contents from the ""Boxes"" table. 2. Condition Structure: No specific filtering condition is required as we want all distinct contents. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Boxes"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct values.",1.0
1648,What are the titles of all the movies that played at the Odeon or Imperial theater?,NON-NESTED,movie_2,"[Movies.Title, MovieTheaters.Name, MovieTheaters.Movie = Movies.Code, Odeon, Imperial]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies JOIN MovieTheaters ON MovieTheaters.Movie = Movies.Code WHERE MovieTheaters.Name = 'Odeon' OR MovieTheaters.Name = 'Imperial';,SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T2.name  =  'Odeon' OR T2.name  =  'Imperial',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Movies.Title"" field, which contains the titles of the movies. 2. Condition Structure: Use a WHERE clause to filter for records where the ""MovieTheaters.Name"" is either ""Odeon"" or ""Imperial."" 3. Join Structure: Use a JOIN between the ""Movies"" and ""MovieTheaters"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to link each movie with the theater where it played. 4. Aggregation Structure: No aggregation is needed as the query only requires listing movie titles.",1.0
1649,Find the number of all distinct contents in all the boxes.,EASY,warehouse_1,[Boxes.Contents],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT COUNT(DISTINCT Boxes.Contents) AS distinct_contents_count FROM Boxes;,SELECT count(DISTINCT CONTENTS) FROM boxes,"1. Sequential Structure: Begin with the SELECT clause to count the distinct contents in all the boxes. 2. Condition Structure: No specific filtering condition is required as we are interested in all distinct contents. 3. Join Structure: No JOIN is necessary since all the required data is contained within the ""Boxes"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique contents in the ""Boxes.Contents"" field.",1.0
1650,What is the name and citation point of the unversities with the top 3 reputation points?,NON-NESTED,university_rank,"[university.University_Name,overall_ranking.Citation_point,overall_ranking.Reputation_point,overall_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT university.University_Name, overall_ranking.Citation_point FROM university JOIN overall_ranking ON university.University_ID = overall_ranking.University_ID ORDER BY overall_ranking.Reputation_point DESC LIMIT 3;","SELECT T1.University_Name ,  T2.Citation_point FROM University AS T1 JOIN Overall_ranking AS T2 ON T1.university_id  =  T2.university_id ORDER BY T2.Reputation_point DESC LIMIT 3","1. Sequential Structure: Start with the SELECT clause to retrieve ""university.University_Name"" and ""overall_ranking.Citation_point."" 2. Condition Structure: Use ORDER BY in descending order on ""overall_ranking.Reputation_point"" to rank universities by their reputation points. Use LIMIT 3 to select the top 3 universities. 3. Join Structure: Use a JOIN between the ""university"" and ""overall_ranking"" tables based on the shared key ""University_ID"" to link each university with its ranking data. 4. Aggregation Structure: No aggregation is needed as we are only retrieving specific fields for the top 3 universities.",1.0
1651,What is the code and contents for the box that has the smallest value?,NESTED,warehouse_1,"[Boxes.Code, Boxes.Contents, Boxes.Value]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Code, Contents FROM Boxes WHERE Value = (SELECT MIN(Value) FROM Boxes);","SELECT code ,  CONTENTS FROM boxes ORDER BY value LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the code and contents of the box. Use the FROM clause to specify the Boxes table. Apply a WHERE clause to filter for the box with the smallest value. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the box where the value is equal to the minimum value in the Boxes table. 3. Join Structure: Not required, as all data is in the Boxes table. 4. Aggregation Structure: Use the MIN function in a subquery to find the smallest value in the Boxes table, which is then used in the filtering condition.",1.0
1652,How many institutions are there for each type of affiliation?,EASY,institution_sports,[institution.Affiliation],"Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT institution.Affiliation, COUNT(*) AS institution_count FROM institution GROUP BY institution.Affiliation;","SELECT Affiliation ,  COUNT(*) FROM institution GROUP BY Affiliation","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the type of affiliation and the count of institutions for each type. 2. Aggregation Structure: Use COUNT to calculate the number of institutions for each type of affiliation. 3. Grouping Structure: Use GROUP BY on ""institution.Affiliation"" to group the results by each type of affiliation. 4. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table.",1.0
1653,"For each warehouse location, what is the value of the most expensive box?",NON-NESTED,warehouse_1,"[Warehouses.Location, Boxes.Value, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Location, MAX(Boxes.Value) AS Most_Expensive_Box FROM Warehouses JOIN Boxes ON Boxes.Warehouse = Warehouses.Code GROUP BY Warehouses.Location;","SELECT max(T1.value) ,  T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code GROUP BY T2.location","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Warehouses.Location"" and the maximum ""Boxes.Value"" for each warehouse location. 2. Condition Structure: No specific filtering condition is required, as we are interested in the maximum value of boxes for each warehouse location. 3. Join Structure: Use a JOIN between the ""Warehouses"" and ""Boxes"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to associate each box with its respective warehouse. 4. Aggregation Structure: Use the MAX function on ""Boxes.Value"" to find the most expensive box for each warehouse location, and GROUP BY ""Warehouses.Location"" to group the results by warehouse location.",1.0
1654,What is all the information about the unrated movies?,EASY,movie_2,"[Movies.Code, Movies.Title, Movies.Rating, Movies.Rating = 'Unrated']","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT * FROM Movies WHERE Movies.Rating = 'Unrated';,SELECT * FROM movies WHERE rating  =  'null',"1. Sequential Structure: Start with the SELECT clause to retrieve all columns from the ""Movies"" table, as the question asks for all information about unrated movies. 2. Condition Structure: Use a WHERE clause to filter rows where ""Movies.Rating"" is equal to 'Unrated'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Movies"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving all information for a specific condition.",1.0
1655,How many distinct movie theaters are there?,EASY,movie_2,[MovieTheaters.Name],"Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT COUNT(DISTINCT MovieTheaters.Name) FROM MovieTheaters;,SELECT count(DISTINCT name) FROM movietheaters,"1. Sequential Structure: Start with the SELECT clause to count the distinct movie theater names, as the question asks for the number of distinct movie theaters. 2. Condition Structure: No specific filtering condition is required since we are counting all distinct movie theaters. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""MovieTheaters"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""MovieTheaters.Name"" to count the unique movie theaters.",1.0
1656,What are the movie names sorted by rating?,EASY,movie_2,"[Movies.Title, Movies.Rating]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies ORDER BY Movies.Rating;,SELECT title FROM movies ORDER BY rating,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the movie title. Include the rating for sorting purposes. 2. Condition Structure: No specific filtering condition is required as we want all movie names. 3. Join Structure: No JOIN is required since all necessary information is in the ""Movies"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by ""Movies.Rating"".",1.0
1657,Count the number of packages sent by Ogden Wernstrom and received by Leo Wong.,NON-NESTED,planet_1,"[Package.Sender, Package.Recipient, Client.Name, Package.Sender = Client.AccountNumber, Package.Recipient = Client.AccountNumber]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT COUNT(*) FROM Package JOIN Client AS SenderClient ON Package.Sender = SenderClient.AccountNumber JOIN Client AS RecipientClient ON Package.Recipient = RecipientClient.AccountNumber WHERE SenderClient.Name = 'Ogden Wernstrom' AND RecipientClient.Name = 'Leo Wong';,"SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name = ""Ogden Wernstrom"" INTERSECT SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Recipient  =  T2.AccountNumber WHERE T2.Name = ""Leo Wong""","1. Sequential Structure: Start with the SELECT clause to count the number of packages. Use COUNT to calculate the total number of packages sent by ""Ogden Wernstrom"" and received by ""Leo Wong."" 2. Condition Structure: Use a WHERE clause to filter packages where the sender is ""Ogden Wernstrom"" and the recipient is ""Leo Wong."" 3. Join Structure: Use JOINs to connect the ""Package"" table with the ""Client"" table twice: once to match the sender's account number with the client's account number and once to match the recipient's account number with the client's account number. 4. Aggregation Structure: Use COUNT to aggregate the total number of packages that meet the specified conditions.",1.0
1658,What is the total capacity of all warehouses?,EASY,warehouse_1,[Warehouses.Capacity],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT SUM(Warehouses.Capacity) AS total_capacity FROM Warehouses;,SELECT sum(capacity) FROM warehouses,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the total capacity of all warehouses. 2. Aggregation Structure: Use the SUM function to calculate the total capacity of all warehouses. 3. Condition Structure: No specific filtering condition is required since we are calculating the total capacity for all warehouses. 4. Join Structure: No JOIN is required as all necessary data is within the ""Warehouses"" table.",1.0
1659,What are all of the movie names?,EASY,movie_2,[Movies.Title],"Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies;,SELECT title FROM movies,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the movie title. 2. Condition Structure: No specific filtering condition is required as the query asks for all movie names. 3. Join Structure: No JOIN is required since all necessary data is within the ""Movies"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all movie titles.",1.0
1660,"What is the maximum, average, and minimum enrollment for universities?",EASY,university_rank,[university.Enrollment],"Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT MAX(university.Enrollment) AS max_enrollment, AVG(university.Enrollment) AS avg_enrollment, MIN(university.Enrollment) AS min_enrollment FROM university;","SELECT max(enrollment) ,  avg(enrollment) ,  min(enrollment) FROM University","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum, average, and minimum enrollments. 2. Aggregation Structure: Use MAX, AVG, and MIN functions to calculate the maximum, average, and minimum enrollment values, respectively. 3. Grouping Structure: No GROUP BY is needed since the query is asking for overall statistics across all universities. 4. Join Structure: No JOIN is required as all necessary data is within the ""university"" table.",1.0
1661,What types of contents cannot be found in warehouses in New York?,NESTED,warehouse_1,"[Boxes.Contents,Warehouses.Location,Boxes.Warehouse = Warehouses.Code,New York]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Boxes.Contents FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Boxes.Contents NOT IN ( SELECT DISTINCT Boxes.Contents FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location = 'New York' );,SELECT CONTENTS FROM boxes EXCEPT SELECT T1.contents FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'New York',"1. Sequential Structure: Start with the SELECT clause to retrieve the types of contents that cannot be found in warehouses located in New York. Use the FROM clause to specify the Boxes and Warehouses tables. Apply a WHERE clause to filter for warehouses not located in New York. 2. Condition Structure: Use the WHERE clause with a subquery to exclude contents that are found in warehouses located in New York. The subquery identifies all contents in warehouses in New York. 3. Join Structure: Use an INNER JOIN between the Boxes and Warehouses tables based on the relationship between Boxes.Warehouse and Warehouses.Code to connect contents with their respective warehouse locations. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1662,What are the average and total values across all boxes?,EASY,warehouse_1,[Boxes.Value],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT AVG(Boxes.Value) AS average_value, SUM(Boxes.Value) AS total_value FROM Boxes;","SELECT avg(value) ,  sum(value) FROM boxes","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average and total values across all boxes. 2. Aggregation Structure: Use AVG to calculate the average value and SUM to calculate the total value of all boxes. 3. Condition Structure: No specific filtering condition is required as the query involves all boxes. 4. Join Structure: No JOIN is required since all necessary data is within the ""Boxes"" table.",1.0
1663,"What are the affiliations of institutions that are not in city ""Vancouver""?",NON-NESTED,institution_sports,"[institution.Affiliation, institution.City, institution.Institution_ID = Championship.Institution_ID, Vancouver]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT institution.Affiliation FROM institution WHERE institution.City != 'Vancouver';,"SELECT Affiliation FROM institution WHERE City != ""Vancouver""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""institution.Affiliation"" field, as the question asks for the affiliations of institutions. 2. Condition Structure: Use a WHERE clause to filter out institutions that are located in the city ""Vancouver."" 3. Join Structure: No JOIN is required since the necessary information is available in the ""institution"" table. 4. Aggregation Structure: No aggregation is needed as the query only retrieves affiliations without any summarization.",1.0
1664,Find the name of the theater that is playing the most number of movies.,NON-NESTED,movie_2,"[MovieTheaters.Name, MovieTheaters.Movie, Movies.Code = MovieTheaters.Movie]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT MovieTheaters.Name FROM MovieTheaters GROUP BY MovieTheaters.Name ORDER BY COUNT(MovieTheaters.Movie) DESC LIMIT 1;,SELECT name FROM movietheaters GROUP BY name ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the theater (""MovieTheaters.Name""). Use COUNT to count the number of movies being played by each theater. 2. Condition Structure: No specific filtering condition is required, as we are interested in all theaters. 3. Join Structure: No JOIN is necessary since the relevant data is contained within the ""MovieTheaters"" table, and the relationship between movies and theaters is already established. 4. Aggregation Structure: Use COUNT to count the number of movies for each theater, GROUP BY ""MovieTheaters.Name"" to group the results by theater, and ORDER BY the count in descending order to find the theater playing the most movies. Use LIMIT 1 to select the top result.",1.0
1665,Return the cities and provinces of institutions.,EASY,institution_sports,"[institution.City, institution.Province]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT institution.City, institution.Province FROM institution;","SELECT City ,  Province FROM institution","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the city and province of institutions. 2. Condition Structure: No specific filtering condition is required as the query aims to retrieve all cities and provinces of institutions. 3. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the city and province information.",1.0
1666,What are the home conferences that have an average university enrollment above 2000?,NESTED,university_rank,"[university.Home_Conference, university.Enrollment]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT Home_Conference FROM university GROUP BY Home_Conference HAVING AVG(Enrollment) > 2000;,SELECT home_conference FROM University GROUP BY home_conference HAVING avg(enrollment)  >  2000,"1. Sequential Structure: Start with the SELECT clause to retrieve the home conferences. Use the FROM clause to specify the university table. Apply a GROUP BY clause to group records by home conferences and calculate the average enrollment for each conference. Use the HAVING clause to filter for conferences with an average enrollment above 2000. 2. Condition Structure: Use the HAVING clause to filter groups where the average enrollment is greater than 2000. 3. Join Structure: Not required, as all data is available within the university table. 4. Aggregation Structure: Use the AVG function to calculate the average enrollment for each home conference and filter based on the condition.",1.0
1667,What position does Amy Wong have?,EASY,planet_1,"[Employee.Name, Employee.Position]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Employee.Position FROM Employee WHERE Employee.Name = 'Amy Wong';,"SELECT POSITION FROM Employee WHERE Name  =  ""Amy Wong"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Employee.Position"" of the employee named ""Amy Wong"". 2. Condition Structure: Use a WHERE clause to filter for the employee whose ""Employee.Name"" is ""Amy Wong"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Employee"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
1668,What are the names of every theater with at least one movie playing?,NON-NESTED,movie_2,"[MovieTheaters.Name, MovieTheaters.Movie, Movies.Code = MovieTheaters.Movie]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT DISTINCT MovieTheaters.Name FROM MovieTheaters JOIN Movies ON Movies.Code = MovieTheaters.Movie;,SELECT name FROM movietheaters GROUP BY name HAVING count(*)  >=  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of theaters. 2. Condition Structure: No specific filtering condition is needed, as we are interested in theaters with at least one movie playing. 3. Join Structure: Use a JOIN between the ""MovieTheaters"" and ""Movies"" tables based on the relationship ""Movies.Code = MovieTheaters.Movie"" to ensure that only theaters with movies playing are included. 4. Aggregation Structure: Use DISTINCT to ensure unique theater names are returned.",0.0
1669,What is Turanga Leela's salary and position?,EASY,planet_1,"[Employee.Name, Employee.Salary, Employee.Position]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Employee.Salary, Employee.Position FROM Employee WHERE Employee.Name = 'Turanga Leela';","SELECT Salary ,  POSITION FROM Employee WHERE Name  =  ""Turanga Leela"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Employee.Salary"" and ""Employee.Position"" for the employee named ""Turanga Leela"". 2. Condition Structure: Use a WHERE clause to filter for the employee whose name is ""Turanga Leela"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Employee"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields for a single employee.",1.0
1670,What is the name of the university with the most research points?,NON-NESTED,university_rank,"[university.University_Name,overall_ranking.Research_point,overall_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.University_Name FROM university JOIN overall_ranking ON overall_ranking.University_ID = university.University_ID ORDER BY overall_ranking.Research_point DESC LIMIT 1;,SELECT T1.university_name FROM University AS T1 JOIN Overall_ranking AS T2 ON T1.university_id  =  T2.university_id ORDER BY T2.research_point DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""university.University_Name"" of the university with the most research points. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the university with the highest research points. 3. Join Structure: Use a JOIN between the ""university"" table and the ""overall_ranking"" table based on the ""University_ID"" to link each university with its research points. 4. Aggregation Structure: Use ORDER BY in descending order on ""overall_ranking.Research_point"" to rank universities by research points. Use LIMIT 1 to select the university with the highest research points.",1.0
1671,Which state has most number of universities?,EASY,university_rank,"[university.State, university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.State FROM university GROUP BY university.State ORDER BY COUNT(university.University_ID) DESC LIMIT 1;,SELECT state FROM University GROUP BY state ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the state, as the question asks for the state with the most universities. 2. Aggregation Structure: Use COUNT to calculate the number of universities in each state. 3. Grouping Structure: Use GROUP BY on ""university.State"" to count universities for each state. 4. Ordering Structure: Use ORDER BY in descending order on the count of universities to rank states by the number of universities. 5. Limiting Structure: Use LIMIT 1 to retrieve the state with the highest number of universities. 6. Join Structure: No JOIN is required since all necessary data is within the ""university"" table.",1.0
1672,What is the average value of boxes?,EASY,warehouse_1,[Boxes.Value],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT AVG(Boxes.Value) AS average_value FROM Boxes;,SELECT avg(value) FROM boxes,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average value of boxes. 2. Aggregation Structure: Use the AVG function to calculate the average value of the ""Boxes.Value"" field. 3. Condition Structure: No specific filtering condition is required as the query aims to calculate the average value for all boxes. 4. Join Structure: No JOIN is required since all necessary data is within the ""Boxes"" table.",1.0
1673,What is the name and rank of every university in Wisconsin?,NON-NESTED,university_rank,"[university.University_Name,university.State,university.University_ID,overall_ranking.Rank,overall_ranking.University_ID = university.University_ID,Wisconsin]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT university.University_Name, overall_ranking.Rank FROM university JOIN overall_ranking ON university.University_ID = overall_ranking.University_ID WHERE university.State = 'Wisconsin';","SELECT T1.university_name ,  T2.rank FROM University AS T1 JOIN Overall_ranking AS T2 ON T1.university_id  =  T2.university_id WHERE T1.state  =  'Wisconsin'","1. Sequential Structure: Start with the SELECT clause to retrieve ""university.University_Name"" and ""overall_ranking.Rank."" 2. Condition Structure: Use a WHERE clause to filter for universities located in the state of Wisconsin. 3. Join Structure: Use an INNER JOIN between the ""university"" table and the ""overall_ranking"" table based on the shared key ""University_ID"" to associate each university with its rank. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without summarization.",1.0
1674,What are the names of all teams from universities that have more people enrolled than average ?,NESTED,university_rank,"[university.Team_Name, university.Enrollment, overall_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT Team_Name FROM university WHERE Enrollment > (SELECT AVG(Enrollment) FROM university);,select team_name from university where enrollment  >  (select avg(enrollment) from university),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of teams. Use the FROM clause to specify the university table. Apply a WHERE clause to filter universities with enrollments greater than the average enrollment. 2. Condition Structure: Use the WHERE clause with a subquery to compare each university's enrollment to the average enrollment across all universities. 3. Join Structure: Not required, as the relevant data (team names and enrollments) is available within the university table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average enrollment, which is then used in the filtering condition.",1.0
1675,Find the name of the cinemas that are playing movies with either rating ‘G’ or rating ‘PG’.,NON-NESTED,movie_2,"[MovieTheaters.Name,Movies.Rating,MovieTheaters.Movie = Movies.Code,G,PG]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT MovieTheaters.Name FROM MovieTheaters JOIN Movies ON MovieTheaters.Movie = Movies.Code WHERE Movies.Rating = 'G' OR Movies.Rating = 'PG';,SELECT title FROM movies WHERE rating  =  'G' OR rating  =  'PG',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of cinemas, i.e., ""MovieTheaters.Name."" 2. Condition Structure: Use a WHERE clause to filter for movies with a rating of either 'G' or 'PG.' 3. Join Structure: Use a JOIN between the ""MovieTheaters"" and ""Movies"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to link cinemas with the movies they are playing. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of cinemas that meet the condition.",0.0
1676,Find the name of theaters that has at least one movie playing.,NON-NESTED,movie_2,"[MovieTheaters.Name,MovieTheaters.Movie,Movies.Code,MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT DISTINCT MovieTheaters.Name FROM MovieTheaters JOIN Movies ON MovieTheaters.Movie = Movies.Code;,SELECT name FROM movietheaters GROUP BY name HAVING count(*)  >=  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of theaters. 2. Condition Structure: Use a WHERE clause to filter theaters that have at least one movie playing. This is implied by the presence of a matching movie code in the ""Movies"" table. 3. Join Structure: Use a JOIN between the ""MovieTheaters"" and ""Movies"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to link theaters with their respective movies. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique theater names are returned.",0.0
1677,What is the clearance level of a physician?,NON-NESTED,planet_1,"[Employee.Position, Has_Clearance.Level, Has_Clearance.Employee = Employee.EmployeeID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Has_Clearance.Level FROM Employee JOIN Has_Clearance ON Has_Clearance.Employee = Employee.EmployeeID WHERE Employee.Position = 'Physician';,"SELECT T1.Level FROM Has_Clearance AS T1 JOIN Employee AS T2 ON T1.Employee = T2.EmployeeID WHERE T2.position  =  ""Physician"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Has_Clearance.Level,"" which represents the clearance level of an employee. 2. Condition Structure: Use a WHERE clause to filter for employees whose position is ""Physician."" 3. Join Structure: Use a JOIN between the ""Employee"" table and the ""Has_Clearance"" table based on the relationship ""Has_Clearance.Employee = Employee.EmployeeID"" to link employees with their clearance levels. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific information for a particular position.",1.0
1678,How many universities are in Illinois or Ohio?,EASY,university_rank,"[university.University_ID, university.State, Illinois, Ohio]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT COUNT(university.University_ID) FROM university WHERE university.State = 'Illinois' OR university.State = 'Ohio';,SELECT count(*) FROM University WHERE state  =  'Illinois' OR state  =  'Ohio',"1. Sequential Structure: Begin with the SELECT clause to count the number of universities. 2. Condition Structure: Use a WHERE clause to filter universities located in either Illinois or Ohio. 3. Join Structure: No JOIN is required since all necessary data is within the ""university"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of universities that meet the specified condition.",1.0
1679,What are the contents of package sent by John Zoidfarb?,NON-NESTED,planet_1,"[Package.Contents,Package.Sender,Client.Name,Package.Sender = Client.AccountNumber,John Zoidfarb]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Package.Contents FROM Package JOIN Client ON Package.Sender = Client.AccountNumber WHERE Client.Name = 'John Zoidfarb';,"SELECT T1.Contents FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name  =  ""John Zoidfarb"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Package.Contents"" field, as the question asks for the contents of the package. 2. Condition Structure: Use a WHERE clause to filter for packages sent by ""John Zoidfarb."" This requires matching the ""Package.Sender"" field with the ""Client.AccountNumber"" and filtering by ""Client.Name = 'John Zoidfarb'."" 3. Join Structure: Use a JOIN between the ""Package"" and ""Client"" tables based on the relationship ""Package.Sender = Client.AccountNumber"" to associate packages with their senders. 4. Aggregation Structure: No aggregation is needed, as the query only retrieves specific package contents.",1.0
1680,What is the name of the university with the most majors ranked number 1?,NON-NESTED,university_rank,"[university.University_Name,major_ranking.University_ID = university.University_ID,major_ranking.Major_ID,major_ranking.Rank,major.Major_ID,1]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.University_Name FROM university JOIN major_ranking ON university.University_ID = major_ranking.University_ID JOIN major ON major_ranking.Major_ID = major.Major_ID WHERE major_ranking.Rank = 1 GROUP BY university.University_Name ORDER BY COUNT(major_ranking.Major_ID) DESC LIMIT 1;,SELECT T2.university_name FROM Major_Ranking AS T1 JOIN University AS T2 ON T1.university_id  =  T2.university_id WHERE T1.rank  =  1 GROUP BY T2.university_name ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""university.University_Name"" of the university with the most majors ranked number 1. Use COUNT to count the number of majors ranked number 1 for each university. 2. Condition Structure: Use a WHERE clause to filter for records where ""major_ranking.Rank"" is equal to 1. 3. Join Structure: Use JOINs to connect the ""university"" table with the ""major_ranking"" table on ""university.University_ID = major_ranking.University_ID"" and the ""major_ranking"" table with the ""major"" table on ""major_ranking.Major_ID = major.Major_ID."" 4. Aggregation Structure: Use COUNT to count the number of majors ranked number 1 for each university, GROUP BY ""university.University_Name"" to group the results by university, and ORDER BY the count in descending order. Use LIMIT 1 to get the university with the most majors ranked number 1.",1.0
1681,Find the name of all movies that are not played in Odeon theater.,NESTED,movie_2,"[Movies.Title, MovieTheaters.Name, MovieTheaters.Movie = Movies.Code, Odeon]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies WHERE Movies.Code NOT IN (SELECT MovieTheaters.Movie FROM MovieTheaters WHERE MovieTheaters.Name = 'Odeon');,SELECT title FROM movies EXCEPT SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T2.name  =  'Odeon',"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of movies. Use the FROM clause to specify the Movies table. Apply a WHERE clause to filter out movies that are played in the Odeon theater. 2. Condition Structure: Use the WHERE clause with a subquery to exclude movies whose codes are associated with the Odeon theater in the MovieTheaters table. 3. Join Structure: Not required, as the filtering can be done using a subquery to check the MovieTheaters table for movies played in the Odeon theater. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1682,Select contents of all boxes with a value larger than $150.,EASY,warehouse_1,"[Boxes.Contents, Boxes.Value, 150]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Boxes.Contents FROM Boxes WHERE Boxes.Value > 150;,SELECT CONTENTS FROM boxes WHERE Value  >  150,"1. Sequential Structure: Start with the SELECT clause to specify the field ""Boxes.Contents"" as we need to retrieve the contents of the boxes. 2. Condition Structure: Use a WHERE clause to filter for boxes where ""Boxes.Value"" is greater than 150. 3. Join Structure: No JOIN is required since all necessary information is in the ""Boxes"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the contents of boxes that meet the specified value condition.",1.0
1683,Select the warehouse codes along with the number of boxes in each warehouse.,NON-NESTED,warehouse_1,"[Warehouses.Code, Boxes.Warehouse, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Code, COUNT(Boxes.Warehouse) AS NumberOfBoxes FROM Warehouses JOIN Boxes ON Boxes.Warehouse = Warehouses.Code GROUP BY Warehouses.Code;","SELECT Warehouse ,  count(*) FROM boxes GROUP BY warehouse","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Warehouses.Code"" and the count of boxes in each warehouse. Use COUNT on ""Boxes.Warehouse"" to count the number of boxes. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Warehouses"" and ""Boxes"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to associate each warehouse with its boxes. 4. Aggregation Structure: Use COUNT to aggregate the number of boxes for each warehouse and GROUP BY ""Warehouses.Code"" to group the results by warehouse code.",1.0
1684,"What are the different contents of boxes, ordered alphabetically?",EASY,warehouse_1,[Boxes.Contents],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Boxes.Contents FROM Boxes ORDER BY Boxes.Contents ASC;,SELECT DISTINCT CONTENTS FROM boxes ORDER BY CONTENTS,"1. Sequential Structure: Begin with the SELECT clause to specify the field ""Boxes.Contents"" as we are interested in the different contents of boxes. 2. Condition Structure: No specific filtering condition is required since we want all distinct contents. 3. Join Structure: No JOIN is necessary as all the required data is in the ""Boxes"" table. 4. Aggregation Structure: Use DISTINCT to ensure only unique contents are retrieved. Use ORDER BY to sort the results alphabetically.",1.0
1685,List team name for all universities with enrollments above the average.,NESTED,university_rank,"[university.Team_Name, university.Enrollment]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT Team_Name FROM university WHERE Enrollment > (SELECT AVG(Enrollment) FROM university);,SELECT team_name FROM University WHERE enrollment  >  (SELECT avg(enrollment) FROM University),"1. Sequential Structure: Start with the SELECT clause to retrieve the team names of universities. Use the FROM clause to specify the university table. Apply a WHERE clause to filter universities with enrollments above the average enrollment. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average enrollment and filter universities whose enrollment is greater than this value. 3. Join Structure: Not required, as all data is available within the university table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average enrollment, which is then used in the filtering condition.",1.0
1686,which states do have more than two universities with enrollment smaller than 3000?,NESTED,university_rank,"[university.State, university.Enrollment, university.University_ID, overall_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.State FROM university WHERE university.Enrollment < 3000 GROUP BY university.State HAVING COUNT(university.University_ID) > 2;,SELECT state FROM university WHERE enrollment  <  3000 GROUP BY state HAVING count(*)  >  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the states. Use the FROM clause to specify the university table. Apply a WHERE clause to filter universities with enrollment smaller than 3000. Use GROUP BY to group records by state and HAVING to filter states with more than two universities meeting the condition. 2. Condition Structure: Use the WHERE clause to filter universities with enrollment smaller than 3000. Then, use the HAVING clause to ensure only states with more than two such universities are included. 3. Join Structure: No JOIN is required, as all necessary data is available in the university table. 4. Aggregation Structure: Use COUNT(*) to count the number of universities per state that meet the enrollment condition, and filter states with a count greater than two using the HAVING clause.",1.0
1687,How many different movies are playing?,NON-NESTED,movie_2,"[Movies.Code, MovieTheaters.Movie, MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT COUNT(DISTINCT Movies.Code) FROM Movies JOIN MovieTheaters ON MovieTheaters.Movie = Movies.Code;,SELECT count(DISTINCT T1.code) FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie,"1. Sequential Structure: Start with the SELECT clause to count the distinct movies. Use COUNT with DISTINCT on ""Movies.Code"" to determine the number of unique movies. 2. Condition Structure: No specific filtering condition is required, as we are interested in all movies playing. 3. Join Structure: Use a JOIN between the ""Movies"" and ""MovieTheaters"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to link movies with theaters where they are playing. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique movie codes.",1.0
1688,Count the number of different provinces that have institutions.,EASY,institution_sports,[institution.Province],"Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT COUNT(DISTINCT institution.Province) FROM institution;,SELECT count(DISTINCT Province) FROM institution,"1. Sequential Structure: Begin with the SELECT clause to count the number of distinct provinces. 2. Condition Structure: No specific filtering condition is required as we are counting all distinct provinces. 3. Join Structure: No JOIN is necessary since all required data is within the ""institution"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""institution.Province"" to count the unique provinces.",1.0
1689,Which countries do not have any drivers?,NESTED,car_racing,"[country.Country,driver.Country,team_driver.Driver_ID = driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT country.Country FROM country WHERE country.Country NOT IN (SELECT driver.Country FROM driver);,SELECT country FROM country WHERE country_id NOT IN (SELECT country FROM driver),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries. Use the FROM clause to specify the country table. Apply a WHERE clause to filter countries that do not have any drivers by ensuring that the country name is not present in the driver table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude countries whose names appear in the driver table, meaning they have drivers. 3. Join Structure: Not required, as we only need to filter based on the absence of matching country names in the driver table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1690,What is the average value of boxes for each warehouse?,NON-NESTED,warehouse_1,"[Boxes.Value, Boxes.Warehouse, Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Code, AVG(Boxes.Value) AS AverageValue FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code GROUP BY Warehouses.Code;","SELECT warehouse ,  avg(value) FROM boxes GROUP BY warehouse","1. Sequential Structure: Start with the SELECT clause to retrieve the average value of boxes for each warehouse. Include the warehouse identifier in the SELECT clause to group the results by warehouse. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship between ""Boxes.Warehouse"" and ""Warehouses.Code"" to associate each box with its respective warehouse. 4. Aggregation Structure: Use the AVG function to calculate the average value of boxes for each warehouse, and GROUP BY the warehouse identifier to group the results by warehouse.",1.0
1691,What movie is playing at both the Odeon and Imperial theater?,NESTED,movie_2,"[MovieTheaters.Name,MovieTheaters.Movie,Movies.Code = MovieTheaters.Movie]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
","SELECT MovieTheaters.Movie FROM MovieTheaters WHERE MovieTheaters.Name IN ('Odeon', 'Imperial') GROUP BY MovieTheaters.Movie HAVING COUNT(DISTINCT MovieTheaters.Name) = 2;",SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T2.name  =  'Odeon' INTERSECT SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T2.name  =  'Imperial',"1. Sequential Structure: Start with the SELECT clause to retrieve the movie name. Use the FROM clause to specify the MovieTheaters table. Apply a WHERE clause to filter for movies that are playing at both the Odeon and Imperial theaters. 2. Condition Structure: Use the WHERE clause with a subquery to identify movies that are playing at both theaters. This can be achieved by grouping by the movie and filtering for movies that appear in both theaters using a HAVING clause. 3. Join Structure: Not required, as all necessary data is available in the MovieTheaters table. 4. Aggregation Structure: Use GROUP BY to group records by movie and HAVING to filter for movies that are associated with both theaters.",1.0
1692,"Show the maximum points of the drivers from countries with capital ""Dublin""",NON-NESTED,car_racing,"[driver.Points,driver.Country,country.Capital,country.Country = driver.Country,Dublin]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT MAX(driver.Points) FROM driver JOIN country ON country.Country = driver.Country WHERE country.Capital = 'Dublin';,"SELECT max(T2.Points) FROM country AS T1 JOIN driver AS T2 ON T1.Country_ID  =  T2.Country WHERE T1.Capital  =  ""Dublin""","1. Sequential Structure: Start with the SELECT clause to retrieve the maximum points of drivers. Use the MAX function on ""driver.Points"" to find the highest points. 2. Condition Structure: Use a WHERE clause to filter drivers whose country has the capital ""Dublin."" This requires filtering based on the relationship between ""driver.Country"" and ""country.Country,"" and checking if ""country.Capital"" is ""Dublin."" 3. Join Structure: Use an INNER JOIN to connect the ""driver"" table with the ""country"" table based on the relationship ""country.Country = driver.Country."" 4. Aggregation Structure: Use the MAX function to compute the maximum points among the filtered drivers.",0.0
1693,What are the contents of boxes with value greater than 150?,EASY,warehouse_1,"[Boxes.Contents, Boxes.Value]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Boxes.Contents FROM Boxes WHERE Boxes.Value > 150;,SELECT CONTENTS FROM boxes WHERE Value  >  150,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the ""Boxes.Contents"". 2. Condition Structure: Use a WHERE clause to filter for boxes where the ""Boxes.Value"" is greater than 150. 3. Join Structure: No JOIN is required since all necessary information is in the ""Boxes"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the contents of boxes that meet the specified value condition.",1.0
1694,Return the nickname of the institution with the lowest enrollment.,NESTED,institution_sports,"[institution.Enrollment, institution.Institution_ID = Championship.Institution_ID, Championship.Nickname]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT Championship.Nickname FROM institution JOIN Championship ON institution.Institution_ID = Championship.Institution_ID WHERE institution.Enrollment = (SELECT MIN(Enrollment) FROM institution);,SELECT T1.Nickname FROM championship AS T1 JOIN institution AS T2 ON T1.Institution_ID  =  T2.Institution_ID ORDER BY T2.Enrollment ASC LIMIT 1,1. Sequential Structure: Start with the SELECT clause to retrieve the nickname of the institution. Use the FROM clause to specify the institution and championship tables. Apply a WHERE clause to filter for the institution with the lowest enrollment. 2. Condition Structure: Use a WHERE clause with a subquery to identify the institution with the minimum enrollment. 3. Join Structure: Use an INNER JOIN between the institution and championship tables based on Institution_ID to connect the enrollment data with the nickname. 4. Aggregation Structure: Use MIN in a subquery to find the lowest enrollment and filter based on this value to retrieve the corresponding nickname.,0.0
1695,List all package numbers received by Leo Wong ?,NON-NESTED,planet_1,"[Package.PackageNumber,Client.Name,Package.Recipient = Client.AccountNumber,Leo Wong]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Package.PackageNumber FROM Package JOIN Client ON Package.Recipient = Client.AccountNumber WHERE Client.Name = 'Leo Wong';,"select t1.packagenumber from package as t1 join client as t2 on t1.recipient  =  t2.accountnumber where t2.name = ""leo wong"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Package.PackageNumber"" field, which represents the package numbers. 2. Condition Structure: Use a WHERE clause to filter for packages where the recipient is ""Leo Wong."" This requires matching the ""Package.Recipient"" field with the ""Client.AccountNumber"" field and filtering for the client name ""Leo Wong."" 3. Join Structure: Use a JOIN between the ""Package"" and ""Client"" tables based on the relationship ""Package.Recipient = Client.AccountNumber"" to associate packages with their recipients. 4. Aggregation Structure: No aggregation is needed as the query only retrieves package numbers.",1.0
1696,What are the names of every movie that is not playing at the Odeon theater?,NESTED,movie_2,"[Movies.Title, MovieTheaters.Name, MovieTheaters.Movie = Movies.Code, Odeon]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies JOIN MovieTheaters ON MovieTheaters.Movie = Movies.Code WHERE Movies.Code NOT IN (SELECT MovieTheaters.Movie FROM MovieTheaters WHERE MovieTheaters.Name = 'Odeon');,SELECT title FROM movies EXCEPT SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T2.name  =  'Odeon',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of movies. Use the FROM clause to specify the Movies table and join it with the MovieTheaters table to link movies with the theaters where they are playing. Apply a WHERE clause to filter out movies that are playing at the Odeon theater. 2. Condition Structure: Use the WHERE clause with a subquery to exclude movies that are associated with the Odeon theater. The subquery identifies the codes of movies playing at the Odeon theater. 3. Join Structure: Use an INNER JOIN between the Movies and MovieTheaters tables based on the relationship between MovieTheaters.Movie and Movies.Code to connect movies with their respective theaters. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
1697,Select the warehouse code and the average value of the boxes in each warehouse.,NON-NESTED,warehouse_1,"[Warehouses.Code, Boxes.Value, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Code, AVG(Boxes.Value) AS AverageValue FROM Warehouses JOIN Boxes ON Boxes.Warehouse = Warehouses.Code GROUP BY Warehouses.Code;","SELECT warehouse ,  avg(value) FROM boxes GROUP BY warehouse","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Warehouses.Code"" and the average value of the boxes in each warehouse. Use the AVG function to calculate the average value of the boxes. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Warehouses"" and ""Boxes"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to associate each box with its respective warehouse. 4. Aggregation Structure: Use AVG to calculate the average value of the boxes and GROUP BY ""Warehouses.Code"" to group the results by each warehouse.",1.0
1698,Find the countries where no driver come from.,NESTED,car_racing,"[country.Country, driver.Country]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT country.Country FROM country WHERE country.Country NOT IN (SELECT driver.Country FROM driver);,SELECT country FROM country WHERE country_id NOT IN (SELECT country FROM driver),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries. Use the FROM clause to specify the country table. Apply a WHERE clause to filter countries that do not have any drivers associated with them. 2. Condition Structure: Use the WHERE clause with a subquery to exclude countries that appear in the driver table, ensuring we only select countries with no drivers. 3. Join Structure: Not required, as we are only filtering based on the absence of matching entries in the driver table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1699,List the code and contents of all boxes sorted by their values.,EASY,warehouse_1,"[Boxes.Code, Boxes.Contents, Boxes.Value]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Code, Boxes.Contents, Boxes.Value FROM Boxes ORDER BY Boxes.Value;","SELECT code ,  CONTENTS FROM boxes ORDER BY value","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""Boxes.Code"", ""Boxes.Contents"", and ""Boxes.Value"". 2. Condition Structure: No specific filtering condition is required as the query asks for all boxes. 3. Join Structure: No JOIN is required since all necessary data is within the ""Boxes"" table. 4. Aggregation Structure: No aggregation is needed as the query does not involve any summarization or grouping. 5. Ordering Structure: Use ORDER BY on ""Boxes.Value"" to sort the results by their values.",1.0
1700,How many movies have a rating that is not null?,EASY,movie_2,[Movies.Rating],"Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT COUNT(*) FROM Movies WHERE Movies.Rating IS NOT NULL;,"SELECT count(*) ,  rating FROM movies WHERE rating != 'null' GROUP BY rating","1. Sequential Structure: Start with the SELECT clause to count the number of movies with a non-null rating. 2. Condition Structure: Use a WHERE clause to filter out rows where the ""Movies.Rating"" is null. 3. Join Structure: No JOIN is required since all necessary information is in the ""Movies"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of movies with a non-null rating.",0.0
1701,What is the total number of students enrolled in an university with a rank of 5 or below?,NON-NESTED,university_rank,"[university.Enrollment,overall_ranking.Rank,overall_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT SUM(university.Enrollment) FROM university JOIN overall_ranking ON overall_ranking.University_ID = university.University_ID WHERE overall_ranking.Rank <= 5;,SELECT sum(enrollment) FROM University AS T1 JOIN Overall_ranking AS T2 ON T1.university_id  =  T2.university_id WHERE T2.rank  >=  5,"1. Sequential Structure: Start with the SELECT clause to calculate the total number of students enrolled. Use the SUM function on ""university.Enrollment."" 2. Condition Structure: Use a WHERE clause to filter universities with a rank of 5 or below. This requires filtering on ""overall_ranking.Rank."" 3. Join Structure: Use an INNER JOIN to connect the ""university"" table with the ""overall_ranking"" table based on the shared key ""University_ID."" 4. Aggregation Structure: Use SUM to aggregate the total enrollment of universities that meet the rank condition.",0.0
1702,List the names of institutions in ascending order of founded year.,EASY,institution_sports,"[institution.Name, institution.Founded]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT institution.Name FROM institution ORDER BY institution.Founded ASC;,SELECT Name FROM institution ORDER BY Founded ASC,"1. Sequential Structure: Start with the SELECT clause to specify the field ""institution.Name"" as we need the names of institutions. 2. Condition Structure: No specific filtering condition is required since we want all institutions. 3. Join Structure: No JOIN is required as all necessary information is in the ""institution"" table. 4. Aggregation Structure: No aggregation is needed since we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""institution.Founded"" in ascending order to sort the institutions by their founded year.",1.0
1703,What are the names and codes for all majors ordered by their code?,EASY,university_rank,"[major.Major_Name, major.Major_Code]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT major.Major_Name, major.Major_Code FROM major ORDER BY major.Major_Code;","SELECT major_name ,  major_code FROM Major ORDER BY major_code","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""major.Major_Name"" and ""major.Major_Code"". 2. Condition Structure: No specific filtering condition is required as the query asks for all majors. 3. Join Structure: No JOIN is required since all necessary data is within the ""major"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data. 5. Ordering Structure: Use ORDER BY on ""major.Major_Code"" to sort the results by their code.",1.0
1704,What is the average salary of an intern?,EASY,planet_1,"[Employee.Salary, Employee.Position]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT AVG(Employee.Salary) AS avg_salary FROM Employee WHERE Employee.Position = 'Intern';,"SELECT avg(Salary) FROM Employee WHERE POSITION  =  ""Intern"";","1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average salary. 2. Condition Structure: Use a WHERE clause to filter for employees whose position is ""Intern."" 3. Join Structure: No JOIN is required since all necessary data is within the ""Employee"" table. 4. Aggregation Structure: Use the AVG function to calculate the average salary of interns.",1.0
1705,"What are the provinces that have not only institutions founded before 1920, but also institutions founded after 1950?",NESTED,institution_sports,"[institution.Province, institution.Founded]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT DISTINCT Province FROM institution AS i1 WHERE EXISTS ( SELECT 1 FROM institution AS i2 WHERE i1.Province = i2.Province AND i2.Founded < 1920 ) AND EXISTS ( SELECT 1 FROM institution AS i3 WHERE i1.Province = i3.Province AND i3.Founded > 1950 );,SELECT Province FROM institution WHERE Founded  <  1920 INTERSECT SELECT Province FROM institution WHERE Founded  >  1950,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct provinces. Use the FROM clause to specify the institution table. Apply a WHERE clause to filter provinces that have institutions founded before 1920 and also institutions founded after 1950. 2. Condition Structure: Use the WHERE clause with EXISTS subqueries to ensure that a province has at least one institution founded before 1920 and at least one institution founded after 1950. 3. Join Structure: Not required, as all data is available within the institution table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1706,What are the names of the movie theaters that are playing 'G' or 'PG' rated movies?,NON-NESTED,movie_2,"[MovieTheaters.Name,Movies.Rating,MovieTheaters.Movie = Movies.Code,'G','PG']","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT MovieTheaters.Name FROM MovieTheaters JOIN Movies ON MovieTheaters.Movie = Movies.Code WHERE Movies.Rating = 'G' OR Movies.Rating = 'PG';,SELECT title FROM movies WHERE rating  =  'G' OR rating  =  'PG',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of movie theaters, i.e., ""MovieTheaters.Name."" 2. Condition Structure: Use a WHERE clause to filter for movies with a rating of 'G' or 'PG.' 3. Join Structure: Use a JOIN between the ""MovieTheaters"" and ""Movies"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to associate theaters with the movies they are playing. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of the theaters.",0.0
1707,Find the content that has the highest total values in all boxes.,EASY,warehouse_1,"[Boxes.Contents, Boxes.Value]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Boxes.Contents FROM Boxes GROUP BY Boxes.Contents ORDER BY SUM(Boxes.Value) DESC LIMIT 1;,SELECT CONTENTS FROM boxes ORDER BY value DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the content that has the highest total value across all boxes. 2. Aggregation Structure: Use SUM to calculate the total value for each content type. 3. Grouping Structure: Use GROUP BY on ""Boxes.Contents"" to aggregate the total value for each content type. 4. Ordering Structure: Use ORDER BY in descending order on the summed values to rank the contents by their total value. 5. Limiting Structure: Use LIMIT 1 to retrieve the content with the highest total value. 6. Join Structure: No JOIN is required since all necessary data is within the ""Boxes"" table.",1.0
1708,What is the state with the most universities?,EASY,university_rank,"[university.State, university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.State FROM university GROUP BY university.State ORDER BY COUNT(university.University_ID) DESC LIMIT 1;,SELECT state FROM University GROUP BY state ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the state, as the question asks for the state with the most universities. 2. Aggregation Structure: Use COUNT to calculate the number of universities in each state. 3. Grouping Structure: Use GROUP BY on ""university.State"" to aggregate the results by state. 4. Ordering Structure: Use ORDER BY in descending order on the count of universities to rank states by the number of universities. 5. Limiting Structure: Use LIMIT 1 to retrieve the state with the most universities. 6. Join Structure: No JOIN is required since all necessary data is within the ""university"" table.",1.0
1709,"What are the names of institutions, ordered by the years in which they were founded?",EASY,institution_sports,"[institution.Name, institution.Founded]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT institution.Name, institution.Founded FROM institution ORDER BY institution.Founded ASC;",SELECT Name FROM institution ORDER BY Founded ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the institution names and their founding years. 2. Condition Structure: No specific filtering condition is required as we want all institutions and their founding years. 3. Join Structure: No JOIN is required since all necessary information is available in the ""institution"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data. 5. Ordering Structure: Use ORDER BY on the ""institution.Founded"" field to sort the institutions by their founding years in ascending order.",1.0
1710,Select the warehouse code and the average value of the boxes only for those warehouses where the average value of the boxes is greater than 150.,NESTED,warehouse_1,"[Warehouses.Code, Boxes.Value, Boxes.Warehouse = Warehouses.Code, 150]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Code, AVG(Boxes.Value) AS average_value FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code GROUP BY Warehouses.Code HAVING AVG(Boxes.Value) > 150;","SELECT warehouse ,  avg(value) FROM boxes GROUP BY warehouse HAVING avg(value)  >  150",1. Sequential Structure: Start with the SELECT clause to retrieve the warehouse code and the average value of the boxes. Use the FROM clause to specify the Boxes table and JOIN it with the Warehouses table on the warehouse code. Apply a GROUP BY clause to group the data by warehouse code and calculate the average value of the boxes for each warehouse. Use the HAVING clause to filter warehouses where the average value of the boxes is greater than 150. 2. Condition Structure: Use the HAVING clause to filter for warehouses where the average value of the boxes exceeds 150. 3. Join Structure: Use an INNER JOIN between the Warehouses and Boxes tables based on the warehouse code to connect warehouses with their respective boxes. 4. Aggregation Structure: Use the AVG function to calculate the average value of the boxes for each warehouse and filter based on this value using the HAVING clause.,1.0
1711,Which team does not have drivers?,NESTED,car_racing,"[team.Team_ID, team_driver.Team_ID, team_driver.Driver_ID = driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT Team_ID FROM team WHERE Team_ID NOT IN (SELECT Team_ID FROM team_driver);,SELECT Team FROM team WHERE Team_ID NOT IN (SELECT Team_ID FROM team_driver),"1. Sequential Structure: Start with the SELECT clause to retrieve the Team_IDs of teams that do not have drivers. Use the FROM clause to specify the team table. Apply a WHERE clause to filter teams whose Team_ID is not present in the team_driver table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude teams whose Team_ID appears in the team_driver table, indicating they have drivers. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Team_ID entries in the team_driver table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",0.0
1712,What are names of movies that have a 'G' ratings?,EASY,movie_2,"[Movies.Title, Movies.Rating]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies WHERE Movies.Rating = 'G';,SELECT title FROM movies WHERE rating  =  'G',"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the movie title. 2. Condition Structure: Use a WHERE clause to filter for movies that have a 'G' rating. 3. Join Structure: No JOIN is required since all necessary information is in the ""Movies"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving movie titles based on a specific condition.",1.0
1713,What is the total number of championship of institution with public affiliation?,NON-NESTED,institution_sports,"[institution.Affiliation, institution.Institution_ID, Championship.Number_of_Championships, Championship.Institution_ID = institution.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT SUM(Championship.Number_of_Championships) FROM institution JOIN Championship ON institution.Institution_ID = Championship.Institution_ID WHERE institution.Affiliation = 'Public';,"SELECT sum(T1.Number_of_Championships) FROM championship AS T1 JOIN institution AS T2 ON T1.Institution_ID  =  T2.Institution_ID WHERE T2.Affiliation  =  ""Public""","1. Sequential Structure: Start with the SELECT clause to calculate the total number of championships. Use the SUM function on ""Championship.Number_of_Championships."" 2. Condition Structure: Use a WHERE clause to filter for institutions with a ""Public"" affiliation. 3. Join Structure: Use an INNER JOIN to connect the ""institution"" table with the ""Championship"" table based on the shared key ""Institution_ID."" 4. Aggregation Structure: Use the SUM function to aggregate the total number of championships for institutions with a public affiliation.",1.0
1714,What is the stadium of the institution with the largest enrollment?,NESTED,institution_sports,"[institution.Stadium, institution.Enrollment]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT Stadium FROM institution WHERE Enrollment = (SELECT MAX(Enrollment) FROM institution);,SELECT Stadium FROM institution ORDER BY Enrollment DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the stadium name. Use the FROM clause to specify the institution table. Apply a WHERE clause to filter for the institution with the largest enrollment. 2. Condition Structure: Use the WHERE clause with a subquery to identify the institution with the maximum enrollment. 3. Join Structure: Not required, as all data is available within the institution table. 4. Aggregation Structure: Use the MAX function in a subquery to find the largest enrollment, which is then used in the filtering condition.",1.0
1715,List all the driver names in descending order of points.,EASY,car_racing,"[driver.Driver, driver.Points]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT driver.Driver FROM driver ORDER BY driver.Points DESC;,SELECT Driver FROM driver ORDER BY Points DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Driver"" field, as the question asks for the names of the drivers. 2. Condition Structure: No specific filtering condition is required since we want all driver names. 3. Join Structure: No JOIN is needed since all necessary information is available in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in descending order based on ""driver.Points"".",1.0
1716,"What are the codes and corresponding contents of all the boxes, ordered by their values?",EASY,warehouse_1,"[Boxes.Code, Boxes.Contents, Boxes.Value]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Code, Boxes.Contents FROM Boxes ORDER BY Boxes.Value ASC;","SELECT code ,  CONTENTS FROM boxes ORDER BY value","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""Boxes.Code"" and ""Boxes.Contents"". 2. Condition Structure: No specific filtering condition is required as the query asks for all boxes. 3. Join Structure: No JOIN is required since all necessary data is within the ""Boxes"" table. 4. Ordering Structure: Use ORDER BY on ""Boxes.Value"" to sort the results by their values in ascending order. 5. Aggregation Structure: No aggregation is needed as we are retrieving individual records without summarization.",1.0
1717,Find the rating of the movie whose name includes the word ‘Citizen’.,EASY,movie_2,"[Movies.Rating, Movies.Title]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Rating FROM Movies WHERE Movies.Title LIKE '%Citizen%';,SELECT rating FROM movies WHERE title LIKE '%Citizen%',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Movies.Rating"" of the movie whose name includes the word 'Citizen'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for movie titles that contain the word 'Citizen'. 3. Join Structure: No JOIN is required since all relevant information is in the ""Movies"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
1718,Find the number of distinct types of contents in each warehouse.,NON-NESTED,warehouse_1,"[Boxes.Contents, Warehouses.Code, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Code, COUNT(DISTINCT Boxes.Contents) AS distinct_content_count FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code GROUP BY Warehouses.Code;","SELECT count(DISTINCT CONTENTS) ,  warehouse FROM boxes GROUP BY warehouse","1. Sequential Structure: Start with the SELECT clause to retrieve the warehouse code and the count of distinct types of contents in each warehouse. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to associate each box with its respective warehouse. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Boxes.Contents"" to count the unique types of contents for each warehouse, and GROUP BY ""Warehouses.Code"" to group the results by warehouse.",1.0
1719,"Find the average age of the drivers from the countries that use ""English"" as official native language.",NON-NESTED,car_racing,"[driver.Age, driver.Country, country.Country, country.Official_native_language, driver.Country = country.Country, English]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT AVG(driver.Age) FROM driver JOIN country ON driver.Country = country.Country WHERE country.Official_native_language = 'English';,"SELECT avg(T2.age) FROM country AS T1 JOIN driver AS T2 ON T1.Country_ID  =  T2.Country WHERE T1.Official_native_language  =  ""English""","1. Sequential Structure: Start with the SELECT clause to calculate the average age of drivers using the AVG function on ""driver.Age."" 2. Condition Structure: Use a WHERE clause to filter for countries where the ""country.Official_native_language"" is ""English."" 3. Join Structure: Use an INNER JOIN to connect the ""driver"" table with the ""country"" table based on the shared ""Country"" field. 4. Aggregation Structure: Use the AVG function to compute the average age of the filtered drivers.",0.0
1720,What is the total weight of all the packages that customer Leo Wong sent?,NON-NESTED,planet_1,"[Package.Weight, Client.Name, Package.Sender = Client.AccountNumber, Leo Wong]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT SUM(Package.Weight) FROM Package JOIN Client ON Package.Sender = Client.AccountNumber WHERE Client.Name = 'Leo Wong';,"SELECT sum(T1.Weight) FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name  =  ""Leo Wong"";","1. Sequential Structure: Start with the SELECT clause to calculate the total weight of packages sent by the customer. Use the SUM function on the ""Package.Weight"" field. 2. Condition Structure: Use a WHERE clause to filter for packages where the sender's account number corresponds to the account of the customer named ""Leo Wong."" 3. Join Structure: Use a JOIN between the ""Package"" table and the ""Client"" table based on the relationship ""Package.Sender = Client.AccountNumber"" to link packages with their respective senders. 4. Aggregation Structure: Use the SUM function to calculate the total weight of all packages sent by ""Leo Wong.""",1.0
1721,What are the locations of warehouses in which boxes that contain Rocks and Scissors are kept?,NESTED,warehouse_1,"[Warehouses.Location, Boxes.Contents, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Location FROM Warehouses JOIN Boxes ON Boxes.Warehouse = Warehouses.Code WHERE Boxes.Contents IN ('Rocks', 'Scissors') GROUP BY Warehouses.Location HAVING COUNT(DISTINCT Boxes.Contents) = 2;",SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' INTERSECT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors',"1. Sequential Structure: Start with the SELECT clause to retrieve the locations of warehouses. Use the FROM clause to specify the Warehouses table and JOIN it with the Boxes table to connect warehouse locations with the contents of the boxes. Apply a WHERE clause to filter for boxes that contain both ""Rocks"" and ""Scissors"". 2. Condition Structure: Use the WHERE clause to filter for boxes that contain ""Rocks"" and ""Scissors"". This can be achieved by checking for warehouses that have boxes with both contents. 3. Join Structure: Use an INNER JOIN between the Warehouses and Boxes tables based on the relationship where the warehouse code in the Boxes table matches the code in the Warehouses table. 4. Aggregation Structure: Use GROUP BY to group results by warehouse location and apply a HAVING clause to ensure that the warehouse contains boxes with both ""Rocks"" and ""Scissors"".",1.0
1722,Select the name of all movie theaters that are not currently showing a movie.,NESTED,movie_2,"[MovieTheaters.Name,MovieTheaters.Movie,Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT MovieTheaters.Name FROM MovieTheaters WHERE MovieTheaters.Movie IS NULL OR MovieTheaters.Movie NOT IN (SELECT Movies.Code FROM Movies);,SELECT DISTINCT name FROM MovieTheaters WHERE Movie  =  'null',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of movie theaters. Use the FROM clause to specify the MovieTheaters table. Apply a WHERE clause to filter for theaters that are not currently showing any movie. 2. Condition Structure: Use the WHERE clause with a condition to check for theaters where the Movie field is NULL or does not match any movie code in the Movies table. 3. Join Structure: Not required, as the filtering can be done directly using the Movie field in the MovieTheaters table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1723,"What are the codes of all boxes, as well as the locations of the warehouses they are in?",NON-NESTED,warehouse_1,"[Boxes.Code, Warehouses.Location, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Code, Warehouses.Location FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code;","SELECT T1.code ,  T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.Warehouse  =  T2.Code","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Boxes.Code"" and ""Warehouses.Location."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to link each box with its corresponding warehouse. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the codes and locations.",1.0
1724,What is the rating of the movie what has a name including a word like 'Citizen'?,NON-NESTED,movie_2,"[Movies.Rating, MovieTheaters.Name, MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Rating FROM Movies WHERE Movies.Name LIKE '%Citizen%';,SELECT rating FROM movies WHERE title LIKE '%Citizen%',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Movies.Rating"" field, as the question asks for the rating of a specific movie. 2. Condition Structure: Use a WHERE clause to filter for movies whose name includes the word ""Citizen."" This can be achieved using the LIKE operator with a wildcard. 3. Join Structure: No JOIN is necessary here, as the required information is available in the ""Movies"" table. 4. Aggregation Structure: No aggregation is needed since we are retrieving a single field for a specific condition.",0.0
1725,Count the number of drivers whose points are below 150.,EASY,car_racing,"[driver.Driver_ID, driver.Points, 150]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT COUNT(driver.Driver_ID) FROM driver WHERE driver.Points < 150;,SELECT count(*) FROM driver WHERE Points  <  150,"1. Sequential Structure: Start with the SELECT clause to count the number of drivers whose points are below 150. 2. Condition Structure: Use a WHERE clause to filter drivers where ""driver.Points"" is less than 150. 3. Join Structure: No JOIN is required since all necessary information is in the ""driver"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of drivers meeting the specified condition.",1.0
1726,Show the provinces that have both institutions founded before 1920 and institutions founded after 1950.,NESTED,institution_sports,"[institution.Province, institution.Founded, Championship.Institution_ID = institution.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT DISTINCT Province FROM institution WHERE Province IN ( SELECT Province FROM institution WHERE Founded < 1920 ) AND Province IN ( SELECT Province FROM institution WHERE Founded > 1950 );,SELECT Province FROM institution WHERE Founded  <  1920 INTERSECT SELECT Province FROM institution WHERE Founded  >  1950,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct provinces. Use the FROM clause to specify the institution table. Apply a WHERE clause to filter provinces that have institutions founded before 1920 and institutions founded after 1950. 2. Condition Structure: Use the WHERE clause with two conditions to check for institutions founded before 1920 and institutions founded after 1950. Use a subquery to ensure that both conditions are satisfied for the same province. 3. Join Structure: Not required, as all necessary data is available in the institution table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1727,Find the name and Citation point of the universities whose reputation points are top 3 and above.,NESTED,university_rank,"[university.University_Name, overall_ranking.Citation_point, overall_ranking.Reputation_point, overall_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT university.University_Name, overall_ranking.Citation_point FROM university JOIN overall_ranking ON university.University_ID = overall_ranking.University_ID WHERE overall_ranking.Reputation_point IN ( SELECT Reputation_point FROM overall_ranking ORDER BY Reputation_point DESC LIMIT 3 );","SELECT T1.University_Name ,  T2.Citation_point FROM University AS T1 JOIN Overall_ranking AS T2 ON T1.university_id  =  T2.university_id ORDER BY T2.Reputation_point DESC LIMIT 3","1. Sequential Structure: Start with the SELECT clause to retrieve the university name and citation points. Use the FROM clause to specify the university and overall_ranking tables. Apply a WHERE clause to filter universities whose reputation points are in the top 3 or above. Use ORDER BY to sort the reputation points in descending order and LIMIT to restrict the results to the top 3. 2. Condition Structure: Use a subquery in the WHERE clause to filter universities with reputation points in the top 3. The subquery retrieves the top 3 reputation points from the overall_ranking table. 3. Join Structure: Use an INNER JOIN between the university and overall_ranking tables based on the University_ID to connect university names with their ranking details. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1728,Return the total number of championships of institutions that have a Public affiliation.,NON-NESTED,institution_sports,"[institution.Affiliation, institution.Institution_ID, Championship.Number_of_Championships, Championship.Institution_ID = institution.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT SUM(Championship.Number_of_Championships) FROM institution JOIN Championship ON institution.Institution_ID = Championship.Institution_ID WHERE institution.Affiliation = 'Public';,"SELECT sum(T1.Number_of_Championships) FROM championship AS T1 JOIN institution AS T2 ON T1.Institution_ID  =  T2.Institution_ID WHERE T2.Affiliation  =  ""Public""","1. Sequential Structure: Start with the SELECT clause to calculate the total number of championships using the SUM function on ""Championship.Number_of_Championships."" 2. Condition Structure: Use a WHERE clause to filter institutions with a ""Public"" affiliation. 3. Join Structure: Use an INNER JOIN to connect the ""institution"" table with the ""Championship"" table based on the shared key ""Institution_ID."" 4. Aggregation Structure: Use the SUM function to aggregate the total number of championships for institutions with a ""Public"" affiliation.",1.0
1729,Find the names of movies whose rating is ‘G’.,EASY,movie_2,"[Movies.Title, Movies.Rating, MovieTheaters.Movie = Movies.Code, G]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies WHERE Movies.Rating = 'G';,SELECT title FROM movies WHERE rating  =  'G',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of movies, which corresponds to ""Movies.Title"". 2. Condition Structure: Use a WHERE clause to filter movies where the ""Movies.Rating"" is 'G'. 3. Join Structure: No JOIN is required since the necessary information is available in the ""Movies"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving movie titles based on a specific condition.",1.0
1730,What is the university name with highest research point?,NON-NESTED,university_rank,"[university.University_Name,overall_ranking.Research_point,overall_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.University_Name FROM university JOIN overall_ranking ON overall_ranking.University_ID = university.University_ID ORDER BY overall_ranking.Research_point DESC LIMIT 1;,SELECT T1.university_name FROM University AS T1 JOIN Overall_ranking AS T2 ON T1.university_id  =  T2.university_id ORDER BY T2.research_point DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""university.University_Name."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the university with the highest research point. 3. Join Structure: Use a JOIN between the ""university"" and ""overall_ranking"" tables based on the ""University_ID"" to link each university with its research points. 4. Aggregation Structure: Use ORDER BY in descending order on ""overall_ranking.Research_point"" to rank universities by research points. Use LIMIT 1 to select the university with the highest research point.",1.0
1731,What are the manager and sponsor of the team that has the most drivers?,NON-NESTED,car_racing,"[team.Manager, team.Sponsor, team.Team_ID = team_driver.Team_ID, team_driver.Driver_ID = driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT team.Manager, team.Sponsor FROM team JOIN team_driver ON team.Team_ID = team_driver.Team_ID GROUP BY team.Team_ID ORDER BY COUNT(team_driver.Driver_ID) DESC LIMIT 1;","SELECT t1.manager ,  t1.sponsor FROM team AS t1 JOIN team_driver AS t2 ON t1.team_id  =  t2.team_id GROUP BY t2.team_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""team.Manager"" and ""team.Sponsor"" as required by the question. 2. Condition Structure: Use a subquery to determine the team with the most drivers by counting the number of drivers per team in the ""team_driver"" table. Use ORDER BY in descending order and LIMIT 1 to identify the team with the highest count. 3. Join Structure: Use a JOIN between the ""team"" and ""team_driver"" tables based on ""team.Team_ID"" to associate teams with their drivers. 4. Aggregation Structure: Use COUNT on ""team_driver.Driver_ID"" to count the number of drivers for each team in the subquery.",1.0
1732,"What are the names of institutions, ordered descending by their number of championships?",NON-NESTED,institution_sports,"[institution.Name, Championship.Number_of_Championships, Championship.Institution_ID = institution.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT institution.Name, Championship.Number_of_Championships FROM institution JOIN Championship ON Championship.Institution_ID = institution.Institution_ID ORDER BY Championship.Number_of_Championships DESC;",SELECT T2.Name FROM championship AS T1 JOIN institution AS T2 ON T1.Institution_ID  =  T2.Institution_ID ORDER BY T1.Number_of_Championships DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""institution.Name"" and the ""Championship.Number_of_Championships."" Use ORDER BY in descending order to sort institutions by their number of championships. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""institution"" and ""Championship"" tables based on the shared key ""Institution_ID"" to link institutions with their championship data. 4. Aggregation Structure: No aggregation is needed as the query directly retrieves and orders the data.",1.0
1733,What are the movie titles for ones that are played in the Odeon theater?,NON-NESTED,movie_2,"[Movies.Title, MovieTheaters.Name, MovieTheaters.Movie = Movies.Code, Odeon]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies JOIN MovieTheaters ON MovieTheaters.Movie = Movies.Code WHERE MovieTheaters.Name = 'Odeon';,SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T2.name  =  'Odeon',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Movies.Title"" field, which represents the titles of the movies. 2. Condition Structure: Use a WHERE clause to filter for records where the ""MovieTheaters.Name"" is ""Odeon."" 3. Join Structure: Use a JOIN between the ""Movies"" and ""MovieTheaters"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to link movies with the theaters where they are played. 4. Aggregation Structure: No aggregation is needed as the query only retrieves movie titles.",1.0
1734,List all major name and major code in the order of their major code,EASY,university_rank,"[major.Major_Name, major.Major_Code]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT major.Major_Name, major.Major_Code FROM major ORDER BY major.Major_Code;","SELECT major_name ,  major_code FROM Major ORDER BY major_code","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""major.Major_Name"" and ""major.Major_Code"". 2. Condition Structure: No specific filtering condition is required as we want to list all majors. 3. Join Structure: No JOIN is required since all necessary data is within the ""major"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data. 5. Ordering Structure: Use ORDER BY on ""major.Major_Code"" to sort the results in ascending order of their major code.",1.0
1735,Find the number of movies whose rating is ‘G’.,EASY,movie_2,"[Movies.Rating,Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT COUNT(Movies.Code) FROM Movies WHERE Movies.Rating = 'G';,SELECT count(*) FROM movies WHERE rating  =  'G',"1. Sequential Structure: Start with the SELECT clause to count the number of movies with a specific rating. 2. Condition Structure: Use a WHERE clause to filter movies where the ""Movies.Rating"" is 'G'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Movies"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of movies that meet the specified condition.",1.0
1736,Find the location of the warehouses which store contents Rocks and Scissors.,NESTED,warehouse_1,"[Warehouses.Location, Boxes.Contents, Boxes.Warehouse = Warehouses.Code, Rocks, Scissors]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Location FROM Warehouses JOIN Boxes ON Warehouses.Code = Boxes.Warehouse WHERE Boxes.Contents IN ('Rocks', 'Scissors') GROUP BY Warehouses.Location HAVING COUNT(DISTINCT Boxes.Contents) = 2;",SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' INTERSECT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors',"1. Sequential Structure: Start with the SELECT clause to retrieve the location of warehouses. Use the FROM clause to specify the Warehouses table and JOIN it with the Boxes table to connect warehouse locations with their stored contents. Apply a WHERE clause to filter for warehouses that store both ""Rocks"" and ""Scissors"". 2. Condition Structure: Use the WHERE clause to filter for contents ""Rocks"" and ""Scissors"". Use a subquery or grouping to ensure that both contents are stored in the same warehouse. 3. Join Structure: Use an INNER JOIN between the Warehouses and Boxes tables based on the warehouse code to link warehouse locations with their stored contents. 4. Aggregation Structure: Use GROUP BY to group records by warehouse location and apply a HAVING clause to ensure that both ""Rocks"" and ""Scissors"" are stored in the same warehouse.",1.0
1737,What are the home conferences with the fewest number of people enrolled?,NESTED,university_rank,"[university.Home_Conference, university.Enrollment]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT Home_Conference FROM university GROUP BY Home_Conference HAVING COUNT(Enrollment) = (SELECT MIN(enrollment_count) FROM (SELECT COUNT(Enrollment) AS enrollment_count FROM university GROUP BY Home_Conference));,SELECT home_conference FROM University GROUP BY home_conference ORDER BY sum(enrollment) LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the home conferences. Use the FROM clause to specify the university table. Apply a GROUP BY clause to group records by home conferences and use COUNT to calculate the number of people enrolled in each conference. Use the HAVING clause to filter for the conferences with the fewest number of people enrolled. 2. Condition Structure: Use the HAVING clause to filter for the minimum enrollment count. A subquery can be used to calculate the minimum enrollment count across all home conferences. 3. Join Structure: Not required, as all data is available within the university table. 4. Aggregation Structure: Use COUNT to calculate the number of people enrolled in each home conference and MIN to identify the smallest enrollment count.",0.0
1738,What are the distinct warehouses that have boxes with Rocks or Scissors as contents?,NON-NESTED,warehouse_1,"[Boxes.Contents, Boxes.Warehouse, Warehouses.Code = Boxes.Warehouse]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Boxes.Warehouse FROM Boxes WHERE Boxes.Contents = 'Rocks' OR Boxes.Contents = 'Scissors';,SELECT DISTINCT warehouse FROM boxes WHERE CONTENTS  =  'Rocks' OR CONTENTS  =  'Scissors',"1. Sequential Structure: Start with the SELECT clause to retrieve distinct warehouse codes. Since the question asks for distinct warehouses, we will use DISTINCT on the ""Boxes.Warehouse"" field. 2. Condition Structure: Use a WHERE clause to filter for boxes that have ""Rocks"" or ""Scissors"" as their contents. 3. Join Structure: No explicit JOIN is needed since the relevant fields are already linked through the ""Boxes"" table. 4. Aggregation Structure: No aggregation is required as we are only retrieving distinct values.",1.0
1739,List the names of teams that do not have any drivers.,NESTED,car_racing,"[team.Team,team.Team_ID,team_driver.Team_ID = team.Team_ID,team_driver.Driver_ID = driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT team.Team FROM team WHERE team.Team_ID NOT IN (SELECT team_driver.Team_ID FROM team_driver);,SELECT Team FROM team WHERE Team_ID NOT IN (SELECT Team_ID FROM team_driver),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of teams. Use the FROM clause to specify the team table. Apply a WHERE clause to filter teams that do not have any drivers by ensuring that the Team_ID is not present in the team_driver table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude teams whose Team_ID appears in the team_driver table, meaning they have drivers. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Team_ID entries in the team_driver table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1740,What are the different contents of boxes for which the value is higher than the average value across all boxes?,NESTED,warehouse_1,"[Boxes.Contents, Boxes.Value]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Contents FROM Boxes WHERE Value > (SELECT AVG(Value) FROM Boxes);,SELECT DISTINCT CONTENTS FROM boxes WHERE value  >  (SELECT avg(value) FROM boxes),"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct contents of boxes. Use the FROM clause to specify the Boxes table. Apply a WHERE clause to filter for boxes whose value is higher than the average value across all boxes. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average value of all boxes and filter for boxes with a value greater than this average. 3. Join Structure: Not required, as all data is available within the Boxes table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average value of all boxes, which is then used in the filtering condition.",1.0
1741,List in alphabetical order the titles of all movies.,EASY,movie_2,[Movies.Title],"Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies ORDER BY Movies.Title ASC;,SELECT title FROM movies ORDER BY title,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the movie title. 2. Condition Structure: No specific filtering condition is required as we want all movie titles. 3. Join Structure: No JOIN is required since all necessary data is within the ""Movies"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the titles. 5. Ordering Structure: Use ORDER BY in ascending order to list the titles alphabetically.",1.0
1742,Find the average and total values of all boxes.,EASY,warehouse_1,[Boxes.Value],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT AVG(Boxes.Value) AS average_value, SUM(Boxes.Value) AS total_value FROM Boxes;","SELECT avg(value) ,  sum(value) FROM boxes","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average and total values of all boxes. 2. Aggregation Structure: Use AVG to calculate the average value and SUM to calculate the total value of all boxes. 3. Condition Structure: No specific filtering condition is required as the query involves all boxes. 4. Join Structure: No JOIN is required since all necessary data is within the ""Boxes"" table.",1.0
1743,What are the total and average points of drivers?,EASY,car_racing,[driver.Points],"Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT SUM(driver.Points) AS total_points, AVG(driver.Points) AS average_points FROM driver;","SELECT sum(Points) ,  avg(Points) FROM driver","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the total and average points of drivers. 2. Aggregation Structure: Use SUM to calculate the total points and AVG to calculate the average points of drivers. 3. Grouping Structure: No GROUP BY is needed since the query asks for the overall total and average points, not grouped by any specific field. 4. Join Structure: No JOIN is required as all necessary data is within the ""driver"" table.",1.0
1744,What are the locations of warehouses that have boxes containing Rocks but not Scissors?,NESTED,warehouse_1,"[Warehouses.Location, Boxes.Contents, Boxes.Warehouse = Warehouses.Code, Rocks, Scissors]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Warehouses.Location FROM Warehouses JOIN Boxes ON Warehouses.Code = Boxes.Warehouse WHERE Boxes.Contents = 'Rocks' AND Warehouses.Code NOT IN ( SELECT Warehouses.Code FROM Warehouses JOIN Boxes ON Warehouses.Code = Boxes.Warehouse WHERE Boxes.Contents = 'Scissors' );,SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' EXCEPT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors',"1. Sequential Structure: Start with the SELECT clause to retrieve the locations of warehouses. Use the FROM clause to specify the Warehouses table and JOIN it with the Boxes table to connect warehouse locations with the contents of the boxes. Apply a WHERE clause to filter for warehouses that have boxes containing ""Rocks"" but not ""Scissors"". 2. Condition Structure: Use the WHERE clause to filter for boxes containing ""Rocks"". Use a subquery to exclude warehouses that have boxes containing ""Scissors"". 3. Join Structure: Use an INNER JOIN between the Warehouses and Boxes tables based on the warehouse code to link warehouse locations with the contents of the boxes. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1745,Which make does the most drivers have?,NON-NESTED,car_racing,"[driver.Make, team_driver.Driver_ID = driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT driver.Make, COUNT(team_driver.Driver_ID) AS driver_count FROM team_driver JOIN driver ON team_driver.Driver_ID = driver.Driver_ID GROUP BY driver.Make ORDER BY driver_count DESC LIMIT 1;",SELECT Make FROM driver GROUP BY Make ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Make"" and the count of drivers for each make. Use COUNT to count the number of drivers for each make. 2. Condition Structure: No specific filtering condition is required, as we are interested in all makes. 3. Join Structure: Use a JOIN between the ""team_driver"" and ""driver"" tables based on ""Driver_ID"" to associate each driver with their make. 4. Aggregation Structure: Use GROUP BY on ""driver.Make"" to group the results by make, and use ORDER BY in descending order of the count to find the make with the most drivers. Use LIMIT 1 to get the make with the highest count.",1.0
1746,What are different types of affiliations of institutions and the corresponding number of institutions?,EASY,institution_sports,"[institution.Affiliation, institution.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT institution.Affiliation, COUNT(institution.Institution_ID) AS num_institutions FROM institution GROUP BY institution.Affiliation;","SELECT Affiliation ,  COUNT(*) FROM institution GROUP BY Affiliation","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the ""institution.Affiliation"" and the count of institutions for each affiliation. 2. Aggregation Structure: Use COUNT to calculate the number of institutions for each type of affiliation. 3. Grouping Structure: Use GROUP BY on ""institution.Affiliation"" to aggregate the results by each affiliation type. 4. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table.",1.0
1747,"Please show the names of drivers, and countries they are from.",EASY,car_racing,"[driver.Driver, driver.Country]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT driver.Driver, driver.Country FROM driver;","SELECT T2.Driver ,  T1.Country FROM country AS T1 JOIN driver AS T2 ON T1.Country_ID  =  T2.Country","1. Sequential Structure: Start with the SELECT clause to retrieve the names of drivers and the countries they are from. 2. Condition Structure: No specific filtering condition is required as the query asks for all drivers and their countries. 3. Join Structure: No JOIN is required since all necessary information is available in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and countries of drivers.",0.0
1748,What is the total weight for all packages that Leo Wong sent?,NON-NESTED,planet_1,"[Package.Weight,Package.Sender,Client.Name,Package.Sender = Client.AccountNumber,Leo Wong]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT SUM(Package.Weight) FROM Package JOIN Client ON Package.Sender = Client.AccountNumber WHERE Client.Name = 'Leo Wong';,"SELECT sum(T1.Weight) FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name  =  ""Leo Wong"";","1. Sequential Structure: Start with the SELECT clause to calculate the total weight of packages sent by ""Leo Wong."" Use the SUM function on the ""Package.Weight"" field. 2. Condition Structure: Use a WHERE clause to filter packages where the sender matches the account number of the client named ""Leo Wong."" 3. Join Structure: Use a JOIN between the ""Package"" table and the ""Client"" table based on the relationship ""Package.Sender = Client.AccountNumber"" to link packages with their senders. 4. Aggregation Structure: Use the SUM function to calculate the total weight of all packages sent by ""Leo Wong.""",1.0
1749,List all package sent or received by Leo Wong.,NON-NESTED,planet_1,"[Client.Name,Package.Sender,Package.Recipient,Client.AccountNumber = Package.Sender,Client.AccountNumber = Package.Recipient]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Package.* FROM Client JOIN Package ON Client.AccountNumber = Package.Sender OR Client.AccountNumber = Package.Recipient WHERE Client.Name = 'Leo Wong';,"SELECT DISTINCT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber OR T1.Recipient  =  T2.AccountNumber WHERE T2.Name = ""Leo Wong""","1. Sequential Structure: Start with the SELECT clause to retrieve all details of the packages sent or received by ""Leo Wong."" 2. Condition Structure: Use a WHERE clause to filter for packages where the sender or recipient matches the account number of the client named ""Leo Wong."" 3. Join Structure: Use JOINs to connect the ""Client"" table with the ""Package"" table on ""Client.AccountNumber"" matching either ""Package.Sender"" or ""Package.Recipient."" 4. Aggregation Structure: No aggregation is needed as the query is retrieving all package details.",1.0
1750,How many different contents are stored in boxes?,EASY,warehouse_1,[Boxes.Contents],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT COUNT(DISTINCT Boxes.Contents) AS unique_contents FROM Boxes;,SELECT count(DISTINCT CONTENTS) FROM boxes,"1. Sequential Structure: Begin with the SELECT clause to count the distinct contents stored in boxes. 2. Condition Structure: No specific filtering condition is required as we want to count all distinct contents. 3. Join Structure: No JOIN is necessary since all required data is within the ""Boxes"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique contents in the ""Boxes.Contents"" field.",1.0
1751,List the make that are associated with most drivers.,NON-NESTED,car_racing,"[driver.Make, team_driver.Driver_ID = driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT driver.Make FROM team_driver JOIN driver ON team_driver.Driver_ID = driver.Driver_ID GROUP BY driver.Make ORDER BY COUNT(driver.Driver_ID) DESC LIMIT 1;,SELECT Make FROM driver GROUP BY Make ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Make"" that is associated with the most drivers. Use COUNT to count the number of drivers for each make. 2. Condition Structure: No specific filtering condition is required, as we are interested in all makes. 3. Join Structure: Use a JOIN between the ""team_driver"" and ""driver"" tables based on ""Driver_ID"" to associate each driver with their make. 4. Aggregation Structure: Use COUNT to count the number of drivers for each make, GROUP BY ""driver.Make"" to group the results by make, and ORDER BY in descending order to rank makes by the number of drivers. Use LIMIT 1 to select the make with the most drivers.",1.0
1752,What is the number of all packages that Leo Wong sent?,NON-NESTED,planet_1,"[Package.Sender, Client.Name, Package.Sender = Client.AccountNumber, Package.PackageNumber]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT COUNT(Package.PackageNumber) FROM Package JOIN Client ON Package.Sender = Client.AccountNumber WHERE Client.Name = 'Leo Wong';,"SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name  =  ""Leo Wong"";","1. Sequential Structure: Start with the SELECT clause to count the total number of packages sent by Leo Wong. Use COUNT on ""Package.PackageNumber"" to get the total number of packages. 2. Condition Structure: Use a WHERE clause to filter for packages where the sender is Leo Wong. This requires matching ""Package.Sender"" with ""Client.AccountNumber"" and filtering ""Client.Name"" for ""Leo Wong."" 3. Join Structure: Use a JOIN between the ""Package"" and ""Client"" tables based on ""Package.Sender = Client.AccountNumber"" to associate packages with their respective senders. 4. Aggregation Structure: Use COUNT to aggregate the total number of packages sent by Leo Wong.",0.0
1753,Find the name of the movie that is on in both Odeon and Imperial theaters.,NESTED,movie_2,"[MovieTheaters.Name,MovieTheaters.Movie,Movies.Code,Movies.Title,MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies JOIN MovieTheaters ON MovieTheaters.Movie = Movies.Code WHERE MovieTheaters.Name = 'Odeon' AND Movies.Code IN ( SELECT MovieTheaters.Movie FROM MovieTheaters WHERE MovieTheaters.Name = 'Imperial' );,SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T2.name  =  'Odeon' INTERSECT SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T2.name  =  'Imperial',"1. Sequential Structure: Start with the SELECT clause to retrieve the title of the movie. Use the FROM clause to specify the MovieTheaters and Movies tables. Apply a WHERE clause to filter for movies that are shown in both ""Odeon"" and ""Imperial"" theaters. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the movie is shown in both theaters. The subquery will check for movies that appear in the MovieTheaters table for both ""Odeon"" and ""Imperial"". 3. Join Structure: Use an INNER JOIN between the MovieTheaters and Movies tables based on the relationship MovieTheaters.Movie = Movies.Code to connect movie codes with their titles. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1754,How many distinct movies are on in theaters?,NON-NESTED,movie_2,"[Movies.Code, MovieTheaters.Movie, MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT COUNT(DISTINCT Movies.Code) FROM Movies JOIN MovieTheaters ON MovieTheaters.Movie = Movies.Code;,SELECT count(DISTINCT T1.code) FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie,"1. Sequential Structure: Start with the SELECT clause to count the distinct movies. Use COUNT with DISTINCT on the ""Movies.Code"" field to ensure only unique movies are counted. 2. Condition Structure: No specific filtering condition is required, as we are interested in all movies currently in theaters. 3. Join Structure: Use a JOIN between the ""Movies"" and ""MovieTheaters"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to link movies with their theater information. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique movies currently in theaters.",1.0
1755,Which make is associated with 3 or more drivers?,NON-NESTED,car_racing,"[driver.Make, driver.Driver_ID, team_driver.Driver_ID = driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT driver.Make FROM driver JOIN team_driver ON team_driver.Driver_ID = driver.Driver_ID GROUP BY driver.Make HAVING COUNT(driver.Driver_ID) >= 3;,SELECT Make FROM driver GROUP BY Make HAVING COUNT(*)  >=  3,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""driver.Make"" associated with 3 or more drivers. 2. Condition Structure: Use a HAVING clause to filter for makes that are associated with 3 or more drivers. 3. Join Structure: Use a JOIN between the ""driver"" and ""team_driver"" tables based on ""Driver_ID"" to link each driver with their respective team. 4. Aggregation Structure: Use COUNT on ""driver.Driver_ID"" to count the number of drivers associated with each make, then filter with HAVING to select makes with 3 or more drivers.",1.0
1756,List each make with the number of drivers with that make.,EASY,car_racing,"[driver.Make, driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT driver.Make, COUNT(driver.Driver_ID) AS number_of_drivers FROM driver GROUP BY driver.Make;","SELECT Make ,  COUNT(*) FROM driver GROUP BY Make","1. Sequential Structure: Begin with the SELECT clause to specify the make and the count of drivers for each make. 2. Aggregation Structure: Use COUNT to calculate the number of drivers for each make. 3. Grouping Structure: Use GROUP BY on ""driver.Make"" to group the results by each make. 4. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table.",1.0
1757,What is all the information about the warehouses?,EASY,warehouse_1,"[Warehouses.Code, Warehouses.Location, Warehouses.Capacity]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT * FROM Warehouses;,SELECT * FROM warehouses,"1. Sequential Structure: Start with the SELECT clause to retrieve all the information about the warehouses. Use the wildcard (*) to select all columns. 2. Condition Structure: No specific filtering condition is required as the query asks for all information. 3. Join Structure: No JOIN is needed since all necessary information is in the ""Warehouses"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all data from the table.",1.0
1758,Return all the enrollments of institutions in either the city of Vancouver or the city of Calgary .,EASY,institution_sports,"[institution.Enrollment, institution.City]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT institution.Enrollment FROM institution WHERE institution.City = 'Vancouver' OR institution.City = 'Calgary';,"select sum(enrollment) from institution where city  =  ""vancouver"" or city  =  ""calgary""","1. Sequential Structure: Start with the SELECT clause to retrieve all enrollments from the ""institution"" table. 2. Condition Structure: Use a WHERE clause to filter for institutions located in either the city of Vancouver or the city of Calgary. 3. Join Structure: No JOIN is required since all necessary information is in the ""institution"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving enrollments based on the specified condition.",0.0
1759,Which country is the driver with the highest points from? Give me the capital of the country.,NON-NESTED,car_racing,"[driver.Country, driver.Points, country.Capital, country.Country_Id = driver.Country]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT country.Capital FROM driver JOIN country ON country.Country_Id = driver.Country WHERE driver.Points = (SELECT MAX(driver.Points) FROM driver);,SELECT T1.Capital FROM country AS T1 JOIN driver AS T2 ON T1.Country_ID  =  T2.Country ORDER BY T2.Points DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the capital of the country where the driver with the highest points is from. 2. Condition Structure: Use a subquery in the WHERE clause to identify the driver with the highest points by using MAX on the ""driver.Points"" field. 3. Join Structure: Use a JOIN between the ""driver"" and ""country"" tables based on the relationship ""country.Country_Id = driver.Country"" to link drivers to their respective countries. 4. Aggregation Structure: Use MAX in the subquery to find the highest points, and filter the main query to match the driver with those points.",1.0
1760,"What is the maximum points of the drivers from a country whose capital is ""Dublin""?",NESTED,car_racing,"[driver.Points,driver.Country,country.Capital,country.Country_Id = driver.Country,Dublin]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT MAX(driver.Points) AS max_points FROM driver WHERE driver.Country = (SELECT country.Country_Id FROM country WHERE country.Capital = 'Dublin');,"SELECT max(T2.Points) FROM country AS T1 JOIN driver AS T2 ON T1.Country_ID  =  T2.Country WHERE T1.Capital  =  ""Dublin""","1. Sequential Structure: Start with the SELECT clause to retrieve the maximum points of drivers. Use the FROM clause to specify the driver table. Use a WHERE clause to filter drivers based on their country, which is determined by the capital being ""Dublin"". 2. Condition Structure: Use the WHERE clause to filter for drivers whose country matches the country where the capital is ""Dublin"". This requires a subquery to identify the country based on the capital. 3. Join Structure: Use a subquery to connect the country table with the driver table using the shared key ""Country_Id"" to filter drivers from the relevant country. 4. Aggregation Structure: Use the MAX function to find the maximum points among the filtered drivers.",1.0
1761,What is the name of the client who received the heaviest package?,NON-NESTED,planet_1,"[Package.Weight, Package.Recipient, Client.Name, Package.Recipient = Client.AccountNumber]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Client.Name FROM Package JOIN Client ON Package.Recipient = Client.AccountNumber ORDER BY Package.Weight DESC LIMIT 1;,SELECT T2.Name FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Recipient  =  T2.AccountNumber ORDER BY T1.Weight DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Client.Name"" of the client who received the heaviest package. Use ORDER BY in descending order on ""Package.Weight"" to rank packages by weight and LIMIT 1 to select the heaviest package. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the heaviest package. 3. Join Structure: Use a JOIN between the ""Package"" and ""Client"" tables based on ""Package.Recipient = Client.AccountNumber"" to associate each package with its recipient's name. 4. Aggregation Structure: No aggregation is needed since we are only retrieving the name of the client associated with the heaviest package.",1.0
1762,Find all different contents stored in New York.,NON-NESTED,warehouse_1,"[Warehouses.Location, Boxes.Contents, Boxes.Warehouse = Warehouses.Code, New York]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Boxes.Contents FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location = 'New York';,SELECT DISTINCT T1.contents FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE LOCATION  =  'New York',"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Boxes.Contents"" as we are looking for all different contents. 2. Condition Structure: Use a WHERE clause to filter for records where ""Warehouses.Location"" is ""New York."" 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to link each box with its respective warehouse. 4. Aggregation Structure: Use DISTINCT to ensure that only unique contents are returned.",1.0
1763,What are the stadiums of institutions in descending order of the capacity.,EASY,institution_sports,"[institution.Stadium, institution.Capacity]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT institution.Stadium, institution.Capacity FROM institution ORDER BY institution.Capacity DESC;",SELECT Stadium FROM institution ORDER BY Capacity DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the stadium names and their capacities. 2. Condition Structure: No specific filtering condition is required as we want all stadiums and their capacities. 3. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in descending order based on ""institution.Capacity"".",1.0
1764,"What are the names of institutions, ordered alphabetically?",EASY,institution_sports,[institution.Name],"Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT institution.Name FROM institution ORDER BY institution.Name ASC;,SELECT Name FROM institution ORDER BY Name ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the institution name. 2. Condition Structure: No specific filtering condition is required as we want all institution names. 3. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the institution names. 5. Ordering Structure: Use ORDER BY in ascending order to sort the institution names alphabetically.",1.0
1765,"What are the names, cities, and states of all universities in alphabetical order (by name of the university).",EASY,university_rank,"[university.University_Name, university.City, university.State]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT university.University_Name, university.City, university.State FROM university ORDER BY university.University_Name ASC;","SELECT university_name ,  city ,  state FROM University ORDER BY university_name","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""university.University_Name"", ""university.City"", and ""university.State"". 2. Condition Structure: No specific filtering condition is required as we want all universities. 3. Join Structure: No JOIN is required since all necessary data is within the ""university"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""university.University_Name"" in ascending order to list the universities alphabetically.",1.0
1766,Find the manager and sponsor of the team that has the most drivers.,NON-NESTED,car_racing,"[team.Manager, team.Sponsor, team.Team_ID = team_driver.Team_ID, team_driver.Driver_ID = driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT team.Manager, team.Sponsor FROM team JOIN team_driver ON team.Team_ID = team_driver.Team_ID GROUP BY team.Team_ID ORDER BY COUNT(team_driver.Driver_ID) DESC LIMIT 1;","SELECT t1.manager ,  t1.sponsor FROM team AS t1 JOIN team_driver AS t2 ON t1.team_id  =  t2.team_id GROUP BY t2.team_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""team.Manager"" and ""team.Sponsor."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in the team with the most drivers. 3. Join Structure: Use a JOIN between the ""team"" and ""team_driver"" tables on ""team.Team_ID"" to associate teams with their drivers. Additionally, no further joins are required as the relevant fields are already accessible. 4. Aggregation Structure: Use COUNT on ""team_driver.Driver_ID"" to count the number of drivers per team. Use ORDER BY in descending order to rank teams by the number of drivers and LIMIT 1 to select the team with the most drivers.",1.0
1767,What level is Physician?,NON-NESTED,planet_1,"[Employee.Position, Has_Clearance.Level, Has_Clearance.Employee = Employee.EmployeeID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Has_Clearance.Level FROM Employee JOIN Has_Clearance ON Has_Clearance.Employee = Employee.EmployeeID WHERE Employee.Position = 'Physician';,"SELECT T1.Level FROM Has_Clearance AS T1 JOIN Employee AS T2 ON T1.Employee = T2.EmployeeID WHERE T2.position  =  ""Physician"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Has_Clearance.Level"" for the position ""Physician."" 2. Condition Structure: Use a WHERE clause to filter for employees whose position is ""Physician."" 3. Join Structure: Use a JOIN between the ""Employee"" and ""Has_Clearance"" tables based on the relationship ""Has_Clearance.Employee = Employee.EmployeeID"" to link employees with their clearance levels. 4. Aggregation Structure: No aggregation is needed as we are retrieving a specific value.",1.0
1768,Find the warehouses which store contents Rocks or Scissors.,NON-NESTED,warehouse_1,"[Warehouses.Code, Boxes.Contents, Boxes.Warehouse = Warehouses.Code, Rocks, Scissors]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Warehouses.Code FROM Warehouses JOIN Boxes ON Boxes.Warehouse = Warehouses.Code WHERE Boxes.Contents = 'Rocks' OR Boxes.Contents = 'Scissors';,SELECT DISTINCT warehouse FROM boxes WHERE CONTENTS  =  'Rocks' OR CONTENTS  =  'Scissors',"1. Sequential Structure: Start with the SELECT clause to retrieve the names or codes of the warehouses that store the specified contents, ""Rocks"" or ""Scissors."" 2. Condition Structure: Use a WHERE clause to filter for boxes that contain ""Rocks"" or ""Scissors."" 3. Join Structure: Use a JOIN between the ""Warehouses"" and ""Boxes"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to link each box to its respective warehouse. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the warehouses that meet the condition.",1.0
1769,Find the location of the warehouses which have contents Rocks but not Scissors.,NESTED,warehouse_1,"[Warehouses.Location, Boxes.Contents, Boxes.Warehouse = Warehouses.Code, Rocks, Scissors]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Warehouses.Location FROM Warehouses JOIN Boxes ON Boxes.Warehouse = Warehouses.Code WHERE Boxes.Contents = 'Rocks' AND Warehouses.Code NOT IN ( SELECT Warehouses.Code FROM Warehouses JOIN Boxes ON Boxes.Warehouse = Warehouses.Code WHERE Boxes.Contents = 'Scissors' );,SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks' EXCEPT SELECT T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Scissors',"1. Sequential Structure: Start with the SELECT clause to retrieve the location of warehouses. Use the FROM clause to specify the Warehouses table and JOIN it with the Boxes table to connect warehouse locations with their contents. Apply a WHERE clause to filter for warehouses that have contents ""Rocks"" but not ""Scissors"". 2. Condition Structure: Use the WHERE clause to filter for warehouses that have ""Rocks"" in their contents. Use a subquery to exclude warehouses that have ""Scissors"" in their contents. 3. Join Structure: Use an INNER JOIN between the Warehouses and Boxes tables based on the relationship where Boxes.Warehouse matches Warehouses.Code. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1770,"What is the name, city, state of the university with a rank 1 on Accounting major?",NON-NESTED,university_rank,"[university.University_Name, university.City, university.State, major.Major_Name, major_ranking.Rank, major_ranking.Major_ID = major.Major_ID, major_ranking.University_ID = university.University_ID, major.Major_Name = 'Accounting', major_ranking.Rank = 1]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT university.University_Name, university.City, university.State FROM major_ranking JOIN major ON major_ranking.Major_ID = major.Major_ID JOIN university ON major_ranking.University_ID = university.University_ID WHERE major.Major_Name = 'Accounting' AND major_ranking.Rank = 1;","SELECT T2.university_name ,  T2.city ,  T2.state FROM Major_Ranking AS T1 JOIN University AS T2 JOIN Major AS T3 ON T1.university_id  =  T2.university_id AND T1.major_id  =  T3.major_id WHERE T1.rank  =  1 AND T3.major_name  =  'Accounting'","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""university.University_Name,"" ""university.City,"" and ""university.State."" 2. Condition Structure: Use a WHERE clause to filter for the ""Accounting"" major and a rank of 1. 3. Join Structure: Use JOINs to connect the ""major_ranking"" table with the ""major"" table on ""major_ranking.Major_ID = major.Major_ID"" and the ""major_ranking"" table with the ""university"" table on ""major_ranking.University_ID = university.University_ID."" 4. Aggregation Structure: No aggregation is needed as the query is focused on filtering and retrieving specific data.",1.0
1771,What are the names of all cinemas not showing any movies?,NESTED,movie_2,"[MovieTheaters.Name,MovieTheaters.Movie,Movies.Code = MovieTheaters.Movie]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT MovieTheaters.Name FROM MovieTheaters WHERE MovieTheaters.Movie NOT IN (SELECT Movies.Code FROM Movies);,SELECT DISTINCT name FROM MovieTheaters WHERE Movie  =  'null',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of cinemas. Use the FROM clause to specify the MovieTheaters table. Apply a WHERE clause to filter cinemas that are not showing any movies by ensuring that the Movie field in the MovieTheaters table is NULL or does not match any movie in the Movies table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude cinemas whose Movie field matches any movie code in the Movies table, indicating they are showing a movie. 3. Join Structure: Not required, as the filtering can be done using a subquery on the Movies table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1772,What is the name of the theater playing the most movies?,NON-NESTED,movie_2,"[MovieTheaters.Name, MovieTheaters.Movie, Movies.Code = MovieTheaters.Movie]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT MovieTheaters.Name FROM MovieTheaters GROUP BY MovieTheaters.Name ORDER BY COUNT(MovieTheaters.Movie) DESC LIMIT 1;,SELECT name FROM movietheaters GROUP BY name ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the theater (""MovieTheaters.Name""). 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the theater playing the most movies. 3. Join Structure: No JOIN is necessary since the relevant data is contained within the ""MovieTheaters"" table, and the relationship between movies and theaters is already established in the schema. 4. Aggregation Structure: Use COUNT on ""MovieTheaters.Movie"" to count the number of movies played by each theater. Use GROUP BY to group the results by ""MovieTheaters.Name"" and ORDER BY in descending order to rank theaters by the number of movies played. Use LIMIT 1 to select the theater playing the most movies.",1.0
1773,What are the average and total capacities across all warehouses?,EASY,warehouse_1,[Warehouses.Capacity],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT AVG(Warehouses.Capacity) AS avg_capacity, SUM(Warehouses.Capacity) AS total_capacity FROM Warehouses;","SELECT avg(capacity) ,  sum(capacity) FROM warehouses","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average and total capacities. 2. Aggregation Structure: Use AVG and SUM functions to calculate the average and total capacities across all warehouses. 3. Condition Structure: No specific filtering condition is required as the query involves all warehouses. 4. Join Structure: No JOIN is required since all necessary data is within the ""Warehouses"" table.",1.0
1774,Show all home conferences with average enrollment of universities above 2000.,NESTED,university_rank,"[university.Home_Conference, university.Enrollment]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT Home_Conference FROM university GROUP BY Home_Conference HAVING AVG(Enrollment) > 2000;,SELECT home_conference FROM University GROUP BY home_conference HAVING avg(enrollment)  >  2000,"1. Sequential Structure: Start with the SELECT clause to retrieve the home conferences. Use the FROM clause to specify the university table. Apply a GROUP BY clause to group records by home conferences and calculate the average enrollment for each group. Use the HAVING clause to filter groups where the average enrollment is greater than 2000. 2. Condition Structure: Use the HAVING clause to filter home conferences with an average enrollment above 2000. 3. Join Structure: Not required, as all data is in the university table. 4. Aggregation Structure: Use the AVG function to calculate the average enrollment for each home conference and filter based on the condition.",1.0
1775,Show all the distinct ratings in the database.,EASY,movie_2,[Movies.Rating],"Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT DISTINCT Movies.Rating FROM Movies;,SELECT DISTINCT rating FROM movies,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ratings from the database. 2. Condition Structure: No specific filtering condition is required as we want all distinct ratings. 3. Join Structure: No JOIN is necessary since the required information is available within the ""Movies"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique ratings are retrieved.",1.0
1776,What are the names and nicknames of institutions?,NON-NESTED,institution_sports,"[institution.Name, Championship.Nickname, Championship.Institution_ID = institution.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT institution.Name, Championship.Nickname FROM institution JOIN Championship ON Championship.Institution_ID = institution.Institution_ID;","SELECT T2.Name ,  T1.Nickname FROM championship AS T1 JOIN institution AS T2 ON T1.Institution_ID  =  T2.Institution_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""institution.Name"" and ""Championship.Nickname."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""institution"" and ""Championship"" tables based on the relationship ""Championship.Institution_ID = institution.Institution_ID"" to link institutions with their nicknames. 4. Aggregation Structure: No aggregation is required as the query simply retrieves names and nicknames.",1.0
1777,Count the number of institutions.,EASY,institution_sports,[institution.Institution_ID],"Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT COUNT(DISTINCT institution.Institution_ID) AS institution_count FROM institution;,SELECT count(*) FROM institution,"1. Sequential Structure: Start with the SELECT clause to count the number of institutions. 2. Aggregation Structure: Use the COUNT function to count the distinct ""Institution_ID"" values, as each institution is uniquely identified by its ID. 3. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table. 4. Condition Structure: No specific filtering condition is needed, as we are counting all institutions.",1.0
1778,"For every home conference, how many universities attended that conference?",EASY,university_rank,"[university.Home_Conference, university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT university.Home_Conference, COUNT(university.University_ID) AS university_count FROM university GROUP BY university.Home_Conference;","SELECT home_conference ,  count(*) FROM University GROUP BY home_conference","1. Sequential Structure: Begin with the SELECT clause to specify the home conference and the count of universities that attended each conference. 2. Aggregation Structure: Use COUNT to calculate the number of universities for each home conference. 3. Grouping Structure: Use GROUP BY on ""university.Home_Conference"" to group the results by each home conference. 4. Join Structure: No JOIN is required since all necessary data is within the ""university"" table.",1.0
1779,Find the type of contents that are not in the warehouses located at New York.,NESTED,warehouse_1,"[Boxes.Contents,Warehouses.Location,Boxes.Warehouse = Warehouses.Code,New York]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Boxes.Contents FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location != 'New York';,SELECT CONTENTS FROM boxes EXCEPT SELECT T1.contents FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'New York',"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct types of contents from the Boxes table. Use the FROM clause to specify the Boxes table and JOIN it with the Warehouses table to connect the contents with their respective warehouse locations. Apply a WHERE clause to filter out the warehouses located in New York. 2. Condition Structure: Use the WHERE clause to exclude warehouses located in New York by checking the Location field in the Warehouses table. 3. Join Structure: Use an INNER JOIN between the Boxes and Warehouses tables based on the relationship between Boxes.Warehouse and Warehouses.Code to link the contents with their respective warehouse locations. 4. Aggregation Structure: Not required, as we are retrieving distinct content types without any aggregation.",1.0
1780,Find the titles of all movies sorted by their ratings.,EASY,movie_2,"[Movies.Title, Movies.Rating]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
","SELECT Movies.Title, Movies.Rating FROM Movies ORDER BY Movies.Rating;",SELECT title FROM movies ORDER BY rating,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the movie titles and their ratings. 2. Condition Structure: No specific filtering condition is required as we want all movie titles and their ratings. 3. Join Structure: No JOIN is required since all necessary data is within the ""Movies"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by the ""Movies.Rating"" field.",1.0
1781,How many packages sent by Ogden Wernstrom and received by Leo Wong?,NON-NESTED,planet_1,"[Package.Sender, Package.Recipient, Client.Name, Package.Sender = Client.AccountNumber, Package.Recipient = Client.AccountNumber, Ogden Wernstrom, Leo Wong]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT COUNT(*) FROM Package JOIN Client AS SenderClient ON Package.Sender = SenderClient.AccountNumber JOIN Client AS RecipientClient ON Package.Recipient = RecipientClient.AccountNumber WHERE SenderClient.Name = 'Ogden Wernstrom' AND RecipientClient.Name = 'Leo Wong';,"SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name = ""Ogden Wernstrom"" INTERSECT SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Recipient  =  T2.AccountNumber WHERE T2.Name = ""Leo Wong""","1. Sequential Structure: Start with the SELECT clause to count the number of packages sent by ""Ogden Wernstrom"" and received by ""Leo Wong."" 2. Condition Structure: Use a WHERE clause to filter for packages where the sender is ""Ogden Wernstrom"" and the recipient is ""Leo Wong."" 3. Join Structure: Use JOINs to connect the ""Package"" table with the ""Client"" table twice: once to match the sender's account number with the client's account number, and once to match the recipient's account number with the client's account number. 4. Aggregation Structure: Use COUNT to count the number of packages that meet the specified conditions.",1.0
1782,What is the capital of the country where the driver with the most points is from?,NESTED,car_racing,"[driver.Country,driver.Points,country.Capital,country.Country = driver.Country]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT country.Capital FROM country JOIN driver ON country.Country = driver.Country WHERE driver.Points = (SELECT MAX(Points) FROM driver);,SELECT T1.Capital FROM country AS T1 JOIN driver AS T2 ON T1.Country_ID  =  T2.Country ORDER BY T2.Points DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the capital of the country. Use the FROM clause to specify the country table and JOIN it with the driver table on the country field. Apply a WHERE clause to filter for the driver with the most points. 2. Condition Structure: Use the WHERE clause with a subquery to identify the driver with the maximum points and filter the corresponding country. 3. Join Structure: Use an INNER JOIN between the driver and country tables based on the country field to connect the driver's country with its capital. 4. Aggregation Structure: Use MAX in a subquery to find the maximum points scored by a driver, which is then used in the filtering condition.",0.0
1783,What are all the different contents stored in boxes in New York?,NON-NESTED,warehouse_1,"[Boxes.Contents,Warehouses.Location,Boxes.Warehouse = Warehouses.Code,New York]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Boxes.Contents FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location = 'New York';,SELECT DISTINCT T1.contents FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE LOCATION  =  'New York',"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Boxes.Contents"" since we are asked for all the different contents stored in boxes. 2. Condition Structure: Use a WHERE clause to filter for warehouses located in ""New York."" 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to associate each box with its corresponding warehouse. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique contents are returned.",1.0
1784,How many institutions are there?,EASY,institution_sports,[institution.Institution_ID],"Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT COUNT(institution.Institution_ID) AS total_institutions FROM institution;,SELECT count(*) FROM institution,"1. Sequential Structure: Start with the SELECT clause to count the number of institutions. 2. Aggregation Structure: Use the COUNT function to calculate the total number of institutions. 3. Condition Structure: No specific filtering condition is required as we want the total count of all institutions. 4. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table.",1.0
1785,Select all details of all warehouses.,EASY,warehouse_1,"[Warehouses.Code, Warehouses.Location, Warehouses.Capacity]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT * FROM Warehouses;,SELECT * FROM warehouses,"1. Sequential Structure: Start with the SELECT clause to retrieve all details of the warehouses. Use SELECT * to include all columns. 2. Condition Structure: No specific filtering condition is required as the query asks for all details of all warehouses. 3. Join Structure: No JOIN is necessary since all required information is available in the ""Warehouses"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all details without any summarization.",1.0
1786,Find the title of the movie that is played in the Odeon theater.,NON-NESTED,movie_2,"[Movies.Title, MovieTheaters.Name, MovieTheaters.Movie = Movies.Code, Odeon]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies JOIN MovieTheaters ON MovieTheaters.Movie = Movies.Code WHERE MovieTheaters.Name = 'Odeon';,SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T2.name  =  'Odeon',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Movies.Title"" field, as the question asks for the title of the movie. 2. Condition Structure: Use a WHERE clause to filter for records where the ""MovieTheaters.Name"" is ""Odeon."" 3. Join Structure: Use a JOIN between the ""Movies"" and ""MovieTheaters"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to link movies with the theaters where they are played. 4. Aggregation Structure: No aggregation is needed since we are retrieving a single movie title.",1.0
1787,What are the different movie ratings?,EASY,movie_2,[Movies.Rating],"Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT DISTINCT Movies.Rating FROM Movies;,SELECT DISTINCT rating FROM movies,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct movie ratings, as the question asks for the different ratings. 2. Condition Structure: No specific filtering condition is required since we want all unique ratings. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Movies"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique ratings are retrieved.",1.0
1788,"Return the names of institutions, as well as their nicknames.",NON-NESTED,institution_sports,"[institution.Name, Championship.Nickname, Championship.Institution_ID = institution.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT institution.Name, Championship.Nickname FROM institution JOIN Championship ON Championship.Institution_ID = institution.Institution_ID;","SELECT T2.Name ,  T1.Nickname FROM championship AS T1 JOIN institution AS T2 ON T1.Institution_ID  =  T2.Institution_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""institution.Name"" and ""Championship.Nickname."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""institution"" table and the ""Championship"" table based on the relationship ""Championship.Institution_ID = institution.Institution_ID"" to link institutions with their nicknames. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the names and nicknames.",1.0
1789,What are the countries that have drivers with points larger than 150?,EASY,car_racing,"[driver.Country, driver.Points]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT driver.Country FROM driver WHERE driver.Points > 150;,SELECT T1.Country FROM country AS T1 JOIN driver AS T2 ON T1.Country_ID  =  T2.Country WHERE T2.Points  >  150,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the ""driver.Country"". 2. Condition Structure: Use a WHERE clause to filter for drivers whose ""driver.Points"" are greater than 150. 3. Join Structure: No JOIN is required since all necessary information is available in the ""driver"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving the countries that meet the specified condition.",0.0
1790,How many movies are playing across all theaters?,NON-NESTED,movie_2,"[MovieTheaters.Movie, Movies.Code, MovieTheaters.Name]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT COUNT(MovieTheaters.Movie) FROM MovieTheaters;,SELECT count(*) FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie,"1. Sequential Structure: Start with the SELECT clause to count the number of movies playing across all theaters. Use COUNT to aggregate the number of movies. 2. Condition Structure: No specific filtering condition is required, as the question asks for the total number of movies across all theaters. 3. Join Structure: No JOIN is necessary since the relevant data is contained within the ""MovieTheaters"" table. 4. Aggregation Structure: Use COUNT on the ""MovieTheaters.Movie"" field to calculate the total number of movies playing across all theaters.",1.0
1791,What are the names of movies that do not have any ratings?,NESTED,movie_2,"[Movies.Title, Movies.Rating, MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies WHERE Movies.Rating IS NULL;,SELECT title FROM movies WHERE rating  =  'null',"1. Sequential Structure: Begin with the SELECT clause to retrieve the names (titles) of movies. Use the FROM clause to specify the Movies table. Apply a WHERE clause to filter movies that do not have any ratings. 2. Condition Structure: Use the WHERE clause to check for movies where the Rating field is NULL or does not exist in the MovieTheaters table. 3. Join Structure: Not required, as the filtering can be done directly on the Movies table without needing to join with MovieTheaters. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",1.0
1792,Find the average and total capacity of all warehouses.,EASY,warehouse_1,[Warehouses.Capacity],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT AVG(Warehouses.Capacity) AS avg_capacity, SUM(Warehouses.Capacity) AS total_capacity FROM Warehouses;","SELECT avg(capacity) ,  sum(capacity) FROM warehouses","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average and total capacities of all warehouses. 2. Aggregation Structure: Use AVG and SUM functions to calculate the average and total capacity of the warehouses. 3. Condition Structure: No specific filtering condition is required as the query involves all warehouses. 4. Join Structure: No JOIN is required since all necessary data is within the ""Warehouses"" table.",1.0
1793,Find the name of the movies that are played in either cinema Odeon or Imperial.,NON-NESTED,movie_2,"[Movies.Title, MovieTheaters.Name, MovieTheaters.Movie = Movies.Code, Odeon, Imperial]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies JOIN MovieTheaters ON MovieTheaters.Movie = Movies.Code WHERE MovieTheaters.Name = 'Odeon' OR MovieTheaters.Name = 'Imperial';,SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T2.name  =  'Odeon' OR T2.name  =  'Imperial',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Movies.Title"" field, which contains the names of the movies. 2. Condition Structure: Use a WHERE clause to filter for records where the ""MovieTheaters.Name"" is either ""Odeon"" or ""Imperial."" 3. Join Structure: Use a JOIN between the ""Movies"" and ""MovieTheaters"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to link movies with the theaters where they are played. 4. Aggregation Structure: No aggregation is needed as the query only requires the names of the movies.",1.0
1794,What are the movie names in alphabetical order?,EASY,movie_2,[Movies.Title],"Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies ORDER BY Movies.Title ASC;,SELECT title FROM movies ORDER BY title,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the movie title. 2. Condition Structure: No specific filtering condition is required as we want all movie titles. 3. Join Structure: No JOIN is required since all necessary data is within the ""Movies"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the movie titles. 5. Ordering Structure: Use ORDER BY to sort the movie titles in alphabetical order.",1.0
1795,Find the number of movies in each rating.,EASY,movie_2,"[Movies.Rating, MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
","SELECT Movies.Rating, COUNT(*) AS movie_count FROM Movies GROUP BY Movies.Rating;","SELECT count(*) ,  rating FROM movies GROUP BY rating","1. Sequential Structure: Begin with the SELECT clause to specify the rating and the count of movies for each rating. 2. Aggregation Structure: Use COUNT to calculate the number of movies for each rating. 3. Grouping Structure: Use GROUP BY on ""Movies.Rating"" to group the results by each rating. 4. Join Structure: No JOIN is required since the information about movies and their ratings is contained within the ""Movies"" table. 5. Condition Structure: No specific filtering condition is required as we want the count of movies for all ratings.",1.0
1796,Find the total capacity of all warehouse locations.,EASY,warehouse_1,"[Warehouses.Capacity, Warehouses.Location]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT SUM(Warehouses.Capacity) AS total_capacity FROM Warehouses;,SELECT sum(capacity) FROM warehouses,"1. Sequential Structure: Begin with the SELECT clause to specify the total capacity, as the question asks for the sum of capacities across all warehouse locations. 2. Aggregation Structure: Use the SUM function to calculate the total capacity of all warehouses. 3. Condition Structure: No specific filtering condition is required since the query involves all warehouse locations. 4. Join Structure: No JOIN is required as all necessary data is within the ""Warehouses"" table.",1.0
1797,Find all distinct locations of warehouses.,EASY,warehouse_1,[Warehouses.Location],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Warehouses.Location FROM Warehouses;,SELECT count(DISTINCT LOCATION) FROM warehouses,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct locations of warehouses. 2. Condition Structure: No specific filtering condition is required as we want all distinct locations. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Warehouses"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct values.",0.0
1798,What are the codes of warehouses that have more boxes than their capacity?,NON-NESTED,warehouse_1,"[Warehouses.Code, Warehouses.Capacity, Boxes.Warehouse, Boxes.Code, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Code FROM Warehouses JOIN Boxes ON Boxes.Warehouse = Warehouses.Code GROUP BY Warehouses.Code, Warehouses.Capacity HAVING COUNT(Boxes.Code) > Warehouses.Capacity;",SELECT T2.code FROM boxes AS T1 JOIN Warehouses AS T2 ON T1.warehouse  =  T2.code GROUP BY T2.code HAVING count(*)  >  T2.capacity,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Warehouses.Code"" for warehouses that meet the condition. 2. Condition Structure: Use a HAVING clause to filter warehouses where the total number of boxes exceeds their capacity. This requires summing the boxes in each warehouse and comparing it to the warehouse capacity. 3. Join Structure: Use a JOIN between the ""Warehouses"" and ""Boxes"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to associate each warehouse with its boxes. 4. Aggregation Structure: Use COUNT to calculate the total number of boxes in each warehouse, then compare this value to the ""Warehouses.Capacity"" using the HAVING clause.",1.0
1799,Find the number of different locations where Rocks are stored.,NON-NESTED,warehouse_1,"[Boxes.Contents, Boxes.Warehouse, Warehouses.Location, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT COUNT(DISTINCT Warehouses.Location) FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Boxes.Contents = 'Rocks';,SELECT count(DISTINCT LOCATION) FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks',"1. Sequential Structure: Start with the SELECT clause to count the distinct locations where ""Rocks"" are stored. Use COUNT with DISTINCT on ""Warehouses.Location."" 2. Condition Structure: Use a WHERE clause to filter for records where ""Boxes.Contents"" is ""Rocks."" 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to link the contents of boxes with their respective warehouse locations. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique locations where ""Rocks"" are stored.",1.0
1800,Show all majors and major ranks for the university with name Augustana College.,NON-NESTED,university_rank,"[university.University_Name, university.University_ID, major.Major_Name, major_ranking.Rank, major_ranking.Major_ID = major.Major_ID, major_ranking.University_ID = university.University_ID, Augustana College]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT major.Major_Name, major_ranking.Rank FROM university JOIN major_ranking ON university.University_ID = major_ranking.University_ID JOIN major ON major_ranking.Major_ID = major.Major_ID WHERE university.University_Name = 'Augustana College';","SELECT T1.rank ,  T3.major_name FROM Major_Ranking AS T1 JOIN University AS T2 JOIN Major AS T3 ON T1.university_id  =  T2.university_id AND T1.major_id  =  T3.major_id WHERE T2.university_name  =  'Augustana College'","1. Sequential Structure: Start with the SELECT clause to retrieve ""major.Major_Name"" and ""major_ranking.Rank."" 2. Condition Structure: Use a WHERE clause to filter for the university with the name ""Augustana College."" 3. Join Structure: Use JOINs to connect the ""university"" table with the ""major_ranking"" table on ""university.University_ID"" and ""major_ranking.University_ID,"" and then connect the ""major_ranking"" table with the ""major"" table on ""major_ranking.Major_ID"" and ""major.Major_ID."" 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without any summarization.",1.0
1801,Find the name of the movie theaters that are playing the movies whose rating is ‘G’.,NON-NESTED,movie_2,"[MovieTheaters.Name,Movies.Rating,MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT MovieTheaters.Name FROM MovieTheaters JOIN Movies ON MovieTheaters.Movie = Movies.Code WHERE Movies.Rating = 'G';,SELECT T2.name FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T1.rating  =  'G',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the movie theaters, i.e., ""MovieTheaters.Name."" 2. Condition Structure: Use a WHERE clause to filter for movies with a rating of 'G.' 3. Join Structure: Use a JOIN between the ""MovieTheaters"" and ""Movies"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to link theaters with the movies they are playing. 4. Aggregation Structure: No aggregation is needed as the query only requires listing the names of the movie theaters.",1.0
1802,Show all university names with both major Accounting and major Urban Education.,NESTED,university_rank,"[university.University_Name,major.Major_Name,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID,Accounting,Urban Education]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT university.University_Name FROM university JOIN major_ranking ON university.University_ID = major_ranking.University_ID JOIN major ON major_ranking.Major_ID = major.Major_ID WHERE major.Major_Name IN ('Accounting', 'Urban Education') GROUP BY university.University_Name HAVING COUNT(DISTINCT major.Major_Name) = 2;",SELECT T2.university_name FROM Major_Ranking AS T1 JOIN University AS T2 JOIN Major AS T3 ON T1.university_id  =  T2.university_id AND T1.major_id  =  T3.major_id WHERE T3.major_name  =  'Accounting' INTERSECT SELECT T2.university_name FROM Major_Ranking AS T1 JOIN University AS T2 JOIN Major AS T3 ON T1.university_id  =  T2.university_id AND T1.major_id  =  T3.major_id WHERE T3.major_name  =  'Urban Education',"1. Sequential Structure: Start with the SELECT clause to retrieve the university names. Use the FROM clause to specify the university table and join it with the major and major_ranking tables to connect universities with their majors. Apply a WHERE clause to filter for universities that have both the ""Accounting"" and ""Urban Education"" majors. 2. Condition Structure: Use the WHERE clause with a subquery or grouping to ensure that only universities with both ""Accounting"" and ""Urban Education"" majors are selected. 3. Join Structure: Use INNER JOINs between the university, major_ranking, and major tables based on their respective keys (University_ID and Major_ID) to connect universities with their majors. 4. Aggregation Structure: Use GROUP BY to group records by university name and apply a HAVING clause to ensure that only universities with both specified majors are included.",1.0
1803,In which years were more than one institution founded?,EASY,institution_sports,[institution.Founded],"Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT institution.Founded FROM institution GROUP BY institution.Founded HAVING COUNT(*) > 1;,"SELECT Founded ,  COUNT(*) FROM institution GROUP BY Founded HAVING COUNT(*)  >  1","1. Sequential Structure: Begin with the SELECT clause to specify the year in which institutions were founded. 2. Aggregation Structure: Use COUNT to determine the number of institutions founded in each year. 3. Grouping Structure: Use GROUP BY on ""institution.Founded"" to aggregate the results by year. 4. Condition Structure: Apply the HAVING clause to filter for years where more than one institution was founded, by setting the count to be greater than 1. 5. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table.",0.0
1804,Who receieved the heaviest package?,NON-NESTED,planet_1,"[Package.Weight, Package.Recipient, Client.AccountNumber = Package.Recipient]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Package.Recipient FROM Package WHERE Package.Weight = (SELECT MAX(Package.Weight) FROM Package);,SELECT T2.Name FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Recipient  =  T2.AccountNumber ORDER BY T1.Weight DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Package.Recipient"" who received the heaviest package. Use the MAX function on ""Package.Weight"" to identify the heaviest package. 2. Condition Structure: No specific filtering condition is needed since we are looking for the heaviest package across all records. 3. Join Structure: No JOIN is required as the necessary information is available within the ""Package"" table. 4. Aggregation Structure: Use MAX to find the maximum weight of the package and retrieve the corresponding recipient.",0.0
1805,What is the name of the film playing at the most number of theaters?,NON-NESTED,movie_2,"[MovieTheaters.Name,MovieTheaters.Movie,Movies.Title,MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM MovieTheaters JOIN Movies ON MovieTheaters.Movie = Movies.Code GROUP BY Movies.Title ORDER BY COUNT(MovieTheaters.Name) DESC LIMIT 1;,SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie GROUP BY T1.title ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Movies.Title,"" which represents the name of the film. Use an aggregate function (COUNT) to count the number of theaters where each movie is playing. Use ORDER BY in descending order to rank movies by the number of theaters, and LIMIT 1 to get the movie playing at the most theaters. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all movies. 3. Join Structure: Use a JOIN between the ""MovieTheaters"" and ""Movies"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to link each theater with its corresponding movie. 4. Aggregation Structure: Use COUNT on ""MovieTheaters.Name"" to count the number of theaters for each movie, then use ORDER BY and LIMIT to find the movie with the highest count.",1.0
1806,What are the names of the movies not being shown in any theaters?,NESTED,movie_2,"[Movies.Title, Movies.Code, MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies WHERE Movies.Code NOT IN (SELECT MovieTheaters.Movie FROM MovieTheaters);,SELECT Title FROM Movies WHERE Code NOT IN (SELECT Movie FROM MovieTheaters WHERE Movie != 'null'),"1. Sequential Structure: Start with the SELECT clause to retrieve the names (titles) of movies. Use the FROM clause to specify the Movies table. Apply a WHERE clause to filter movies that are not being shown in any theaters by ensuring that their code is not present in the MovieTheaters table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude movies whose code appears in the MovieTheaters table, meaning they are being shown in theaters. 3. Join Structure: Not required, as we only need to filter based on the absence of matching movie codes in the MovieTheaters table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",0.0
1807,"Find the countries in which there are both drivers with make ""Dodge"" and drivers with make ""Chevrolet"".",NESTED,car_racing,"[driver.Country,driver.Make,team_driver.Driver_ID = driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT driver.Country FROM driver WHERE driver.Make IN ('Dodge', 'Chevrolet') GROUP BY driver.Country HAVING COUNT(DISTINCT driver.Make) = 2;","SELECT t2.country FROM driver AS t1 JOIN country AS t2 ON t1.country  =  t2.country_id WHERE t1.Make  =  ""Dodge"" INTERSECT SELECT t2.country FROM driver AS t1 JOIN country AS t2 ON t1.country  =  t2.country_id WHERE t1.Make  =  ""Chevrolet""","1. Sequential Structure: Start with the SELECT clause to retrieve distinct countries. Use the FROM clause to specify the driver table. Apply a WHERE clause to filter for drivers with makes ""Dodge"" and ""Chevrolet"". Use a GROUP BY clause to group by country and a HAVING clause to ensure that both makes are present in each country. 2. Condition Structure: Use the WHERE clause to filter for drivers with makes ""Dodge"" or ""Chevrolet"". Then, use the HAVING clause to ensure that both makes are present in the grouped results for each country. 3. Join Structure: Not required, as all necessary data is available in the driver table. 4. Aggregation Structure: Use COUNT(DISTINCT Make) in the HAVING clause to ensure that both ""Dodge"" and ""Chevrolet"" are present in each country.",0.0
1808,List all different types of contents ordered by contents.,EASY,warehouse_1,[Boxes.Contents],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Boxes.Contents FROM Boxes ORDER BY Boxes.Contents;,SELECT DISTINCT CONTENTS FROM boxes ORDER BY CONTENTS,"1. Sequential Structure: Begin with the SELECT clause to specify the distinct types of contents from the ""Boxes"" table. 2. Condition Structure: No specific filtering condition is required as we want all distinct types of contents. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Boxes"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by the contents.",1.0
1809,How many different movie theaters exist?,EASY,movie_2,[MovieTheaters.Name],"Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT COUNT(DISTINCT MovieTheaters.Name) FROM MovieTheaters;,SELECT count(DISTINCT name) FROM movietheaters,"1. Sequential Structure: Start with the SELECT clause to count the distinct movie theater names, as the question asks for the number of different movie theaters. 2. Condition Structure: No specific filtering condition is required since we are counting all movie theaters. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""MovieTheaters"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""MovieTheaters.Name"" to count the unique movie theaters.",1.0
1810,What is the name of the university that has most number of majors with rank 1?,NON-NESTED,university_rank,"[university.University_Name, major_ranking.Major_ID, major_ranking.University_ID, major_ranking.Rank, major_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.University_Name FROM university JOIN major_ranking ON major_ranking.University_ID = university.University_ID WHERE major_ranking.Rank = 1 GROUP BY university.University_Name ORDER BY COUNT(major_ranking.Major_ID) DESC LIMIT 1;,SELECT T2.university_name FROM Major_Ranking AS T1 JOIN University AS T2 ON T1.university_id  =  T2.university_id WHERE T1.rank  =  1 GROUP BY T2.university_name ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""university.University_Name."" Use COUNT to count the number of majors with rank 1 for each university. 2. Condition Structure: Apply a WHERE clause to filter for records where ""major_ranking.Rank"" is 1. 3. Join Structure: Use a JOIN between the ""university"" and ""major_ranking"" tables based on ""major_ranking.University_ID = university.University_ID"" to associate each university with its major rankings. 4. Aggregation Structure: Use COUNT to count the number of majors with rank 1 for each university, GROUP BY ""university.University_Name"" to group results by university, and ORDER BY the count in descending order. Use LIMIT 1 to get the university with the most majors ranked 1.",1.0
1811,What are the names of all universities that have both Accounting and Urban Education majors?,NESTED,university_rank,"[university.University_Name,major.Major_Name,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID,Accounting,Urban Education]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT DISTINCT university.University_Name FROM university JOIN major_ranking ON university.University_ID = major_ranking.University_ID JOIN major ON major_ranking.Major_ID = major.Major_ID WHERE university.University_ID IN ( SELECT university.University_ID FROM university JOIN major_ranking ON university.University_ID = major_ranking.University_ID JOIN major ON major_ranking.Major_ID = major.Major_ID WHERE major.Major_Name = 'Accounting' ) AND university.University_ID IN ( SELECT university.University_ID FROM university JOIN major_ranking ON university.University_ID = major_ranking.University_ID JOIN major ON major_ranking.Major_ID = major.Major_ID WHERE major.Major_Name = 'Urban Education' );,SELECT T2.university_name FROM Major_Ranking AS T1 JOIN University AS T2 JOIN Major AS T3 ON T1.university_id  =  T2.university_id AND T1.major_id  =  T3.major_id WHERE T3.major_name  =  'Accounting' INTERSECT SELECT T2.university_name FROM Major_Ranking AS T1 JOIN University AS T2 JOIN Major AS T3 ON T1.university_id  =  T2.university_id AND T1.major_id  =  T3.major_id WHERE T3.major_name  =  'Urban Education',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of universities. Use the FROM clause to specify the university table. Join it with the major_ranking table to connect universities with their majors, and then join the major table to access the major names. Use a WHERE clause to filter for universities that have both ""Accounting"" and ""Urban Education"" majors. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the university has both ""Accounting"" and ""Urban Education"" majors. This can be achieved by checking that the university appears in the results for both majors. 3. Join Structure: Use INNER JOINs between the university, major_ranking, and major tables based on their respective keys (University_ID and Major_ID) to connect universities with their majors. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1812,List the names of institutions with at least one championship.,NON-NESTED,institution_sports,"[institution.Name, Championship.Institution_ID, Championship.Number_of_Championships, Championship.Institution_ID = institution.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT institution.Name FROM institution JOIN Championship ON Championship.Institution_ID = institution.Institution_ID WHERE Championship.Number_of_Championships >= 1;,SELECT T2.Name FROM championship AS T1 JOIN institution AS T2 ON T1.Institution_ID  =  T2.Institution_ID WHERE T1.Number_of_Championships  >=  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""institution.Name."" 2. Condition Structure: Use a WHERE clause to filter for institutions that have at least one championship. This can be done by checking if ""Championship.Number_of_Championships"" is greater than or equal to 1. 3. Join Structure: Use a JOIN between the ""institution"" and ""Championship"" tables based on the relationship ""Championship.Institution_ID = institution.Institution_ID"" to link institutions with their championship records. 4. Aggregation Structure: No aggregation is needed since we are only filtering and retrieving institution names.",1.0
1813,What are the names of theaters playing 'G' rated movies?,NON-NESTED,movie_2,"[MovieTheaters.Name,Movies.Rating,Movies.Code = MovieTheaters.Movie,'G']","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT MovieTheaters.Name FROM Movies JOIN MovieTheaters ON Movies.Code = MovieTheaters.Movie WHERE Movies.Rating = 'G';,SELECT T2.name FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie WHERE T1.rating  =  'G',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of theaters, i.e., ""MovieTheaters.Name."" 2. Condition Structure: Use a WHERE clause to filter for movies with a rating of 'G.' 3. Join Structure: Use a JOIN between the ""Movies"" and ""MovieTheaters"" tables based on the relationship ""Movies.Code = MovieTheaters.Movie"" to link theaters with the movies they are playing. 4. Aggregation Structure: No aggregation is needed as the query only requires the names of theaters.",1.0
1814,Find the code and contents of the box with the lowest value.,EASY,warehouse_1,"[Boxes.Code, Boxes.Contents, Boxes.Value]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Code, Boxes.Contents FROM Boxes ORDER BY Boxes.Value ASC LIMIT 1;","SELECT code ,  CONTENTS FROM boxes ORDER BY value LIMIT 1","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the ""Boxes.Code"" and ""Boxes.Contents"". 2. Condition Structure: No specific filtering condition is required, as we are looking for the box with the lowest value. 3. Aggregation Structure: Use ORDER BY on ""Boxes.Value"" in ascending order to rank the boxes by their value. 4. Limiting Structure: Use LIMIT 1 to retrieve only the box with the lowest value. 5. Join Structure: No JOIN is required since all necessary data is within the ""Boxes"" table.",1.0
1815,What is the name and overall ranking of universities in Wisconsin state?,NON-NESTED,university_rank,"[university.University_Name, university.State, overall_ranking.Rank, overall_ranking.University_ID = university.University_ID, Wisconsin]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT university.University_Name, overall_ranking.Rank FROM university JOIN overall_ranking ON university.University_ID = overall_ranking.University_ID WHERE university.State = 'Wisconsin';","SELECT T1.university_name ,  T2.rank FROM University AS T1 JOIN Overall_ranking AS T2 ON T1.university_id  =  T2.university_id WHERE T1.state  =  'Wisconsin'","1. Sequential Structure: Start with the SELECT clause to retrieve ""university.University_Name"" and ""overall_ranking.Rank."" 2. Condition Structure: Use a WHERE clause to filter for universities located in the state of ""Wisconsin."" 3. Join Structure: Use a JOIN between the ""university"" table and the ""overall_ranking"" table based on the shared key ""university.University_ID"" to link each university with its ranking. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without summarization.",1.0
1816,Show all information of all unrated movies.,EASY,movie_2,"[Movies.Code, Movies.Rating]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT * FROM Movies WHERE Movies.Rating IS NULL;,SELECT * FROM movies WHERE rating  =  'null',"1. Sequential Structure: Begin with the SELECT clause to retrieve all columns from the ""Movies"" table, as the question asks for all information. 2. Condition Structure: Use a WHERE clause to filter for movies that are unrated, which means the ""Movies.Rating"" field is NULL. 3. Join Structure: No JOIN is required since all necessary data is within the ""Movies"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving all information for unrated movies without any summarization.",1.0
1817,Show the titles of movies not currently being shown in any theaters.,NESTED,movie_2,"[Movies.Title, MovieTheaters.Movie, MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies WHERE Movies.Code NOT IN (SELECT MovieTheaters.Movie FROM MovieTheaters);,SELECT Title FROM Movies WHERE Code NOT IN (SELECT Movie FROM MovieTheaters WHERE Movie != 'null'),"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of movies. Use the FROM clause to specify the Movies table. Apply a WHERE clause to filter movies that are not currently being shown in any theaters. 2. Condition Structure: Use the WHERE clause with a subquery to exclude movies whose codes appear in the MovieTheaters table, indicating they are being shown in theaters. 3. Join Structure: Not required, as we only need to filter based on the absence of matching movie codes in the MovieTheaters table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",0.0
1818,What are the different locations of warehouses?,EASY,warehouse_1,[Warehouses.Location],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Warehouses.Location FROM Warehouses;,SELECT count(DISTINCT LOCATION) FROM warehouses,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct locations of warehouses. 2. Condition Structure: No specific filtering condition is required as we want all unique warehouse locations. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Warehouses"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique locations are retrieved.",0.0
1819,What is the content with the greatest value across all boxes?,EASY,warehouse_1,"[Boxes.Contents, Boxes.Value]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Boxes.Contents FROM Boxes WHERE Boxes.Value = (SELECT MAX(Boxes.Value) FROM Boxes);,SELECT CONTENTS FROM boxes ORDER BY value DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the content with the greatest value. 2. Condition Structure: No specific filtering condition is required since we are looking for the content with the maximum value across all boxes. 3. Join Structure: No JOIN is required as all necessary information is within the ""Boxes"" table. 4. Aggregation Structure: Use the MAX function to find the greatest value and retrieve the corresponding content.",1.0
1820,Show all university names without a major with rank 1?,NESTED,university_rank,"[university.University_Name,major_ranking.Rank,major_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.University_Name FROM university LEFT JOIN major_ranking ON university.University_ID = major_ranking.University_ID WHERE major_ranking.Rank IS NULL OR major_ranking.Rank != 1;,SELECT university_name FROM University EXCEPT SELECT T2.university_name FROM Major_Ranking AS T1 JOIN University AS T2 ON T1.university_id  =  T2.university_id WHERE T1.rank  =  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the university names. Use the FROM clause to specify the university table. Apply a LEFT JOIN with the major_ranking table on the University_ID to include all universities and their associated rankings. Use a WHERE clause to filter for universities that do not have a major with rank 1. 2. Condition Structure: Use the WHERE clause to check for cases where the rank is not 1 or where there is no associated rank (NULL). 3. Join Structure: Use a LEFT JOIN between the university and major_ranking tables based on University_ID to ensure all universities are included, even if they do not have a major ranking. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1821,How many different types of contents are stored in each warehouse?,NON-NESTED,warehouse_1,"[Boxes.Contents, Boxes.Warehouse, Warehouses.Code = Boxes.Warehouse]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Code, COUNT(DISTINCT Boxes.Contents) AS Content_Types FROM Warehouses JOIN Boxes ON Warehouses.Code = Boxes.Warehouse GROUP BY Warehouses.Code;","SELECT count(DISTINCT CONTENTS) ,  warehouse FROM boxes GROUP BY warehouse","1. Sequential Structure: Start with the SELECT clause to retrieve the warehouse identifier and count the distinct types of contents stored in each warehouse. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Warehouses.Code = Boxes.Warehouse"" to associate each warehouse with its stored contents. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Boxes.Contents"" to count the unique types of contents for each warehouse, and GROUP BY ""Warehouses.Code"" to group the results by warehouse.",1.0
1822,What are the different home conferences from the university table?,EASY,university_rank,[university.Home_Conference],"Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT DISTINCT university.Home_Conference FROM university;,SELECT DISTINCT home_conference FROM University,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct values of ""university.Home_Conference"" since the question asks for different home conferences. 2. Condition Structure: No specific filtering condition is required as we want all distinct home conferences. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""university"" table. 4. Aggregation Structure: Use DISTINCT to ensure only unique home conferences are retrieved.",1.0
1823,Sort the driver names by age in ascending order.,EASY,car_racing,"[driver.Driver, driver.Age]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT driver.Driver FROM driver ORDER BY driver.Age ASC;,SELECT Driver FROM driver ORDER BY Age ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the driver name. 2. Condition Structure: No specific filtering condition is required as we want all driver names. 3. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in ascending order based on ""driver.Age"".",1.0
1824,What are all of the package numbers received by Leo Wong?,NON-NESTED,planet_1,"[Package.PackageNumber,Client.Name,Package.Recipient = Client.AccountNumber,Leo Wong]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Package.PackageNumber FROM Package JOIN Client ON Package.Recipient = Client.AccountNumber WHERE Client.Name = 'Leo Wong';,"SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Recipient  =  T2.AccountNumber WHERE T2.Name = ""Leo Wong"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Package.PackageNumber"" field, as the question asks for package numbers. 2. Condition Structure: Use a WHERE clause to filter for packages where the recipient matches the account number of the client named ""Leo Wong."" 3. Join Structure: Use a JOIN between the ""Package"" table and the ""Client"" table based on the relationship ""Package.Recipient = Client.AccountNumber"" to link packages with their recipients. 4. Aggregation Structure: No aggregation is needed, as the query simply retrieves all relevant package numbers.",1.0
1825,How many boxes are there with each warehouse ?,NON-NESTED,warehouse_1,"[Boxes.Warehouse, Warehouses.Code, Boxes.Code = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Code, COUNT(Boxes.Code) AS BoxCount FROM Warehouses JOIN Boxes ON Boxes.Code = Warehouses.Code GROUP BY Warehouses.Code;","select warehouse ,  count(*) from boxes group by warehouse","1. Sequential Structure: Start with the SELECT clause to retrieve the warehouse identifier and the count of boxes for each warehouse. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the shared ""Code"" field to associate each box with its respective warehouse. 4. Aggregation Structure: Use COUNT to count the number of boxes for each warehouse and GROUP BY the warehouse identifier to group the results by each warehouse.",0.0
1826,How many movies had a 'G' rating?,EASY,movie_2,[Movies.Rating],"Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT COUNT(*) FROM Movies WHERE Movies.Rating = 'G';,SELECT count(*) FROM movies WHERE rating  =  'G',"1. Sequential Structure: Start with the SELECT clause to count the number of movies with a 'G' rating. 2. Condition Structure: Use a WHERE clause to filter movies where the ""Movies.Rating"" is 'G'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Movies"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of movies that meet the specified condition.",1.0
1827,"For each make, return the make and the count of drivers with that make.",EASY,car_racing,"[driver.Make, driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT driver.Make, COUNT(driver.Driver_ID) AS driver_count FROM driver GROUP BY driver.Make;","SELECT Make ,  COUNT(*) FROM driver GROUP BY Make","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""driver.Make"" and the count of drivers for each make. 2. Aggregation Structure: Use COUNT to calculate the number of drivers for each make. 3. Grouping Structure: Use GROUP BY on ""driver.Make"" to group the results by each make. 4. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table.",1.0
1828,What is the position of Amy Wong?,EASY,planet_1,"[Employee.Position, Employee.Name]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Employee.Position FROM Employee WHERE Employee.Name = 'Amy Wong';,"SELECT POSITION FROM Employee WHERE Name  =  ""Amy Wong"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Employee.Position"" of the employee named ""Amy Wong"". 2. Condition Structure: Use a WHERE clause to filter for the employee whose name is ""Amy Wong"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Employee"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
1829,Find all contents present in warehouses located in Chicago and those located in New York.,NESTED,warehouse_1,"[Warehouses.Location, Boxes.Contents, Boxes.Warehouse = Warehouses.Code, Chicago, New York]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Contents FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location IN ('Chicago', 'New York');",SELECT T1.contents FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'Chicago' INTERSECT SELECT T1.contents FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'New York',"1. Sequential Structure: Start with the SELECT clause to retrieve the contents of boxes. Use the FROM clause to specify the Boxes table and JOIN it with the Warehouses table to link box contents with warehouse locations. Apply a WHERE clause to filter for warehouses located in Chicago or New York. 2. Condition Structure: Use the WHERE clause to filter for warehouses where the location is either 'Chicago' or 'New York'. 3. Join Structure: Use an INNER JOIN between the Boxes and Warehouses tables based on the warehouse code to connect box contents with their respective warehouse locations. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1830,Show all home conferences.,EASY,university_rank,[university.Home_Conference],"Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT DISTINCT university.Home_Conference FROM university;,SELECT DISTINCT home_conference FROM University,"1. Sequential Structure: Start with the SELECT clause to retrieve all distinct values of ""university.Home_Conference"". 2. Condition Structure: No specific filtering condition is required as the query aims to show all home conferences. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""university"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique home conferences are displayed.",1.0
1831,What are the names of institutions that have 1 or more championships?,NON-NESTED,institution_sports,"[institution.Name, Championship.Number_of_Championships, Championship.Institution_ID = institution.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT institution.Name FROM institution JOIN Championship ON Championship.Institution_ID = institution.Institution_ID WHERE Championship.Number_of_Championships >= 1;,SELECT T2.Name FROM championship AS T1 JOIN institution AS T2 ON T1.Institution_ID  =  T2.Institution_ID WHERE T1.Number_of_Championships  >=  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""institution.Name."" 2. Condition Structure: Use a WHERE clause to filter for institutions that have 1 or more championships by checking ""Championship.Number_of_Championships"" is greater than or equal to 1. 3. Join Structure: Use a JOIN between the ""institution"" and ""Championship"" tables based on the relationship ""Championship.Institution_ID = institution.Institution_ID"" to link institutions with their championship records. 4. Aggregation Structure: No aggregation is needed as we are only filtering and retrieving institution names.",1.0
1832,"What is the average age of drivers from countries with official native language ""English""",NON-NESTED,car_racing,"[driver.Age, driver.Country, country.Country, country.Official_native_language, driver.Country = country.Country, English]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT AVG(driver.Age) FROM driver JOIN country ON driver.Country = country.Country WHERE country.Official_native_language = 'English';,"SELECT avg(T2.age) FROM country AS T1 JOIN driver AS T2 ON T1.Country_ID  =  T2.Country WHERE T1.Official_native_language  =  ""English""","1. Sequential Structure: Start with the SELECT clause to calculate the average age of drivers. Use the AVG function on the ""driver.Age"" field. 2. Condition Structure: Use a WHERE clause to filter for countries where the ""country.Official_native_language"" is ""English."" 3. Join Structure: Use an INNER JOIN to connect the ""driver"" table with the ""country"" table based on the shared ""Country"" field. 4. Aggregation Structure: Use the AVG function to compute the average age of drivers from the filtered countries.",0.0
1833,Find the average and maximum value for each different content.,EASY,warehouse_1,"[Boxes.Contents, Boxes.Value]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Contents, AVG(Boxes.Value) AS avg_value, MAX(Boxes.Value) AS max_value FROM Boxes GROUP BY Boxes.Contents;","SELECT avg(value) ,  max(value) ,  CONTENTS FROM boxes GROUP BY CONTENTS","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the content type and the required aggregate values (average and maximum value). 2. Aggregation Structure: Use AVG and MAX functions to calculate the average and maximum value for each content type. 3. Grouping Structure: Use GROUP BY on ""Boxes.Contents"" to calculate these aggregate values for each unique content type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Boxes"" table.",1.0
1834,How many movies exist for each rating?,EASY,movie_2,"[Movies.Rating, Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
","SELECT Movies.Rating, COUNT(Movies.Code) AS movie_count FROM Movies GROUP BY Movies.Rating;","SELECT count(*) ,  rating FROM movies GROUP BY rating","1. Sequential Structure: Begin with the SELECT clause to specify the rating and the count of movies for each rating. 2. Aggregation Structure: Use COUNT to calculate the number of movies for each rating. 3. Grouping Structure: Use GROUP BY on ""Movies.Rating"" to aggregate the results by each rating. 4. Join Structure: No JOIN is required since all necessary data is within the ""Movies"" table.",1.0
1835,Find the value of the most expensive boxes saved in each warehouse location.,NON-NESTED,warehouse_1,"[Boxes.Value, Warehouses.Location, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Location, MAX(Boxes.Value) AS Most_Expensive_Box FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code GROUP BY Warehouses.Location;","SELECT max(T1.value) ,  T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code GROUP BY T2.location","1. Sequential Structure: Start with the SELECT clause to retrieve the maximum value of boxes and the corresponding warehouse location. Use MAX on ""Boxes.Value"" to find the most expensive box in each warehouse. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to associate each box with its warehouse location. 4. Aggregation Structure: Use GROUP BY on ""Warehouses.Location"" to group the results by each warehouse location and apply MAX to find the most expensive box in each group.",1.0
1836,Find the contents that are stored in both Chicago and New York.,NESTED,warehouse_1,"[Boxes.Contents,Warehouses.Location,Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT b1.Contents FROM Boxes b1 JOIN Warehouses w1 ON b1.Warehouse = w1.Code WHERE w1.Location = 'Chicago' AND b1.Contents IN ( SELECT b2.Contents FROM Boxes b2 JOIN Warehouses w2 ON b2.Warehouse = w2.Code WHERE w2.Location = 'New York' );,SELECT T1.contents FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'Chicago' INTERSECT SELECT T1.contents FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'New York',"1. Sequential Structure: Start with the SELECT clause to retrieve the contents of boxes. Use the FROM clause to specify the Boxes and Warehouses tables. Apply a WHERE clause to filter for boxes stored in warehouses located in both Chicago and New York. 2. Condition Structure: Use the WHERE clause to filter for warehouses located in Chicago and New York. Use a subquery to find the contents that are common to both locations. 3. Join Structure: Use an INNER JOIN between the Boxes and Warehouses tables based on the Warehouse code to connect box contents with their respective warehouse locations. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1837,What are the cities and provinces of institutions?,EASY,institution_sports,"[institution.City, institution.Province]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT institution.City, institution.Province FROM institution;","SELECT City ,  Province FROM institution","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the city and province of institutions. 2. Condition Structure: No specific filtering condition is required as the query asks for all cities and provinces of institutions. 3. Join Structure: No JOIN is required since all necessary information is available in the ""institution"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the city and province information for all institutions.",1.0
1838,"For each content, what is the total value and number of boxes?",EASY,warehouse_1,"[Boxes.Contents, Boxes.Value, Boxes.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Contents, SUM(Boxes.Value) AS total_value, COUNT(Boxes.Code) AS number_of_boxes FROM Boxes GROUP BY Boxes.Contents;","SELECT sum(value) ,  count(*) ,  CONTENTS FROM boxes GROUP BY CONTENTS","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the content type, the total value, and the number of boxes. 2. Aggregation Structure: Use SUM to calculate the total value and COUNT to determine the number of boxes for each content type. 3. Grouping Structure: Use GROUP BY on ""Boxes.Contents"" to aggregate the results by each content type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Boxes"" table.",1.0
1839,What are the average values of boxes for each warehouse than has an average value greater than 150?,NESTED,warehouse_1,"[Boxes.Value, Boxes.Warehouse, Warehouses.Code = Boxes.Warehouse]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Warehouse, AVG(Boxes.Value) AS average_value FROM Boxes JOIN Warehouses ON Warehouses.Code = Boxes.Warehouse GROUP BY Boxes.Warehouse HAVING AVG(Boxes.Value) > 150;","SELECT warehouse ,  avg(value) FROM boxes GROUP BY warehouse HAVING avg(value)  >  150",1. Sequential Structure: Start with the SELECT clause to calculate the average value of boxes for each warehouse. Use the FROM clause to specify the Boxes table and JOIN it with the Warehouses table to connect warehouses with their respective boxes. Apply a GROUP BY clause to group the data by warehouse. Use a HAVING clause to filter warehouses where the average value of boxes is greater than 150. 2. Condition Structure: Use the HAVING clause to filter for warehouses with an average value of boxes greater than 150. 3. Join Structure: Use an INNER JOIN between the Boxes and Warehouses tables based on the relationship Warehouses.Code = Boxes.Warehouse to connect the data. 4. Aggregation Structure: Use the AVG function to calculate the average value of boxes for each warehouse and apply the condition in the HAVING clause.,1.0
1840,List Package Number of all package sent by Leo Wong?,NON-NESTED,planet_1,"[Package.PackageNumber,Client.Name,Package.Sender = Client.AccountNumber,Leo Wong]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Package.PackageNumber FROM Package JOIN Client ON Package.Sender = Client.AccountNumber WHERE Client.Name = 'Leo Wong';,"SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name  =  ""Leo Wong"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Package.PackageNumber"" field, which represents the package numbers. 2. Condition Structure: Use a WHERE clause to filter for packages sent by the client named ""Leo Wong."" 3. Join Structure: Use a JOIN between the ""Package"" table and the ""Client"" table based on the relationship ""Package.Sender = Client.AccountNumber"" to link packages with their senders. 4. Aggregation Structure: No aggregation is needed as the query only retrieves package numbers.",1.0
1841,What is the name of university with major Accounting ranked 3 or above?,NON-NESTED,university_rank,"[university.University_Name,major.Major_Name,major_ranking.Rank,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID,Accounting,3]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.University_Name FROM major_ranking JOIN major ON major_ranking.Major_ID = major.Major_ID JOIN university ON major_ranking.University_ID = university.University_ID WHERE major.Major_Name = 'Accounting' AND major_ranking.Rank <= 3;,"SELECT T2.university_name FROM Major_Ranking AS T1 JOIN University AS T2 JOIN Major AS T3 ON T1.university_id  =  T2.university_id AND T1.major_id  =  T3.major_id WHERE T1.rank  <=  3 AND T3.major_name  =  ""Accounting""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""university.University_Name."" 2. Condition Structure: Use a WHERE clause to filter for records where the ""major.Major_Name"" is ""Accounting"" and the ""major_ranking.Rank"" is 3 or above. 3. Join Structure: Use JOINs to connect the ""major_ranking"" table with the ""major"" table on ""major_ranking.Major_ID = major.Major_ID"" and the ""major_ranking"" table with the ""university"" table on ""major_ranking.University_ID = university.University_ID"" to link universities with their respective majors and rankings. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific university names based on the given conditions.",1.0
1842,What are the maximum and minimum enrollment of all institutions?,EASY,institution_sports,[institution.Enrollment],"Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT MAX(institution.Enrollment) AS max_enrollment, MIN(institution.Enrollment) AS min_enrollment FROM institution;","SELECT max(Enrollment) ,  min(Enrollment) FROM institution","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum enrollment. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum enrollment across all institutions. 3. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table. 4. Condition Structure: No specific filtering condition is needed as the query is for all institutions.",1.0
1843,What is the salary and position of the employee named Turanga Leela?,EASY,planet_1,"[Employee.Salary, Employee.Position, Employee.Name]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Employee.Salary, Employee.Position FROM Employee WHERE Employee.Name = 'Turanga Leela';","SELECT Salary ,  POSITION FROM Employee WHERE Name  =  ""Turanga Leela"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Employee.Salary"" and ""Employee.Position"" of the employee named ""Turanga Leela"". 2. Condition Structure: Use a WHERE clause to filter for the employee whose name is ""Turanga Leela"". 3. Join Structure: No JOIN is required since all relevant information is in the ""Employee"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
1844,"What is the name, city, and state of the university with number 1 ranked Accounting major?",NON-NESTED,university_rank,"[university.University_Name, university.City, university.State, major.Major_Name, major_ranking.Rank, major_ranking.Major_ID = major.Major_ID, major_ranking.University_ID = university.University_ID, major.Major_Name = 'Accounting', major_ranking.Rank = 1]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT university.University_Name, university.City, university.State FROM major_ranking JOIN major ON major_ranking.Major_ID = major.Major_ID JOIN university ON major_ranking.University_ID = university.University_ID WHERE major.Major_Name = 'Accounting' AND major_ranking.Rank = 1;","SELECT T2.university_name ,  T2.city ,  T2.state FROM Major_Ranking AS T1 JOIN University AS T2 JOIN Major AS T3 ON T1.university_id  =  T2.university_id AND T1.major_id  =  T3.major_id WHERE T1.rank  =  1 AND T3.major_name  =  'Accounting'","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""university.University_Name,"" ""university.City,"" and ""university.State."" 2. Condition Structure: Use a WHERE clause to filter for the ""Accounting"" major and the rank equal to 1. 3. Join Structure: Use JOINs to connect the ""major_ranking"" table with the ""major"" table on ""major_ranking.Major_ID = major.Major_ID"" and the ""major_ranking"" table with the ""university"" table on ""major_ranking.University_ID = university.University_ID."" 4. Aggregation Structure: No aggregation is needed as the query is focused on filtering and retrieving specific information.",1.0
1845,List the names of institutions in descending order of the number of championships.,NON-NESTED,institution_sports,"[institution.Name, Championship.Number_of_Championships, Championship.Institution_ID = institution.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT institution.Name, SUM(Championship.Number_of_Championships) AS Total_Championships FROM institution JOIN Championship ON Championship.Institution_ID = institution.Institution_ID GROUP BY institution.Name ORDER BY Total_Championships DESC;",SELECT T2.Name FROM championship AS T1 JOIN institution AS T2 ON T1.Institution_ID  =  T2.Institution_ID ORDER BY T1.Number_of_Championships DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""institution.Name"" and the count of championships. Use an aggregate function (SUM) on ""Championship.Number_of_Championships"" to calculate the total number of championships for each institution. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""institution"" and ""Championship"" tables based on the shared key ""Championship.Institution_ID = institution.Institution_ID"" to link institutions with their championship data. 4. Aggregation Structure: Use GROUP BY on ""institution.Name"" to group the results by institution, and then use ORDER BY in descending order of the total number of championships.",1.0
1846,What are the names of the university with an Accounting major ranked 3 or higher?,NON-NESTED,university_rank,"[university.University_Name,major.Major_Name,major_ranking.Rank,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID,Accounting,3]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.University_Name FROM major_ranking JOIN major ON major_ranking.Major_ID = major.Major_ID JOIN university ON major_ranking.University_ID = university.University_ID WHERE major.Major_Name = 'Accounting' AND major_ranking.Rank <= 3;,"SELECT T2.university_name FROM Major_Ranking AS T1 JOIN University AS T2 JOIN Major AS T3 ON T1.university_id  =  T2.university_id AND T1.major_id  =  T3.major_id WHERE T1.rank  <=  3 AND T3.major_name  =  ""Accounting""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""university.University_Name."" 2. Condition Structure: Use a WHERE clause to filter for records where the ""major.Major_Name"" is ""Accounting"" and the ""major_ranking.Rank"" is 3 or higher. 3. Join Structure: Use JOINs to connect the ""major_ranking"" table with the ""major"" table on ""major_ranking.Major_ID = major.Major_ID"" and the ""major_ranking"" table with the ""university"" table on ""major_ranking.University_ID = university.University_ID."" 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific university names based on the conditions.",1.0
1847,"What are the nicknames of institutions, ordered descending by their capacities?",NON-NESTED,institution_sports,"[Championship.Nickname, institution.Capacity, Championship.Institution_ID = institution.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT Championship.Nickname, institution.Capacity FROM Championship JOIN institution ON Championship.Institution_ID = institution.Institution_ID ORDER BY institution.Capacity DESC;",SELECT T1.Nickname FROM championship AS T1 JOIN institution AS T2 ON T1.Institution_ID  =  T2.Institution_ID ORDER BY T2.Capacity DESC,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Championship.Nickname"" and ""institution.Capacity."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Championship"" and ""institution"" tables based on the shared key ""Institution_ID"" to link each institution with its nickname. 4. Aggregation Structure: No aggregation is required, but apply ORDER BY in descending order on ""institution.Capacity"" to sort the results as specified.",1.0
1848,List all the driver names in ascending order of age.,EASY,car_racing,"[driver.Driver, driver.Age]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
",SELECT driver.Driver FROM driver ORDER BY driver.Age ASC;,SELECT Driver FROM driver ORDER BY Age ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the driver names. 2. Condition Structure: No specific filtering condition is required as we want all driver names. 3. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in ascending order based on the ""driver.Age"".",1.0
1849,In how many different warehouses are Rocks stored within boxes?,NON-NESTED,warehouse_1,"[Boxes.Contents, Boxes.Warehouse, Warehouses.Code = Boxes.Warehouse]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT COUNT(DISTINCT Boxes.Warehouse) FROM Boxes JOIN Warehouses ON Warehouses.Code = Boxes.Warehouse WHERE Boxes.Contents = 'Rocks';,SELECT count(DISTINCT LOCATION) FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T1.contents  =  'Rocks',"1. Sequential Structure: Start with the SELECT clause to count the distinct warehouses where ""Rocks"" are stored within boxes. Use COUNT with DISTINCT on the ""Boxes.Warehouse"" field. 2. Condition Structure: Use a WHERE clause to filter for records where ""Boxes.Contents"" is ""Rocks."" 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Warehouses.Code = Boxes.Warehouse"" to link each box to its respective warehouse. 4. Aggregation Structure: Use COUNT with DISTINCT to ensure that only unique warehouses are counted.",1.0
1850,What are the different contents in boxes?,EASY,warehouse_1,[Boxes.Contents],"Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Boxes.Contents FROM Boxes;,SELECT DISTINCT CONTENTS FROM boxes,"1. Sequential Structure: Start with the SELECT clause to specify the distinct contents in the boxes. 2. Condition Structure: No specific filtering condition is required as we want all unique contents. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Boxes"" table. 4. Aggregation Structure: Use DISTINCT to retrieve unique contents from the ""Boxes.Contents"" column.",1.0
1851,Find the unique contents of all boxes whose value is higher than the average value of all boxes.,NESTED,warehouse_1,"[Boxes.Contents, Boxes.Value]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT DISTINCT Contents FROM Boxes WHERE Value > (SELECT AVG(Value) FROM Boxes);,SELECT DISTINCT CONTENTS FROM boxes WHERE value  >  (SELECT avg(value) FROM boxes),"1. Sequential Structure: Start with the SELECT clause to retrieve the unique contents of boxes. Use the FROM clause to specify the Boxes table. Apply a WHERE clause to filter boxes whose value is higher than the average value of all boxes. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average value of all boxes and filter for boxes with a value greater than this average. 3. Join Structure: Not required, as all data is in the Boxes table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average value of all boxes, and use DISTINCT to ensure unique contents are retrieved.",1.0
1852,What is the most common type of affiliation for institutions?,EASY,institution_sports,[institution.Affiliation],"Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT institution.Affiliation FROM institution GROUP BY institution.Affiliation ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Affiliation FROM institution GROUP BY Affiliation ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""institution.Affiliation"". 2. Aggregation Structure: Use COUNT to determine the frequency of each type of affiliation. 3. Grouping Structure: Use GROUP BY on ""institution.Affiliation"" to aggregate the results by each affiliation type. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank affiliations by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common type of affiliation. 6. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table.",1.0
1853,What are all the different package numbers that Leo Wong sent or received?,NON-NESTED,planet_1,"[Package.PackageNumber,Client.Name,Package.Sender = Client.AccountNumber,Package.Recipient = Client.AccountNumber,Leo Wong]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT DISTINCT Package.PackageNumber FROM Package JOIN Client ON Package.Sender = Client.AccountNumber OR Package.Recipient = Client.AccountNumber WHERE Client.Name = 'Leo Wong';,"SELECT DISTINCT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber OR T1.Recipient  =  T2.AccountNumber WHERE T2.Name = ""Leo Wong""","1. Sequential Structure: Start with the SELECT clause to retrieve distinct ""Package.PackageNumber"" since we are interested in all unique package numbers. 2. Condition Structure: Use a WHERE clause to filter for packages where the sender or recipient is ""Leo Wong."" This requires matching ""Package.Sender"" or ""Package.Recipient"" with the ""Client.AccountNumber"" of ""Leo Wong."" 3. Join Structure: Use JOIN to connect the ""Package"" table with the ""Client"" table on ""Package.Sender = Client.AccountNumber"" and ""Package.Recipient = Client.AccountNumber"" to identify packages associated with ""Leo Wong."" 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique package numbers are returned.",1.0
1854,What are the manager and car owner of the team that has at least 2 drivers?,NESTED,car_racing,"[team.Manager, team.Car_Owner, team.Team_ID = team_driver.Team_ID, team_driver.Driver_ID, driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT team.Manager, team.Car_Owner FROM team JOIN team_driver ON team.Team_ID = team_driver.Team_ID GROUP BY team.Team_ID, team.Manager, team.Car_Owner HAVING COUNT(team_driver.Driver_ID) >= 2;","SELECT t1.manager ,  t1.car_owner FROM team AS t1 JOIN team_driver AS t2 ON t1.team_id  =  t2.team_id GROUP BY t2.team_id HAVING count(*)  >=  2",1. Sequential Structure: Start with the SELECT clause to retrieve the manager and car owner of the team. Use the FROM clause to specify the team table and JOIN it with the team_driver table to connect teams with their drivers. Apply a GROUP BY clause to group by team ID and count the number of drivers per team. Use the HAVING clause to filter teams with at least 2 drivers. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for teams that have at least 2 drivers. 3. Join Structure: Use an INNER JOIN between the team and team_driver tables based on Team_ID to connect teams with their drivers. 4. Aggregation Structure: Use COUNT(*) within HAVING to count the number of drivers per team and filter out teams with fewer than 2 drivers.,1.0
1855,What are the names of all universities in ascending order of reputation points?,NON-NESTED,university_rank,"[university.University_Name, overall_ranking.Reputation_point, overall_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT university.University_Name FROM university JOIN overall_ranking ON university.University_ID = overall_ranking.University_ID ORDER BY overall_ranking.Reputation_point ASC;,SELECT T1.university_name FROM University AS T1 JOIN Overall_ranking AS T2 ON T1.university_id  =  T2.university_id ORDER BY T2.reputation_point,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""university.University_Name."" 2. Condition Structure: No specific filtering condition is required as the query asks for all universities. 3. Join Structure: Use a JOIN between the ""university"" table and the ""overall_ranking"" table based on the shared key ""University_ID"" to access the reputation points for each university. 4. Aggregation Structure: No aggregation is needed, but apply ORDER BY on ""overall_ranking.Reputation_point"" in ascending order to sort the universities by their reputation points.",1.0
1856,"Return the years in which more than 1 institution was founded, as well as the number of institutions founded in each of those.",EASY,institution_sports,"[institution.Founded, institution.Institution_ID]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
","SELECT institution.Founded, COUNT(institution.Institution_ID) AS institution_count FROM institution GROUP BY institution.Founded HAVING COUNT(institution.Institution_ID) > 1;","SELECT Founded ,  COUNT(*) FROM institution GROUP BY Founded HAVING COUNT(*)  >  1","1. Sequential Structure: Begin with the SELECT clause to specify the year of founding and the count of institutions founded in each year. 2. Aggregation Structure: Use COUNT to calculate the number of institutions founded in each year. 3. Grouping Structure: Use GROUP BY on ""institution.Founded"" to group the results by the year of founding. 4. Condition Structure: Apply the HAVING clause to filter for years where more than one institution was founded. 5. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table.",1.0
1857,What is the total enrollment of universities with a overall rank 5 or below?,NON-NESTED,university_rank,"[university.Enrollment,overall_ranking.Rank,overall_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT SUM(university.Enrollment) FROM university JOIN overall_ranking ON overall_ranking.University_ID = university.University_ID WHERE overall_ranking.Rank <= 5;,SELECT sum(enrollment) FROM University AS T1 JOIN Overall_ranking AS T2 ON T1.university_id  =  T2.university_id WHERE T2.rank  >=  5,"1. Sequential Structure: Start with the SELECT clause to calculate the total enrollment using the SUM function on ""university.Enrollment."" 2. Condition Structure: Use a WHERE clause to filter universities with an overall rank of 5 or below. 3. Join Structure: Use an INNER JOIN to connect the ""university"" table with the ""overall_ranking"" table based on the shared key ""University_ID."" 4. Aggregation Structure: Use the SUM function to calculate the total enrollment of the filtered universities.",0.0
1858,Find the name of the movie that is played in the most number of theaters.,NON-NESTED,movie_2,"[MovieTheaters.Name,MovieTheaters.Movie,Movies.Code = MovieTheaters.Movie,Movies.Title]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT Movies.Title FROM Movies JOIN MovieTheaters ON Movies.Code = MovieTheaters.Movie GROUP BY Movies.Code ORDER BY COUNT(MovieTheaters.Name) DESC LIMIT 1;,SELECT T1.title FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie GROUP BY T1.title ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Movies.Title"" since we need the name of the movie. Use COUNT to count the number of theaters each movie is played in. 2. Condition Structure: No specific filtering condition is required as we are interested in the movie played in the most theaters. 3. Join Structure: Use a JOIN between the ""Movies"" table and the ""MovieTheaters"" table based on the relationship ""Movies.Code = MovieTheaters.Movie"" to link each movie with its theater data. 4. Aggregation Structure: Use COUNT on ""MovieTheaters.Name"" to count the number of theaters for each movie. Use GROUP BY on ""Movies.Code"" to group the results by each movie. Use ORDER BY in descending order on the count to rank movies by the number of theaters, and LIMIT 1 to select the movie with the highest count.",0.0
1859,What are the total enrollment of institutions in city `` Vancouver '' or `` Calgary '' ?,EASY,institution_sports,"[institution.Enrollment, institution.City]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT SUM(institution.Enrollment) AS total_enrollment FROM institution WHERE institution.City = 'Vancouver' OR institution.City = 'Calgary';,"select sum(enrollment) from institution where city  =  ""vancouver"" or city  =  ""calgary""","1. Sequential Structure: Begin with the SELECT clause to specify the total enrollment, as the question asks for the total enrollment of institutions. 2. Condition Structure: Use a WHERE clause to filter institutions located in the cities ""Vancouver"" or ""Calgary"". 3. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table. 4. Aggregation Structure: Use SUM to calculate the total enrollment for the specified cities.",0.0
1860,What is the total number of universities located in Illinois or Ohio?,EASY,university_rank,"[university.University_ID, university.State, Illinois, Ohio]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT COUNT(university.University_ID) FROM university WHERE university.State = 'Illinois' OR university.State = 'Ohio';,SELECT count(*) FROM University WHERE state  =  'Illinois' OR state  =  'Ohio',"1. Sequential Structure: Begin with the SELECT clause to count the total number of universities. 2. Condition Structure: Use a WHERE clause to filter universities located in the states of Illinois or Ohio. 3. Join Structure: No JOIN is required since all necessary data is within the ""university"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of universities that meet the specified condition.",1.0
1861,Show all home conferences and the number of universities in each conference.,EASY,university_rank,"[university.Home_Conference, university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
","SELECT university.Home_Conference, COUNT(university.University_ID) AS university_count FROM university GROUP BY university.Home_Conference;","SELECT home_conference ,  count(*) FROM University GROUP BY home_conference","1. Sequential Structure: Begin with the SELECT clause to specify the home conference and the count of universities in each conference. 2. Aggregation Structure: Use COUNT to calculate the number of universities in each home conference. 3. Grouping Structure: Use GROUP BY on ""university.Home_Conference"" to group the results by each conference. 4. Join Structure: No JOIN is required since all necessary data is within the ""university"" table.",1.0
1862,What are the codes of boxes stored in warehouses in either Chicago or New York?,NON-NESTED,warehouse_1,"[Boxes.Code, Warehouses.Location, Boxes.Warehouse = Warehouses.Code, Chicago, New York]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Boxes.Code FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location = 'Chicago' OR Warehouses.Location = 'New York';,SELECT T1.code FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'Chicago' OR T2.location  =  'New York',"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Boxes.Code"" field, as the question asks for the codes of boxes. 2. Condition Structure: Use a WHERE clause to filter warehouses located in either ""Chicago"" or ""New York."" 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to associate each box with its respective warehouse. 4. Aggregation Structure: No aggregation is needed since the query only retrieves specific box codes.",1.0
1863,How many boxes are stored in each warehouse?,NON-NESTED,warehouse_1,"[Boxes.Warehouse,Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Warehouse, COUNT(*) AS box_count FROM Boxes GROUP BY Boxes.Warehouse;","SELECT count(*) ,  warehouse FROM boxes GROUP BY warehouse","1. Sequential Structure: Start with the SELECT clause to retrieve the warehouse code and the count of boxes stored in each warehouse. 2. Condition Structure: No specific filtering condition is required, as the question asks for all warehouses. 3. Join Structure: No JOIN is necessary since the information is already linked through the ""Boxes.Warehouse"" and ""Warehouses.Code."" 4. Aggregation Structure: Use COUNT to count the number of boxes for each warehouse and GROUP BY the warehouse code to group the results by each warehouse.",1.0
1864,"Return the stadiums of institutions, ordered by capacity descending.",EASY,institution_sports,"[institution.Stadium, institution.Capacity]","Table Championship, columns = [*,Institution_ID,Nickname,Joined,Number_of_Championships]
Table institution, columns = [*,Institution_ID,Name,Team,City,Province,Founded,Affiliation,Enrollment,Endowment,Stadium,Capacity]
","Foreign_keys = [Championship.Institution_ID = institution.Institution_ID]
",SELECT institution.Stadium FROM institution ORDER BY institution.Capacity DESC;,SELECT Stadium FROM institution ORDER BY Capacity DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the stadium name. 2. Ordering Structure: Use ORDER BY in descending order on the ""institution.Capacity"" to sort the stadiums by their capacity. 3. Condition Structure: No specific filtering condition is required as we want all stadiums. 4. Join Structure: No JOIN is required since all necessary data is within the ""institution"" table. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the stadiums by capacity.",1.0
1865,Find the total values of boxes that are not in the warehouses located at Chicago.,NESTED,warehouse_1,"[Boxes.Value, Warehouses.Location, Boxes.Warehouse = Warehouses.Code, Chicago]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT SUM(Boxes.Value) AS total_value FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location != 'Chicago';,SELECT sum(T1.value) FROM boxes AS T1 JOIN Warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location != 'Chicago',1. Sequential Structure: Start with the SELECT clause to calculate the total value of boxes. Use the FROM clause to specify the Boxes table and JOIN it with the Warehouses table to connect boxes with their respective warehouse locations. Apply a WHERE clause to exclude warehouses located in Chicago. 2. Condition Structure: Use the WHERE clause to filter out warehouses where the location is 'Chicago'. 3. Join Structure: Use an INNER JOIN between the Boxes and Warehouses tables based on the relationship between Boxes.Warehouse and Warehouses.Code to link boxes with their respective warehouses. 4. Aggregation Structure: Use the SUM function to calculate the total value of boxes that are not in warehouses located in Chicago.,1.0
1866,"Which country has both drivers with make ""Dodge"" and drivers with make ""Chevrolet""?",NESTED,car_racing,"[driver.Country, driver.Make, team_driver.Driver_ID = driver.Driver_ID]","Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT driver.Country FROM driver WHERE driver.Make IN ('Dodge', 'Chevrolet') GROUP BY driver.Country HAVING COUNT(DISTINCT driver.Make) = 2;","SELECT t2.country FROM driver AS t1 JOIN country AS t2 ON t1.country  =  t2.country_id WHERE t1.Make  =  ""Dodge"" INTERSECT SELECT t2.country FROM driver AS t1 JOIN country AS t2 ON t1.country  =  t2.country_id WHERE t1.Make  =  ""Chevrolet""","1. Sequential Structure: Start with the SELECT clause to retrieve the country. Use the FROM clause to specify the driver table. Apply a WHERE clause to filter for drivers with makes ""Dodge"" and ""Chevrolet"". Use a GROUP BY clause to group by country and a HAVING clause to ensure that both makes are present in the same country. 2. Condition Structure: Use the WHERE clause to filter for drivers with makes ""Dodge"" or ""Chevrolet"". Then, use the HAVING clause to ensure that both makes are present in the grouped results. 3. Join Structure: Not required, as all necessary data is available in the driver table. 4. Aggregation Structure: Use COUNT(DISTINCT Make) in the HAVING clause to ensure that both ""Dodge"" and ""Chevrolet"" are present for a country.",0.0
1867,What are the names of the movies that are played in any theater and the name of the corresponding theater?,NON-NESTED,movie_2,"[Movies.Title, MovieTheaters.Name, MovieTheaters.Movie = Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
","SELECT Movies.Title, MovieTheaters.Name FROM Movies JOIN MovieTheaters ON MovieTheaters.Movie = Movies.Code;","SELECT T1.title ,  T2.name FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie","1. Sequential Structure: Start with the SELECT clause to retrieve the names of the movies (""Movies.Title"") and the names of the corresponding theaters (""MovieTheaters.Name""). 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Movies"" and ""MovieTheaters"" tables based on the relationship ""MovieTheaters.Movie = Movies.Code"" to link each movie with the theaters where it is played. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the names of movies and theaters.",1.0
1868,Find the total value of boxes in the warehouses located at Chicago or New York.,NON-NESTED,warehouse_1,"[Warehouses.Location, Warehouses.Code, Boxes.Value, Boxes.Warehouse = Warehouses.Code, Chicago, New York]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT SUM(Boxes.Value) FROM Warehouses JOIN Boxes ON Boxes.Warehouse = Warehouses.Code WHERE Warehouses.Location = 'Chicago' OR Warehouses.Location = 'New York';,SELECT sum(T1.value) FROM boxes AS T1 JOIN warehouses AS T2 ON T1.warehouse  =  T2.code WHERE T2.location  =  'Chicago' OR T2.location  =  'New York',"1. Sequential Structure: Start with the SELECT clause to calculate the total value of boxes. Use the SUM function on the ""Boxes.Value"" field. 2. Condition Structure: Use a WHERE clause to filter warehouses located in ""Chicago"" or ""New York."" 3. Join Structure: Use a JOIN between the ""Warehouses"" and ""Boxes"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to associate each box with its respective warehouse. 4. Aggregation Structure: Use SUM to aggregate the total value of boxes for the specified warehouses.",1.0
1869,"Find the total, average, and maximum capacity for different locations.",EASY,warehouse_1,"[Warehouses.Location, Warehouses.Capacity]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Warehouses.Location, SUM(Warehouses.Capacity) AS total_capacity, AVG(Warehouses.Capacity) AS average_capacity, MAX(Warehouses.Capacity) AS maximum_capacity FROM Warehouses GROUP BY Warehouses.Location;","SELECT sum(capacity) ,  avg(capacity) ,  max(capacity) ,  LOCATION FROM warehouses GROUP BY LOCATION","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the total, average, and maximum capacities for each location. 2. Aggregation Structure: Use SUM, AVG, and MAX functions to calculate the total, average, and maximum capacities for each location. 3. Grouping Structure: Use GROUP BY on ""Warehouses.Location"" to calculate these aggregate values for each location. 4. Join Structure: No JOIN is required since all necessary data is within the ""Warehouses"" table.",1.0
1870,"Select the code of each box, along with the name of the city the box is located in.",NON-NESTED,warehouse_1,"[Boxes.Code, Warehouses.Location, Boxes.Warehouse = Warehouses.Code]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Code, Warehouses.Location FROM Boxes JOIN Warehouses ON Boxes.Warehouse = Warehouses.Code;","SELECT T1.code ,  T2.location FROM boxes AS T1 JOIN warehouses AS T2 ON T1.Warehouse  =  T2.Code","1. Sequential Structure: Start with the SELECT clause to retrieve ""Boxes.Code"" and ""Warehouses.Location."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Boxes"" and ""Warehouses"" tables based on the relationship ""Boxes.Warehouse = Warehouses.Code"" to link each box with its corresponding warehouse location. 4. Aggregation Structure: No aggregation is required as the query only involves retrieving and displaying data.",1.0
1871,What are the codes and corresponding contents of boxes for which their value is higher than the values of all boxes containing Scissors?,NESTED,warehouse_1,"[Boxes.Code, Boxes.Contents, Boxes.Value, Warehouses.Code = Boxes.Warehouse]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
","SELECT Boxes.Code, Boxes.Contents FROM Boxes WHERE Boxes.Value > ALL (SELECT Boxes.Value FROM Boxes WHERE Boxes.Contents = 'Scissors');","SELECT code ,  CONTENTS FROM boxes WHERE value  >  (SELECT max(value) FROM boxes WHERE CONTENTS  =  'Scissors')","1. Sequential Structure: Start with the SELECT clause to retrieve the codes and contents of boxes. Use the FROM clause to specify the Boxes table. Apply a WHERE clause to filter boxes whose value is higher than the values of all boxes containing ""Scissors"". 2. Condition Structure: Use the WHERE clause with a subquery to compare the value of each box to the maximum value of boxes containing ""Scissors"". The subquery filters boxes with ""Scissors"" in their contents and retrieves their values. 3. Join Structure: Not required, as all necessary data is available within the Boxes table. 4. Aggregation Structure: Use a subquery to find the maximum value of boxes containing ""Scissors"" and compare it with the value of other boxes in the main query.",0.0
1872,Show total and average points of all drivers.,EASY,car_racing,[driver.Points],"Table country, columns = [*,Country_Id,Country,Capital,Official_native_language,Regoin]
Table driver, columns = [*,Driver_ID,Driver,Country,Age,Car_#,Make,Points,Laps,Winnings]
Table team, columns = [*,Team_ID,Team,Make,Manager,Sponsor,Car_Owner]
Table team_driver, columns = [*,Team_ID,Driver_ID]
","Foreign_keys = [team_driver.Driver_ID = driver.Driver_ID,team_driver.Team_ID = team.Team_ID]
","SELECT SUM(driver.Points) AS total_points, AVG(driver.Points) AS average_points FROM driver;","SELECT sum(Points) ,  avg(Points) FROM driver","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the total and average points of all drivers. 2. Aggregation Structure: Use SUM to calculate the total points and AVG to calculate the average points for all drivers. 3. Condition Structure: No specific filtering condition is required as the query involves all drivers. 4. Join Structure: No JOIN is required since all necessary data is within the ""driver"" table.",1.0
1873,What are the names of all universities without any majors ranked number 1?,NESTED,university_rank,"[university.University_Name,major_ranking.Rank,major_ranking.University_ID = university.University_ID]","Table major, columns = [*,Major_ID,Major_Name,Major_Code]
Table major_ranking, columns = [*,Rank,University_ID,Major_ID]
Table overall_ranking, columns = [*,Rank,University_ID,Reputation_point,Research_point,Citation_point,Total]
Table university, columns = [*,University_ID,University_Name,City,State,Team_Name,Affiliation,Enrollment,Home_Conference]
","Foreign_keys = [overall_ranking.University_ID = university.University_ID,major_ranking.Major_ID = major.Major_ID,major_ranking.University_ID = university.University_ID]
",SELECT University_Name FROM university WHERE University_ID NOT IN (SELECT University_ID FROM major_ranking WHERE Rank = 1);,SELECT university_name FROM University EXCEPT SELECT T2.university_name FROM Major_Ranking AS T1 JOIN University AS T2 ON T1.university_id  =  T2.university_id WHERE T1.rank  =  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of universities. Use the FROM clause to specify the university table. Apply a WHERE clause to filter universities that do not have any majors ranked number 1. 2. Condition Structure: Use the WHERE clause with a subquery to exclude universities whose University_ID appears in the major_ranking table with a rank of 1. 3. Join Structure: Not required, as the filtering is based on the absence of matching University_ID entries in the major_ranking table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1874,How many movies are playing in theaters?,NON-NESTED,movie_2,"[MovieTheaters.Movie, Movies.Code]","Table MovieTheaters, columns = [*,Code,Name,Movie]
Table Movies, columns = [*,Code,Title,Rating]
","Foreign_keys = [MovieTheaters.Movie = Movies.Code]
",SELECT COUNT(*) FROM MovieTheaters JOIN Movies ON MovieTheaters.Movie = Movies.Code;,SELECT count(*) FROM movies AS T1 JOIN movietheaters AS T2 ON T1.code  =  T2.movie,"1. Sequential Structure: Start with the SELECT clause to count the number of movies playing in theaters. Use COUNT to aggregate the number of movies. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all movies currently playing in theaters. 3. Join Structure: Use a JOIN between the ""MovieTheaters"" and ""Movies"" tables based on the relationship between ""MovieTheaters.Movie"" and ""Movies.Code"" to link movies with theaters. 4. Aggregation Structure: Use COUNT to calculate the total number of movies playing in theaters.",1.0
1875,Find the code of all boxes whose value is higher than the value of any boxes with Rocks as content.,NESTED,warehouse_1,"[Boxes.Code, Boxes.Value, Boxes.Contents]","Table Boxes, columns = [*,Code,Contents,Value,Warehouse]
Table Warehouses, columns = [*,Code,Location,Capacity]
","Foreign_keys = [Boxes.Warehouse = Warehouses.Code]
",SELECT Code FROM Boxes WHERE Value > ANY (SELECT Value FROM Boxes WHERE Contents = 'Rocks');,SELECT code FROM boxes WHERE value  >  (SELECT min(value) FROM boxes WHERE CONTENTS  =  'Rocks'),"1. Sequential Structure: Start with the SELECT clause to retrieve the code of boxes. Use the FROM clause to specify the Boxes table. Apply a WHERE clause to filter boxes whose value is higher than the value of any box with ""Rocks"" as content. 2. Condition Structure: Use the WHERE clause with a subquery to compare the value of each box against the values of boxes containing ""Rocks"". The subquery retrieves the values of all boxes with ""Rocks"" as content. 3. Join Structure: Not required, as all data is within the Boxes table. 4. Aggregation Structure: Not needed, as we are comparing individual values without any aggregation.",0.0
1876,Show all meeting outcomes and purposes.,EASY,advertising_agencies,"[Meetings.meeting_outcome, Meetings.purpose_of_meeting]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.meeting_outcome, Meetings.purpose_of_meeting FROM Meetings;","SELECT meeting_outcome ,  purpose_of_meeting FROM meetings","1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""Meetings.meeting_outcome"" and ""Meetings.purpose_of_meeting"" as the question asks for all meeting outcomes and purposes. 2. Condition Structure: No specific filtering condition is required since the question asks for all records. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Meetings"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all records.",1.0
1877,find the number of authors who are older than 30 for each gender.,EASY,book_press,"[author.Age, author.Gender, author.Author_ID, author.Name, 30]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT author.Gender, COUNT(author.Author_ID) AS author_count FROM author WHERE author.Age > 30 GROUP BY author.Gender;","SELECT count(*) ,  gender FROM author WHERE age  >  30 GROUP BY gender","1. Sequential Structure: Begin with the SELECT clause to specify the gender and the count of authors for each gender. 2. Condition Structure: Use a WHERE clause to filter authors who are older than 30. 3. Grouping Structure: Use GROUP BY on ""author.Gender"" to count authors for each gender. 4. Aggregation Structure: Use COUNT to calculate the number of authors who meet the age condition for each gender. 5. Join Structure: No JOIN is required since all necessary data is within the ""author"" table.",1.0
1878,How many payments do we have?,EASY,advertising_agencies,[Payments.payment_id],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(Payments.payment_id) AS total_payments FROM Payments;,SELECT count(*) FROM Payments,"1. Sequential Structure: Start with the SELECT clause to count the number of payments. 2. Aggregation Structure: Use the COUNT function on the ""Payments.payment_id"" field to calculate the total number of payments. 3. Condition Structure: No specific filtering condition is required as we want the total count of all payments. 4. Join Structure: No JOIN is necessary since all required data is within the ""Payments"" table.",1.0
1879,Which planet has most shipments? List the planet name.,NON-NESTED,planet_1,"[Planet.Name, Shipment.Planet, Shipment.Planet = Planet.PlanetID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Planet.Name FROM Planet JOIN Shipment ON Shipment.Planet = Planet.PlanetID GROUP BY Planet.PlanetID ORDER BY COUNT(Shipment.Planet) DESC LIMIT 1;,SELECT T2.Name FROM Shipment AS T1 JOIN Planet AS T2 ON T1.Planet = T2.PlanetID GROUP BY T1.Planet ORDER BY count(*) DESC LIMIT 1;,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Planet.Name"" of the planet with the most shipments. Use COUNT to count the number of shipments for each planet. 2. Condition Structure: No specific filtering condition is required, as we are interested in all shipments. 3. Join Structure: Use a JOIN between the ""Planet"" and ""Shipment"" tables based on the relationship ""Shipment.Planet = Planet.PlanetID"" to associate shipments with their respective planets. 4. Aggregation Structure: Use COUNT to count the number of shipments for each planet, GROUP BY ""Planet.PlanetID"" to group the results by planet, and ORDER BY the count in descending order to find the planet with the most shipments. Use LIMIT 1 to return only the top result.",1.0
1880,What are the employees's names for those that have salaries between 5000 and 10000?,EASY,planet_1,"[Employee.Name, Employee.Salary]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Employee.Name FROM Employee WHERE Employee.Salary BETWEEN 5000 AND 10000;,SELECT Name FROM Employee WHERE Salary BETWEEN 5000 AND 10000,"1. Sequential Structure: Start with the SELECT clause to specify the employee names, as the question asks for the names of employees. 2. Condition Structure: Use a WHERE clause to filter employees whose salaries are between 5000 and 10000. 3. Join Structure: No JOIN is required since all necessary information is in the ""Employee"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving employee names based on a specific salary range.",1.0
1881,List the manger's name and number of shipments under his management.,NON-NESTED,planet_1,"[Employee.Name, Shipment.Manager, Shipment.ShipmentID, Shipment.Manager = Employee.EmployeeID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Employee.Name, COUNT(Shipment.ShipmentID) AS NumberOfShipments FROM Employee JOIN Shipment ON Shipment.Manager = Employee.EmployeeID GROUP BY Employee.Name;","SELECT T2.Name ,  count(*) FROM Shipment AS T1 JOIN Employee AS T2 ON T1.Manager = T2.EmployeeID GROUP BY T1.Manager;","1. Sequential Structure: Start with the SELECT clause to retrieve the manager's name and the count of shipments under their management. Use COUNT on ""Shipment.ShipmentID"" to count the number of shipments. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Employee"" and ""Shipment"" tables based on the relationship ""Shipment.Manager = Employee.EmployeeID"" to link each manager with their shipments. 4. Aggregation Structure: Use COUNT to aggregate the number of shipments for each manager and GROUP BY ""Employee.Name"" to group the results by manager.",1.0
1882,Who sent most number of packages? List client name and number of packages sent by that client.,NON-NESTED,planet_1,"[Client.Name, Package.Sender, Package.Sender = Client.AccountNumber]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Client.Name, COUNT(Package.Sender) AS NumberOfPackages FROM Client JOIN Package ON Package.Sender = Client.AccountNumber GROUP BY Client.Name ORDER BY NumberOfPackages DESC LIMIT 1;","SELECT T2.Name ,  count(*) FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber GROUP BY T1.Sender ORDER BY count(*) DESC LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Client.Name"" and the count of packages sent by each client. Use COUNT on ""Package.Sender"" to count the number of packages sent. 2. Condition Structure: No specific filtering condition is required, as we are interested in all clients. 3. Join Structure: Use a JOIN between the ""Client"" and ""Package"" tables based on ""Package.Sender = Client.AccountNumber"" to associate each package with the corresponding client. 4. Aggregation Structure: Use COUNT to calculate the number of packages sent by each client, GROUP BY ""Client.Name"" to group the results by client, and ORDER BY the count in descending order to find the client who sent the most packages. Use LIMIT 1 to get the top result.",0.0
1883,What are all the agency ids and details?,EASY,advertising_agencies,"[Agencies.agency_id, Agencies.agency_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, Agencies.agency_details FROM Agencies;","SELECT agency_id ,  agency_details FROM Agencies","1. Sequential Structure: Start with the SELECT clause to retrieve all fields from the ""Agencies"" table, as the question asks for all agency IDs and details. 2. Condition Structure: No specific filtering condition is required since the query aims to retrieve all records. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Agencies"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all records.",1.0
1884,Return the ids and details of clients who have attended a meeting or had an invoice.,NESTED,advertising_agencies,"[Clients.client_id,Clients.client_details,Meetings.client_id,Invoices.client_id,Meetings.client_id = Clients.client_id,Invoices.client_id = Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_id, Clients.client_details FROM Clients LEFT JOIN Meetings ON Meetings.client_id = Clients.client_id LEFT JOIN Invoices ON Invoices.client_id = Clients.client_id WHERE Meetings.client_id IS NOT NULL OR Invoices.client_id IS NOT NULL;","SELECT T1.client_id ,  T1.client_details FROM Clients AS T1 JOIN meetings AS T2 ON T1.client_id  =  T2.client_id UNION SELECT T1.client_id ,  T1.client_details FROM Clients AS T1 JOIN invoices AS T2 ON T1.client_id  =  T2.client_id","1. Sequential Structure: Start with the SELECT clause to retrieve the client IDs and details. Use the FROM clause to specify the Clients table. Use JOINs to connect the Clients table with the Meetings and Invoices tables. Apply a WHERE clause to filter clients who have attended a meeting or had an invoice. 2. Condition Structure: Use the WHERE clause to check for clients who are present in either the Meetings or Invoices tables by using conditions on the client_id field. 3. Join Structure: Use LEFT JOINs between the Clients table and the Meetings and Invoices tables based on the client_id field to ensure we capture all clients who meet the criteria. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1885,"List the start time, end time of each meeting, and the corresponding client detail and staff detail.",NON-NESTED,advertising_agencies,"[Meetings.start_date_time, Meetings.end_date_time, Meetings.client_id = Clients.client_id, Clients.client_details, Staff_in_Meetings.meeting_id = Meetings.meeting_id, Staff_in_Meetings.staff_id = Staff.staff_id, Staff.staff_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.start_date_time, Meetings.end_date_time, Clients.client_details, Staff.staff_details FROM Meetings JOIN Clients ON Meetings.client_id = Clients.client_id JOIN Staff_in_Meetings ON Staff_in_Meetings.meeting_id = Meetings.meeting_id JOIN Staff ON Staff_in_Meetings.staff_id = Staff.staff_id;","SELECT T1.start_date_time ,  T1.end_date_time ,  T2.client_details ,  T4.staff_details FROM meetings AS T1 JOIN clients AS T2 ON T1.client_id  =  T2.client_id JOIN staff_in_meetings AS T3 ON T1.meeting_id  =  T3.meeting_id JOIN staff AS T4 ON T3.staff_id  =  T4.staff_id","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Meetings.start_date_time,"" ""Meetings.end_date_time,"" ""Clients.client_details,"" and ""Staff.staff_details."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Meetings"" table with the ""Clients"" table on ""Meetings.client_id = Clients.client_id,"" and then connect the ""Meetings"" table with the ""Staff_in_Meetings"" table on ""Staff_in_Meetings.meeting_id = Meetings.meeting_id."" Finally, join the ""Staff_in_Meetings"" table with the ""Staff"" table on ""Staff_in_Meetings.staff_id = Staff.staff_id."" 4. Aggregation Structure: No aggregation is required as the query is retrieving detailed information for each meeting.",1.0
1886,What are the names of franchises that have two or more games?,NESTED,video_game,"[game.Franchise, game.Game_ID]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT Franchise FROM game GROUP BY Franchise HAVING COUNT(Game_ID) >= 2;,SELECT Franchise FROM game GROUP BY Franchise HAVING COUNT(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of franchises. Use the FROM clause to specify the game table. Apply a GROUP BY clause to group records by franchise, allowing us to count the number of games per franchise. Use the HAVING clause to filter franchises with two or more games. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for franchises that have two or more games. 3. Join Structure: Not required, as all data is available within the game table. 4. Aggregation Structure: Use COUNT(*) within HAVING to count the number of games per franchise and filter out franchises with fewer than two games.",1.0
1887,What are client ids for clients with at least 2 invoices.,NON-NESTED,advertising_agencies,"[Clients.client_id, Invoices.client_id, COUNT(Invoices.invoice_id) >= 2]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT Clients.client_id FROM Clients JOIN Invoices ON Clients.client_id = Invoices.client_id GROUP BY Clients.client_id HAVING COUNT(Invoices.invoice_id) >= 2;,SELECT client_id FROM Invoices GROUP BY client_id HAVING count(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Clients.client_id."" 2. Condition Structure: Use a HAVING clause to filter for clients with at least 2 invoices. This requires counting the number of ""Invoices.invoice_id"" for each client. 3. Join Structure: Use a JOIN between the ""Clients"" and ""Invoices"" tables based on ""client_id"" to associate each client with their invoices. 4. Aggregation Structure: Use COUNT on ""Invoices.invoice_id"" to count the number of invoices per client, then filter with HAVING to select clients with at least 2 invoices.",1.0
1888,Which employees do not have clearance in Mars? List employee's name.,NESTED,planet_1,"[Employee.Name,Has_Clearance.Employee,Has_Clearance.Planet,Planet.Name,Has_Clearance.Employee = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Mars]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Employee.Name FROM Employee WHERE Employee.EmployeeID NOT IN ( SELECT Has_Clearance.Employee FROM Has_Clearance JOIN Planet ON Has_Clearance.Planet = Planet.PlanetID WHERE Planet.Name = 'Mars' );,"SELECT Name FROM Employee EXCEPT SELECT T2.Name FROM Has_Clearance AS T1 JOIN Employee AS T2 ON T1.Employee = T2.EmployeeID JOIN Planet AS T3 ON T1.Planet = T3.PlanetID WHERE T3.Name = ""Mars"";","1. Sequential Structure: Start with the SELECT clause to retrieve the names of employees. Use the FROM clause to specify the Employee table. Apply a WHERE clause to filter employees who do not have clearance for Mars. 2. Condition Structure: Use the WHERE clause with a subquery to exclude employees whose EmployeeID appears in the Has_Clearance table for the planet Mars. The subquery identifies the PlanetID for Mars and matches it with the Has_Clearance table. 3. Join Structure: Use a JOIN between the Employee and Has_Clearance tables based on EmployeeID to relate employees with their clearance records. Additionally, use a JOIN between the Has_Clearance and Planet tables to identify the PlanetID for Mars. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1889,What are the names of all employees who don't have clearance on Mars?,NESTED,planet_1,"[Employee.Name,Has_Clearance.Employee,Has_Clearance.Planet,Planet.Name,Has_Clearance.Employee = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Mars]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Employee.Name FROM Employee WHERE Employee.EmployeeID NOT IN ( SELECT Has_Clearance.Employee FROM Has_Clearance JOIN Planet ON Has_Clearance.Planet = Planet.PlanetID WHERE Planet.Name = 'Mars' );,"SELECT Name FROM Employee EXCEPT SELECT T2.Name FROM Has_Clearance AS T1 JOIN Employee AS T2 ON T1.Employee = T2.EmployeeID JOIN Planet AS T3 ON T1.Planet = T3.PlanetID WHERE T3.Name = ""Mars"";","1. Sequential Structure: Start with the SELECT clause to retrieve the names of employees. Use the FROM clause to specify the Employee table. Use a WHERE clause to filter employees who do not have clearance on Mars. 2. Condition Structure: Use the WHERE clause with a subquery to exclude employees whose EmployeeID appears in the Has_Clearance table for the planet Mars. The subquery identifies the PlanetID for Mars and matches it with the Has_Clearance table. 3. Join Structure: Use an INNER JOIN between the Employee and Has_Clearance tables based on EmployeeID to link employees with their clearance records. Also, join the Has_Clearance table with the Planet table to identify the PlanetID for Mars. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1890,"Show all meeting ids, meeting outcomes, meeting types and the details of the client atttending it.",NON-NESTED,advertising_agencies,"[Meetings.meeting_id, Meetings.meeting_outcome, Meetings.meeting_type, Clients.client_details, Meetings.client_id = Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.meeting_id, Meetings.meeting_outcome, Meetings.meeting_type, Clients.client_details FROM Meetings JOIN Clients ON Meetings.client_id = Clients.client_id;","SELECT T1.meeting_id ,  T1.meeting_outcome ,  T1.meeting_type ,  T2.client_details FROM meetings AS T1 JOIN clients AS T2 ON T1.client_id  =  T2.client_id","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Meetings.meeting_id,"" ""Meetings.meeting_outcome,"" ""Meetings.meeting_type,"" and ""Clients.client_details."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Meetings"" and ""Clients"" tables based on the relationship ""Meetings.client_id = Clients.client_id"" to link each meeting with its respective client details. 4. Aggregation Structure: No aggregation is required as the query is retrieving detailed information without any summarization.",1.0
1891,What are the names of all players in alphabetical order?,EASY,video_game,[player.Player_name],"Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT player.Player_name FROM player ORDER BY player.Player_name ASC;,SELECT Player_name FROM player ORDER BY Player_name ASC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""player.Player_name"". 2. Condition Structure: No specific filtering condition is required as we want all player names. 3. Join Structure: No JOIN is required since all necessary data is within the ""player"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all player names. 5. Ordering Structure: Use ORDER BY to sort the player names in alphabetical order.",1.0
1892,What is the staff id of the staff who attended the least meetings but attended some meeting?,NESTED,advertising_agencies,"[Staff.staff_id, Staff_in_Meetings.staff_id, Staff_in_Meetings.meeting_id = Meetings.meeting_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT staff_id FROM Staff_in_Meetings GROUP BY staff_id HAVING COUNT(meeting_id) = (SELECT MIN(meeting_count) FROM (SELECT staff_id, COUNT(meeting_id) AS meeting_count FROM Staff_in_Meetings GROUP BY staff_id HAVING COUNT(meeting_id) > 0));","SELECT staff_id ,  count(*) FROM Staff_in_meetings GROUP BY staff_id ORDER BY count(*) ASC LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the staff_id of the staff member. Use the FROM clause to specify the Staff_in_Meetings table, which links staff to meetings. Use GROUP BY to group records by staff_id and COUNT to calculate the number of meetings attended by each staff member. Apply a HAVING clause to filter out staff who attended no meetings and to identify the staff member who attended the least number of meetings. 2. Condition Structure: Use the HAVING clause to ensure that only staff who attended at least one meeting are considered. Use a subquery to find the minimum count of meetings attended and filter for staff with that count. 3. Join Structure: Not required, as the relevant data for counting meetings attended is available in the Staff_in_Meetings table. 4. Aggregation Structure: Use COUNT to calculate the number of meetings attended by each staff member and MIN in a subquery to find the least number of meetings attended.",1.0
1893,List all process ids with no document.,NESTED,cre_Doc_Workflow,"[Business_Processes.process_id,Documents_Processes.process_id,Documents_Processes.document_id]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT process_id FROM Business_Processes WHERE process_id NOT IN (SELECT process_id FROM Documents_Processes WHERE document_id IS NOT NULL);,SELECT process_id FROM Business_processes EXCEPT SELECT process_id FROM Documents_processes,"1. Sequential Structure: Start with the SELECT clause to retrieve all process IDs. Use the FROM clause to specify the Business_Processes table. Apply a WHERE clause to filter for process IDs that do not have any associated document IDs in the Documents_Processes table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude process IDs that appear in the Documents_Processes table with a valid document_id. 3. Join Structure: Not required, as we only need to filter based on the absence of matching process_id entries in the Documents_Processes table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1894,"Show the distinct developer of games played by players that go to college ""Auburn"".",NON-NESTED,video_game,"[game.Developers,player.College,player.Player_ID = game_player.Player_ID,game_player.Game_ID = game.Game_ID,Auburn]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT DISTINCT game.Developers FROM player JOIN game_player ON player.Player_ID = game_player.Player_ID JOIN game ON game_player.Game_ID = game.Game_ID WHERE player.College = 'Auburn';,"SELECT DISTINCT T1.Developers FROM game AS T1 JOIN game_player AS T2 ON T1.Game_ID  =  T2.Game_ID JOIN player AS T3 ON T2.Player_ID  =  T3.Player_ID WHERE T3.College  =  ""Auburn""","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""game.Developers"" field, as we are interested in the unique developers of games. 2. Condition Structure: Use a WHERE clause to filter for players who attend the college ""Auburn."" 3. Join Structure: Use JOINs to connect the ""player"" table with the ""game_player"" table on ""player.Player_ID = game_player.Player_ID"" and the ""game_player"" table with the ""game"" table on ""game_player.Game_ID = game.Game_ID"" to link players with the games they play and the developers of those games. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique developers are returned.",1.0
1895,How many documents does has the author Era Kerluke written?,NON-NESTED,cre_Doc_Workflow,"[Documents.document_id,Documents.author_name,Documents.author_name = Authors.author_name,Era Kerluke]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT COUNT(Documents.document_id) FROM Documents WHERE Documents.author_name = 'Era Kerluke';,"SELECT count(*) FROM Documents WHERE author_name  =  ""Era Kerluke""","1. Sequential Structure: Start with the SELECT clause to count the number of documents written by the author. Use COUNT on ""Documents.document_id"" to get the total number of documents. 2. Condition Structure: Use a WHERE clause to filter for records where ""Documents.author_name"" matches the name ""Era Kerluke."" 3. Join Structure: No JOIN is required since the necessary information is available in the ""Documents"" table. 4. Aggregation Structure: Use COUNT to aggregate the total number of documents written by the specified author.",1.0
1896,What are the names of all employees who have a salary greater than average or more than 5000?,NESTED,planet_1,"[Employee.Name, Employee.Salary]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Name FROM Employee WHERE Salary > (SELECT AVG(Salary) FROM Employee) OR Salary > 5000;,SELECT Name FROM Employee WHERE Salary  >  5000 OR Salary  >  (SELECT avg(salary) FROM employee),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of employees. Use the FROM clause to specify the Employee table. Apply a WHERE clause to filter employees based on the condition that their salary is greater than the average salary or more than 5000. 2. Condition Structure: Use the WHERE clause with a logical OR condition. The first condition checks if the salary is greater than the average salary (calculated using a subquery), and the second condition checks if the salary is greater than 5000. 3. Join Structure: Not required, as all data is in the Employee table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average salary, which is then used in the filtering condition.",1.0
1897,find the name and gender of the author who published the most books.,NON-NESTED,book_press,"[author.Name, author.Gender, book.Author_ID, book.Book_ID, book.Author_ID = author.Author_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT author.Name, author.Gender FROM author JOIN book ON book.Author_ID = author.Author_ID GROUP BY author.Author_ID ORDER BY COUNT(book.Book_ID) DESC LIMIT 1;","SELECT t1.name ,  t1.gender FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id GROUP BY t2.author_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""author.Name"" and ""author.Gender."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in the author who published the most books. 3. Join Structure: Use a JOIN between the ""author"" and ""book"" tables based on the relationship ""book.Author_ID = author.Author_ID"" to associate books with their respective authors. 4. Aggregation Structure: Use COUNT on ""book.Book_ID"" to count the number of books published by each author. Use ORDER BY in descending order on the count to rank authors by the number of books published, and LIMIT 1 to select the author with the most books.",1.0
1898,List all player names in ascending alphabetical order.,EASY,video_game,[player.Player_name],"Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT player.Player_name FROM player ORDER BY player.Player_name ASC;,SELECT Player_name FROM player ORDER BY Player_name ASC,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is ""player.Player_name"". 2. Condition Structure: No specific filtering condition is required as we want all player names. 3. Join Structure: No JOIN is required since all necessary data is within the ""player"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the player names. 5. Ordering Structure: Use ORDER BY in ascending order to sort the player names alphabetically.",1.0
1899,How many authors are of age above 30 for each gender?,EASY,book_press,"[author.Age, author.Gender, author.Author_ID, 30]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT author.Gender, COUNT(author.Author_ID) AS author_count FROM author WHERE author.Age > 30 GROUP BY author.Gender;","SELECT count(*) ,  gender FROM author WHERE age  >  30 GROUP BY gender","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the gender and the count of authors. 2. Condition Structure: Apply a WHERE clause to filter authors with an age greater than 30. 3. Grouping Structure: Use GROUP BY on ""author.Gender"" to count authors by each gender. 4. Aggregation Structure: Use COUNT to calculate the number of authors for each gender that meet the age condition. 5. Join Structure: No JOIN is required since all needed data is within the ""author"" table.",1.0
1900,"What is the process name for the document ""Travel to Brazil""?",NON-NESTED,cre_Doc_Workflow,"[Documents.document_name, Documents.document_id, Documents_Processes.document_id = Documents.document_id, Documents_Processes.process_id, Business_Processes.process_id = Documents_Processes.process_id, Business_Processes.process_name]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT Business_Processes.process_name FROM Documents JOIN Documents_Processes ON Documents.document_id = Documents_Processes.document_id JOIN Business_Processes ON Documents_Processes.process_id = Business_Processes.process_id WHERE Documents.document_name = 'Travel to Brazil';,"SELECT T3.process_name FROM Documents_processes AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id JOIN Business_processes AS T3 ON T1.process_id  =  T3.process_id WHERE T2.document_name  =  ""Travel to Brazil""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Business_Processes.process_name"" for the document ""Travel to Brazil."" 2. Condition Structure: Use a WHERE clause to filter for the document with the name ""Travel to Brazil."" 3. Join Structure: Use JOINs to connect the ""Documents"" table with the ""Documents_Processes"" table on ""Documents.document_id"" and ""Documents_Processes.document_id,"" and then connect the ""Documents_Processes"" table with the ""Business_Processes"" table on ""Documents_Processes.process_id"" and ""Business_Processes.process_id."" 4. Aggregation Structure: No aggregation is needed as we are retrieving a single process name.",1.0
1901,What are the coordinates of the planet named Mars?,EASY,planet_1,"[Planet.Coordinates, Planet.Name]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Planet.Coordinates FROM Planet WHERE Planet.Name = 'Mars';,"SELECT Coordinates FROM Planet WHERE Name  =  ""Mars"";","1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the coordinates of the planet. 2. Condition Structure: Use a WHERE clause to filter for the planet with the name ""Mars"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Planet"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
1902,"For each gender, return gender and the average age of authors.",EASY,book_press,"[author.Gender, author.Age]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT author.Gender, AVG(author.Age) AS avg_age FROM author GROUP BY author.Gender;","SELECT avg(age) ,  gender FROM author GROUP BY gender","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the gender and the average age of authors. 2. Aggregation Structure: Use the AVG function to calculate the average age for each gender. 3. Grouping Structure: Use GROUP BY on ""author.Gender"" to calculate the average age for each gender. 4. Join Structure: No JOIN is required since all necessary data is within the ""author"" table.",1.0
1903,Who is the author of the document with id 4?,NON-NESTED,cre_Doc_Workflow,"[Documents.document_id, Documents.author_name, Authors.author_name = Documents.author_name, 4]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT Documents.author_name FROM Documents WHERE Documents.document_id = 4;,SELECT author_name FROM Documents WHERE document_id  =  4,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Documents.author_name"" field, as the question asks for the author of a specific document. 2. Condition Structure: Use a WHERE clause to filter for the document with ""Documents.document_id"" equal to 4. 3. Join Structure: No JOIN is necessary, as the required information is available within the ""Documents"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving a single author's name for a specific document.",1.0
1904,Return the average number of units sold in millions for games not developed by Nintendo.,NESTED,video_game,"[game.Units_sold_Millions, game.Developers]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT AVG(Units_sold_Millions) AS average_units_sold FROM game WHERE Developers != 'Nintendo';,SELECT avg(Units_sold_Millions) FROM game WHERE developers != 'Nintendo',"1. Sequential Structure: Start with the SELECT clause to calculate the average number of units sold in millions. Use the FROM clause to specify the game table. Apply a WHERE clause to filter out games developed by Nintendo. 2. Condition Structure: Use the WHERE clause to exclude games where the developer is 'Nintendo'. 3. Join Structure: Not required, as all data is available within the game table. 4. Aggregation Structure: Use the AVG function to calculate the average number of units sold in millions for the filtered games.",1.0
1905,"Show all client ids and details with sic code ""Bad"".",EASY,advertising_agencies,"[Clients.client_id, Clients.client_details, Clients.sic_code, ""Bad""]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_id, Clients.client_details FROM Clients WHERE Clients.sic_code = 'Bad';","SELECT client_id ,  client_details FROM Clients WHERE sic_code  =  ""Bad"";","1. Sequential Structure: Start with the SELECT clause to retrieve all client IDs and their details from the ""Clients"" table. 2. Condition Structure: Use a WHERE clause to filter records where the ""Clients.sic_code"" is equal to ""Bad"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Clients"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
1906,Who wrote the best selling book? Give me the author name.,NON-NESTED,book_press,"[book.Sale_Amount, book.Author_ID = author.Author_ID, author.Name]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT author.Name FROM book JOIN author ON book.Author_ID = author.Author_ID WHERE book.Sale_Amount = (SELECT MAX(book.Sale_Amount) FROM book);,SELECT t1.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id ORDER BY t2.sale_amount DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""author.Name"" of the author who wrote the best-selling book. Use an aggregation function (MAX) on ""book.Sale_Amount"" to identify the highest sales amount. 2. Condition Structure: Use a WHERE clause to filter the book with the maximum sales amount. 3. Join Structure: Use a JOIN between the ""book"" and ""author"" tables based on the ""Author_ID"" field to link each book with its respective author. 4. Aggregation Structure: Use MAX on ""book.Sale_Amount"" to find the highest sales amount and filter the corresponding author.",1.0
1907,List all client ids and client details.,EASY,advertising_agencies,"[Clients.client_id, Clients.client_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_id, Clients.client_details FROM Clients;","SELECT client_id ,  client_details FROM Clients","1. Sequential Structure: Start with the SELECT clause to retrieve all client IDs and client details. 2. Condition Structure: No specific filtering condition is required as the query asks for all client IDs and details. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""Clients"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all records from the table.",1.0
1908,What is the description for process status code ct?,EASY,cre_Doc_Workflow,"[Process_Status.process_status_description,Process_Status.process_status_code,ct]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT Process_Status.process_status_description FROM Process_Status WHERE Process_Status.process_status_code = 'ct';,"SELECT process_status_description FROM Process_status WHERE process_status_code  =  ""ct""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""process_status_description"" field, as the question asks for the description of a specific process status code. 2. Condition Structure: Use a WHERE clause to filter for the specific ""process_status_code"" equal to 'ct'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Process_Status"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving a single field based on a specific condition.",1.0
1909,What is the heaviest package sent by the clients which 'John' is part of their name? List package number and weight.,NON-NESTED,planet_1,"[Package.PackageNumber, Package.Weight, Package.Sender, Client.Name, Package.Sender = Client.AccountNumber, 'John']","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Package.PackageNumber, Package.Weight FROM Package JOIN Client ON Package.Sender = Client.AccountNumber WHERE Client.Name LIKE '%John%' ORDER BY Package.Weight DESC LIMIT 1;","SELECT T1.PackageNumber ,  max(T1.Weight) FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name LIKE ""John"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Package.PackageNumber"" and ""Package.Weight"" of the heaviest package. Use ORDER BY in descending order on ""Package.Weight"" to rank packages by weight and LIMIT 1 to select the heaviest package. 2. Condition Structure: Use a WHERE clause to filter for clients whose name contains 'John.' This involves filtering ""Client.Name"" with a condition using the LIKE operator. 3. Join Structure: Use a JOIN between the ""Package"" and ""Client"" tables based on the relationship ""Package.Sender = Client.AccountNumber"" to associate packages with their senders. 4. Aggregation Structure: No aggregation is needed since we are only retrieving the heaviest package.",0.0
1910,What are the ids of all shipments on the planet Mars that are managed by Turanga Leela?,NON-NESTED,planet_1,"[Shipment.ShipmentID,Shipment.Planet,Shipment.Manager,Planet.Name,Planet.PlanetID = Shipment.Planet,Employee.Name,Employee.EmployeeID = Shipment.Manager]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Shipment.ShipmentID FROM Shipment JOIN Planet ON Planet.PlanetID = Shipment.Planet JOIN Employee ON Employee.EmployeeID = Shipment.Manager WHERE Planet.Name = 'Mars' AND Employee.Name = 'Turanga Leela';,"SELECT T1.ShipmentID FROM Shipment AS T1 JOIN Planet AS T2 ON T1.Planet = T2.PlanetID JOIN Employee AS T3 ON T3.EmployeeID = T1.Manager WHERE T2.Name = ""Mars"" AND T3.Name = ""Turanga Leela"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Shipment.ShipmentID"" as the question asks for the IDs of shipments. 2. Condition Structure: Use a WHERE clause to filter for shipments where the planet is ""Mars"" and the manager is ""Turanga Leela."" 3. Join Structure: Use JOINs to connect the ""Shipment"" table with the ""Planet"" table on ""Planet.PlanetID = Shipment.Planet"" to get the planet name, and with the ""Employee"" table on ""Employee.EmployeeID = Shipment.Manager"" to get the manager's name. 4. Aggregation Structure: No aggregation is needed as the query is focused on filtering and retrieving specific shipment IDs.",1.0
1911,What are the different developers of games that are played by players that attend Auburn college?,NON-NESTED,video_game,"[game.Developers,player.College,player.Player_ID = game_player.Player_ID,game_player.Game_ID = game.Game_ID,Auburn]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT DISTINCT game.Developers FROM player JOIN game_player ON player.Player_ID = game_player.Player_ID JOIN game ON game_player.Game_ID = game.Game_ID WHERE player.College = 'Auburn';,"SELECT DISTINCT T1.Developers FROM game AS T1 JOIN game_player AS T2 ON T1.Game_ID  =  T2.Game_ID JOIN player AS T3 ON T2.Player_ID  =  T3.Player_ID WHERE T3.College  =  ""Auburn""","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""game.Developers"" since we are interested in the different developers of games. 2. Condition Structure: Use a WHERE clause to filter for players who attend ""Auburn"" college. 3. Join Structure: Use JOINs to connect the ""player"" table with the ""game_player"" table on ""player.Player_ID = game_player.Player_ID"" and the ""game_player"" table with the ""game"" table on ""game_player.Game_ID = game.Game_ID"" to link players with the games they play and their developers. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique developers are returned.",1.0
1912,Which press has the largest monthly profit? Give me the press name.,EASY,book_press,"[press.Name, press.Month_Profits_billion]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT press.Name FROM press ORDER BY press.Month_Profits_billion DESC LIMIT 1;,SELECT name FROM press ORDER BY Month_Profits_billion DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""press.Name"" of the press with the largest monthly profit. 2. Condition Structure: No specific filtering condition is required since we are looking for the press with the highest monthly profit. 3. Join Structure: No JOIN is necessary as all the required information is available in the ""press"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""press.Month_Profits_billion"" to rank presses by their monthly profits. Apply LIMIT 1 to select the press with the largest monthly profit.",1.0
1913,What are the dates of every shipment in the database?,EASY,planet_1,[Shipment.Date],"Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Shipment.Date FROM Shipment;,SELECT Date FROM Shipment;,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""Shipment.Date"". 2. Condition Structure: No specific filtering condition is required as the query asks for all shipment dates. 3. Join Structure: No JOIN is required since all necessary information is within the ""Shipment"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all shipment dates.",1.0
1914,List all meeting type codes and details.,EASY,advertising_agencies,"[Meetings.meeting_type, Meetings.other_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.meeting_type, Meetings.other_details FROM Meetings;","SELECT meeting_type ,  other_details FROM meetings","1. Sequential Structure: Start with the SELECT clause to retrieve all meeting type codes and their corresponding details. 2. Condition Structure: No specific filtering condition is required as the query asks for all meeting type codes and details. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""Meetings"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all records from the specified columns.",1.0
1915,List the client id and detail with most number of invoices.,NON-NESTED,advertising_agencies,"[Clients.client_id, Clients.client_details, Invoices.client_id, COUNT(Invoices.invoice_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_id, Clients.client_details FROM Clients JOIN Invoices ON Clients.client_id = Invoices.client_id GROUP BY Clients.client_id, Clients.client_details ORDER BY COUNT(Invoices.invoice_id) DESC LIMIT 1;","SELECT T1.client_id ,  T2.client_details FROM Invoices AS T1 JOIN Clients AS T2 ON T1.client_id  =  T2.client_id GROUP BY T1.client_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""Clients.client_id"" and ""Clients.client_details."" Use COUNT on ""Invoices.invoice_id"" to count the number of invoices for each client. 2. Condition Structure: Use ORDER BY in descending order on the count of invoices to rank clients by the number of invoices. Use LIMIT 1 to select the client with the most invoices. 3. Join Structure: Use an INNER JOIN between the ""Clients"" and ""Invoices"" tables on ""Clients.client_id = Invoices.client_id"" to associate each client with their invoices. 4. Aggregation Structure: Use COUNT on ""Invoices.invoice_id"" to count the number of invoices per client, then GROUP BY ""Clients.client_id"" and ""Clients.client_details"" to group results by each client.",1.0
1916,"What are the start and end times of each meeting, as well as the corresponding client and staff details the attendees?",NON-NESTED,advertising_agencies,"[Meetings.start_date_time, Meetings.end_date_time, Meetings.client_id = Clients.client_id, Clients.client_details, Staff_in_Meetings.meeting_id = Meetings.meeting_id, Staff_in_Meetings.staff_id = Staff.staff_id, Staff.staff_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.start_date_time, Meetings.end_date_time, Clients.client_details, Staff.staff_details FROM Meetings JOIN Clients ON Meetings.client_id = Clients.client_id JOIN Staff_in_Meetings ON Staff_in_Meetings.meeting_id = Meetings.meeting_id JOIN Staff ON Staff_in_Meetings.staff_id = Staff.staff_id;","SELECT T1.start_date_time ,  T1.end_date_time ,  T2.client_details ,  T4.staff_details FROM meetings AS T1 JOIN clients AS T2 ON T1.client_id  =  T2.client_id JOIN staff_in_meetings AS T3 ON T1.meeting_id  =  T3.meeting_id JOIN staff AS T4 ON T3.staff_id  =  T4.staff_id","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Meetings.start_date_time,"" ""Meetings.end_date_time,"" ""Clients.client_details,"" and ""Staff.staff_details."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Meetings"" table with the ""Clients"" table on ""Meetings.client_id = Clients.client_id,"" and then connect the ""Meetings"" table with the ""Staff_in_Meetings"" table on ""Staff_in_Meetings.meeting_id = Meetings.meeting_id."" Finally, join the ""Staff_in_Meetings"" table with the ""Staff"" table on ""Staff_in_Meetings.staff_id = Staff.staff_id"" to retrieve the staff details. 4. Aggregation Structure: No aggregation is required as the query is retrieving detailed information for each meeting.",1.0
1917,"Find the press that published more than two books, and return its name and yearly profit in billion.",NON-NESTED,book_press,"[press.Name, press.Year_Profits_billion, book.Press_ID, book.Book_ID, book.Press_ID = press.Press_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT press.Name, press.Year_Profits_billion FROM press JOIN book ON press.Press_ID = book.Press_ID GROUP BY press.Press_ID HAVING COUNT(book.Book_ID) > 2;","SELECT t2.name ,  t2.Year_Profits_billion FROM book AS t1 JOIN press AS t2 ON t1.press_id  =  t2.press_id GROUP BY t2.press_id HAVING count(*)  >  2","1. Sequential Structure: Start with the SELECT clause to retrieve the ""press.Name"" and ""press.Year_Profits_billion."" 2. Condition Structure: Use a HAVING clause to filter presses that have published more than two books. This requires counting the number of books associated with each press. 3. Join Structure: Use a JOIN between the ""press"" and ""book"" tables based on the ""Press_ID"" field to associate each press with its published books. 4. Aggregation Structure: Use COUNT on ""book.Book_ID"" to count the number of books published by each press, then filter with HAVING to select presses with more than two books.",1.0
1918,Who wrote the largest number of books? Give me the author name and gender.,NON-NESTED,book_press,"[author.Name, author.Gender, book.Author_ID, book.Author_ID = author.Author_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT author.Name, author.Gender FROM author JOIN book ON book.Author_ID = author.Author_ID GROUP BY author.Author_ID ORDER BY COUNT(book.Author_ID) DESC LIMIT 1;","SELECT t1.name ,  t1.gender FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id GROUP BY t2.author_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""author.Name"" and ""author.Gender."" Additionally, count the number of books written by each author using COUNT on ""book.Author_ID."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the author with the largest number of books. 3. Join Structure: Use a JOIN between the ""author"" and ""book"" tables based on the ""Author_ID"" field to associate each book with its respective author. 4. Aggregation Structure: Use COUNT to count the number of books per author, GROUP BY ""author.Author_ID"" to group the results by author, and ORDER BY the count in descending order to rank authors by the number of books written. Use LIMIT 1 to select the author with the largest number of books.",1.0
1919,Find the names of authors who have more than one book in the database.,NON-NESTED,book_press,"[author.Name, book.Author_ID, book.Title, book.Author_ID = author.Author_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT author.Name FROM author JOIN book ON book.Author_ID = author.Author_ID GROUP BY author.Author_ID HAVING COUNT(book.Title) > 1;,SELECT t1.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id GROUP BY t2.author_id HAVING count(*)  >  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""author.Name."" 2. Condition Structure: Use a HAVING clause to filter authors who have more than one book. This requires counting the number of books associated with each author. 3. Join Structure: Use a JOIN between the ""author"" and ""book"" tables based on ""book.Author_ID = author.Author_ID"" to associate each book with its respective author. 4. Aggregation Structure: Use COUNT on ""book.Title"" to count the number of books per author, then filter with HAVING to select authors with more than one book.",1.0
1920,What is the package number and weight of the 3 lightest packages?,EASY,planet_1,"[Package.PackageNumber, Package.Weight]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Package.PackageNumber, Package.Weight FROM Package ORDER BY Package.Weight ASC LIMIT 3;","SELECT PackageNumber ,  Weight FROM PACKAGE ORDER BY Weight ASC LIMIT 3;","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are ""Package.PackageNumber"" and ""Package.Weight"". 2. Condition Structure: No specific filtering condition is required as we are retrieving all packages. 3. Ordering Structure: Use ORDER BY on ""Package.Weight"" in ascending order to rank packages by their weight. 4. Limiting Structure: Use LIMIT 3 to retrieve only the 3 lightest packages. 5. Join Structure: No JOIN is required since all necessary data is within the ""Package"" table.",1.0
1921,Find the number of employees who do not have clearance in Mars .,NESTED,planet_1,"[Employee.EmployeeID,Has_Clearance.Employee,Has_Clearance.Planet,Planet.Name,Has_Clearance.Planet = Planet.PlanetID,Mars]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT COUNT(Employee.EmployeeID) FROM Employee WHERE Employee.EmployeeID NOT IN ( SELECT Has_Clearance.Employee FROM Has_Clearance JOIN Planet ON Has_Clearance.Planet = Planet.PlanetID WHERE Planet.Name = 'Mars' );,"select count(*) from employee where employeeid not in ( select t2.employeeid from has_clearance as t1 join employee as t2 on t1.employee = t2.employeeid join planet as t3 on t1.planet = t3.planetid where t3.name = ""mars"" );",1. Sequential Structure: Start with the SELECT clause to count the number of employees. Use the FROM clause to specify the Employee table. Apply a WHERE clause to filter employees who do not have clearance for Mars. 2. Condition Structure: Use a WHERE clause with a subquery to exclude employees whose EmployeeID appears in the Has_Clearance table for the planet Mars. The subquery identifies the PlanetID corresponding to Mars. 3. Join Structure: Use a subquery to link the Planet table with the Has_Clearance table to identify the PlanetID for Mars. 4. Aggregation Structure: Use COUNT to calculate the total number of employees who do not have clearance for Mars.,0.0
1922,Calculate total weight of package shipped in each planet . show the name of each planet .,NON-NESTED,planet_1,"[Planet.Name, Package.Weight, Package.Shipment = Shipment.ShipmentID, Shipment.Planet = Planet.PlanetID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Planet.Name, SUM(Package.Weight) AS TotalWeight FROM Package JOIN Shipment ON Package.Shipment = Shipment.ShipmentID JOIN Planet ON Shipment.Planet = Planet.PlanetID GROUP BY Planet.Name;","select t3.name ,  sum(t1.weight) from package as t1 join shipment as t2 on t1.shipment = t2.shipmentid join planet as t3 on t2.planet = t3.planetid group by t2.planet;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Planet.Name"" and the total weight of packages shipped to each planet. Use the SUM function to calculate the total weight. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Package"" table with the ""Shipment"" table on ""Package.Shipment = Shipment.ShipmentID"" and the ""Shipment"" table with the ""Planet"" table on ""Shipment.Planet = Planet.PlanetID"" to link packages with their respective planets. 4. Aggregation Structure: Use SUM to calculate the total weight of packages for each planet and GROUP BY ""Planet.Name"" to group the results by planet.",1.0
1923,How many meetings are there for each meeting type?,EASY,advertising_agencies,"[Meetings.meeting_type, Meetings.meeting_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.meeting_type, COUNT(Meetings.meeting_id) AS meeting_count FROM Meetings GROUP BY Meetings.meeting_type;","SELECT meeting_type ,  count(*) FROM Meetings GROUP BY meeting_type","1. Sequential Structure: Begin with the SELECT clause to specify the meeting type and the count of meetings for each type. 2. Aggregation Structure: Use COUNT to calculate the number of meetings for each meeting type. 3. Grouping Structure: Use GROUP BY on ""Meetings.meeting_type"" to aggregate the results by each meeting type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Meetings"" table.",1.0
1924,"What are the names and ranks of players who have played the game with the title ""Super Mario World""?",NON-NESTED,video_game,"[player.Player_name,player.Rank_of_the_year,game.Title,game.Game_ID = game_player.Game_ID,game_player.Player_ID = player.Player_ID,Super Mario World]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT player.Player_name, player.Rank_of_the_year FROM game JOIN game_player ON game.Game_ID = game_player.Game_ID JOIN player ON game_player.Player_ID = player.Player_ID WHERE game.Title = 'Super Mario World';","SELECT T3.Player_name ,  T3.rank_of_the_year FROM game AS T1 JOIN game_player AS T2 ON T1.Game_ID  =  T2.Game_ID JOIN player AS T3 ON T2.Player_ID  =  T3.Player_ID WHERE T1.Title  =  ""Super Mario World""","1. Sequential Structure: Start with the SELECT clause to retrieve ""player.Player_name"" and ""player.Rank_of_the_year."" 2. Condition Structure: Use a WHERE clause to filter for records where the ""game.Title"" is ""Super Mario World."" 3. Join Structure: Use JOINs to connect the ""game"" table with the ""game_player"" table on ""game.Game_ID"" and then connect the ""game_player"" table with the ""player"" table on ""game_player.Player_ID"" to link players with the specific game. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific player details for a given game.",1.0
1925,What are the titles of games not played by any players who play the Guard position?,NESTED,video_game,"[game.Title,player.Position,game_player.Player_ID = player.Player_ID,game_player.Game_ID = game.Game_ID,Guard]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT game.Title FROM game WHERE game.Game_ID NOT IN ( SELECT game_player.Game_ID FROM game_player JOIN player ON game_player.Player_ID = player.Player_ID WHERE player.Position = 'Guard' );,"SELECT Title FROM game EXCEPT SELECT T1.Title FROM game AS T1 JOIN game_player AS T2 ON T1.Game_ID  =  T2.Game_ID JOIN player AS T3 ON T2.Player_ID  =  T3.Player_ID WHERE T3.Position  =  ""Guard""","1. Sequential Structure: Start with the SELECT clause to retrieve the titles of games. Use the FROM clause to specify the game table. Apply a WHERE clause to filter games that are not played by any players who play the Guard position. 2. Condition Structure: Use the WHERE clause with a subquery to exclude games that are associated with players who play the Guard position. The subquery identifies all Game_IDs linked to players with the position 'Guard'. 3. Join Structure: Use JOINs between the game_player, player, and game tables to connect game titles with player positions. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1926,What are the names of all employees with clearance on Omega III?,NON-NESTED,planet_1,"[Employee.Name,Has_Clearance.Employee,Has_Clearance.Planet,Planet.Name,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Omega III]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Employee.Name FROM Has_Clearance JOIN Employee ON Has_Clearance.Employee = Employee.EmployeeID JOIN Planet ON Has_Clearance.Planet = Planet.PlanetID WHERE Planet.Name = 'Omega III';,"SELECT T2.Name FROM Has_Clearance AS T1 JOIN Employee AS T2 ON T1.Employee = T2.EmployeeID JOIN Planet AS T3 ON T1.Planet = T3.PlanetID WHERE T3.Name  =  ""Omega III"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Employee.Name"" field, as the question asks for the names of employees. 2. Condition Structure: Use a WHERE clause to filter for records where the planet name is ""Omega III."" 3. Join Structure: Use JOINs to connect the ""Has_Clearance"" table with the ""Employee"" table on ""Has_Clearance.Employee = Employee.EmployeeID"" and the ""Planet"" table on ""Has_Clearance.Planet = Planet.PlanetID"" to link employees with their clearance and the corresponding planet. 4. Aggregation Structure: No aggregation is needed, as the query only retrieves employee names.",1.0
1927,"Which authors have never published under the ""Accor"" press? Give me their names.",NESTED,book_press,"[author.Name,book.Press_ID,press.Press_ID,book.Author_ID = author.Author_ID,book.Press_ID = press.Press_ID,press.Name,Accor]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT author.Name FROM author WHERE author.Author_ID NOT IN ( SELECT book.Author_ID FROM book JOIN press ON book.Press_ID = press.Press_ID WHERE press.Name = 'Accor' );,SELECT name FROM author EXCEPT SELECT t1.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id JOIN press AS t3 ON t2.press_id  =  t3.press_id WHERE t3.name  =  'Accor',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors. Use the FROM clause to specify the author table. Apply a WHERE clause to filter authors who have never published under the ""Accor"" press by ensuring their Author_ID is not associated with any book published by the ""Accor"" press. 2. Condition Structure: Use the WHERE clause with a subquery to exclude authors whose Author_ID is linked to books published by the ""Accor"" press. The subquery identifies the Press_ID for ""Accor"" and checks for authors associated with it. 3. Join Structure: Use JOINs between the author, book, and press tables to connect authors with their books and the press under which the books were published. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1928,List the codes and descriptions for all process status.,EASY,cre_Doc_Workflow,"[Process_Status.process_status_code, Process_Status.process_status_description]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Process_Status.process_status_code, Process_Status.process_status_description FROM Process_Status;","SELECT process_status_code ,  process_status_description FROM Process_status","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""process_status_code"" and ""process_status_description"". 2. Condition Structure: No specific filtering condition is required as the query asks for all process statuses. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Process_Status"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all rows from the table.",1.0
1929,What is the agency id and details with most number of clients?,NON-NESTED,advertising_agencies,"[Agencies.agency_id, Agencies.agency_details, Clients.agency_id, Clients.client_id, Clients.agency_id = Agencies.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, Agencies.agency_details FROM Agencies JOIN Clients ON Clients.agency_id = Agencies.agency_id GROUP BY Agencies.agency_id, Agencies.agency_details ORDER BY COUNT(Clients.client_id) DESC LIMIT 1;","SELECT T1.agency_id ,  T1.agency_details FROM Agencies AS T1 JOIN Clients AS T2 ON T1.agency_id  =  T2.agency_id GROUP BY T1.agency_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""Agencies.agency_id"" and ""Agencies.agency_details."" Additionally, count the number of clients for each agency using COUNT on ""Clients.client_id."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the agency with the most clients. 3. Join Structure: Use an INNER JOIN between the ""Agencies"" and ""Clients"" tables based on the relationship ""Clients.agency_id = Agencies.agency_id"" to associate clients with their respective agencies. 4. Aggregation Structure: Use COUNT to calculate the number of clients per agency, GROUP BY ""Agencies.agency_id"" to group results by agency, and ORDER BY the count in descending order to rank agencies by the number of clients. Use LIMIT 1 to select the agency with the most clients.",1.0
1930,"Return the invoice ids, statuses, and details for invoices with the most payments?",NESTED,advertising_agencies,"[Invoices.invoice_id, Invoices.invoice_status, Invoices.invoice_details, Payments.invoice_id = Invoices.invoice_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.invoice_id, Invoices.invoice_status, Invoices.invoice_details FROM Invoices JOIN Payments ON Payments.invoice_id = Invoices.invoice_id GROUP BY Invoices.invoice_id, Invoices.invoice_status, Invoices.invoice_details HAVING COUNT(Payments.invoice_id) = ( SELECT MAX(payment_count) FROM ( SELECT COUNT(Payments.invoice_id) AS payment_count FROM Payments GROUP BY Payments.invoice_id ) AS subquery );","SELECT T1.invoice_id ,  T2.invoice_status ,  T2.invoice_details FROM Payments AS T1 JOIN Invoices AS T2 ON T1.invoice_id  =  T2.invoice_id GROUP BY T1.invoice_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the invoice IDs, statuses, and details. Use the FROM clause to specify the Invoices table and JOIN it with the Payments table to relate invoices with their payments. Use GROUP BY to group records by invoice_id, allowing us to count the number of payments for each invoice. Apply a HAVING clause to filter for invoices with the maximum number of payments. 2. Condition Structure: Use the HAVING clause with COUNT to filter for invoices that have the maximum number of payments. 3. Join Structure: Use an INNER JOIN between the Invoices and Payments tables based on invoice_id to connect invoices with their payments. 4. Aggregation Structure: Use COUNT to calculate the number of payments for each invoice and MAX to identify the maximum number of payments.",1.0
1931,Which book series contain both books with sale amount above 1000 and books with sale amount below 500?,NESTED,book_press,"[book.Book_Series, book.Sale_Amount]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT book.Book_Series FROM book GROUP BY book.Book_Series HAVING COUNT(CASE WHEN book.Sale_Amount > 1000 THEN 1 END) > 0 AND COUNT(CASE WHEN book.Sale_Amount < 500 THEN 1 END) > 0;,SELECT book_series FROM book WHERE sale_amount  >  1000 INTERSECT SELECT book_series FROM book WHERE sale_amount  <  500,"1. Sequential Structure: Start with the SELECT clause to retrieve the book series. Use the FROM clause to specify the book table. Apply a GROUP BY clause to group records by book series. Use the HAVING clause to filter for book series that contain both books with sale amounts above 1000 and books with sale amounts below 500. 2. Condition Structure: Use the HAVING clause with conditional aggregation to ensure that the book series has at least one book with a sale amount above 1000 and at least one book with a sale amount below 500. 3. Join Structure: Not required, as all data is available within the book table. 4. Aggregation Structure: Use conditional aggregation with COUNT to check for the existence of books meeting the specified sale amount conditions within each book series.",1.0
1932,Return the agency id and details for the agency with the greatest number of clients.,NON-NESTED,advertising_agencies,"[Agencies.agency_id, Agencies.agency_details, Clients.agency_id, Clients.client_id, Clients.agency_id = Agencies.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, Agencies.agency_details FROM Agencies JOIN Clients ON Clients.agency_id = Agencies.agency_id GROUP BY Agencies.agency_id, Agencies.agency_details ORDER BY COUNT(Clients.client_id) DESC LIMIT 1;","SELECT T1.agency_id ,  T1.agency_details FROM Agencies AS T1 JOIN Clients AS T2 ON T1.agency_id  =  T2.agency_id GROUP BY T1.agency_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""Agencies.agency_id"" and ""Agencies.agency_details."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the agency with the greatest number of clients. 3. Join Structure: Use a JOIN between the ""Agencies"" and ""Clients"" tables based on ""Clients.agency_id = Agencies.agency_id"" to associate each agency with its clients. 4. Aggregation Structure: Use COUNT on ""Clients.client_id"" to count the number of clients per agency. Use ORDER BY in descending order on the count to rank agencies by the number of clients, and LIMIT 1 to select the agency with the greatest number of clients.",1.0
1933,Show all staff role codes and the number of document processes for each role.,NON-NESTED,cre_Doc_Workflow,"[Staff_in_Processes.staff_role_code, Staff_in_Processes.document_id, Documents_Processes.document_id = Staff_in_Processes.document_id, Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Staff_in_Processes.staff_role_code, COUNT(Staff_in_Processes.document_id) AS num_document_processes FROM Staff_in_Processes JOIN Documents_Processes ON Staff_in_Processes.document_id = Documents_Processes.document_id JOIN Ref_Staff_Roles ON Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code GROUP BY Staff_in_Processes.staff_role_code;","SELECT staff_role_code ,  count(*) FROM Staff_in_processes GROUP BY staff_role_code","1. Sequential Structure: Start with the SELECT clause to retrieve ""Staff_in_Processes.staff_role_code"" and the count of ""Staff_in_Processes.document_id"" for each role. Use COUNT to calculate the number of document processes for each role. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between ""Staff_in_Processes"" and ""Documents_Processes"" on ""document_id"" to link staff roles with document processes. Additionally, join ""Staff_in_Processes"" with ""Ref_Staff_Roles"" on ""staff_role_code"" to ensure valid role codes are included. 4. Aggregation Structure: Use COUNT to aggregate the number of document processes for each role and GROUP BY ""Staff_in_Processes.staff_role_code"" to group the results by role code.",1.0
1934,"What is the invoice id, status code, and details for the invoice with most number of payments.",NON-NESTED,advertising_agencies,"[Invoices.invoice_id,Invoices.invoice_status,Invoices.invoice_details,Payments.invoice_id = Invoices.invoice_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.invoice_id, Invoices.invoice_status, Invoices.invoice_details FROM Invoices JOIN Payments ON Payments.invoice_id = Invoices.invoice_id GROUP BY Invoices.invoice_id, Invoices.invoice_status, Invoices.invoice_details ORDER BY COUNT(Payments.invoice_id) DESC LIMIT 1;","SELECT T1.invoice_id ,  T2.invoice_status ,  T2.invoice_details FROM Payments AS T1 JOIN Invoices AS T2 ON T1.invoice_id  =  T2.invoice_id GROUP BY T1.invoice_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""Invoices.invoice_id,"" ""Invoices.invoice_status,"" and ""Invoices.invoice_details."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in the invoice with the most number of payments. 3. Join Structure: Use a JOIN between the ""Invoices"" and ""Payments"" tables based on ""Payments.invoice_id = Invoices.invoice_id"" to link each invoice with its payments. 4. Aggregation Structure: Use COUNT on ""Payments.invoice_id"" to count the number of payments for each invoice. Use ORDER BY in descending order to rank invoices by the number of payments, and LIMIT 1 to select the invoice with the most payments.",1.0
1935,Show all distinct franchises of games.,EASY,video_game,[game.Franchise],"Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT DISTINCT game.Franchise FROM game;,SELECT DISTINCT Franchise FROM game,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct franchises of games. 2. Condition Structure: No specific filtering condition is required as we want all distinct franchises. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""game"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct values.",1.0
1936,List all shipment ids on the planet Mars or under the management of Turanga Leela.,NON-NESTED,planet_1,"[Shipment.ShipmentID,Planet.Name,Shipment.Planet = Planet.PlanetID,Employee.Name,Shipment.Manager = Employee.EmployeeID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Shipment.ShipmentID FROM Shipment JOIN Planet ON Shipment.Planet = Planet.PlanetID JOIN Employee ON Shipment.Manager = Employee.EmployeeID WHERE Planet.Name = 'Mars' OR Employee.Name = 'Turanga Leela';,"SELECT T1.ShipmentID FROM Shipment AS T1 JOIN Planet AS T2 ON T1.Planet = T2.PlanetID JOIN Employee AS T3 ON T3.EmployeeID = T1.Manager WHERE T2.Name = ""Mars"" OR T3.Name = ""Turanga Leela"";","1. Sequential Structure: Start with the SELECT clause to retrieve ""Shipment.ShipmentID."" 2. Condition Structure: Use a WHERE clause to filter shipments that are either on the planet Mars or managed by Turanga Leela. This requires filtering based on ""Planet.Name"" being 'Mars' or ""Employee.Name"" being 'Turanga Leela.' 3. Join Structure: Use JOINs to connect the ""Shipment"" table with the ""Planet"" table on ""Shipment.Planet = Planet.PlanetID"" and with the ""Employee"" table on ""Shipment.Manager = Employee.EmployeeID"" to access the necessary fields for filtering. 4. Aggregation Structure: No aggregation is needed as the query only retrieves shipment IDs without any summarization.",1.0
1937,List package number and weight of top 3 lightest packages.,EASY,planet_1,"[Package.PackageNumber, Package.Weight]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Package.PackageNumber, Package.Weight FROM Package ORDER BY Package.Weight ASC LIMIT 3;","SELECT PackageNumber ,  Weight FROM PACKAGE ORDER BY Weight ASC LIMIT 3;","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the package number and weight. 2. Condition Structure: No specific filtering condition is required as we want all packages. 3. Ordering Structure: Use ORDER BY in ascending order on ""Package.Weight"" to rank packages by their weight from lightest to heaviest. 4. Limiting Structure: Use LIMIT 3 to retrieve only the top 3 lightest packages. 5. Join Structure: No JOIN is required since all necessary data is within the ""Package"" table.",1.0
1938,Return the number of distinct staff who have attended a meeting?,NON-NESTED,advertising_agencies,"[Staff.staff_id, Staff_in_Meetings.staff_id, Staff_in_Meetings.meeting_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(DISTINCT Staff.staff_id) FROM Staff JOIN Staff_in_Meetings ON Staff.staff_id = Staff_in_Meetings.staff_id;,SELECT count(DISTINCT staff_id) FROM Staff_in_meetings,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""Staff.staff_id"" who have attended a meeting. 2. Condition Structure: No specific filtering condition is required, as we are interested in all staff who have attended any meeting. 3. Join Structure: Use a JOIN between the ""Staff"" table and the ""Staff_in_Meetings"" table based on ""Staff.staff_id"" and ""Staff_in_Meetings.staff_id"" to link staff with their meeting attendance records. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique staff IDs who have attended meetings.",1.0
1939,Show the agency ids and the number of staff in each agent?,NON-NESTED,advertising_agencies,"[Agencies.agency_id, Staff.agency_id, Agencies.agency_id = Staff.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, COUNT(Staff.agency_id) AS number_of_staff FROM Agencies JOIN Staff ON Agencies.agency_id = Staff.agency_id GROUP BY Agencies.agency_id;","SELECT agency_id ,  count(*) FROM Staff GROUP BY agency_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Agencies.agency_id"" and the count of staff members for each agency. Use COUNT on ""Staff.agency_id"" to count the number of staff members. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Agencies"" and ""Staff"" tables based on the shared key ""Agencies.agency_id = Staff.agency_id"" to associate each agency with its staff members. 4. Aggregation Structure: Use COUNT to aggregate the number of staff members for each agency, and GROUP BY ""Agencies.agency_id"" to group the results by agency.",1.0
1940,Show agency ids and details with at least 2 clients.,NON-NESTED,advertising_agencies,"[Agencies.agency_id, Agencies.agency_details, Clients.agency_id, Clients.client_id, Clients.agency_id = Agencies.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, Agencies.agency_details FROM Agencies JOIN Clients ON Clients.agency_id = Agencies.agency_id GROUP BY Agencies.agency_id, Agencies.agency_details HAVING COUNT(Clients.client_id) >= 2;","SELECT T1.agency_id ,  T1.agency_details FROM Agencies AS T1 JOIN Clients AS T2 ON T1.agency_id  =  T2.agency_id GROUP BY T1.agency_id HAVING count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve ""Agencies.agency_id"" and ""Agencies.agency_details."" 2. Condition Structure: Use a HAVING clause to filter for agencies that have at least 2 clients. 3. Join Structure: Use a JOIN between the ""Agencies"" and ""Clients"" tables based on ""Clients.agency_id = Agencies.agency_id"" to associate each agency with its clients. 4. Aggregation Structure: Use COUNT on ""Clients.client_id"" to count the number of clients per agency, then filter with HAVING to select agencies with at least 2 clients.",1.0
1941,List the name of players that do not play any game.,NESTED,video_game,"[player.Player_name,game_player.Player_ID,game_player.Game_ID = game.Game_ID]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT player.Player_name FROM player WHERE player.Player_ID NOT IN (SELECT game_player.Player_ID FROM game_player);,SELECT Player_name FROM player WHERE Player_ID NOT IN (SELECT Player_ID FROM game_player),"1. Sequential Structure: Begin with the SELECT clause to retrieve the names of players. Use the FROM clause to specify the player table. Apply a WHERE clause to filter players who do not play any game by ensuring their Player_ID is not present in the game_player table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude players whose Player_ID appears in the game_player table, meaning they play at least one game. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Player_ID entries in the game_player table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1942,What is the description for staff role code HR?,EASY,cre_Doc_Workflow,"[Ref_Staff_Roles.staff_role_description,Ref_Staff_Roles.staff_role_code,HR]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT Ref_Staff_Roles.staff_role_description FROM Ref_Staff_Roles WHERE Ref_Staff_Roles.staff_role_code = 'HR';,"SELECT staff_role_description FROM Ref_staff_roles WHERE staff_role_code  =  ""HR""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Ref_Staff_Roles.staff_role_description"" for the staff role code 'HR'. 2. Condition Structure: Use a WHERE clause to filter for the specific staff role code 'HR'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Ref_Staff_Roles"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",1.0
1943,Return the average number of units sold in millions among games played by players who have the position Guard.,NON-NESTED,video_game,"[game.Units_sold_Millions,player.Position,game_player.Player_ID = player.Player_ID,game_player.Game_ID = game.Game_ID,Guard]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT AVG(game.Units_sold_Millions) FROM game_player JOIN player ON game_player.Player_ID = player.Player_ID JOIN game ON game_player.Game_ID = game.Game_ID WHERE player.Position = 'Guard';,"SELECT avg(Units_sold_Millions) FROM game AS T1 JOIN game_player AS T2 ON T1.Game_ID  =  T2.Game_ID JOIN player AS T3 ON T2.Player_ID  =  T3.Player_ID WHERE T3.Position  =  ""Guard""","1. Sequential Structure: Start with the SELECT clause to calculate the average number of units sold in millions, which corresponds to the ""game.Units_sold_Millions"" field. 2. Condition Structure: Use a WHERE clause to filter for players who have the position ""Guard."" 3. Join Structure: Use JOINs to connect the ""game_player"" table with the ""player"" table on ""game_player.Player_ID = player.Player_ID"" and the ""game_player"" table with the ""game"" table on ""game_player.Game_ID = game.Game_ID."" This ensures we can link games with players and their positions. 4. Aggregation Structure: Use the AVG function to calculate the average of ""game.Units_sold_Millions"" for the filtered records.",1.0
1944,List the name of each franchise and the number of games belonging to that franchise.,EASY,video_game,"[game.Franchise, game.Game_ID]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT game.Franchise, COUNT(game.Game_ID) AS game_count FROM game GROUP BY game.Franchise;","SELECT Franchise ,  COUNT(*) FROM game GROUP BY Franchise","1. Sequential Structure: Begin with the SELECT clause to specify the franchise name and the count of games belonging to each franchise. 2. Aggregation Structure: Use COUNT to calculate the number of games for each franchise. 3. Grouping Structure: Use GROUP BY on ""game.Franchise"" to group the results by each franchise. 4. Join Structure: No JOIN is required since all necessary data is within the ""game"" table.",1.0
1945,Count the number of authors of age below 30.,EASY,book_press,"[author.Age, author.Author_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT COUNT(author.Author_ID) FROM author WHERE author.Age < 30;,SELECT count(*) FROM author WHERE age  <  30,"1. Sequential Structure: Start with the SELECT clause to count the number of authors. 2. Condition Structure: Use a WHERE clause to filter authors whose age is below 30. 3. Join Structure: No JOIN is required since all necessary information is in the ""author"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of authors meeting the age condition.",1.0
1946,Show the meeting ids and the number of staff in each meeting.,NON-NESTED,advertising_agencies,"[Meetings.meeting_id, Staff_in_Meetings.staff_id, Staff_in_Meetings.meeting_id = Meetings.meeting_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.meeting_id, COUNT(Staff_in_Meetings.staff_id) AS number_of_staff FROM Meetings JOIN Staff_in_Meetings ON Staff_in_Meetings.meeting_id = Meetings.meeting_id GROUP BY Meetings.meeting_id;","SELECT meeting_id ,  count(*) FROM Staff_in_meetings GROUP BY meeting_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Meetings.meeting_id"" and the count of ""Staff_in_Meetings.staff_id"" for each meeting. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""Meetings"" table with the ""Staff_in_Meetings"" table based on the relationship ""Staff_in_Meetings.meeting_id = Meetings.meeting_id."" 4. Aggregation Structure: Use COUNT to count the number of staff in each meeting and GROUP BY ""Meetings.meeting_id"" to group the results by meeting.",1.0
1947,Count the number of games.,EASY,video_game,[game.Game_ID],"Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT COUNT(game.Game_ID) AS total_games FROM game;,SELECT count(*) FROM game,"1. Sequential Structure: Start with the SELECT clause to count the number of games. 2. Condition Structure: No specific filtering condition is required as we want the total count of games. 3. Join Structure: No JOIN is necessary since all required information is in the ""game"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of games.",1.0
1948,"What are the titles and developers of all games, sorted by units sold descending?",EASY,video_game,"[game.Title, game.Developers, game.Units_sold_Millions]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT game.Title, game.Developers FROM game ORDER BY game.Units_sold_Millions DESC;","SELECT Title ,  Developers FROM game ORDER BY Units_sold_Millions DESC","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the ""game.Title"" and ""game.Developers"". Additionally, include ""game.Units_sold_Millions"" for sorting purposes. 2. Condition Structure: No specific filtering condition is required as the query asks for all games. 3. Join Structure: No JOIN is required since all necessary data is within the ""game"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in descending order based on ""game.Units_sold_Millions"".",1.0
1949,What are the names and coordinates of all planets in alphabetical order by name?,EASY,planet_1,"[Planet.Name, Planet.Coordinates]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Planet.Name, Planet.Coordinates FROM Planet ORDER BY Planet.Name ASC;","SELECT Name ,  Coordinates FROM Planet ORDER BY Name","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the planet names and their coordinates. 2. Condition Structure: No specific filtering condition is required as we want all planets. 3. Join Structure: No JOIN is required since all necessary data is within the ""Planet"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""Planet.Name"" in ascending order to sort the planets alphabetically by name.",1.0
1950,What are the maximum and minimum rank of the year of players.,EASY,video_game,[player.Rank_of_the_year],"Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT MAX(player.Rank_of_the_year) AS max_rank, MIN(player.Rank_of_the_year) AS min_rank FROM player;","SELECT max(Rank_of_the_year) ,  min(Rank_of_the_year) FROM player","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum ranks of the year. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum rank of the year for players. 3. Grouping Structure: No GROUP BY is needed since we are calculating the overall maximum and minimum ranks without grouping by any specific field. 4. Join Structure: No JOIN is required since all necessary data is within the ""player"" table.",1.0
1951,Find the name of the publisher whose monthly profit is the highest or the lowest.,NESTED,book_press,"[press.Name, press.Month_Profits_billion]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT Name FROM press WHERE Month_Profits_billion = (SELECT MAX(Month_Profits_billion) FROM press) OR Month_Profits_billion = (SELECT MIN(Month_Profits_billion) FROM press);,SELECT name FROM press WHERE Month_Profits_billion  =  (SELECT min(Month_Profits_billion) FROM press) OR Month_Profits_billion  =  (SELECT max(Month_Profits_billion) FROM press),"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the publisher. Use the FROM clause to specify the press table. Apply a WHERE clause to filter for the publisher whose monthly profit is either the highest or the lowest. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the maximum and minimum monthly profits. Use the OR operator to include both conditions. 3. Join Structure: Not required, as all data is in the press table. 4. Aggregation Structure: Use MAX and MIN functions in subqueries to find the highest and lowest monthly profits, respectively, and filter based on these values.",1.0
1952,What are the number of packages sent by Zapp Brannigan and shipped on the Omicron Persei 8?,NON-NESTED,planet_1,"[Package.Sender, Package.Shipment, Shipment.Planet, Client.Name, Planet.Name, Package.Sender = Client.AccountNumber, Package.Shipment = Shipment.ShipmentID, Shipment.Planet = Planet.PlanetID, Zapp Brannigan, Omicron Persei 8]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT COUNT(Package.Sender) FROM Package JOIN Client ON Package.Sender = Client.AccountNumber JOIN Shipment ON Package.Shipment = Shipment.ShipmentID JOIN Planet ON Shipment.Planet = Planet.PlanetID WHERE Client.Name = 'Zapp Brannigan' AND Planet.Name = 'Omicron Persei 8';,"SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON  T1.Sender = T2.AccountNumber JOIN Shipment AS T3 ON T1.Shipment = T3.ShipmentID JOIN Planet AS T4 ON T3.Planet = T4.PlanetID WHERE T2.Name = ""Zapp Brannigan"" AND T4.Name = ""Omicron Persei 8"";","1. Sequential Structure: Start with the SELECT clause to count the number of packages. Use COUNT on ""Package.Sender"" to determine the number of packages sent by Zapp Brannigan and shipped to Omicron Persei 8. 2. Condition Structure: Use a WHERE clause to filter for packages where the sender is Zapp Brannigan and the shipment destination is Omicron Persei 8. 3. Join Structure: Use JOINs to connect the ""Package"" table with the ""Client"" table on ""Package.Sender = Client.AccountNumber,"" the ""Shipment"" table on ""Package.Shipment = Shipment.ShipmentID,"" and the ""Planet"" table on ""Shipment.Planet = Planet.PlanetID"" to link the sender, shipment, and destination planet. 4. Aggregation Structure: Use COUNT to aggregate the number of packages that meet the specified conditions.",1.0
1953,Which authors have published more than 1 book according to the database? Give me their names.,NON-NESTED,book_press,"[author.Name, book.Author_ID, book.Title, book.Author_ID = author.Author_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT author.Name FROM author JOIN book ON book.Author_ID = author.Author_ID GROUP BY author.Author_ID HAVING COUNT(book.Author_ID) > 1;,SELECT t1.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id GROUP BY t2.author_id HAVING count(*)  >  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors. Use the ""author.Name"" field for this purpose. 2. Condition Structure: Apply a HAVING clause to filter authors who have published more than one book. This requires counting the number of books associated with each author. 3. Join Structure: Use a JOIN between the ""author"" and ""book"" tables based on the ""Author_ID"" field to link authors with their books. 4. Aggregation Structure: Use COUNT on ""book.Author_ID"" to count the number of books for each author, then filter with HAVING to select authors with more than one book.",1.0
1954,What is the total shipments in each planet? List the planet name and total shipments.,NON-NESTED,planet_1,"[Planet.Name, Shipment.Planet, Shipment.Planet = Planet.PlanetID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Planet.Name, COUNT(Shipment.Planet) AS TotalShipments FROM Planet JOIN Shipment ON Shipment.Planet = Planet.PlanetID GROUP BY Planet.Name;","SELECT T2.Name ,  count(*) FROM Shipment AS T1 JOIN Planet AS T2 ON T1.Planet = T2.PlanetID GROUP BY T1.Planet;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Planet.Name"" and the total shipments. Use an aggregate function (COUNT) on the ""Shipment.Planet"" to calculate the total shipments for each planet. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Planet"" and ""Shipment"" tables based on the relationship ""Shipment.Planet = Planet.PlanetID"" to associate shipments with their respective planets. 4. Aggregation Structure: Use COUNT to count the number of shipments for each planet, and GROUP BY ""Planet.Name"" to group the results by planet.",1.0
1955,Count the number of staff in each meeting by meeting id.,NON-NESTED,advertising_agencies,"[Staff_in_Meetings.meeting_id, Staff_in_Meetings.staff_id, Staff.staff_id = Staff_in_Meetings.staff_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Staff_in_Meetings.meeting_id, COUNT(Staff_in_Meetings.staff_id) AS staff_count FROM Staff_in_Meetings GROUP BY Staff_in_Meetings.meeting_id;","SELECT meeting_id ,  count(*) FROM Staff_in_meetings GROUP BY meeting_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Staff_in_Meetings.meeting_id"" and the count of staff in each meeting. Use COUNT to count the number of staff for each meeting. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: No JOIN is necessary since all the required data is available in the ""Staff_in_Meetings"" table. 4. Aggregation Structure: Use COUNT on ""Staff_in_Meetings.staff_id"" to count the number of staff per meeting, and GROUP BY ""Staff_in_Meetings.meeting_id"" to group the results by meeting ID.",1.0
1956,"What are the ids, statuses, and details for all invoices?",EASY,advertising_agencies,"[Invoices.invoice_id, Invoices.invoice_status, Invoices.invoice_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.invoice_id, Invoices.invoice_status, Invoices.invoice_details FROM Invoices;","SELECT invoice_id ,  invoice_status ,  invoice_details FROM Invoices","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""invoice_id"", ""invoice_status"", and ""invoice_details"". 2. Condition Structure: No specific filtering condition is required as the query asks for all invoices. 3. Join Structure: No JOIN is required since all necessary data is within the ""Invoices"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all the specified fields.",1.0
1957,Show all process ids and the number of documents in each process.,EASY,cre_Doc_Workflow,"[Documents_Processes.process_id, Documents_Processes.document_id]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Documents_Processes.process_id, COUNT(Documents_Processes.document_id) AS document_count FROM Documents_Processes GROUP BY Documents_Processes.process_id;","SELECT process_id ,  count(*) FROM Documents_processes GROUP BY process_id","1. Sequential Structure: Begin with the SELECT clause to specify the process IDs and the count of documents for each process. 2. Aggregation Structure: Use COUNT to calculate the number of documents associated with each process. 3. Grouping Structure: Use GROUP BY on ""Documents_Processes.process_id"" to aggregate the results by each process ID. 4. Join Structure: No JOIN is required since all necessary data is within the ""Documents_Processes"" table.",1.0
1958,Give the maximum and minimum rank of the year across all players.,EASY,video_game,[player.Rank_of_the_year],"Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT MAX(player.Rank_of_the_year) AS max_rank, MIN(player.Rank_of_the_year) AS min_rank FROM player;","SELECT max(Rank_of_the_year) ,  min(Rank_of_the_year) FROM player","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum ranks of the year. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum rank of the year across all players. 3. Grouping Structure: No GROUP BY is needed since the query asks for the overall maximum and minimum rank, not grouped by any specific field. 4. Join Structure: No JOIN is required as all necessary data is within the ""player"" table.",1.0
1959,Find the book series that have some book selling more than 1000 and some book less 500.,NESTED,book_press,"[book.Book_Series, book.Sale_Amount]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT DISTINCT book.Book_Series FROM book WHERE EXISTS ( SELECT 1 FROM book AS b1 WHERE b1.Book_Series = book.Book_Series AND b1.Sale_Amount > 1000 ) AND EXISTS ( SELECT 1 FROM book AS b2 WHERE b2.Book_Series = book.Book_Series AND b2.Sale_Amount < 500 );,SELECT book_series FROM book WHERE sale_amount  >  1000 INTERSECT SELECT book_series FROM book WHERE sale_amount  <  500,"1. Sequential Structure: Start with the SELECT clause to retrieve the book series. Use the FROM clause to specify the book table. Apply a WHERE clause to filter for book series that have at least one book with a sale amount greater than 1000 and at least one book with a sale amount less than 500. 2. Condition Structure: Use the WHERE clause with EXISTS subqueries to ensure that the book series has books meeting both conditions (sale amount greater than 1000 and sale amount less than 500). 3. Join Structure: Not required, as all data is available within the book table. 4. Aggregation Structure: Not needed, as we are only filtering based on specific conditions without any aggregation.",1.0
1960,Who sent more than one packages? List the client's name.,NON-NESTED,planet_1,"[Package.Sender, Client.Name, Package.Sender = Client.AccountNumber]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Client.Name FROM Package JOIN Client ON Package.Sender = Client.AccountNumber GROUP BY Client.Name HAVING COUNT(Package.Sender) > 1;,"SELECT T2.Name ,  count(*) FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber GROUP BY T1.Sender HAVING count(*)  >  1;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Client.Name"" of clients who sent more than one package. 2. Condition Structure: Use a HAVING clause to filter for clients who sent more than one package. This requires counting the number of packages sent by each client. 3. Join Structure: Use a JOIN between the ""Package"" and ""Client"" tables based on the relationship ""Package.Sender = Client.AccountNumber"" to associate packages with their respective senders. 4. Aggregation Structure: Use COUNT on ""Package.Sender"" to count the number of packages sent by each client, then filter with HAVING to select clients who sent more than one package.",0.0
1961,Show all document ids without a process.,NESTED,cre_Doc_Workflow,"[Documents.document_id,Documents_Processes.document_id,Documents.document_id != Documents_Processes.document_id]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT document_id FROM Documents WHERE document_id NOT IN (SELECT document_id FROM Documents_Processes);,SELECT document_id FROM Documents EXCEPT SELECT document_id FROM Documents_processes,"1. Sequential Structure: Start with the SELECT clause to retrieve document IDs from the Documents table. Use the FROM clause to specify the Documents table. Apply a WHERE clause to filter for document IDs that do not have a corresponding entry in the Documents_Processes table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude document IDs that appear in the Documents_Processes table, ensuring only document IDs without a process are selected. 3. Join Structure: Not required, as the filtering is based on the absence of matching document IDs in the Documents_Processes table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1962,Which planets that have exact one employee has clearance? List planets' name.,NESTED,planet_1,"[Planet.Name, Has_Clearance.Planet, Has_Clearance.Employee, Has_Clearance.Planet = Planet.PlanetID, Has_Clearance.Employee = Employee.EmployeeID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Planet.Name FROM Planet JOIN Has_Clearance ON Has_Clearance.Planet = Planet.PlanetID GROUP BY Planet.PlanetID, Planet.Name HAVING COUNT(Has_Clearance.Employee) = 1;",SELECT T3.Name FROM Has_Clearance AS T1 JOIN Employee AS T2 ON T1.Employee = T2.EmployeeID JOIN Planet AS T3 ON T1.Planet = T3.PlanetID GROUP BY T1.Planet HAVING count(*)  =  1;,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of planets. Use the FROM clause to specify the Planet table and JOIN it with the Has_Clearance table to connect planets with employees who have clearance. Use GROUP BY to group records by planet and COUNT to determine the number of employees with clearance for each planet. Apply a HAVING clause to filter for planets with exactly one employee having clearance. 2. Condition Structure: Use the HAVING clause with COUNT(Employee) = 1 to filter for planets with exactly one employee having clearance. 3. Join Structure: Use an INNER JOIN between the Planet and Has_Clearance tables based on the relationship between Planet.PlanetID and Has_Clearance.Planet. Also, ensure the relationship between Has_Clearance.Employee and Employee.EmployeeID is maintained. 4. Aggregation Structure: Use COUNT(Employee) to count the number of employees with clearance for each planet and filter for those with exactly one employee.",1.0
1963,List package number of package shipped in planet Omicron Persei 8 and sent by Zapp Brannigan.,NON-NESTED,planet_1,"[Package.PackageNumber,Package.Sender,Package.Shipment,Client.Name,Shipment.Planet,Planet.Name,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID,Shipment.Planet = Planet.PlanetID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Package.PackageNumber FROM Package JOIN Client ON Package.Sender = Client.AccountNumber JOIN Shipment ON Package.Shipment = Shipment.ShipmentID JOIN Planet ON Shipment.Planet = Planet.PlanetID WHERE Client.Name = 'Zapp Brannigan' AND Planet.Name = 'Omicron Persei 8';,"SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON  T1.Sender = T2.AccountNumber JOIN Shipment AS T3 ON T1.Shipment = T3.ShipmentID JOIN Planet AS T4 ON T3.Planet = T4.PlanetID WHERE T2.Name = ""Zapp Brannigan"" AND T4.Name = ""Omicron Persei 8"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Package.PackageNumber"" as the required field. 2. Condition Structure: Use a WHERE clause to filter for packages sent by ""Zapp Brannigan"" and shipped to the planet ""Omicron Persei 8."" 3. Join Structure: Use JOINs to connect the ""Package"" table with the ""Client"" table on ""Package.Sender = Client.AccountNumber,"" the ""Shipment"" table on ""Package.Shipment = Shipment.ShipmentID,"" and the ""Planet"" table on ""Shipment.Planet = Planet.PlanetID"" to link the package with its sender and destination planet. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific package numbers based on the conditions.",1.0
1964,What are the titles and platform names of all games?,NON-NESTED,video_game,"[game.Title, platform.Platform_name, game.Platform_ID = platform.Platform_ID]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT game.Title, platform.Platform_name FROM game JOIN platform ON game.Platform_ID = platform.Platform_ID;","SELECT T1.Title ,  T2.Platform_name FROM game AS T1 JOIN platform AS T2 ON T1.Platform_ID  =  T2.Platform_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""game.Title"" and ""platform.Platform_name."" 2. Condition Structure: No specific filtering condition is needed, so no WHERE clause is required. 3. Join Structure: Use a JOIN between the ""game"" and ""platform"" tables based on the shared key ""Platform_ID"" to link each game with its respective platform. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all titles and platform names.",1.0
1965,List names and colleges of all players in descending order of rank of the year.,EASY,video_game,"[player.Player_name,player.College,player.Rank_of_the_year]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT player.Player_name, player.College FROM player ORDER BY player.Rank_of_the_year DESC;","SELECT Player_name ,  College FROM player ORDER BY Rank_of_the_year DESC","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""player.Player_name"" and ""player.College"". 2. Condition Structure: No specific filtering condition is required as we want all players and their colleges. 3. Join Structure: No JOIN is required since all necessary information is available in the ""player"" table. 4. Ordering Structure: Use ORDER BY in descending order on ""player.Rank_of_the_year"" to sort the results by rank of the year. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data.",1.0
1966,"For each press, return its name and the number of books that have sale amount above 1000.",NON-NESTED,book_press,"[press.Name, book.Sale_Amount, book.Press_ID = press.Press_ID, 1000]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT press.Name, COUNT(book.Sale_Amount) AS NumberOfBooks FROM press JOIN book ON book.Press_ID = press.Press_ID WHERE book.Sale_Amount > 1000 GROUP BY press.Name;","SELECT count(*) ,  t2.name FROM book AS t1 JOIN press AS t2 ON t1.press_id  =  t2.press_id WHERE sale_amount  >  1000 GROUP BY t2.name","1. Sequential Structure: Start with the SELECT clause to retrieve the ""press.Name"" and the count of books with a sale amount above 1000. Use COUNT to count the number of such books for each press. 2. Condition Structure: Use a WHERE clause to filter books with a ""Sale_Amount"" greater than 1000. 3. Join Structure: Use a JOIN between the ""press"" and ""book"" tables based on the ""Press_ID"" field to associate books with their respective presses. 4. Aggregation Structure: Use COUNT to count the number of books for each press that meet the condition, and GROUP BY ""press.Name"" to group the results by each press.",1.0
1967,What are the ids and details of the clients who have attended any meeting or have any invoice?,NESTED,advertising_agencies,"[Clients.client_id,Clients.client_details,Meetings.client_id,Invoices.client_id,Meetings.client_id = Clients.client_id,Invoices.client_id = Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_id, Clients.client_details FROM Clients LEFT JOIN Meetings ON Meetings.client_id = Clients.client_id LEFT JOIN Invoices ON Invoices.client_id = Clients.client_id WHERE Meetings.client_id IS NOT NULL OR Invoices.client_id IS NOT NULL;","SELECT T1.client_id ,  T1.client_details FROM Clients AS T1 JOIN meetings AS T2 ON T1.client_id  =  T2.client_id UNION SELECT T1.client_id ,  T1.client_details FROM Clients AS T1 JOIN invoices AS T2 ON T1.client_id  =  T2.client_id","1. Sequential Structure: Start with the SELECT clause to retrieve the client IDs and details. Use the FROM clause to specify the Clients table. Use JOINs to connect the Clients table with the Meetings and Invoices tables to identify clients who have attended any meeting or have any invoice. 2. Condition Structure: Use a WHERE clause to filter clients who are present in either the Meetings table or the Invoices table. 3. Join Structure: Use LEFT JOINs between the Clients table and the Meetings and Invoices tables based on the client_id to ensure all clients with either meetings or invoices are included. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
1968,What are the 5 best books in terms of sale amount? Give me their titles and release dates.,EASY,book_press,"[book.Title, book.Release_date, book.Sale_Amount]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT book.Title, book.Release_date FROM book ORDER BY book.Sale_Amount DESC LIMIT 5;","SELECT title ,  release_date FROM book ORDER BY sale_amount DESC LIMIT 5","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the book titles and their release dates. 2. Ordering Structure: Use ORDER BY in descending order on ""book.Sale_Amount"" to rank the books by their sale amounts. 3. Limiting Structure: Use LIMIT 5 to retrieve only the top 5 books with the highest sale amounts. 4. Join Structure: No JOIN is required since all necessary data is within the ""book"" table. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving the top 5 books based on their sale amounts.",1.0
1969,What are the titles of games that have platforms in the market districts of Asia or the USA?,NON-NESTED,video_game,"[game.Title, platform.Market_district, game.Platform_ID = platform.Platform_ID, Asia, USA]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT game.Title FROM game JOIN platform ON game.Platform_ID = platform.Platform_ID WHERE platform.Market_district = 'Asia' OR platform.Market_district = 'USA';,"SELECT T1.Title FROM game AS T1 JOIN platform AS T2 ON T1.Platform_ID  =  T2.Platform_ID WHERE T2.Market_district  =  ""Asia"" OR T2.Market_district  =  ""USA""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""game.Title"" field, as the question asks for the titles of games. 2. Condition Structure: Use a WHERE clause to filter for platforms that are in the market districts of ""Asia"" or ""USA."" 3. Join Structure: Use a JOIN between the ""game"" and ""platform"" tables based on the shared key ""Platform_ID"" to associate each game with its platform details. 4. Aggregation Structure: No aggregation is needed since the query only retrieves game titles without any summarization.",1.0
1970,What are the names of players who do not play any games?,NESTED,video_game,"[player.Player_ID,game_player.Player_ID,player.Player_name]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT player.Player_name FROM player WHERE player.Player_ID NOT IN (SELECT game_player.Player_ID FROM game_player);,SELECT Player_name FROM player WHERE Player_ID NOT IN (SELECT Player_ID FROM game_player),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of players. Use the FROM clause to specify the player table. Apply a WHERE clause to filter players who do not play any games by ensuring their Player_ID is not present in the game_player table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude players whose Player_ID appears in the game_player table, meaning they play games. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Player_ID entries in the game_player table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
1971,"What are the payment ids, invoice ids, and payment details for all payments?",EASY,advertising_agencies,"[Payments.payment_id, Payments.invoice_id, Payments.payment_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Payments.payment_id, Payments.invoice_id, Payments.payment_details FROM Payments;","SELECT payment_id ,  invoice_id ,  payment_details FROM Payments","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Payments.payment_id,"" ""Payments.invoice_id,"" and ""Payments.payment_details."" 2. Condition Structure: No specific filtering condition is required as the query asks for all payments. 3. Join Structure: No JOIN is required since all necessary data is within the ""Payments"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all the specified fields.",1.0
1972,Find the press whose yearly profit is more than 15 billion or whose monthly profit is more than 1 billion. Return the press names.,EASY,book_press,"[press.Name, press.Year_Profits_billion, press.Month_Profits_billion]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT press.Name FROM press WHERE press.Year_Profits_billion > 15 OR press.Month_Profits_billion > 1;,SELECT name FROM press WHERE Year_Profits_billion  >  15 OR Month_Profits_billion  >  1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""press.Name"" of presses that meet the profit conditions. 2. Condition Structure: Use a WHERE clause to filter presses where ""press.Year_Profits_billion"" is greater than 15 or ""press.Month_Profits_billion"" is greater than 1. 3. Join Structure: No JOIN is required since all necessary information is in the ""press"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving press names based on specific conditions.",1.0
1973,Count the number of payments.,EASY,advertising_agencies,[Payments.payment_id],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(Payments.payment_id) AS total_payments FROM Payments;,SELECT count(*) FROM Payments,"1. Sequential Structure: Begin with the SELECT clause to count the number of payments. 2. Aggregation Structure: Use the COUNT function on the ""Payments.payment_id"" field to calculate the total number of payments. 3. Condition Structure: No specific filtering condition is required as the query aims to count all payments. 4. Join Structure: No JOIN is necessary since all required data is within the ""Payments"" table.",1.0
1974,Show details for all clients and the details of their corresponding agents.,NON-NESTED,advertising_agencies,"[Clients.client_details,Agencies.agency_details,Clients.agency_id = Agencies.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_details, Agencies.agency_details FROM Clients JOIN Agencies ON Clients.agency_id = Agencies.agency_id;","SELECT T1.client_details ,  T2.agency_details FROM Clients AS T1 JOIN Agencies AS T2 ON T1.agency_id  =  T2.agency_id","1. Sequential Structure: Start with the SELECT clause to retrieve all client details and their corresponding agency details. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""Clients"" table with the ""Agencies"" table based on the shared key ""agency_id."" 4. Aggregation Structure: No aggregation is required as the query is focused on retrieving details without summarization.",1.0
1975,What are the details for the staff member with id 100.,EASY,cre_Doc_Workflow,"[Staff.staff_id, Staff.staff_details]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT * FROM Staff WHERE Staff.staff_id = 100;,SELECT staff_details FROM Staff WHERE staff_id  =  100,"1. Sequential Structure: Begin with the SELECT clause to retrieve all details of the staff member with the specified ID. 2. Condition Structure: Use a WHERE clause to filter for the staff member whose ""Staff.staff_id"" is 100. 3. Join Structure: No JOIN is required since all necessary information is in the ""Staff"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific details for a single staff member.",1.0
1976,List all payment ids and its corresponding invoice ids and details.,NON-NESTED,advertising_agencies,"[Payments.payment_id, Payments.invoice_id, Payments.payment_details, Invoices.invoice_id, Invoices.invoice_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Payments.payment_id, Payments.invoice_id, Payments.payment_details, Invoices.invoice_details FROM Payments JOIN Invoices ON Payments.invoice_id = Invoices.invoice_id;","SELECT payment_id ,  invoice_id ,  payment_details FROM Payments","1. Sequential Structure: Start with the SELECT clause to retrieve ""Payments.payment_id,"" ""Payments.invoice_id,"" and ""Payments.payment_details"" along with ""Invoices.invoice_details."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Payments"" and ""Invoices"" tables based on the shared key ""invoice_id"" to link payments with their corresponding invoices. 4. Aggregation Structure: No aggregation is required as the query is focused on listing all relevant details.",1.0
1977,Count the number of staff who did not attend any meeting.,NESTED,advertising_agencies,"[Staff.staff_id,Staff_in_Meetings.staff_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(*) FROM Staff WHERE staff_id NOT IN (SELECT staff_id FROM Staff_in_Meetings);,SELECT count(*) FROM Staff WHERE staff_id NOT IN ( SELECT staff_id FROM Staff_in_meetings ),"1. Sequential Structure: Start with the SELECT clause to count the number of staff. Use the FROM clause to specify the Staff table. Apply a WHERE clause to filter staff who did not attend any meeting by ensuring their staff_id is not present in the Staff_in_Meetings table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude staff whose staff_id appears in the Staff_in_Meetings table, meaning they attended a meeting. 3. Join Structure: Not required, as we only need to filter based on the absence of matching staff_id entries in the Staff_in_Meetings table. 4. Aggregation Structure: Use COUNT to calculate the total number of staff who meet the condition of not attending any meeting.",1.0
1978,"Please show the names and rank of players that have played the game titled ""Super Mario World"".",NON-NESTED,video_game,"[player.Player_name, player.Rank_of_the_year, game.Title, game_player.Player_ID = player.Player_ID, game_player.Game_ID = game.Game_ID, game.Title = ""Super Mario World""]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT player.Player_name, player.Rank_of_the_year FROM player JOIN game_player ON player.Player_ID = game_player.Player_ID JOIN game ON game_player.Game_ID = game.Game_ID WHERE game.Title = ""Super Mario World"";","SELECT T3.Player_name ,  T3.rank_of_the_year FROM game AS T1 JOIN game_player AS T2 ON T1.Game_ID  =  T2.Game_ID JOIN player AS T3 ON T2.Player_ID  =  T3.Player_ID WHERE T1.Title  =  ""Super Mario World""","1. Sequential Structure: Start with the SELECT clause to retrieve ""player.Player_name"" and ""player.Rank_of_the_year."" 2. Condition Structure: Use a WHERE clause to filter for records where the ""game.Title"" is ""Super Mario World."" 3. Join Structure: Use JOINs to connect the ""player"" table with the ""game_player"" table on ""player.Player_ID"" and the ""game_player"" table with the ""game"" table on ""game.Game_ID"" to link players with the specific game. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific player details for the given game.",1.0
1979,Who received least number of packages ? List client name and number of packages received by that client .,NON-NESTED,planet_1,"[Client.Name, Package.Recipient, Package.Shipment, Client.AccountNumber = Package.Recipient]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Client.Name, COUNT(Package.Shipment) AS NumberOfPackages FROM Client JOIN Package ON Client.AccountNumber = Package.Recipient GROUP BY Client.Name ORDER BY NumberOfPackages ASC LIMIT 1;","select t2.name ,  count(*) from package as t1 join client as t2 on t1.recipient  =  t2.accountnumber group by t1.recipient order by count(*) limit 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Client.Name"" and the count of packages received by each client. Use COUNT on ""Package.Shipment"" to count the number of packages received by each client. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all clients and their package counts. 3. Join Structure: Use a JOIN between the ""Client"" and ""Package"" tables based on ""Client.AccountNumber = Package.Recipient"" to associate each client with their received packages. 4. Aggregation Structure: Use GROUP BY on ""Client.Name"" to group the results by client. Use ORDER BY in ascending order on the count of packages to rank clients by the number of packages received. Use LIMIT 1 to select the client with the least number of packages.",0.0
1980,How many meetings are there for each client id?,EASY,advertising_agencies,"[Meetings.client_id, Meetings.meeting_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.client_id, COUNT(Meetings.meeting_id) AS meeting_count FROM Meetings GROUP BY Meetings.client_id;","SELECT client_id ,  count(*) FROM Meetings GROUP BY client_id","1. Sequential Structure: Begin with the SELECT clause to specify the client ID and the count of meetings for each client. 2. Aggregation Structure: Use COUNT to calculate the number of meetings for each client. 3. Grouping Structure: Use GROUP BY on ""Meetings.client_id"" to aggregate the count of meetings for each client ID. 4. Join Structure: No JOIN is required since all necessary data is within the ""Meetings"" table.",1.0
1981,Please list the title and platform name of games.,NON-NESTED,video_game,"[game.Title, platform.Platform_name, game.Platform_ID = platform.Platform_ID]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT game.Title, platform.Platform_name FROM game JOIN platform ON game.Platform_ID = platform.Platform_ID;","SELECT T1.Title ,  T2.Platform_name FROM game AS T1 JOIN platform AS T2 ON T1.Platform_ID  =  T2.Platform_ID","1. Sequential Structure: Start with the SELECT clause to retrieve ""game.Title"" and ""platform.Platform_name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""game"" and ""platform"" tables based on the shared key ""Platform_ID"" to link each game with its respective platform. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the titles and platform names.",1.0
1982,Find the average and maximum yearly profit for each press.,EASY,book_press,"[press.Month_Profits_billion, press.Year_Profits_billion]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT press.name, AVG(press.Year_Profits_billion) AS avg_yearly_profit, MAX(press.Year_Profits_billion) AS max_yearly_profit FROM press GROUP BY press.name;","SELECT avg(Year_Profits_billion) ,  max(Year_Profits_billion) FROM press","1. Sequential Structure: Begin with the SELECT clause to specify the press name and the required aggregate values, which are the average and maximum yearly profits. 2. Aggregation Structure: Use AVG and MAX functions to calculate the average and maximum yearly profits for each press. 3. Grouping Structure: Use GROUP BY on ""press.name"" to calculate these aggregate values for each press. 4. Join Structure: No JOIN is required since all necessary data is within the ""press"" table.",1.0
1983,Find the number of books that are sold more than 1000 for each publisher. List the press name as well.,NON-NESTED,book_press,"[book.Sale_Amount,press.Name,book.Press_ID = press.Press_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT press.Name, COUNT(book.Sale_Amount) AS Number_of_Books FROM book JOIN press ON book.Press_ID = press.Press_ID WHERE book.Sale_Amount > 1000 GROUP BY press.Name;","SELECT count(*) ,  t2.name FROM book AS t1 JOIN press AS t2 ON t1.press_id  =  t2.press_id WHERE sale_amount  >  1000 GROUP BY t2.name","1. Sequential Structure: Start with the SELECT clause to retrieve the ""press.Name"" and the count of books sold more than 1000 for each publisher. Use COUNT to count the number of books. 2. Condition Structure: Use a WHERE clause to filter books where ""book.Sale_Amount"" is greater than 1000. 3. Join Structure: Use a JOIN between the ""book"" and ""press"" tables based on the ""Press_ID"" field to associate books with their respective publishers. 4. Aggregation Structure: Use COUNT to count the number of books for each publisher and GROUP BY ""press.Name"" to group the results by publisher.",1.0
1984,Show all client ids and the number of invoices for each client.,NON-NESTED,advertising_agencies,"[Clients.client_id, Invoices.client_id, Clients.client_id = Invoices.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_id, COUNT(Invoices.client_id) AS invoice_count FROM Clients JOIN Invoices ON Clients.client_id = Invoices.client_id GROUP BY Clients.client_id;","SELECT client_id ,  count(*) FROM Invoices GROUP BY client_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Clients.client_id"" and the count of invoices for each client. Use COUNT on ""Invoices.client_id"" to count the number of invoices. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Clients"" and ""Invoices"" tables based on the relationship ""Clients.client_id = Invoices.client_id"" to associate each client with their invoices. 4. Aggregation Structure: Use COUNT to aggregate the number of invoices for each client, and GROUP BY ""Clients.client_id"" to group the results by client.",1.0
1985,What are the Coordinates of planet Mars?,EASY,planet_1,"[Planet.Coordinates,Planet.Name]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Planet.Coordinates FROM Planet WHERE Planet.Name = 'Mars';,"SELECT Coordinates FROM Planet WHERE Name  =  ""Mars"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Planet.Coordinates"" for the planet Mars. 2. Condition Structure: Use a WHERE clause to filter for the planet with the name ""Mars"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Planet"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a specific field based on a condition.",1.0
1986,Return the invoice status that has the most invoices.,EASY,advertising_agencies,[Invoices.invoice_status],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT Invoices.invoice_status FROM Invoices GROUP BY Invoices.invoice_status ORDER BY COUNT(*) DESC LIMIT 1;,SELECT invoice_status FROM Invoices GROUP BY invoice_status ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""invoice_status"". 2. Aggregation Structure: Use COUNT to calculate the number of invoices for each ""invoice_status"". 3. Grouping Structure: Use GROUP BY on ""Invoices.invoice_status"" to aggregate the results by each invoice status. 4. Ordering Structure: Use ORDER BY in descending order on the count of invoices to rank the statuses by the number of invoices. 5. Limiting Structure: Use LIMIT 1 to retrieve the invoice status with the most invoices. 6. Join Structure: No JOIN is required since all necessary data is within the ""Invoices"" table.",1.0
1987,What is the average units sold in millions of the games that are not developed by Nintendo?,NESTED,video_game,"[game.Units_sold_Millions, game.Developers]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT AVG(Units_sold_Millions) AS average_units_sold FROM game WHERE Developers != 'Nintendo';,SELECT avg(Units_sold_Millions) FROM game WHERE developers != 'Nintendo',"1. Sequential Structure: Start with the SELECT clause to calculate the average units sold in millions. Use the FROM clause to specify the game table. Apply a WHERE clause to filter out games developed by Nintendo. 2. Condition Structure: Use the WHERE clause to exclude games where the developer is 'Nintendo'. 3. Join Structure: Not required, as all data is available within the game table. 4. Aggregation Structure: Use the AVG function to calculate the average units sold in millions for the filtered games.",1.0
1988,How many invoices are there for each client id?,EASY,advertising_agencies,"[Invoices.client_id, Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.client_id, COUNT(*) AS invoice_count FROM Invoices GROUP BY Invoices.client_id;","SELECT client_id ,  count(*) FROM Invoices GROUP BY client_id","1. Sequential Structure: Start with the SELECT clause to specify the client ID and the count of invoices for each client. 2. Aggregation Structure: Use COUNT to calculate the number of invoices for each client. 3. Grouping Structure: Use GROUP BY on ""Invoices.client_id"" to group the results by each client ID. 4. Join Structure: No JOIN is required since the necessary information is available in the ""Invoices"" table.",1.0
1989,What are all payment ids and payment details for invoices with status Working?,NON-NESTED,advertising_agencies,"[Payments.payment_id, Payments.payment_details, Invoices.invoice_status, Payments.invoice_id = Invoices.invoice_id, Working]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Payments.payment_id, Payments.payment_details FROM Payments JOIN Invoices ON Payments.invoice_id = Invoices.invoice_id WHERE Invoices.invoice_status = 'Working';","SELECT T1.payment_id ,  T1.payment_details FROM Payments AS T1 JOIN Invoices AS T2 ON T1.invoice_id  =  T2.invoice_id WHERE T2.invoice_status  =  'Working'","1. Sequential Structure: Start with the SELECT clause to retrieve ""Payments.payment_id"" and ""Payments.payment_details."" 2. Condition Structure: Use a WHERE clause to filter for invoices with the status ""Working."" 3. Join Structure: Use a JOIN between the ""Payments"" and ""Invoices"" tables based on the relationship ""Payments.invoice_id = Invoices.invoice_id"" to link payments with their corresponding invoices. 4. Aggregation Structure: No aggregation is needed as the query is retrieving specific details without summarization.",1.0
1990,Show all sic codes and the number of clients with each code.,EASY,advertising_agencies,"[Clients.sic_code, Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.sic_code, COUNT(Clients.client_id) AS client_count FROM Clients GROUP BY Clients.sic_code;","SELECT sic_code ,  count(*) FROM Clients GROUP BY sic_code","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the ""sic_code"" and the count of clients. 2. Aggregation Structure: Use COUNT to calculate the number of clients for each ""sic_code"". 3. Grouping Structure: Use GROUP BY on ""Clients.sic_code"" to group the results by each SIC code. 4. Join Structure: No JOIN is required since all necessary data is within the ""Clients"" table.",1.0
1991,Which packages have weight between 10 and 30? List the package number and weight.,EASY,planet_1,"[Package.PackageNumber, Package.Weight]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Package.PackageNumber, Package.Weight FROM Package WHERE Package.Weight BETWEEN 10 AND 30;","SELECT PackageNumber ,  Weight FROM PACKAGE WHERE Weight BETWEEN 10 AND 30;","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the package number and weight. 2. Condition Structure: Use a WHERE clause to filter packages with weight between 10 and 30. 3. Join Structure: No JOIN is required since all necessary information is in the ""Package"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving package numbers and weights that meet the specified condition.",1.0
1992,How many staff are the document with id 0 and process with id 9.,NON-NESTED,cre_Doc_Workflow,"[Staff_in_Processes.staff_id,Staff_in_Processes.document_id,Staff_in_Processes.process_id,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Documents_Processes.document_id,Documents_Processes.process_id]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT COUNT(Staff_in_Processes.staff_id) FROM Staff_in_Processes WHERE Staff_in_Processes.document_id = 0 AND Staff_in_Processes.process_id = 9;,SELECT count(*) FROM Staff_in_processes WHERE document_id  =  0 AND process_id  =  9,"1. Sequential Structure: Start with the SELECT clause to count the number of staff involved. Use COUNT on ""Staff_in_Processes.staff_id"" to get the total number of staff. 2. Condition Structure: Use a WHERE clause to filter for records where ""Staff_in_Processes.document_id"" is 0 and ""Staff_in_Processes.process_id"" is 9. 3. Join Structure: No JOIN is required since all the necessary information is available in the ""Staff_in_Processes"" table. 4. Aggregation Structure: Use COUNT to aggregate the number of staff meeting the specified conditions.",1.0
1993,How many staff have attended a meeting?,NON-NESTED,advertising_agencies,"[Staff.staff_id, Staff_in_Meetings.staff_id, Staff_in_Meetings.meeting_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(DISTINCT Staff_in_Meetings.staff_id) FROM Staff_in_Meetings;,SELECT count(DISTINCT staff_id) FROM Staff_in_meetings,"1. Sequential Structure: Start with the SELECT clause to count the number of unique staff members who have attended a meeting. Use COUNT with DISTINCT on ""Staff_in_Meetings.staff_id."" 2. Condition Structure: No specific filtering condition is required, as we are interested in all staff who have attended any meeting. 3. Join Structure: No JOIN is necessary because the required information is available in the ""Staff_in_Meetings"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to ensure that each staff member is only counted once, regardless of how many meetings they attended.",1.0
1994,How many invoices do we have?,EASY,advertising_agencies,[Invoices.invoice_id],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(Invoices.invoice_id) AS total_invoices FROM Invoices;,SELECT count(*) FROM Invoices,"1. Sequential Structure: Start with the SELECT clause to count the number of invoices. 2. Condition Structure: No specific filtering condition is required since we want the total count of all invoices. 3. Join Structure: No JOIN is necessary as the required information is available in the ""Invoices"" table. 4. Aggregation Structure: Use COUNT on ""Invoices.invoice_id"" to calculate the total number of invoices.",1.0
1995,Return the id and detail for the agency with the most staff.,NON-NESTED,advertising_agencies,"[Agencies.agency_id,Agencies.agency_details,Staff.agency_id,Staff.staff_id = Staff.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, Agencies.agency_details FROM Agencies JOIN Staff ON Agencies.agency_id = Staff.agency_id GROUP BY Agencies.agency_id, Agencies.agency_details ORDER BY COUNT(Staff.staff_id) DESC LIMIT 1;","SELECT T1.agency_id ,  T2.agency_details FROM Staff AS T1 JOIN Agencies AS T2 ON T1.agency_id  =  T2.agency_id GROUP BY T1.agency_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Agencies.agency_id"" and ""Agencies.agency_details."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the agency with the most staff. 3. Join Structure: Use a JOIN between the ""Agencies"" and ""Staff"" tables based on ""agency_id"" to associate each agency with its staff members. 4. Aggregation Structure: Use COUNT on ""Staff.staff_id"" to count the number of staff members per agency. Use ORDER BY in descending order on the count to rank agencies by the number of staff, and LIMIT 1 to select the agency with the most staff.",1.0
1996,"Show ids, status codes, and details for all invoices for clients.",NON-NESTED,advertising_agencies,"[Invoices.invoice_id, Invoices.invoice_status, Invoices.invoice_details, Invoices.client_id = Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.invoice_id, Invoices.invoice_status, Invoices.invoice_details FROM Invoices JOIN Clients ON Invoices.client_id = Clients.client_id;","SELECT invoice_id ,  invoice_status ,  invoice_details FROM Invoices","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Invoices.invoice_id,"" ""Invoices.invoice_status,"" and ""Invoices.invoice_details."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Invoices"" and ""Clients"" tables based on the relationship ""Invoices.client_id = Clients.client_id"" to ensure that invoices are linked to their respective clients. 4. Aggregation Structure: No aggregation is required as the query simply retrieves details for all invoices.",1.0
1997,What are the name and total book sale amount of each press?,NON-NESTED,book_press,"[press.Name, book.Sale_Amount, book.Press_ID = press.Press_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT press.Name, SUM(book.Sale_Amount) AS Total_Sale_Amount FROM press JOIN book ON book.Press_ID = press.Press_ID GROUP BY press.Name;","SELECT sum(t1.sale_amount) ,  t2.name FROM book AS t1 JOIN press AS t2 ON t1.press_id  =  t2.press_id GROUP BY t1.press_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""press.Name"" and the total ""book.Sale_Amount"" for each press. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""press"" and ""book"" tables based on the relationship ""book.Press_ID = press.Press_ID"" to associate each press with its books. 4. Aggregation Structure: Use SUM on ""book.Sale_Amount"" to calculate the total sales for each press, and GROUP BY ""press.Name"" to group the results by press.",1.0
1998,List the client ids and the number of meeting for each client.,NON-NESTED,advertising_agencies,"[Clients.client_id, Meetings.client_id, Clients.client_id = Meetings.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_id, COUNT(Meetings.client_id) AS number_of_meetings FROM Clients JOIN Meetings ON Clients.client_id = Meetings.client_id GROUP BY Clients.client_id;","SELECT client_id ,  count(*) FROM Meetings GROUP BY client_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Clients.client_id"" and the count of meetings for each client. Use COUNT to count the number of meetings. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Clients"" and ""Meetings"" tables based on the shared key ""Clients.client_id = Meetings.client_id"" to associate clients with their meetings. 4. Aggregation Structure: Use COUNT to count the number of meetings for each client and GROUP BY ""Clients.client_id"" to group the results by client.",1.0
1999,Show all agency ids and details for agencies with a client.,NON-NESTED,advertising_agencies,"[Agencies.agency_id, Agencies.agency_details, Clients.agency_id = Agencies.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, Agencies.agency_details FROM Agencies JOIN Clients ON Clients.agency_id = Agencies.agency_id;","SELECT T1.agency_id ,  T1.agency_details FROM Agencies AS T1 JOIN Clients AS T2 ON T1.agency_id  =  T2.agency_id","1. Sequential Structure: Start with the SELECT clause to retrieve all fields from the ""Agencies"" table, including ""agency_id"" and ""agency_details."" 2. Condition Structure: Use a WHERE clause to filter for agencies that have at least one client. This can be achieved by checking for matching ""agency_id"" in the ""Clients"" table. 3. Join Structure: Use an INNER JOIN between the ""Agencies"" and ""Clients"" tables on the ""agency_id"" field to ensure only agencies with clients are included. 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving details for agencies with clients.",1.0
2000,"Show the author name and details for the document ""Travel to China"".",NON-NESTED,cre_Doc_Workflow,"[Documents.author_name,Authors.author_name,Authors.other_details,Documents.document_name,Documents.author_name = Authors.author_name,""Travel to China""]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Authors.author_name, Authors.other_details FROM Documents JOIN Authors ON Documents.author_name = Authors.author_name WHERE Documents.document_name = 'Travel to China';","SELECT T2.author_name ,  T2.other_details FROM Documents AS T1 JOIN Authors AS T2 ON T1.author_name  =  T2.author_name WHERE document_name  =  ""Travel to China""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Authors.author_name"" and ""Authors.other_details."" 2. Condition Structure: Use a WHERE clause to filter for the document with the name ""Travel to China."" 3. Join Structure: Use a JOIN between the ""Documents"" and ""Authors"" tables based on the relationship ""Documents.author_name = Authors.author_name"" to link each document with its respective author. 4. Aggregation Structure: No aggregation is needed as the query is retrieving specific details for a single document.",1.0
2001,"What are the 3 best selling books? Show their titles, author names, and press names.",NON-NESTED,book_press,"[book.Title, book.Sale_Amount, author.Name, press.Name, book.Author_ID = author.Author_ID, book.Press_ID = press.Press_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT book.Title, author.Name, press.Name FROM book JOIN author ON book.Author_ID = author.Author_ID JOIN press ON book.Press_ID = press.Press_ID ORDER BY book.Sale_Amount DESC LIMIT 3;","SELECT t1.name ,  t2.title ,  t3.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id JOIN press AS t3 ON t2.press_id  =  t3.press_id ORDER BY t2.sale_amount DESC LIMIT 3","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""book.Title,"" ""author.Name,"" and ""press.Name."" Use ORDER BY to rank books by their ""book.Sale_Amount"" in descending order, as we are looking for the best-selling books. Use LIMIT 3 to restrict the results to the top 3 books. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all books ranked by their sales. 3. Join Structure: Use JOIN clauses to connect the ""book"" table with the ""author"" table on ""book.Author_ID = author.Author_ID"" and the ""press"" table on ""book.Press_ID = press.Press_ID"" to retrieve the corresponding author and press names for each book. 4. Aggregation Structure: No aggregation is required, as we are directly retrieving and ranking the data.",1.0
2002,Count the number of agencies.,EASY,advertising_agencies,[Agencies.agency_id],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(Agencies.agency_id) AS agency_count FROM Agencies;,SELECT count(*) FROM Agencies,"1. Sequential Structure: Start with the SELECT clause to count the number of agencies. 2. Aggregation Structure: Use the COUNT function on the ""Agencies.agency_id"" field to count the total number of agencies. 3. Condition Structure: No specific filtering condition is required as we want the total count of agencies. 4. Join Structure: No JOIN is required since all necessary data is within the ""Agencies"" table.",1.0
2003,Show agency ids and the number of clients for each agency.,NON-NESTED,advertising_agencies,"[Agencies.agency_id, Clients.agency_id, Clients.agency_id = Agencies.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, COUNT(Clients.agency_id) AS client_count FROM Agencies JOIN Clients ON Clients.agency_id = Agencies.agency_id GROUP BY Agencies.agency_id;","SELECT agency_id ,  count(*) FROM Clients GROUP BY agency_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Agencies.agency_id"" and the count of clients for each agency. Use COUNT on ""Clients.agency_id"" to count the number of clients. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Agencies"" and ""Clients"" tables based on the relationship ""Clients.agency_id = Agencies.agency_id"" to associate clients with their respective agencies. 4. Aggregation Structure: Use COUNT to aggregate the number of clients for each agency and GROUP BY ""Agencies.agency_id"" to group the results by agency.",1.0
2004,How many staff do we have?,EASY,advertising_agencies,[Staff.staff_id],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(Staff.staff_id) AS total_staff FROM Staff;,SELECT count(*) FROM Staff,"1. Sequential Structure: Start with the SELECT clause to count the total number of staff members. 2. Condition Structure: No specific filtering condition is required as we want the total count of all staff. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Staff"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of staff members.",1.0
2005,Show all invoice ids and the number of payments for each invoice.,NON-NESTED,advertising_agencies,"[Invoices.invoice_id, Payments.invoice_id, Payments.payment_id, Payments.invoice_id = Invoices.invoice_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.invoice_id, COUNT(Payments.payment_id) AS number_of_payments FROM Invoices JOIN Payments ON Payments.invoice_id = Invoices.invoice_id GROUP BY Invoices.invoice_id;","SELECT invoice_id ,  count(*) FROM Payments GROUP BY invoice_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Invoices.invoice_id"" and the count of ""Payments.payment_id"" for each invoice. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Invoices"" and ""Payments"" tables based on the relationship ""Payments.invoice_id = Invoices.invoice_id"" to associate payments with their respective invoices. 4. Aggregation Structure: Use COUNT on ""Payments.payment_id"" to count the number of payments for each invoice, and GROUP BY ""Invoices.invoice_id"" to group the results by invoice.",1.0
2006,What are the number of shipments managed and names of each manager?,NON-NESTED,planet_1,"[Shipment.Manager, Employee.Name, Shipment.Manager = Employee.EmployeeID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT COUNT(Shipment.Manager) AS NumberOfShipments, Employee.Name FROM Shipment JOIN Employee ON Shipment.Manager = Employee.EmployeeID GROUP BY Employee.Name;","SELECT T2.Name ,  count(*) FROM Shipment AS T1 JOIN Employee AS T2 ON T1.Manager = T2.EmployeeID GROUP BY T1.Manager;","1. Sequential Structure: Start with the SELECT clause to retrieve the number of shipments managed and the names of each manager. Use COUNT to calculate the number of shipments and include ""Employee.Name"" in the SELECT clause. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Shipment"" and ""Employee"" tables based on the relationship ""Shipment.Manager = Employee.EmployeeID"" to link each shipment with its respective manager. 4. Aggregation Structure: Use COUNT on ""Shipment.Manager"" to count the number of shipments managed by each manager, and GROUP BY ""Employee.Name"" to group the results by manager name.",1.0
2007,Count the number of players that have a rank of year of at most 3.,EASY,video_game,"[player.Player_ID,player.Rank_of_the_year]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT COUNT(player.Player_ID) FROM player WHERE player.Rank_of_the_year <= 3;,SELECT count(*) FROM player WHERE Rank_of_the_year  <=  3,"1. Sequential Structure: Start with the SELECT clause to count the number of players. 2. Condition Structure: Use a WHERE clause to filter players whose ""Rank_of_the_year"" is at most 3. 3. Join Structure: No JOIN is required since all necessary information is in the ""player"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of players meeting the specified condition.",1.0
2008,Show the number of process status.,EASY,cre_Doc_Workflow,[Process_Status.process_status_code],"Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT COUNT(DISTINCT Process_Status.process_status_code) AS number_of_process_status FROM Process_Status;,SELECT count(*) FROM Process_status,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the count of distinct process statuses. 2. Aggregation Structure: Use COUNT with DISTINCT to count the unique process statuses. 3. Condition Structure: No specific filtering condition is required as we want to count all process statuses. 4. Join Structure: No JOIN is required since all necessary data is within the ""Process_Status"" table.",1.0
2009,List all shipment id under Phillip J. Fry's management.,NON-NESTED,planet_1,"[Shipment.ShipmentID,Shipment.Manager,Employee.Name,Shipment.Manager = Employee.EmployeeID,Phillip J. Fry]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Shipment.ShipmentID FROM Shipment JOIN Employee ON Shipment.Manager = Employee.EmployeeID WHERE Employee.Name = 'Phillip J. Fry';,"SELECT T1.ShipmentID FROM Shipment AS T1 JOIN Employee AS T2 ON T1.Manager = T2.EmployeeID WHERE T2.Name = ""Phillip J. Fry"";","1. Sequential Structure: Start with the SELECT clause to retrieve ""Shipment.ShipmentID."" 2. Condition Structure: Use a WHERE clause to filter for shipments managed by ""Phillip J. Fry."" This requires matching the ""Shipment.Manager"" field with the ""Employee.EmployeeID"" where the ""Employee.Name"" is ""Phillip J. Fry."" 3. Join Structure: Use a JOIN between the ""Shipment"" and ""Employee"" tables based on ""Shipment.Manager = Employee.EmployeeID"" to associate each shipment with its manager. 4. Aggregation Structure: No aggregation is needed as the query only retrieves shipment IDs.",1.0
2010,Show the meeting type codes and the number of meeting for each client.,NON-NESTED,advertising_agencies,"[Meetings.meeting_type, Meetings.client_id, Clients.client_id = Meetings.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.meeting_type, COUNT(Meetings.client_id) AS meeting_count FROM Meetings JOIN Clients ON Clients.client_id = Meetings.client_id GROUP BY Meetings.meeting_type;","SELECT meeting_type ,  count(*) FROM Meetings GROUP BY meeting_type","1. Sequential Structure: Start with the SELECT clause to retrieve ""Meetings.meeting_type"" and the count of meetings for each client. Use COUNT to count the number of meetings. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Clients"" and ""Meetings"" tables based on the shared key ""client_id"" to associate each client with their meetings. 4. Aggregation Structure: Use COUNT to count the number of meetings for each client, and GROUP BY ""Meetings.meeting_type"" to group the results by meeting type.",1.0
2011,List the Title and Developers of all games ordered by units sold from large to small.,EASY,video_game,"[game.Title, game.Developers, game.Units_sold_Millions]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT game.Title, game.Developers FROM game ORDER BY game.Units_sold_Millions DESC;","SELECT Title ,  Developers FROM game ORDER BY Units_sold_Millions DESC","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the ""game.Title"" and ""game.Developers"". 2. Condition Structure: No specific filtering condition is required as we want all games. 3. Join Structure: No JOIN is required since all necessary data is within the ""game"" table. 4. Ordering Structure: Use ORDER BY in descending order on ""game.Units_sold_Millions"" to sort the games by units sold from large to small. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data.",1.0
2012,Calculate total weight of package shipped on Mars.,NON-NESTED,planet_1,"[Package.Weight, Shipment.Planet, Shipment.ShipmentID = Package.Shipment, Planet.Name, Shipment.Planet = Planet.PlanetID, Mars]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT SUM(Package.Weight) FROM Package JOIN Shipment ON Shipment.ShipmentID = Package.Shipment JOIN Planet ON Shipment.Planet = Planet.PlanetID WHERE Planet.Name = 'Mars';,"SELECT sum(T1.Weight) FROM PACKAGE AS T1 JOIN Shipment AS T2 ON T1.Shipment = T2.ShipmentID JOIN Planet AS T3 ON T2.Planet = T3.PlanetID WHERE T3.Name = ""Mars"";","1. Sequential Structure: Start with the SELECT clause to calculate the total weight of packages. Use the SUM function on ""Package.Weight"" to compute the total weight. 2. Condition Structure: Use a WHERE clause to filter shipments where the planet is ""Mars."" 3. Join Structure: Use JOINs to connect the ""Package"" table with the ""Shipment"" table on ""Shipment.ShipmentID = Package.Shipment"" and the ""Shipment"" table with the ""Planet"" table on ""Shipment.Planet = Planet.PlanetID"" to associate packages with their respective planets. 4. Aggregation Structure: Use the SUM function to aggregate the weights of packages shipped to Mars.",1.0
2013,How many payments are there for each invoice?,NON-NESTED,advertising_agencies,"[Payments.payment_id,Invoices.invoice_id,Payments.invoice_id = Invoices.invoice_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.invoice_id, COUNT(Payments.payment_id) AS payment_count FROM Payments JOIN Invoices ON Payments.invoice_id = Invoices.invoice_id GROUP BY Invoices.invoice_id;","SELECT invoice_id ,  count(*) FROM Payments GROUP BY invoice_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Invoices.invoice_id"" and the count of ""Payments.payment_id"" for each invoice. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Payments"" and ""Invoices"" tables based on the relationship ""Payments.invoice_id = Invoices.invoice_id"" to associate payments with their respective invoices. 4. Aggregation Structure: Use COUNT on ""Payments.payment_id"" to count the number of payments for each invoice, and GROUP BY ""Invoices.invoice_id"" to group the results by each invoice.",1.0
2014,What is the name of the planet with the most shipments?,NON-NESTED,planet_1,"[Planet.Name, Shipment.Planet, Shipment.Planet = Planet.PlanetID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Planet.Name FROM Planet JOIN Shipment ON Shipment.Planet = Planet.PlanetID GROUP BY Planet.Name ORDER BY COUNT(Shipment.Planet) DESC LIMIT 1;,SELECT T2.Name FROM Shipment AS T1 JOIN Planet AS T2 ON T1.Planet = T2.PlanetID GROUP BY T1.Planet ORDER BY count(*) DESC LIMIT 1;,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Planet.Name"" of the planet with the most shipments. Use an aggregate function (COUNT) to count the number of shipments for each planet. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all shipments. 3. Join Structure: Use a JOIN between the ""Planet"" and ""Shipment"" tables based on the relationship ""Shipment.Planet = Planet.PlanetID"" to associate shipments with their respective planets. 4. Aggregation Structure: Use COUNT to count the number of shipments for each planet, then use ORDER BY in descending order to rank planets by the number of shipments. Use LIMIT 1 to select the planet with the most shipments.",1.0
2015,What are the client id and details for the client with the most invoices?,NON-NESTED,advertising_agencies,"[Clients.client_id,Clients.client_details,Invoices.client_id,Invoices.invoice_id,Invoices.client_id = Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_id, Clients.client_details FROM Clients JOIN Invoices ON Invoices.client_id = Clients.client_id GROUP BY Clients.client_id, Clients.client_details ORDER BY COUNT(Invoices.invoice_id) DESC LIMIT 1;","SELECT T1.client_id ,  T2.client_details FROM Invoices AS T1 JOIN Clients AS T2 ON T1.client_id  =  T2.client_id GROUP BY T1.client_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve ""Clients.client_id"" and ""Clients.client_details."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in the client with the most invoices. 3. Join Structure: Use a JOIN between the ""Clients"" and ""Invoices"" tables based on ""Invoices.client_id = Clients.client_id"" to associate each client with their invoices. 4. Aggregation Structure: Use COUNT on ""Invoices.invoice_id"" to count the number of invoices per client. Use ORDER BY in descending order on the count to rank clients by the number of invoices, and LIMIT 1 to select the client with the most invoices.",1.0
2016,What are the invoice ids and statuses for invoices without a payment?,NESTED,advertising_agencies,"[Invoices.invoice_id, Invoices.invoice_status, Payments.invoice_id = Invoices.invoice_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.invoice_id, Invoices.invoice_status FROM Invoices WHERE Invoices.invoice_id NOT IN (SELECT Payments.invoice_id FROM Payments);","SELECT invoice_id ,  invoice_status FROM Invoices EXCEPT SELECT T1.invoice_id ,  T1.invoice_status FROM Invoices AS T1 JOIN Payments AS T2 ON T1.invoice_id  =  T2.invoice_id","1. Sequential Structure: Start with the SELECT clause to retrieve the invoice IDs and statuses from the Invoices table. Use the FROM clause to specify the Invoices table. Apply a WHERE clause to filter invoices that do not have a corresponding payment in the Payments table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude invoices whose invoice_id appears in the Payments table, indicating they have a payment. 3. Join Structure: Not required, as we only need to filter based on the absence of matching invoice_id entries in the Payments table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
2017,Show all author names and number of documents corresponding to each.,NON-NESTED,cre_Doc_Workflow,"[Authors.author_name, Documents.author_name, Documents.document_id]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Authors.author_name, COUNT(Documents.document_id) AS document_count FROM Authors JOIN Documents ON Authors.author_name = Documents.author_name GROUP BY Authors.author_name;","SELECT author_name ,  count(*) FROM Documents GROUP BY author_name","1. Sequential Structure: Start with the SELECT clause to retrieve ""Authors.author_name"" and the count of ""Documents.document_id"" for each author. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Authors"" and ""Documents"" tables based on the ""author_name"" field to associate each author with their documents. 4. Aggregation Structure: Use COUNT on ""Documents.document_id"" to count the number of documents for each author, and GROUP BY ""Authors.author_name"" to group the results by author.",1.0
2018,Show all invoice status codes and the number of invoices with each status.,EASY,advertising_agencies,"[Invoices.invoice_status, Invoices.invoice_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.invoice_status, COUNT(Invoices.invoice_id) AS invoice_count FROM Invoices GROUP BY Invoices.invoice_status;","SELECT invoice_status ,  count(*) FROM Invoices GROUP BY invoice_status","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the invoice status codes and the count of invoices for each status. 2. Aggregation Structure: Use COUNT to calculate the number of invoices for each status code. 3. Grouping Structure: Use GROUP BY on ""Invoices.invoice_status"" to aggregate the results by each status code. 4. Join Structure: No JOIN is required since all necessary data is within the ""Invoices"" table.",1.0
2019,What are the names of all planets with one employee that has clearance?,NON-NESTED,planet_1,"[Planet.Name, Has_Clearance.Planet, Has_Clearance.Employee, Has_Clearance.Planet = Planet.PlanetID, Has_Clearance.Employee = Employee.EmployeeID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Planet.Name FROM Planet JOIN Has_Clearance ON Has_Clearance.Planet = Planet.PlanetID GROUP BY Planet.PlanetID, Planet.Name HAVING COUNT(Has_Clearance.Employee) = 1;",SELECT T3.Name FROM Has_Clearance AS T1 JOIN Employee AS T2 ON T1.Employee = T2.EmployeeID JOIN Planet AS T3 ON T1.Planet = T3.PlanetID GROUP BY T1.Planet HAVING count(*)  =  1;,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of planets. Since we are looking for planets with exactly one employee that has clearance, we will use a GROUP BY clause on the planet and a HAVING clause to filter for planets with exactly one employee with clearance. 2. Condition Structure: Use a HAVING clause to filter for planets where the count of employees with clearance is exactly one. 3. Join Structure: Use a JOIN between the ""Planet"" table and the ""Has_Clearance"" table on ""Has_Clearance.Planet = Planet.PlanetID"" to associate planets with clearance records. 4. Aggregation Structure: Use COUNT on ""Has_Clearance.Employee"" to count the number of employees with clearance for each planet, and filter using HAVING to ensure the count is exactly one.",1.0
2020,How many authors do we have?,EASY,cre_Doc_Workflow,[Authors.author_name],"Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT COUNT(Authors.author_name) AS total_authors FROM Authors;,SELECT count(*) FROM Authors,"1. Sequential Structure: Start with the SELECT clause to count the number of authors. 2. Condition Structure: No specific filtering condition is required as we want the total count of authors. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Authors"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of authors.",1.0
2021,What are the distinct invoice ids and statuses for all payments?,NON-NESTED,advertising_agencies,"[Payments.invoice_id, Invoices.invoice_id, Invoices.invoice_status, Payments.invoice_id = Invoices.invoice_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT DISTINCT Payments.invoice_id, Invoices.invoice_status FROM Payments JOIN Invoices ON Payments.invoice_id = Invoices.invoice_id;","SELECT DISTINCT T1.invoice_id ,  T1.invoice_status FROM Invoices AS T1 JOIN Payments AS T2 ON T1.invoice_id  =  T2.invoice_id","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""invoice_id"" and ""invoice_status."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Payments"" and ""Invoices"" tables based on the shared key ""invoice_id"" to link payments with their corresponding invoice statuses. 4. Aggregation Structure: Use DISTINCT to ensure unique combinations of ""invoice_id"" and ""invoice_status"" are returned.",1.0
2022,Which planet has total weight of shipment greater than 30? List planet name.,NON-NESTED,planet_1,"[Planet.Name, Package.Weight, Package.Shipment = Shipment.ShipmentID, Shipment.Planet = Planet.PlanetID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Planet.Name FROM Package JOIN Shipment ON Package.Shipment = Shipment.ShipmentID JOIN Planet ON Shipment.Planet = Planet.PlanetID GROUP BY Planet.Name HAVING SUM(Package.Weight) > 30;,SELECT T3.Name FROM PACKAGE AS T1 JOIN Shipment AS T2 ON T1.Shipment = T2.ShipmentID JOIN Planet AS T3 ON T2.Planet = T3.PlanetID GROUP BY T2.Planet HAVING sum(T1.Weight)  >  30;,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Planet.Name."" 2. Condition Structure: Use a HAVING clause to filter for planets where the total weight of shipments exceeds 30. This requires summing up the weights of packages for each planet. 3. Join Structure: Use JOINs to connect the ""Package"" table with the ""Shipment"" table on ""Package.Shipment = Shipment.ShipmentID,"" and then connect the ""Shipment"" table with the ""Planet"" table on ""Shipment.Planet = Planet.PlanetID."" 4. Aggregation Structure: Use SUM on ""Package.Weight"" to calculate the total weight of shipments for each planet, and GROUP BY ""Planet.Name"" to group the results by planet.",1.0
2023,What is the package number and weight of the heaviest package that was sent by a client named John or something similar?,NON-NESTED,planet_1,"[Package.PackageNumber, Package.Weight, Package.Sender, Client.Name, Package.Sender = Client.AccountNumber]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Package.PackageNumber, Package.Weight FROM Package JOIN Client ON Package.Sender = Client.AccountNumber WHERE Client.Name LIKE '%John%' ORDER BY Package.Weight DESC LIMIT 1;","SELECT T1.PackageNumber ,  max(T1.Weight) FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name LIKE ""John"";","1. Sequential Structure: Start with the SELECT clause to retrieve ""Package.PackageNumber"" and ""Package.Weight"" for the heaviest package. Use ORDER BY in descending order on ""Package.Weight"" to rank packages by weight and LIMIT 1 to select the heaviest package. 2. Condition Structure: Use a WHERE clause to filter packages sent by clients whose name is ""John"" or something similar. This requires a condition using a pattern match (e.g., LIKE) on ""Client.Name."" 3. Join Structure: Use a JOIN between the ""Package"" and ""Client"" tables based on the relationship ""Package.Sender = Client.AccountNumber"" to associate packages with their senders. 4. Aggregation Structure: No aggregation is needed, as we are only retrieving the heaviest package.",0.0
2024,How many games are there from each Franchise?,EASY,video_game,"[game.Franchise, game.Game_ID]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT game.Franchise, COUNT(game.Game_ID) AS game_count FROM game GROUP BY game.Franchise;","SELECT Franchise ,  COUNT(*) FROM game GROUP BY Franchise","1. Sequential Structure: Begin with the SELECT clause to specify the franchise and the count of games for each franchise. 2. Aggregation Structure: Use COUNT to calculate the number of games for each franchise. 3. Grouping Structure: Use GROUP BY on ""game.Franchise"" to group the results by each franchise. 4. Join Structure: No JOIN is required since all necessary data is within the ""game"" table.",1.0
2025,What are the names of all planets tjat have a total shipment weight greater than 30?,NON-NESTED,planet_1,"[Planet.Name, Package.Weight, Package.Shipment = Shipment.ShipmentID, Shipment.Planet = Planet.PlanetID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Planet.Name FROM Planet JOIN Shipment ON Shipment.Planet = Planet.PlanetID JOIN Package ON Package.Shipment = Shipment.ShipmentID GROUP BY Planet.Name HAVING SUM(Package.Weight) > 30;,SELECT T3.Name FROM PACKAGE AS T1 JOIN Shipment AS T2 ON T1.Shipment = T2.ShipmentID JOIN Planet AS T3 ON T2.Planet = T3.PlanetID GROUP BY T2.Planet HAVING sum(T1.Weight)  >  30;,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of planets (""Planet.Name""). 2. Condition Structure: Use a HAVING clause to filter for planets where the total shipment weight exceeds 30. This requires summing the weights of packages associated with each planet. 3. Join Structure: Use JOINs to connect the ""Planet,"" ""Shipment,"" and ""Package"" tables. First, join ""Package"" with ""Shipment"" on ""Package.Shipment = Shipment.ShipmentID,"" and then join ""Shipment"" with ""Planet"" on ""Shipment.Planet = Planet.PlanetID."" 4. Aggregation Structure: Use SUM on ""Package.Weight"" to calculate the total shipment weight for each planet, and group by ""Planet.Name"" to aggregate the data by planet.",1.0
2026,How many staff did not attend any meeting?,NESTED,advertising_agencies,"[Staff.staff_id,Staff_in_Meetings.staff_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(*) FROM Staff WHERE staff_id NOT IN (SELECT staff_id FROM Staff_in_Meetings);,SELECT count(*) FROM Staff WHERE staff_id NOT IN ( SELECT staff_id FROM Staff_in_meetings ),"1. Sequential Structure: Start with the SELECT clause to count the number of staff members. Use the FROM clause to specify the Staff table. Apply a WHERE clause to filter staff members who did not attend any meeting by ensuring their staff_id is not present in the Staff_in_Meetings table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude staff members whose staff_id appears in the Staff_in_Meetings table, meaning they attended a meeting. 3. Join Structure: Not required, as we only need to filter based on the absence of matching staff_id entries in the Staff_in_Meetings table. 4. Aggregation Structure: Use COUNT to calculate the total number of staff members who did not attend any meeting.",1.0
2027,What is the name of the author with most number of documents?,NON-NESTED,cre_Doc_Workflow,"[Documents.author_name, Documents.document_id, Documents.author_name = Authors.author_name]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT Documents.author_name FROM Documents GROUP BY Documents.author_name ORDER BY COUNT(Documents.document_id) DESC LIMIT 1;,SELECT author_name FROM Documents GROUP BY author_name ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""author_name"" of the author with the most documents. Use COUNT to count the number of documents for each author. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all authors. 3. Join Structure: No JOIN is required since all the necessary data is available in the ""Documents"" table. 4. Aggregation Structure: Use COUNT on ""Documents.document_id"" to count the number of documents per author. Use GROUP BY to group the results by ""Documents.author_name"" and ORDER BY in descending order to rank authors by the number of documents. Use LIMIT 1 to select the author with the most documents.",1.0
2028,What are ids of agencies that do not have any clients?,NESTED,advertising_agencies,"[Agencies.agency_id, Clients.agency_id, Clients.agency_id = Agencies.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT agency_id FROM Agencies WHERE agency_id NOT IN (SELECT agency_id FROM Clients);,SELECT agency_id FROM Agencies EXCEPT SELECT agency_id FROM Clients,"1. Sequential Structure: Begin with the SELECT clause to retrieve the agency IDs from the Agencies table. Use the FROM clause to specify the Agencies table. Apply a WHERE clause to filter agencies that do not have any clients by ensuring that their agency_id is not present in the Clients table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude agencies whose agency_id appears in the Clients table, meaning they have clients. 3. Join Structure: Not required, as we only need to filter based on the absence of matching agency_id entries in the Clients table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
2029,Return the agency ids and number of staff in each.,NON-NESTED,advertising_agencies,"[Agencies.agency_id, Staff.agency_id, Agencies.agency_id = Staff.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, COUNT(Staff.agency_id) AS number_of_staff FROM Agencies JOIN Staff ON Agencies.agency_id = Staff.agency_id GROUP BY Agencies.agency_id;","SELECT agency_id ,  count(*) FROM Staff GROUP BY agency_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Agencies.agency_id"" and the count of staff members for each agency. Use COUNT to calculate the number of staff. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""Agencies"" table with the ""Staff"" table based on the shared key ""agency_id."" 4. Aggregation Structure: Use COUNT to count the number of staff members for each agency and GROUP BY ""Agencies.agency_id"" to group the results by agency.",1.0
2030,What is the name of the client who sent the most packages and how many were there?,NON-NESTED,planet_1,"[Client.Name, Package.Sender, Package.Sender = Client.AccountNumber]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Client.Name, COUNT(Package.Sender) AS PackageCount FROM Client JOIN Package ON Package.Sender = Client.AccountNumber GROUP BY Client.Name ORDER BY PackageCount DESC LIMIT 1;","SELECT T2.Name ,  count(*) FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber GROUP BY T1.Sender ORDER BY count(*) DESC LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Client.Name"" and the count of packages sent by each client. Use an aggregate function (COUNT) to count the number of packages sent by each client. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all clients who sent packages. 3. Join Structure: Use a JOIN between the ""Client"" and ""Package"" tables based on the relationship ""Package.Sender = Client.AccountNumber"" to associate each package with the corresponding client. 4. Aggregation Structure: Use COUNT to count the number of packages sent by each client, GROUP BY ""Client.Name"" to group the results by client, and ORDER BY the count in descending order to rank clients by the number of packages sent. Use LIMIT 1 to select the client who sent the most packages.",0.0
2031,How many meetings had each meeting outcome?,EASY,advertising_agencies,[Meetings.meeting_outcome],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.meeting_outcome, COUNT(*) AS meeting_count FROM Meetings GROUP BY Meetings.meeting_outcome;","SELECT meeting_outcome ,  count(*) FROM Meetings GROUP BY meeting_outcome","1. Sequential Structure: Begin with the SELECT clause to specify the meeting outcome and the count of meetings for each outcome. 2. Aggregation Structure: Use COUNT to calculate the number of meetings for each meeting outcome. 3. Grouping Structure: Use GROUP BY on ""Meetings.meeting_outcome"" to group the results by each meeting outcome. 4. Join Structure: No JOIN is required since all necessary data is within the ""Meetings"" table.",1.0
2032,Find the number of books for each series.,EASY,book_press,"[book.Book_Series, book.Book_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT book.Book_Series, COUNT(book.Book_ID) AS book_count FROM book GROUP BY book.Book_Series;","SELECT count(*) ,  book_series FROM book GROUP BY book_series","1. Sequential Structure: Begin with the SELECT clause to specify the series name and the count of books in each series. 2. Aggregation Structure: Use COUNT to calculate the number of books for each series. 3. Grouping Structure: Use GROUP BY on ""book.Book_Series"" to aggregate the results by each series. 4. Join Structure: No JOIN is required since all necessary data is within the ""book"" table.",1.0
2033,What is the smallest number of packages received and by whom ?,NON-NESTED,planet_1,"[Package.Recipient, Package.Shipment, Package.PackageNumber, Client.AccountNumber = Package.Recipient]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Package.Recipient, COUNT(Package.PackageNumber) AS PackageCount FROM Package GROUP BY Package.Recipient ORDER BY PackageCount ASC LIMIT 1;","select t2.name ,  count(*) from package as t1 join client as t2 on t1.recipient  =  t2.accountnumber group by t1.recipient order by count(*) limit 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Package.Recipient"" and the smallest number of packages received. Use the MIN function to find the smallest number of packages. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: No JOIN is required since all the necessary data is in the ""Package"" table. 4. Aggregation Structure: Use COUNT to count the number of packages received by each recipient, then use MIN to find the smallest count. Use GROUP BY to group the results by ""Package.Recipient.""",0.0
2034,What is the number of employees that do not have clearance on Mars ?,NESTED,planet_1,"[Employee.EmployeeID,Has_Clearance.Employee,Has_Clearance.Planet,Planet.Name,Has_Clearance.Planet = Planet.PlanetID,Mars]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT COUNT(Employee.EmployeeID) FROM Employee WHERE Employee.EmployeeID NOT IN ( SELECT Has_Clearance.Employee FROM Has_Clearance JOIN Planet ON Has_Clearance.Planet = Planet.PlanetID WHERE Planet.Name = 'Mars' );,"select count(*) from employee where employeeid not in ( select t2.employeeid from has_clearance as t1 join employee as t2 on t1.employee = t2.employeeid join planet as t3 on t1.planet = t3.planetid where t3.name = ""mars"" );",1. Sequential Structure: Start with the SELECT clause to count the number of employees. Use the FROM clause to specify the Employee table. Use a WHERE clause to filter employees who do not have clearance on Mars. 2. Condition Structure: Use a WHERE clause with a subquery to exclude employees who have clearance on Mars. The subquery identifies employees with clearance on Mars by joining the Has_Clearance table with the Planet table and filtering for the planet named 'Mars'. 3. Join Structure: Use a subquery to join the Has_Clearance table with the Planet table on PlanetID to identify employees with clearance on Mars. The main query filters out these employees. 4. Aggregation Structure: Use COUNT to calculate the total number of employees who do not have clearance on Mars.,0.0
2035,How many clients are there for each sic code?,EASY,advertising_agencies,"[Clients.sic_code, Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.sic_code, COUNT(Clients.client_id) AS client_count FROM Clients GROUP BY Clients.sic_code;","SELECT sic_code ,  count(*) FROM Clients GROUP BY sic_code","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the ""sic_code"" and the count of clients. 2. Aggregation Structure: Use COUNT to calculate the number of clients for each ""sic_code"". 3. Grouping Structure: Use GROUP BY on ""Clients.sic_code"" to count clients for each SIC code. 4. Join Structure: No JOIN is required since all necessary data is within the ""Clients"" table.",1.0
2036,What are the client ideas and details for clients with the sic code Bad?,EASY,advertising_agencies,"[Clients.client_id, Clients.client_details, Clients.sic_code, Clients.sic_code = 'Bad']","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_id, Clients.client_details, Clients.sic_code FROM Clients WHERE Clients.sic_code = 'Bad';","SELECT client_id ,  client_details FROM Clients WHERE sic_code  =  ""Bad"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Clients.client_id"", ""Clients.client_details"", and ""Clients.sic_code"" for clients with the specified sic code. 2. Condition Structure: Use a WHERE clause to filter for clients where ""Clients.sic_code"" is equal to 'Bad'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Clients"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
2037,"Show the title of games that are played by both players from college ""Oklahoma"" and players from college ""Auburn"".",NESTED,video_game,"[game.Title,player.College,game_player.Player_ID = player.Player_ID,game_player.Game_ID = game.Game_ID,Oklahoma,Auburn]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT game.Title FROM game JOIN game_player ON game.Game_ID = game_player.Game_ID JOIN player ON game_player.Player_ID = player.Player_ID WHERE game.Game_ID IN ( SELECT game_player.Game_ID FROM game_player JOIN player ON game_player.Player_ID = player.Player_ID WHERE player.College = 'Oklahoma' ) AND game.Game_ID IN ( SELECT game_player.Game_ID FROM game_player JOIN player ON game_player.Player_ID = player.Player_ID WHERE player.College = 'Auburn' );,"SELECT T1.Title FROM game AS T1 JOIN game_player AS T2 ON T1.Game_ID  =  T2.Game_ID JOIN player AS T3 ON T2.Player_ID  =  T3.Player_ID WHERE T3.College  =  ""Oklahoma"" INTERSECT SELECT T1.Title FROM game AS T1 JOIN game_player AS T2 ON T1.Game_ID  =  T2.Game_ID JOIN player AS T3 ON T2.Player_ID  =  T3.Player_ID WHERE T3.College  =  ""Auburn""","1. Sequential Structure: Start with the SELECT clause to retrieve the title of games. Use the FROM clause to specify the game table and join it with the game_player and player tables to connect games with players and their colleges. Apply a WHERE clause to filter games played by players from both ""Oklahoma"" and ""Auburn"". 2. Condition Structure: Use the WHERE clause to filter for players from ""Oklahoma"" and ""Auburn"". Use a subquery to identify games played by players from each college and find the intersection of these games. 3. Join Structure: Use INNER JOINs between the game, game_player, and player tables based on Game_ID and Player_ID to connect games with players and their colleges. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
2038,What is the agent id and details for the agency with most staff?,NON-NESTED,advertising_agencies,"[Agencies.agency_id,Agencies.agency_details,Staff.agency_id,Staff.staff_id,Staff.agency_id = Agencies.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, Agencies.agency_details FROM Agencies JOIN Staff ON Agencies.agency_id = Staff.agency_id GROUP BY Agencies.agency_id, Agencies.agency_details ORDER BY COUNT(Staff.staff_id) DESC LIMIT 1;","SELECT T1.agency_id ,  T2.agency_details FROM Staff AS T1 JOIN Agencies AS T2 ON T1.agency_id  =  T2.agency_id GROUP BY T1.agency_id ORDER BY count(*) DESC LIMIT 1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Agencies.agency_id"" and ""Agencies.agency_details"" for the agency with the most staff. Use COUNT to count the number of staff members for each agency. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the agency with the most staff. 3. Join Structure: Use a JOIN between the ""Agencies"" and ""Staff"" tables based on the shared key ""agency_id"" to associate staff members with their respective agencies. 4. Aggregation Structure: Use COUNT to count the number of staff members per agency, then use ORDER BY in descending order to rank agencies by staff count. Use LIMIT 1 to select the agency with the most staff.",1.0
2039,Show the other details for the author Addison Denesik.,NON-NESTED,cre_Doc_Workflow,"[Authors.other_details,Authors.author_name,Documents.author_name = Authors.author_name,Addison Denesik]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT Authors.other_details FROM Authors WHERE Authors.author_name = 'Addison Denesik';,"SELECT other_details FROM Authors WHERE author_name  =  ""Addison Denesik""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Authors.other_details"" field for the specified author. 2. Condition Structure: Use a WHERE clause to filter for the author whose name is ""Addison Denesik."" 3. Join Structure: No JOIN is required since the information is available in the ""Authors"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific details for a single author.",1.0
2040,How many documents have a process?,NON-NESTED,cre_Doc_Workflow,"[Documents.document_id,Documents_Processes.document_id,Documents_Processes.process_id]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT COUNT(Documents.document_id) FROM Documents JOIN Documents_Processes ON Documents.document_id = Documents_Processes.document_id;,SELECT count(DISTINCT document_id) FROM Documents_processes,"1. Sequential Structure: Start with the SELECT clause to count the number of documents that have a process. Use COUNT on ""Documents.document_id"" to get the total count. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all documents that have a process. 3. Join Structure: Use an INNER JOIN between the ""Documents"" table and the ""Documents_Processes"" table on ""Documents.document_id"" to ensure we only count documents that are associated with a process. 4. Aggregation Structure: Use COUNT to aggregate the number of documents that have a process.",1.0
2041,Show the names for authors with at least two documents.,NON-NESTED,cre_Doc_Workflow,"[Authors.author_name, Documents.author_name, Documents.document_id]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT Authors.author_name FROM Authors JOIN Documents ON Authors.author_name = Documents.author_name GROUP BY Authors.author_name HAVING COUNT(Documents.document_id) >= 2;,SELECT author_name FROM Documents GROUP BY author_name HAVING count(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Authors.author_name."" 2. Condition Structure: Use a HAVING clause to filter for authors who have at least two documents. This requires counting the number of documents associated with each author. 3. Join Structure: Use a JOIN between the ""Authors"" and ""Documents"" tables based on the ""author_name"" field to associate authors with their documents. 4. Aggregation Structure: Use COUNT on ""Documents.document_id"" to count the number of documents per author, then filter with HAVING to select authors with at least two documents.",1.0
2042,List package number of packages shipped in Omicron Persei 8 planet or sent by Zapp Brannigan.,NON-NESTED,planet_1,"[Package.PackageNumber,Shipment.Planet,Planet.Name,Package.Sender,Client.Name,Shipment.ShipmentID = Package.Shipment,Shipment.Planet = Planet.PlanetID,Package.Sender = Client.AccountNumber]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Package.PackageNumber FROM Package JOIN Shipment ON Shipment.ShipmentID = Package.Shipment JOIN Planet ON Shipment.Planet = Planet.PlanetID JOIN Client ON Package.Sender = Client.AccountNumber WHERE Planet.Name = 'Omicron Persei 8' OR Client.Name = 'Zapp Brannigan';,"SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON  T1.Sender = T2.AccountNumber JOIN Shipment AS T3 ON T1.Shipment = T3.ShipmentID JOIN Planet AS T4 ON T3.Planet = T4.PlanetID WHERE T2.Name  =  ""Zapp Brannigan"" OR T4.Name  =  ""Omicron Persei 8"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Package.PackageNumber"" field, as the question asks for the package numbers. 2. Condition Structure: Use a WHERE clause to filter for packages shipped to the planet ""Omicron Persei 8"" or sent by the client ""Zapp Brannigan."" 3. Join Structure: Use JOINs to connect the ""Package"" table with the ""Shipment"" table on ""Shipment.ShipmentID = Package.Shipment,"" the ""Planet"" table on ""Shipment.Planet = Planet.PlanetID,"" and the ""Client"" table on ""Package.Sender = Client.AccountNumber"" to access the relevant fields for filtering. 4. Aggregation Structure: No aggregation is needed, as the query only retrieves package numbers based on the specified conditions.",1.0
2043,Show all agency ids without any client.,NESTED,advertising_agencies,"[Agencies.agency_id,Clients.agency_id,Agencies.agency_id = Clients.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT agency_id FROM Agencies WHERE agency_id NOT IN (SELECT agency_id FROM Clients);,SELECT agency_id FROM Agencies EXCEPT SELECT agency_id FROM Clients,"1. Sequential Structure: Start with the SELECT clause to retrieve all agency IDs from the Agencies table. Use the FROM clause to specify the Agencies table. Apply a WHERE clause to filter out agencies that have clients by ensuring their agency_id is not present in the Clients table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude agencies whose agency_id appears in the Clients table, meaning they have clients. 3. Join Structure: Not required, as we only need to filter based on the absence of matching agency_id entries in the Clients table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
2044,What are the names of the publishers that made more than 15 billion profits each year or 1 billion each month?,EASY,book_press,"[press.Name, press.Year_Profits_billion, press.Month_Profits_billion]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT press.Name FROM press WHERE press.Year_Profits_billion > 15 OR press.Month_Profits_billion > 1;,SELECT name FROM press WHERE Year_Profits_billion  >  15 OR Month_Profits_billion  >  1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the publisher name (""press.Name""). 2. Condition Structure: Use a WHERE clause to filter for publishers whose yearly profits are greater than 15 billion or monthly profits are greater than 1 billion. 3. Join Structure: No JOIN is required since all necessary data is within the ""press"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving publisher names based on specific conditions.",1.0
2045,How many invoices are there for each status code?,EASY,advertising_agencies,"[Invoices.invoice_id, Invoices.invoice_status]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.invoice_status, COUNT(Invoices.invoice_id) AS invoice_count FROM Invoices GROUP BY Invoices.invoice_status;","SELECT invoice_status ,  count(*) FROM Invoices GROUP BY invoice_status","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the status code and the count of invoices. 2. Aggregation Structure: Use COUNT to calculate the number of invoices for each status code. 3. Grouping Structure: Use GROUP BY on ""Invoices.invoice_status"" to count invoices by each status code. 4. Join Structure: No JOIN is required since all needed data is within the ""Invoices"" table.",1.0
2046,"What are the invoice status, invoice details, and corresponding client ids and details and agency id and details?",NON-NESTED,advertising_agencies,"[Invoices.invoice_status, Invoices.invoice_details, Invoices.client_id = Clients.client_id, Clients.client_details, Clients.agency_id = Agencies.agency_id, Agencies.agency_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.invoice_status, Invoices.invoice_details, Clients.client_id, Clients.client_details, Agencies.agency_id, Agencies.agency_details FROM Invoices JOIN Clients ON Invoices.client_id = Clients.client_id JOIN Agencies ON Clients.agency_id = Agencies.agency_id;","SELECT T1.invoice_status ,  T1.invoice_details ,  T2.client_id ,  T2.client_details ,  T3.agency_id ,  T3.agency_details FROM Invoices AS T1 JOIN Clients AS T2 ON T1.client_id  =  T2.client_id JOIN Agencies AS T3 ON T2.agency_id  =  T3.agency_id","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Invoices.invoice_status,"" ""Invoices.invoice_details,"" ""Clients.client_id,"" ""Clients.client_details,"" ""Agencies.agency_id,"" and ""Agencies.agency_details."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOIN clauses to connect the ""Invoices"" table with the ""Clients"" table on ""Invoices.client_id = Clients.client_id"" and the ""Clients"" table with the ""Agencies"" table on ""Clients.agency_id = Agencies.agency_id."" 4. Aggregation Structure: No aggregation is required as the query is retrieving detailed information without any summarization.",1.0
2047,List the codes and descriptions for all staff roles.,EASY,cre_Doc_Workflow,"[Ref_Staff_Roles.staff_role_code, Ref_Staff_Roles.staff_role_description]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Ref_Staff_Roles.staff_role_code, Ref_Staff_Roles.staff_role_description FROM Ref_Staff_Roles;","SELECT staff_role_code ,  staff_role_description FROM Ref_staff_roles","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Ref_Staff_Roles.staff_role_code"" and ""Ref_Staff_Roles.staff_role_description"". 2. Condition Structure: No specific filtering condition is required as the query asks for all staff roles. 3. Join Structure: No JOIN is required since all necessary data is within the ""Ref_Staff_Roles"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all rows from the table.",1.0
2048,Return the names and ids of all platforms with the download rank of 1.,EASY,video_game,"[platform.Platform_name, platform.Platform_ID, platform.Download_rank, 1]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT platform.Platform_name, platform.Platform_ID FROM platform WHERE platform.Download_rank = 1;","SELECT Platform_name ,  Platform_ID FROM platform WHERE Download_rank  =  1","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the platform names and their IDs. 2. Condition Structure: Use a WHERE clause to filter platforms with a download rank of 1. 3. Join Structure: No JOIN is required since all necessary data is within the ""platform"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving platform names and IDs based on a specific condition.",1.0
2049,Please list the title of games with platforms that have market district in Asia or USA.,NON-NESTED,video_game,"[game.Title,platform.Market_district,game.Platform_ID = platform.Platform_ID,Asia,USA]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT game.Title FROM game JOIN platform ON game.Platform_ID = platform.Platform_ID WHERE platform.Market_district = 'Asia' OR platform.Market_district = 'USA';,"SELECT T1.Title FROM game AS T1 JOIN platform AS T2 ON T1.Platform_ID  =  T2.Platform_ID WHERE T2.Market_district  =  ""Asia"" OR T2.Market_district  =  ""USA""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""game.Title."" 2. Condition Structure: Use a WHERE clause to filter for platforms with a ""Market_district"" in either Asia or USA. 3. Join Structure: Use a JOIN between the ""game"" and ""platform"" tables based on the shared key ""Platform_ID"" to associate each game with its platform details. 4. Aggregation Structure: No aggregation is needed as the query only requires listing game titles.",1.0
2050,Count the number of staff.,EASY,advertising_agencies,[Staff.staff_id],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(Staff.staff_id) AS staff_count FROM Staff;,SELECT count(*) FROM Staff,"1. Sequential Structure: Begin with the SELECT clause to count the number of staff members. 2. Aggregation Structure: Use the COUNT function to calculate the total number of staff entries. 3. Condition Structure: No specific filtering condition is required as we want to count all staff members. 4. Join Structure: No JOIN is necessary since all required data is within the ""Staff"" table.",1.0
2051,List all book titles in the order of their release date from the most recent to the past.,EASY,book_press,"[book.Title, book.Release_date]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT book.Title FROM book ORDER BY book.Release_date DESC;,SELECT title FROM book ORDER BY release_date DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the book title. 2. Ordering Structure: Use ORDER BY on ""book.Release_date"" in descending order to sort the books from the most recent to the past. 3. Condition Structure: No specific filtering condition is required as we want all book titles. 4. Join Structure: No JOIN is required since all necessary data is within the ""book"" table. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the book titles.",1.0
2052,Find the name of the publisher whose monthly profit is the highest.,EASY,book_press,"[press.Name, press.Month_Profits_billion]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT press.Name FROM press ORDER BY press.Month_Profits_billion DESC LIMIT 1;,SELECT name FROM press ORDER BY Month_Profits_billion DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""press.Name"" of the publisher with the highest monthly profit. 2. Condition Structure: No specific filtering condition is needed since we are looking for the publisher with the maximum monthly profit. 3. Join Structure: No JOIN is required, as all necessary information is available in the ""press"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""press.Month_Profits_billion"" to rank publishers by their monthly profits and apply LIMIT 1 to select the publisher with the highest profit.",1.0
2053,Show the number of staff roles.,EASY,cre_Doc_Workflow,"[Ref_Staff_Roles.staff_role_code, Ref_Staff_Roles.staff_role_description]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT COUNT(DISTINCT Ref_Staff_Roles.staff_role_code) AS number_of_staff_roles FROM Ref_Staff_Roles;,SELECT count(*) FROM Ref_staff_roles,"1. Sequential Structure: Begin with the SELECT clause to count the number of distinct staff roles. 2. Aggregation Structure: Use COUNT with DISTINCT on ""Ref_Staff_Roles.staff_role_code"" to count the unique staff roles. 3. Condition Structure: No specific filtering condition is required as we want the total count of staff roles. 4. Join Structure: No JOIN is necessary since all relevant information is available in the ""Ref_Staff_Roles"" table.",1.0
2054,What are the agency details for clients with the detail Mac?,NON-NESTED,advertising_agencies,"[Agencies.agency_details, Clients.client_details, Clients.agency_id = Agencies.agency_id, Mac]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT Agencies.agency_details FROM Clients JOIN Agencies ON Clients.agency_id = Agencies.agency_id WHERE Clients.client_details = 'Mac';,SELECT T2.agency_details FROM Clients AS T1 JOIN Agencies AS T2 ON T1.agency_id  =  T2.agency_id WHERE T1.client_details  =  'Mac',"1. Sequential Structure: Start with the SELECT clause to retrieve ""Agencies.agency_details"" as the question asks for agency details. 2. Condition Structure: Use a WHERE clause to filter for clients whose ""Clients.client_details"" contain the detail ""Mac."" 3. Join Structure: Use an INNER JOIN between the ""Clients"" and ""Agencies"" tables based on the relationship ""Clients.agency_id = Agencies.agency_id"" to link clients with their respective agencies. 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving specific details without summarization.",1.0
2055,What is the name of all clients who sent more than one package?,NON-NESTED,planet_1,"[Client.Name, Package.Sender, Package.Sender = Client.AccountNumber]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT DISTINCT Client.Name FROM Client JOIN Package ON Package.Sender = Client.AccountNumber GROUP BY Client.AccountNumber HAVING COUNT(Package.Sender) > 1;,"SELECT T2.Name ,  count(*) FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber GROUP BY T1.Sender HAVING count(*)  >  1;","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of clients. Use COUNT to count the number of packages sent by each client. 2. Condition Structure: Apply a HAVING clause to filter for clients who sent more than one package. 3. Join Structure: Use a JOIN between the ""Client"" and ""Package"" tables based on ""Package.Sender"" and ""Client.AccountNumber"" to associate each package with its sender. 4. Aggregation Structure: Use COUNT on ""Package.Sender"" to count the number of packages sent by each client, then filter with HAVING to select clients who sent more than one package.",0.0
2056,What is the process outcome description and process status description for the document with id 0?,NON-NESTED,cre_Doc_Workflow,"[Process_Outcomes.process_outcome_description, Process_Status.process_status_description, Documents_Processes.document_id, Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code, Documents_Processes.process_status_code = Process_Status.process_status_code, Documents_Processes.document_id = Documents.document_id, Documents.document_id, 0]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Process_Outcomes.process_outcome_description, Process_Status.process_status_description FROM Documents_Processes JOIN Documents ON Documents_Processes.document_id = Documents.document_id JOIN Process_Outcomes ON Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code JOIN Process_Status ON Documents_Processes.process_status_code = Process_Status.process_status_code WHERE Documents.document_id = 0;","SELECT T2.process_outcome_description ,  T3.process_status_description FROM Documents_processes AS T1 JOIN Process_outcomes AS T2 ON T1.process_outcome_code  =  T2.process_outcome_code JOIN Process_Status AS T3 ON T1.process_status_code  =  T3.process_status_code WHERE T1.document_id  =  0","1. Sequential Structure: Start with the SELECT clause to retrieve ""Process_Outcomes.process_outcome_description"" and ""Process_Status.process_status_description."" 2. Condition Structure: Use a WHERE clause to filter for the document with ""Documents.document_id = 0."" 3. Join Structure: Use JOINs to connect the ""Documents_Processes"" table with the ""Documents"" table on ""Documents_Processes.document_id = Documents.document_id,"" then join ""Documents_Processes"" with ""Process_Outcomes"" on ""Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,"" and finally join ""Documents_Processes"" with ""Process_Status"" on ""Documents_Processes.process_status_code = Process_Status.process_status_code."" 4. Aggregation Structure: No aggregation is needed as the query retrieves specific descriptions for a single document.",1.0
2057,What are all meeting outcomes and purposes?,EASY,advertising_agencies,"[Meetings.meeting_outcome, Meetings.purpose_of_meeting]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.meeting_outcome, Meetings.purpose_of_meeting FROM Meetings;","SELECT meeting_outcome ,  purpose_of_meeting FROM meetings","1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""Meetings.meeting_outcome"" and ""Meetings.purpose_of_meeting"" as the question asks for all meeting outcomes and purposes. 2. Condition Structure: No specific filtering condition is required since the query aims to retrieve all records. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Meetings"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all meeting outcomes and purposes.",1.0
2058,What are all the client ids and details?,EASY,advertising_agencies,"[Clients.client_id, Clients.client_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_id, Clients.client_details FROM Clients;","SELECT client_id ,  client_details FROM Clients","1. Sequential Structure: Start with the SELECT clause to retrieve all the fields related to client IDs and their details. 2. Condition Structure: No specific filtering condition is required as the query asks for all client IDs and their details. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""Clients"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all client IDs and their details.",1.0
2059,Show all the different invoice ids and statuses of the payments,NON-NESTED,advertising_agencies,"[Payments.invoice_id, Invoices.invoice_status, Payments.invoice_id = Invoices.invoice_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT DISTINCT Payments.invoice_id, Invoices.invoice_status FROM Payments JOIN Invoices ON Payments.invoice_id = Invoices.invoice_id;","SELECT DISTINCT T1.invoice_id ,  T1.invoice_status FROM Invoices AS T1 JOIN Payments AS T2 ON T1.invoice_id  =  T2.invoice_id","1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Payments.invoice_id"" and ""Invoices.invoice_status."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Payments"" and ""Invoices"" tables based on the shared key ""Payments.invoice_id = Invoices.invoice_id"" to link each payment with its corresponding invoice status. 4. Aggregation Structure: Use DISTINCT to ensure that only unique combinations of ""invoice_id"" and ""invoice_status"" are returned.",1.0
2060,What are the shipment IDs of every delivery managed by Phillip J Fry?,NON-NESTED,planet_1,"[Shipment.ShipmentID,Shipment.Manager,Employee.Name,Shipment.Manager = Employee.EmployeeID,Phillip J Fry]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Shipment.ShipmentID FROM Shipment JOIN Employee ON Shipment.Manager = Employee.EmployeeID WHERE Employee.Name = 'Phillip J Fry';,"SELECT T1.ShipmentID FROM Shipment AS T1 JOIN Employee AS T2 ON T1.Manager = T2.EmployeeID WHERE T2.Name = ""Phillip J. Fry"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Shipment.ShipmentID"" field, as the question asks for shipment IDs. 2. Condition Structure: Use a WHERE clause to filter for shipments managed by ""Phillip J Fry."" This requires matching the ""Shipment.Manager"" field with the ""Employee.EmployeeID"" where the ""Employee.Name"" is ""Phillip J Fry."" 3. Join Structure: Use a JOIN between the ""Shipment"" and ""Employee"" tables based on the relationship ""Shipment.Manager = Employee.EmployeeID"" to link shipments with their respective managers. 4. Aggregation Structure: No aggregation is needed, as the query only retrieves shipment IDs.",0.0
2061,Return the ids and details of staff who have attended at least 1 meeting and have an s in their staff details?,NON-NESTED,advertising_agencies,"[Staff.staff_id, Staff.staff_details, Staff_in_Meetings.staff_id = Staff.staff_id, Staff_in_Meetings.meeting_id = Meetings.meeting_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT DISTINCT Staff.staff_id, Staff.staff_details FROM Staff JOIN Staff_in_Meetings ON Staff.staff_id = Staff_in_Meetings.staff_id WHERE Staff.staff_details LIKE '%s%';","SELECT staff_id ,  staff_details FROM staff WHERE staff_details LIKE ""%s%"" GROUP BY staff_id HAVING count(*)  >=  1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""staff_id"" and ""staff_details"" of staff members. 2. Condition Structure: Use a WHERE clause to filter for staff members whose ""staff_details"" contain the letter 's' and who have attended at least one meeting. The condition for attending at least one meeting will be implemented using a subquery or a JOIN. 3. Join Structure: Use a JOIN between the ""Staff"" and ""Staff_in_Meetings"" tables on ""Staff.staff_id"" to identify staff members who have attended meetings. Additionally, the ""Staff_in_Meetings"" table is linked to the ""Meetings"" table via ""meeting_id,"" but this is not directly needed for the query since we only care about attendance. 4. Aggregation Structure: No aggregation is required, but DISTINCT is applied to ensure unique staff records are returned.",0.0
2062,"What are the names and colleges of all players, ordered by rank of year descending?",EASY,video_game,"[player.Player_name, player.College, player.Rank_of_the_year]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT player.Player_name, player.College FROM player ORDER BY player.Rank_of_the_year DESC;","SELECT Player_name ,  College FROM player ORDER BY Rank_of_the_year DESC","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""player.Player_name"" and ""player.College"". 2. Condition Structure: No specific filtering condition is required as we want all players and their colleges. 3. Join Structure: No JOIN is required since all necessary information is available in the ""player"" table. 4. Ordering Structure: Use ORDER BY in descending order on ""player.Rank_of_the_year"" to sort the results by rank of the year. 5. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data.",1.0
2063,Show all payment ids and details for invoices whose status is 'Working'.,NON-NESTED,advertising_agencies,"[Payments.payment_id, Payments.payment_details, Invoices.invoice_status, Payments.invoice_id = Invoices.invoice_id, Working]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Payments.payment_id, Payments.payment_details FROM Payments JOIN Invoices ON Payments.invoice_id = Invoices.invoice_id WHERE Invoices.invoice_status = 'Working';","SELECT T1.payment_id ,  T1.payment_details FROM Payments AS T1 JOIN Invoices AS T2 ON T1.invoice_id  =  T2.invoice_id WHERE T2.invoice_status  =  'Working'","1. Sequential Structure: Start with the SELECT clause to retrieve ""Payments.payment_id"" and ""Payments.payment_details."" 2. Condition Structure: Use a WHERE clause to filter for invoices where ""Invoices.invoice_status"" is 'Working.' 3. Join Structure: Use a JOIN between the ""Payments"" and ""Invoices"" tables based on the relationship ""Payments.invoice_id = Invoices.invoice_id"" to link payments with their corresponding invoices. 4. Aggregation Structure: No aggregation is needed as the query requires all matching records without any summarization.",1.0
2064,Find the name and age of the authors who do not have any book in the record.,NESTED,book_press,"[author.Name, author.Age, book.Author_ID, author.Author_ID = book.Author_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT author.Name, author.Age FROM author WHERE author.Author_ID NOT IN (SELECT book.Author_ID FROM book);","SELECT name ,  age FROM author WHERE author_id NOT IN (SELECT author_id FROM book)","1. Sequential Structure: Start with the SELECT clause to retrieve the name and age of authors. Use the FROM clause to specify the author table. Apply a WHERE clause to filter authors who do not have any book in the record by ensuring their Author_ID is not present in the book table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude authors whose Author_ID appears in the book table, meaning they have books in the record. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Author_ID entries in the book table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
2065,"What are the meeting ids, meeting outcomes, meeting types, and client details for all meetings?",NON-NESTED,advertising_agencies,"[Meetings.meeting_id, Meetings.meeting_outcome, Meetings.meeting_type, Clients.client_details, Meetings.client_id = Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.meeting_id, Meetings.meeting_outcome, Meetings.meeting_type, Clients.client_details FROM Meetings JOIN Clients ON Meetings.client_id = Clients.client_id;","SELECT T1.meeting_id ,  T1.meeting_outcome ,  T1.meeting_type ,  T2.client_details FROM meetings AS T1 JOIN clients AS T2 ON T1.client_id  =  T2.client_id","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Meetings.meeting_id,"" ""Meetings.meeting_outcome,"" ""Meetings.meeting_type,"" and ""Clients.client_details."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Meetings"" and ""Clients"" tables based on the relationship ""Meetings.client_id = Clients.client_id"" to link each meeting with its corresponding client details. 4. Aggregation Structure: No aggregation is required as the query simply retrieves all relevant data without summarization.",1.0
2066,Show the title of games that are not played by any player who is in the Guard position.,NESTED,video_game,"[game.Title,player.Position,game_player.Player_ID = player.Player_ID,game_player.Game_ID = game.Game_ID,Guard]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT game.Title FROM game WHERE game.Game_ID NOT IN ( SELECT game_player.Game_ID FROM game_player JOIN player ON game_player.Player_ID = player.Player_ID WHERE player.Position = 'Guard' );,"SELECT Title FROM game EXCEPT SELECT T1.Title FROM game AS T1 JOIN game_player AS T2 ON T1.Game_ID  =  T2.Game_ID JOIN player AS T3 ON T2.Player_ID  =  T3.Player_ID WHERE T3.Position  =  ""Guard""","1. Sequential Structure: Start with the SELECT clause to retrieve the title of games. Use the FROM clause to specify the game table. Apply a WHERE clause to filter games that are not played by any player in the Guard position. 2. Condition Structure: Use the WHERE clause with a subquery to exclude games that are associated with players in the Guard position. The subquery identifies all game IDs linked to players in the Guard position. 3. Join Structure: Use INNER JOINs between the game, game_player, and player tables to connect games with players and their positions. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
2067,What are the client details for each client and the corresponding details of their agencies?,NON-NESTED,advertising_agencies,"[Clients.client_details,Agencies.agency_details,Clients.agency_id = Agencies.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_details, Agencies.agency_details FROM Clients JOIN Agencies ON Clients.agency_id = Agencies.agency_id;","SELECT T1.client_details ,  T2.agency_details FROM Clients AS T1 JOIN Agencies AS T2 ON T1.agency_id  =  T2.agency_id","1. Sequential Structure: Start with the SELECT clause to retrieve the client details from the ""Clients"" table and the agency details from the ""Agencies"" table. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to combine the ""Clients"" and ""Agencies"" tables based on the shared key ""agency_id"" to link each client with their corresponding agency. 4. Aggregation Structure: No aggregation is required as the query is focused on retrieving details for each client and their corresponding agency.",1.0
2068,What are all meeting types and other details?,EASY,advertising_agencies,"[Meetings.meeting_type, Meetings.other_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.meeting_type, Meetings.other_details FROM Meetings;","SELECT meeting_type ,  other_details FROM meetings","1. Sequential Structure: Start with the SELECT clause to retrieve all meeting types and their corresponding other details. 2. Condition Structure: No specific filtering condition is required as the query asks for all meeting types and their details. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""Meetings"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all records from the table.",1.0
2069,find the average age of authors for each gender.,EASY,book_press,"[author.Age, author.Gender]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT author.Gender, AVG(author.Age) AS avg_age FROM author GROUP BY author.Gender;","SELECT avg(age) ,  gender FROM author GROUP BY gender","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the gender and the average age of authors. 2. Aggregation Structure: Use the AVG function to calculate the average age of authors for each gender. 3. Grouping Structure: Use GROUP BY on ""author.Gender"" to calculate the average age for each gender. 4. Join Structure: No JOIN is required since all necessary data is within the ""author"" table.",1.0
2070,How many clients does each agency have?,NON-NESTED,advertising_agencies,"[Clients.agency_id,Agencies.agency_id,Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, COUNT(Clients.client_id) AS client_count FROM Agencies JOIN Clients ON Agencies.agency_id = Clients.agency_id GROUP BY Agencies.agency_id;","SELECT agency_id ,  count(*) FROM Clients GROUP BY agency_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""agency_id"" from the ""Agencies"" table and the count of ""client_id"" from the ""Clients"" table. Use COUNT to calculate the number of clients for each agency. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""Clients"" table with the ""Agencies"" table based on the shared ""agency_id"" field. 4. Aggregation Structure: Use COUNT on ""Clients.client_id"" to count the number of clients for each agency, and GROUP BY ""Agencies.agency_id"" to group the results by each agency.",1.0
2071,How many business processes do we have?,EASY,cre_Doc_Workflow,[Business_Processes.process_id],"Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT COUNT(Business_Processes.process_id) AS total_processes FROM Business_Processes;,SELECT count(*) FROM Business_processes,"1. Sequential Structure: Start with the SELECT clause to count the number of business processes. 2. Aggregation Structure: Use the COUNT function to calculate the total number of process IDs in the ""Business_Processes"" table. 3. Condition Structure: No specific filtering condition is required as we want the total count of all business processes. 4. Join Structure: No JOIN is necessary since all required data is within the ""Business_Processes"" table.",1.0
2072,What are the package numbers and weights that are between 10 and 30?,EASY,planet_1,"[Package.PackageNumber, Package.Weight, 10, 30]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Package.PackageNumber, Package.Weight FROM Package WHERE Package.Weight BETWEEN 10 AND 30;","SELECT PackageNumber ,  Weight FROM PACKAGE WHERE Weight BETWEEN 10 AND 30;","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Package.PackageNumber"" and ""Package.Weight"". 2. Condition Structure: Use a WHERE clause to filter packages where the weight is between 10 and 30. 3. Join Structure: No JOIN is required since all necessary information is in the ""Package"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving package numbers and weights that meet the specified condition.",1.0
2073,What are the package contents of all those sent by John Zoidfarb?,NON-NESTED,planet_1,"[Package.Contents,Package.Sender,Client.Name,Package.Sender = Client.AccountNumber,John Zoidfarb]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Package.Contents FROM Package JOIN Client ON Package.Sender = Client.AccountNumber WHERE Client.Name = 'John Zoidfarb';,"SELECT T1.Contents FROM PACKAGE AS T1 JOIN Client AS T2 ON T1.Sender  =  T2.AccountNumber WHERE T2.Name  =  ""John Zoidfarb"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Package.Contents"" field, as the question asks for the package contents. 2. Condition Structure: Use a WHERE clause to filter for packages sent by ""John Zoidfarb."" This requires identifying the sender's account number from the ""Client"" table where the name matches ""John Zoidfarb."" 3. Join Structure: Use a JOIN between the ""Package"" table and the ""Client"" table on the relationship ""Package.Sender = Client.AccountNumber"" to link packages with their respective senders. 4. Aggregation Structure: No aggregation is needed, as the query only retrieves the package contents for a specific sender.",1.0
2074,What is the process name for the next process of the process with id 9?,EASY,cre_Doc_Workflow,"[Business_Processes.process_name, Business_Processes.next_process_id, Business_Processes.process_id = 9]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT bp2.process_name FROM Business_Processes AS bp1 JOIN Business_Processes AS bp2 ON bp1.next_process_id = bp2.process_id WHERE bp1.process_id = 9;,SELECT process_name FROM Business_processes WHERE process_id  =  (SELECT next_process_id FROM Business_processes WHERE process_id  =  9),"1. Sequential Structure: Start with the SELECT clause to retrieve the ""process_name"" of the next process. 2. Condition Structure: Use a WHERE clause to filter for the process with ""process_id = 9"" and retrieve its ""next_process_id"". 3. Join Structure: Use a self-join on the ""Business_Processes"" table to match the ""next_process_id"" of the current process with the ""process_id"" of the next process. 4. Aggregation Structure: No aggregation is needed, as we are retrieving a single field based on a specific condition.",1.0
2075,Show all invoice status codes and details and the corresponding client id and details and agency id and details.,NON-NESTED,advertising_agencies,"[Invoices.invoice_status, Invoices.invoice_details, Invoices.client_id = Clients.client_id, Clients.client_id, Clients.client_details, Clients.agency_id = Agencies.agency_id, Agencies.agency_id, Agencies.agency_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.invoice_status, Invoices.invoice_details, Clients.client_id, Clients.client_details, Agencies.agency_id, Agencies.agency_details FROM Invoices JOIN Clients ON Invoices.client_id = Clients.client_id JOIN Agencies ON Clients.agency_id = Agencies.agency_id;","SELECT T1.invoice_status ,  T1.invoice_details ,  T2.client_id ,  T2.client_details ,  T3.agency_id ,  T3.agency_details FROM Invoices AS T1 JOIN Clients AS T2 ON T1.client_id  =  T2.client_id JOIN Agencies AS T3 ON T2.agency_id  =  T3.agency_id","1. Sequential Structure: Start with the SELECT clause to retrieve all relevant fields: ""Invoices.invoice_status,"" ""Invoices.invoice_details,"" ""Clients.client_id,"" ""Clients.client_details,"" ""Agencies.agency_id,"" and ""Agencies.agency_details."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOIN clauses to connect the ""Invoices"" table with the ""Clients"" table on ""Invoices.client_id = Clients.client_id"" and the ""Clients"" table with the ""Agencies"" table on ""Clients.agency_id = Agencies.agency_id."" 4. Aggregation Structure: No aggregation is required as the query is retrieving detailed information without summarization.",1.0
2076,How many clients are there?,EASY,advertising_agencies,[Clients.client_id],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(Clients.client_id) AS total_clients FROM Clients;,SELECT count(*) FROM Clients,"1. Sequential Structure: Begin with the SELECT clause to count the number of clients. 2. Aggregation Structure: Use the COUNT function to calculate the total number of clients based on their unique ""client_id"". 3. Join Structure: No JOIN is required since all necessary data is within the ""Clients"" table. 4. Condition Structure: No specific filtering condition is needed as we want the total count of all clients.",1.0
2077,"Which authors publish books in both ""MM"" and ""LT"" series? Give me the author names.",NESTED,book_press,"[author.Name,book.Book_Series,book.Author_ID = author.Author_ID,MM,LT]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT author.Name FROM author JOIN book ON author.Author_ID = book.Author_ID WHERE book.Book_Series IN ('MM', 'LT') GROUP BY author.Author_ID, author.Name HAVING COUNT(DISTINCT book.Book_Series) = 2;",SELECT t1.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id WHERE t2.book_series  =  'MM' INTERSECT SELECT t1.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id WHERE t2.book_series  =  'LT',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors. Use the FROM clause to specify the author table and JOIN it with the book table to link authors with their books. Apply a WHERE clause to filter authors who have published books in both ""MM"" and ""LT"" series. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the author has books in both ""MM"" and ""LT"" series. This can be achieved by grouping by the author and checking the count of distinct series they have published in. 3. Join Structure: Use an INNER JOIN between the author and book tables based on the Author_ID to connect authors with their books. 4. Aggregation Structure: Use GROUP BY to group records by author and apply a HAVING clause to filter authors who have published in both ""MM"" and ""LT"" series.",1.0
2078,What is the description for the process outcome code working?,EASY,cre_Doc_Workflow,"[Process_Outcomes.process_outcome_description,Process_Outcomes.process_outcome_code]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT Process_Outcomes.process_outcome_description FROM Process_Outcomes WHERE Process_Outcomes.process_outcome_code = 'working';,"SELECT process_outcome_description FROM Process_outcomes WHERE process_outcome_code  =  ""working""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Process_Outcomes.process_outcome_description"" field, as the question asks for the description. 2. Condition Structure: Use a WHERE clause to filter for the specific ""Process_Outcomes.process_outcome_code"" that matches ""working"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Process_Outcomes"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving a single field based on a specific condition.",1.0
2079,what are the average and maximum profit of a year for all presses?,EASY,book_press,"[press.Year_Profits_billion,press.Month_Profits_billion]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT AVG(press.Year_Profits_billion) AS avg_yearly_profit, MAX(press.Year_Profits_billion) AS max_yearly_profit FROM press;","SELECT avg(Year_Profits_billion) ,  max(Year_Profits_billion) FROM press","1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average and maximum profits of a year for all presses. 2. Aggregation Structure: Use AVG and MAX functions to calculate the average and maximum yearly profits. 3. Grouping Structure: No GROUP BY is required since the query asks for the overall average and maximum profits across all presses. 4. Join Structure: No JOIN is required as all necessary data is within the ""press"" table.",1.0
2080,List all Planets' names and coordinates in alphabetical order of name.,EASY,planet_1,"[Planet.Name, Planet.Coordinates]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Planet.Name, Planet.Coordinates FROM Planet ORDER BY Planet.Name ASC;","SELECT Name ,  Coordinates FROM Planet ORDER BY Name","1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the planet names and their coordinates. 2. Condition Structure: No specific filtering condition is required as we want all planets' names and coordinates. 3. Join Structure: No JOIN is required since all necessary data is within the ""Planet"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""Planet.Name"" in ascending order to list the planets alphabetically.",1.0
2081,List all shipment ids for the planet Mars.,NON-NESTED,planet_1,"[Shipment.ShipmentID,Shipment.Planet,Planet.Name,Shipment.Planet = Planet.PlanetID,Mars]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Shipment.ShipmentID FROM Shipment JOIN Planet ON Shipment.Planet = Planet.PlanetID WHERE Planet.Name = 'Mars';,"SELECT T1.ShipmentID FROM Shipment AS T1 JOIN Planet AS T2 ON T1.Planet = T2.PlanetID WHERE T2.Name  =  ""Mars"";","1. Sequential Structure: Start with the SELECT clause to retrieve ""Shipment.ShipmentID."" 2. Condition Structure: Use a WHERE clause to filter for shipments associated with the planet Mars. This requires matching the ""Shipment.Planet"" with the ""Planet.PlanetID"" and filtering for ""Planet.Name = 'Mars'."" 3. Join Structure: Use a JOIN between the ""Shipment"" and ""Planet"" tables based on the relationship ""Shipment.Planet = Planet.PlanetID"" to associate shipments with their respective planets. 4. Aggregation Structure: No aggregation is needed as the query only retrieves shipment IDs.",1.0
2082,Show the number of documents.,EASY,cre_Doc_Workflow,[Documents.document_id],"Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT COUNT(Documents.document_id) AS document_count FROM Documents;,SELECT count(*) FROM Documents,"1. Sequential Structure: Begin with the SELECT clause to count the number of documents. 2. Aggregation Structure: Use the COUNT function on ""Documents.document_id"" to calculate the total number of documents. 3. Condition Structure: No specific filtering condition is required as we want the total count of all documents. 4. Join Structure: No JOIN is necessary since all required data is within the ""Documents"" table.",1.0
2083,What is the name of the author of best selling book?,NON-NESTED,book_press,"[book.Sale_Amount,book.Author_ID,author.Name,book.Author_ID = author.Author_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT author.Name FROM book JOIN author ON book.Author_ID = author.Author_ID ORDER BY book.Sale_Amount DESC LIMIT 1;,SELECT t1.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id ORDER BY t2.sale_amount DESC LIMIT 1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""author.Name"" of the best-selling book. 2. Condition Structure: Use ORDER BY in descending order on ""book.Sale_Amount"" to rank books by their sales. Use LIMIT 1 to select the book with the highest sales. 3. Join Structure: Use a JOIN between the ""book"" and ""author"" tables based on ""book.Author_ID = author.Author_ID"" to link each book with its respective author. 4. Aggregation Structure: No aggregation is needed as we are only interested in the author of the single best-selling book.",1.0
2084,"Find the title, author name, and publisher name for the top 3 best sales books.",NON-NESTED,book_press,"[book.Title, author.Name, press.Name, book.Sale_Amount, book.Author_ID = author.Author_ID, book.Press_ID = press.Press_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT book.Title, author.Name, press.Name FROM book JOIN author ON book.Author_ID = author.Author_ID JOIN press ON book.Press_ID = press.Press_ID ORDER BY book.Sale_Amount DESC LIMIT 3;","SELECT t1.name ,  t2.title ,  t3.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id JOIN press AS t3 ON t2.press_id  =  t3.press_id ORDER BY t2.sale_amount DESC LIMIT 3","1. Sequential Structure: Start with the SELECT clause to retrieve ""book.Title,"" ""author.Name,"" and ""press.Name."" Since the question asks for the top 3 best sales books, use ORDER BY on ""book.Sale_Amount"" in descending order and LIMIT 3 to get the top 3 books. 2. Condition Structure: No specific filtering condition is required, as we are interested in all books ranked by sales. 3. Join Structure: Use JOINs to connect the ""book"" table with the ""author"" table on ""book.Author_ID = author.Author_ID"" and the ""press"" table on ""book.Press_ID = press.Press_ID"" to link each book with its respective author and publisher. 4. Aggregation Structure: No aggregation is needed, as the query focuses on retrieving specific fields for the top 3 books based on sales.",1.0
2085,Show the ids and details for all staff.,EASY,cre_Doc_Workflow,"[Staff.staff_id, Staff.staff_details]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Staff.staff_id, Staff.staff_details FROM Staff;","SELECT staff_id ,  staff_details FROM Staff","1. Sequential Structure: Start with the SELECT clause to retrieve the ""staff_id"" and ""staff_details"" fields from the ""Staff"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for all staff. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""Staff"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving all records without any summarization.",1.0
2086,Show meeting outcome codes and the number of meeting in each outcome.,EASY,advertising_agencies,[Meetings.meeting_outcome],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Meetings.meeting_outcome, COUNT(*) AS meeting_count FROM Meetings GROUP BY Meetings.meeting_outcome;","SELECT meeting_outcome ,  count(*) FROM Meetings GROUP BY meeting_outcome","1. Sequential Structure: Begin with the SELECT clause to specify the meeting outcome codes and the count of meetings for each outcome. 2. Aggregation Structure: Use COUNT to calculate the number of meetings for each outcome code. 3. Grouping Structure: Use GROUP BY on ""Meetings.meeting_outcome"" to aggregate the results by each outcome code. 4. Join Structure: No JOIN is required since all necessary data is within the ""Meetings"" table.",1.0
2087,what is the total weight of all packages shipped on Mars?,NON-NESTED,planet_1,"[Package.Weight, Shipment.Planet, Shipment.ShipmentID = Package.Shipment, Planet.Name, Shipment.Planet = Planet.PlanetID, Mars]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT SUM(Package.Weight) FROM Package JOIN Shipment ON Shipment.ShipmentID = Package.Shipment JOIN Planet ON Shipment.Planet = Planet.PlanetID WHERE Planet.Name = 'Mars';,"SELECT sum(T1.Weight) FROM PACKAGE AS T1 JOIN Shipment AS T2 ON T1.Shipment = T2.ShipmentID JOIN Planet AS T3 ON T2.Planet = T3.PlanetID WHERE T3.Name = ""Mars"";","1. Sequential Structure: Start with the SELECT clause to calculate the total weight of packages. Use the SUM function on ""Package.Weight"" to compute the total weight. 2. Condition Structure: Use a WHERE clause to filter shipments that were sent to the planet ""Mars."" 3. Join Structure: Use JOINs to connect the ""Package"" table with the ""Shipment"" table on ""Shipment.ShipmentID = Package.Shipment"" and the ""Shipment"" table with the ""Planet"" table on ""Shipment.Planet = Planet.PlanetID"" to link packages with their respective shipment destinations. 4. Aggregation Structure: Use the SUM function to aggregate the weights of all packages shipped to Mars.",1.0
2088,Return all platform names and corresponding market districts.,EASY,video_game,"[platform.Platform_name, platform.Market_district]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT platform.Platform_name, platform.Market_district FROM platform;","SELECT Platform_name ,  Market_district FROM platform","1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""platform.Platform_name"" and ""platform.Market_district"". 2. Condition Structure: No specific filtering condition is required as the query asks for all platform names and their corresponding market districts. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""platform"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all records from the specified fields.",1.0
2089,Find the name and total book sale amount of each press.,NON-NESTED,book_press,"[press.Name, book.Sale_Amount, book.Press_ID = press.Press_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT press.Name, SUM(book.Sale_Amount) AS Total_Sale_Amount FROM press JOIN book ON book.Press_ID = press.Press_ID GROUP BY press.Name;","SELECT sum(t1.sale_amount) ,  t2.name FROM book AS t1 JOIN press AS t2 ON t1.press_id  =  t2.press_id GROUP BY t1.press_id","1. Sequential Structure: Start with the SELECT clause to retrieve the ""press.Name"" and the total ""book.Sale_Amount"" for each press. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""press"" and ""book"" tables based on the relationship ""book.Press_ID = press.Press_ID"" to associate each press with its books. 4. Aggregation Structure: Use SUM on ""book.Sale_Amount"" to calculate the total sales for each press, and GROUP BY ""press.Name"" to group the results by each press.",1.0
2090,Show all invoice ids and statuses without a payment.,NESTED,advertising_agencies,"[Invoices.invoice_id, Invoices.invoice_status, Payments.invoice_id = Invoices.invoice_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Invoices.invoice_id, Invoices.invoice_status FROM Invoices WHERE Invoices.invoice_id NOT IN (SELECT Payments.invoice_id FROM Payments);","SELECT invoice_id ,  invoice_status FROM Invoices EXCEPT SELECT T1.invoice_id ,  T1.invoice_status FROM Invoices AS T1 JOIN Payments AS T2 ON T1.invoice_id  =  T2.invoice_id","1. Sequential Structure: Start with the SELECT clause to retrieve the invoice IDs and statuses from the Invoices table. Use the FROM clause to specify the Invoices table. Apply a WHERE clause to filter invoices that do not have a corresponding payment in the Payments table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude invoices whose invoice_id appears in the Payments table, indicating they have a payment. 3. Join Structure: Not required, as we only need to filter based on the absence of matching invoice_id entries in the Payments table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
2091,What are the shipment ids for the planet Mars?,NON-NESTED,planet_1,"[Shipment.ShipmentID,Planet.Name,Shipment.Planet = Planet.PlanetID,Mars]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Shipment.ShipmentID FROM Shipment JOIN Planet ON Shipment.Planet = Planet.PlanetID WHERE Planet.Name = 'Mars';,"SELECT T1.ShipmentID FROM Shipment AS T1 JOIN Planet AS T2 ON T1.Planet = T2.PlanetID WHERE T2.Name  =  ""Mars"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Shipment.ShipmentID"" field, as the question asks for shipment IDs. 2. Condition Structure: Use a WHERE clause to filter for shipments associated with the planet ""Mars."" This requires matching the ""Planet.Name"" field to ""Mars."" 3. Join Structure: Use a JOIN between the ""Shipment"" and ""Planet"" tables based on the relationship ""Shipment.Planet = Planet.PlanetID"" to link shipments to their respective planets. 4. Aggregation Structure: No aggregation is needed, as the query only retrieves specific shipment IDs.",1.0
2092,How many players have rank of the year smaller than 3?,EASY,video_game,"[player.Player_ID,player.Rank_of_the_year]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT COUNT(player.Player_ID) FROM player WHERE player.Rank_of_the_year < 3;,SELECT count(*) FROM player WHERE Rank_of_the_year  <=  3,"1. Sequential Structure: Start with the SELECT clause to count the number of players. 2. Condition Structure: Use a WHERE clause to filter players whose ""Rank_of_the_year"" is smaller than 3. 3. Join Structure: No JOIN is required since all necessary information is in the ""player"" table. 4. Aggregation Structure: Use COUNT to calculate the number of players meeting the specified condition.",1.0
2093,Show all agency ids and details.,EASY,advertising_agencies,"[Agencies.agency_id, Agencies.agency_details]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, Agencies.agency_details FROM Agencies;","SELECT agency_id ,  agency_details FROM Agencies","1. Sequential Structure: Start with the SELECT clause to retrieve all fields from the ""Agencies"" table, as the question asks for all agency IDs and details. 2. Condition Structure: No specific filtering condition is required since the query requests all records. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Agencies"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all records.",1.0
2094,Which employees have salaries between 5000 and 10000? List employees' name.,EASY,planet_1,"[Employee.Name, Employee.Salary]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Employee.Name FROM Employee WHERE Employee.Salary BETWEEN 5000 AND 10000;,SELECT Name FROM Employee WHERE Salary BETWEEN 5000 AND 10000,"1. Sequential Structure: Start with the SELECT clause to specify the employee names, as the question asks for the names of employees. 2. Condition Structure: Use a WHERE clause to filter employees whose salaries are between 5000 and 10000. 3. Join Structure: No JOIN is required since all necessary information is in the ""Employee"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving employee names that meet the specified salary condition.",1.0
2095,"What are the id, sic code and agency id of the client who has attended 1 meeting and has any invoice.",NON-NESTED,advertising_agencies,"[Clients.client_id,Clients.sic_code,Clients.agency_id,Meetings.client_id = Clients.client_id,Invoices.client_id = Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_id, Clients.sic_code, Clients.agency_id FROM Clients JOIN Meetings ON Meetings.client_id = Clients.client_id JOIN Invoices ON Invoices.client_id = Clients.client_id GROUP BY Clients.client_id, Clients.sic_code, Clients.agency_id HAVING COUNT(Meetings.client_id) = 1 AND COUNT(Invoices.client_id) > 0;","SELECT T1.client_id ,  T1.sic_code ,  T1.agency_id FROM clients AS T1 JOIN meetings AS T2 ON T1.client_id  =  T2.client_id GROUP BY T1.client_id HAVING count(*)  =  1 INTERSECT SELECT T1.client_id ,  T1.sic_code ,  T1.agency_id FROM clients AS T1 JOIN invoices AS T2 ON T1.client_id  =  T2.client_id","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Clients.client_id,"" ""Clients.sic_code,"" and ""Clients.agency_id."" 2. Condition Structure: Use a WHERE clause to filter clients who have attended exactly one meeting and have at least one invoice. This involves using a subquery or aggregation to count the number of meetings and invoices for each client. 3. Join Structure: Use JOINs to connect the ""Clients"" table with the ""Meetings"" table on ""Meetings.client_id = Clients.client_id"" and the ""Invoices"" table on ""Invoices.client_id = Clients.client_id."" 4. Aggregation Structure: Use COUNT to count the number of meetings for each client and filter using HAVING to ensure the count is exactly one. Additionally, ensure that the client has at least one invoice.",0.0
2096,List all shipment ids for the planet Mars and under the management of Turanga Leela.,NON-NESTED,planet_1,"[Shipment.ShipmentID,Planet.Name,Employee.Name,Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Mars,Turanga Leela]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Shipment.ShipmentID FROM Shipment JOIN Planet ON Shipment.Planet = Planet.PlanetID JOIN Employee ON Shipment.Manager = Employee.EmployeeID WHERE Planet.Name = 'Mars' AND Employee.Name = 'Turanga Leela';,"SELECT T1.ShipmentID FROM Shipment AS T1 JOIN Planet AS T2 ON T1.Planet = T2.PlanetID JOIN Employee AS T3 ON T3.EmployeeID = T1.Manager WHERE T2.Name = ""Mars"" AND T3.Name = ""Turanga Leela"";","1. Sequential Structure: Start with the SELECT clause to retrieve ""Shipment.ShipmentID."" 2. Condition Structure: Use a WHERE clause to filter for shipments where the planet is ""Mars"" and the manager is ""Turanga Leela."" 3. Join Structure: Use JOINs to connect the ""Shipment"" table with the ""Planet"" table on ""Shipment.Planet = Planet.PlanetID"" and with the ""Employee"" table on ""Shipment.Manager = Employee.EmployeeID"" to link shipments with their respective planets and managers. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific shipment IDs based on the conditions.",1.0
2097,Show agency details for client with detail 'Mac'.,NON-NESTED,advertising_agencies,"[Agencies.agency_details,Clients.client_details,Clients.agency_id = Agencies.agency_id,'Mac']","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT Agencies.* FROM Clients JOIN Agencies ON Clients.agency_id = Agencies.agency_id WHERE Clients.client_details = 'Mac';,SELECT T2.agency_details FROM Clients AS T1 JOIN Agencies AS T2 ON T1.agency_id  =  T2.agency_id WHERE T1.client_details  =  'Mac',"1. Sequential Structure: Start with the SELECT clause to retrieve all fields from the ""Agencies"" table since the question asks for ""agency details."" 2. Condition Structure: Use a WHERE clause to filter for clients with the detail ""Mac"" in the ""Clients.client_details"" field. 3. Join Structure: Use an INNER JOIN between the ""Clients"" and ""Agencies"" tables based on the relationship ""Clients.agency_id = Agencies.agency_id"" to link clients with their respective agencies. 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving specific agency details for a given client detail.",1.0
2098,List the name of franchise that have the most number of games.,EASY,video_game,"[game.Franchise, game.Game_ID]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT game.Franchise FROM game GROUP BY game.Franchise ORDER BY COUNT(game.Game_ID) DESC LIMIT 1;,SELECT Franchise FROM game GROUP BY Franchise ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the franchise name. 2. Aggregation Structure: Use COUNT to calculate the number of games for each franchise. 3. Grouping Structure: Use GROUP BY on ""game.Franchise"" to aggregate the results by each franchise. 4. Ordering Structure: Use ORDER BY in descending order on the count of games to rank franchises by the number of games they have. 5. Limiting Structure: Use LIMIT 1 to retrieve only the franchise with the most number of games. 6. Join Structure: No JOIN is required since all necessary data is within the ""game"" table.",1.0
2099,What are the ids and details of the staff who have attended at least 1 meetings and have the detail with letter 's'?,NON-NESTED,advertising_agencies,"[Staff.staff_id, Staff.staff_details, Staff_in_Meetings.staff_id = Staff.staff_id, Staff_in_Meetings.meeting_id = Meetings.meeting_id, Meetings.meeting_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT DISTINCT Staff.staff_id, Staff.staff_details FROM Staff JOIN Staff_in_Meetings ON Staff.staff_id = Staff_in_Meetings.staff_id JOIN Meetings ON Staff_in_Meetings.meeting_id = Meetings.meeting_id WHERE Staff.staff_details LIKE '%s%';","SELECT staff_id ,  staff_details FROM staff WHERE staff_details LIKE ""%s%"" GROUP BY staff_id HAVING count(*)  >=  1","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Staff.staff_id"" and ""Staff.staff_details"" fields. 2. Condition Structure: Use a WHERE clause to filter for staff whose ""staff_details"" contain the letter 's' and who have attended at least one meeting. This requires checking the existence of a relationship between ""Staff"" and ""Meetings"" through the ""Staff_in_Meetings"" table. 3. Join Structure: Use JOINs to connect the ""Staff"" table with the ""Staff_in_Meetings"" table on ""Staff.staff_id"" and then with the ""Meetings"" table on ""Staff_in_Meetings.meeting_id = Meetings.meeting_id"" to ensure we only consider staff who have attended meetings. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique staff records are returned.",0.0
2100,What are the agency ids and details agencies with at least 2 clients?,NON-NESTED,advertising_agencies,"[Agencies.agency_id, Agencies.agency_details, Clients.agency_id, Clients.client_id, Clients.agency_id = Agencies.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, Agencies.agency_details FROM Agencies JOIN Clients ON Clients.agency_id = Agencies.agency_id GROUP BY Agencies.agency_id, Agencies.agency_details HAVING COUNT(Clients.client_id) >= 2;","SELECT T1.agency_id ,  T1.agency_details FROM Agencies AS T1 JOIN Clients AS T2 ON T1.agency_id  =  T2.agency_id GROUP BY T1.agency_id HAVING count(*)  >=  2","1. Sequential Structure: Start with the SELECT clause to retrieve ""Agencies.agency_id"" and ""Agencies.agency_details."" 2. Condition Structure: Use a HAVING clause to filter for agencies that have at least 2 clients. 3. Join Structure: Use a JOIN between the ""Agencies"" and ""Clients"" tables based on ""Clients.agency_id = Agencies.agency_id"" to associate each agency with its clients. 4. Aggregation Structure: Use COUNT on ""Clients.client_id"" to count the number of clients per agency, then filter with HAVING to select agencies with at least 2 clients.",1.0
2101,How many agencies do we have?,EASY,advertising_agencies,[Agencies.agency_id],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(DISTINCT Agencies.agency_id) AS total_agencies FROM Agencies;,SELECT count(*) FROM Agencies,"1. Sequential Structure: Start with the SELECT clause to count the number of agencies. 2. Aggregation Structure: Use COUNT to calculate the total number of unique agency IDs. 3. Join Structure: No JOIN is required since all necessary data is within the ""Agencies"" table. 4. Condition Structure: No specific filtering condition is needed as we want the total count of agencies.",1.0
2102,List the names of franchises that have at least two games.,NESTED,video_game,"[game.Franchise, game.Game_ID]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT Franchise FROM game GROUP BY Franchise HAVING COUNT(Game_ID) >= 2;,SELECT Franchise FROM game GROUP BY Franchise HAVING COUNT(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of franchises. Use the FROM clause to specify the game table. Apply a GROUP BY clause to group records by franchise, allowing us to count the number of games per franchise. Use the HAVING clause to filter franchises with at least two games. 2. Condition Structure: Use the HAVING clause with COUNT(Game_ID) to filter for franchises that have two or more games. 3. Join Structure: Not required, as all data is available within the game table. 4. Aggregation Structure: Use COUNT(Game_ID) to count the number of games for each franchise and filter based on this count.",1.0
2103,"what is the total package weight for each planet, list its name ?",NON-NESTED,planet_1,"[Planet.Name, Package.Weight, Package.Shipment = Shipment.ShipmentID, Shipment.Planet = Planet.PlanetID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Planet.Name, SUM(Package.Weight) AS TotalWeight FROM Package JOIN Shipment ON Package.Shipment = Shipment.ShipmentID JOIN Planet ON Shipment.Planet = Planet.PlanetID GROUP BY Planet.Name;","select t3.name ,  sum(t1.weight) from package as t1 join shipment as t2 on t1.shipment = t2.shipmentid join planet as t3 on t2.planet = t3.planetid group by t2.planet;","1. Sequential Structure: Start with the SELECT clause to retrieve the planet name and the total package weight for each planet. Use an aggregate function (SUM) on ""Package.Weight"" to calculate the total weight. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Package"" table with the ""Shipment"" table on ""Package.Shipment = Shipment.ShipmentID"" and the ""Shipment"" table with the ""Planet"" table on ""Shipment.Planet = Planet.PlanetID"" to associate packages with their respective planets. 4. Aggregation Structure: Use SUM to calculate the total weight of packages for each planet and GROUP BY ""Planet.Name"" to group the results by planet.",1.0
2104,How many shipments take place on each planet?,NON-NESTED,planet_1,"[Shipment.Planet, Planet.PlanetID, Shipment.ShipmentID]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
","SELECT Shipment.Planet, COUNT(Shipment.ShipmentID) AS ShipmentCount FROM Shipment GROUP BY Shipment.Planet;","SELECT T2.Name ,  count(*) FROM Shipment AS T1 JOIN Planet AS T2 ON T1.Planet = T2.PlanetID GROUP BY T1.Planet;","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Shipment.Planet"" and the count of ""Shipment.ShipmentID"" for each planet. 2. Condition Structure: No specific filtering condition is required, as we are interested in all shipments on all planets. 3. Join Structure: No JOIN is necessary because the required information is available within the ""Shipment"" table. 4. Aggregation Structure: Use COUNT on ""Shipment.ShipmentID"" to count the number of shipments for each planet, and GROUP BY ""Shipment.Planet"" to group the results by planet.",0.0
2105,Find the name and the yearly profit in billion for press that published more than two books.,NON-NESTED,book_press,"[press.Name, press.Year_Profits_billion, book.Press_ID, book.Book_ID, book.Press_ID = press.Press_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT press.Name, press.Year_Profits_billion FROM press JOIN book ON book.Press_ID = press.Press_ID GROUP BY press.Press_ID HAVING COUNT(book.Book_ID) > 2;","SELECT t2.name ,  t2.Year_Profits_billion FROM book AS t1 JOIN press AS t2 ON t1.press_id  =  t2.press_id GROUP BY t2.press_id HAVING count(*)  >  2","1. Sequential Structure: Start with the SELECT clause to retrieve ""press.Name"" and ""press.Year_Profits_billion."" 2. Condition Structure: Use a HAVING clause to filter presses that published more than two books. This requires counting the number of books associated with each press. 3. Join Structure: Use a JOIN between the ""press"" and ""book"" tables based on ""book.Press_ID = press.Press_ID"" to associate each press with its published books. 4. Aggregation Structure: Use COUNT on ""book.Book_ID"" to count the number of books published by each press, then filter with HAVING to select presses with more than two books.",1.0
2106,Show the ids and names for all documents by author Bianka Cummings.,NON-NESTED,cre_Doc_Workflow,"[Documents.document_id, Documents.document_name, Documents.author_name = Authors.author_name, Authors.author_name, Bianka Cummings]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Documents.document_id, Documents.document_name FROM Documents JOIN Authors ON Documents.author_name = Authors.author_name WHERE Authors.author_name = 'Bianka Cummings';","SELECT document_id ,  document_name FROM Documents WHERE author_name  =  ""Bianka Cummings""","1. Sequential Structure: Start with the SELECT clause to retrieve ""Documents.document_id"" and ""Documents.document_name."" 2. Condition Structure: Use a WHERE clause to filter for records where the ""Authors.author_name"" is ""Bianka Cummings."" 3. Join Structure: Use a JOIN between the ""Documents"" and ""Authors"" tables based on the relationship ""Documents.author_name = Authors.author_name"" to link documents with their respective authors. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without summarization.",1.0
2107,What are the names of the press that makes the highest monthly profit or the lowest monthly profit?,NESTED,book_press,"[press.Name, press.Month_Profits_billion]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT Name FROM press WHERE Month_Profits_billion = (SELECT MAX(Month_Profits_billion) FROM press) OR Month_Profits_billion = (SELECT MIN(Month_Profits_billion) FROM press);,SELECT name FROM press WHERE Month_Profits_billion  =  (SELECT min(Month_Profits_billion) FROM press) OR Month_Profits_billion  =  (SELECT max(Month_Profits_billion) FROM press),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the press. Use the FROM clause to specify the press table. Apply a WHERE clause to filter for the press with either the highest or the lowest monthly profit. 2. Condition Structure: Use the WHERE clause with two subqueries to filter for the press whose monthly profit matches either the maximum or the minimum monthly profit. 3. Join Structure: Not required, as all data is in the press table. 4. Aggregation Structure: Use MAX and MIN functions in subqueries to find the highest and lowest monthly profits, respectively, and filter the press names based on these values.",1.0
2108,Which employees have clearance in Omega III? List employees' name.,NON-NESTED,planet_1,"[Employee.Name,Has_Clearance.Employee,Has_Clearance.Planet,Planet.Name,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Omega III]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Employee.Name FROM Has_Clearance JOIN Employee ON Has_Clearance.Employee = Employee.EmployeeID JOIN Planet ON Has_Clearance.Planet = Planet.PlanetID WHERE Planet.Name = 'Omega III';,"SELECT T2.Name FROM Has_Clearance AS T1 JOIN Employee AS T2 ON T1.Employee = T2.EmployeeID JOIN Planet AS T3 ON T1.Planet = T3.PlanetID WHERE T3.Name  =  ""Omega III"";","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Employee.Name."" 2. Condition Structure: Use a WHERE clause to filter for records where the ""Planet.Name"" is ""Omega III."" 3. Join Structure: Use JOINs to connect the ""Has_Clearance"" table with the ""Employee"" table on ""Has_Clearance.Employee = Employee.EmployeeID"" and the ""Planet"" table on ""Has_Clearance.Planet = Planet.PlanetID"" to link employees with their clearance and the corresponding planet. 4. Aggregation Structure: No aggregation is needed as we are simply listing employee names.",1.0
2109,Count the number of invoices.,EASY,advertising_agencies,[Invoices.invoice_id],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(Invoices.invoice_id) AS total_invoices FROM Invoices;,SELECT count(*) FROM Invoices,"1. Sequential Structure: Start with the SELECT clause to count the number of invoices. 2. Condition Structure: No specific filtering condition is required as we want the total count of invoices. 3. Join Structure: No JOIN is necessary since all required information is in the ""Invoices"" table. 4. Aggregation Structure: Use COUNT on ""Invoices.invoice_id"" to calculate the total number of invoices.",1.0
2110,What are the number of packages shipped on Omicron Persei 8 planet or sent by Zapp Brannigan?,NON-NESTED,planet_1,"[Package.Shipment,Package.Sender,Shipment.Planet,Planet.Name,Client.Name,Shipment.ShipmentID = Package.Shipment,Shipment.Planet = Planet.PlanetID,Package.Sender = Client.AccountNumber,Omicron Persei 8,Zapp Brannigan]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT COUNT(Package.Shipment) FROM Package JOIN Shipment ON Shipment.ShipmentID = Package.Shipment JOIN Planet ON Shipment.Planet = Planet.PlanetID JOIN Client ON Package.Sender = Client.AccountNumber WHERE Planet.Name = 'Omicron Persei 8' OR Client.Name = 'Zapp Brannigan';,"SELECT T1.PackageNumber FROM PACKAGE AS T1 JOIN Client AS T2 ON  T1.Sender = T2.AccountNumber JOIN Shipment AS T3 ON T1.Shipment = T3.ShipmentID JOIN Planet AS T4 ON T3.Planet = T4.PlanetID WHERE T2.Name  =  ""Zapp Brannigan"" OR T4.Name  =  ""Omicron Persei 8"";","1. Sequential Structure: Start with the SELECT clause to count the number of packages. Use COUNT on ""Package.Shipment"" to determine the total number of packages shipped. 2. Condition Structure: Use a WHERE clause to filter for packages shipped to the planet ""Omicron Persei 8"" or sent by the client ""Zapp Brannigan."" 3. Join Structure: Use JOINs to connect the ""Package"" table with the ""Shipment"" table on ""Shipment.ShipmentID = Package.Shipment,"" the ""Shipment"" table with the ""Planet"" table on ""Shipment.Planet = Planet.PlanetID,"" and the ""Package"" table with the ""Client"" table on ""Package.Sender = Client.AccountNumber."" 4. Aggregation Structure: Use COUNT to aggregate the total number of packages that meet the specified conditions.",0.0
2111,What are the names and id of platforms whose download rank is 1?,EASY,video_game,"[platform.Platform_name, platform.Platform_ID, platform.Download_rank, 1]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT platform.Platform_name, platform.Platform_ID FROM platform WHERE platform.Download_rank = 1;","SELECT Platform_name ,  Platform_ID FROM platform WHERE Download_rank  =  1","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the platform name and platform ID. 2. Condition Structure: Use a WHERE clause to filter platforms where the ""platform.Download_rank"" is equal to 1. 3. Join Structure: No JOIN is required since all necessary information is available in the ""platform"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving platform names and IDs that meet the specified condition.",1.0
2112,List all process ids with a document.,NON-NESTED,cre_Doc_Workflow,"[Documents_Processes.process_id, Documents_Processes.document_id, Documents_Processes.document_id = Documents.document_id]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT DISTINCT Documents_Processes.process_id FROM Documents_Processes JOIN Documents ON Documents_Processes.document_id = Documents.document_id;,SELECT DISTINCT process_id FROM Documents_processes,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Documents_Processes.process_id"" since we are listing all process IDs associated with a document. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Documents_Processes"" table and the ""Documents"" table based on the ""document_id"" field to ensure that only process IDs with associated documents are included. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique process IDs are returned.",1.0
2113,How many staff do we have?,EASY,cre_Doc_Workflow,[Staff.staff_id],"Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT COUNT(Staff.staff_id) AS total_staff FROM Staff;,SELECT count(*) FROM Staff,"1. Sequential Structure: Start with the SELECT clause to count the total number of staff members. 2. Condition Structure: No specific filtering condition is required as we want the total count of all staff. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Staff"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of staff members.",1.0
2114,List the codes and descriptions for all process outcomes.,EASY,cre_Doc_Workflow,"[Process_Outcomes.process_outcome_code, Process_Outcomes.process_outcome_description]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Process_Outcomes.process_outcome_code, Process_Outcomes.process_outcome_description FROM Process_Outcomes;","SELECT process_outcome_code ,  process_outcome_description FROM Process_outcomes","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""process_outcome_code"" and ""process_outcome_description"". 2. Condition Structure: No specific filtering condition is required as the query asks for all process outcomes. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Process_Outcomes"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all records from the table.",1.0
2115,Which franchise has the most games?,EASY,video_game,"[game.Franchise, game.Game_ID]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT game.Franchise FROM game GROUP BY game.Franchise ORDER BY COUNT(game.Game_ID) DESC LIMIT 1;,SELECT Franchise FROM game GROUP BY Franchise ORDER BY COUNT(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the franchise name, as the question asks for the franchise with the most games. 2. Aggregation Structure: Use COUNT to calculate the number of games for each franchise. 3. Grouping Structure: Use GROUP BY on ""game.Franchise"" to count the games for each franchise. 4. Ordering Structure: Use ORDER BY in descending order on the game count to rank franchises by the number of games they have. 5. Limiting Structure: Use LIMIT 1 to retrieve only the franchise with the most games. 6. Join Structure: No JOIN is required since all necessary data is within the ""game"" table.",1.0
2116,How many different roles does the staff with id 3 have?,NON-NESTED,cre_Doc_Workflow,"[Staff_in_Processes.staff_id,Staff_in_Processes.staff_role_code,Ref_Staff_Roles.staff_role_code = Staff_in_Processes.staff_role_code,Staff.staff_id]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT COUNT(DISTINCT Staff_in_Processes.staff_role_code) FROM Staff_in_Processes WHERE Staff_in_Processes.staff_id = 3;,SELECT count(DISTINCT staff_role_code) FROM Staff_in_processes WHERE staff_id  =  3,"1. Sequential Structure: Start with the SELECT clause to count the distinct roles of the staff member with id 3. Use COUNT with DISTINCT on ""Staff_in_Processes.staff_role_code."" 2. Condition Structure: Use a WHERE clause to filter for the specific staff member with ""Staff_in_Processes.staff_id = 3."" 3. Join Structure: No JOIN is required to count the roles directly from the ""Staff_in_Processes"" table, as the relevant data is already linked through ""staff_role_code."" 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique roles associated with the staff member.",1.0
2117,Show the names and descriptions for all documents.,EASY,cre_Doc_Workflow,"[Documents.document_name, Documents.document_description]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Documents.document_name, Documents.document_description FROM Documents;","SELECT document_name ,  document_description FROM Documents","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Documents.document_name"" and ""Documents.document_description"". 2. Condition Structure: No specific filtering condition is required as the query asks for all documents. 3. Join Structure: No JOIN is required since all necessary information is in the ""Documents"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and descriptions of all documents.",1.0
2118,Find the name of employees whose salary is above the average salary or more than 5000.,NESTED,planet_1,"[Employee.Name, Employee.Salary]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Name FROM Employee WHERE Salary > (SELECT AVG(Salary) FROM Employee) OR Salary > 5000;,SELECT Name FROM Employee WHERE Salary  >  5000 OR Salary  >  (SELECT avg(salary) FROM employee),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of employees. Use the FROM clause to specify the Employee table. Apply a WHERE clause to filter employees whose salary is either above the average salary or more than 5000. 2. Condition Structure: Use the WHERE clause with a condition that checks if the salary is greater than the average salary (calculated using a subquery) or greater than 5000. 3. Join Structure: Not required, as all data is in the Employee table. 4. Aggregation Structure: Use AVG in a subquery to calculate the average salary, which is then used in the filtering condition.",1.0
2119,List the dates of all shipments.,EASY,planet_1,[Shipment.Date],"Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Shipment.Date FROM Shipment;,SELECT Date FROM Shipment;,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""Shipment.Date"". 2. Condition Structure: No specific filtering condition is required as the query asks for all shipment dates. 3. Join Structure: No JOIN is required since all necessary data is within the ""Shipment"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all shipment dates.",1.0
2120,Return the client ids for clients with two or more invoices?,NON-NESTED,advertising_agencies,"[Clients.client_id, Invoices.client_id, Invoices.client_id = Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT Clients.client_id FROM Clients JOIN Invoices ON Clients.client_id = Invoices.client_id GROUP BY Invoices.client_id HAVING COUNT(Invoices.client_id) >= 2;,SELECT client_id FROM Invoices GROUP BY client_id HAVING count(*)  >=  2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""client_id"" of clients. Use GROUP BY to group the results by ""Invoices.client_id"" to count the number of invoices per client. 2. Condition Structure: Apply a HAVING clause to filter for clients with two or more invoices. 3. Join Structure: Use a JOIN between the ""Clients"" and ""Invoices"" tables based on the shared ""client_id"" field to associate clients with their invoices. 4. Aggregation Structure: Use COUNT on ""Invoices.client_id"" to count the number of invoices for each client, and filter using HAVING to include only those with two or more invoices.",1.0
2121,What are all the distinct franchises?,EASY,video_game,[game.Franchise],"Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT DISTINCT game.Franchise FROM game;,SELECT DISTINCT Franchise FROM game,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct franchises. 2. Condition Structure: No specific filtering condition is required as we want all distinct franchises. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""game"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique franchises are retrieved.",1.0
2122,Show all author names.,EASY,cre_Doc_Workflow,[Authors.author_name],"Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT Authors.author_name FROM Authors;,SELECT author_name FROM Authors,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""author_name"". 2. Condition Structure: No specific filtering condition is required as the query asks for all author names. 3. Join Structure: No JOIN is required since all necessary data is within the ""Authors"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all author names.",1.0
2123,Which authors in the record have not published any books ? Give me their names .,NESTED,book_press,"[author.Name, book.Author_ID, author.Author_ID = book.Author_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT author.Name FROM author WHERE author.Author_ID NOT IN (SELECT book.Author_ID FROM book);,select name from author where author_id not in (select author_id from book),"1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors. Use the FROM clause to specify the author table. Apply a WHERE clause to filter authors who have not published any books by ensuring their Author_ID is not present in the book table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude authors whose Author_ID appears in the book table, meaning they have published books. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Author_ID entries in the book table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.",1.0
2124,What are the titles of games that are played by players from Oklahoma college or Auburn college?,NON-NESTED,video_game,"[game.Title,player.College,game_player.Player_ID = player.Player_ID,game_player.Game_ID = game.Game_ID,Oklahoma,Auburn]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT DISTINCT game.Title FROM game JOIN game_player ON game.Game_ID = game_player.Game_ID JOIN player ON game_player.Player_ID = player.Player_ID WHERE player.College = 'Oklahoma' OR player.College = 'Auburn';,"SELECT T1.Title FROM game AS T1 JOIN game_player AS T2 ON T1.Game_ID  =  T2.Game_ID JOIN player AS T3 ON T2.Player_ID  =  T3.Player_ID WHERE T3.College  =  ""Oklahoma"" INTERSECT SELECT T1.Title FROM game AS T1 JOIN game_player AS T2 ON T1.Game_ID  =  T2.Game_ID JOIN player AS T3 ON T2.Player_ID  =  T3.Player_ID WHERE T3.College  =  ""Auburn""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""game.Title"" field, as the question asks for the titles of games. 2. Condition Structure: Use a WHERE clause to filter for players whose ""player.College"" is either ""Oklahoma"" or ""Auburn."" 3. Join Structure: Use JOINs to connect the ""game_player"" table with the ""player"" table on ""game_player.Player_ID = player.Player_ID"" and the ""game"" table on ""game_player.Game_ID = game.Game_ID"" to link games with the players who played them. 4. Aggregation Structure: No aggregation is needed, as the query only requires the titles of games without any summarization.",1.0
2125,How many games are there?,EASY,video_game,[game.Game_ID],"Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT COUNT(game.Game_ID) AS total_games FROM game;,SELECT count(*) FROM game,"1. Sequential Structure: Start with the SELECT clause to count the total number of games. 2. Condition Structure: No specific filtering condition is required since we want the total count of all games. 3. Join Structure: No JOIN is necessary as the required information is available in the ""game"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of games based on the ""game.Game_ID"".",1.0
2126,list all the names of press in descending order of the profit of the year.,EASY,book_press,"[press.Name, press.Year_Profits_billion]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT press.Name FROM press ORDER BY press.Year_Profits_billion DESC;,SELECT name FROM press ORDER BY Year_Profits_billion DESC,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the name of the press. Additionally, include the profit of the year for sorting purposes. 2. Condition Structure: No specific filtering condition is required as the query asks for all press names. 3. Join Structure: No JOIN is required since all necessary data is within the ""press"" table. 4. Aggregation Structure: No aggregation is needed as we are simply sorting the data. Use ORDER BY in descending order on ""press.Year_Profits_billion"" to rank the press by their profits.",1.0
2127,What are the ids for all shipments on the planet Mars that Turanga Leela manages?,NESTED,planet_1,"[Shipment.ShipmentID,Shipment.Planet,Shipment.Manager,Planet.Name,Employee.Name,Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Mars,Turanga Leela]","Table Client, columns = [*,AccountNumber,Name]
Table Employee, columns = [*,EmployeeID,Name,Position,Salary,Remarks]
Table Has_Clearance, columns = [*,Employee,Planet,Level]
Table Package, columns = [*,Shipment,PackageNumber,Contents,Weight,Sender,Recipient]
Table Planet, columns = [*,PlanetID,Name,Coordinates]
Table Shipment, columns = [*,ShipmentID,Date,Manager,Planet]
","Foreign_keys = [Shipment.Planet = Planet.PlanetID,Shipment.Manager = Employee.EmployeeID,Has_Clearance.Planet = Planet.PlanetID,Has_Clearance.Employee = Employee.EmployeeID,Package.Recipient = Client.AccountNumber,Package.Sender = Client.AccountNumber,Package.Shipment = Shipment.ShipmentID]
",SELECT Shipment.ShipmentID FROM Shipment JOIN Planet ON Shipment.Planet = Planet.PlanetID JOIN Employee ON Shipment.Manager = Employee.EmployeeID WHERE Planet.Name = 'Mars' AND Employee.Name = 'Turanga Leela';,"SELECT T1.ShipmentID FROM Shipment AS T1 JOIN Planet AS T2 ON T1.Planet = T2.PlanetID JOIN Employee AS T3 ON T3.EmployeeID = T1.Manager WHERE T2.Name = ""Mars"" OR T3.Name = ""Turanga Leela"";","1. Sequential Structure: Start with the SELECT clause to retrieve the shipment IDs. Use the FROM clause to specify the Shipment table. Join it with the Planet and Employee tables to connect shipments with their respective planet and manager. Apply a WHERE clause to filter for shipments on the planet Mars and managed by Turanga Leela. 2. Condition Structure: Use the WHERE clause to filter for shipments where the planet name is 'Mars' and the manager's name is 'Turanga Leela'. 3. Join Structure: Use INNER JOINs between the Shipment, Planet, and Employee tables. The Shipment table is joined with the Planet table on the PlanetID, and with the Employee table on the EmployeeID to access the required details. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",0.0
2128,"Sort all the books in descending order of release date, and return the book titles.",EASY,book_press,"[book.Title, book.Release_date]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT book.Title FROM book ORDER BY book.Release_date DESC;,SELECT title FROM book ORDER BY release_date DESC,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the book title. 2. Condition Structure: No specific filtering condition is required as we want all books. 3. Join Structure: No JOIN is required since all necessary information is in the ""book"" table. 4. Aggregation Structure: No aggregation is needed as we are simply sorting the books. 5. Ordering Structure: Use ORDER BY in descending order on ""book.Release_date"" to sort the books by their release date.",1.0
2129,Find the titles and publish dates of the top 5 best sale books.,EASY,book_press,"[book.Title, book.Release_date, book.Sale_Amount]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT book.Title, book.Release_date FROM book ORDER BY book.Sale_Amount DESC LIMIT 5;","SELECT title ,  release_date FROM book ORDER BY sale_amount DESC LIMIT 5","1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the book titles and their release dates. 2. Aggregation Structure: No aggregation is needed since we are directly retrieving the titles and release dates of the books. 3. Ordering Structure: Use ORDER BY on ""book.Sale_Amount"" in descending order to rank the books by their sales. 4. Limiting Structure: Use LIMIT 5 to retrieve only the top 5 best-selling books. 5. Join Structure: No JOIN is required since all necessary data is within the ""book"" table.",1.0
2130,"Return the ids, sic codes, and agency ids of clients who have attended 1 meeting and had an invoice.",NON-NESTED,advertising_agencies,"[Clients.client_id,Clients.sic_code,Clients.agency_id,Meetings.client_id = Clients.client_id,Invoices.client_id = Clients.client_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Clients.client_id, Clients.sic_code, Clients.agency_id FROM Clients JOIN Meetings ON Meetings.client_id = Clients.client_id JOIN Invoices ON Invoices.client_id = Clients.client_id GROUP BY Clients.client_id, Clients.sic_code, Clients.agency_id HAVING COUNT(Meetings.client_id) = 1 AND COUNT(Invoices.client_id) > 0;","SELECT T1.client_id ,  T1.sic_code ,  T1.agency_id FROM clients AS T1 JOIN meetings AS T2 ON T1.client_id  =  T2.client_id GROUP BY T1.client_id HAVING count(*)  =  1 INTERSECT SELECT T1.client_id ,  T1.sic_code ,  T1.agency_id FROM clients AS T1 JOIN invoices AS T2 ON T1.client_id  =  T2.client_id","1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Clients.client_id,"" ""Clients.sic_code,"" and ""Clients.agency_id."" 2. Condition Structure: Use a HAVING clause to filter clients who have attended exactly 1 meeting and have at least one invoice. 3. Join Structure: Use JOINs to connect the ""Clients"" table with the ""Meetings"" table on ""Meetings.client_id = Clients.client_id"" and the ""Invoices"" table on ""Invoices.client_id = Clients.client_id"" to link clients with their meetings and invoices. 4. Aggregation Structure: Use COUNT on ""Meetings.client_id"" to count the number of meetings per client and filter for clients with exactly 1 meeting. Ensure that the client also has at least one invoice by checking the presence of related records in the ""Invoices"" table.",0.0
2131,What is the invoice status code with most number of invoices.,EASY,advertising_agencies,[Invoices.invoice_status],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT Invoices.invoice_status FROM Invoices GROUP BY Invoices.invoice_status ORDER BY COUNT(*) DESC LIMIT 1;,SELECT invoice_status FROM Invoices GROUP BY invoice_status ORDER BY count(*) DESC LIMIT 1,"1. Sequential Structure: Begin with the SELECT clause to specify the invoice status code, as the question asks for the status code with the most invoices. 2. Aggregation Structure: Use COUNT to calculate the number of invoices for each status code. 3. Grouping Structure: Use GROUP BY on ""Invoices.invoice_status"" to group the invoices by their status codes. 4. Ordering Structure: Use ORDER BY in descending order on the count of invoices to rank the status codes by the number of invoices. 5. Limiting Structure: Use LIMIT 1 to retrieve the status code with the most invoices. 6. Join Structure: No JOIN is required since all necessary data is within the ""Invoices"" table.",1.0
2132,Show the number of clients.,EASY,advertising_agencies,[Clients.client_id],"Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
",SELECT COUNT(Clients.client_id) AS number_of_clients FROM Clients;,SELECT count(*) FROM Clients,"1. Sequential Structure: Start with the SELECT clause to count the number of clients. 2. Aggregation Structure: Use the COUNT function on the ""Clients.client_id"" field to calculate the total number of clients. 3. Condition Structure: No specific filtering condition is required as we want the total count of all clients. 4. Join Structure: No JOIN is needed since all necessary information is in the ""Clients"" table.",1.0
2133,How many books does each book series have? Return the counts and book series.,EASY,book_press,"[book.Book_Series, book.Book_ID]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT book.Book_Series, COUNT(book.Book_ID) AS book_count FROM book GROUP BY book.Book_Series;","SELECT count(*) ,  book_series FROM book GROUP BY book_series","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the book series and the count of books in each series. 2. Aggregation Structure: Use COUNT to calculate the number of books in each book series. 3. Grouping Structure: Use GROUP BY on ""book.Book_Series"" to count books for each series. 4. Join Structure: No JOIN is required since all necessary data is within the ""book"" table.",1.0
2134,"Sorted all the press by year profits in descending order, and return press names.",EASY,book_press,"[press.Name, press.Year_Profits_billion]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT press.Name FROM press ORDER BY press.Year_Profits_billion DESC;,SELECT name FROM press ORDER BY Year_Profits_billion DESC,"1. Sequential Structure: Start with the SELECT clause to specify the press names and their year profits. 2. Condition Structure: No specific filtering condition is required as we want all press names sorted by their year profits. 3. Join Structure: No JOIN is required since all necessary information is available in the ""press"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in descending order based on ""press.Year_Profits_billion"".",1.0
2135,"What is the average number of units sold in millions of games played by players with position ""Guard""?",NON-NESTED,video_game,"[game.Units_sold_Millions,player.Position,game_player.Player_ID = player.Player_ID,game_player.Game_ID = game.Game_ID,Guard]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
",SELECT AVG(game.Units_sold_Millions) FROM game_player JOIN player ON game_player.Player_ID = player.Player_ID JOIN game ON game_player.Game_ID = game.Game_ID WHERE player.Position = 'Guard';,"SELECT avg(Units_sold_Millions) FROM game AS T1 JOIN game_player AS T2 ON T1.Game_ID  =  T2.Game_ID JOIN player AS T3 ON T2.Player_ID  =  T3.Player_ID WHERE T3.Position  =  ""Guard""","1. Sequential Structure: Start with the SELECT clause to calculate the average number of units sold in millions. Use the AVG function on the ""game.Units_sold_Millions"" field. 2. Condition Structure: Use a WHERE clause to filter for players with the position ""Guard."" 3. Join Structure: Use JOINs to connect the ""game_player"" table with the ""player"" table on ""Player_ID"" and the ""game"" table on ""Game_ID"" to link players with their respective games and units sold. 4. Aggregation Structure: Use the AVG function to compute the average number of units sold in millions for the filtered records.",1.0
2136,Show all staff ids and the number of document processes for each staff.,NON-NESTED,cre_Doc_Workflow,"[Staff.staff_id, Staff_in_Processes.staff_id, Staff_in_Processes.document_id, Documents_Processes.document_id]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Staff.staff_id, COUNT(Staff_in_Processes.document_id) AS num_document_processes FROM Staff JOIN Staff_in_Processes ON Staff.staff_id = Staff_in_Processes.staff_id JOIN Documents_Processes ON Staff_in_Processes.document_id = Documents_Processes.document_id GROUP BY Staff.staff_id;","SELECT staff_id ,  count(*) FROM Staff_in_processes GROUP BY staff_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Staff.staff_id"" and the count of ""Staff_in_Processes.document_id"" for each staff. Use COUNT to calculate the number of document processes. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Staff"" table with ""Staff_in_Processes"" on ""Staff.staff_id"" and then connect ""Staff_in_Processes"" with ""Documents_Processes"" on ""document_id"" to link staff with their document processes. 4. Aggregation Structure: Use COUNT to count the number of document processes for each staff and GROUP BY ""Staff.staff_id"" to group the results by staff.",1.0
2137,"Who is the author of the document ""Travel to Brazil""?",NON-NESTED,cre_Doc_Workflow,"[Documents.author_name, Documents.document_name, Documents.author_name = Authors.author_name, ""Travel to Brazil""]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT Documents.author_name FROM Documents WHERE Documents.document_name = 'Travel to Brazil';,"SELECT author_name FROM Documents WHERE document_name  =  ""Travel to Brazil""","1. Sequential Structure: Start with the SELECT clause to retrieve the ""Documents.author_name"" field, as the question asks for the author of a specific document. 2. Condition Structure: Use a WHERE clause to filter for the document with the name ""Travel to Brazil."" 3. Join Structure: No JOIN is necessary since the required information is available in the ""Documents"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving a single author's name for a specific document.",1.0
2138,What are the agency ids and agency details for all agencies who have a client?,NON-NESTED,advertising_agencies,"[Agencies.agency_id, Agencies.agency_details, Clients.agency_id = Agencies.agency_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT Agencies.agency_id, Agencies.agency_details FROM Agencies JOIN Clients ON Clients.agency_id = Agencies.agency_id;","SELECT T1.agency_id ,  T1.agency_details FROM Agencies AS T1 JOIN Clients AS T2 ON T1.agency_id  =  T2.agency_id","1. Sequential Structure: Start with the SELECT clause to retrieve ""Agencies.agency_id"" and ""Agencies.agency_details."" 2. Condition Structure: Use a WHERE clause to filter for agencies that have at least one client. This can be achieved by checking if there is a match between ""Clients.agency_id"" and ""Agencies.agency_id."" 3. Join Structure: Use an INNER JOIN between the ""Agencies"" and ""Clients"" tables on the ""agency_id"" field to link agencies with their clients. 4. Aggregation Structure: No aggregation is needed since the query only requires listing agency details for agencies with clients.",1.0
2139,"Find the names of the authors who did not have any book with the ""Accor"" press.",NESTED,book_press,"[author.Name, book.Author_ID, book.Press_ID, press.Press_ID, press.Name, book.Press_ID = press.Press_ID, book.Author_ID = author.Author_ID, Accor]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT author.Name FROM author WHERE author.Author_ID NOT IN ( SELECT book.Author_ID FROM book JOIN press ON book.Press_ID = press.Press_ID WHERE press.Name = 'Accor' );,SELECT name FROM author EXCEPT SELECT t1.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id JOIN press AS t3 ON t2.press_id  =  t3.press_id WHERE t3.name  =  'Accor',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors. Use the FROM clause to specify the author table. Apply a WHERE clause to filter authors who do not have any book published by the ""Accor"" press. 2. Condition Structure: Use a WHERE clause with a subquery to exclude authors whose Author_ID is associated with books published by the ""Accor"" press. The subquery identifies the Press_ID for ""Accor"" and matches it with books. 3. Join Structure: Use JOINs between the author, book, and press tables to connect authors with their books and the press details. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",1.0
2140,Show the names and other details for all authors.,EASY,cre_Doc_Workflow,"[Authors.author_name, Authors.other_details]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Authors.author_name, Authors.other_details FROM Authors;","SELECT author_name ,  other_details FROM Authors","1. Sequential Structure: Start with the SELECT clause to retrieve all fields, including ""author_name"" and ""other_details,"" from the ""Authors"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for all authors and their details. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""Authors"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving all records without any summarization.",1.0
2141,Show the staff id and the number of meetings attended by the staff who attended some meeting but had the lowest attendance.,NESTED,advertising_agencies,"[Staff.staff_id, Staff_in_Meetings.staff_id, Staff_in_Meetings.meeting_id, Meetings.meeting_id]","Table Agencies, columns = [*,agency_id,agency_details]
Table Clients, columns = [*,client_id,agency_id,sic_code,client_details]
Table Invoices, columns = [*,invoice_id,client_id,invoice_status,invoice_details]
Table Meetings, columns = [*,meeting_id,client_id,meeting_outcome,meeting_type,billable_yn,start_date_time,end_date_time,purpose_of_meeting,other_details]
Table Payments, columns = [*,payment_id,invoice_id,payment_details]
Table Staff, columns = [*,staff_id,agency_id,staff_details]
Table Staff_in_Meetings, columns = [*,meeting_id,staff_id]
","Foreign_keys = [Clients.agency_id = Agencies.agency_id,Invoices.client_id = Clients.client_id,Meetings.client_id = Clients.client_id,Payments.invoice_id = Invoices.invoice_id,Staff_in_Meetings.staff_id = Staff.staff_id,Staff_in_Meetings.meeting_id = Meetings.meeting_id]
","SELECT staff_id, COUNT(meeting_id) AS num_meetings FROM Staff_in_Meetings GROUP BY staff_id HAVING num_meetings = (SELECT MIN(meeting_count) FROM (SELECT staff_id, COUNT(meeting_id) AS meeting_count FROM Staff_in_Meetings GROUP BY staff_id) AS subquery) AND num_meetings > 0;","SELECT staff_id ,  count(*) FROM Staff_in_meetings GROUP BY staff_id ORDER BY count(*) ASC LIMIT 1;","1. Sequential Structure: Start with the SELECT clause to retrieve the staff ID and the count of meetings attended. Use the FROM clause to specify the Staff_in_Meetings table, as it contains the attendance data. Use GROUP BY to group records by staff ID and COUNT to calculate the number of meetings attended by each staff member. Use a WHERE clause to filter for staff who attended at least one meeting and had the lowest attendance. 2. Condition Structure: Use the WHERE clause to ensure that only staff who attended some meetings are considered. Use a HAVING clause to filter for the minimum attendance count. 3. Join Structure: No explicit JOIN is required, as all necessary data for attendance is in the Staff_in_Meetings table. 4. Aggregation Structure: Use COUNT to calculate the number of meetings attended by each staff member and MIN to find the lowest attendance count.",1.0
2142,how many authors are under age 30?,EASY,book_press,[author.Age],"Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
",SELECT COUNT(*) FROM author WHERE author.Age < 30;,SELECT count(*) FROM author WHERE age  <  30,"1. Sequential Structure: Begin with the SELECT clause to count the number of authors. 2. Condition Structure: Use a WHERE clause to filter authors whose age is less than 30. 3. Join Structure: No JOIN is required since all necessary data is within the ""author"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of authors meeting the age condition.",1.0
2143,"Show the next process id, process name, process description for process with id 9.",EASY,cre_Doc_Workflow,"[Business_Processes.next_process_id, Business_Processes.process_name, Business_Processes.process_description, Business_Processes.process_id]","Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
","SELECT Business_Processes.next_process_id, Business_Processes.process_name, Business_Processes.process_description FROM Business_Processes WHERE Business_Processes.process_id = 9;","SELECT next_process_id ,  process_name ,  process_description FROM Business_processes WHERE process_id  =  9","1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Business_Processes.next_process_id"", ""Business_Processes.process_name"", and ""Business_Processes.process_description"". 2. Condition Structure: Use a WHERE clause to filter for the process with ""Business_Processes.process_id"" equal to 9. 3. Join Structure: No JOIN is required since all necessary data is within the ""Business_Processes"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",1.0
2144,What are the names and market districts of all platforms?,EASY,video_game,"[platform.Platform_name, platform.Market_district]","Table game, columns = [*,Game_ID,Title,Release_Date,Franchise,Developers,Platform_ID,Units_sold_Millions]
Table game_player, columns = [*,Player_ID,Game_ID,If_active]
Table platform, columns = [*,Platform_ID,Platform_name,Market_district,Download_rank]
Table player, columns = [*,Player_ID,Rank_of_the_year,Player_name,Position,College]
","Foreign_keys = [game.Platform_ID = platform.Platform_ID,game_player.Game_ID = game.Game_ID,game_player.Player_ID = player.Player_ID]
","SELECT platform.Platform_name, platform.Market_district FROM platform;","SELECT Platform_name ,  Market_district FROM platform","1. Sequential Structure: Start with the SELECT clause to retrieve the ""platform.Platform_name"" and ""platform.Market_district"" fields, as the question asks for the names and market districts of all platforms. 2. Condition Structure: No specific filtering condition is required since the query asks for all platforms. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""platform"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all platforms.",1.0
2145,Show the number of process outcomes.,EASY,cre_Doc_Workflow,[Process_Outcomes.process_outcome_code],"Table Authors, columns = [*,author_name,other_details]
Table Business_Processes, columns = [*,process_id,next_process_id,process_name,process_description,other_details]
Table Documents, columns = [*,document_id,author_name,document_name,document_description,other_details]
Table Documents_Processes, columns = [*,document_id,process_id,process_outcome_code,process_status_code]
Table Process_Outcomes, columns = [*,process_outcome_code,process_outcome_description]
Table Process_Status, columns = [*,process_status_code,process_status_description]
Table Ref_Staff_Roles, columns = [*,staff_role_code,staff_role_description]
Table Staff, columns = [*,staff_id,staff_details]
Table Staff_in_Processes, columns = [*,document_id,process_id,staff_id,staff_role_code,date_from,date_to,other_details]
","Foreign_keys = [Documents.author_name = Authors.author_name,Documents_Processes.process_status_code = Process_Status.process_status_code,Documents_Processes.process_outcome_code = Process_Outcomes.process_outcome_code,Documents_Processes.process_id = Business_Processes.process_id,Documents_Processes.document_id = Documents.document_id,Staff_in_Processes.staff_role_code = Ref_Staff_Roles.staff_role_code,Staff_in_Processes.document_id = Documents_Processes.document_id,Staff_in_Processes.process_id = Documents_Processes.process_id,Staff_in_Processes.staff_id = Staff.staff_id]
",SELECT COUNT(Process_Outcomes.process_outcome_code) AS number_of_process_outcomes FROM Process_Outcomes;,SELECT count(*) FROM Process_outcomes,"1. Sequential Structure: Begin with the SELECT clause to count the number of process outcomes. 2. Aggregation Structure: Use the COUNT function to calculate the total number of process outcomes. 3. Condition Structure: No specific filtering condition is required as we want the total count of all process outcomes. 4. Join Structure: No JOIN is required since all necessary data is within the ""Process_Outcomes"" table.",1.0
2146,"Find the name of authors who publish their books in both ""MM"" and ""LT"" series.",NESTED,book_press,"[author.Name, book.Book_Series, book.Author_ID = author.Author_ID, MM, LT]","Table author, columns = [*,Author_ID,Name,Age,Gender]
Table book, columns = [*,Book_ID,Title,Book_Series,Author_ID,Press_ID,Sale_Amount,Release_date]
Table press, columns = [*,Press_ID,Name,Month_Profits_billion,Year_Profits_billion]
","Foreign_keys = [book.Press_ID = press.Press_ID,book.Author_ID = author.Author_ID]
","SELECT author.Name FROM author JOIN book ON book.Author_ID = author.Author_ID WHERE book.Book_Series IN ('MM', 'LT') GROUP BY author.Author_ID, author.Name HAVING COUNT(DISTINCT book.Book_Series) = 2;",SELECT t1.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id WHERE t2.book_series  =  'MM' INTERSECT SELECT t1.name FROM author AS t1 JOIN book AS t2 ON t1.author_id  =  t2.author_id WHERE t2.book_series  =  'LT',"1. Sequential Structure: Start with the SELECT clause to retrieve the names of authors. Use the FROM clause to specify the author table and JOIN it with the book table to link authors with their books. Apply a WHERE clause to filter authors who have books in both ""MM"" and ""LT"" series. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the author has books in both ""MM"" and ""LT"" series. This can be achieved by grouping by the author and checking the count of distinct series they have published in. 3. Join Structure: Use an INNER JOIN between the author and book tables based on the Author_ID to connect authors with their books. 4. Aggregation Structure: Use GROUP BY to group records by author and apply a HAVING clause to filter authors who have published in both ""MM"" and ""LT"" series.",1.0
