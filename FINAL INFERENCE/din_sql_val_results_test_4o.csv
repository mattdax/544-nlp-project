question,schema_links,fields,foriegn keys,classification,predicted_sql,gold_sql,db_id,reasoning,pred_results,gold_results,pred_error,score,gold_error
Show the stadium name and capacity with most number of concerts in year 2014 or after.,"[stadium.Name, stadium.Capacity, concert.Stadium_ID = stadium.Stadium_ID, concert.Year, 2014]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NON-NESTED,"SELECT stadium.Name, stadium.Capacity FROM concert JOIN stadium ON concert.Stadium_ID = stadium.Stadium_ID WHERE concert.Year >= 2014 GROUP BY stadium.Name, stadium.Capacity ORDER BY COUNT(concert.concert_ID) DESC LIMIT 1;","SELECT T2.name ,  T2.capacity FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  >=  2014 GROUP BY T2.stadium_id ORDER BY count(*) DESC LIMIT 1",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve ""stadium.Name"" and ""stadium.Capacity."" To find the stadium with the most concerts, use COUNT to count the number of concerts per stadium. Use a WHERE clause to filter concerts held in the year 2014 or after. Finally, use ORDER BY in descending order of the concert count and LIMIT 1 to get the stadium with the highest number of concerts. 2. Condition Structure: Use a WHERE clause to filter for concerts where ""concert.Year"" is greater than or equal to 2014. 3. Join Structure: Use an INNER JOIN between the ""concert"" and ""stadium"" tables on ""concert.Stadium_ID = stadium.Stadium_ID"" to associate each concert with its respective stadium. 4. Aggregation Structure: Use COUNT to count the number of concerts per stadium, GROUP BY ""stadium.Name"" and ""stadium.Capacity,"" and use ORDER BY to rank the results by the number of concerts in descending order. Use LIMIT 1 to select the stadium with the most concerts.","[('Somerset Park', 11998)]","[('Somerset Park', 11998)]",,1.0,
Which distinct car models are the produced after 1980?,"[cars_data.Year,car_names.Model,cars_data.Id = car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT DISTINCT car_names.Model FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Year > 1980;,SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct car models. Use DISTINCT to ensure unique results. 2. Condition Structure: Use a WHERE clause to filter for cars produced after 1980, i.e., ""cars_data.Year > 1980."" 3. Join Structure: Use a JOIN between the ""cars_data"" and ""car_names"" tables based on the foreign key relationship ""cars_data.Id = car_names.MakeId"" to link car data with their respective models. 4. Aggregation Structure: No aggregation is needed as the query only requires distinct car models.","[('plymouth',), ('buick',), ('dodge',), ('chevrolet',), ('toyota',), ('honda',), ('subaru',), ('datsun',), ('mazda',), ('ford',), ('volkswagen',), ('renault',), ('peugeot',), ('saab',), ('volvo',), ('oldsmobile',), ('chrysler',), ('pontiac',), ('amc',), ('mercury',), ('nissan',)]","[('plymouth',), ('buick',), ('dodge',), ('chevrolet',), ('toyota',), ('honda',), ('subaru',), ('datsun',), ('mazda',), ('ford',), ('volkswagen',), ('renault',), ('peugeot',), ('saab',), ('volvo',), ('oldsmobile',), ('chrysler',), ('pontiac',), ('amc',), ('mercury',), ('nissan',)]",,1.0,
How many car models are produced by each maker ? Only list the count and the maker full name .,"[car_makers.FullName, model_list.Maker, model_list.Model, model_list.Maker = car_makers.Id]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT car_makers.FullName, COUNT(model_list.Model) AS ModelCount FROM model_list JOIN car_makers ON model_list.Maker = car_makers.Id GROUP BY car_makers.FullName;","select count(*) ,  t2.fullname from model_list as t1 join car_makers as t2 on t1.maker  =  t2.id group by t2.id;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the count of car models and the maker's full name. Use COUNT on ""model_list.Model"" to count the number of models for each maker. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between ""model_list"" and ""car_makers"" tables based on ""model_list.Maker = car_makers.Id"" to associate each model with its maker. 4. Aggregation Structure: Use GROUP BY on ""car_makers.FullName"" to group the results by each maker and apply COUNT to calculate the number of models for each maker.","[('American Motor Company', 1), ('BMW', 1), ('Chrysler', 4), ('Citroen', 1), ('Daimler Benz', 2), ('Fiat', 1), ('Ford Motor Company', 3), ('General Motors', 5), ('Honda', 1), ('Hyundai', 1), ('Kia Motors', 1), ('Mazda', 1), ('Nissan Motors', 2), ('Opel', 1), ('Peugeaut', 1), ('Renault', 1), ('Saab', 1), ('Subaru', 1), ('Toyota', 2), ('Triumph', 1), ('Volkswagen', 2), ('Volvo', 1)]","[(1, 'American Motor Company'), (2, 'Volkswagen'), (1, 'BMW'), (5, 'General Motors'), (3, 'Ford Motor Company'), (4, 'Chrysler'), (1, 'Citroen'), (2, 'Nissan Motors'), (1, 'Fiat'), (1, 'Honda'), (1, 'Mazda'), (2, 'Daimler Benz'), (1, 'Opel'), (1, 'Peugeaut'), (1, 'Renault'), (1, 'Saab'), (1, 'Subaru'), (2, 'Toyota'), (1, 'Triumph'), (1, 'Volvo'), (1, 'Kia Motors'), (1, 'Hyundai')]",,1.0,
What is the average and maximum age for each pet type?,"[Pets.PetType, Pets.pet_age, Has_Pet.PetID = Pets.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",EASY,"SELECT Pets.PetType, AVG(Pets.pet_age) AS avg_age, MAX(Pets.pet_age) AS max_age FROM Pets GROUP BY Pets.PetType;","SELECT avg(pet_age) ,  max(pet_age) ,  pettype FROM pets GROUP BY pettype",pets_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the pet type, average age, and maximum age. 2. Aggregation Structure: Use AVG and MAX functions to calculate the average and maximum age for each pet type. 3. Grouping Structure: Use GROUP BY on ""Pets.PetType"" to calculate these aggregate values for each pet type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Pets"" table.","[('cat', 3.0, 3), ('dog', 1.5, 2)]","[(3.0, 3, 'cat'), (1.5, 2, 'dog')]",,1.0,
What is the number of the cars with horsepower more than 150?,"[cars_data.Horsepower,150]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT COUNT(*) FROM cars_data WHERE cars_data.Horsepower > 150;,SELECT count(*) FROM CARS_DATA WHERE horsepower  >  150;,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of cars with horsepower greater than 150. 2. Condition Structure: Use a WHERE clause to filter cars where ""cars_data.Horsepower"" is greater than 150. 3. Join Structure: No JOIN is required since all necessary information is in the ""cars_data"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cars meeting the specified condition.","[(281,)]","[(281,)]",,1.0,
Find the weight of the youngest dog.,"[Pets.weight, Pets.pet_age, Pets.PetType, Has_Pet.PetID = Pets.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT Pets.weight FROM Pets WHERE Pets.PetType = 'dog' AND Pets.pet_age = (SELECT MIN(Pets.pet_age) FROM Pets WHERE Pets.PetType = 'dog');,SELECT weight FROM pets ORDER BY pet_age LIMIT 1,pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Pets.weight"" of the youngest dog. Use a subquery to find the minimum ""Pets.pet_age"" for dogs. 2. Condition Structure: Use a WHERE clause to filter for records where ""Pets.PetType"" is 'dog' and the ""Pets.pet_age"" matches the youngest age found in the subquery. 3. Join Structure: No JOIN is required since all the necessary data is in the ""Pets"" table. 4. Aggregation Structure: Use MIN in a subquery to find the youngest age of dogs, and then filter the main query using this value.","[(9.3,)]","[(9.3,)]",,1.0,
What is the total number of singers?,[singer.Singer_ID],"Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,SELECT COUNT(singer.Singer_ID) AS total_singers FROM singer;,SELECT count(*) FROM singer,concert_singer,"1. Sequential Structure: Start with the SELECT clause to count the total number of singers. 2. Condition Structure: No specific filtering condition is required as we want the total count of all singers. 3. Join Structure: No JOIN is necessary since the required information is available within the ""singer"" table. 4. Aggregation Structure: Use COUNT on ""singer.Singer_ID"" to calculate the total number of singers.","[(6,)]","[(6,)]",,1.0,
What is the id and weight of every pet who is older than 1?,"[Pets.PetID, Pets.weight, Pets.pet_age]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",EASY,"SELECT Pets.PetID, Pets.weight FROM Pets WHERE Pets.pet_age > 1;","SELECT petid ,  weight FROM pets WHERE pet_age  >  1",pets_1,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the pet ID and weight. 2. Condition Structure: Use a WHERE clause to filter pets where ""Pets.pet_age"" is greater than 1. 3. Join Structure: No JOIN is required since all necessary information is in the ""Pets"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the pet ID and weight for pets that meet the age condition.","[(2001, 12.0), (2002, 13.4)]","[(2001, 12.0), (2002, 13.4)]",,1.0,
What is the count of the car models produced in the United States?,"[countries.CountryName,car_makers.Country,countries.CountryId = car_makers.Country,model_list.Maker,car_makers.Id = model_list.Maker,car_names.Model,model_list.Model = car_names.Model]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT COUNT(car_names.Model) FROM countries JOIN car_makers ON countries.CountryId = car_makers.Country JOIN model_list ON car_makers.Id = model_list.Maker JOIN car_names ON model_list.Model = car_names.Model WHERE countries.CountryName = 'United States';,SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of car models. Use COUNT on ""car_names.Model"" to get the total count of models. 2. Condition Structure: Use a WHERE clause to filter for car makers located in the United States. This requires filtering ""countries.CountryName"" for 'United States.' 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""countries"" with ""car_makers"" on ""countries.CountryId = car_makers.Country"" to identify car makers in the United States. Then, join ""car_makers"" with ""model_list"" on ""car_makers.Id = model_list.Maker"" to link car makers with their models. Finally, join ""model_list"" with ""car_names"" on ""model_list.Model = car_names.Model"" to count the car models. 4. Aggregation Structure: Use COUNT to aggregate the total number of car models produced in the United States.","[(0,)]","[(13,)]",,0.0,
What is the model for the car with a weight smaller than the average?,"[cars_data.Weight,car_names.Model,cars_data.Id = car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT car_names.Model FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Weight < (SELECT AVG(Weight) FROM cars_data);,SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA),car_1,1. Sequential Structure: Start with the SELECT clause to retrieve the model of the car. Use the FROM clause to specify the cars_data and car_names tables. Apply a WHERE clause to filter cars with a weight smaller than the average weight. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average weight from the cars_data table and filter cars whose weight is less than this value. 3. Join Structure: Use an INNER JOIN between the cars_data and car_names tables based on the Id and MakeId fields to connect car data with their respective models. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average weight of all cars.,"[('toyota',), ('plymouth',), ('amc',), ('ford',), ('datsun',), ('volkswagen',), ('peugeot',), ('audi',), ('saab',), ('bmw',), ('amc',), ('datsun',), ('chevrolet',), ('toyota',), ('ford',), ('volkswagen',), ('amc',), ('amc',), ('chevrolet',), ('mercury',), ('opel',), ('peugeot',), ('fiat',), ('toyota',), ('datsun',), ('volkswagen',), ('plymouth',), ('toyota',), ('dodge',), ('volkswagen',), ('chevrolet',), ('ford',), ('mazda',), ('volvo',), ('volkswagen',), ('peugeot',), ('renault',), ('ford',), ('datsun',), ('toyota',), ('dodge',), ('toyota',), ('amc',), ('plymouth',), ('volkswagen',), ('amc',), ('toyota',), ('chevrolet',), ('datsun',), ('mazda',), ('ford',), ('mercury',), ('fiat',), ('fiat',), ('opel',), ('audi',), ('volvo',), ('saab',), ('toyota',), ('ford',), ('amc',), ('datsun',), ('ford',), ('toyota',), ('chevrolet',), ('audi',), ('volkswagen',), ('opel',), ('toyota',), ('datsun',), ('dodge',), ('fiat',), ('fiat',), ('honda',), ('subaru',), ('fiat',), ('toyota',), ('ford',), ('amc',), ('pontiac',), ('toyota',), ('volkswagen',), ('datsun',), ('volkswagen',), ('audi',), ('peugeot',), ('volvo',), ('saab',), ('honda',), ('fiat',), ('opel',), ('capri',), ('dodge',), ('renault',), ('chevrolet',), ('chevrolet',), ('volkswagen',), ('honda',), ('volkswagen',), ('datsun',), ('toyota',), ('ford',), ('toyota',), ('honda',), ('buick',), ('renault',), ('plymouth',), ('datsun',), ('volkswagen',), ('pontiac',), ('toyota',), ('ford',), ('chevrolet',), ('dodge',), ('subaru',), ('volkswagen',), ('datsun',), ('bmw',), ('mazda',), ('volkswagen',), ('ford',), ('mazda',), ('datsun',), ('honda',), ('ford',), ('ford',), ('chevrolet',), ('toyota',), ('datsun',), ('dodge',), ('toyota',), ('plymouth',), ('oldsmobile',), ('datsun',), ('audi',), ('saab',), ('volkswagen',), ('honda',), ('ford',), ('volkswagen',), ('mazda',), ('dodge',), ('amc',), ('plymouth',), ('plymouth',), ('datsun',), ('fiat',), ('buick',), ('chevrolet',), ('oldsmobile',), ('pontiac',), ('volkswagen',), ('toyota',), ('chevrolet',), ('datsun',), ('chevrolet',), ('ford',), ('audi',), ('toyota',), ('mazda',), ('datsun',), ('toyota',), ('mazda',), ('dodge',), ('datsun',), ('volkswagen',), ('volkswagen',), ('audi',), ('honda',), ('renault',), ('subaru',), (' volkswagen',), ('datsun',), ('mazda',), ('triumph',), ('ford',), ('honda',), ('plymouth',), ('buick',), ('dodge',), ('chevrolet',), ('plymouth',), ('toyota',), ('plymouth',), ('honda',), ('subaru',), ('datsun',), ('toyota',), ('mazda',), ('plymouth',), ('ford',), ('ford',), ('volkswagen',), ('renault',), ('honda',), ('toyota',), ('datsun',), ('mazda',), ('saab',), ('toyota',), ('datsun',), ('chevrolet',), ('chevrolet',), ('chevrolet',), ('pontiac',), ('dodge',), ('pontiac',), ('ford',), ('volkswagen',), ('mazda',), ('mazda',), ('plymouth',), ('mercury',), ('nissan',), ('honda',), ('toyota',), ('honda',), ('honda',), ('datsun',), ('buick',), ('chrysler',), ('ford',), ('toyota',), ('dodge',), ('chevrolet',), ('ford',), ('volkswagen',), ('dodge',), ('ford',), ('chevrolet',)]","[('toyota',), ('plymouth',), ('amc',), ('ford',), ('datsun',), ('volkswagen',), ('peugeot',), ('audi',), ('saab',), ('bmw',), ('amc',), ('datsun',), ('chevrolet',), ('toyota',), ('ford',), ('volkswagen',), ('amc',), ('amc',), ('chevrolet',), ('mercury',), ('opel',), ('peugeot',), ('fiat',), ('toyota',), ('datsun',), ('volkswagen',), ('plymouth',), ('toyota',), ('dodge',), ('volkswagen',), ('chevrolet',), ('ford',), ('mazda',), ('volvo',), ('volkswagen',), ('peugeot',), ('renault',), ('ford',), ('datsun',), ('toyota',), ('dodge',), ('toyota',), ('amc',), ('plymouth',), ('volkswagen',), ('amc',), ('toyota',), ('chevrolet',), ('datsun',), ('mazda',), ('ford',), ('mercury',), ('fiat',), ('fiat',), ('opel',), ('audi',), ('volvo',), ('saab',), ('toyota',), ('ford',), ('amc',), ('datsun',), ('ford',), ('toyota',), ('chevrolet',), ('audi',), ('volkswagen',), ('opel',), ('toyota',), ('datsun',), ('dodge',), ('fiat',), ('fiat',), ('honda',), ('subaru',), ('fiat',), ('toyota',), ('ford',), ('amc',), ('pontiac',), ('toyota',), ('volkswagen',), ('datsun',), ('volkswagen',), ('audi',), ('peugeot',), ('volvo',), ('saab',), ('honda',), ('fiat',), ('opel',), ('capri',), ('dodge',), ('renault',), ('chevrolet',), ('chevrolet',), ('volkswagen',), ('honda',), ('volkswagen',), ('datsun',), ('toyota',), ('ford',), ('toyota',), ('honda',), ('buick',), ('renault',), ('plymouth',), ('datsun',), ('volkswagen',), ('pontiac',), ('toyota',), ('ford',), ('chevrolet',), ('dodge',), ('subaru',), ('volkswagen',), ('datsun',), ('bmw',), ('mazda',), ('volkswagen',), ('ford',), ('mazda',), ('datsun',), ('honda',), ('ford',), ('ford',), ('chevrolet',), ('toyota',), ('datsun',), ('dodge',), ('toyota',), ('plymouth',), ('oldsmobile',), ('datsun',), ('audi',), ('saab',), ('volkswagen',), ('honda',), ('ford',), ('volkswagen',), ('mazda',), ('dodge',), ('amc',), ('plymouth',), ('plymouth',), ('datsun',), ('fiat',), ('buick',), ('chevrolet',), ('oldsmobile',), ('pontiac',), ('volkswagen',), ('toyota',), ('chevrolet',), ('datsun',), ('chevrolet',), ('ford',), ('audi',), ('toyota',), ('mazda',), ('datsun',), ('toyota',), ('mazda',), ('dodge',), ('datsun',), ('volkswagen',), ('volkswagen',), ('audi',), ('honda',), ('renault',), ('subaru',), (' volkswagen',), ('datsun',), ('mazda',), ('triumph',), ('ford',), ('honda',), ('plymouth',), ('buick',), ('dodge',), ('chevrolet',), ('plymouth',), ('toyota',), ('plymouth',), ('honda',), ('subaru',), ('datsun',), ('toyota',), ('mazda',), ('plymouth',), ('ford',), ('ford',), ('volkswagen',), ('renault',), ('honda',), ('toyota',), ('datsun',), ('mazda',), ('saab',), ('toyota',), ('datsun',), ('chevrolet',), ('chevrolet',), ('chevrolet',), ('pontiac',), ('dodge',), ('pontiac',), ('ford',), ('volkswagen',), ('mazda',), ('mazda',), ('plymouth',), ('mercury',), ('nissan',), ('honda',), ('toyota',), ('honda',), ('honda',), ('datsun',), ('buick',), ('chrysler',), ('ford',), ('toyota',), ('dodge',), ('chevrolet',), ('ford',), ('volkswagen',), ('dodge',), ('ford',), ('chevrolet',)]",,1.0,
What is the name and capacity for the stadium with the highest average attendance?,"[stadium.Name, stadium.Capacity, stadium.Average]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,"SELECT Name, Capacity FROM stadium WHERE Average = (SELECT MAX(Average) FROM stadium);","SELECT name ,  capacity FROM stadium ORDER BY average DESC LIMIT 1",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the name and capacity of the stadium. Use the FROM clause to specify the stadium table. Apply a WHERE clause to filter for the stadium with the highest average attendance. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the stadium where the average attendance is the maximum. 3. Join Structure: Not required, as all the necessary data is in the stadium table. 4. Aggregation Structure: Use the MAX function in a subquery to find the highest average attendance, which is then used in the filtering condition.","[(""Stark's Park"", 10104)]","[(""Stark's Park"", 10104)]",,1.0,
What are the names and ids of all countries with at least one car maker?,"[countries.CountryId, countries.CountryName, car_makers.Country, car_makers.Id = model_list.Maker]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT countries.CountryName, countries.CountryId FROM countries JOIN car_makers ON countries.CountryId = car_makers.Country GROUP BY countries.CountryName, countries.CountryId HAVING COUNT(car_makers.Id) >= 1;","SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve ""countries.CountryName"" and ""countries.CountryId."" 2. Condition Structure: Use a HAVING clause to filter for countries that have at least one car maker. This requires counting the number of car makers associated with each country. 3. Join Structure: Use a JOIN between ""countries"" and ""car_makers"" on ""countries.CountryId = car_makers.Country"" to associate countries with their car makers. 4. Aggregation Structure: Use COUNT on ""car_makers.Id"" to count the number of car makers for each country, then filter with HAVING to include only countries with at least one car maker.","[('france', 3), ('germany', 2), ('italy', 5), ('japan', 4), ('korea', 8), ('sweden', 6), ('uk', 7), ('usa', 1)]","[('usa', 1), ('germany', 2), ('france', 3), ('japan', 4), ('italy', 5), ('sweden', 6), ('uk', 7), ('korea', 8)]",,1.0,
Find the id and weight of all pets whose age is older than 1.,"[Pets.PetID, Pets.weight, Pets.pet_age]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",EASY,"SELECT Pets.PetID, Pets.weight FROM Pets WHERE Pets.pet_age > 1;","SELECT petid ,  weight FROM pets WHERE pet_age  >  1",pets_1,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""Pets.PetID"" and ""Pets.weight"". 2. Condition Structure: Use a WHERE clause to filter for pets whose ""Pets.pet_age"" is greater than 1. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Pets"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the IDs and weights of pets that meet the specified age condition.","[(2001, 12.0), (2002, 13.4)]","[(2001, 12.0), (2002, 13.4)]",,1.0,
Show the name and the release year of the song by the youngest singer.,"[singer.Name, singer.Song_Name, singer.Song_release_year, singer.Age]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,"SELECT Song_Name, Song_release_year FROM singer WHERE Age = (SELECT MIN(Age) FROM singer);","SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the song and its release year. Use the FROM clause to specify the singer table. Apply a WHERE clause to filter for the youngest singer. 2. Condition Structure: Use the WHERE clause with a subquery to identify the youngest singer by finding the minimum age in the singer table. 3. Join Structure: Not required, as all the necessary data is available in the singer table. 4. Aggregation Structure: Use the MIN function in a subquery to find the minimum age, which is then used in the filtering condition.","[('Love', '2016')]","[('Love', '2016')]",,1.0,
Show the stadium name and the number of concerts in each stadium.,"[stadium.Name, concert.Stadium_ID, concert.concert_ID, concert.Stadium_ID = stadium.Stadium_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NON-NESTED,"SELECT stadium.Name, COUNT(concert.concert_ID) AS number_of_concerts FROM stadium JOIN concert ON concert.Stadium_ID = stadium.Stadium_ID GROUP BY stadium.Name;","SELECT T2.name ,  count(*) FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id GROUP BY T1.stadium_id",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""stadium.Name"" and the count of concerts in each stadium. Use COUNT on ""concert.concert_ID"" to count the number of concerts. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""stadium"" and ""concert"" tables based on the foreign key relationship ""concert.Stadium_ID = stadium.Stadium_ID"" to associate each concert with its respective stadium. 4. Aggregation Structure: Use COUNT to aggregate the number of concerts for each stadium and GROUP BY ""stadium.Name"" to group the results by stadium.","[('Balmoor', 1), ('Glebe Park', 1), ('Recreation Park', 1), ('Somerset Park', 2), (""Stark's Park"", 1)]","[(""Stark's Park"", 1), ('Glebe Park', 1), ('Somerset Park', 2), ('Recreation Park', 1), ('Balmoor', 1)]",,1.0,
What are the countries having at least one car maker? List name and id.,"[countries.CountryName, countries.CountryId, car_makers.Country = countries.CountryId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT DISTINCT countries.CountryName, countries.CountryId FROM countries JOIN car_makers ON car_makers.Country = countries.CountryId;","SELECT T1.CountryName ,  T1.CountryId FROM COUNTRIES AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.CountryId HAVING count(*)  >=  1;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countries.CountryName"" and ""countries.CountryId."" 2. Condition Structure: Use a WHERE clause to filter for countries that have at least one car maker. This can be achieved by checking the existence of related records in the ""car_makers"" table. 3. Join Structure: Use an INNER JOIN between the ""countries"" table and the ""car_makers"" table on the ""countries.CountryId"" and ""car_makers.Country"" columns to link countries with their car makers. 4. Aggregation Structure: Use DISTINCT to ensure that each country is listed only once, as we are only interested in countries with at least one car maker.","[('usa', 1), ('germany', 2), ('france', 3), ('japan', 4), ('italy', 5), ('sweden', 6), ('uk', 7), ('korea', 8)]","[('usa', 1), ('germany', 2), ('france', 3), ('japan', 4), ('italy', 5), ('sweden', 6), ('uk', 7), ('korea', 8)]",,1.0,
Find the number of concerts happened in the stadium with the highest capacity .,"[stadium.Capacity, stadium.Stadium_ID, concert.Stadium_ID = stadium.Stadium_ID, concert.concert_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,SELECT COUNT(concert.concert_ID) AS number_of_concerts FROM concert JOIN stadium ON concert.Stadium_ID = stadium.Stadium_ID WHERE stadium.Capacity = (SELECT MAX(Capacity) FROM stadium);,select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1),concert_singer,1. Sequential Structure: Start with the SELECT clause to count the number of concerts. Use the FROM clause to specify the concert table and join it with the stadium table to access the capacity information. Apply a WHERE clause to filter for the stadium with the highest capacity. 2. Condition Structure: Use a WHERE clause with a subquery to filter for the stadium with the maximum capacity. 3. Join Structure: Use an INNER JOIN between the concert and stadium tables based on the Stadium_ID to connect concerts with their respective stadiums. 4. Aggregation Structure: Use COUNT to calculate the total number of concerts held in the stadium with the highest capacity.,"[(0,)]","[(0,)]",,1.0,
What are all the song names by singers who are older than average?,"[singer.Song_Name, singer.Age, stadium.Average]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,SELECT Song_Name FROM singer WHERE Age > (SELECT AVG(Age) FROM singer);,SELECT song_name FROM singer WHERE age  >  (SELECT avg(age) FROM singer),concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the song names from the singer table. Use the FROM clause to specify the singer table. Apply a WHERE clause to filter singers whose age is greater than the average age of all singers. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average age of all singers and filter for singers whose age is greater than this value. 3. Join Structure: Not required, as all the necessary data is in the singer table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average age of all singers, which is then used in the filtering condition.","[('You',), ('Sun',), ('Gentleman',)]","[('You',), ('Sun',), ('Gentleman',)]",,1.0,
What is the minimum weight of the car with 8 cylinders produced in 1974 ?,"[cars_data.Weight, cars_data.Cylinders, cars_data.Year]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT MIN(cars_data.Weight) AS min_weight FROM cars_data WHERE cars_data.Cylinders = 8 AND cars_data.Year = 1974;,select min(weight) from cars_data where cylinders  =  8 and year  =  1974,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the minimum weight of the car. Use the MIN function on ""cars_data.Weight"" to find the minimum value. 2. Condition Structure: Use a WHERE clause to filter for cars with 8 cylinders and produced in the year 1974. This involves filtering ""cars_data.Cylinders"" to 8 and ""cars_data.Year"" to 1974. 3. Join Structure: No JOIN is required since all necessary information is available in the ""cars_data"" table. 4. Aggregation Structure: Use the MIN function to calculate the minimum weight among the filtered cars.","[(4141,)]","[(4141,)]",,1.0,
Find the last name of the student who has a cat that is age 3.,"[Student.LName, Has_Pet.StuID = Student.StuID, Has_Pet.PetID = Pets.PetID, Pets.PetType, Pets.pet_age, cat, 3]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT Student.LName FROM Student JOIN Has_Pet ON Has_Pet.StuID = Student.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'cat' AND Pets.pet_age = 3;,SELECT T1.lname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pet_age  =  3 AND T3.pettype  =  'cat',pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student.LName"" field, as the question asks for the last name of the student. 2. Condition Structure: Use a WHERE clause to filter for records where the ""Pets.PetType"" is 'cat' and ""Pets.pet_age"" is 3. 3. Join Structure: Use JOINs to connect the ""Student"" table with the ""Has_Pet"" table on ""Has_Pet.StuID = Student.StuID"" and the ""Has_Pet"" table with the ""Pets"" table on ""Has_Pet.PetID = Pets.PetID"" to link students with their pets. 4. Aggregation Structure: No aggregation is needed, as the query only retrieves specific information about a single student.","[('Smith',)]","[('Smith',)]",,1.0,
Show location and name for all stadiums with a capacity between 5000 and 10000.,"[stadium.Location, stadium.Name, stadium.Capacity, 5000, 10000]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT stadium.Location, stadium.Name FROM stadium WHERE stadium.Capacity BETWEEN 5000 AND 10000;","SELECT LOCATION ,  name FROM stadium WHERE capacity BETWEEN 5000 AND 10000",concert_singer,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""stadium.Location"" and ""stadium.Name"". 2. Condition Structure: Use a WHERE clause to filter stadiums with a ""stadium.Capacity"" between 5000 and 10000. 3. Join Structure: No JOIN is required since all necessary data is within the ""stadium"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving stadiums that meet the specified capacity condition.",[],[],,1.0,
List all song names by singers above the average age.,"[singer.Song_Name, singer.Age]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,SELECT Song_Name FROM singer WHERE Age > (SELECT AVG(Age) FROM singer);,SELECT song_name FROM singer WHERE age  >  (SELECT avg(age) FROM singer),concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the song names from the singer table. Use the FROM clause to specify the singer table. Apply a WHERE clause to filter singers whose age is above the average age. 2. Condition Structure: Use the WHERE clause with a subquery to filter for singers whose age is greater than the average age. The subquery calculates the average age of all singers. 3. Join Structure: Not required, as all data is in the singer table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average age of singers, which is then used in the filtering condition.","[('You',), ('Sun',), ('Gentleman',)]","[('You',), ('Sun',), ('Gentleman',)]",,1.0,
Find the first name of students who have both cat and dog pets .,"[Student.Fname,Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID,Pets.PetType]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NESTED,SELECT DISTINCT Student.Fname FROM Student JOIN Has_Pet ON Student.StuID = Has_Pet.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE EXISTS ( SELECT 1 FROM Has_Pet AS HP1 JOIN Pets AS P1 ON HP1.PetID = P1.PetID WHERE HP1.StuID = Student.StuID AND P1.PetType = 'cat' ) AND EXISTS ( SELECT 1 FROM Has_Pet AS HP2 JOIN Pets AS P2 ON HP2.PetID = P2.PetID WHERE HP2.StuID = Student.StuID AND P2.PetType = 'dog' );,select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'cat' intersect select t1.fname from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid join pets as t3 on t3.petid  =  t2.petid where t3.pettype  =  'dog',pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the first names of students. Use the FROM clause to specify the Student table and JOIN it with the Has_Pet and Pets tables to connect students with their pets. Apply a WHERE clause to filter students who have both a cat and a dog. 2. Condition Structure: Use the WHERE clause with EXISTS subqueries to ensure that a student has both a pet of type 'cat' and a pet of type 'dog'. 3. Join Structure: Use INNER JOINs between the Student, Has_Pet, and Pets tables based on the foreign key relationships (Has_Pet.StuID = Student.StuID and Has_Pet.PetID = Pets.PetID) to link students with their pets. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",[],[],,1.0,
How many pets have a greater weight than 10?,"[Pets.weight, Pets.PetID, Has_Pet.PetID = Pets.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",EASY,SELECT COUNT(*) FROM Pets WHERE Pets.weight > 10;,SELECT count(*) FROM pets WHERE weight  >  10,pets_1,"1. Sequential Structure: Start with the SELECT clause to count the number of pets with a weight greater than 10. 2. Condition Structure: Use a WHERE clause to filter pets where ""Pets.weight"" is greater than 10. 3. Join Structure: No JOIN is required since the necessary information is available in the ""Pets"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of pets meeting the weight condition.","[(2,)]","[(2,)]",,1.0,
How many pets are owned by students that have an age greater than 20?,"[Student.StuID,Student.Age,Has_Pet.StuID = Student.StuID,Has_Pet.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT COUNT(Has_Pet.PetID) FROM Student JOIN Has_Pet ON Student.StuID = Has_Pet.StuID WHERE Student.Age > 20;,SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.age  >  20,pets_1,"1. Sequential Structure: Start with the SELECT clause to count the number of pets owned by students. Use COUNT on ""Has_Pet.PetID"" to count the pets. 2. Condition Structure: Use a WHERE clause to filter for students whose age is greater than 20. 3. Join Structure: Use an INNER JOIN between the ""Student"" table and the ""Has_Pet"" table on ""Student.StuID = Has_Pet.StuID"" to associate students with their pets. 4. Aggregation Structure: Use COUNT to aggregate the number of pets owned by students meeting the age condition.","[(0,)]","[(0,)]",,1.0,
Find the first name of students who have cat or dog pet.,"[Student.Fname,Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID,Pets.PetType,cat,dog]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT Student.Fname FROM Student JOIN Has_Pet ON Has_Pet.StuID = Student.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'cat' OR Pets.PetType = 'dog';,SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' OR T3.pettype  =  'dog',pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the first names of students, i.e., ""Student.Fname."" 2. Condition Structure: Use a WHERE clause to filter for records where the ""Pets.PetType"" is either 'cat' or 'dog.' 3. Join Structure: Use JOINs to connect the ""Student"" table with the ""Has_Pet"" table on ""Has_Pet.StuID = Student.StuID"" and the ""Has_Pet"" table with the ""Pets"" table on ""Has_Pet.PetID = Pets.PetID"" to link students with their pets. 4. Aggregation Structure: No aggregation is needed as we are retrieving individual student names.","[('Linda',), ('Tracy',), ('Tracy',)]","[('Linda',), ('Tracy',)]",,1.0,
What are the students' first names who have both cats and dogs as pets?,"[Student.Fname,Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID,Pets.PetType]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NESTED,"SELECT Student.Fname FROM Student JOIN Has_Pet ON Student.StuID = Has_Pet.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Student.StuID IN ( SELECT StuID FROM Has_Pet JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType IN ('Cat', 'Dog') GROUP BY StuID HAVING COUNT(DISTINCT Pets.PetType) = 2 );",SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' INTERSECT SELECT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog',pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the first names of students. Use the FROM clause to specify the Student table and JOIN it with the Has_Pet table to link students with their pets. Further, JOIN the Pets table to access the type of pets owned by the students. Use a WHERE clause to filter students who have both cats and dogs as pets. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the student has both 'Cat' and 'Dog' as pet types. This can be achieved by grouping by the student ID and filtering using a HAVING clause to check for both pet types. 3. Join Structure: Use INNER JOINs between the Student, Has_Pet, and Pets tables based on the foreign key relationships (Has_Pet.StuID = Student.StuID and Has_Pet.PetID = Pets.PetID) to connect students with their pets and their pet types. 4. Aggregation Structure: Use GROUP BY on the student ID to group records by each student and use the HAVING clause to ensure that both 'Cat' and 'Dog' pet types exist for the student.",[],[],,1.0,
What are the number of concerts that occurred in the stadium with the largest capacity ?,"[stadium.Capacity, concert.Stadium_ID, concert.concert_ID, concert.Stadium_ID = stadium.Stadium_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,SELECT COUNT(concert.concert_ID) AS number_of_concerts FROM concert JOIN stadium ON concert.Stadium_ID = stadium.Stadium_ID WHERE stadium.Capacity = (SELECT MAX(Capacity) FROM stadium);,select count(*) from concert where stadium_id = (select stadium_id from stadium order by capacity desc limit 1),concert_singer,1. Sequential Structure: Start with the SELECT clause to count the number of concerts. Use the FROM clause to specify the concert table and join it with the stadium table to access the capacity information. Apply a WHERE clause to filter for the stadium with the largest capacity. 2. Condition Structure: Use a WHERE clause with a subquery to filter for the stadium with the maximum capacity. 3. Join Structure: Use an INNER JOIN between the concert and stadium tables based on the Stadium_ID to connect concerts with their respective stadiums. 4. Aggregation Structure: Use COUNT to calculate the total number of concerts that occurred in the stadium with the largest capacity.,"[(0,)]","[(0,)]",,1.0,
What are the names and release years for all the songs of the youngest singer?,"[singer.Name, singer.Song_Name, singer.Song_release_year, singer.Age]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,"SELECT Song_Name, Song_release_year FROM singer WHERE Age = (SELECT MIN(Age) FROM singer);","SELECT song_name ,  song_release_year FROM singer ORDER BY age LIMIT 1",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the song names and release years. Use the FROM clause to specify the singer table. Apply a WHERE clause to filter for the youngest singer by identifying the minimum age. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the singer with the minimum age. 3. Join Structure: Not required, as all the necessary data is available in the singer table. 4. Aggregation Structure: Use the MIN function in a subquery to find the minimum age, which is then used in the filtering condition.","[('Love', '2016')]","[('Love', '2016')]",,1.0,
What are the makers and models?,"[car_makers.Maker, model_list.Model, model_list.Maker = car_makers.Id]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT car_makers.Maker, model_list.Model FROM car_makers JOIN model_list ON model_list.Maker = car_makers.Id;","SELECT Maker ,  Model FROM MODEL_LIST;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve ""car_makers.Maker"" and ""model_list.Model."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between ""car_makers"" and ""model_list"" on ""model_list.Maker = car_makers.Id"" to link each maker with its respective models. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the makers and their models.","[('amc', 'amc'), ('volkswagen', 'audi'), ('bmw', 'bmw'), ('gm', 'buick'), ('gm', 'cadillac'), ('ford', 'capri'), ('gm', 'chevrolet'), ('chrysler', 'chrysler'), ('citroen', 'citroen'), ('nissan', 'datsun'), ('chrysler', 'dodge'), ('fiat', 'fiat'), ('ford', 'ford'), ('honda', 'honda'), ('mazda', 'mazda'), ('daimler benz', 'mercedes'), ('daimler benz', 'mercedes-benz'), ('ford', 'mercury'), ('nissan', 'nissan'), ('gm', 'oldsmobile'), ('opel', 'opel'), ('peugeaut', 'peugeot'), ('chrysler', 'plymouth'), ('gm', 'pontiac'), ('renault', 'renault'), ('saab', 'saab'), ('subaru', 'subaru'), ('toyota', 'toyota'), ('triumph', 'triumph'), ('volkswagen', 'volkswagen'), ('volvo', 'volvo'), ('kia', 'kia'), ('hyundai', 'hyundai'), ('chrysler', 'jeep'), ('toyota', 'scion')]","[(1, 'amc'), (2, 'audi'), (3, 'bmw'), (4, 'buick'), (4, 'cadillac'), (5, 'capri'), (4, 'chevrolet'), (6, 'chrysler'), (7, 'citroen'), (8, 'datsun'), (6, 'dodge'), (9, 'fiat'), (5, 'ford'), (10, 'hi'), (11, 'honda'), (12, 'mazda'), (13, 'mercedes'), (13, 'mercedes-benz'), (5, 'mercury'), (8, 'nissan'), (4, 'oldsmobile'), (14, 'opel'), (15, 'peugeot'), (6, 'plymouth'), (4, 'pontiac'), (16, 'renault'), (17, 'saab'), (18, 'subaru'), (19, 'toyota'), (20, 'triumph'), (2, 'volkswagen'), (21, 'volvo'), (22, 'kia'), (23, 'hyundai'), (6, 'jeep'), (19, 'scion')]",,0.0,
What is the number of car models that are produced by each maker and what is the id and full name of each maker?,"[model_list.Model,model_list.Maker,car_makers.Id = model_list.Maker,car_makers.Id,car_makers.FullName]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT car_makers.Id, car_makers.FullName, COUNT(model_list.Model) AS NumberOfModels FROM car_makers JOIN model_list ON car_makers.Id = model_list.Maker GROUP BY car_makers.Id, car_makers.FullName;","SELECT Count(*) ,  T2.FullName ,  T2.id FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id GROUP BY T2.id;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the number of car models for each maker, along with the maker's ID and full name. Use COUNT to count the number of models and include ""car_makers.Id"" and ""car_makers.FullName"" in the SELECT clause. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""car_makers"" table with the ""model_list"" table based on the relationship ""car_makers.Id = model_list.Maker."" 4. Aggregation Structure: Use COUNT on ""model_list.Model"" to count the number of models for each maker, and GROUP BY ""car_makers.Id"" and ""car_makers.FullName"" to group the results by each maker.","[(1, 'American Motor Company', 1), (2, 'Volkswagen', 2), (3, 'BMW', 1), (4, 'General Motors', 5), (5, 'Ford Motor Company', 3), (6, 'Chrysler', 4), (7, 'Citroen', 1), (8, 'Nissan Motors', 2), (9, 'Fiat', 1), (11, 'Honda', 1), (12, 'Mazda', 1), (13, 'Daimler Benz', 2), (14, 'Opel', 1), (15, 'Peugeaut', 1), (16, 'Renault', 1), (17, 'Saab', 1), (18, 'Subaru', 1), (19, 'Toyota', 2), (20, 'Triumph', 1), (21, 'Volvo', 1), (22, 'Kia Motors', 1), (23, 'Hyundai', 1)]","[(1, 'American Motor Company', 1), (2, 'Volkswagen', 2), (1, 'BMW', 3), (5, 'General Motors', 4), (3, 'Ford Motor Company', 5), (4, 'Chrysler', 6), (1, 'Citroen', 7), (2, 'Nissan Motors', 8), (1, 'Fiat', 9), (1, 'Honda', 11), (1, 'Mazda', 12), (2, 'Daimler Benz', 13), (1, 'Opel', 14), (1, 'Peugeaut', 15), (1, 'Renault', 16), (1, 'Saab', 17), (1, 'Subaru', 18), (2, 'Toyota', 19), (1, 'Triumph', 20), (1, 'Volvo', 21), (1, 'Kia Motors', 22), (1, 'Hyundai', 23)]",,1.0,
How many concerts occurred in 2014 or 2015?,[concert.Year],"Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT COUNT(*) FROM concert WHERE concert.Year IN (2014, 2015);",SELECT count(*) FROM concert WHERE YEAR  =  2014 OR YEAR  =  2015,concert_singer,"1. Sequential Structure: Start with the SELECT clause to count the number of concerts that occurred in the specified years. 2. Condition Structure: Use a WHERE clause to filter concerts where the ""concert.Year"" is either 2014 or 2015. 3. Join Structure: No JOIN is required since all necessary information is in the ""concert"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of concerts that meet the specified condition.","[(6,)]","[(6,)]",,1.0,
"What is the average, minimum, and maximum age of all singers from France?","[singer.Age, singer.Country, France]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT AVG(singer.Age) AS avg_age, MIN(singer.Age) AS min_age, MAX(singer.Age) AS max_age FROM singer WHERE singer.Country = 'France';","SELECT avg(age) ,  min(age) ,  max(age) FROM singer WHERE country  =  'France'",concert_singer,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average, minimum, and maximum ages of singers. 2. Condition Structure: Use a WHERE clause to filter singers whose ""Country"" is 'France'. 3. Join Structure: No JOIN is required since all necessary data is within the ""singer"" table. 4. Aggregation Structure: Use AVG, MIN, and MAX functions to calculate the average, minimum, and maximum ages of the singers.","[(34.5, 25, 43)]","[(34.5, 25, 43)]",,1.0,
Show countries where a singer above age 40 and a singer below 30 are from.,"[singer.Country, singer.Age]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,SELECT DISTINCT Country FROM singer WHERE Age > 40 OR Age < 30;,SELECT country FROM singer WHERE age  >  40 INTERSECT SELECT country FROM singer WHERE age  <  30,concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct countries of singers. Use the FROM clause to specify the singer table. Apply a WHERE clause to filter singers based on their age, specifically those above 40 and those below 30. 2. Condition Structure: Use the WHERE clause with conditions to filter singers whose age is greater than 40 or less than 30. 3. Join Structure: Not required, as all the necessary data is available in the singer table. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('Netherlands',), ('France',)]","[('France',)]",,1.0,
How many different types of pet are there?,[Pets.PetType],"Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",EASY,SELECT COUNT(DISTINCT Pets.PetType) AS num_pet_types FROM Pets;,SELECT count(DISTINCT pettype) FROM pets,pets_1,"1. Sequential Structure: Begin with the SELECT clause to count the distinct types of pets, as the question asks for the number of different pet types. 2. Condition Structure: No specific filtering condition is required since we are interested in all pet types. 3. Join Structure: No JOIN is necessary because the required information is available within the ""Pets"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Pets.PetType"" to count the unique pet types.","[(2,)]","[(2,)]",,1.0,
What is the average weight of cars each year?,"[cars_data.Weight, cars_data.Year]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,"SELECT cars_data.Year, AVG(cars_data.Weight) AS avg_weight FROM cars_data GROUP BY cars_data.Year;","SELECT avg(Weight) ,  YEAR FROM CARS_DATA GROUP BY YEAR;",car_1,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the year and the average weight of cars. 2. Aggregation Structure: Use the AVG function to calculate the average weight of cars for each year. 3. Grouping Structure: Use GROUP BY on ""cars_data.Year"" to calculate the average weight for each year. 4. Join Structure: No JOIN is required since all necessary data is within the ""cars_data"" table.","[(1970, 3441.3142857142857), (1971, 2960.344827586207), (1972, 3237.714285714286), (1973, 3419.025), (1974, 2877.925925925926), (1975, 3176.8), (1976, 3078.735294117647), (1977, 2997.3571428571427), (1978, 2861.8055555555557), (1979, 3055.344827586207), (1980, 2436.655172413793), (1981, 2532.1666666666665), (1982, 2453.548387096774)]","[(3441.3142857142857, 1970), (2960.344827586207, 1971), (3237.714285714286, 1972), (3419.025, 1973), (2877.925925925926, 1974), (3176.8, 1975), (3078.735294117647, 1976), (2997.3571428571427, 1977), (2861.8055555555557, 1978), (3055.344827586207, 1979), (2436.655172413793, 1980), (2532.1666666666665, 1981), (2453.548387096774, 1982)]",,1.0,
List all singer names in concerts in year 2014.,"[singer.Name, concert.Year, singer_in_concert.Singer_ID = singer.Singer_ID, singer_in_concert.concert_ID = concert.concert_ID, 2014]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NON-NESTED,SELECT DISTINCT singer.Name FROM singer_in_concert JOIN singer ON singer_in_concert.Singer_ID = singer.Singer_ID JOIN concert ON singer_in_concert.concert_ID = concert.concert_ID WHERE concert.Year = 2014;,SELECT T2.name FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id JOIN concert AS T3 ON T1.concert_id  =  T3.concert_id WHERE T3.year  =  2014,concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of singers (""singer.Name""). 2. Condition Structure: Use a WHERE clause to filter for concerts that occurred in the year 2014 (""concert.Year = 2014""). 3. Join Structure: Use JOINs to connect the ""singer_in_concert"" table with the ""singer"" table on ""Singer_ID"" and with the ""concert"" table on ""concert_ID"" to link singers with their respective concerts. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique singer names are returned.","[('Timbaland',), ('Justin Brown',), ('John Nizinik',), ('Tribal King',), ('Rose White',)]","[('Timbaland',), ('Justin Brown',), ('John Nizinik',), ('Justin Brown',), ('Tribal King',), ('Rose White',)]",,1.0,
Find the first name and age of students who have a dog but do not have a cat as a pet.,"[Student.Fname, Student.Age, Has_Pet.StuID = Student.StuID, Has_Pet.PetID = Pets.PetID, Pets.PetType, dog, cat]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NESTED,"SELECT Student.Fname, Student.Age FROM Student JOIN Has_Pet ON Student.StuID = Has_Pet.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'dog' AND Student.StuID NOT IN ( SELECT Student.StuID FROM Student JOIN Has_Pet ON Student.StuID = Has_Pet.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'cat' );","SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the first name and age of students. Use the FROM clause to specify the Student table and JOIN it with the Has_Pet table to link students with their pets. Further, JOIN the Pets table to access the type of pet. Apply a WHERE clause to filter students who have a dog but do not have a cat. 2. Condition Structure: Use the WHERE clause to filter for students who have a dog by checking the PetType column. Use a subquery to exclude students who have a cat by ensuring their StuID is not in the list of students with a cat. 3. Join Structure: Use INNER JOINs between the Student, Has_Pet, and Pets tables based on the foreign key relationships (Has_Pet.StuID = Student.StuID and Has_Pet.PetID = Pets.PetID) to connect students with their pets. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('Tracy', 19), ('Tracy', 19)]","[('Tracy', 19), ('Tracy', 19)]",,1.0,
How much does the youngest dog weigh?,"[Pets.weight, Pets.PetType, Pets.pet_age, Has_Pet.PetID = Pets.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT Pets.weight FROM Pets WHERE Pets.PetType = 'dog' ORDER BY Pets.pet_age ASC LIMIT 1;,SELECT weight FROM pets ORDER BY pet_age LIMIT 1,pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the weight of the youngest dog. Since we are looking for the youngest dog, we will use ORDER BY on ""Pets.pet_age"" in ascending order and LIMIT 1 to get the youngest dog. 2. Condition Structure: Use a WHERE clause to filter for records where ""Pets.PetType"" is 'dog'. 3. Join Structure: No JOIN is required as all the necessary information is available in the ""Pets"" table. 4. Aggregation Structure: No aggregation is needed since we are only retrieving the weight of a single record (the youngest dog).","[(9.3,)]","[(9.3,)]",,1.0,
What is the id of the pet owned by the student whose last name is 'Smith'?,"[Student.StuID,Student.LName,Has_Pet.StuID = Student.StuID,Has_Pet.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT Has_Pet.PetID FROM Student JOIN Has_Pet ON Student.StuID = Has_Pet.StuID WHERE Student.LName = 'Smith';,SELECT T2.petid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.Lname  =  'Smith',pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Has_Pet.PetID,"" which represents the ID of the pet owned by the student. 2. Condition Structure: Use a WHERE clause to filter for the student whose last name (""Student.LName"") is 'Smith.' 3. Join Structure: Use an INNER JOIN between the ""Student"" table and the ""Has_Pet"" table on the ""StuID"" field to associate students with their pets. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific data without summarization.","[(2001,)]","[(2001,)]",,1.0,
What are  the different countries with singers above age 20?,"[singer.Country, singer.Age]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,SELECT DISTINCT singer.Country FROM singer WHERE singer.Age > 20;,SELECT DISTINCT country FROM singer WHERE age  >  20,concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct countries of singers. 2. Condition Structure: Use a WHERE clause to filter singers whose age is above 20. 3. Join Structure: No JOIN is required since all necessary information is in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is used to ensure unique countries are retrieved.","[('Netherlands',), ('United States',), ('France',)]","[('Netherlands',), ('United States',), ('France',)]",,1.0,
Which model of the car has the minimum horsepower?,"[cars_data.Horsepower,car_names.Model,cars_data.Id = car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT car_names.Model FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Horsepower = (SELECT MIN(Horsepower) FROM cars_data);,SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""car_names.Model"" of the car with the minimum horsepower. Use the MIN function on ""cars_data.Horsepower"" to find the minimum value. 2. Condition Structure: No specific filtering condition is needed, as we are looking for the car with the minimum horsepower across all records. 3. Join Structure: Use a JOIN between the ""cars_data"" and ""car_names"" tables based on the foreign key relationship ""cars_data.Id = car_names.MakeId"" to link car data with their respective models. 4. Aggregation Structure: Use MIN to find the minimum horsepower, and apply it to retrieve the corresponding car model.","[('amc',), ('chevrolet',), ('amc',), ('pontiac',), ('chevrolet',), ('amc',), ('amc',), ('amc',), ('chevrolet',), ('chevrolet',), ('amc',), ('plymouth',), ('dodge',), ('plymouth',), ('plymouth',), ('mazda',), ('datsun',)]","[('amc',)]",,1.0,
What is the number of cars with a horsepower greater than 150?,"[cars_data.Horsepower,150]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT COUNT(*) FROM cars_data WHERE cars_data.Horsepower > 150;,SELECT count(*) FROM CARS_DATA WHERE horsepower  >  150;,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of cars with a horsepower greater than 150. 2. Condition Structure: Use a WHERE clause to filter cars where ""cars_data.Horsepower"" is greater than 150. 3. Join Structure: No JOIN is required since all necessary information is in the ""cars_data"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cars that meet the specified horsepower condition.","[(281,)]","[(281,)]",,1.0,
Show the name and theme for all concerts and the number of singers in each concert.,"[concert.concert_Name, concert.Theme, singer_in_concert.concert_ID, singer_in_concert.Singer_ID, concert.concert_ID = singer_in_concert.concert_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NON-NESTED,"SELECT concert.concert_Name, concert.Theme, COUNT(singer_in_concert.Singer_ID) AS number_of_singers FROM concert JOIN singer_in_concert ON concert.concert_ID = singer_in_concert.concert_ID GROUP BY concert.concert_ID;","SELECT T2.concert_name ,  T2.theme ,  count(*) FROM singer_in_concert AS T1 JOIN concert AS T2 ON T1.concert_id  =  T2.concert_id GROUP BY T2.concert_id",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve ""concert.concert_Name,"" ""concert.Theme,"" and the count of singers in each concert. Use COUNT on ""singer_in_concert.Singer_ID"" to count the number of singers. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""concert"" and ""singer_in_concert"" tables based on ""concert.concert_ID"" to link each concert with its singers. 4. Aggregation Structure: Use COUNT to count the number of singers for each concert and GROUP BY ""concert.concert_ID"" to group results by each concert.","[('Auditions', 'Free choice', 3), ('Super bootcamp', 'Free choice 2', 2), ('Home Visits', 'Bleeding Love', 1), ('Week 1', 'Wide Awake', 1), ('Week 1', 'Happy Tonight', 2), ('Week 2', 'Party All Night', 1)]","[('Auditions', 'Free choice', 3), ('Super bootcamp', 'Free choice 2', 2), ('Home Visits', 'Bleeding Love', 1), ('Week 1', 'Wide Awake', 1), ('Week 1', 'Happy Tonight', 2), ('Week 2', 'Party All Night', 1)]",,1.0,
Which of the countries has the most car makers? List the country name.,"[countries.CountryName,car_makers.Country,countries.CountryId = car_makers.Country]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT countries.CountryName FROM countries JOIN car_makers ON countries.CountryId = car_makers.Country GROUP BY countries.CountryName ORDER BY COUNT(car_makers.Id) DESC LIMIT 1;,SELECT T2.CountryName FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId GROUP BY T1.Country ORDER BY Count(*) DESC LIMIT 1;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countries.CountryName"" and the count of car makers for each country. Use an aggregate function (COUNT) to count the number of car makers per country. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all countries. 3. Join Structure: Use a JOIN between the ""countries"" and ""car_makers"" tables based on the relationship ""countries.CountryId = car_makers.Country"" to associate each country with its car makers. 4. Aggregation Structure: Use COUNT to count the number of car makers per country, then use ORDER BY in descending order to rank countries by the number of car makers. Use LIMIT 1 to select the country with the most car makers.","[('japan',)]","[('japan',)]",,1.0,
What is the year that had the most concerts?,"[concert.Year, concert.concert_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,SELECT concert.Year FROM concert GROUP BY concert.Year ORDER BY COUNT(concert.concert_ID) DESC LIMIT 1;,SELECT YEAR FROM concert GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1,concert_singer,"1. Sequential Structure: Begin with the SELECT clause to retrieve the ""concert.Year"" since the question asks for the year with the most concerts. 2. Condition Structure: No specific filtering condition is required as we are analyzing all years. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""concert"" table. 4. Aggregation Structure: Use COUNT to count the number of concerts for each year. Use GROUP BY on ""concert.Year"" to group the data by year. Use ORDER BY in descending order on the count to rank the years by the number of concerts. Apply LIMIT 1 to retrieve the year with the most concerts.","[('2015',)]","[('2015',)]",,1.0,
How many dog pets are raised by female students?,"[Pets.PetType, Student.Sex, Has_Pet.StuID = Student.StuID, Has_Pet.PetID = Pets.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT COUNT(*) FROM Has_Pet JOIN Student ON Has_Pet.StuID = Student.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'dog' AND Student.Sex = 'female';,SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T2.petid  =  T3.petid WHERE T1.sex  =  'F' AND T3.pettype  =  'dog',pets_1,"1. Sequential Structure: Start with the SELECT clause to count the number of dog pets raised by female students. Use COUNT to aggregate the results. 2. Condition Structure: Use a WHERE clause to filter for ""Pets.PetType"" as 'dog' and ""Student.Sex"" as 'female.' 3. Join Structure: Use JOINs to connect the ""Has_Pet"" table with the ""Student"" table on ""Has_Pet.StuID = Student.StuID"" and the ""Pets"" table on ""Has_Pet.PetID = Pets.PetID"" to link students with their pets. 4. Aggregation Structure: Use COUNT to calculate the total number of dog pets raised by female students.","[(0,)]","[(2,)]",,0.0,
What are the different first names and ages of the students who do have pets?,"[Student.Fname, Student.Age, Has_Pet.StuID = Student.StuID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,"SELECT DISTINCT Student.Fname, Student.Age FROM Student JOIN Has_Pet ON Student.StuID = Has_Pet.StuID;","SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid",pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct first names (""Student.Fname"") and ages (""Student.Age"") of students who have pets. 2. Condition Structure: No specific filtering condition is needed beyond ensuring that the student has a pet, which is implied by the presence of a matching record in the ""Has_Pet"" table. 3. Join Structure: Use an INNER JOIN between the ""Student"" table and the ""Has_Pet"" table on the ""StuID"" field to link students with their pets. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique combinations of first names and ages are returned.","[('Linda', 18), ('Tracy', 19)]","[('Linda', 18), ('Tracy', 19)]",,1.0,
List the maximum weight and type for each type of pet.,"[Pets.PetType, Pets.weight]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",EASY,"SELECT Pets.PetType, MAX(Pets.weight) AS max_weight FROM Pets GROUP BY Pets.PetType;","SELECT max(weight) ,  petType FROM pets GROUP BY petType",pets_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the pet type and the maximum weight for each type of pet. 2. Aggregation Structure: Use the MAX function to calculate the maximum weight for each pet type. 3. Grouping Structure: Use GROUP BY on ""Pets.PetType"" to calculate the maximum weight for each type of pet. 4. Join Structure: No JOIN is required since all necessary data is within the ""Pets"" table.","[('cat', 12.0), ('dog', 13.4)]","[(12.0, 'cat'), (13.4, 'dog')]",,1.0,
Find the id of students who do not have a cat pet.,"[Student.StuID,Has_Pet.StuID = Student.StuID,Has_Pet.PetID,Pets.PetID = Has_Pet.PetID,Pets.PetType,cat]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NESTED,SELECT Student.StuID FROM Student WHERE Student.StuID NOT IN ( SELECT Has_Pet.StuID FROM Has_Pet JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'cat' );,SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat',pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the student IDs. Use the FROM clause to specify the Student table. Use a WHERE clause to filter students who do not have a cat pet by ensuring their IDs are not associated with a pet of type 'cat'. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose IDs are linked to a pet of type 'cat' in the Pets table. 3. Join Structure: Use INNER JOINs between the Student, Has_Pet, and Pets tables based on the relationships defined by the foreign keys to connect students with their pets and pet types. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[(1002,), (1003,), (1004,), (1005,), (1006,), (1007,), (1008,), (1009,), (1010,), (1011,), (1012,), (1014,), (1015,), (1016,), (1017,), (1018,), (1019,), (1020,), (1021,), (1022,), (1023,), (1024,), (1025,), (1026,), (1027,), (1028,), (1029,), (1030,), (1031,), (1032,), (1033,), (1034,), (1035,)]","[(1002,), (1003,), (1004,), (1005,), (1006,), (1007,), (1008,), (1009,), (1010,), (1011,), (1012,), (1014,), (1015,), (1016,), (1017,), (1018,), (1019,), (1020,), (1021,), (1022,), (1023,), (1024,), (1025,), (1026,), (1027,), (1028,), (1029,), (1030,), (1031,), (1032,), (1033,), (1034,), (1035,)]",,1.0,
"What is the average, minimum, and maximum age for all French singers?","[singer.Age, singer.Country]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT AVG(singer.Age) AS avg_age, MIN(singer.Age) AS min_age, MAX(singer.Age) AS max_age FROM singer WHERE singer.Country = 'France';","SELECT avg(age) ,  min(age) ,  max(age) FROM singer WHERE country  =  'France'",concert_singer,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average, minimum, and maximum ages of singers. 2. Condition Structure: Use a WHERE clause to filter for singers whose ""Country"" is 'France'. 3. Join Structure: No JOIN is required since all necessary data is within the ""singer"" table. 4. Aggregation Structure: Use AVG, MIN, and MAX functions to calculate the average, minimum, and maximum ages of the filtered singers.","[(34.5, 25, 43)]","[(34.5, 25, 43)]",,1.0,
Find the maximum weight for each type of pet. List the maximum weight and pet type.,"[Pets.PetType, Pets.weight]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",EASY,"SELECT Pets.PetType, MAX(Pets.weight) AS max_weight FROM Pets GROUP BY Pets.PetType;","SELECT max(weight) ,  petType FROM pets GROUP BY petType",pets_1,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the pet type and the maximum weight. 2. Aggregation Structure: Use the MAX function to calculate the maximum weight for each type of pet. 3. Grouping Structure: Use GROUP BY on ""Pets.PetType"" to calculate the maximum weight for each pet type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Pets"" table.","[('cat', 12.0), ('dog', 13.4)]","[(12.0, 'cat'), (13.4, 'dog')]",,1.0,
What are the different models for the cards produced after 1980?,"[cars_data.Year,car_names.Model,cars_data.Id = car_names.MakeId,1980]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT DISTINCT car_names.Model FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Year > 1980;,SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.model  =  T2.model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.id WHERE T3.year  >  1980;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""car_names.Model"" since we are looking for different models. 2. Condition Structure: Use a WHERE clause to filter for cars produced after the year 1980, i.e., ""cars_data.Year > 1980."" 3. Join Structure: Use a JOIN between the ""cars_data"" and ""car_names"" tables based on the foreign key relationship ""cars_data.Id = car_names.MakeId"" to link car data with their respective models. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique models are returned.","[('plymouth',), ('buick',), ('dodge',), ('chevrolet',), ('toyota',), ('honda',), ('subaru',), ('datsun',), ('mazda',), ('ford',), ('volkswagen',), ('renault',), ('peugeot',), ('saab',), ('volvo',), ('oldsmobile',), ('chrysler',), ('pontiac',), ('amc',), ('mercury',), ('nissan',)]","[('plymouth',), ('buick',), ('dodge',), ('chevrolet',), ('toyota',), ('honda',), ('subaru',), ('datsun',), ('mazda',), ('ford',), ('volkswagen',), ('renault',), ('peugeot',), ('saab',), ('volvo',), ('oldsmobile',), ('chrysler',), ('pontiac',), ('amc',), ('mercury',), ('nissan',)]",,1.0,
Find the make and production time of the cars that were produced in the earliest year?,"[cars_data.Year,car_names.Make,cars_data.Id = car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,"SELECT car_names.Make, cars_data.Year FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Year = (SELECT MIN(Year) FROM cars_data);","SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);",car_1,1. Sequential Structure: Start with the SELECT clause to retrieve the make and production year of the cars. Use the FROM clause to specify the cars_data and car_names tables. Apply a WHERE clause to filter for cars produced in the earliest year. 2. Condition Structure: Use a WHERE clause with a subquery to filter for the cars produced in the minimum year. The subquery calculates the earliest year from the cars_data table. 3. Join Structure: Use an INNER JOIN between the cars_data and car_names tables based on the Id and MakeId fields to connect car details with their make. 4. Aggregation Structure: Use MIN in the subquery to find the earliest production year.,"[('chevrolet chevelle malibu', 1970), ('buick skylark 320', 1970), ('plymouth satellite', 1970), ('amc rebel sst', 1970), ('ford torino', 1970), ('ford galaxie 500', 1970), ('chevrolet impala', 1970), ('plymouth fury iii', 1970), ('pontiac catalina', 1970), ('amc ambassador dpl', 1970), ('citroen ds-21 pallas', 1970), ('chevrolet chevelle concours (sw)', 1970), ('ford torino (sw)', 1970), ('plymouth satellite (sw)', 1970), ('amc rebel sst (sw)', 1970), ('dodge challenger se', 1970), ('plymouth cuda 340', 1970), ('ford mustang boss 302', 1970), ('chevrolet monte carlo', 1970), ('buick estate wagon (sw)', 1970), ('toyota corona mark ii', 1970), ('plymouth duster', 1970), ('amc hornet', 1970), ('ford maverick', 1970), ('datsun pl510', 1970), ('volkswagen 1131 deluxe sedan', 1970), ('peugeot 504', 1970), ('audi 100 ls', 1970), ('saab 99e', 1970), ('bmw 2002', 1970), ('amc gremlin', 1970), ('ford f250', 1970), ('chevy c20', 1970), ('dodge d200', 1970), ('hi 1200d', 1970)]","[('chevrolet chevelle malibu', 1970), ('buick skylark 320', 1970), ('plymouth satellite', 1970), ('amc rebel sst', 1970), ('ford torino', 1970), ('ford galaxie 500', 1970), ('chevrolet impala', 1970), ('plymouth fury iii', 1970), ('pontiac catalina', 1970), ('amc ambassador dpl', 1970), ('citroen ds-21 pallas', 1970), ('chevrolet chevelle concours (sw)', 1970), ('ford torino (sw)', 1970), ('plymouth satellite (sw)', 1970), ('amc rebel sst (sw)', 1970), ('dodge challenger se', 1970), ('plymouth cuda 340', 1970), ('ford mustang boss 302', 1970), ('chevrolet monte carlo', 1970), ('buick estate wagon (sw)', 1970), ('toyota corona mark ii', 1970), ('plymouth duster', 1970), ('amc hornet', 1970), ('ford maverick', 1970), ('datsun pl510', 1970), ('volkswagen 1131 deluxe sedan', 1970), ('peugeot 504', 1970), ('audi 100 ls', 1970), ('saab 99e', 1970), ('bmw 2002', 1970), ('amc gremlin', 1970), ('ford f250', 1970), ('chevy c20', 1970), ('dodge d200', 1970), ('hi 1200d', 1970)]",,1.0,
Find the type and weight of the youngest pet.,"[Pets.PetType, Pets.weight, Pets.pet_age]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",EASY,"SELECT Pets.PetType, Pets.weight FROM Pets WHERE Pets.pet_age = (SELECT MIN(Pets.pet_age) FROM Pets);","SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1",pets_1,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Pets.PetType"" and ""Pets.weight"". 2. Condition Structure: Use a WHERE clause to filter for the pet with the minimum age, as we are looking for the youngest pet. 3. Aggregation Structure: Use the MIN function to find the minimum age of pets. 4. Join Structure: No JOIN is required since all necessary data is within the ""Pets"" table.","[('dog', 9.3)]","[('dog', 9.3)]",,1.0,
What is the accelerate of the car make amc hornet sportabout (sw)?,"[cars_data.Accelerate,car_names.Make,car_names.Model,car_names.MakeId = cars_data.Id,car_names.Model = model_list.Model,model_list.Maker = car_makers.Id,car_makers.FullName]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT cars_data.Accelerate FROM car_names JOIN cars_data ON car_names.MakeId = cars_data.Id JOIN model_list ON car_names.Model = model_list.Model JOIN car_makers ON model_list.Maker = car_makers.Id WHERE car_makers.FullName = 'amc' AND car_names.Model = 'hornet sportabout (sw)';,SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""cars_data.Accelerate"" value for the specified car make and model. 2. Condition Structure: Use a WHERE clause to filter for the specific car make ""amc"" and model ""hornet sportabout (sw)."" 3. Join Structure: Use multiple JOINs to connect the relevant tables. First, join ""car_names"" with ""cars_data"" on ""car_names.MakeId = cars_data.Id"" to link car names with their data. Then, join ""car_names"" with ""model_list"" on ""car_names.Model = model_list.Model"" to link models with makers. Finally, join ""model_list"" with ""car_makers"" on ""model_list.Maker = car_makers.Id"" to get the full name of the car maker. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single value.",[],"[(13.5,)]",,0.0,
What are the names of the singers and number of concerts for each person?,"[singer.Name, singer.Singer_ID, singer_in_concert.Singer_ID = singer.Singer_ID, singer_in_concert.concert_ID, concert.concert_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NON-NESTED,"SELECT singer.Name, COUNT(singer_in_concert.concert_ID) AS Number_of_Concerts FROM singer JOIN singer_in_concert ON singer.Singer_ID = singer_in_concert.Singer_ID GROUP BY singer.Name;","SELECT T2.name ,  count(*) FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id GROUP BY T2.singer_id",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""singer.Name"" and the count of concerts for each singer. Use COUNT on ""singer_in_concert.concert_ID"" to count the number of concerts for each singer. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""singer"" and ""singer_in_concert"" tables on ""singer.Singer_ID = singer_in_concert.Singer_ID"" to associate each singer with their concert records. 4. Aggregation Structure: Use COUNT to aggregate the number of concerts for each singer and GROUP BY ""singer.Name"" to group the results by each singer.","[('John Nizinik', 2), ('Justin Brown', 3), ('Rose White', 1), ('Timbaland', 2), ('Tribal King', 2)]","[('Timbaland', 2), ('Justin Brown', 3), ('Rose White', 1), ('John Nizinik', 2), ('Tribal King', 2)]",,1.0,
Which year has most number of concerts?,[concert.Year],"Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,SELECT concert.Year FROM concert GROUP BY concert.Year ORDER BY COUNT(*) DESC LIMIT 1;,SELECT YEAR FROM concert GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1,concert_singer,"1. Sequential Structure: Begin with the SELECT clause to specify the year, as the question asks for the year with the most number of concerts. 2. Aggregation Structure: Use COUNT to calculate the number of concerts for each year. 3. Grouping Structure: Use GROUP BY on ""concert.Year"" to aggregate the results by year. 4. Ordering Structure: Use ORDER BY in descending order on the count of concerts to rank the years by the number of concerts. 5. Limiting Structure: Use LIMIT 1 to retrieve the year with the highest number of concerts. 6. Join Structure: No JOIN is required since all necessary data is within the ""concert"" table.","[('2015',)]","[('2015',)]",,1.0,
Find the number of pets whose weight is heavier than 10.,"[Pets.weight, Pets.PetID, Has_Pet.PetID = Pets.PetID, 10]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT COUNT(Pets.PetID) FROM Pets WHERE Pets.weight > 10;,SELECT count(*) FROM pets WHERE weight  >  10,pets_1,"1. Sequential Structure: Start with the SELECT clause to count the number of pets. Use COUNT on ""Pets.PetID"" to get the total number of pets meeting the condition. 2. Condition Structure: Use a WHERE clause to filter for pets whose weight is greater than 10. 3. Join Structure: No JOIN is required since the relevant data is available in the ""Pets"" table. 4. Aggregation Structure: Use COUNT to aggregate the number of pets that satisfy the weight condition.","[(2,)]","[(2,)]",,1.0,
How many singers do we have?,[singer.Singer_ID],"Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,SELECT COUNT(singer.Singer_ID) AS total_singers FROM singer;,SELECT count(*) FROM singer,concert_singer,"1. Sequential Structure: Start with the SELECT clause to count the number of singers. 2. Condition Structure: No specific filtering condition is required as we want the total count of singers. 3. Join Structure: No JOIN is required since all necessary information is in the ""singer"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of singers based on the ""singer.Singer_ID"".","[(6,)]","[(6,)]",,1.0,
What is the last name of the student who has a cat that is 3 years old?,"[Student.LName, Has_Pet.StuID = Student.StuID, Has_Pet.PetID = Pets.PetID, Pets.PetType, Pets.pet_age, cat, 3]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT Student.LName FROM Student JOIN Has_Pet ON Has_Pet.StuID = Student.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'cat' AND Pets.pet_age = 3;,SELECT T1.lname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pet_age  =  3 AND T3.pettype  =  'cat',pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student.LName"" field, as the question asks for the last name of the student. 2. Condition Structure: Use a WHERE clause to filter for records where the ""Pets.PetType"" is 'cat' and ""Pets.pet_age"" is 3 years. 3. Join Structure: Use JOINs to connect the ""Student"" table with the ""Has_Pet"" table on ""Has_Pet.StuID = Student.StuID"" and the ""Has_Pet"" table with the ""Pets"" table on ""Has_Pet.PetID = Pets.PetID"" to link students with their pets. 4. Aggregation Structure: No aggregation is needed, as the query is focused on retrieving specific information about a single student.","[('Smith',)]","[('Smith',)]",,1.0,
"For each continent, list its id, name, and how many countries it has?","[continents.ContId,continents.Continent,countries.Continent,countries.CountryId,continents.ContId = countries.Continent]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT continents.ContId, continents.Continent, COUNT(countries.CountryId) AS CountryCount FROM continents JOIN countries ON continents.ContId = countries.Continent GROUP BY continents.ContId, continents.Continent;","SELECT T1.ContId ,  T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.Continent GROUP BY T1.ContId;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the continent's ID (""continents.ContId""), name (""continents.Continent""), and the count of countries in each continent. Use COUNT on ""countries.CountryId"" to count the number of countries. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""continents"" table and the ""countries"" table on the relationship ""continents.ContId = countries.Continent"" to associate continents with their respective countries. 4. Aggregation Structure: Use COUNT to count the number of countries per continent and GROUP BY ""continents.ContId"" and ""continents.Continent"" to group the results by each continent.","[(1, 'america', 3), (2, 'europe', 6), (3, 'asia', 2), (4, 'africa', 2), (5, 'australia', 2)]","[(1, 'america', 3), (2, 'europe', 6), (3, 'asia', 2), (4, 'africa', 2), (5, 'australia', 2)]",,1.0,
Find the name and location of the stadiums which some concerts happened in the years of both 2014 and 2015.,"[stadium.Name, stadium.Location, concert.Stadium_ID = stadium.Stadium_ID, concert.Year, 2014, 2015]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,"SELECT stadium.Name, stadium.Location FROM stadium JOIN concert ON concert.Stadium_ID = stadium.Stadium_ID WHERE stadium.Stadium_ID IN ( SELECT Stadium_ID FROM concert WHERE Year = 2014 INTERSECT SELECT Stadium_ID FROM concert WHERE Year = 2015 );","SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2014 INTERSECT SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2015",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the name and location of the stadiums. Use the FROM clause to specify the stadium table and join it with the concert table to link stadiums with concerts. Apply a WHERE clause to filter for concerts that occurred in both 2014 and 2015. 2. Condition Structure: Use a WHERE clause with a subquery to ensure that the stadiums are associated with concerts in both 2014 and 2015. The subquery identifies stadiums that have concerts in both years. 3. Join Structure: Use an INNER JOIN between the stadium and concert tables based on the Stadium_ID to connect stadiums with their respective concerts. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('Somerset Park', 'Ayr United'), ('Somerset Park', 'Ayr United')]","[('Somerset Park', 'Ayr United')]",,1.0,
How many singers are from each country?,"[singer.Country, singer.Singer_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT singer.Country, COUNT(singer.Singer_ID) AS singer_count FROM singer GROUP BY singer.Country;","SELECT country ,  count(*) FROM singer GROUP BY country",concert_singer,"1. Sequential Structure: Start with the SELECT clause to specify the country and the count of singers from each country. 2. Aggregation Structure: Use COUNT to calculate the number of singers for each country. 3. Grouping Structure: Use GROUP BY on ""singer.Country"" to group the results by each country. 4. Join Structure: No JOIN is required since all necessary data is within the ""singer"" table.","[('France', 4), ('Netherlands', 1), ('United States', 1)]","[('France', 4), ('Netherlands', 1), ('United States', 1)]",,1.0,
What is the name and country of origin of every singer who has a song with the word 'Hey' in its title?,"[singer.Name, singer.Country, singer.Song_Name]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT singer.Name, singer.Country FROM singer WHERE singer.Song_Name LIKE '%Hey%';","SELECT name ,  country FROM singer WHERE song_name LIKE '%Hey%'",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""singer.Name"" and ""singer.Country"" fields, as the question asks for the name and country of origin of singers. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for songs that have the word 'Hey' in their title. This will be applied to the ""singer.Song_Name"" field. 3. Join Structure: No JOIN is required since all the necessary information is available in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving specific fields based on a condition.","[('Justin Brown', 'France')]","[('Justin Brown', 'France')]",,1.0,
"How many models does each car maker produce? List maker full name, id and the number.","[car_makers.FullName, car_makers.Id, model_list.Maker = car_makers.Id, model_list.Model]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT car_makers.FullName, car_makers.Id, COUNT(model_list.Model) AS NumberOfModels FROM car_makers JOIN model_list ON model_list.Maker = car_makers.Id GROUP BY car_makers.Id;","SELECT T1.FullName ,  T1.Id ,  count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""car_makers.FullName,"" ""car_makers.Id,"" and the count of models produced by each maker. Use COUNT on ""model_list.Model"" to count the number of models. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between ""car_makers"" and ""model_list"" on ""model_list.Maker = car_makers.Id"" to associate each car maker with its models. 4. Aggregation Structure: Use COUNT to calculate the number of models for each maker and GROUP BY ""car_makers.Id"" to group the results by each car maker.","[('American Motor Company', 1, 1), ('Volkswagen', 2, 2), ('BMW', 3, 1), ('General Motors', 4, 5), ('Ford Motor Company', 5, 3), ('Chrysler', 6, 4), ('Citroen', 7, 1), ('Nissan Motors', 8, 2), ('Fiat', 9, 1), ('Honda', 11, 1), ('Mazda', 12, 1), ('Daimler Benz', 13, 2), ('Opel', 14, 1), ('Peugeaut', 15, 1), ('Renault', 16, 1), ('Saab', 17, 1), ('Subaru', 18, 1), ('Toyota', 19, 2), ('Triumph', 20, 1), ('Volvo', 21, 1), ('Kia Motors', 22, 1), ('Hyundai', 23, 1)]","[('American Motor Company', 1, 1), ('Volkswagen', 2, 2), ('BMW', 3, 1), ('General Motors', 4, 5), ('Ford Motor Company', 5, 3), ('Chrysler', 6, 4), ('Citroen', 7, 1), ('Nissan Motors', 8, 2), ('Fiat', 9, 1), ('Honda', 11, 1), ('Mazda', 12, 1), ('Daimler Benz', 13, 2), ('Opel', 14, 1), ('Peugeaut', 15, 1), ('Renault', 16, 1), ('Saab', 17, 1), ('Subaru', 18, 1), ('Toyota', 19, 2), ('Triumph', 20, 1), ('Volvo', 21, 1), ('Kia Motors', 22, 1), ('Hyundai', 23, 1)]",,1.0,
What are the ids of the students who do not own cats as pets?,"[Student.StuID,Has_Pet.StuID = Student.StuID,Has_Pet.PetID,Pets.PetID = Has_Pet.PetID,Pets.PetType]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NESTED,SELECT Student.StuID FROM Student WHERE Student.StuID NOT IN ( SELECT Has_Pet.StuID FROM Has_Pet JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'Cat' );,SELECT stuid FROM student EXCEPT SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat',pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of students. Use the FROM clause to specify the Student table. Apply a WHERE clause to filter students who do not own cats as pets by ensuring their IDs are not associated with any pet of type 'Cat'. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose IDs are linked to pets of type 'Cat'. The subquery identifies all student IDs associated with pets of type 'Cat'. 3. Join Structure: Use INNER JOINs between the Student, Has_Pet, and Pets tables to connect students with their pets and filter based on pet type. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[(1001,), (1002,), (1003,), (1004,), (1005,), (1006,), (1007,), (1008,), (1009,), (1010,), (1011,), (1012,), (1014,), (1015,), (1016,), (1017,), (1018,), (1019,), (1020,), (1021,), (1022,), (1023,), (1024,), (1025,), (1026,), (1027,), (1028,), (1029,), (1030,), (1031,), (1032,), (1033,), (1034,), (1035,)]","[(1002,), (1003,), (1004,), (1005,), (1006,), (1007,), (1008,), (1009,), (1010,), (1011,), (1012,), (1014,), (1015,), (1016,), (1017,), (1018,), (1019,), (1020,), (1021,), (1022,), (1023,), (1024,), (1025,), (1026,), (1027,), (1028,), (1029,), (1030,), (1031,), (1032,), (1033,), (1034,), (1035,)]",,1.0,
What is the average age for all students who do not own any pets ?,"[Student.Age, Has_Pet.StuID = Student.StuID, Has_Pet.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NESTED,SELECT AVG(Age) AS average_age FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet);,select avg(age) from student where stuid not in (select stuid from has_pet),pets_1,"1. Sequential Structure: Start with the SELECT clause to calculate the average age of students. Use the FROM clause to specify the Student table. Apply a WHERE clause to filter students who do not own any pets by ensuring their StuID is not present in the Has_Pet table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose StuID appears in the Has_Pet table, indicating they own pets. 3. Join Structure: Not required, as the filtering is based on the absence of matching StuID entries in the Has_Pet table. 4. Aggregation Structure: Use the AVG function to calculate the average age of the filtered students.","[(19.625,)]","[(19.625,)]",,1.0,
"What type of pet is the youngest animal, and how much does it weigh?","[Pets.PetType, Pets.pet_age, Pets.weight]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",EASY,"SELECT Pets.PetType, Pets.weight FROM Pets WHERE Pets.pet_age = (SELECT MIN(Pets.pet_age) FROM Pets);","SELECT pettype ,  weight FROM pets ORDER BY pet_age LIMIT 1",pets_1,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the type of pet (""Pets.PetType"") and its weight (""Pets.weight""). 2. Condition Structure: Use a WHERE clause to filter for the youngest pet by identifying the minimum age (""Pets.pet_age""). 3. Aggregation Structure: Use the MIN function to find the youngest pet's age. 4. Join Structure: No JOIN is required since all necessary data is within the ""Pets"" table.","[('dog', 9.3)]","[('dog', 9.3)]",,1.0,
What are all distinct countries where singers above age 20 are from?,"[singer.Country, singer.Age]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,SELECT DISTINCT singer.Country FROM singer WHERE singer.Age > 20;,SELECT DISTINCT country FROM singer WHERE age  >  20,concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct countries of singers. 2. Condition Structure: Use a WHERE clause to filter singers whose age is above 20. 3. Join Structure: No JOIN is required since all necessary information is in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is used to ensure unique countries are retrieved.","[('Netherlands',), ('United States',), ('France',)]","[('Netherlands',), ('United States',), ('France',)]",,1.0,
What is the maximum capacity and the average of all stadiums ?,[stadium.Capacity],"Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT MAX(stadium.Capacity) AS max_capacity, AVG(stadium.Capacity) AS avg_capacity FROM stadium;","select max(capacity), average from stadium",concert_singer,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum capacity and the average capacity of all stadiums. 2. Aggregation Structure: Use MAX and AVG functions to calculate the maximum and average capacity across all stadiums. 3. Grouping Structure: No GROUP BY is required since the query asks for aggregate values across all stadiums. 4. Join Structure: No JOIN is required as all necessary data is within the ""stadium"" table.","[(52500, 10621.666666666666)]","[(52500, 730)]",,0.0,
Find the name of the makers that produced some cars in the year of 1970?,"[car_makers.FullName, cars_data.Year, cars_data.Id = car_names.MakeId, car_names.Model = model_list.Model, model_list.Maker = car_makers.Id, 1970]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT DISTINCT car_makers.FullName FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId JOIN model_list ON car_names.Model = model_list.Model JOIN car_makers ON model_list.Maker = car_makers.Id WHERE cars_data.Year = 1970;,SELECT DISTINCT T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model JOIN CARS_DATA AS T4 ON T3.MakeId  =  T4.id WHERE T4.year  =  '1970';,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""car_makers.FullName"" of makers that produced cars in the year 1970. 2. Condition Structure: Use a WHERE clause to filter for records where ""cars_data.Year"" is 1970. 3. Join Structure: Use multiple JOINs to connect the relevant tables. First, join ""cars_data"" with ""car_names"" on ""cars_data.Id = car_names.MakeId."" Then, join ""car_names"" with ""model_list"" on ""car_names.Model = model_list.Model."" Finally, join ""model_list"" with ""car_makers"" on ""model_list.Maker = car_makers.Id"" to link cars to their respective makers. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique maker names are returned.","[('General Motors',), ('Chrysler',), ('American Motor Company',), ('Ford Motor Company',), ('Citroen',), ('Toyota',), ('Nissan Motors',), ('Volkswagen',), ('Peugeaut',), ('Saab',), ('BMW',)]","[('gm',), ('chrysler',), ('amc',), ('ford',), ('citroen',), ('toyota',), ('nissan',), ('volkswagen',), ('peugeaut',), ('saab',), ('bmw',)]",,0.0,
What are all the makers and models?,"[car_makers.Maker, model_list.Model, model_list.Maker = car_makers.Id]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT car_makers.Maker, model_list.Model FROM car_makers JOIN model_list ON model_list.Maker = car_makers.Id;","SELECT Maker ,  Model FROM MODEL_LIST;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve ""car_makers.Maker"" and ""model_list.Model."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between ""car_makers"" and ""model_list"" on ""model_list.Maker = car_makers.Id"" to link each maker with its respective models. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all makers and their models.","[('amc', 'amc'), ('volkswagen', 'audi'), ('bmw', 'bmw'), ('gm', 'buick'), ('gm', 'cadillac'), ('ford', 'capri'), ('gm', 'chevrolet'), ('chrysler', 'chrysler'), ('citroen', 'citroen'), ('nissan', 'datsun'), ('chrysler', 'dodge'), ('fiat', 'fiat'), ('ford', 'ford'), ('honda', 'honda'), ('mazda', 'mazda'), ('daimler benz', 'mercedes'), ('daimler benz', 'mercedes-benz'), ('ford', 'mercury'), ('nissan', 'nissan'), ('gm', 'oldsmobile'), ('opel', 'opel'), ('peugeaut', 'peugeot'), ('chrysler', 'plymouth'), ('gm', 'pontiac'), ('renault', 'renault'), ('saab', 'saab'), ('subaru', 'subaru'), ('toyota', 'toyota'), ('triumph', 'triumph'), ('volkswagen', 'volkswagen'), ('volvo', 'volvo'), ('kia', 'kia'), ('hyundai', 'hyundai'), ('chrysler', 'jeep'), ('toyota', 'scion')]","[(1, 'amc'), (2, 'audi'), (3, 'bmw'), (4, 'buick'), (4, 'cadillac'), (5, 'capri'), (4, 'chevrolet'), (6, 'chrysler'), (7, 'citroen'), (8, 'datsun'), (6, 'dodge'), (9, 'fiat'), (5, 'ford'), (10, 'hi'), (11, 'honda'), (12, 'mazda'), (13, 'mercedes'), (13, 'mercedes-benz'), (5, 'mercury'), (8, 'nissan'), (4, 'oldsmobile'), (14, 'opel'), (15, 'peugeot'), (6, 'plymouth'), (4, 'pontiac'), (16, 'renault'), (17, 'saab'), (18, 'subaru'), (19, 'toyota'), (20, 'triumph'), (2, 'volkswagen'), (21, 'volvo'), (22, 'kia'), (23, 'hyundai'), (6, 'jeep'), (19, 'scion')]",,0.0,
"For each stadium, how many concerts play there?","[stadium.Stadium_ID, concert.Stadium_ID, concert.concert_ID = stadium.Stadium_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NON-NESTED,"SELECT stadium.Name, COUNT(concert.concert_ID) AS concert_count FROM stadium JOIN concert ON stadium.Stadium_ID = concert.Stadium_ID GROUP BY stadium.Name;","SELECT T2.name ,  count(*) FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id GROUP BY T1.stadium_id",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the stadium name and the count of concerts held there. Use COUNT on ""concert.concert_ID"" to count the number of concerts for each stadium. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""stadium"" and ""concert"" tables based on the shared key ""Stadium_ID"" to associate each concert with its respective stadium. 4. Aggregation Structure: Use COUNT to aggregate the number of concerts for each stadium and GROUP BY ""stadium.Name"" to group the results by stadium.","[('Balmoor', 1), ('Glebe Park', 1), ('Recreation Park', 1), ('Somerset Park', 2), (""Stark's Park"", 1)]","[(""Stark's Park"", 1), ('Glebe Park', 1), ('Somerset Park', 2), ('Recreation Park', 1), ('Balmoor', 1)]",,1.0,
What is the name of the different car makers who produced a car in 1970?,"[car_makers.FullName, cars_data.Year, cars_data.Id = car_names.MakeId, car_names.Model = model_list.Model, model_list.Maker = car_makers.Id, 1970]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT DISTINCT car_makers.FullName FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId JOIN model_list ON car_names.Model = model_list.Model JOIN car_makers ON model_list.Maker = car_makers.Id WHERE cars_data.Year = 1970;,SELECT DISTINCT T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model JOIN CARS_DATA AS T4 ON T3.MakeId  =  T4.id WHERE T4.year  =  '1970';,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of car makers (""car_makers.FullName""). 2. Condition Structure: Use a WHERE clause to filter for cars produced in the year 1970 (""cars_data.Year = 1970""). 3. Join Structure: Use multiple JOINs to connect the relevant tables: - Join ""cars_data"" with ""car_names"" on ""cars_data.Id = car_names.MakeId"" to link car data with car names. - Join ""car_names"" with ""model_list"" on ""car_names.Model = model_list.Model"" to link car names with their models. - Join ""model_list"" with ""car_makers"" on ""model_list.Maker = car_makers.Id"" to link models with their makers. 4. Aggregation Structure: Use DISTINCT to ensure that only unique car maker names are returned.","[('General Motors',), ('Chrysler',), ('American Motor Company',), ('Ford Motor Company',), ('Citroen',), ('Toyota',), ('Nissan Motors',), ('Volkswagen',), ('Peugeaut',), ('Saab',), ('BMW',)]","[('gm',), ('chrysler',), ('amc',), ('ford',), ('citroen',), ('toyota',), ('nissan',), ('volkswagen',), ('peugeaut',), ('saab',), ('bmw',)]",,0.0,
"What is the full name of each car maker, along with its id and how many models it produces?","[car_makers.FullName,car_makers.Id,model_list.Maker = car_makers.Id,model_list.Model]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT car_makers.FullName, car_makers.Id, COUNT(model_list.Model) AS model_count FROM car_makers JOIN model_list ON model_list.Maker = car_makers.Id GROUP BY car_makers.Id;","SELECT T1.FullName ,  T1.Id ,  count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""car_makers.FullName,"" ""car_makers.Id,"" and the count of models produced by each car maker. Use COUNT to count the number of models. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""car_makers"" table and the ""model_list"" table on ""model_list.Maker = car_makers.Id"" to associate each car maker with its models. 4. Aggregation Structure: Use COUNT on ""model_list.Model"" to count the number of models for each car maker, and GROUP BY ""car_makers.Id"" to group the results by each car maker.","[('American Motor Company', 1, 1), ('Volkswagen', 2, 2), ('BMW', 3, 1), ('General Motors', 4, 5), ('Ford Motor Company', 5, 3), ('Chrysler', 6, 4), ('Citroen', 7, 1), ('Nissan Motors', 8, 2), ('Fiat', 9, 1), ('Honda', 11, 1), ('Mazda', 12, 1), ('Daimler Benz', 13, 2), ('Opel', 14, 1), ('Peugeaut', 15, 1), ('Renault', 16, 1), ('Saab', 17, 1), ('Subaru', 18, 1), ('Toyota', 19, 2), ('Triumph', 20, 1), ('Volvo', 21, 1), ('Kia Motors', 22, 1), ('Hyundai', 23, 1)]","[('American Motor Company', 1, 1), ('Volkswagen', 2, 2), ('BMW', 3, 1), ('General Motors', 4, 5), ('Ford Motor Company', 5, 3), ('Chrysler', 6, 4), ('Citroen', 7, 1), ('Nissan Motors', 8, 2), ('Fiat', 9, 1), ('Honda', 11, 1), ('Mazda', 12, 1), ('Daimler Benz', 13, 2), ('Opel', 14, 1), ('Peugeaut', 15, 1), ('Renault', 16, 1), ('Saab', 17, 1), ('Subaru', 18, 1), ('Toyota', 19, 2), ('Triumph', 20, 1), ('Volvo', 21, 1), ('Kia Motors', 22, 1), ('Hyundai', 23, 1)]",,1.0,
How many car makers are there in each continents? List the continent name and the count.,"[continents.Continent, countries.Continent, car_makers.Country, countries.CountryId = car_makers.Country, countries.Continent = continents.ContId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT continents.Continent, COUNT(car_makers.Id) AS MakerCount FROM continents JOIN countries ON countries.Continent = continents.ContId JOIN car_makers ON countries.CountryId = car_makers.Country GROUP BY continents.Continent;","SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the continent name (""continents.Continent"") and the count of car makers. Use COUNT to count the number of car makers for each continent. 2. Condition Structure: No specific filtering condition is required, as we need data for all continents. 3. Join Structure: Use JOINs to connect the ""continents"" table with the ""countries"" table on ""countries.Continent = continents.ContId"" and then connect the ""countries"" table with the ""car_makers"" table on ""countries.CountryId = car_makers.Country"" to associate car makers with their respective continents. 4. Aggregation Structure: Use GROUP BY on ""continents.Continent"" to group the results by each continent and apply COUNT to calculate the number of car makers in each group.","[('america', 4), ('asia', 7), ('europe', 11)]","[('america', 4), ('asia', 7), ('europe', 11)]",,1.0,
How many car makers are there in france?,"[car_makers.Id,car_makers.Country,countries.CountryName,countries.CountryId = car_makers.Country,France]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT COUNT(car_makers.Id) FROM car_makers JOIN countries ON car_makers.Country = countries.CountryId WHERE countries.CountryName = 'France';,SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of car makers. Use COUNT on ""car_makers.Id"" to get the total number of car makers. 2. Condition Structure: Use a WHERE clause to filter for car makers located in France. This requires joining the ""car_makers"" table with the ""countries"" table to match the ""Country"" field with ""CountryName."" 3. Join Structure: Use an INNER JOIN between ""car_makers"" and ""countries"" on ""car_makers.Country = countries.CountryId"" to link car makers with their respective countries. 4. Aggregation Structure: Use COUNT to aggregate the total number of car makers in France.","[(0,)]","[(3,)]",,0.0,
"What are the names , themes , and number of singers for every concert ?","[concert.concert_Name, concert.Theme, singer_in_concert.concert_ID = concert.concert_ID, singer_in_concert.Singer_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NON-NESTED,"SELECT concert.concert_Name, concert.Theme, COUNT(singer_in_concert.Singer_ID) AS number_of_singers FROM concert JOIN singer_in_concert ON concert.concert_ID = singer_in_concert.concert_ID GROUP BY concert.concert_ID;","select t2.concert_name ,  t2.theme ,  count(*) from singer_in_concert as t1 join concert as t2 on t1.concert_id  =  t2.concert_id group by t2.concert_id",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the concert name (""concert.concert_Name""), theme (""concert.Theme""), and the number of singers for each concert. Use COUNT on ""singer_in_concert.Singer_ID"" to count the number of singers. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""concert"" and ""singer_in_concert"" tables based on ""concert.concert_ID"" to link each concert with its singers. 4. Aggregation Structure: Use COUNT to calculate the number of singers for each concert and GROUP BY ""concert.concert_ID"" to group the results by each concert.","[('Auditions', 'Free choice', 3), ('Super bootcamp', 'Free choice 2', 2), ('Home Visits', 'Bleeding Love', 1), ('Week 1', 'Wide Awake', 1), ('Week 1', 'Happy Tonight', 2), ('Week 2', 'Party All Night', 1)]","[('Auditions', 'Free choice', 3), ('Super bootcamp', 'Free choice 2', 2), ('Home Visits', 'Bleeding Love', 1), ('Week 1', 'Wide Awake', 1), ('Week 1', 'Happy Tonight', 2), ('Week 2', 'Party All Night', 1)]",,1.0,
Find the major and age of students who do not have a cat pet.,"[Student.Major, Student.Age, Has_Pet.StuID = Student.StuID, Has_Pet.PetID = Pets.PetID, Pets.PetType, cat]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NESTED,"SELECT Student.Major, Student.Age FROM Student WHERE Student.StuID NOT IN ( SELECT Has_Pet.StuID FROM Has_Pet JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'cat' );","SELECT major ,  age FROM student WHERE stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the major and age of students. Use the FROM clause to specify the Student table. Use a WHERE clause to filter students who do not have a cat pet. 2. Condition Structure: Use a WHERE clause with a subquery to exclude students whose StuID is associated with a PetID in the Has_Pet table where the PetType is 'cat'. 3. Join Structure: Use the relationships between the Student, Has_Pet, and Pets tables. Specifically, join Has_Pet with Student on StuID and with Pets on PetID to identify students and their pets. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[(600, 19), (600, 21), (600, 20), (600, 26), (600, 18), (600, 18), (600, 20), (600, 19), (600, 17), (600, 22), (600, 20), (600, 18), (600, 16), (600, 17), (600, 27), (600, 20), (600, 18), (520, 22), (520, 19), (540, 17), (520, 20), (540, 18), (520, 18), (520, 19), (520, 18), (550, 20), (100, 17), (550, 21), (550, 20), (550, 20), (550, 18), (50, 18), (50, 26)]","[(600, 19), (600, 21), (600, 20), (600, 26), (600, 18), (600, 18), (600, 20), (600, 19), (600, 17), (600, 22), (600, 20), (600, 18), (600, 16), (600, 17), (600, 27), (600, 20), (600, 18), (520, 22), (520, 19), (540, 17), (520, 20), (540, 18), (520, 18), (520, 19), (520, 18), (550, 20), (100, 17), (550, 21), (550, 20), (550, 20), (550, 18), (50, 18), (50, 26)]",,1.0,
What is the first name of every student who has a dog but does not have a cat?,"[Student.Fname,Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID,Pets.PetType]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NESTED,SELECT Student.Fname FROM Student JOIN Has_Pet ON Has_Pet.StuID = Student.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'Dog' AND Student.StuID NOT IN ( SELECT Has_Pet.StuID FROM Has_Pet JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'Cat' );,"SELECT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'dog' AND T1.stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the first name of students. Use the FROM clause to specify the Student table and JOIN it with the Has_Pet and Pets tables to connect students with their pets. Apply a WHERE clause to filter students who have a dog and exclude those who have a cat. 2. Condition Structure: Use the WHERE clause to filter for students who have a pet of type 'Dog' and ensure their IDs are not associated with a pet of type 'Cat'. 3. Join Structure: Use INNER JOINs between the Student, Has_Pet, and Pets tables based on the foreign key relationships (Has_Pet.StuID = Student.StuID and Has_Pet.PetID = Pets.PetID) to connect students with their pets. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",[],"[('Tracy', 19), ('Tracy', 19)]",,0.0,
Show the stadium names without any concert.,"[stadium.Name, concert.Stadium_ID, stadium.Stadium_ID = concert.Stadium_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,SELECT Name FROM stadium WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM concert);,SELECT name FROM stadium WHERE stadium_id NOT IN (SELECT stadium_id FROM concert),concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of stadiums. Use the FROM clause to specify the stadium table. Apply a WHERE clause to filter stadiums that do not have any associated concerts. 2. Condition Structure: Use the WHERE clause with a subquery to exclude stadiums whose Stadium_ID appears in the concert table, meaning they have hosted concerts. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Stadium_ID entries in the concert table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Bayview Stadium',), ('Hampden Park',), ('Forthbank Stadium',), ('Gayfield Park',)]","[('Bayview Stadium',), ('Hampden Park',), ('Forthbank Stadium',), ('Gayfield Park',)]",,1.0,
What is the name of the country with the most car makers?,"[countries.CountryName,car_makers.Country,countries.CountryId = car_makers.Country]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT countries.CountryName FROM countries JOIN car_makers ON countries.CountryId = car_makers.Country GROUP BY countries.CountryName ORDER BY COUNT(car_makers.Id) DESC LIMIT 1;,SELECT T2.CountryName FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId GROUP BY T1.Country ORDER BY Count(*) DESC LIMIT 1;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countries.CountryName"" of the country with the most car makers. Use COUNT to count the number of car makers for each country. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all countries. 3. Join Structure: Use a JOIN between the ""countries"" and ""car_makers"" tables based on ""countries.CountryId = car_makers.Country"" to associate car makers with their respective countries. 4. Aggregation Structure: Use COUNT to count the number of car makers for each country, then use ORDER BY in descending order to rank countries by the number of car makers. Use LIMIT 1 to select the country with the most car makers.","[('japan',)]","[('japan',)]",,1.0,
What is the average and maximum capacities for all stadiums ?,[stadium.Capacity],"Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT AVG(stadium.Capacity) AS avg_capacity, MAX(stadium.Capacity) AS max_capacity FROM stadium;","select avg(capacity) ,  max(capacity) from stadium",concert_singer,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average and maximum capacities of all stadiums. 2. Aggregation Structure: Use AVG and MAX functions to calculate the average and maximum capacities, respectively. 3. Grouping Structure: No GROUP BY is needed since the query asks for the overall average and maximum capacities across all stadiums. 4. Join Structure: No JOIN is required as all necessary data is within the ""stadium"" table.","[(10621.666666666666, 52500)]","[(10621.666666666666, 52500)]",,1.0,
What are the locations and names of all stations with capacity between 5000 and 10000?,"[stadium.Location, stadium.Name, stadium.Capacity, 5000, 10000]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT stadium.Location, stadium.Name FROM stadium WHERE stadium.Capacity BETWEEN 5000 AND 10000;","SELECT LOCATION ,  name FROM stadium WHERE capacity BETWEEN 5000 AND 10000",concert_singer,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""stadium.Location"" and ""stadium.Name"". 2. Condition Structure: Use a WHERE clause to filter stadiums with a capacity between 5000 and 10000. 3. Join Structure: No JOIN is required since all necessary data is within the ""stadium"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the locations and names of stadiums that meet the specified capacity condition.",[],[],,1.0,
List singer names and number of concerts for each singer.,"[singer.Name, singer.Singer_ID, singer_in_concert.Singer_ID, singer_in_concert.concert_ID, concert.concert_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NON-NESTED,"SELECT singer.Name, COUNT(singer_in_concert.concert_ID) AS number_of_concerts FROM singer JOIN singer_in_concert ON singer.Singer_ID = singer_in_concert.Singer_ID GROUP BY singer.Name;","SELECT T2.name ,  count(*) FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id GROUP BY T2.singer_id",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the singer's name and the count of concerts they participated in. Use COUNT to calculate the number of concerts for each singer. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""singer"" and ""singer_in_concert"" tables on ""Singer_ID"" to link each singer with their concert participation. 4. Aggregation Structure: Use COUNT on ""singer_in_concert.concert_ID"" to count the number of concerts for each singer. Use GROUP BY on ""singer.Name"" to group the results by each singer.","[('John Nizinik', 2), ('Justin Brown', 3), ('Rose White', 1), ('Timbaland', 2), ('Tribal King', 2)]","[('Timbaland', 2), ('Justin Brown', 3), ('Rose White', 1), ('John Nizinik', 2), ('Tribal King', 2)]",,1.0,
Find the average weight for each pet type.,"[Pets.PetType, Pets.weight]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",EASY,"SELECT Pets.PetType, AVG(Pets.weight) AS avg_weight FROM Pets GROUP BY Pets.PetType;","SELECT avg(weight) ,  pettype FROM pets GROUP BY pettype",pets_1,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the pet type and the average weight. 2. Aggregation Structure: Use the AVG function to calculate the average weight for each pet type. 3. Grouping Structure: Use GROUP BY on ""Pets.PetType"" to calculate the average weight for each pet type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Pets"" table.","[('cat', 12.0), ('dog', 11.350000000000001)]","[(12.0, 'cat'), (11.350000000000001, 'dog')]",,1.0,
How many continents are there?,[continents.ContId],"Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT COUNT(DISTINCT continents.ContId) AS continent_count FROM continents;,SELECT count(*) FROM CONTINENTS;,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of unique continents. 2. Condition Structure: No specific filtering condition is required as we want to count all continents. 3. Join Structure: No JOIN is necessary since all required data is in the ""continents"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""continents.ContId"" to count the unique continents.","[(5,)]","[(5,)]",,1.0,
Find the model of the car whose weight is below the average weight.,"[cars_data.Weight,car_names.Model,cars_data.Id = car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT car_names.Model FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Weight < (SELECT AVG(Weight) FROM cars_data);,SELECT T1.model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Weight  <  (SELECT avg(Weight) FROM CARS_DATA),car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the model of the car. Use the FROM clause to specify the cars_data and car_names tables. Apply a WHERE clause to filter cars whose weight is below the average weight. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average weight from the cars_data table and filter cars whose weight is less than this value. 3. Join Structure: Use an INNER JOIN between the cars_data and car_names tables based on the Id from cars_data and MakeId from car_names to connect car details with their models. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average weight, which is then used in the filtering condition.","[('toyota',), ('plymouth',), ('amc',), ('ford',), ('datsun',), ('volkswagen',), ('peugeot',), ('audi',), ('saab',), ('bmw',), ('amc',), ('datsun',), ('chevrolet',), ('toyota',), ('ford',), ('volkswagen',), ('amc',), ('amc',), ('chevrolet',), ('mercury',), ('opel',), ('peugeot',), ('fiat',), ('toyota',), ('datsun',), ('volkswagen',), ('plymouth',), ('toyota',), ('dodge',), ('volkswagen',), ('chevrolet',), ('ford',), ('mazda',), ('volvo',), ('volkswagen',), ('peugeot',), ('renault',), ('ford',), ('datsun',), ('toyota',), ('dodge',), ('toyota',), ('amc',), ('plymouth',), ('volkswagen',), ('amc',), ('toyota',), ('chevrolet',), ('datsun',), ('mazda',), ('ford',), ('mercury',), ('fiat',), ('fiat',), ('opel',), ('audi',), ('volvo',), ('saab',), ('toyota',), ('ford',), ('amc',), ('datsun',), ('ford',), ('toyota',), ('chevrolet',), ('audi',), ('volkswagen',), ('opel',), ('toyota',), ('datsun',), ('dodge',), ('fiat',), ('fiat',), ('honda',), ('subaru',), ('fiat',), ('toyota',), ('ford',), ('amc',), ('pontiac',), ('toyota',), ('volkswagen',), ('datsun',), ('volkswagen',), ('audi',), ('peugeot',), ('volvo',), ('saab',), ('honda',), ('fiat',), ('opel',), ('capri',), ('dodge',), ('renault',), ('chevrolet',), ('chevrolet',), ('volkswagen',), ('honda',), ('volkswagen',), ('datsun',), ('toyota',), ('ford',), ('toyota',), ('honda',), ('buick',), ('renault',), ('plymouth',), ('datsun',), ('volkswagen',), ('pontiac',), ('toyota',), ('ford',), ('chevrolet',), ('dodge',), ('subaru',), ('volkswagen',), ('datsun',), ('bmw',), ('mazda',), ('volkswagen',), ('ford',), ('mazda',), ('datsun',), ('honda',), ('ford',), ('ford',), ('chevrolet',), ('toyota',), ('datsun',), ('dodge',), ('toyota',), ('plymouth',), ('oldsmobile',), ('datsun',), ('audi',), ('saab',), ('volkswagen',), ('honda',), ('ford',), ('volkswagen',), ('mazda',), ('dodge',), ('amc',), ('plymouth',), ('plymouth',), ('datsun',), ('fiat',), ('buick',), ('chevrolet',), ('oldsmobile',), ('pontiac',), ('volkswagen',), ('toyota',), ('chevrolet',), ('datsun',), ('chevrolet',), ('ford',), ('audi',), ('toyota',), ('mazda',), ('datsun',), ('toyota',), ('mazda',), ('dodge',), ('datsun',), ('volkswagen',), ('volkswagen',), ('audi',), ('honda',), ('renault',), ('subaru',), (' volkswagen',), ('datsun',), ('mazda',), ('triumph',), ('ford',), ('honda',), ('plymouth',), ('buick',), ('dodge',), ('chevrolet',), ('plymouth',), ('toyota',), ('plymouth',), ('honda',), ('subaru',), ('datsun',), ('toyota',), ('mazda',), ('plymouth',), ('ford',), ('ford',), ('volkswagen',), ('renault',), ('honda',), ('toyota',), ('datsun',), ('mazda',), ('saab',), ('toyota',), ('datsun',), ('chevrolet',), ('chevrolet',), ('chevrolet',), ('pontiac',), ('dodge',), ('pontiac',), ('ford',), ('volkswagen',), ('mazda',), ('mazda',), ('plymouth',), ('mercury',), ('nissan',), ('honda',), ('toyota',), ('honda',), ('honda',), ('datsun',), ('buick',), ('chrysler',), ('ford',), ('toyota',), ('dodge',), ('chevrolet',), ('ford',), ('volkswagen',), ('dodge',), ('ford',), ('chevrolet',)]","[('toyota',), ('plymouth',), ('amc',), ('ford',), ('datsun',), ('volkswagen',), ('peugeot',), ('audi',), ('saab',), ('bmw',), ('amc',), ('datsun',), ('chevrolet',), ('toyota',), ('ford',), ('volkswagen',), ('amc',), ('amc',), ('chevrolet',), ('mercury',), ('opel',), ('peugeot',), ('fiat',), ('toyota',), ('datsun',), ('volkswagen',), ('plymouth',), ('toyota',), ('dodge',), ('volkswagen',), ('chevrolet',), ('ford',), ('mazda',), ('volvo',), ('volkswagen',), ('peugeot',), ('renault',), ('ford',), ('datsun',), ('toyota',), ('dodge',), ('toyota',), ('amc',), ('plymouth',), ('volkswagen',), ('amc',), ('toyota',), ('chevrolet',), ('datsun',), ('mazda',), ('ford',), ('mercury',), ('fiat',), ('fiat',), ('opel',), ('audi',), ('volvo',), ('saab',), ('toyota',), ('ford',), ('amc',), ('datsun',), ('ford',), ('toyota',), ('chevrolet',), ('audi',), ('volkswagen',), ('opel',), ('toyota',), ('datsun',), ('dodge',), ('fiat',), ('fiat',), ('honda',), ('subaru',), ('fiat',), ('toyota',), ('ford',), ('amc',), ('pontiac',), ('toyota',), ('volkswagen',), ('datsun',), ('volkswagen',), ('audi',), ('peugeot',), ('volvo',), ('saab',), ('honda',), ('fiat',), ('opel',), ('capri',), ('dodge',), ('renault',), ('chevrolet',), ('chevrolet',), ('volkswagen',), ('honda',), ('volkswagen',), ('datsun',), ('toyota',), ('ford',), ('toyota',), ('honda',), ('buick',), ('renault',), ('plymouth',), ('datsun',), ('volkswagen',), ('pontiac',), ('toyota',), ('ford',), ('chevrolet',), ('dodge',), ('subaru',), ('volkswagen',), ('datsun',), ('bmw',), ('mazda',), ('volkswagen',), ('ford',), ('mazda',), ('datsun',), ('honda',), ('ford',), ('ford',), ('chevrolet',), ('toyota',), ('datsun',), ('dodge',), ('toyota',), ('plymouth',), ('oldsmobile',), ('datsun',), ('audi',), ('saab',), ('volkswagen',), ('honda',), ('ford',), ('volkswagen',), ('mazda',), ('dodge',), ('amc',), ('plymouth',), ('plymouth',), ('datsun',), ('fiat',), ('buick',), ('chevrolet',), ('oldsmobile',), ('pontiac',), ('volkswagen',), ('toyota',), ('chevrolet',), ('datsun',), ('chevrolet',), ('ford',), ('audi',), ('toyota',), ('mazda',), ('datsun',), ('toyota',), ('mazda',), ('dodge',), ('datsun',), ('volkswagen',), ('volkswagen',), ('audi',), ('honda',), ('renault',), ('subaru',), (' volkswagen',), ('datsun',), ('mazda',), ('triumph',), ('ford',), ('honda',), ('plymouth',), ('buick',), ('dodge',), ('chevrolet',), ('plymouth',), ('toyota',), ('plymouth',), ('honda',), ('subaru',), ('datsun',), ('toyota',), ('mazda',), ('plymouth',), ('ford',), ('ford',), ('volkswagen',), ('renault',), ('honda',), ('toyota',), ('datsun',), ('mazda',), ('saab',), ('toyota',), ('datsun',), ('chevrolet',), ('chevrolet',), ('chevrolet',), ('pontiac',), ('dodge',), ('pontiac',), ('ford',), ('volkswagen',), ('mazda',), ('mazda',), ('plymouth',), ('mercury',), ('nissan',), ('honda',), ('toyota',), ('honda',), ('honda',), ('datsun',), ('buick',), ('chrysler',), ('ford',), ('toyota',), ('dodge',), ('chevrolet',), ('ford',), ('volkswagen',), ('dodge',), ('ford',), ('chevrolet',)]",,1.0,
"For students who have pets , how many pets does each student have ? list their ids instead of names .","[Student.StuID, Has_Pet.StuID, Has_Pet.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,"SELECT Student.StuID, COUNT(Has_Pet.PetID) AS pet_count FROM Student JOIN Has_Pet ON Student.StuID = Has_Pet.StuID GROUP BY Student.StuID;","select count(*) ,  t1.stuid from student as t1 join has_pet as t2 on t1.stuid  =  t2.stuid group by t1.stuid",pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the student IDs and the count of pets for each student. Use COUNT on ""Has_Pet.PetID"" to count the number of pets for each student. 2. Condition Structure: No specific filtering condition is needed since we are only interested in students who have pets, which is inherently filtered by the ""Has_Pet"" table. 3. Join Structure: Use a JOIN between the ""Student"" and ""Has_Pet"" tables based on ""Student.StuID = Has_Pet.StuID"" to associate students with their pets. 4. Aggregation Structure: Use GROUP BY on ""Student.StuID"" to group the results by each student and apply COUNT to calculate the number of pets for each student.","[(1001, 1), (1002, 2)]","[(1, 1001), (2, 1002)]",,1.0,
How many car models are produced in the usa?,"[countries.CountryName,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT COUNT(car_names.Model) FROM countries JOIN car_makers ON car_makers.Country = countries.CountryId JOIN model_list ON model_list.Maker = car_makers.Id JOIN car_names ON car_names.Model = model_list.Model WHERE countries.CountryName = 'USA';,SELECT count(*) FROM MODEL_LIST AS T1 JOIN CAR_MAKERS AS T2 ON T1.Maker  =  T2.Id JOIN COUNTRIES AS T3 ON T2.Country  =  T3.CountryId WHERE T3.CountryName  =  'usa';,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of car models. Use COUNT on ""car_names.Model"" to get the total number of models. 2. Condition Structure: Use a WHERE clause to filter for car models produced in the USA. This requires filtering ""countries.CountryName"" for 'USA'. 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""countries"" with ""car_makers"" on ""car_makers.Country = countries.CountryId"" to associate car makers with their countries. Then, join ""car_makers"" with ""model_list"" on ""model_list.Maker = car_makers.Id"" to link car makers with their models. Finally, join ""model_list"" with ""car_names"" on ""car_names.Model = model_list.Model"" to get the car models. 4. Aggregation Structure: Use COUNT to aggregate the total number of car models produced in the USA.","[(0,)]","[(13,)]",,0.0,
What is the average miles per gallon(mpg) of the cars with 4 cylinders?,"[cars_data.MPG,cars_data.Cylinders,4]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT AVG(cars_data.MPG) AS avg_mpg FROM cars_data WHERE cars_data.Cylinders = 4;,SELECT avg(mpg) FROM CARS_DATA WHERE Cylinders  =  4;,car_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average miles per gallon (MPG). 2. Condition Structure: Use a WHERE clause to filter for cars with 4 cylinders. 3. Join Structure: No JOIN is required since all necessary data is within the ""cars_data"" table. 4. Aggregation Structure: Use the AVG function to calculate the average MPG for cars that meet the specified condition.","[(28.86231884057971,)]","[(28.86231884057971,)]",,1.0,
Find the id of the pet owned by student whose last name is ‘Smith’.,"[Student.StuID,Student.LName,Has_Pet.StuID = Student.StuID,Has_Pet.PetID,Pets.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT Pets.PetID FROM Student JOIN Has_Pet ON Has_Pet.StuID = Student.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Student.LName = 'Smith';,SELECT T2.petid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.Lname  =  'Smith',pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""PetID"" of the pet owned by the student. 2. Condition Structure: Use a WHERE clause to filter for the student whose last name (""Student.LName"") is 'Smith.' 3. Join Structure: Use JOINs to connect the ""Student"" table with the ""Has_Pet"" table on ""Has_Pet.StuID = Student.StuID"" and then connect the ""Has_Pet"" table with the ""Pets"" table on ""Has_Pet.PetID = Pets.PetID."" 4. Aggregation Structure: No aggregation is needed as we are retrieving specific data without summarization.","[(2001,)]","[(2001,)]",,1.0,
Find the number of distinct type of pets.,[Pets.PetType],"Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",EASY,SELECT COUNT(DISTINCT Pets.PetType) AS distinct_pet_types FROM Pets;,SELECT count(DISTINCT pettype) FROM pets,pets_1,"1. Sequential Structure: Begin with the SELECT clause to count the distinct types of pets, as the question asks for the number of distinct pet types. 2. Condition Structure: No specific filtering condition is required since we are interested in all pet types. 3. Join Structure: No JOIN is necessary because the required data is available within the ""Pets"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Pets.PetType"" to count the unique pet types.","[(2,)]","[(2,)]",,1.0,
What are the names of the stadiums without any concerts?,"[stadium.Name, concert.Stadium_ID, stadium.Stadium_ID = concert.Stadium_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,SELECT Name FROM stadium WHERE Stadium_ID NOT IN (SELECT Stadium_ID FROM concert);,SELECT name FROM stadium WHERE stadium_id NOT IN (SELECT stadium_id FROM concert),concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of stadiums. Use the FROM clause to specify the stadium table. Apply a WHERE clause to filter stadiums that do not have any associated concerts. 2. Condition Structure: Use the WHERE clause with a subquery to exclude stadiums whose Stadium_ID appears in the concert table, meaning they have hosted concerts. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Stadium_ID entries in the concert table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Bayview Stadium',), ('Hampden Park',), ('Forthbank Stadium',), ('Gayfield Park',)]","[('Bayview Stadium',), ('Hampden Park',), ('Forthbank Stadium',), ('Gayfield Park',)]",,1.0,
What is the maker of the carr produced in the earliest year and what year was it?,"[cars_data.Year,car_makers.Maker,cars_data.Id = car_names.MakeId,car_names.Model = model_list.Model,model_list.Maker = car_makers.Id]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,"SELECT car_makers.Maker, cars_data.Year FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId JOIN model_list ON car_names.Model = model_list.Model JOIN car_makers ON model_list.Maker = car_makers.Id WHERE cars_data.Year = (SELECT MIN(Year) FROM cars_data);","SELECT T2.Make ,  T1.Year FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Year  =  (SELECT min(YEAR) FROM CARS_DATA);",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the maker and the year of the car. Use the FROM clause to specify the cars_data table and join it with car_names, model_list, and car_makers to connect the car's data with its maker. Apply a WHERE clause to filter for the car produced in the earliest year. 2. Condition Structure: Use a WHERE clause with a subquery to filter for the car with the minimum year in the cars_data table. 3. Join Structure: Use JOINs between cars_data, car_names, model_list, and car_makers based on the relationships: cars_data.Id = car_names.MakeId, car_names.Model = model_list.Model, and model_list.Maker = car_makers.Id. 4. Aggregation Structure: Use MIN in a subquery to find the earliest year and filter based on this value to retrieve the relevant maker and year.","[('gm', 1970), ('gm', 1970), ('chrysler', 1970), ('amc', 1970), ('ford', 1970), ('ford', 1970), ('gm', 1970), ('chrysler', 1970), ('gm', 1970), ('amc', 1970), ('citroen', 1970), ('gm', 1970), ('ford', 1970), ('chrysler', 1970), ('amc', 1970), ('chrysler', 1970), ('chrysler', 1970), ('ford', 1970), ('gm', 1970), ('gm', 1970), ('toyota', 1970), ('chrysler', 1970), ('amc', 1970), ('ford', 1970), ('nissan', 1970), ('volkswagen', 1970), ('peugeaut', 1970), ('volkswagen', 1970), ('saab', 1970), ('bmw', 1970), ('amc', 1970), ('ford', 1970), ('gm', 1970), ('chrysler', 1970)]","[('chevrolet chevelle malibu', 1970), ('buick skylark 320', 1970), ('plymouth satellite', 1970), ('amc rebel sst', 1970), ('ford torino', 1970), ('ford galaxie 500', 1970), ('chevrolet impala', 1970), ('plymouth fury iii', 1970), ('pontiac catalina', 1970), ('amc ambassador dpl', 1970), ('citroen ds-21 pallas', 1970), ('chevrolet chevelle concours (sw)', 1970), ('ford torino (sw)', 1970), ('plymouth satellite (sw)', 1970), ('amc rebel sst (sw)', 1970), ('dodge challenger se', 1970), ('plymouth cuda 340', 1970), ('ford mustang boss 302', 1970), ('chevrolet monte carlo', 1970), ('buick estate wagon (sw)', 1970), ('toyota corona mark ii', 1970), ('plymouth duster', 1970), ('amc hornet', 1970), ('ford maverick', 1970), ('datsun pl510', 1970), ('volkswagen 1131 deluxe sedan', 1970), ('peugeot 504', 1970), ('audi 100 ls', 1970), ('saab 99e', 1970), ('bmw 2002', 1970), ('amc gremlin', 1970), ('ford f250', 1970), ('chevy c20', 1970), ('dodge d200', 1970), ('hi 1200d', 1970)]",,0.0,
How many countries exist?,[countries.CountryId],"Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT COUNT(countries.CountryId) AS total_countries FROM countries;,SELECT count(*) FROM COUNTRIES;,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of countries. 2. Condition Structure: No specific filtering condition is required as we want the total count of all countries. 3. Join Structure: No JOIN is necessary since the required information is available within the ""countries"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of countries.","[(15,)]","[(15,)]",,1.0,
What is the name and capacity of the stadium with the most concerts after 2013 ?,"[stadium.Name, stadium.Capacity, concert.Stadium_ID = stadium.Stadium_ID, concert.Year, singer_in_concert.concert_ID = concert.concert_ID, 2013]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NON-NESTED,"SELECT stadium.Name, stadium.Capacity FROM concert JOIN stadium ON concert.Stadium_ID = stadium.Stadium_ID WHERE concert.Year > 2013 GROUP BY stadium.Stadium_ID ORDER BY COUNT(concert.concert_ID) DESC LIMIT 1;","select t2.name ,  t2.capacity from concert as t1 join stadium as t2 on t1.stadium_id  =  t2.stadium_id where t1.year  >  2013 group by t2.stadium_id order by count(*) desc limit 1",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""stadium.Name"" and ""stadium.Capacity."" Use COUNT to count the number of concerts held in each stadium. 2. Condition Structure: Use a WHERE clause to filter concerts that occurred after the year 2013. 3. Join Structure: Use a JOIN between the ""concert"" and ""stadium"" tables on ""concert.Stadium_ID = stadium.Stadium_ID"" to associate concerts with their respective stadiums. 4. Aggregation Structure: Use GROUP BY on ""stadium.Stadium_ID"" to group the results by stadium. Use ORDER BY in descending order of the concert count and LIMIT 1 to get the stadium with the most concerts.","[('Somerset Park', 11998)]","[('Somerset Park', 11998)]",,1.0,
"What are the names, countries, and ages for every singer in descending order of age?","[singer.Name, singer.Country, singer.Age]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT singer.Name, singer.Country, singer.Age FROM singer ORDER BY singer.Age DESC;","SELECT name ,  country ,  age FROM singer ORDER BY age DESC",concert_singer,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the singer's name, country, and age. 2. Condition Structure: No specific filtering condition is required as we want information for all singers. 3. Join Structure: No JOIN is required since all necessary information is available in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in descending order based on the ""singer.Age"".","[('Joe Sharp', 'Netherlands', 52), ('John Nizinik', 'France', 43), ('Rose White', 'France', 41), ('Timbaland', 'United States', 32), ('Justin Brown', 'France', 29), ('Tribal King', 'France', 25)]","[('Joe Sharp', 'Netherlands', 52), ('John Nizinik', 'France', 43), ('Rose White', 'France', 41), ('Timbaland', 'United States', 32), ('Justin Brown', 'France', 29), ('Tribal King', 'France', 25)]",,1.0,
Find the first name and gender of student who have more than one pet.,"[Student.Fname, Student.Sex, Has_Pet.StuID = Student.StuID, Has_Pet.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,"SELECT Student.Fname, Student.Sex FROM Has_Pet JOIN Student ON Has_Pet.StuID = Student.StuID GROUP BY Student.StuID HAVING COUNT(Has_Pet.PetID) > 1;","SELECT T1.fname ,  T1.sex FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid HAVING count(*)  >  1",pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student.Fname"" and ""Student.Sex"" fields. 2. Condition Structure: Use a HAVING clause to filter students who have more than one pet. This requires counting the number of pets associated with each student. 3. Join Structure: Use an INNER JOIN between the ""Has_Pet"" table and the ""Student"" table on ""Has_Pet.StuID = Student.StuID"" to associate students with their pets. 4. Aggregation Structure: Use COUNT on ""Has_Pet.PetID"" to count the number of pets for each student, then filter with HAVING to select students with more than one pet.","[('Tracy', 'F')]","[('Tracy', 'F')]",,1.0,
What is the average miles per gallon of all the cards with 4 cylinders?,"[cars_data.MPG,cars_data.Cylinders,4]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT AVG(cars_data.MPG) AS average_mpg FROM cars_data WHERE cars_data.Cylinders = 4;,SELECT avg(mpg) FROM CARS_DATA WHERE Cylinders  =  4;,car_1,"1. Sequential Structure: Start with the SELECT clause to calculate the average miles per gallon (MPG) for cars with 4 cylinders. 2. Condition Structure: Use a WHERE clause to filter cars where ""cars_data.Cylinders"" equals 4. 3. Join Structure: No JOIN is required since all necessary information is in the ""cars_data"" table. 4. Aggregation Structure: Use the AVG function to calculate the average MPG for the filtered cars.","[(28.86231884057971,)]","[(28.86231884057971,)]",,1.0,
Show all countries and the number of singers in each country.,"[singer.Country, singer.Singer_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT singer.Country, COUNT(singer.Singer_ID) AS number_of_singers FROM singer GROUP BY singer.Country;","SELECT country ,  count(*) FROM singer GROUP BY country",concert_singer,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the country and the count of singers. 2. Aggregation Structure: Use COUNT to calculate the number of singers in each country. 3. Grouping Structure: Use GROUP BY on ""singer.Country"" to count singers for each country. 4. Join Structure: No JOIN is required since all necessary data is within the ""singer"" table.","[('France', 4), ('Netherlands', 1), ('United States', 1)]","[('France', 4), ('Netherlands', 1), ('United States', 1)]",,1.0,
What is the first name and gender of the all the students who have more than one pet?,"[Student.Fname, Student.Sex, Has_Pet.StuID = Student.StuID, Has_Pet.PetID, Pets.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,"SELECT Student.Fname, Student.Sex FROM Student JOIN Has_Pet ON Has_Pet.StuID = Student.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID GROUP BY Student.StuID HAVING COUNT(Has_Pet.PetID) > 1;","SELECT T1.fname ,  T1.sex FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid HAVING count(*)  >  1",pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Student.Fname"" and ""Student.Sex."" 2. Condition Structure: Use a HAVING clause to filter students who have more than one pet. This requires counting the number of pets associated with each student. 3. Join Structure: Use JOINs to connect the ""Student"" table with the ""Has_Pet"" table on ""Has_Pet.StuID = Student.StuID"" and the ""Has_Pet"" table with the ""Pets"" table on ""Has_Pet.PetID = Pets.PetID."" 4. Aggregation Structure: Use COUNT on ""Has_Pet.PetID"" to count the number of pets for each student, then filter with HAVING to select students with more than one pet.","[('Tracy', 'F')]","[('Tracy', 'F')]",,1.0,
How many concerts are there in year 2014 or 2015?,[concert.Year],"Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT COUNT(*) FROM concert WHERE concert.Year IN (2014, 2015);",SELECT count(*) FROM concert WHERE YEAR  =  2014 OR YEAR  =  2015,concert_singer,"1. Sequential Structure: Start with the SELECT clause to count the number of concerts. 2. Condition Structure: Use a WHERE clause to filter concerts that occurred in the years 2014 or 2015. 3. Join Structure: No JOIN is required since all necessary information is in the ""concert"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of concerts that meet the specified condition.","[(6,)]","[(6,)]",,1.0,
What are the names and locations of the stadiums that had concerts that occurred in both 2014 and 2015?,"[stadium.Name, stadium.Location, concert.Stadium_ID = stadium.Stadium_ID, concert.Year, 2014, 2015]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,"SELECT stadium.Name, stadium.Location FROM stadium JOIN concert ON concert.Stadium_ID = stadium.Stadium_ID WHERE stadium.Stadium_ID IN ( SELECT Stadium_ID FROM concert WHERE Year = 2014 INTERSECT SELECT Stadium_ID FROM concert WHERE Year = 2015 );","SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2014 INTERSECT SELECT T2.name ,  T2.location FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.Year  =  2015",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the names and locations of stadiums. Use the FROM clause to specify the stadium table and JOIN it with the concert table to link stadiums with their concerts. Apply a WHERE clause to filter for concerts that occurred in both 2014 and 2015. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the stadiums had concerts in both 2014 and 2015. The subquery identifies stadiums that had concerts in both years. 3. Join Structure: Use an INNER JOIN between the stadium and concert tables based on the Stadium_ID to connect stadiums with their concerts. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('Somerset Park', 'Ayr United'), ('Somerset Park', 'Ayr United')]","[('Somerset Park', 'Ayr United')]",,1.0,
What are the first names of every student who has a cat or dog as a pet?,"[Student.Fname,Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID,Pets.PetType,cat,dog]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT Student.Fname FROM Student JOIN Has_Pet ON Has_Pet.StuID = Student.StuID JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'cat' OR Pets.PetType = 'dog';,SELECT DISTINCT T1.Fname FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat' OR T3.pettype  =  'dog',pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student.Fname"" field, which represents the first names of students. 2. Condition Structure: Use a WHERE clause to filter for records where ""Pets.PetType"" is either 'cat' or 'dog.' 3. Join Structure: Use JOINs to connect the ""Student"" table with the ""Has_Pet"" table on ""Has_Pet.StuID = Student.StuID"" and the ""Has_Pet"" table with the ""Pets"" table on ""Has_Pet.PetID = Pets.PetID"" to link students with their pets. 4. Aggregation Structure: No aggregation is needed, as the query only requires listing the first names of students.","[('Linda',), ('Tracy',), ('Tracy',)]","[('Linda',), ('Tracy',)]",,1.0,
How many countries are listed?,[countries.CountryId],"Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT COUNT(countries.CountryId) AS total_countries FROM countries;,SELECT count(*) FROM COUNTRIES;,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of countries listed. 2. Condition Structure: No specific filtering condition is required as we want to count all countries. 3. Join Structure: No JOIN is necessary since all required data is in the ""countries"" table. 4. Aggregation Structure: Use COUNT on ""countries.CountryId"" to calculate the total number of countries.","[(15,)]","[(15,)]",,1.0,
what is the name and nation of the singer who have a song having 'Hey' in its name?,"[singer.Name, singer.Country, singer.Song_Name]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT singer.Name, singer.Country FROM singer WHERE singer.Song_Name LIKE '%Hey%';","SELECT name ,  country FROM singer WHERE song_name LIKE '%Hey%'",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""singer.Name"" and ""singer.Country"" of the singer. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for songs that have 'Hey' in their name. 3. Join Structure: No JOIN is required since all relevant information is in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.","[('Justin Brown', 'France')]","[('Justin Brown', 'France')]",,1.0,
Find the number of dog pets that are raised by female students (with sex F).,"[Pets.PetType, Pets.PetID = Has_Pet.PetID, Has_Pet.StuID = Student.StuID, Student.Sex]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT COUNT(Pets.PetID) FROM Pets JOIN Has_Pet ON Pets.PetID = Has_Pet.PetID JOIN Student ON Has_Pet.StuID = Student.StuID WHERE Pets.PetType = 'dog' AND Student.Sex = 'F';,SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T2.petid  =  T3.petid WHERE T1.sex  =  'F' AND T3.pettype  =  'dog',pets_1,"1. Sequential Structure: Start with the SELECT clause to count the number of dog pets. Use COUNT on ""Pets.PetID"" to get the total number of dog pets raised by female students. 2. Condition Structure: Use a WHERE clause to filter for pets of type ""dog"" and students with sex ""F."" 3. Join Structure: Use JOINs to connect the ""Pets"" table with ""Has_Pet"" on ""Pets.PetID"" and then connect ""Has_Pet"" with ""Student"" on ""Has_Pet.StuID"" to link pets with their respective students. 4. Aggregation Structure: Use COUNT to aggregate the number of dog pets raised by female students.","[(2,)]","[(2,)]",,1.0,
What is the number of makers of care in France?,"[car_makers.Id,car_makers.Country,countries.CountryName,countries.CountryId = car_makers.Country,France]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT COUNT(DISTINCT car_makers.Id) FROM car_makers JOIN countries ON countries.CountryId = car_makers.Country WHERE countries.CountryName = 'France';,SELECT count(*) FROM CAR_MAKERS AS T1 JOIN COUNTRIES AS T2 ON T1.Country  =  T2.CountryId WHERE T2.CountryName  =  'france';,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of distinct makers. Use COUNT with DISTINCT on ""car_makers.Id"" to get the unique count of makers. 2. Condition Structure: Use a WHERE clause to filter for makers located in France. This requires filtering ""countries.CountryName"" for 'France.' 3. Join Structure: Use a JOIN between the ""car_makers"" and ""countries"" tables. The relationship is established through ""countries.CountryId = car_makers.Country."" 4. Aggregation Structure: Use COUNT with DISTINCT to aggregate the unique makers in France.","[(0,)]","[(3,)]",,0.0,
What is the name of each continent and how many car makers are there in each one?,"[continents.Continent,car_makers.Id,countries.Continent = continents.ContId,car_makers.Country = countries.CountryId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT continents.Continent, COUNT(car_makers.Id) AS CarMakerCount FROM continents JOIN countries ON countries.Continent = continents.ContId JOIN car_makers ON car_makers.Country = countries.CountryId GROUP BY continents.Continent;","SELECT T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.continent JOIN car_makers AS T3 ON T2.CountryId  =  T3.Country GROUP BY T1.Continent;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of each continent (""continents.Continent"") and the count of car makers in each continent. Use COUNT on ""car_makers.Id"" to count the number of car makers. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""continents"" table with the ""countries"" table on ""countries.Continent = continents.ContId"" and then connect the ""countries"" table with the ""car_makers"" table on ""car_makers.Country = countries.CountryId"" to associate car makers with their respective continents. 4. Aggregation Structure: Use GROUP BY on ""continents.Continent"" to group the results by each continent and apply COUNT to calculate the number of car makers in each group.","[('america', 4), ('asia', 7), ('europe', 11)]","[('america', 4), ('asia', 7), ('europe', 11)]",,1.0,
What is the number of continents?,[continents.ContId],"Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT COUNT(DISTINCT continents.ContId) AS number_of_continents FROM continents;,SELECT count(*) FROM CONTINENTS;,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of continents. 2. Condition Structure: No specific filtering condition is required as we want the total count of continents. 3. Join Structure: No JOIN is necessary since all the required data is in the ""continents"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of unique continents.","[(5,)]","[(5,)]",,1.0,
Show names for all stadiums except for stadiums having a concert in year 2014.,"[stadium.Name,concert.Year,concert.Stadium_ID = stadium.Stadium_ID,2014]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,SELECT stadium.Name FROM stadium WHERE stadium.Stadium_ID NOT IN ( SELECT concert.Stadium_ID FROM concert WHERE concert.Year = 2014 );,SELECT name FROM stadium EXCEPT SELECT T2.name FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  =  2014,concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of stadiums. Use the FROM clause to specify the stadium table. Apply a WHERE clause to exclude stadiums that have a concert in the year 2014. 2. Condition Structure: Use the WHERE clause with a subquery to filter out stadiums whose Stadium_ID appears in the concert table for the year 2014. 3. Join Structure: Not required, as the filtering is done using a subquery that relates the concert table to the stadium table via Stadium_ID. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Bayview Stadium',), ('Hampden Park',), ('Forthbank Stadium',), ('Gayfield Park',), ('Recreation Park',), ('Balmoor',)]","[('Balmoor',), ('Bayview Stadium',), ('Forthbank Stadium',), ('Gayfield Park',), ('Hampden Park',), ('Recreation Park',)]",,1.0,
Find the first name and age of students who have a pet.,"[Student.Fname, Student.Age, Has_Pet.StuID = Student.StuID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,"SELECT Student.Fname, Student.Age FROM Student JOIN Has_Pet ON Student.StuID = Has_Pet.StuID;","SELECT DISTINCT T1.fname ,  T1.age FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid",pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student.Fname"" and ""Student.Age"" fields. 2. Condition Structure: No specific filtering condition is required, as we are interested in all students who have a pet. 3. Join Structure: Use an INNER JOIN between the ""Student"" table and the ""Has_Pet"" table on the ""StuID"" field to identify students who have a pet. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving the first name and age of students.","[('Linda', 18), ('Tracy', 19), ('Tracy', 19)]","[('Linda', 18), ('Tracy', 19)]",,1.0,
Find the average and maximum age for each type of pet.,"[Pets.PetType, Pets.pet_age, Has_Pet.PetID = Pets.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,"SELECT Pets.PetType, AVG(Pets.pet_age) AS average_age, MAX(Pets.pet_age) AS maximum_age FROM Has_Pet JOIN Pets ON Has_Pet.PetID = Pets.PetID GROUP BY Pets.PetType;","SELECT avg(pet_age) ,  max(pet_age) ,  pettype FROM pets GROUP BY pettype",pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Pets.PetType"" and calculate the average and maximum age for each type of pet using the AVG and MAX aggregate functions. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Has_Pet"" and ""Pets"" tables on ""Has_Pet.PetID = Pets.PetID"" to link pets with their details. 4. Aggregation Structure: Use AVG and MAX on ""Pets.pet_age"" to calculate the average and maximum age for each pet type, and GROUP BY ""Pets.PetType"" to group the results by pet type.","[('cat', 3.0, 3), ('dog', 1.5, 2)]","[(3.0, 3, 'cat'), (1.5, 2, 'dog')]",,1.0,
What is the model of the car with the smallest amount of horsepower?,"[cars_data.Horsepower,car_names.Model,cars_data.Id = car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT car_names.Model FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Horsepower = (SELECT MIN(cars_data.Horsepower) FROM cars_data);,SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.horsepower ASC LIMIT 1;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""car_names.Model"" field, as the question asks for the model of the car. Use a subquery in the WHERE clause to find the car with the smallest ""cars_data.Horsepower."" 2. Condition Structure: Use a WHERE clause to filter the car with the minimum horsepower. A subquery will be used to calculate the minimum value of ""cars_data.Horsepower."" 3. Join Structure: Use a JOIN between ""cars_data"" and ""car_names"" on ""cars_data.Id = car_names.MakeId"" to link the car data with its corresponding model. 4. Aggregation Structure: Use the MIN function in the subquery to find the smallest horsepower value.","[('amc',), ('chevrolet',), ('amc',), ('pontiac',), ('chevrolet',), ('amc',), ('amc',), ('amc',), ('chevrolet',), ('chevrolet',), ('amc',), ('plymouth',), ('dodge',), ('plymouth',), ('plymouth',), ('mazda',), ('datsun',)]","[('amc',)]",,1.0,
Find the average age of students who do not have any pet .,"[Student.Age, Has_Pet.StuID = Student.StuID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NESTED,SELECT AVG(Age) AS average_age FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_Pet);,select avg(age) from student where stuid not in (select stuid from has_pet),pets_1,"1. Sequential Structure: Start with the SELECT clause to calculate the average age of students. Use the FROM clause to specify the Student table. Apply a WHERE clause to filter students who do not have any pet by ensuring their StuID is not present in the Has_Pet table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose StuID appears in the Has_Pet table, meaning they have pets. 3. Join Structure: Not required, as we only need to filter based on the absence of matching StuID entries in the Has_Pet table. 4. Aggregation Structure: Use the AVG function to calculate the average age of the filtered students.","[(19.625,)]","[(19.625,)]",,1.0,
What are the names of the singers who performed in a concert in 2014?,"[singer.Name, concert.Year, singer.Singer_ID = singer_in_concert.Singer_ID, singer_in_concert.concert_ID = concert.concert_ID, 2014]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NON-NESTED,SELECT DISTINCT singer.Name FROM singer JOIN singer_in_concert ON singer.Singer_ID = singer_in_concert.Singer_ID JOIN concert ON singer_in_concert.concert_ID = concert.concert_ID WHERE concert.Year = 2014;,SELECT T2.name FROM singer_in_concert AS T1 JOIN singer AS T2 ON T1.singer_id  =  T2.singer_id JOIN concert AS T3 ON T1.concert_id  =  T3.concert_id WHERE T3.year  =  2014,concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of singers (""singer.Name""). 2. Condition Structure: Use a WHERE clause to filter for concerts that occurred in the year 2014 (""concert.Year = 2014""). 3. Join Structure: Use JOINs to connect the ""singer"" table with the ""singer_in_concert"" table on ""singer.Singer_ID = singer_in_concert.Singer_ID"" and the ""singer_in_concert"" table with the ""concert"" table on ""singer_in_concert.concert_ID = concert.concert_ID"" to link singers with their respective concerts. 4. Aggregation Structure: No aggregation is needed as we are retrieving individual singer names.","[('Timbaland',), ('Justin Brown',), ('John Nizinik',), ('Tribal King',), ('Rose White',)]","[('Timbaland',), ('Justin Brown',), ('John Nizinik',), ('Justin Brown',), ('Tribal King',), ('Rose White',)]",,1.0,
What is the average weight for each type of pet?,"[Pets.PetType, Pets.weight]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",EASY,"SELECT Pets.PetType, AVG(Pets.weight) AS avg_weight FROM Pets GROUP BY Pets.PetType;","SELECT avg(weight) ,  pettype FROM pets GROUP BY pettype",pets_1,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the pet type and the average weight. 2. Aggregation Structure: Use the AVG function to calculate the average weight for each type of pet. 3. Grouping Structure: Use GROUP BY on ""Pets.PetType"" to calculate the average weight for each pet type. 4. Join Structure: No JOIN is required since all necessary data is within the ""Pets"" table.","[('cat', 12.0), ('dog', 11.350000000000001)]","[(12.0, 'cat'), (11.350000000000001, 'dog')]",,1.0,
"Show name, country, age for all singers ordered by age from the oldest to the youngest.","[singer.Name, singer.Country, singer.Age]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",EASY,"SELECT singer.Name, singer.Country, singer.Age FROM singer ORDER BY singer.Age DESC;","SELECT name ,  country ,  age FROM singer ORDER BY age DESC",concert_singer,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""singer.Name"", ""singer.Country"", and ""singer.Age"". 2. Condition Structure: No specific filtering condition is required as we want all singers. 3. Join Structure: No JOIN is required since all necessary information is available in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by ""singer.Age"" in descending order to list singers from the oldest to the youngest.","[('Joe Sharp', 'Netherlands', 52), ('John Nizinik', 'France', 43), ('Rose White', 'France', 41), ('Timbaland', 'United States', 32), ('Justin Brown', 'France', 29), ('Tribal King', 'France', 25)]","[('Joe Sharp', 'Netherlands', 52), ('John Nizinik', 'France', 43), ('Rose White', 'France', 41), ('Timbaland', 'United States', 32), ('Justin Brown', 'France', 29), ('Tribal King', 'France', 25)]",,1.0,
"What major is every student who does not own a cat as a pet, and also how old are they?","[Student.Major, Student.Age, Has_Pet.StuID = Student.StuID, Has_Pet.PetID = Pets.PetID, Pets.PetType]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NESTED,"SELECT Student.Major, Student.Age FROM Student WHERE Student.StuID NOT IN ( SELECT Has_Pet.StuID FROM Has_Pet JOIN Pets ON Has_Pet.PetID = Pets.PetID WHERE Pets.PetType = 'Cat' );","SELECT major ,  age FROM student WHERE stuid NOT IN (SELECT T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid JOIN pets AS T3 ON T3.petid  =  T2.petid WHERE T3.pettype  =  'cat')",pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the major and age of students. Use the FROM clause to specify the Student table. Use a WHERE clause to filter students who do not own a cat as a pet. 2. Condition Structure: Use a subquery in the WHERE clause to exclude students whose StuID appears in the Has_Pet table linked to a PetID in the Pets table where the PetType is 'Cat'. 3. Join Structure: Use the relationships between Has_Pet, Pets, and Student tables to identify students who own pets and filter out those who own a cat. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[(600, 18), (600, 19), (600, 21), (600, 20), (600, 26), (600, 18), (600, 18), (600, 20), (600, 19), (600, 17), (600, 22), (600, 20), (600, 18), (600, 16), (600, 17), (600, 27), (600, 20), (600, 18), (520, 22), (520, 19), (540, 17), (520, 20), (540, 18), (520, 18), (520, 19), (520, 18), (550, 20), (100, 17), (550, 21), (550, 20), (550, 20), (550, 18), (50, 18), (50, 26)]","[(600, 19), (600, 21), (600, 20), (600, 26), (600, 18), (600, 18), (600, 20), (600, 19), (600, 17), (600, 22), (600, 20), (600, 18), (600, 16), (600, 17), (600, 27), (600, 20), (600, 18), (520, 22), (520, 19), (540, 17), (520, 20), (540, 18), (520, 18), (520, 19), (520, 18), (550, 20), (100, 17), (550, 21), (550, 20), (550, 20), (550, 18), (50, 18), (50, 26)]",,1.0,
Find the number of pets for each student who has any pet and student id.,"[Student.StuID, Has_Pet.StuID, Has_Pet.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,"SELECT Student.StuID, COUNT(Has_Pet.PetID) AS pet_count FROM Student JOIN Has_Pet ON Student.StuID = Has_Pet.StuID GROUP BY Student.StuID;","SELECT count(*) ,  T1.stuid FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid GROUP BY T1.stuid",pets_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Student.StuID"" and the count of pets for each student. Use COUNT on ""Has_Pet.PetID"" to count the number of pets. 2. Condition Structure: No specific filtering condition is needed since we are only interested in students who have pets. This is inherently handled by the JOIN and GROUP BY clauses. 3. Join Structure: Use an INNER JOIN between the ""Student"" and ""Has_Pet"" tables on ""Student.StuID = Has_Pet.StuID"" to associate students with their pets. 4. Aggregation Structure: Use COUNT on ""Has_Pet.PetID"" to count the number of pets for each student, and GROUP BY ""Student.StuID"" to group the results by each student.","[(1001, 1), (1002, 2)]","[(1, 1001), (2, 1002)]",,1.0,
How much does the car accelerate that makes amc hornet sportabout (sw)?,"[car_names.Make,car_names.Model,cars_data.Accelerate,cars_data.Id = car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT cars_data.Accelerate FROM car_names JOIN cars_data ON cars_data.Id = car_names.MakeId WHERE car_names.Make = 'amc' AND car_names.Model = 'hornet sportabout (sw)';,SELECT T1.Accelerate FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Make  =  'amc hornet sportabout (sw)';,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""cars_data.Accelerate"" value for the specific car model. 2. Condition Structure: Use a WHERE clause to filter for the car with the ""Make"" as ""amc"" and ""Model"" as ""hornet sportabout (sw)."" 3. Join Structure: Use a JOIN between the ""car_names"" and ""cars_data"" tables based on the foreign key relationship ""cars_data.Id = car_names.MakeId"" to link car details with their acceleration data. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single value.",[],"[(13.5,)]",,0.0,
What are the names of all stadiums that did not have a concert in 2014?,"[stadium.Name,concert.Year,concert.Stadium_ID = stadium.Stadium_ID]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,SELECT stadium.Name FROM stadium WHERE stadium.Stadium_ID NOT IN (SELECT concert.Stadium_ID FROM concert WHERE concert.Year = 2014);,SELECT name FROM stadium EXCEPT SELECT T2.name FROM concert AS T1 JOIN stadium AS T2 ON T1.stadium_id  =  T2.stadium_id WHERE T1.year  =  2014,concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of stadiums. Use the FROM clause to specify the stadium table. Apply a WHERE clause to filter stadiums that did not have a concert in 2014 by ensuring their Stadium_ID is not present in the concert table for the year 2014. 2. Condition Structure: Use the WHERE clause with a subquery to exclude stadiums whose Stadium_ID appears in the concert table for the year 2014. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Stadium_ID entries in the concert table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Bayview Stadium',), ('Hampden Park',), ('Forthbank Stadium',), ('Gayfield Park',), ('Recreation Park',), ('Balmoor',)]","[('Balmoor',), ('Bayview Stadium',), ('Forthbank Stadium',), ('Gayfield Park',), ('Hampden Park',), ('Recreation Park',)]",,1.0,
What is the smallest weight of the car produced with 8 cylinders on 1974 ?,"[cars_data.Weight, cars_data.Cylinders, cars_data.Year]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT MIN(cars_data.Weight) AS smallest_weight FROM cars_data WHERE cars_data.Cylinders = 8 AND cars_data.Year = 1974;,select min(weight) from cars_data where cylinders  =  8 and year  =  1974,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the smallest weight of the car. Use the MIN function to find the smallest value of ""cars_data.Weight"". 2. Condition Structure: Use a WHERE clause to filter for cars with ""cars_data.Cylinders"" equal to 8 and ""cars_data.Year"" equal to 1974. 3. Join Structure: No JOIN is required since all necessary information is in the ""cars_data"" table. 4. Aggregation Structure: Use the MIN function to calculate the smallest weight among the filtered cars.","[(4141,)]","[(4141,)]",,1.0,
Find number of pets owned by students who are older than 20.,"[Student.StuID, Student.Age, Has_Pet.StuID = Student.StuID, Has_Pet.PetID]","Table Has_Pet, columns = [*,StuID,PetID]
Table Pets, columns = [*,PetID,PetType,pet_age,weight]
Table Student, columns = [*,StuID,LName,Fname,Age,Sex,Major,Advisor,city_code]
","Foreign_keys = [Has_Pet.StuID = Student.StuID,Has_Pet.PetID = Pets.PetID]
",NON-NESTED,SELECT COUNT(Has_Pet.PetID) FROM Student JOIN Has_Pet ON Has_Pet.StuID = Student.StuID WHERE Student.Age > 20;,SELECT count(*) FROM student AS T1 JOIN has_pet AS T2 ON T1.stuid  =  T2.stuid WHERE T1.age  >  20,pets_1,"1. Sequential Structure: Start with the SELECT clause to count the number of pets owned by students. Use COUNT on ""Has_Pet.PetID"" to count the pets. 2. Condition Structure: Use a WHERE clause to filter for students who are older than 20 by checking ""Student.Age > 20."" 3. Join Structure: Use an INNER JOIN between the ""Student"" table and the ""Has_Pet"" table on ""Has_Pet.StuID = Student.StuID"" to associate students with their pets. 4. Aggregation Structure: Use COUNT to aggregate the number of pets owned by the filtered students.","[(0,)]","[(0,)]",,1.0,
"How many countries does each continent have? List the continent id, continent name and the number of countries.","[continents.ContId,continents.Continent,countries.Continent,countries.CountryId,continents.ContId = countries.Continent]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT continents.ContId, continents.Continent, COUNT(countries.CountryId) AS NumberOfCountries FROM continents JOIN countries ON continents.ContId = countries.Continent GROUP BY continents.ContId, continents.Continent;","SELECT T1.ContId ,  T1.Continent ,  count(*) FROM CONTINENTS AS T1 JOIN COUNTRIES AS T2 ON T1.ContId  =  T2.Continent GROUP BY T1.ContId;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""continents.ContId,"" ""continents.Continent,"" and the count of countries for each continent. Use COUNT on ""countries.CountryId"" to count the number of countries. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""continents"" and ""countries"" tables based on the relationship ""continents.ContId = countries.Continent"" to associate each continent with its countries. 4. Aggregation Structure: Use COUNT to calculate the number of countries per continent and GROUP BY ""continents.ContId"" and ""continents.Continent"" to group the results by each continent.","[(1, 'america', 3), (2, 'europe', 6), (3, 'asia', 2), (4, 'africa', 2), (5, 'australia', 2)]","[(1, 'america', 3), (2, 'europe', 6), (3, 'asia', 2), (4, 'africa', 2), (5, 'australia', 2)]",,1.0,
What is the average weight and year for each year?,"[cars_data.Weight, cars_data.Year]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,"SELECT cars_data.Year, AVG(cars_data.Weight) AS avg_weight, AVG(cars_data.Year) AS avg_year FROM cars_data GROUP BY cars_data.Year;","SELECT avg(Weight) ,  YEAR FROM CARS_DATA GROUP BY YEAR;",car_1,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the year and the aggregate values for average weight and year. 2. Aggregation Structure: Use AVG to calculate the average weight and year for each year. 3. Grouping Structure: Use GROUP BY on ""cars_data.Year"" to calculate these aggregate values for each year. 4. Join Structure: No JOIN is required since all necessary data is within the ""cars_data"" table.","[(1970, 3441.3142857142857, 1970.0), (1971, 2960.344827586207, 1971.0), (1972, 3237.714285714286, 1972.0), (1973, 3419.025, 1973.0), (1974, 2877.925925925926, 1974.0), (1975, 3176.8, 1975.0), (1976, 3078.735294117647, 1976.0), (1977, 2997.3571428571427, 1977.0), (1978, 2861.8055555555557, 1978.0), (1979, 3055.344827586207, 1979.0), (1980, 2436.655172413793, 1980.0), (1981, 2532.1666666666665, 1981.0), (1982, 2453.548387096774, 1982.0)]","[(3441.3142857142857, 1970), (2960.344827586207, 1971), (3237.714285714286, 1972), (3419.025, 1973), (2877.925925925926, 1974), (3176.8, 1975), (3078.735294117647, 1976), (2997.3571428571427, 1977), (2861.8055555555557, 1978), (3055.344827586207, 1979), (2436.655172413793, 1980), (2532.1666666666665, 1981), (2453.548387096774, 1982)]",,1.0,
What is the name and capacity for the stadium with highest average attendance?,"[stadium.Name, stadium.Capacity, stadium.Average]","Table concert, columns = [*,concert_ID,concert_Name,Theme,Stadium_ID,Year]
Table singer, columns = [*,Singer_ID,Name,Country,Song_Name,Song_release_year,Age,Is_male]
Table singer_in_concert, columns = [*,concert_ID,Singer_ID]
Table stadium, columns = [*,Stadium_ID,Location,Name,Capacity,Highest,Lowest,Average]
","Foreign_keys = [concert.Stadium_ID = stadium.Stadium_ID,singer_in_concert.Singer_ID = singer.Singer_ID,singer_in_concert.concert_ID = concert.concert_ID]
",NESTED,"SELECT Name, Capacity FROM stadium WHERE Average = (SELECT MAX(Average) FROM stadium);","SELECT name ,  capacity FROM stadium ORDER BY average DESC LIMIT 1",concert_singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the name and capacity of the stadium. Use the FROM clause to specify the stadium table. Apply a WHERE clause to filter for the stadium with the highest average attendance. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the stadium where the average attendance is equal to the maximum average attendance. 3. Join Structure: Not required, as all the necessary data is in the stadium table. 4. Aggregation Structure: Use MAX in a subquery to find the maximum average attendance, and filter the main query based on this value.","[(""Stark's Park"", 10104)]","[(""Stark's Park"", 10104)]",,1.0,
How many flights depart from City 'Aberdeen' and have destination City 'Ashley'?,"[flights.SourceAirport, flights.DestAirport, airports.City, flights.SourceAirport = airports.AirportCode, flights.DestAirport = airports.AirportCode, 'Aberdeen', 'Ashley']","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(*) FROM flights JOIN airports AS source_airport ON flights.SourceAirport = source_airport.AirportCode JOIN airports AS dest_airport ON flights.DestAirport = dest_airport.AirportCode WHERE source_airport.City = 'Aberdeen' AND dest_airport.City = 'Ashley';,"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRPORTS AS T3 ON T1.SourceAirport  =  T3.AirportCode WHERE T2.City  =  ""Ashley"" AND T3.City  =  ""Aberdeen""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights. Use COUNT(*) to count all matching rows. 2. Condition Structure: Use a WHERE clause to filter flights where the source airport is in the city ""Aberdeen"" and the destination airport is in the city ""Ashley."" 3. Join Structure: Use two JOINs to connect the ""flights"" table with the ""airports"" table. The first JOIN links ""flights.SourceAirport"" with ""airports.AirportCode"" to get the source city, and the second JOIN links ""flights.DestAirport"" with ""airports.AirportCode"" to get the destination city. 4. Aggregation Structure: No additional aggregation is needed beyond the COUNT function.","[(0,)]","[(0,)]",,1.0,
"For model volvo, how many cylinders does the car with the least accelerate have?","[car_names.Model, cars_data.Cylinders, cars_data.Accelerate, car_names.MakeId = cars_data.Id, model_list.Model = car_names.Model]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT cars_data.Cylinders FROM car_names JOIN cars_data ON car_names.MakeId = cars_data.Id JOIN model_list ON model_list.Model = car_names.Model WHERE model_list.Model = 'volvo' ORDER BY cars_data.Accelerate ASC LIMIT 1;,SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the number of cylinders. Use the FROM clause to specify the car_names and cars_data tables. Join these tables on the MakeId and Id fields to connect car models with their data. Apply a WHERE clause to filter for the model ""volvo"". Use ORDER BY on the Accelerate column in ascending order to find the car with the least acceleration and LIMIT 1 to select only that car. 2. Condition Structure: Use the WHERE clause to filter for the model ""volvo"". 3. Join Structure: Use an INNER JOIN between car_names and cars_data tables based on the relationship car_names.MakeId = cars_data.Id. Additionally, use the model_list table to ensure the model ""volvo"" is correctly identified by joining model_list.Model = car_names.Model. 4. Aggregation Structure: Not required, as we are retrieving specific data for a single car with the least acceleration.","[(6,)]","[(6,)]",,1.0,
"What are flight numbers of flights departing from City ""Aberdeen ""?","[flights.FlightNo,flights.SourceAirport,airports.City,flights.SourceAirport = airports.AirportCode,""Aberdeen""]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT flights.FlightNo FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode WHERE airports.City = 'Aberdeen';,"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport   =  T2.AirportCode WHERE T2.City  =  ""Aberdeen""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""flights.FlightNo"" as the question asks for flight numbers. 2. Condition Structure: Use a WHERE clause to filter flights where the source airport is located in the city ""Aberdeen."" 3. Join Structure: Use an INNER JOIN between the ""flights"" table and the ""airports"" table on ""flights.SourceAirport = airports.AirportCode"" to link flights with their source airport details. 4. Aggregation Structure: No aggregation is needed as the query only retrieves flight numbers.",[],[],,1.0,
How many flights depart from 'APG'?,"[flights.SourceAirport,flights.FlightNo,flights.SourceAirport = 'APG']","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT COUNT(flights.FlightNo) FROM flights WHERE flights.SourceAirport = 'APG';,"SELECT count(*) FROM FLIGHTS WHERE SourceAirport  =  ""APG""",flight_2,"1. Sequential Structure: Begin with the SELECT clause to count the number of flights departing from the specified airport. 2. Condition Structure: Use a WHERE clause to filter flights where ""flights.SourceAirport"" is equal to 'APG'. 3. Join Structure: No JOIN is required since all necessary information is available in the ""flights"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of flights departing from 'APG'.","[(0,)]","[(0,)]",,1.0,
Which airlines have at least 10 flights?,"[flights.Airline, flights.FlightNo]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT flights.Airline FROM flights GROUP BY flights.Airline HAVING COUNT(flights.FlightNo) >= 10;,SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10,flight_2,"1. Sequential Structure: Begin with the SELECT clause to specify the airline name, as the question asks for the airlines. 2. Aggregation Structure: Use COUNT to calculate the number of flights for each airline. 3. Grouping Structure: Use GROUP BY on ""flights.Airline"" to count the flights for each airline. 4. Condition Structure: Apply the HAVING clause to filter airlines with at least 10 flights, by setting the count to be greater than or equal to 10. 5. Join Structure: No JOIN is required since all necessary data is within the ""flights"" table.","[(1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,), (10,), (11,), (12,)]","[('AirTran Airways',), ('Allegiant Air',), ('American Airlines',), ('Continental Airlines',), ('Delta Airlines',), ('Frontier Airlines',), ('JetBlue Airways',), ('Northwest Airlines',), ('Southwest Airlines',), ('US Airways',), ('United Airlines',), ('Virgin America',)]",,0.0,
What airline serves the most flights?,[flights.Airline],"Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT flights.Airline FROM flights GROUP BY flights.Airline ORDER BY COUNT(*) DESC LIMIT 1;,SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1,flight_2,"1. Sequential Structure: Begin with the SELECT clause to specify the airline name, as the question asks for the airline serving the most flights. 2. Aggregation Structure: Use COUNT to calculate the number of flights served by each airline. 3. Grouping Structure: Use GROUP BY on ""flights.Airline"" to count the flights for each airline. 4. Ordering Structure: Use ORDER BY in descending order on the flight count to rank airlines by the number of flights they serve. 5. Limiting Structure: Use LIMIT 1 to retrieve only the airline with the most flights. 6. Join Structure: No JOIN is required since all necessary data is within the ""flights"" table.","[(1,)]","[('Virgin America',)]",,0.0,
How many countries has more than 2 car makers ?,"[countries.CountryId, car_makers.Country, countries.CountryId = car_makers.Country]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT COUNT(*) FROM ( SELECT countries.CountryId FROM countries JOIN car_makers ON countries.CountryId = car_makers.Country GROUP BY countries.CountryId HAVING COUNT(car_makers.Id) > 2 ) AS subquery;,select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of countries that have more than 2 car makers. Use COUNT to count the number of car makers for each country. 2. Condition Structure: Use a HAVING clause to filter for countries where the count of car makers is greater than 2. 3. Join Structure: Use an INNER JOIN between the ""countries"" table and the ""car_makers"" table on the ""countries.CountryId"" and ""car_makers.Country"" columns to associate car makers with their respective countries. 4. Aggregation Structure: Use COUNT to count the number of car makers for each country, and GROUP BY ""countries.CountryId"" to group the results by country.","[(4,)]","[(4,), (4,), (3,), (5,)]",,0.0,
What are the different models wthat are lighter than 3500 but were not built by the Ford Motor Company?,"[cars_data.Weight, cars_data.Id = car_names.MakeId, car_names.Model, car_names.Model = model_list.Model, model_list.Maker, car_makers.Id = model_list.Maker, car_makers.FullName, 3500, Ford Motor Company]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT DISTINCT car_names.Model FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId JOIN model_list ON car_names.Model = model_list.Model JOIN car_makers ON model_list.Maker = car_makers.Id WHERE cars_data.Weight < 3500 AND car_makers.FullName != 'Ford Motor Company';,SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct models. Use the FROM clause to specify the cars_data table and join it with car_names, model_list, and car_makers to connect the weight, model, and maker details. Apply a WHERE clause to filter for cars with weight less than 3500 and exclude those made by the Ford Motor Company. 2. Condition Structure: Use the WHERE clause to filter for cars with weight less than 3500 and exclude those where the FullName of the maker is 'Ford Motor Company'. 3. Join Structure: Use INNER JOINs to connect cars_data with car_names on Id = MakeId, car_names with model_list on Model, and model_list with car_makers on Maker = Id to access the required fields. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('plymouth',), ('amc',), ('citroen',), ('buick',), ('toyota',), ('datsun',), ('volkswagen',), ('peugeot',), ('audi',), ('saab',), ('bmw',), ('chevrolet',), ('pontiac',), ('opel',), ('fiat',), ('dodge',), ('mazda',), ('volvo',), ('renault',), ('honda',), ('subaru',), ('oldsmobile',), ('mercedes-benz',), ('triumph',), ('chrysler',), ('nissan',)]","[('plymouth',), ('amc',), ('citroen',), ('buick',), ('toyota',), ('datsun',), ('volkswagen',), ('peugeot',), ('audi',), ('saab',), ('bmw',), ('chevrolet',), ('pontiac',), ('opel',), ('fiat',), ('dodge',), ('mazda',), ('volvo',), ('renault',), ('honda',), ('subaru',), ('oldsmobile',), ('mercedes-benz',), ('triumph',), ('chrysler',), ('nissan',)]",,1.0,
Which flight numbers correspond to United Airlines flights?,"[flights.FlightNo,flights.Airline,airlines.Airline]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT flights.FlightNo FROM flights JOIN airlines ON flights.Airline = airlines.Airline WHERE airlines.Airline = 'United Airlines';,"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  ""United Airlines""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""flights.FlightNo"" field, as the question asks for flight numbers. 2. Condition Structure: Use a WHERE clause to filter for flights where the airline corresponds to ""United Airlines."" 3. Join Structure: Use a JOIN between the ""flights"" table and the ""airlines"" table on the ""Airline"" field to match flights with their respective airlines. 4. Aggregation Structure: No aggregation is needed since the query only retrieves specific flight numbers.",[],"[(28,), (29,), (44,), (45,), (54,), (55,), (90,), (91,), (108,), (109,), (142,), (143,), (148,), (149,), (198,), (199,), (226,), (227,), (276,), (277,), (308,), (309,), (326,), (327,), (370,), (371,), (414,), (415,), (424,), (425,), (470,), (471,), (520,), (521,), (556,), (557,), (560,), (561,), (604,), (605,), (608,), (609,), (626,), (627,), (658,), (659,), (708,), (709,), (744,), (745,), (754,), (755,), (786,), (787,), (810,), (811,), (828,), (829,), (878,), (879,), (888,), (889,), (900,), (901,), (924,), (925,), (946,), (947,), (996,), (997,), (1000,), (1001,), (1026,), (1027,), (1062,), (1063,), (1068,), (1069,), (1100,), (1101,), (1144,), (1145,), (1166,), (1167,), (1168,), (1169,), (1192,), (1193,), (1208,), (1209,), (1216,), (1217,), (1250,), (1251,), (1274,), (1275,), (1284,), (1285,), (1328,), (1329,)]",,0.0,
Return the number of  airports.,[airports.AirportCode],"Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT COUNT(airports.AirportCode) AS total_airports FROM airports;,SELECT count(*) FROM AIRPORTS,flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of airports. 2. Aggregation Structure: Use the COUNT function on the ""airports.AirportCode"" column to calculate the total number of airports. 3. Condition Structure: No specific filtering condition is required as we want the total count of all airports. 4. Join Structure: No JOIN is necessary since all required data is within the ""airports"" table.","[(100,)]","[(100,)]",,1.0,
What are the names of airports in Aberdeen?,"[airports.City, airports.AirportName]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT airports.AirportName FROM airports WHERE airports.City = 'Aberdeen';,"SELECT AirportName FROM AIRPORTS WHERE City = ""Aberdeen""",flight_2,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the airport name. 2. Condition Structure: Use a WHERE clause to filter for airports located in the city of Aberdeen. 3. Join Structure: No JOIN is required since all necessary information is in the ""airports"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving airport names based on a specific condition.",[],[],,1.0,
How many flights fly from Aberdeen to Ashley?,"[flights.SourceAirport, flights.DestAirport, airports.City, flights.SourceAirport = airports.AirportCode, flights.DestAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(*) FROM flights JOIN airports AS source_airport ON flights.SourceAirport = source_airport.AirportCode JOIN airports AS dest_airport ON flights.DestAirport = dest_airport.AirportCode WHERE source_airport.City = 'Aberdeen' AND dest_airport.City = 'Ashley';,"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRPORTS AS T3 ON T1.SourceAirport  =  T3.AirportCode WHERE T2.City  =  ""Ashley"" AND T3.City  =  ""Aberdeen""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights. Use COUNT(*) to count all rows that match the specified conditions. 2. Condition Structure: Use a WHERE clause to filter flights where the source airport corresponds to the city ""Aberdeen"" and the destination airport corresponds to the city ""Ashley."" 3. Join Structure: Use two JOINs to connect the ""flights"" table with the ""airports"" table. The first JOIN links ""flights.SourceAirport"" with ""airports.AirportCode"" to get the source city, and the second JOIN links ""flights.DestAirport"" with ""airports.AirportCode"" to get the destination city. 4. Aggregation Structure: Use COUNT(*) to aggregate the total number of flights that meet the specified conditions.","[(0,)]","[(0,)]",,1.0,
What are airport names at City 'Aberdeen'?,"[airports.AirportName,airports.City,airports.City = 'Aberdeen']","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT airports.AirportName FROM airports WHERE airports.City = 'Aberdeen';,"SELECT AirportName FROM AIRPORTS WHERE City = ""Aberdeen""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airports.AirportName"" for airports located in the city of 'Aberdeen'. 2. Condition Structure: Use a WHERE clause to filter records where ""airports.City"" is equal to 'Aberdeen'. 3. Join Structure: No JOIN is required since all necessary information is in the ""airports"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving airport names based on a specific condition.",[],[],,1.0,
How many flights have destination ATO?,"[flights.DestAirport,flights.FlightNo,flights.DestAirport = airports.AirportCode,ATO]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT COUNT(flights.FlightNo) FROM flights WHERE flights.DestAirport = 'ATO';,"SELECT count(*) FROM FLIGHTS WHERE DestAirport  =  ""ATO""",flight_2,"1. Sequential Structure: Begin with the SELECT clause to count the number of flights, as the question asks for the total number of flights with a specific destination. 2. Condition Structure: Use a WHERE clause to filter flights where the destination airport is ""ATO"". 3. Join Structure: No JOIN is required since the destination airport code is directly available in the ""flights"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of flights meeting the specified condition.","[(0,)]","[(0,)]",,1.0,
Give the city and country for the Alton airport.,"[airports.City, airports.Country, airports.AirportName]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,"SELECT airports.City, airports.Country FROM airports WHERE airports.AirportName = 'Alton';","SELECT City ,  Country FROM AIRPORTS WHERE AirportName  =  ""Alton""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the city and country of the airport named ""Alton"". 2. Condition Structure: Use a WHERE clause to filter for the airport where ""airports.AirportName"" is ""Alton"". 3. Join Structure: No JOIN is required since all necessary information is in the ""airports"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",[],[],,1.0,
Give the number of Jetblue Airways flights.,"[flights.Airline,flights.FlightNo,airlines.Airline]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(flights.FlightNo) FROM flights WHERE flights.Airline = 'Jetblue Airways';,"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = ""JetBlue Airways""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights. Use COUNT on ""flights.FlightNo"" to get the total number of flights. 2. Condition Structure: Use a WHERE clause to filter for flights operated by ""Jetblue Airways."" This requires matching the ""flights.Airline"" field with the airline name. 3. Join Structure: No JOIN is needed here, as the required information is available in the ""flights"" table. 4. Aggregation Structure: Use COUNT to aggregate the total number of flights for the specified airline.","[(0,)]","[(100,)]",,0.0,
"For all of the 4 cylinder cars, which model has the most horsepower?","[cars_data.Cylinders, cars_data.Horsepower, cars_data.Id = car_names.MakeId, car_names.Model]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT car_names.Model, MAX(cars_data.Horsepower) AS MaxHorsepower FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Cylinders = 4 GROUP BY car_names.Model ORDER BY MaxHorsepower DESC LIMIT 1;",SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""car_names.Model"" and the maximum ""cars_data.Horsepower"" for 4-cylinder cars. Use an aggregation function (MAX) to find the model with the highest horsepower. 2. Condition Structure: Use a WHERE clause to filter for cars with ""cars_data.Cylinders"" equal to 4. 3. Join Structure: Use a JOIN between ""cars_data"" and ""car_names"" on ""cars_data.Id = car_names.MakeId"" to link car data with their respective models. 4. Aggregation Structure: Use MAX to find the maximum horsepower among 4-cylinder cars. Use ORDER BY and LIMIT 1 to ensure only the model with the highest horsepower is returned.","[('renault', 'null')]","[('ford',)]",,0.0,
Return the number of flights.,[flights.FlightNo],"Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT COUNT(flights.FlightNo) AS total_flights FROM flights;,SELECT count(*) FROM FLIGHTS,flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights. Use the COUNT function on ""flights.FlightNo"" to determine the total number of flights. 2. Condition Structure: No specific filtering condition is required since the query asks for the total number of flights. 3. Join Structure: No JOIN is necessary as all the required data is available in the ""flights"" table. 4. Aggregation Structure: Use the COUNT function to aggregate the total number of flights.","[(1200,)]","[(1200,)]",,1.0,
How many 'United Airlines' flights depart from Airport 'AHD'?,"[flights.Airline,flights.SourceAirport,airports.AirportCode,flights.SourceAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(*) FROM flights WHERE flights.Airline = 'United Airlines' AND flights.SourceAirport = 'AHD';,"SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  ""United Airlines"" AND T2.SourceAirport  =  ""AHD""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights. Use COUNT to calculate the total number of flights matching the criteria. 2. Condition Structure: Use a WHERE clause to filter for flights where the airline is ""United Airlines"" and the source airport is ""AHD."" 3. Join Structure: No JOIN is necessary because the relevant fields (Airline and SourceAirport) are already in the ""flights"" table. 4. Aggregation Structure: Use COUNT to aggregate the total number of flights that meet the specified conditions.","[(0,)]","[(0,)]",,1.0,
"What are flight numbers of Airline ""United Airlines""?","[flights.FlightNo,flights.Airline]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT flights.FlightNo FROM flights WHERE flights.Airline = 'United Airlines';,"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T2.uid  =  T1.Airline WHERE T2.Airline  =  ""United Airlines""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the flight numbers (""flights.FlightNo"") of the airline ""United Airlines"". 2. Condition Structure: Use a WHERE clause to filter for flights where the ""flights.Airline"" matches ""United Airlines"". 3. Join Structure: No JOIN is required since all necessary information is available in the ""flights"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving flight numbers based on a specific condition.",[],"[(28,), (29,), (44,), (45,), (54,), (55,), (90,), (91,), (108,), (109,), (142,), (143,), (148,), (149,), (198,), (199,), (226,), (227,), (276,), (277,), (308,), (309,), (326,), (327,), (370,), (371,), (414,), (415,), (424,), (425,), (470,), (471,), (520,), (521,), (556,), (557,), (560,), (561,), (604,), (605,), (608,), (609,), (626,), (627,), (658,), (659,), (708,), (709,), (744,), (745,), (754,), (755,), (786,), (787,), (810,), (811,), (828,), (829,), (878,), (879,), (888,), (889,), (900,), (901,), (924,), (925,), (946,), (947,), (996,), (997,), (1000,), (1001,), (1026,), (1027,), (1062,), (1063,), (1068,), (1069,), (1100,), (1101,), (1144,), (1145,), (1166,), (1167,), (1168,), (1169,), (1192,), (1193,), (1208,), (1209,), (1216,), (1217,), (1250,), (1251,), (1274,), (1275,), (1284,), (1285,), (1328,), (1329,)]",,0.0,
"Among the cars that do not have the minimum horsepower , what are the make ids and names of all those with less than 4 cylinders ?","[cars_data.Horsepower, cars_data.Cylinders, cars_data.Id = car_names.MakeId, car_names.MakeId, car_names.Make]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,"SELECT car_names.MakeId, car_names.Make FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Horsepower > (SELECT MIN(Horsepower) FROM cars_data) AND cars_data.Cylinders < 4;","select t2.makeid ,  t2.make from cars_data as t1 join car_names as t2 on t1.id  =  t2.makeid where t1.horsepower  >  (select min(horsepower) from cars_data) and t1.cylinders  <  4;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the make IDs and names of cars. Use the FROM clause to specify the cars_data and car_names tables. Apply a WHERE clause to filter out cars with the minimum horsepower and those with less than 4 cylinders. 2. Condition Structure: Use the WHERE clause to exclude cars with the minimum horsepower by using a subquery to find the minimum horsepower. Additionally, filter for cars with less than 4 cylinders. 3. Join Structure: Use an INNER JOIN between the cars_data and car_names tables based on the relationship cars_data.Id = car_names.MakeId to connect car details with their make names. 4. Aggregation Structure: Use the MIN function in a subquery to find the minimum horsepower, which is then used in the filtering condition.","[(79, 'mazda rx2 coupe'), (119, 'mazda rx3'), (251, 'mazda rx-4')]","[(79, 'mazda rx2 coupe'), (119, 'mazda rx3'), (251, 'mazda rx-4')]",,1.0,
What is the maximum accelerate for different number of cylinders?,"[cars_data.Cylinders, cars_data.Accelerate]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,"SELECT cars_data.Cylinders, MAX(cars_data.Accelerate) AS max_accelerate FROM cars_data GROUP BY cars_data.Cylinders;","SELECT max(Accelerate) ,  Cylinders FROM CARS_DATA GROUP BY Cylinders;",car_1,"1. Sequential Structure: Begin with the SELECT clause to specify the number of cylinders and the maximum acceleration. 2. Aggregation Structure: Use the MAX function to calculate the maximum acceleration for each number of cylinders. 3. Grouping Structure: Use GROUP BY on ""cars_data.Cylinders"" to calculate the maximum acceleration for each distinct number of cylinders. 4. Join Structure: No JOIN is required since all necessary data is within the ""cars_data"" table.","[(3, 13.5), (4, 24.8), (5, 20.1), (6, 21.0), (8, 22.2)]","[(13.5, 3), (24.8, 4), (20.1, 5), (21.0, 6), (22.2, 8)]",,1.0,
Which airlines have departures from CVO but not from APG airports?,"[flights.Airline, flights.SourceAirport, airports.AirportCode, flights.SourceAirport = airports.AirportCode, CVO, APG]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NESTED,SELECT DISTINCT Airline FROM flights WHERE SourceAirport = 'CVO' AND Airline NOT IN ( SELECT DISTINCT Airline FROM flights WHERE SourceAirport = 'APG' );,"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  ""CVO"" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  ""APG""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct airlines from the flights table. Use the FROM clause to specify the flights table. Apply a WHERE clause to filter for flights departing from the CVO airport. Use a subquery in the WHERE clause to exclude airlines that have departures from the APG airport. 2. Condition Structure: Use the WHERE clause to filter for flights where the SourceAirport is 'CVO'. Use a subquery to exclude airlines that have flights where the SourceAirport is 'APG'. 3. Join Structure: Not required, as all necessary data is available in the flights table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",[],[],,1.0,
What are the ids and makers of all car makers that produce at least 2 models and make more than 3 cars?,"[car_makers.Id, car_makers.Maker, model_list.Maker = car_makers.Id, car_names.Model = model_list.Model, cars_data.Id = car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,"SELECT car_makers.Id, car_makers.Maker FROM car_makers JOIN model_list ON model_list.Maker = car_makers.Id JOIN car_names ON car_names.Model = model_list.Model JOIN cars_data ON cars_data.Id = car_names.MakeId GROUP BY car_makers.Id, car_makers.Maker HAVING COUNT(DISTINCT model_list.Model) >= 2 AND COUNT(cars_data.Id) > 3;","SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >=  2 INTERSECT SELECT T1.Id ,  T1.Maker FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker JOIN CAR_NAMES AS T3 ON T2.model  =  T3.model GROUP BY T1.Id HAVING count(*)  >  3;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs and makers of car makers. Use the FROM clause to specify the car_makers table. Join it with the model_list table to link car makers with their models, and then join with the car_names and cars_data tables to link models with cars. Use GROUP BY to group by car maker ID and maker name. Apply a HAVING clause to filter car makers that produce at least 2 models and make more than 3 cars. 2. Condition Structure: Use the HAVING clause to filter groups where the count of distinct models is at least 2 and the count of cars is more than 3. 3. Join Structure: Use INNER JOINs between car_makers, model_list, car_names, and cars_data tables based on their respective foreign key relationships to connect car makers, models, and cars. 4. Aggregation Structure: Use COUNT(DISTINCT model_list.Model) to count the number of distinct models for each car maker and COUNT(cars_data.Id) to count the number of cars. Apply these aggregate functions in the HAVING clause to enforce the conditions.","[(2, 'volkswagen'), (4, 'gm'), (5, 'ford'), (6, 'chrysler'), (8, 'nissan')]","[(2, 'volkswagen'), (4, 'gm'), (5, 'ford'), (6, 'chrysler'), (8, 'nissan'), (19, 'toyota')]",,0.0,
Return the number of United Airlines flights leaving from AHD Airport.,"[flights.Airline, flights.SourceAirport, flights.FlightNo, airports.AirportCode, flights.SourceAirport = airports.AirportCode, United Airlines, AHD]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(flights.FlightNo) FROM flights WHERE flights.Airline = 'United Airlines' AND flights.SourceAirport = 'AHD';,"SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  ""United Airlines"" AND T2.SourceAirport  =  ""AHD""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights. Use COUNT on ""flights.FlightNo"" to get the total number of flights. 2. Condition Structure: Use a WHERE clause to filter for flights where the airline is ""United Airlines"" and the source airport is ""AHD."" 3. Join Structure: No JOIN is required since the relevant fields are all in the ""flights"" table. 4. Aggregation Structure: Use COUNT to aggregate the total number of flights matching the specified conditions.","[(0,)]","[(0,)]",,1.0,
What is the horsepower of the car with the largest accelerate?,"[cars_data.Horsepower, cars_data.Accelerate]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT cars_data.Horsepower FROM cars_data WHERE cars_data.Accelerate = (SELECT MAX(cars_data.Accelerate) FROM cars_data);,SELECT T1.horsepower FROM CARS_DATA AS T1 ORDER BY T1.accelerate DESC LIMIT 1;,car_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""Horsepower"" of the car. 2. Condition Structure: Use a WHERE clause to filter for the car with the largest ""Accelerate"" value. 3. Join Structure: No JOIN is required since all necessary data is within the ""cars_data"" table. 4. Aggregation Structure: Use the MAX function to find the largest ""Accelerate"" value and filter the corresponding car's ""Horsepower"".","[('71',)]","[('71',)]",,1.0,
"What are flight numbers of flights arriving at Airport ""APG""?","[flights.FlightNo,flights.DestAirport,airports.AirportCode,flights.DestAirport = airports.AirportCode,APG]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT flights.FlightNo FROM flights WHERE flights.DestAirport = 'APG';,"SELECT FlightNo FROM FLIGHTS WHERE DestAirport  =  ""APG""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""flights.FlightNo"" field, as the question asks for flight numbers. 2. Condition Structure: Use a WHERE clause to filter for flights where the ""flights.DestAirport"" matches the airport code ""APG."" 3. Join Structure: No JOIN is necessary because the ""flights.DestAirport"" directly corresponds to the ""airports.AirportCode,"" and the condition can be applied directly. 4. Aggregation Structure: No aggregation is needed since the query only retrieves specific flight numbers without any summarization.",[],[],,1.0,
What are the name of the countries where there is not a single car maker?,"[countries.CountryName,car_makers.Country,countries.CountryId = car_makers.Country]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT countries.CountryName FROM countries WHERE countries.CountryId NOT IN (SELECT car_makers.Country FROM car_makers);,SELECT CountryName FROM countries EXCEPT SELECT T1.CountryName FROM countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.countryId  =  T2.Country;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries. Use the FROM clause to specify the countries table. Apply a WHERE clause to filter countries that do not have any car makers associated with them. 2. Condition Structure: Use the WHERE clause with a subquery to exclude countries whose CountryId appears in the car_makers table, meaning they have car makers. 3. Join Structure: Not required, as we only need to filter based on the absence of matching CountryId entries in the car_makers table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('russia',), ('nigeria',), ('australia',), ('new zealand',), ('egypt',), ('mexico',), ('brazil',)]","[('australia',), ('brazil',), ('egypt',), ('mexico',), ('new zealand',), ('nigeria',), ('russia',)]",,1.0,
What is the largest amount of horsepower for the models with 3 cylinders and what make is it?,"[cars_data.Horsepower, cars_data.Cylinders, cars_data.Id = car_names.MakeId, car_names.Model = model_list.Model, model_list.Maker = car_makers.Id, car_makers.FullName, cars_data.Cylinders = 3]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_makers.FullName FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId JOIN model_list ON car_names.Model = model_list.Model JOIN car_makers ON model_list.Maker = car_makers.Id WHERE cars_data.Cylinders = 3;","SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the maximum horsepower and the make (car_makers.FullName). Use MAX on the ""cars_data.Horsepower"" field to find the largest horsepower. 2. Condition Structure: Use a WHERE clause to filter for models with exactly 3 cylinders (""cars_data.Cylinders = 3""). 3. Join Structure: Use multiple JOINs to connect the relevant tables. First, join ""cars_data"" with ""car_names"" on ""cars_data.Id = car_names.MakeId."" Then, join ""car_names"" with ""model_list"" on ""car_names.Model = model_list.Model."" Finally, join ""model_list"" with ""car_makers"" on ""model_list.Maker = car_makers.Id"" to retrieve the make information. 4. Aggregation Structure: Use MAX to find the largest horsepower value for the filtered models.","[('97', 'Mazda')]","[('97', 'mazda rx2 coupe')]",,0.0,
Return the number of flights departing from Aberdeen.,"[flights.SourceAirport,airports.City,flights.SourceAirport = airports.AirportCode,Aberdeen]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(flights.FlightNo) FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode WHERE airports.City = 'Aberdeen';,"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport  =  T2.AirportCode WHERE T2.City  =  ""Aberdeen""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights departing from Aberdeen. Use COUNT on ""flights.FlightNo"" to get the total number of flights. 2. Condition Structure: Use a WHERE clause to filter for flights where the source airport is located in Aberdeen. This requires linking the ""flights.SourceAirport"" to the ""airports.AirportCode"" and filtering by ""airports.City = 'Aberdeen'."" 3. Join Structure: Use an INNER JOIN to connect the ""flights"" table with the ""airports"" table based on the relationship ""flights.SourceAirport = airports.AirportCode."" 4. Aggregation Structure: Use COUNT to aggregate the total number of flights departing from Aberdeen.","[(0,)]","[(0,)]",,1.0,
What are the names and ids of all makers with more than 3 models?,"[car_makers.Id, car_makers.Maker, model_list.Maker, model_list.Model, model_list.Maker = car_makers.Id]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,"SELECT car_makers.Id, car_makers.Maker FROM car_makers JOIN model_list ON model_list.Maker = car_makers.Id GROUP BY car_makers.Id, car_makers.Maker HAVING COUNT(model_list.Model) > 3;","SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names and IDs of makers. Use the FROM clause to specify the car_makers table and JOIN it with the model_list table to connect makers with their models. Use GROUP BY to group records by maker ID and name, and apply a HAVING clause to filter makers with more than 3 models. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for makers having more than 3 models. 3. Join Structure: Use an INNER JOIN between the car_makers and model_list tables based on the maker ID to link makers with their models. 4. Aggregation Structure: Use COUNT(*) within HAVING to count the number of models per maker and filter out makers with 3 or fewer models.","[(4, 'gm'), (6, 'chrysler')]","[('General Motors', 4), ('Chrysler', 6)]",,0.0,
What is the horsepower of the car with the greatest accelerate?,"[cars_data.Horsepower, cars_data.Accelerate]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT cars_data.Horsepower FROM cars_data WHERE cars_data.Accelerate = (SELECT MAX(cars_data.Accelerate) FROM cars_data);,SELECT T1.horsepower FROM CARS_DATA AS T1 ORDER BY T1.accelerate DESC LIMIT 1;,car_1,"1. Sequential Structure: Begin with the SELECT clause to specify the ""Horsepower"" of the car with the greatest ""Accelerate"". 2. Condition Structure: Use a subquery in the WHERE clause to find the maximum value of ""Accelerate"". 3. Join Structure: No JOIN is required since all necessary data is within the ""cars_data"" table. 4. Aggregation Structure: Use MAX in the subquery to determine the greatest ""Accelerate"" value.","[('71',)]","[('71',)]",,1.0,
"Which model saves the most gasoline? That is to say, have the maximum miles per gallon.","[cars_data.MPG,car_names.Model,cars_data.Id = car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT car_names.Model FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.MPG = (SELECT MAX(cars_data.MPG) FROM cars_data);,SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id ORDER BY T2.mpg DESC LIMIT 1;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""car_names.Model"" and the maximum ""cars_data.MPG"" value. Since we are looking for the model with the maximum MPG, we will use an aggregation function (MAX) on the ""cars_data.MPG"" field. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the model with the maximum MPG. 3. Join Structure: Use a JOIN between the ""cars_data"" and ""car_names"" tables based on the relationship ""cars_data.Id = car_names.MakeId"" to link each car's data with its corresponding model. 4. Aggregation Structure: Use MAX to find the maximum MPG value. To retrieve the corresponding model, use a subquery or a filtering condition to match the maximum MPG value.","[('citroen',), ('chevrolet',), ('ford',), ('plymouth',), ('amc',), ('ford',), ('volkswagen',), ('saab',)]","[('citroen',)]",,1.0,
What is the total number of airlines?,[airlines.uid],"Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT COUNT(airlines.uid) AS total_airlines FROM airlines;,SELECT count(*) FROM AIRLINES,flight_2,"1. Sequential Structure: Start with the SELECT clause to count the total number of airlines. 2. Condition Structure: No specific filtering condition is required as we want the total count of airlines. 3. Join Structure: No JOIN is necessary since all required data is in the ""airlines"" table. 4. Aggregation Structure: Use COUNT on the ""airlines.uid"" field to calculate the total number of airlines.","[(12,)]","[(12,)]",,1.0,
Which makers designed more than 3 car models? List full name and the id.,"[car_makers.FullName, car_makers.Id, model_list.Maker = car_makers.Id, model_list.Model]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT car_makers.FullName, car_makers.Id FROM car_makers JOIN model_list ON model_list.Maker = car_makers.Id GROUP BY car_makers.FullName, car_makers.Id HAVING COUNT(model_list.Model) > 3;","SELECT T1.FullName ,  T1.Id FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker GROUP BY T1.Id HAVING count(*)  >  3;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve ""car_makers.FullName"" and ""car_makers.Id."" Use a GROUP BY clause to group the results by ""car_makers.Id"" and ""car_makers.FullName."" 2. Condition Structure: Use a HAVING clause to filter for makers who designed more than 3 car models. 3. Join Structure: Use a JOIN between ""model_list"" and ""car_makers"" on ""model_list.Maker = car_makers.Id"" to associate each maker with their car models. 4. Aggregation Structure: Use COUNT on ""model_list.Model"" to count the number of car models designed by each maker, and apply the HAVING clause to filter makers with more than 3 models.","[('Chrysler', 6), ('General Motors', 4)]","[('General Motors', 4), ('Chrysler', 6)]",,1.0,
What is the number of carsw ith over 6 cylinders?,"[cars_data.Cylinders,6]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT COUNT(*) FROM cars_data WHERE cars_data.Cylinders > 6;,SELECT COUNT(*) FROM CARS_DATA WHERE Cylinders  >  6;,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of cars that have more than 6 cylinders. 2. Condition Structure: Use a WHERE clause to filter cars where ""cars_data.Cylinders"" is greater than 6. 3. Join Structure: No JOIN is required since all necessary information is in the ""cars_data"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cars meeting the specified condition.","[(108,)]","[(108,)]",,1.0,
What is the code of airport that has the highest number of flights?,"[flights.SourceAirport, flights.DestAirport, airports.AirportCode, flights.DestAirport = airports.AirportCode, flights.SourceAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT airports.AirportCode FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode OR flights.DestAirport = airports.AirportCode GROUP BY airports.AirportCode ORDER BY COUNT(*) DESC LIMIT 1;,SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1,flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the airport code. Since we are looking for the airport with the highest number of flights, we will use COUNT to count the occurrences of each airport code in both ""flights.SourceAirport"" and ""flights.DestAirport."" Use GROUP BY to group the results by airport code and ORDER BY in descending order of the count. Finally, use LIMIT 1 to get the airport with the highest number of flights. 2. Condition Structure: No specific filtering condition is required as we are considering all flights. 3. Join Structure: Use JOIN to connect the ""flights"" table with the ""airports"" table on ""flights.SourceAirport = airports.AirportCode"" and ""flights.DestAirport = airports.AirportCode"" to ensure we are working with valid airport codes. 4. Aggregation Structure: Use COUNT to calculate the total number of flights for each airport code, combining both source and destination airports.",[],[],,1.0,
What is the abbreviation of the airilne has the fewest flights and what country is it in?,"[flights.Airline,flights.FlightNo,airlines.Abbreviation,airlines.Country,flights.Airline = airlines.uid]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NESTED,"SELECT airlines.Abbreviation, airlines.Country FROM flights JOIN airlines ON flights.Airline = airlines.uid GROUP BY flights.Airline, airlines.Abbreviation, airlines.Country ORDER BY COUNT(flights.FlightNo) ASC LIMIT 1;","SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the abbreviation and country of the airline. Use the FROM clause to specify the flights and airlines tables. Use GROUP BY to group flights by airline and COUNT to calculate the number of flights for each airline. Use ORDER BY to sort the airlines by the number of flights in ascending order and LIMIT 1 to get the airline with the fewest flights. 2. Condition Structure: No specific WHERE clause is needed as we are considering all airlines and their flight counts. 3. Join Structure: Use an INNER JOIN between the flights and airlines tables on the airline's unique identifier (uid) to connect flight data with airline details. 4. Aggregation Structure: Use COUNT to calculate the number of flights for each airline and ORDER BY to sort by this count in ascending order, selecting the airline with the fewest flights.","[('UAL', 'USA')]","[('AirTran', 'USA')]",,0.0,
Which are the car makers which produce at least 2 models and more than 3 car makers ? List the id and the maker .,"[car_makers.Id, car_makers.Maker, model_list.Maker = car_makers.Id, model_list.Model]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,"SELECT car_makers.Id, car_makers.Maker FROM car_makers JOIN model_list ON model_list.Maker = car_makers.Id GROUP BY car_makers.Id, car_makers.Maker HAVING COUNT(model_list.Model) >= 2 AND (SELECT COUNT(DISTINCT car_makers.Id) FROM car_makers JOIN model_list ON model_list.Maker = car_makers.Id GROUP BY car_makers.Id HAVING COUNT(model_list.Model) >= 2) > 3;","select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker group by t1.id having count(*)  >=  2 intersect select t1.id ,  t1.maker from car_makers as t1 join model_list as t2 on t1.id  =  t2.maker join car_names as t3 on t2.model  =  t3.model group by t1.id having count(*)  >  3;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the id and maker from the car_makers table. Use the FROM clause to specify the car_makers table and JOIN it with the model_list table to link car makers with their models. Use GROUP BY to group by car maker id and name, and apply a HAVING clause to filter for car makers that produce at least 2 models. Finally, use a subquery to ensure that more than 3 car makers meet this condition. 2. Condition Structure: Use the HAVING clause to filter for car makers with at least 2 models. Use a subquery in the WHERE clause to ensure that the total number of car makers meeting this condition is greater than 3. 3. Join Structure: Use an INNER JOIN between the car_makers and model_list tables based on the maker id to connect car makers with their models. 4. Aggregation Structure: Use COUNT to count the number of models per car maker and filter using the HAVING clause. Use a subquery with COUNT to ensure that more than 3 car makers meet the condition.",[],"[(2, 'volkswagen'), (4, 'gm'), (5, 'ford'), (6, 'chrysler'), (8, 'nissan'), (19, 'toyota')]",,0.0,
Find all airlines that have at least 10 flights.,"[flights.Airline,flights.FlightNo]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT flights.Airline FROM flights GROUP BY flights.Airline HAVING COUNT(flights.FlightNo) >= 10;,SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  >  10,flight_2,"1. Sequential Structure: Begin with the SELECT clause to specify the airline names, as the question asks for airlines with at least 10 flights. 2. Aggregation Structure: Use COUNT to calculate the number of flights for each airline. 3. Grouping Structure: Use GROUP BY on ""flights.Airline"" to count the flights for each airline. 4. Condition Structure: Apply the HAVING clause to filter airlines with a flight count of at least 10. 5. Join Structure: No JOIN is required since all necessary data is within the ""flights"" table.","[(1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,), (10,), (11,), (12,)]","[('AirTran Airways',), ('Allegiant Air',), ('American Airlines',), ('Continental Airlines',), ('Delta Airlines',), ('Frontier Airlines',), ('JetBlue Airways',), ('Northwest Airlines',), ('Southwest Airlines',), ('US Airways',), ('United Airlines',), ('Virgin America',)]",,0.0,
Which airlines have less than 200 flights?,"[flights.Airline,flights.FlightNo]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT flights.Airline FROM flights GROUP BY flights.Airline HAVING COUNT(flights.FlightNo) < 200;,SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200,flight_2,"1. Sequential Structure: Begin with the SELECT clause to specify the airline names, as the question asks for airlines with less than 200 flights. 2. Aggregation Structure: Use COUNT to calculate the number of flights for each airline. 3. Grouping Structure: Use GROUP BY on ""flights.Airline"" to count the flights for each airline. 4. Condition Structure: Apply the HAVING clause to filter airlines with a flight count of less than 200. 5. Join Structure: No JOIN is required since all necessary data is within the ""flights"" table.","[(1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,), (10,), (11,), (12,)]","[('AirTran Airways',), ('Allegiant Air',), ('American Airlines',), ('Continental Airlines',), ('Delta Airlines',), ('Frontier Airlines',), ('JetBlue Airways',), ('Northwest Airlines',), ('Southwest Airlines',), ('US Airways',), ('United Airlines',), ('Virgin America',)]",,0.0,
How many flights depart from City Aberdeen?,"[airports.City, flights.SourceAirport, flights.SourceAirport = airports.AirportCode, Aberdeen]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(flights.FlightNo) FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode WHERE airports.City = 'Aberdeen';,"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport  =  T2.AirportCode WHERE T2.City  =  ""Aberdeen""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights departing from the specified city. Use COUNT on ""flights.FlightNo"" to get the total number of flights. 2. Condition Structure: Use a WHERE clause to filter for flights where the source airport is located in the city ""Aberdeen."" 3. Join Structure: Use an INNER JOIN between the ""flights"" table and the ""airports"" table on the condition ""flights.SourceAirport = airports.AirportCode"" to link flights with their source airport details. 4. Aggregation Structure: Use COUNT to aggregate the total number of flights departing from the specified city.","[(0,)]","[(0,)]",,1.0,
Which countries in europe have at least 3 car manufacturers?,"[countries.CountryName,continents.Continent,countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,car_makers.Id]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT countries.CountryName FROM countries JOIN continents ON countries.Continent = continents.ContId JOIN car_makers ON car_makers.Country = countries.CountryId WHERE continents.Continent = 'Europe' GROUP BY countries.CountryName HAVING COUNT(car_makers.Id) >= 3;,SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries in Europe. Use a GROUP BY clause to group the results by country. Apply a HAVING clause to filter for countries with at least 3 car manufacturers. 2. Condition Structure: Use a WHERE clause to filter for countries located in Europe. This requires joining the ""countries"" table with the ""continents"" table to identify countries in Europe. 3. Join Structure: Use a JOIN between the ""countries"" and ""continents"" tables based on ""countries.Continent = continents.ContId"" to filter for European countries. Additionally, join the ""car_makers"" table with the ""countries"" table based on ""car_makers.Country = countries.CountryId"" to count the car manufacturers for each country. 4. Aggregation Structure: Use COUNT on ""car_makers.Id"" to count the number of car manufacturers for each country. Apply the HAVING clause to filter for countries with at least 3 manufacturers.",[],"[('france',), ('germany',)]",,0.0,
Which city has the most frequent destination airport?,"[flights.DestAirport,airports.City,flights.DestAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,"SELECT airports.City, COUNT(flights.DestAirport) AS frequency FROM flights JOIN airports ON flights.DestAirport = airports.AirportCode GROUP BY airports.City ORDER BY frequency DESC LIMIT 1;",SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1,flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airports.City"" and the count of destination airports. Use COUNT to calculate the frequency of each city as a destination. 2. Condition Structure: No specific filtering condition is required since we are analyzing all destination airports. 3. Join Structure: Use an INNER JOIN between the ""flights"" table and the ""airports"" table on the condition ""flights.DestAirport = airports.AirportCode"" to link flights with their destination airport details. 4. Aggregation Structure: Use COUNT to count the occurrences of each city as a destination. Use GROUP BY to group the results by ""airports.City"" and ORDER BY in descending order of the count to find the city with the most frequent destination airport. Use LIMIT 1 to get the top result.",[],[],,1.0,
What is the average horsepower for all cars produced before 1980 ?,"[cars_data.Horsepower, cars_data.Year]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT AVG(cars_data.Horsepower) AS avg_horsepower FROM cars_data WHERE cars_data.Year < 1980;,select avg(horsepower) from cars_data where year  <  1980;,car_1,"1. Sequential Structure: Start with the SELECT clause to calculate the average horsepower for cars produced before 1980. 2. Condition Structure: Use a WHERE clause to filter cars where the ""cars_data.Year"" is less than 1980. 3. Join Structure: No JOIN is required since all necessary information is in the ""cars_data"" table. 4. Aggregation Structure: Use the AVG function to calculate the average horsepower for the filtered cars.","[(111.13291139240506,)]","[(111.13291139240506,)]",,1.0,
Which airline has most number of flights?,[flights.Airline],"Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT flights.Airline FROM flights GROUP BY flights.Airline ORDER BY COUNT(*) DESC LIMIT 1;,SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) DESC LIMIT 1,flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the airline name, as the question asks for the airline with the most flights. 2. Aggregation Structure: Use COUNT to calculate the number of flights for each airline. 3. Grouping Structure: Use GROUP BY on ""flights.Airline"" to count the flights for each airline. 4. Ordering Structure: Use ORDER BY in descending order on the flight count to rank airlines by the number of flights. 5. Limiting Structure: Use LIMIT 1 to retrieve the airline with the most flights. 6. Join Structure: No JOIN is required since all necessary data is within the ""flights"" table.","[(1,)]","[('Virgin America',)]",,0.0,
"In 1980, how many cars were made?","[cars_data.Year, cars_data.Id]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT COUNT(cars_data.Id) FROM cars_data WHERE cars_data.Year = 1980;,SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980;,car_1,"1. Sequential Structure: Begin with the SELECT clause to count the number of cars made in 1980. Use COUNT on the ""cars_data.Id"" field to determine the total number of cars. 2. Condition Structure: Use a WHERE clause to filter records where ""cars_data.Year"" is 1980. 3. Join Structure: No JOIN is required since all necessary data is within the ""cars_data"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cars made in the specified year.","[(29,)]","[(29,)]",,1.0,
What is the maximum horsepower and the make of the car models with 3 cylinders?,"[cars_data.Horsepower, cars_data.Cylinders, car_names.Make, cars_data.Id = car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT MAX(cars_data.Horsepower) AS MaxHorsepower, car_names.Make FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Cylinders = 3;","SELECT T2.horsepower ,  T1.Make FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.cylinders  =  3 ORDER BY T2.horsepower DESC LIMIT 1;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the maximum horsepower and the make of the car models. Use the MAX function on ""cars_data.Horsepower"" to find the maximum horsepower. 2. Condition Structure: Use a WHERE clause to filter for car models with exactly 3 cylinders by checking ""cars_data.Cylinders = 3."" 3. Join Structure: Use a JOIN between the ""cars_data"" and ""car_names"" tables based on the foreign key relationship ""cars_data.Id = car_names.MakeId"" to link car data with their respective makes. 4. Aggregation Structure: Use the MAX function to find the maximum horsepower among the filtered car models.","[('97', 'mazda rx2 coupe')]","[('97', 'mazda rx2 coupe')]",,1.0,
How many cars have more than 4 cylinders?,[cars_data.Cylinders],"Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT COUNT(*) FROM cars_data WHERE cars_data.Cylinders > 4;,SELECT count(*) FROM CARS_DATA WHERE Cylinders  >  4;,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of cars that have more than 4 cylinders. 2. Condition Structure: Use a WHERE clause to filter cars where ""cars_data.Cylinders"" is greater than 4. 3. Join Structure: No JOIN is required since all necessary information is in the ""cars_data"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cars meeting the specified condition.","[(195,)]","[(195,)]",,1.0,
Give the airport code and airport name corresonding to the city Anthony.,"[airports.City, airports.AirportCode, airports.AirportName, Anthony]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,"SELECT airports.AirportCode, airports.AirportName FROM airports WHERE airports.City = 'Anthony';","SELECT AirportCode ,  AirportName FROM AIRPORTS WHERE city  =  ""Anthony""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airports.AirportCode"" and ""airports.AirportName"" corresponding to the city ""Anthony"". 2. Condition Structure: Use a WHERE clause to filter for records where ""airports.City"" is equal to ""Anthony"". 3. Join Structure: No JOIN is required since all necessary information is available in the ""airports"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",[],[],,1.0,
What is the maximum mpg of the cars that had 8 cylinders or that were produced before 1980 ?,"[cars_data.MPG, cars_data.Cylinders, cars_data.Year]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT MAX(cars_data.MPG) AS max_mpg FROM cars_data WHERE cars_data.Cylinders = 8 OR cars_data.Year < 1980;,select max(mpg) from cars_data where cylinders  =  8 or year  <  1980,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the maximum MPG value of cars that meet the specified conditions. 2. Condition Structure: Use a WHERE clause to filter cars that either have 8 cylinders or were produced before 1980. 3. Join Structure: No JOIN is required since all necessary information is available in the ""cars_data"" table. 4. Aggregation Structure: Use the MAX function to calculate the maximum MPG value for the filtered cars.","[('null',)]","[('null',)]",,1.0,
What is the average edispl of the cars of model volvo?,"[cars_data.Edispl,car_names.Model,car_names.MakeId = cars_data.Id,model_list.Model = car_names.Model,model_list.Maker,car_makers.Id = model_list.Maker,car_makers.FullName,volvo]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT AVG(cars_data.Edispl) FROM car_makers JOIN model_list ON car_makers.Id = model_list.Maker JOIN car_names ON model_list.Model = car_names.Model JOIN cars_data ON car_names.MakeId = cars_data.Id WHERE car_makers.FullName = 'volvo';,SELECT avg(T2.edispl) FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T1.Model  =  'volvo';,car_1,"1. Sequential Structure: Start with the SELECT clause to calculate the average ""cars_data.Edispl"" for the cars of the specified model. Use the AVG function for this purpose. 2. Condition Structure: Use a WHERE clause to filter for cars of the model ""volvo."" This requires joining multiple tables to trace the relationship from ""car_makers.FullName"" to ""cars_data.Edispl."" 3. Join Structure: Use JOINs to connect the relevant tables. Start by linking ""car_makers"" with ""model_list"" on ""car_makers.Id = model_list.Maker,"" then link ""model_list"" with ""car_names"" on ""model_list.Model = car_names.Model,"" and finally link ""car_names"" with ""cars_data"" on ""car_names.MakeId = cars_data.Id."" 4. Aggregation Structure: Use the AVG function to compute the average ""Edispl"" for the filtered records.","[(None,)]","[(133.5,)]",,0.0,
How many cars have a larger accelerate than the car with the largest horsepower?,"[cars_data.Accelerate, cars_data.Horsepower]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT COUNT(*) FROM cars_data WHERE Accelerate > (SELECT Accelerate FROM cars_data WHERE Horsepower = (SELECT MAX(Horsepower) FROM cars_data));,SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of cars. Use the FROM clause to specify the cars_data table. Apply a WHERE clause to filter cars with an acceleration value greater than the acceleration of the car with the largest horsepower. 2. Condition Structure: Use the WHERE clause with a subquery to find the acceleration of the car with the largest horsepower. The subquery calculates the maximum horsepower and retrieves the corresponding acceleration value. 3. Join Structure: Not required, as all data is in the cars_data table. 4. Aggregation Structure: Use COUNT to count the number of cars that satisfy the condition.","[(39,)]","[(39,)]",,1.0,
How many flights land in Aberdeen or Abilene?,"[flights.DestAirport,airports.AirportCode,airports.City,flights.DestAirport = airports.AirportCode,Aberdeen,Abilene]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(flights.FlightNo) FROM flights JOIN airports ON flights.DestAirport = airports.AirportCode WHERE airports.City = 'Aberdeen' OR airports.City = 'Abilene';,"SELECT count(*) FROM Flights AS T1 JOIN Airports AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.city  =  ""Aberdeen"" OR T2.city  =  ""Abilene""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights landing in the specified cities. Use COUNT on ""flights.FlightNo"" to get the total number of flights. 2. Condition Structure: Use a WHERE clause to filter for flights where the destination airport's city is either ""Aberdeen"" or ""Abilene."" 3. Join Structure: Use an INNER JOIN between the ""flights"" table and the ""airports"" table on ""flights.DestAirport = airports.AirportCode"" to associate each flight with its destination airport's details. 4. Aggregation Structure: Use COUNT to aggregate the total number of flights meeting the specified condition.","[(0,)]","[(0,)]",,1.0,
Which city is the most frequent source airport?,"[flights.SourceAirport, airports.City, flights.SourceAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,"SELECT airports.City, COUNT(flights.SourceAirport) AS frequency FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode GROUP BY airports.City ORDER BY frequency DESC LIMIT 1;",SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.SourceAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1,flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airports.City"" and the count of occurrences for each city. Use COUNT to count the number of times each city appears as a source airport. 2. Condition Structure: No specific filtering condition is required since we are analyzing all source airports. 3. Join Structure: Use an INNER JOIN between the ""flights"" table and the ""airports"" table on ""flights.SourceAirport = airports.AirportCode"" to link each flight with its source airport's city. 4. Aggregation Structure: Use GROUP BY on ""airports.City"" to group the results by city. Use ORDER BY in descending order of the count to rank cities by frequency, and LIMIT 1 to get the most frequent source airport city.",[],[],,1.0,
How many airlines are from USA?,"[airlines.Country,airlines.Airline,USA]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT COUNT(airlines.Airline) FROM airlines WHERE airlines.Country = 'USA';,"SELECT count(*) FROM AIRLINES WHERE Country  =  ""USA""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of airlines from the USA. 2. Condition Structure: Use a WHERE clause to filter airlines where the ""airlines.Country"" is 'USA'. 3. Join Structure: No JOIN is required since all necessary information is in the ""airlines"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of airlines that meet the specified condition.","[(12,)]","[(12,)]",,1.0,
Find all airlines that have flights from airport 'CVO' but not from 'APG'.,"[flights.Airline, flights.SourceAirport, flights.SourceAirport = airports.AirportCode, flights.DestAirport = airports.AirportCode, airports.AirportCode, CVO, APG]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NESTED,SELECT DISTINCT Airline FROM flights WHERE SourceAirport = 'CVO' AND Airline NOT IN ( SELECT Airline FROM flights WHERE SourceAirport = 'APG' );,"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  ""CVO"" EXCEPT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  ""APG""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct airlines. Use the FROM clause to specify the flights table. Apply a WHERE clause to filter airlines that have flights from the airport with code 'CVO'. Use a subquery in the WHERE clause to exclude airlines that have flights from the airport with code 'APG'. 2. Condition Structure: Use the WHERE clause to filter for flights where the SourceAirport is 'CVO'. Use a subquery to exclude airlines where the SourceAirport is 'APG'. 3. Join Structure: Not required, as all necessary data is available in the flights table. 4. Aggregation Structure: Not needed, as we are retrieving distinct airlines without any aggregation.",[],[],,1.0,
What are the names of the countries with no car makers?,"[countries.CountryName,car_makers.Country,countries.CountryId = car_makers.Country]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT countries.CountryName FROM countries WHERE countries.CountryId NOT IN (SELECT car_makers.Country FROM car_makers);,SELECT CountryName FROM countries EXCEPT SELECT T1.CountryName FROM countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.countryId  =  T2.Country;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries. Use the FROM clause to specify the countries table. Apply a WHERE clause to filter for countries that do not have any car makers associated with them. 2. Condition Structure: Use the WHERE clause with a subquery to exclude countries whose CountryId appears in the car_makers table, meaning they have car makers. 3. Join Structure: Not required, as we only need to filter based on the absence of matching CountryId entries in the car_makers table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('russia',), ('nigeria',), ('australia',), ('new zealand',), ('egypt',), ('mexico',), ('brazil',)]","[('australia',), ('brazil',), ('egypt',), ('mexico',), ('new zealand',), ('nigeria',), ('russia',)]",,1.0,
What are the different years in which there were cars produced that weighed less than 4000 and also cars that weighted more than 3000 ?,"[cars_data.Year, cars_data.Weight, 4000, 3000]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT DISTINCT Year FROM cars_data WHERE Weight < 4000 AND Weight > 3000;,select distinct year from cars_data where weight between 3000 and 4000;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct years from the cars_data table. Use the FROM clause to specify the cars_data table. Apply a WHERE clause to filter for cars that weighed less than 4000 and also cars that weighed more than 3000. 2. Condition Structure: Use the WHERE clause with conditions to filter for cars with weight less than 4000 and weight greater than 3000. Use the DISTINCT keyword to ensure unique years are retrieved. 3. Join Structure: Not required, as all data is available within the cars_data table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.","[(1970,), (1971,), (1972,), (1973,), (1974,), (1975,), (1976,), (1977,), (1978,), (1979,), (1980,), (1981,), (1982,)]","[(1970,), (1971,), (1972,), (1973,), (1974,), (1975,), (1976,), (1977,), (1978,), (1979,), (1980,), (1981,), (1982,)]",,1.0,
Find all airlines that have flights from both airports 'APG' and 'CVO'.,"[flights.Airline,flights.SourceAirport,flights.DestAirport,airports.AirportCode,flights.SourceAirport = airports.AirportCode,flights.DestAirport = airports.AirportCode,APG,CVO]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NESTED,"SELECT Airline FROM flights WHERE SourceAirport IN ('APG', 'CVO') GROUP BY Airline HAVING COUNT(DISTINCT SourceAirport) = 2;","SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  ""APG"" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  ""CVO""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the airline names. Use the FROM clause to specify the flights table. Apply a WHERE clause to filter airlines that have flights from both 'APG' and 'CVO' airports. Use a GROUP BY clause to group by airline and a HAVING clause to ensure that both conditions are satisfied. 2. Condition Structure: Use the WHERE clause to filter flights where the source airport is either 'APG' or 'CVO'. Use the HAVING clause to ensure that both airports are present for the same airline. 3. Join Structure: Not required, as all necessary data is available in the flights table. 4. Aggregation Structure: Use COUNT with HAVING to ensure that both 'APG' and 'CVO' are present for the same airline.",[],[],,1.0,
Which distinctive models are produced by maker with the full name General Motors or weighing more than 3500?,"[model_list.Model,car_makers.FullName,car_makers.Id = model_list.Maker,car_names.Model = model_list.Model,cars_data.Weight,car_names.MakeId = cars_data.Id,General Motors,3500]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT DISTINCT model_list.Model FROM car_makers JOIN model_list ON car_makers.Id = model_list.Maker JOIN car_names ON car_names.Model = model_list.Model JOIN cars_data ON car_names.MakeId = cars_data.Id WHERE car_makers.FullName = 'General Motors' OR cars_data.Weight > 3500;,SELECT DISTINCT T2.Model FROM CAR_NAMES AS T1 JOIN MODEL_LIST AS T2 ON T1.Model  =  T2.Model JOIN CAR_MAKERS AS T3 ON T2.Maker  =  T3.Id JOIN CARS_DATA AS T4 ON T1.MakeId  =  T4.Id WHERE T3.FullName  =  'General Motors' OR T4.weight  >  3500;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct ""model_list.Model"" as the question asks for distinctive models. 2. Condition Structure: Use a WHERE clause to filter for models produced by a maker with the full name ""General Motors"" or cars weighing more than 3500. 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""car_makers"" with ""model_list"" on ""car_makers.Id = model_list.Maker"" to link makers with their models. Then, join ""car_names"" with ""model_list"" on ""car_names.Model = model_list.Model"" to associate models with car names. Finally, join ""cars_data"" with ""car_names"" on ""car_names.MakeId = cars_data.Id"" to access the weight of the cars. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique models are returned.","[('chevrolet',), ('buick',), ('ford',), ('plymouth',), ('pontiac',), ('amc',), ('dodge',), ('mercury',), ('oldsmobile',), ('chrysler',), ('mercedes-benz',), ('cadillac',), ('mercedes',)]","[('chevrolet',), ('buick',), ('ford',), ('plymouth',), ('pontiac',), ('amc',), ('dodge',), ('mercury',), ('oldsmobile',), ('chrysler',), ('mercedes-benz',), ('cadillac',), ('mercedes',)]",,1.0,
"What is the abbreviation of Airline ""JetBlue Airways""?","[airlines.Airline, airlines.Abbreviation]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT airlines.Abbreviation FROM airlines WHERE airlines.Airline = 'JetBlue Airways';,"SELECT Abbreviation FROM AIRLINES WHERE Airline  =  ""JetBlue Airways""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airlines.Abbreviation"" for the airline ""JetBlue Airways"". 2. Condition Structure: Use a WHERE clause to filter for the airline name ""JetBlue Airways"". 3. Join Structure: No JOIN is required since all necessary information is in the ""airlines"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('JetBlue',)]","[('JetBlue',)]",,1.0,
Count the number of United Airlines flights that arrive in Aberdeen.,"[flights.Airline,flights.DestAirport,airports.AirportCode,airports.City,flights.DestAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(*) FROM flights JOIN airports ON flights.DestAirport = airports.AirportCode WHERE flights.Airline = 'United Airlines' AND airports.City = 'Aberdeen';,"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRLINES AS T3 ON T3.uid  =  T1.Airline WHERE T2.City  =  ""Aberdeen"" AND T3.Airline  =  ""United Airlines""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights. Use COUNT to aggregate the number of flights. 2. Condition Structure: Use a WHERE clause to filter for flights where the airline is ""United Airlines"" and the destination city is ""Aberdeen."" 3. Join Structure: Use an INNER JOIN to connect the ""flights"" table with the ""airports"" table on the ""DestAirport"" and ""AirportCode"" fields to access the city information for the destination airport. 4. Aggregation Structure: Use COUNT to count the number of flights that meet the specified conditions.","[(0,)]","[(0,)]",,1.0,
Find the abbreviation and country of the airline that has fewest number of flights?,"[airlines.Abbreviation, airlines.Country, flights.Airline]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NESTED,"SELECT airlines.Abbreviation, airlines.Country FROM airlines JOIN flights ON airlines.Airline = flights.Airline GROUP BY airlines.Abbreviation, airlines.Country ORDER BY COUNT(flights.FlightNo) ASC LIMIT 1;","SELECT T1.Abbreviation ,  T1.Country FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline ORDER BY count(*) LIMIT 1",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the abbreviation and country of the airline. Use the FROM clause to specify the airlines table and JOIN it with the flights table to connect airlines with their flights. Use GROUP BY to group flights by airline and COUNT to calculate the number of flights for each airline. Apply ORDER BY to sort the airlines by the number of flights in ascending order and LIMIT to select the airline with the fewest flights. 2. Condition Structure: No specific WHERE clause is needed, as we are interested in all airlines and their flight counts. 3. Join Structure: Use an INNER JOIN between the airlines and flights tables based on the Airline field to connect airlines with their flights. 4. Aggregation Structure: Use COUNT to calculate the number of flights for each airline and ORDER BY to sort by this count in ascending order. Use LIMIT 1 to select the airline with the fewest flights.",[],"[('AirTran', 'USA')]",,0.0,
Give the flight numbers of flights leaving from Aberdeen.,"[flights.FlightNo,flights.SourceAirport,airports.City,flights.SourceAirport = airports.AirportCode,Aberdeen]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT flights.FlightNo FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode WHERE airports.City = 'Aberdeen';,"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.SourceAirport   =  T2.AirportCode WHERE T2.City  =  ""Aberdeen""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""flights.FlightNo"" field, as the question asks for flight numbers. 2. Condition Structure: Use a WHERE clause to filter for flights where the source airport is located in the city of ""Aberdeen."" 3. Join Structure: Use an INNER JOIN between the ""flights"" table and the ""airports"" table on the condition ""flights.SourceAirport = airports.AirportCode"" to link flights with their source airport details. 4. Aggregation Structure: No aggregation is needed since the query only retrieves flight numbers without any summarization.",[],[],,1.0,
In which years cars were produced weighing no less than 3000 and no more than 4000 ?,"[cars_data.Year, cars_data.Weight, 3000, 4000]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT DISTINCT cars_data.Year FROM cars_data WHERE cars_data.Weight BETWEEN 3000 AND 4000;,select distinct year from cars_data where weight between 3000 and 4000;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct years in which cars were produced. 2. Condition Structure: Use a WHERE clause to filter cars with weights between 3000 and 4000 inclusive. 3. Join Structure: No JOIN is required since all necessary information is in the ""cars_data"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct years that meet the specified weight condition.","[(1970,), (1971,), (1972,), (1973,), (1974,), (1975,), (1976,), (1977,), (1978,), (1979,), (1980,), (1981,), (1982,)]","[(1970,), (1971,), (1972,), (1973,), (1974,), (1975,), (1976,), (1977,), (1978,), (1979,), (1980,), (1981,), (1982,)]",,1.0,
Return the number of airlines in the USA.,"[airlines.Country,airlines.uid]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT COUNT(airlines.uid) FROM airlines WHERE airlines.Country = 'USA';,"SELECT count(*) FROM AIRLINES WHERE Country  =  ""USA""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of airlines in the USA. 2. Condition Structure: Use a WHERE clause to filter airlines where the ""airlines.Country"" is 'USA'. 3. Join Structure: No JOIN is required since all necessary information is in the ""airlines"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of airlines that meet the specified condition.","[(12,)]","[(12,)]",,1.0,
Which models are lighter than 3500 but not built by the 'Ford Motor Company'?,"[cars_data.Weight,car_names.Model,car_makers.FullName,car_names.Make = cars_data.Id,car_names.Model = model_list.Model,model_list.Maker = car_makers.Id,3500,'Ford Motor Company']","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT car_names.Model FROM cars_data JOIN car_names ON car_names.Make = cars_data.Id JOIN model_list ON car_names.Model = model_list.Model JOIN car_makers ON model_list.Maker = car_makers.Id WHERE cars_data.Weight < 3500 AND car_makers.FullName != 'Ford Motor Company';,SELECT DISTINCT T1.model FROM MODEL_LIST AS T1 JOIN CAR_NAMES AS T2 ON T1.Model  =  T2.Model JOIN CARS_DATA AS T3 ON T2.MakeId  =  T3.Id JOIN CAR_MAKERS AS T4 ON T1.Maker  =  T4.Id WHERE T3.weight  <  3500 AND T4.FullName != 'Ford Motor Company';,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the model names. Use the FROM clause to specify the cars_data and car_names tables, and join them with the model_list and car_makers tables to connect the weight and maker details. Apply a WHERE clause to filter models with weight less than 3500 and exclude those built by 'Ford Motor Company'. 2. Condition Structure: Use the WHERE clause to filter for cars with weight less than 3500 and exclude those where the maker's FullName is 'Ford Motor Company'. 3. Join Structure: Use JOINs between cars_data, car_names, model_list, and car_makers tables based on the relationships: car_names.Make = cars_data.Id, car_names.Model = model_list.Model, and model_list.Maker = car_makers.Id. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",[],"[('plymouth',), ('amc',), ('citroen',), ('buick',), ('toyota',), ('datsun',), ('volkswagen',), ('peugeot',), ('audi',), ('saab',), ('bmw',), ('chevrolet',), ('pontiac',), ('opel',), ('fiat',), ('dodge',), ('mazda',), ('volvo',), ('renault',), ('honda',), ('subaru',), ('oldsmobile',), ('mercedes-benz',), ('triumph',), ('chrysler',), ('nissan',)]",,0.0,
What are the ids and names of all countries that either have more than 3 car makers or produce fiat model ?,"[countries.CountryId, countries.CountryName, car_makers.Country = countries.CountryId, car_makers.Id, model_list.Maker = car_makers.Id, model_list.Model, car_names.Model = model_list.Model, car_names.Make, car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,"SELECT countries.CountryId, countries.CountryName FROM countries WHERE countries.CountryId IN ( SELECT car_makers.Country FROM car_makers GROUP BY car_makers.Country HAVING COUNT(car_makers.Id) > 3 ) OR countries.CountryId IN ( SELECT car_makers.Country FROM car_makers JOIN model_list ON model_list.Maker = car_makers.Id JOIN car_names ON car_names.Model = model_list.Model WHERE car_names.Make = 'Fiat' );","select t1.countryid ,  t1.countryname from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  3 union select t1.countryid ,  t1.countryname from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country join model_list as t3 on t2.id  =  t3.maker where t3.model  =  'fiat';",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the CountryId and CountryName from the countries table. Use the FROM clause to specify the countries table. Apply a WHERE clause to filter countries that either have more than 3 car makers or produce a Fiat model. 2. Condition Structure: Use the WHERE clause with two conditions combined using OR. The first condition checks for countries with more than 3 car makers using a subquery that counts the number of car makers per country. The second condition checks for countries that produce a Fiat model by joining the relevant tables to trace the relationship between countries and the Fiat model. 3. Join Structure: Use JOINs to connect the countries table with car_makers, model_list, and car_names tables to identify countries producing the Fiat model. The relationship is established through the foreign keys. 4. Aggregation Structure: Use COUNT in a subquery to count the number of car makers per country and filter those with more than 3 car makers.","[(1, 'usa'), (2, 'germany'), (4, 'japan')]","[(1, 'usa'), (2, 'germany'), (4, 'japan'), (5, 'italy')]",,0.0,
What are the id and names of the countries which have more than 3 car makers or produce the 'fiat' model?,"[countries.CountryId, countries.CountryName, car_makers.Country = countries.CountryId, car_makers.Id, car_makers.Maker, model_list.Maker = car_makers.Id, model_list.Model, car_names.Model = model_list.Model, car_names.Make, fiat]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,"SELECT countries.CountryId, countries.CountryName FROM countries JOIN car_makers ON car_makers.Country = countries.CountryId LEFT JOIN model_list ON model_list.Maker = car_makers.Id LEFT JOIN car_names ON car_names.Model = model_list.Model GROUP BY countries.CountryId, countries.CountryName HAVING COUNT(car_makers.Id) > 3 OR SUM(CASE WHEN car_names.Make = 'fiat' THEN 1 ELSE 0 END) > 0;","SELECT T1.countryId ,  T1.CountryName FROM Countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country GROUP BY T1.countryId HAVING count(*)  >  3 UNION SELECT T1.countryId ,  T1.CountryName FROM Countries AS T1 JOIN CAR_MAKERS AS T2 ON T1.CountryId  =  T2.Country JOIN MODEL_LIST AS T3 ON T2.Id  =  T3.Maker WHERE T3.Model  =  'fiat';",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the CountryId and CountryName. Use the FROM clause to specify the countries table. Join it with the car_makers table to link countries with car makers. Further, join the car_makers table with the model_list and car_names tables to identify countries producing the 'fiat' model. Use a GROUP BY clause to group by CountryId and CountryName, and apply a HAVING clause to filter countries with more than 3 car makers or those producing the 'fiat' model. 2. Condition Structure: Use the HAVING clause to filter countries with more than 3 car makers. Additionally, use a WHERE clause to check if the 'fiat' model is produced by the country. 3. Join Structure: Use INNER JOINs to connect countries with car_makers, car_makers with model_list, and model_list with car_names to establish relationships between countries, car makers, and car models. 4. Aggregation Structure: Use COUNT(*) to count the number of car makers per country and filter those with more than 3 car makers.","[(1, 'usa'), (2, 'germany'), (3, 'france'), (4, 'japan'), (5, 'italy'), (6, 'sweden')]","[(1, 'usa'), (2, 'germany'), (4, 'japan'), (5, 'italy')]",,1.0,
List the airport code and name in the city of Anthony.,"[airports.City, airports.AirportCode, airports.AirportName, Anthony]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,"SELECT airports.AirportCode, airports.AirportName FROM airports WHERE airports.City = 'Anthony';","SELECT AirportCode ,  AirportName FROM AIRPORTS WHERE city  =  ""Anthony""",flight_2,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the airport code and airport name. 2. Condition Structure: Use a WHERE clause to filter for airports located in the city of ""Anthony"". 3. Join Structure: No JOIN is required since all necessary information is available in the ""airports"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the airport code and name for a specific city.",[],[],,1.0,
How many airlines do we have?,"[airlines.uid, airlines.Airline]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT COUNT(airlines.uid) AS total_airlines FROM airlines;,SELECT count(*) FROM AIRLINES,flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of airlines. 2. Condition Structure: No specific filtering condition is required as we want the total count of airlines. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""airlines"" table. 4. Aggregation Structure: Use COUNT on ""airlines.uid"" to calculate the total number of airlines.","[(12,)]","[(12,)]",,1.0,
What is the number of car models created by the car maker American Motor Company?,"[car_makers.Id,car_makers.FullName,model_list.Maker = car_makers.Id,model_list.Model,car_makers.FullName = 'American Motor Company']","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT COUNT(model_list.Model) FROM car_makers JOIN model_list ON model_list.Maker = car_makers.Id WHERE car_makers.FullName = 'American Motor Company';,SELECT count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker WHERE T1.FullName  =  'American Motor Company';,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of car models. Use COUNT on ""model_list.Model"" to get the total number of models created by the specified car maker. 2. Condition Structure: Use a WHERE clause to filter for the car maker whose ""car_makers.FullName"" is 'American Motor Company.' 3. Join Structure: Use an INNER JOIN between ""car_makers"" and ""model_list"" on ""model_list.Maker = car_makers.Id"" to associate car makers with their respective models. 4. Aggregation Structure: Use COUNT to aggregate the total number of models for the specified car maker.","[(1,)]","[(1,)]",,1.0,
Which abbreviation corresponds to Jetblue Airways?,"[airlines.Airline, airlines.Abbreviation, airlines.Airline = 'Jetblue Airways']","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT airlines.Abbreviation FROM airlines WHERE airlines.Airline = 'Jetblue Airways';,"SELECT Abbreviation FROM AIRLINES WHERE Airline  =  ""JetBlue Airways""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airlines.Abbreviation"" corresponding to the airline ""Jetblue Airways"". 2. Condition Structure: Use a WHERE clause to filter for the airline name ""Jetblue Airways"". 3. Join Structure: No JOIN is required since all necessary information is in the ""airlines"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",[],"[('JetBlue',)]",,0.0,
How many car models were produced by the maker with full name American Motor Company?,"[car_makers.FullName, model_list.Maker, car_makers.Id = model_list.Maker]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT COUNT(model_list.Model) FROM car_makers JOIN model_list ON car_makers.Id = model_list.Maker WHERE car_makers.FullName = 'American Motor Company';,SELECT count(*) FROM CAR_MAKERS AS T1 JOIN MODEL_LIST AS T2 ON T1.Id  =  T2.Maker WHERE T1.FullName  =  'American Motor Company';,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of car models. Use COUNT on the ""model_list.Model"" field to get the total number of models. 2. Condition Structure: Use a WHERE clause to filter for the maker with the full name ""American Motor Company."" 3. Join Structure: Use a JOIN between the ""car_makers"" table and the ""model_list"" table based on the relationship ""car_makers.Id = model_list.Maker"" to link each maker with its models. 4. Aggregation Structure: Use COUNT to aggregate the total number of models for the specified maker.","[(1,)]","[(1,)]",,1.0,
What is the number of cars with more than 4 cylinders?,"[cars_data.Cylinders,4]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT COUNT(*) FROM cars_data WHERE cars_data.Cylinders > 4;,SELECT count(*) FROM CARS_DATA WHERE Cylinders  >  4;,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of cars that meet the condition. 2. Condition Structure: Use a WHERE clause to filter cars where ""cars_data.Cylinders"" is greater than 4. 3. Join Structure: No JOIN is required since all necessary information is in the ""cars_data"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cars that satisfy the condition.","[(195,)]","[(195,)]",,1.0,
"Among the cars with more than lowest horsepower, which ones do not have more than 3 cylinders? List the car makeid and make name.","[cars_data.Horsepower, cars_data.Cylinders, cars_data.Id = car_names.MakeId, car_names.MakeId, car_names.Make]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,"SELECT car_names.MakeId, car_names.Make FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Horsepower > (SELECT MIN(Horsepower) FROM cars_data) AND cars_data.Cylinders <= 3;","SELECT T2.MakeId ,  T2.Make FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T1.Horsepower  >  (SELECT min(Horsepower) FROM CARS_DATA) AND T1.Cylinders  <=  3;",car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the car MakeId and Make name. Use the FROM clause to specify the cars_data and car_names tables. Apply a WHERE clause to filter cars with horsepower greater than the lowest horsepower and cylinders not exceeding 3. 2. Condition Structure: Use the WHERE clause to filter cars with horsepower greater than the minimum horsepower (using a subquery to calculate the minimum horsepower) and cylinders less than or equal to 3. 3. Join Structure: Use an INNER JOIN between cars_data and car_names tables based on the relationship cars_data.Id = car_names.MakeId to connect car details with their make information. 4. Aggregation Structure: Use MIN in a subquery to calculate the lowest horsepower, which is then used in the filtering condition.","[(79, 'mazda rx2 coupe'), (119, 'mazda rx3'), (251, 'mazda rx-4')]","[(79, 'mazda rx2 coupe'), (119, 'mazda rx3'), (251, 'mazda rx-4')]",,1.0,
Find the number of flights landing in the city of Aberdeen or Abilene.,"[flights.DestAirport,airports.City,flights.DestAirport = airports.AirportCode,airports.City = 'Aberdeen',airports.City = 'Abilene']","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(flights.FlightNo) FROM flights JOIN airports ON flights.DestAirport = airports.AirportCode WHERE airports.City = 'Aberdeen' OR airports.City = 'Abilene';,"SELECT count(*) FROM Flights AS T1 JOIN Airports AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.city  =  ""Aberdeen"" OR T2.city  =  ""Abilene""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights landing in the specified cities. Use COUNT on ""flights.FlightNo"" to get the total number of flights. 2. Condition Structure: Use a WHERE clause to filter for flights where the destination airport's city is either ""Aberdeen"" or ""Abilene."" 3. Join Structure: Use an INNER JOIN between the ""flights"" table and the ""airports"" table on ""flights.DestAirport = airports.AirportCode"" to associate each flight with its destination airport's city. 4. Aggregation Structure: Use COUNT to aggregate the total number of flights landing in the specified cities.","[(0,)]","[(0,)]",,1.0,
What is the number of cars with a greater accelerate than the one with the most horsepower?,"[cars_data.Accelerate, cars_data.Horsepower]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT COUNT(*) FROM cars_data WHERE Accelerate > (SELECT Accelerate FROM cars_data WHERE Horsepower = (SELECT MAX(Horsepower) FROM cars_data));,SELECT COUNT(*) FROM CARS_DATA WHERE Accelerate  >  ( SELECT Accelerate FROM CARS_DATA ORDER BY Horsepower DESC LIMIT 1 );,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of cars. Use the FROM clause to specify the cars_data table. Apply a WHERE clause to filter cars with an acceleration value greater than the acceleration of the car with the maximum horsepower. 2. Condition Structure: Use the WHERE clause with a subquery to find the acceleration of the car with the maximum horsepower and filter cars with acceleration values greater than this. 3. Join Structure: Not required, as all data is in the cars_data table. 4. Aggregation Structure: Use the MAX function in a subquery to find the car with the maximum horsepower and its corresponding acceleration value. Use COUNT to count the number of cars meeting the condition.","[(39,)]","[(39,)]",,1.0,
What is the airport name for airport 'AKO'?,"[airports.AirportName,airports.AirportCode,AKO]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT airports.AirportName FROM airports WHERE airports.AirportCode = 'AKO';,"SELECT AirportName FROM AIRPORTS WHERE AirportCode  =  ""AKO""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airports.AirportName"" for the airport with the code 'AKO'. 2. Condition Structure: Use a WHERE clause to filter for the specific airport code 'AKO'. 3. Join Structure: No JOIN is required since all necessary information is in the ""airports"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('Colorado Plains Regional Airport ',)]","[('Colorado Plains Regional Airport ',)]",,1.0,
Give the flight numbers of flights landing at APG.,"[flights.FlightNo,flights.DestAirport,airports.AirportCode,flights.DestAirport = airports.AirportCode,APG]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT flights.FlightNo FROM flights JOIN airports ON flights.DestAirport = airports.AirportCode WHERE airports.AirportCode = 'APG';,"SELECT FlightNo FROM FLIGHTS WHERE DestAirport  =  ""APG""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""flights.FlightNo"" field, as the question asks for flight numbers. 2. Condition Structure: Use a WHERE clause to filter for flights where the destination airport code (""flights.DestAirport"") matches ""APG."" 3. Join Structure: Use an INNER JOIN between the ""flights"" table and the ""airports"" table on the condition ""flights.DestAirport = airports.AirportCode"" to link flights with their destination airport details. 4. Aggregation Structure: No aggregation is needed since the query only retrieves flight numbers without any summarization.",[],[],,1.0,
What are the different models created by either the car maker General Motors or weighed more than 3500?,"[model_list.Model,car_makers.FullName,car_makers.Id = model_list.Maker,cars_data.Weight,cars_data.Id = car_names.MakeId,car_names.Model = model_list.Model,General Motors,3500]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT DISTINCT model_list.Model FROM model_list JOIN car_makers ON car_makers.Id = model_list.Maker JOIN car_names ON car_names.Model = model_list.Model JOIN cars_data ON cars_data.Id = car_names.MakeId WHERE car_makers.FullName = 'General Motors' OR cars_data.Weight > 3500;,SELECT DISTINCT T2.Model FROM CAR_NAMES AS T1 JOIN MODEL_LIST AS T2 ON T1.Model  =  T2.Model JOIN CAR_MAKERS AS T3 ON T2.Maker  =  T3.Id JOIN CARS_DATA AS T4 ON T1.MakeId  =  T4.Id WHERE T3.FullName  =  'General Motors' OR T4.weight  >  3500;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct models. Use the FROM clause to specify the model_list table. Join it with the car_makers table to filter by the car maker ""General Motors"" and with the cars_data table to filter by weight greater than 3500. Use a WHERE clause to apply these conditions. 2. Condition Structure: Use the WHERE clause to filter models created by the car maker ""General Motors"" or models with a weight greater than 3500. 3. Join Structure: Use INNER JOINs to connect the model_list table with the car_makers table on the maker ID and with the cars_data table on the car ID through the car_names table. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('chevrolet',), ('buick',), ('ford',), ('plymouth',), ('pontiac',), ('amc',), ('dodge',), ('mercury',), ('oldsmobile',), ('chrysler',), ('mercedes-benz',), ('cadillac',), ('mercedes',)]","[('chevrolet',), ('buick',), ('ford',), ('plymouth',), ('pontiac',), ('amc',), ('dodge',), ('mercury',), ('oldsmobile',), ('chrysler',), ('mercedes-benz',), ('cadillac',), ('mercedes',)]",,1.0,
Which city and country is the Alton airport at?,"[airports.City, airports.Country, airports.AirportName]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,"SELECT airports.City, airports.Country FROM airports WHERE airports.AirportName = 'Alton';","SELECT City ,  Country FROM AIRPORTS WHERE AirportName  =  ""Alton""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the city and country of the airport named ""Alton"". 2. Condition Structure: Use a WHERE clause to filter for the airport with the name ""Alton"". 3. Join Structure: No JOIN is required since all necessary information is in the ""airports"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.",[],[],,1.0,
Give the code of the airport with the least flights.,"[flights.SourceAirport, flights.DestAirport, airports.AirportCode, flights.DestAirport = airports.AirportCode, flights.SourceAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT airports.AirportCode FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode OR flights.DestAirport = airports.AirportCode GROUP BY airports.AirportCode ORDER BY COUNT(flights.FlightNo) ASC LIMIT 1;,SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1,flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the airport code. Use COUNT to count the number of flights for each airport. Use ORDER BY in ascending order to rank airports by the number of flights. Use LIMIT 1 to select the airport with the least flights. 2. Condition Structure: No specific filtering condition is needed, as we are considering all flights and airports. 3. Join Structure: Use JOIN to connect the ""flights"" table with the ""airports"" table on both ""SourceAirport"" and ""DestAirport"" to account for flights arriving at and departing from each airport. 4. Aggregation Structure: Use COUNT to calculate the total number of flights for each airport, grouping by the airport code.",[],[],,1.0,
What are airlines that have flights arriving at airport 'AHD'?,"[flights.Airline,flights.DestAirport,flights.DestAirport = airports.AirportCode,airports.AirportCode,'AHD']","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT DISTINCT flights.Airline FROM flights WHERE flights.DestAirport = 'AHD';,"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.DestAirport  =  ""AHD""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of airlines (""flights.Airline"") that have flights arriving at the specified airport. 2. Condition Structure: Use a WHERE clause to filter for records where ""flights.DestAirport"" matches the airport code 'AHD'. 3. Join Structure: No JOIN is necessary because the ""flights"" table already contains the ""DestAirport"" field, which can be directly filtered. 4. Aggregation Structure: Use DISTINCT to ensure that each airline is listed only once.",[],[],,1.0,
What country is Jetblue Airways affiliated with?,"[airlines.Airline,airlines.Country]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT airlines.Country FROM airlines WHERE airlines.Airline = 'Jetblue Airways';,"SELECT Country FROM AIRLINES WHERE Airline  =  ""JetBlue Airways""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airlines.Country"" for the airline ""Jetblue Airways"". 2. Condition Structure: Use a WHERE clause to filter for the airline name ""Jetblue Airways"". 3. Join Structure: No JOIN is required since all necessary information is in the ""airlines"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",[],"[('USA',)]",,0.0,
Which airline has abbreviation 'UAL'?,"[airlines.Airline,airlines.Abbreviation,UAL]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT airlines.Airline FROM airlines WHERE airlines.Abbreviation = 'UAL';,"SELECT Airline FROM AIRLINES WHERE Abbreviation  =  ""UAL""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airlines.Airline"" field, as the question asks for the airline name. 2. Condition Structure: Use a WHERE clause to filter for the airline with the abbreviation 'UAL'. 3. Join Structure: No JOIN is required since all necessary information is in the ""airlines"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving a single field based on a specific condition.","[('United Airlines',)]","[('United Airlines',)]",,1.0,
Return the number of flights arriving in Aberdeen.,"[flights.DestAirport,airports.AirportCode,airports.City,flights.DestAirport = airports.AirportCode,Aberdeen]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(flights.FlightNo) FROM flights JOIN airports ON flights.DestAirport = airports.AirportCode WHERE airports.City = 'Aberdeen';,"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.City  =  ""Aberdeen""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights arriving in Aberdeen. Use COUNT on ""flights.FlightNo"" to get the total number of flights. 2. Condition Structure: Use a WHERE clause to filter for flights where the destination airport is in Aberdeen. This requires filtering ""airports.City"" for ""Aberdeen."" 3. Join Structure: Use an INNER JOIN between the ""flights"" table and the ""airports"" table on the condition ""flights.DestAirport = airports.AirportCode"" to link flights with their destination airport details. 4. Aggregation Structure: Use COUNT to aggregate the total number of flights arriving in Aberdeen.","[(0,)]","[(0,)]",,1.0,
How many flights do we have?,[flights.FlightNo],"Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT COUNT(flights.FlightNo) AS total_flights FROM flights;,SELECT count(*) FROM FLIGHTS,flight_2,"1. Sequential Structure: Start with the SELECT clause to count the total number of flights. 2. Condition Structure: No specific filtering condition is required since we want the total count of all flights. 3. Join Structure: No JOIN is necessary as the required information is available within the ""flights"" table. 4. Aggregation Structure: Use COUNT on ""flights.FlightNo"" to calculate the total number of flights.","[(1200,)]","[(1200,)]",,1.0,
What is the maximum accelerate for all the different cylinders?,"[cars_data.Cylinders, cars_data.Accelerate]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,"SELECT cars_data.Cylinders, MAX(cars_data.Accelerate) AS max_accelerate FROM cars_data GROUP BY cars_data.Cylinders;","SELECT max(Accelerate) ,  Cylinders FROM CARS_DATA GROUP BY Cylinders;",car_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the number of cylinders and the maximum acceleration. 2. Aggregation Structure: Use the MAX function to calculate the maximum acceleration for each cylinder type. 3. Grouping Structure: Use GROUP BY on ""cars_data.Cylinders"" to calculate the maximum acceleration for each unique cylinder value. 4. Join Structure: No JOIN is required since all necessary data is within the ""cars_data"" table.","[(3, 13.5), (4, 24.8), (5, 20.1), (6, 21.0), (8, 22.2)]","[(13.5, 3), (24.8, 4), (20.1, 5), (21.0, 6), (22.2, 8)]",,1.0,
How many airports do we have?,[airports.AirportCode],"Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT COUNT(airports.AirportCode) AS total_airports FROM airports;,SELECT count(*) FROM AIRPORTS,flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of airports. 2. Aggregation Structure: Use COUNT on the ""airports.AirportCode"" column to calculate the total number of airports. 3. Condition Structure: No specific filtering condition is required as we want the total count of all airports. 4. Join Structure: No JOIN is necessary since all required data is within the ""airports"" table.","[(100,)]","[(100,)]",,1.0,
What are the airline names and abbreviations for airlines in the USA?,"[airlines.Airline, airlines.Abbreviation, airlines.Country]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,"SELECT airlines.Airline, airlines.Abbreviation FROM airlines WHERE airlines.Country = 'USA';","SELECT Airline ,  Abbreviation FROM AIRLINES WHERE Country  =  ""USA""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the airline names and their abbreviations. 2. Condition Structure: Use a WHERE clause to filter airlines where the ""Country"" is 'USA'. 3. Join Structure: No JOIN is required since all necessary information is in the ""airlines"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving airline names and abbreviations based on a specific condition.","[('United Airlines', 'UAL'), ('US Airways', 'USAir'), ('Delta Airlines', 'Delta'), ('Southwest Airlines', 'Southwest'), ('American Airlines', 'American'), ('Northwest Airlines', 'Northwest'), ('Continental Airlines', 'Continental'), ('JetBlue Airways', 'JetBlue'), ('Frontier Airlines', 'Frontier'), ('AirTran Airways', 'AirTran'), ('Allegiant Air', 'Allegiant'), ('Virgin America', 'Virgin')]","[('United Airlines', 'UAL'), ('US Airways', 'USAir'), ('Delta Airlines', 'Delta'), ('Southwest Airlines', 'Southwest'), ('American Airlines', 'American'), ('Northwest Airlines', 'Northwest'), ('Continental Airlines', 'Continental'), ('JetBlue Airways', 'JetBlue'), ('Frontier Airlines', 'Frontier'), ('AirTran Airways', 'AirTran'), ('Allegiant Air', 'Allegiant'), ('Virgin America', 'Virgin')]",,1.0,
"For the cars with 4 cylinders, which model has the largest horsepower?","[cars_data.Cylinders,cars_data.Horsepower,cars_data.Id,car_names.Model,cars_data.Id = car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT car_names.Model, cars_data.Horsepower FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId WHERE cars_data.Cylinders = 4 ORDER BY cars_data.Horsepower DESC LIMIT 1;",SELECT T1.Model FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T2.Cylinders  =  4 ORDER BY T2.horsepower DESC LIMIT 1;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""car_names.Model"" and the maximum ""cars_data.Horsepower"" for cars with 4 cylinders. Use a subquery to identify the maximum horsepower. 2. Condition Structure: Use a WHERE clause to filter for cars with 4 cylinders. 3. Join Structure: Use a JOIN between ""cars_data"" and ""car_names"" on ""cars_data.Id = car_names.MakeId"" to associate each car's data with its model name. 4. Aggregation Structure: Use MAX to find the car with the largest horsepower among those with 4 cylinders.","[('ford', 'null')]","[('ford',)]",,1.0,
Find the name of airports which do not have any flight in and out.,"[airports.AirportCode, flights.SourceAirport, flights.DestAirport, flights.SourceAirport = airports.AirportCode, flights.DestAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NESTED,SELECT AirportName FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights UNION SELECT DestAirport FROM flights);,SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights),flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the airport names from the airports table. Use the FROM clause to specify the airports table. Apply a WHERE clause to filter airports that do not have any flights either as a source or destination. 2. Condition Structure: Use the WHERE clause with a subquery to exclude airports whose AirportCode appears in the flights table as either SourceAirport or DestAirport. 3. Join Structure: Not required, as we only need to filter based on the absence of matching AirportCode entries in the flights table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Phillips AAF ',), ('Municipal ',), ('Dyess AFB ',), ('Municipal ',), ('Virginia Highlands ',), ('Ada ',), ('Adak Island Ns ',), ('Lenawee County ',), ('Municipal ',), ('Municipal ',), ('Ainsworth ',), ('Akhiok SPB ',), ('Spb ',), ('Akiak ',), ('Colorado Plains Regional Airport ',), ('Akron/canton Regional ',), ('Fulton International ',), ('Akutan ',), ('Alakanuk ',), ('NAS ',), ('Holloman AFB ',), ('Municipal ',), ('Municipal ',), ('Albany NAS ',), ('Dougherty County ',), ('Albany International ',), ('Albany ',), ('Albert Lea ',), ('Albuquerque International ',), ('Aleknagik ',), ('Aleneva ',), ('Thomas C Russell Fld ',), ('Alexandria International ',), ('Esler Field ',), ('Alexandria ',), ('Alexandria Bay ',), ('Algona ',), ('International ',), ('George Downer ',), ('Alitak SPB ',), ('Allakaket ',), ('Alliance ',), ('Gratiot Community ',), ('Alpena County Regional ',), ('Alpine ',), ('Alton ',), ('Altus AFB ',), ('Municipal ',), ('Alyeska ',), ('Rick Husband Amarillo International ',), ('Tradewind ',), ('Ambler ',), ('Amchitka ',), ('Municipal ',), ('Ames ',), ('Zahns ',), ('Amook ',), ('Anacortes ',), ('USN Heliport ',), ('Orange County Steel Salvage Heliport ',), ('Anaktuvuk ',), ('Elmendorf Afb ',), ('Ted Stevens Anchorage International Airport ',), ('Merrill Field ',), ('Municipal ',), ('Anderson ',), ('Andrews ',), ('Angel Fire ',), ('Tri-State Steuben Cty ',), ('Angoon ',), ('Rollang Field ',), ('Aniak ',), ('Anita Bay ',), ('Municipal ',), ('Lee ',), ('Annette Island ',), ('Anniston Metropolitan ',), ('Ft Mcclellan Bus Trml ',), ('Reilly AHP ',), ('Anthony ',), ('Antlers ',), ('Anvik ',), ('Municipal ',), ('Apple Valley ',), ('Outagamie County ',), ('Municipal ',), ('Arcata ',), ('Arctic Village ',), ('Downtown ',), ('Ardmore Municipal Arpt ',), ('US Army Heliport ',), ('Artesia ',), ('Asbury Park ',), ('Ashland ',), ('Ashley ',), ('Aspen ',), ('Astoria ',), ('Athens ',), ('Ohio University ',), ('McMinn County ',)]","[('Phillips AAF ',), ('Municipal ',), ('Dyess AFB ',), ('Municipal ',), ('Virginia Highlands ',), ('Ada ',), ('Adak Island Ns ',), ('Lenawee County ',), ('Municipal ',), ('Municipal ',), ('Ainsworth ',), ('Akhiok SPB ',), ('Spb ',), ('Akiak ',), ('Colorado Plains Regional Airport ',), ('Akron/canton Regional ',), ('Fulton International ',), ('Akutan ',), ('Alakanuk ',), ('NAS ',), ('Holloman AFB ',), ('Municipal ',), ('Municipal ',), ('Albany NAS ',), ('Dougherty County ',), ('Albany International ',), ('Albany ',), ('Albert Lea ',), ('Albuquerque International ',), ('Aleknagik ',), ('Aleneva ',), ('Thomas C Russell Fld ',), ('Alexandria International ',), ('Esler Field ',), ('Alexandria ',), ('Alexandria Bay ',), ('Algona ',), ('International ',), ('George Downer ',), ('Alitak SPB ',), ('Allakaket ',), ('Alliance ',), ('Gratiot Community ',), ('Alpena County Regional ',), ('Alpine ',), ('Alton ',), ('Altus AFB ',), ('Municipal ',), ('Alyeska ',), ('Rick Husband Amarillo International ',), ('Tradewind ',), ('Ambler ',), ('Amchitka ',), ('Municipal ',), ('Ames ',), ('Zahns ',), ('Amook ',), ('Anacortes ',), ('USN Heliport ',), ('Orange County Steel Salvage Heliport ',), ('Anaktuvuk ',), ('Elmendorf Afb ',), ('Ted Stevens Anchorage International Airport ',), ('Merrill Field ',), ('Municipal ',), ('Anderson ',), ('Andrews ',), ('Angel Fire ',), ('Tri-State Steuben Cty ',), ('Angoon ',), ('Rollang Field ',), ('Aniak ',), ('Anita Bay ',), ('Municipal ',), ('Lee ',), ('Annette Island ',), ('Anniston Metropolitan ',), ('Ft Mcclellan Bus Trml ',), ('Reilly AHP ',), ('Anthony ',), ('Antlers ',), ('Anvik ',), ('Municipal ',), ('Apple Valley ',), ('Outagamie County ',), ('Municipal ',), ('Arcata ',), ('Arctic Village ',), ('Downtown ',), ('Ardmore Municipal Arpt ',), ('US Army Heliport ',), ('Artesia ',), ('Asbury Park ',), ('Ashland ',), ('Ashley ',), ('Aspen ',), ('Astoria ',), ('Athens ',), ('Ohio University ',), ('McMinn County ',)]",,1.0,
Return the name of the airport with code 'AKO'.,"[airports.AirportName,airports.AirportCode,'AKO']","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT airports.AirportName FROM airports WHERE airports.AirportCode = 'AKO';,"SELECT AirportName FROM AIRPORTS WHERE AirportCode  =  ""AKO""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airports.AirportName"" for the airport with the specified code. 2. Condition Structure: Use a WHERE clause to filter for the airport where ""airports.AirportCode"" equals 'AKO'. 3. Join Structure: No JOIN is required since all necessary information is in the ""airports"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('Colorado Plains Regional Airport ',)]","[('Colorado Plains Regional Airport ',)]",,1.0,
Give the flight numbers of flights arriving in Aberdeen.,"[flights.FlightNo,flights.DestAirport,airports.AirportCode,airports.City,flights.DestAirport = airports.AirportCode,Aberdeen]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT flights.FlightNo FROM flights JOIN airports ON flights.DestAirport = airports.AirportCode WHERE airports.City = 'Aberdeen';,"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport   =  T2.AirportCode WHERE T2.City  =  ""Aberdeen""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""flights.FlightNo"" field, as the question asks for flight numbers. 2. Condition Structure: Use a WHERE clause to filter for flights where the destination airport's city is ""Aberdeen."" 3. Join Structure: Use an INNER JOIN between the ""flights"" table and the ""airports"" table on the condition ""flights.DestAirport = airports.AirportCode"" to link flights with their destination airport details. 4. Aggregation Structure: No aggregation is needed since the query only retrieves flight numbers.",[],[],,1.0,
Count the number of flights departing from 'APG'.,"[flights.SourceAirport, flights.DestAirport = airports.AirportCode, 'APG']","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT COUNT(*) FROM flights WHERE flights.SourceAirport = 'APG';,"SELECT count(*) FROM FLIGHTS WHERE SourceAirport  =  ""APG""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights departing from the specified airport ('APG'). 2. Condition Structure: Use a WHERE clause to filter flights where the ""flights.SourceAirport"" matches 'APG'. 3. Join Structure: No JOIN is required since the relevant information is directly available in the ""flights"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of flights departing from 'APG'.","[(0,)]","[(0,)]",,1.0,
What is the average horsepower of the cars before 1980?,"[cars_data.Horsepower, cars_data.Year]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT AVG(cars_data.Horsepower) AS avg_horsepower FROM cars_data WHERE cars_data.Year < 1980;,SELECT avg(horsepower) FROM CARS_DATA WHERE YEAR  <  1980;,car_1,"1. Sequential Structure: Begin with the SELECT clause to calculate the average horsepower of cars. 2. Condition Structure: Use a WHERE clause to filter for cars manufactured before the year 1980. 3. Join Structure: No JOIN is required since all necessary data is within the ""cars_data"" table. 4. Aggregation Structure: Use the AVG function to calculate the average horsepower of the filtered cars.","[(111.13291139240506,)]","[(111.13291139240506,)]",,1.0,
Find all airlines that have fewer than 200 flights.,"[flights.Airline,flights.FlightNo]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT flights.Airline FROM flights GROUP BY flights.Airline HAVING COUNT(flights.FlightNo) < 200;,SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline GROUP BY T1.Airline HAVING count(*)  <  200,flight_2,"1. Sequential Structure: Begin with the SELECT clause to specify the airline names, as the question asks for airlines with fewer than 200 flights. 2. Aggregation Structure: Use COUNT to calculate the number of flights for each airline. 3. Grouping Structure: Use GROUP BY on ""flights.Airline"" to count the flights for each airline. 4. Condition Structure: Apply the HAVING clause to filter airlines with fewer than 200 flights. 5. Join Structure: No JOIN is required since all necessary data is within the ""flights"" table.","[(1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,), (10,), (11,), (12,)]","[('AirTran Airways',), ('Allegiant Air',), ('American Airlines',), ('Continental Airlines',), ('Delta Airlines',), ('Frontier Airlines',), ('JetBlue Airways',), ('Northwest Airlines',), ('Southwest Airlines',), ('US Airways',), ('United Airlines',), ('Virgin America',)]",,0.0,
Which city has most number of arriving flights?,"[flights.DestAirport, airports.City, flights.DestAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,"SELECT airports.City, COUNT(flights.DestAirport) AS ArrivingFlights FROM flights JOIN airports ON flights.DestAirport = airports.AirportCode GROUP BY airports.City ORDER BY ArrivingFlights DESC LIMIT 1;",SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1,flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airports.City"" and the count of arriving flights. Use COUNT to count the number of flights arriving at each city. 2. Condition Structure: No specific filtering condition is required, as we are interested in all arriving flights. 3. Join Structure: Use a JOIN between the ""flights"" and ""airports"" tables on ""flights.DestAirport = airports.AirportCode"" to link each flight with its destination city. 4. Aggregation Structure: Use GROUP BY on ""airports.City"" to group the results by city, and use ORDER BY in descending order of the count to find the city with the most arriving flights. Use LIMIT 1 to get the city with the highest count.",[],[],,1.0,
What is the code of airport that has fewest number of flights?,"[flights.SourceAirport, flights.DestAirport, airports.AirportCode, flights.DestAirport = airports.AirportCode, flights.SourceAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT airports.AirportCode FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode OR flights.DestAirport = airports.AirportCode GROUP BY airports.AirportCode ORDER BY COUNT(flights.FlightNo) ASC LIMIT 1;,SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) LIMIT 1,flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the airport code. Use COUNT to count the number of flights for each airport. Use ORDER BY to sort the airports by the number of flights in ascending order. Use LIMIT 1 to get the airport with the fewest flights. 2. Condition Structure: No specific filtering condition is needed, as we are considering all airports. 3. Join Structure: Use JOIN to connect the ""flights"" table with the ""airports"" table on both ""flights.SourceAirport = airports.AirportCode"" and ""flights.DestAirport = airports.AirportCode"" to account for flights arriving at and departing from each airport. 4. Aggregation Structure: Use COUNT to aggregate the total number of flights for each airport, grouping by the airport code.",[],[],,1.0,
How many United Airlines flights go to City 'Aberdeen'?,"[flights.Airline,flights.DestAirport,airports.City,flights.DestAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(*) FROM flights JOIN airports ON flights.DestAirport = airports.AirportCode WHERE flights.Airline = 'United Airlines' AND airports.City = 'Aberdeen';,"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode JOIN AIRLINES AS T3 ON T3.uid  =  T1.Airline WHERE T2.City  =  ""Aberdeen"" AND T3.Airline  =  ""United Airlines""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights. Use COUNT to calculate the total number of flights for United Airlines going to the city ""Aberdeen."" 2. Condition Structure: Use a WHERE clause to filter for flights where the airline is ""United Airlines"" and the destination city is ""Aberdeen."" 3. Join Structure: Use an INNER JOIN to connect the ""flights"" table with the ""airports"" table on the ""DestAirport"" and ""AirportCode"" fields to link flights with their destination airport details. 4. Aggregation Structure: Use COUNT to aggregate the number of flights that meet the specified conditions.","[(0,)]","[(0,)]",,1.0,
"List all airline names and their abbreviations in ""USA"".","[airlines.Airline, airlines.Abbreviation, airlines.Country, USA]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,"SELECT airlines.Airline, airlines.Abbreviation FROM airlines WHERE airlines.Country = 'USA';","SELECT Airline ,  Abbreviation FROM AIRLINES WHERE Country  =  ""USA""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the airline names and their abbreviations. 2. Condition Structure: Use a WHERE clause to filter airlines where the ""Country"" is ""USA"". 3. Join Structure: No JOIN is required since all necessary information is in the ""airlines"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving airline names and abbreviations based on the specified condition.","[('United Airlines', 'UAL'), ('US Airways', 'USAir'), ('Delta Airlines', 'Delta'), ('Southwest Airlines', 'Southwest'), ('American Airlines', 'American'), ('Northwest Airlines', 'Northwest'), ('Continental Airlines', 'Continental'), ('JetBlue Airways', 'JetBlue'), ('Frontier Airlines', 'Frontier'), ('AirTran Airways', 'AirTran'), ('Allegiant Air', 'Allegiant'), ('Virgin America', 'Virgin')]","[('United Airlines', 'UAL'), ('US Airways', 'USAir'), ('Delta Airlines', 'Delta'), ('Southwest Airlines', 'Southwest'), ('American Airlines', 'American'), ('Northwest Airlines', 'Northwest'), ('Continental Airlines', 'Continental'), ('JetBlue Airways', 'JetBlue'), ('Frontier Airlines', 'Frontier'), ('AirTran Airways', 'AirTran'), ('Allegiant Air', 'Allegiant'), ('Virgin America', 'Virgin')]",,1.0,
"For a volvo model, how many cylinders does the version with least accelerate have?","[car_names.Model,model_list.Maker,car_makers.FullName,car_makers.Id = model_list.Maker,cars_data.Cylinders,cars_data.Accelerate,cars_data.Id = car_names.MakeId,car_makers.FullName = 'Volvo']","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT cars_data.Cylinders FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId JOIN model_list ON car_names.Model = model_list.Model JOIN car_makers ON model_list.Maker = car_makers.Id WHERE car_makers.FullName = 'Volvo' ORDER BY cars_data.Accelerate ASC LIMIT 1;,SELECT T1.cylinders FROM CARS_DATA AS T1 JOIN CAR_NAMES AS T2 ON T1.Id  =  T2.MakeId WHERE T2.Model  =  'volvo' ORDER BY T1.accelerate ASC LIMIT 1;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the number of cylinders. Use the FROM clause to specify the cars_data table and join it with car_names, model_list, and car_makers to connect the car details with the maker's full name. Apply a WHERE clause to filter for models made by Volvo. Use ORDER BY on the accelerate column to sort by the least acceleration and LIMIT 1 to get the version with the least acceleration. 2. Condition Structure: Use the WHERE clause to filter for car makers with the FullName 'Volvo'. 3. Join Structure: Use INNER JOINs to connect car_makers with model_list on the maker ID, model_list with car_names on the model, and car_names with cars_data on the MakeId to retrieve the relevant car details. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[(6,)]","[(6,)]",,1.0,
"What are flight numbers of flights arriving at City ""Aberdeen""?","[flights.FlightNo,flights.DestAirport,airports.City,flights.DestAirport = airports.AirportCode,Aberdeen]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT flights.FlightNo FROM flights JOIN airports ON flights.DestAirport = airports.AirportCode WHERE airports.City = 'Aberdeen';,"SELECT T1.FlightNo FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport   =  T2.AirportCode WHERE T2.City  =  ""Aberdeen""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""flights.FlightNo"" field, as the question asks for flight numbers. 2. Condition Structure: Use a WHERE clause to filter for flights where the destination city is ""Aberdeen."" This requires filtering on ""airports.City"" with the value ""Aberdeen."" 3. Join Structure: Use an INNER JOIN between the ""flights"" table and the ""airports"" table on the condition ""flights.DestAirport = airports.AirportCode"" to link flights with their destination airport details. 4. Aggregation Structure: No aggregation is needed since the query only retrieves flight numbers without any summarization.",[],[],,1.0,
Which model has the most version(make) of cars?,"[car_names.Model,car_names.Make,car_names.Model = model_list.Model]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT car_names.Model, COUNT(car_names.Make) AS version_count FROM car_names JOIN model_list ON car_names.Model = model_list.Model GROUP BY car_names.Model ORDER BY version_count DESC LIMIT 1;",SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""car_names.Model"" and count the number of versions (makes) for each model. Use COUNT on ""car_names.Make"" to count the versions. 2. Condition Structure: No specific filtering condition is required, as we are interested in all models. 3. Join Structure: Use a JOIN between ""car_names"" and ""model_list"" on ""car_names.Model = model_list.Model"" to ensure the models are correctly linked. 4. Aggregation Structure: Use GROUP BY on ""car_names.Model"" to group the data by model, and use ORDER BY in descending order on the count of makes to find the model with the most versions. Use LIMIT 1 to select the top result.","[('ford', 53)]","[('ford',)]",,1.0,
What model has the most different versions?,"[car_names.Model,car_names.Make,car_names.Model = model_list.Model]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,"SELECT car_names.Model, COUNT(DISTINCT car_names.Make) AS version_count FROM car_names GROUP BY car_names.Model ORDER BY version_count DESC LIMIT 1;",SELECT Model FROM CAR_NAMES GROUP BY Model ORDER BY count(*) DESC LIMIT 1;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""car_names.Model"" and count the distinct ""car_names.Make"" for each model. Use COUNT with DISTINCT to count the different versions (makes) of each model. 2. Condition Structure: No specific filtering condition is required, as we are interested in all models. 3. Join Structure: No JOIN is necessary since all the required data is available in the ""car_names"" table. 4. Aggregation Structure: Use GROUP BY on ""car_names.Model"" to group the data by model, and use ORDER BY in descending order on the count of distinct makes to rank models by the number of versions. Use LIMIT 1 to select the model with the most versions.","[('ford', 37)]","[('ford',)]",,1.0,
How many 'United Airlines' flights go to Airport 'ASY'?,"[flights.Airline,flights.DestAirport,airports.AirportCode,flights.DestAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(*) FROM flights WHERE flights.Airline = 'United Airlines' AND flights.DestAirport = 'ASY';,"SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  ""United Airlines"" AND T2.DestAirport  =  ""ASY""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights. Use COUNT to calculate the total number of flights matching the criteria. 2. Condition Structure: Use a WHERE clause to filter for flights where the airline is ""United Airlines"" and the destination airport is ""ASY."" 3. Join Structure: No JOIN is necessary since the relevant fields are all in the ""flights"" table, and the destination airport code is directly referenced. 4. Aggregation Structure: Use COUNT to aggregate the number of flights that meet the specified conditions.","[(0,)]","[(0,)]",,1.0,
What is the airport code of the airport with the most flights?,"[flights.SourceAirport, flights.DestAirport, airports.AirportCode, flights.DestAirport = airports.AirportCode, flights.SourceAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT airports.AirportCode FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode OR flights.DestAirport = airports.AirportCode GROUP BY airports.AirportCode ORDER BY COUNT(*) DESC LIMIT 1;,SELECT T1.AirportCode FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.DestAirport OR T1.AirportCode  =  T2.SourceAirport GROUP BY T1.AirportCode ORDER BY count(*) DESC LIMIT 1,flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airports.AirportCode"" of the airport with the most flights. Use COUNT to count the number of flights associated with each airport. 2. Condition Structure: No specific filtering condition is required, as we are interested in all flights. 3. Join Structure: Use JOIN to connect the ""flights"" table with the ""airports"" table on both ""flights.SourceAirport = airports.AirportCode"" and ""flights.DestAirport = airports.AirportCode"" to account for flights arriving at and departing from each airport. 4. Aggregation Structure: Use COUNT to count the total number of flights for each airport. Use GROUP BY to group results by ""airports.AirportCode"" and ORDER BY in descending order to rank airports by the number of flights. Use LIMIT 1 to select the airport with the most flights.",[],[],,1.0,
What is the average edispl for all volvos?,"[cars_data.Edispl,car_names.Make,car_names.MakeId = cars_data.Id,car_names.Model = model_list.Model,model_list.Maker = car_makers.Id,car_makers.FullName]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT AVG(cars_data.Edispl) FROM cars_data JOIN car_names ON car_names.MakeId = cars_data.Id JOIN model_list ON car_names.Model = model_list.Model JOIN car_makers ON model_list.Maker = car_makers.Id WHERE car_makers.FullName = 'Volvo';,SELECT avg(T2.edispl) FROM CAR_NAMES AS T1 JOIN CARS_DATA AS T2 ON T1.MakeId  =  T2.Id WHERE T1.Model  =  'volvo';,car_1,"1. Sequential Structure: Start with the SELECT clause to calculate the average ""cars_data.Edispl"" for all Volvos. Use the AVG function for this purpose. 2. Condition Structure: Use a WHERE clause to filter for records where the ""car_makers.FullName"" is 'Volvo.' 3. Join Structure: Use JOINs to connect the relevant tables. First, join ""cars_data"" with ""car_names"" on ""car_names.MakeId = cars_data.Id."" Then, join ""car_names"" with ""model_list"" on ""car_names.Model = model_list.Model."" Finally, join ""model_list"" with ""car_makers"" on ""model_list.Maker = car_makers.Id"" to access the ""car_makers.FullName"" field. 4. Aggregation Structure: Use the AVG function to compute the average ""Edispl"" for the filtered records.","[(133.5,)]","[(133.5,)]",,1.0,
What are the names of all European countries with at least 3 manufacturers?,"[countries.CountryName,continents.Continent,countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,car_makers.Id]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT countries.CountryName FROM countries JOIN continents ON countries.Continent = continents.ContId JOIN car_makers ON car_makers.Country = countries.CountryId WHERE continents.Continent = 'Europe' GROUP BY countries.CountryName HAVING COUNT(car_makers.Id) >= 3;,SELECT T1.CountryName FROM COUNTRIES AS T1 JOIN CONTINENTS AS T2 ON T1.Continent  =  T2.ContId JOIN CAR_MAKERS AS T3 ON T1.CountryId  =  T3.Country WHERE T2.Continent  =  'europe' GROUP BY T1.CountryName HAVING count(*)  >=  3;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of European countries. Use a GROUP BY clause to group by ""countries.CountryName"" since we need to count manufacturers per country. Apply a HAVING clause to filter countries with at least 3 manufacturers. 2. Condition Structure: Use a WHERE clause to filter for countries in Europe. This requires joining ""countries"" with ""continents"" to check if the continent is Europe. 3. Join Structure: Use a JOIN between ""countries"" and ""continents"" on ""countries.Continent = continents.ContId"" to identify European countries. Then, join ""countries"" with ""car_makers"" on ""car_makers.Country = countries.CountryId"" to count manufacturers per country. 4. Aggregation Structure: Use COUNT on ""car_makers.Id"" to count the number of manufacturers per country. Apply HAVING to filter for countries with at least 3 manufacturers.",[],"[('france',), ('germany',)]",,0.0,
Which airlines have departing flights from both APG and CVO airports?,"[flights.Airline, flights.SourceAirport, airports.AirportCode, flights.SourceAirport = airports.AirportCode, APG, CVO]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NESTED,"SELECT flights.Airline FROM flights WHERE flights.SourceAirport IN ('APG', 'CVO') GROUP BY flights.Airline HAVING COUNT(DISTINCT flights.SourceAirport) = 2;","SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  ""APG"" INTERSECT SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  ""CVO""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the airline names. Use the FROM clause to specify the flights table. Apply a WHERE clause to filter flights that have a SourceAirport of either 'APG' or 'CVO'. Use GROUP BY to group by airline and apply a HAVING clause to ensure that the airline has flights departing from both 'APG' and 'CVO'. 2. Condition Structure: Use the WHERE clause to filter for flights where the SourceAirport is either 'APG' or 'CVO'. Use the HAVING clause to ensure that both airports are present for each airline. 3. Join Structure: Not required, as all necessary data is available in the flights table. 4. Aggregation Structure: Use COUNT(DISTINCT SourceAirport) in the HAVING clause to ensure that both 'APG' and 'CVO' are covered for each airline.",[],[],,1.0,
What are airlines that have some flight departing from airport 'AHD'?,"[flights.Airline, flights.SourceAirport, flights.SourceAirport = airports.AirportCode, airports.AirportCode, 'AHD']","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT DISTINCT flights.Airline FROM flights WHERE flights.SourceAirport = 'AHD';,"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  ""AHD""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of airlines (""flights.Airline"") that have flights departing from the specified airport ('AHD'). 2. Condition Structure: Use a WHERE clause to filter for flights where ""flights.SourceAirport"" matches the airport code 'AHD'. 3. Join Structure: No JOIN is required since the ""flights"" table already contains the ""SourceAirport"" field, and the condition directly applies to it. 4. Aggregation Structure: Use DISTINCT to ensure that each airline is listed only once.",[],[],,1.0,
Give the flight numbers of flights leaving from APG.,"[flights.FlightNo, flights.SourceAirport, airports.AirportCode, flights.SourceAirport = airports.AirportCode, APG]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT flights.FlightNo FROM flights WHERE flights.SourceAirport = 'APG';,"SELECT FlightNo FROM FLIGHTS WHERE SourceAirport  =  ""APG""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""flights.FlightNo"" field, as the question asks for flight numbers. 2. Condition Structure: Use a WHERE clause to filter flights where the ""flights.SourceAirport"" matches the airport code ""APG."" 3. Join Structure: No JOIN is required because the ""flights.SourceAirport"" directly corresponds to the airport code ""APG."" 4. Aggregation Structure: No aggregation is needed since the query only retrieves flight numbers without any summarization.",[],[],,1.0,
"Which country does Airline ""JetBlue Airways"" belong to?","[airlines.Airline, airlines.Country]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT airlines.Country FROM airlines WHERE airlines.Airline = 'JetBlue Airways';,"SELECT Country FROM AIRLINES WHERE Airline  =  ""JetBlue Airways""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Country"" of the airline ""JetBlue Airways"". 2. Condition Structure: Use a WHERE clause to filter for the airline with the name ""JetBlue Airways"". 3. Join Structure: No JOIN is required since all necessary information is in the ""airlines"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('USA',)]","[('USA',)]",,1.0,
What is the number of countries with more than 2 car makers ?,"[countries.CountryId,car_makers.Country,countries.Continent = continents.ContId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NESTED,SELECT COUNT(*) AS number_of_countries FROM countries JOIN car_makers ON countries.CountryId = car_makers.Country GROUP BY countries.CountryId HAVING COUNT(car_makers.Id) > 2;,select count(*) from countries as t1 join car_makers as t2 on t1.countryid  =  t2.country group by t1.countryid having count(*)  >  2,car_1,1. Sequential Structure: Start with the SELECT clause to count the number of countries. Use the FROM clause to specify the countries table and JOIN it with the car_makers table to link countries with their car makers. Apply a GROUP BY clause to group by country and use the HAVING clause to filter countries with more than 2 car makers. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for countries that have more than 2 car makers. 3. Join Structure: Use an INNER JOIN between the countries and car_makers tables based on the CountryId and Country fields to connect countries with their car makers. 4. Aggregation Structure: Use COUNT(*) to count the number of car makers per country and filter based on the condition of having more than 2 car makers.,"[(4,), (4,), (3,), (5,)]","[(4,), (4,), (3,), (5,)]",,1.0,
How many flights does airline 'JetBlue Airways' have?,"[flights.Airline,flights.FlightNo]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT COUNT(flights.FlightNo) FROM flights WHERE flights.Airline = 'JetBlue Airways';,"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRLINES AS T2 ON T1.Airline  =  T2.uid WHERE T2.Airline = ""JetBlue Airways""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights for the airline 'JetBlue Airways'. 2. Condition Structure: Use a WHERE clause to filter records where ""flights.Airline"" is 'JetBlue Airways'. 3. Join Structure: No JOIN is required since all necessary information is in the ""flights"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of flights for the specified airline.","[(0,)]","[(100,)]",,0.0,
How many flights arriving in Aberdeen city?,"[flights.DestAirport,airports.City,flights.DestAirport = airports.AirportCode,Aberdeen]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(flights.FlightNo) FROM flights JOIN airports ON flights.DestAirport = airports.AirportCode WHERE airports.City = 'Aberdeen';,"SELECT count(*) FROM FLIGHTS AS T1 JOIN AIRPORTS AS T2 ON T1.DestAirport  =  T2.AirportCode WHERE T2.City  =  ""Aberdeen""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights arriving in Aberdeen city. Use COUNT on ""flights.FlightNo"" to get the total number of flights. 2. Condition Structure: Use a WHERE clause to filter for flights where the destination airport corresponds to an airport in Aberdeen city. This requires matching ""flights.DestAirport"" with ""airports.AirportCode"" and filtering ""airports.City"" for ""Aberdeen."" 3. Join Structure: Use an INNER JOIN to connect the ""flights"" table with the ""airports"" table based on the relationship ""flights.DestAirport = airports.AirportCode."" 4. Aggregation Structure: Use COUNT to aggregate the total number of flights arriving in Aberdeen city.","[(0,)]","[(0,)]",,1.0,
What is the maximum miles per gallon of the car with 8 cylinders or produced before 1980 ?,"[cars_data.MPG, cars_data.Cylinders, cars_data.Year]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT MAX(cars_data.MPG) AS max_mpg FROM cars_data WHERE cars_data.Cylinders = 8 OR cars_data.Year < 1980;,select max(mpg) from cars_data where cylinders  =  8 or year  <  1980,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the maximum miles per gallon (MPG) from the ""cars_data"" table. 2. Condition Structure: Use a WHERE clause to filter for cars that have 8 cylinders or were produced before the year 1980. 3. Join Structure: No JOIN is required since all necessary information is in the ""cars_data"" table. 4. Aggregation Structure: Use the MAX function to calculate the maximum MPG for the filtered cars.","[('null',)]","[('null',)]",,1.0,
Give the airline with abbreviation 'UAL'.,"[airlines.Abbreviation, airlines.Airline, 'UAL']","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT airlines.Airline FROM airlines WHERE airlines.Abbreviation = 'UAL';,"SELECT Airline FROM AIRLINES WHERE Abbreviation  =  ""UAL""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airlines.Airline"" field, as the question asks for the airline name. 2. Condition Structure: Use a WHERE clause to filter for the airline with the abbreviation 'UAL'. 3. Join Structure: No JOIN is required since all necessary information is in the ""airlines"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving a single field based on a specific condition.","[('United Airlines',)]","[('United Airlines',)]",,1.0,
Count the number of United Airlines flights arriving in ASY Airport.,"[flights.Airline,flights.DestAirport,airports.AirportCode,flights.DestAirport = airports.AirportCode,airlines.Airline,airlines.uid]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(*) FROM flights JOIN airlines ON flights.Airline = airlines.Airline JOIN airports ON flights.DestAirport = airports.AirportCode WHERE airlines.Airline = 'United Airlines' AND airports.AirportCode = 'ASY';,"SELECT count(*) FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T2.Airline  =  T1.uid WHERE T1.Airline  =  ""United Airlines"" AND T2.DestAirport  =  ""ASY""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights. Use COUNT to aggregate the number of flights arriving at the specified airport. 2. Condition Structure: Use a WHERE clause to filter for flights where the airline is ""United Airlines"" and the destination airport is ""ASY."" 3. Join Structure: Use JOINs to connect the ""flights"" table with the ""airlines"" table on the ""Airline"" field and the ""airports"" table on the ""DestAirport"" field to ensure the relationships are properly established. 4. Aggregation Structure: Use COUNT to count the number of flights that meet the specified conditions.","[(0,)]","[(0,)]",,1.0,
Which airlines have a flight with destination airport AHD?,"[flights.Airline,flights.DestAirport,flights.DestAirport = airports.AirportCode,airports.AirportCode,AHD]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT DISTINCT flights.Airline FROM flights WHERE flights.DestAirport = 'AHD';,"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.DestAirport  =  ""AHD""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of airlines that have flights with the specified destination airport. Use DISTINCT to ensure unique airline names are returned. 2. Condition Structure: Use a WHERE clause to filter for flights where the destination airport matches the specified airport code ""AHD."" 3. Join Structure: No JOIN is required since the ""flights"" table already contains the necessary information to filter by destination airport and retrieve the airline. 4. Aggregation Structure: No aggregation is needed as the query only requires distinct airline names.",[],[],,1.0,
"What are flight numbers of flights departing from Airport ""APG""?","[flights.FlightNo,flights.SourceAirport,airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",EASY,SELECT flights.FlightNo FROM flights WHERE flights.SourceAirport = 'APG';,"SELECT FlightNo FROM FLIGHTS WHERE SourceAirport  =  ""APG""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the flight numbers (""flights.FlightNo"") of flights departing from the specified airport. 2. Condition Structure: Use a WHERE clause to filter flights where the ""flights.SourceAirport"" matches the airport code ""APG"". 3. Join Structure: No JOIN is required since the relevant information is already in the ""flights"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving flight numbers based on a specific condition.",[],[],,1.0,
What is the car model with the highest mpg ?,"[cars_data.MPG,car_names.Model,cars_data.Id = car_names.MakeId]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",NON-NESTED,SELECT car_names.Model FROM cars_data JOIN car_names ON cars_data.Id = car_names.MakeId ORDER BY cars_data.MPG DESC LIMIT 1;,select t1.model from car_names as t1 join cars_data as t2 on t1.makeid  =  t2.id order by t2.mpg desc limit 1;,car_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""car_names.Model"" of the car with the highest MPG. Use ORDER BY in descending order on ""cars_data.MPG"" to rank cars by their MPG and LIMIT 1 to select the car with the highest MPG. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the car with the highest MPG. 3. Join Structure: Use a JOIN between ""cars_data"" and ""car_names"" tables based on ""cars_data.Id = car_names.MakeId"" to link each car's data with its model name. 4. Aggregation Structure: No aggregation is needed since we are only retrieving the model with the highest MPG.","[('citroen',)]","[('citroen',)]",,1.0,
How many cars has over 6 cylinders?,"[cars_data.Cylinders,6]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT COUNT(*) FROM cars_data WHERE cars_data.Cylinders > 6;,SELECT COUNT(*) FROM CARS_DATA WHERE Cylinders  >  6;,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of cars with more than 6 cylinders. 2. Condition Structure: Use a WHERE clause to filter cars where ""cars_data.Cylinders"" is greater than 6. 3. Join Structure: No JOIN is required since all necessary information is in the ""cars_data"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cars that meet the specified condition.","[(108,)]","[(108,)]",,1.0,
Count the number of flights into ATO.,"[flights.DestAirport,airports.AirportCode,flights.DestAirport = airports.AirportCode,ATO]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT COUNT(flights.FlightNo) FROM flights WHERE flights.DestAirport = 'ATO';,"SELECT count(*) FROM FLIGHTS WHERE DestAirport  =  ""ATO""",flight_2,"1. Sequential Structure: Start with the SELECT clause to count the number of flights. Use COUNT on ""flights.FlightNo"" to get the total number of flights. 2. Condition Structure: Use a WHERE clause to filter for flights where the destination airport (""flights.DestAirport"") is ""ATO."" 3. Join Structure: No JOIN is necessary because the destination airport code is directly available in the ""flights"" table. 4. Aggregation Structure: Use COUNT to aggregate the total number of flights into ""ATO.""","[(0,)]","[(0,)]",,1.0,
how many cars were produced in 1980?,"[cars_data.Year,cars_data.Id]","Table car_makers, columns = [*,Id,Maker,FullName,Country]
Table car_names, columns = [*,MakeId,Model,Make]
Table cars_data, columns = [*,Id,MPG,Cylinders,Edispl,Horsepower,Weight,Accelerate,Year]
Table continents, columns = [*,ContId,Continent]
Table countries, columns = [*,CountryId,CountryName,Continent]
Table model_list, columns = [*,ModelId,Maker,Model]
","Foreign_keys = [countries.Continent = continents.ContId,car_makers.Country = countries.CountryId,model_list.Maker = car_makers.Id,car_names.Model = model_list.Model,cars_data.Id = car_names.MakeId]
",EASY,SELECT COUNT(cars_data.Id) FROM cars_data WHERE cars_data.Year = 1980;,SELECT count(*) FROM CARS_DATA WHERE YEAR  =  1980;,car_1,"1. Sequential Structure: Start with the SELECT clause to count the number of cars produced in 1980. 2. Condition Structure: Use a WHERE clause to filter records where ""cars_data.Year"" is 1980. 3. Join Structure: No JOIN is required since all necessary information is in the ""cars_data"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cars produced in 1980.","[(29,)]","[(29,)]",,1.0,
Which airlines have a flight with source airport AHD?,"[flights.Airline, flights.SourceAirport, flights.SourceAirport = airports.AirportCode, airports.AirportCode, AHD]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,SELECT DISTINCT flights.Airline FROM flights WHERE flights.SourceAirport = 'AHD';,"SELECT T1.Airline FROM AIRLINES AS T1 JOIN FLIGHTS AS T2 ON T1.uid  =  T2.Airline WHERE T2.SourceAirport  =  ""AHD""",flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of airlines (""flights.Airline"") that have flights originating from the specified source airport ""AHD."" 2. Condition Structure: Use a WHERE clause to filter for records where ""flights.SourceAirport"" matches the airport code ""AHD."" 3. Join Structure: No JOIN is required since the ""flights"" table already contains the ""SourceAirport"" field, and the condition directly applies to it. 4. Aggregation Structure: Use DISTINCT to ensure that each airline is listed only once.",[],[],,1.0,
Which city has most number of departing flights?,"[flights.SourceAirport, airports.City, flights.SourceAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NON-NESTED,"SELECT airports.City, COUNT(flights.SourceAirport) AS DepartingFlights FROM flights JOIN airports ON flights.SourceAirport = airports.AirportCode GROUP BY airports.City ORDER BY DepartingFlights DESC LIMIT 1;",SELECT T1.City FROM AIRPORTS AS T1 JOIN FLIGHTS AS T2 ON T1.AirportCode  =  T2.SourceAirport GROUP BY T1.City ORDER BY count(*) DESC LIMIT 1,flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""airports.City"" and the count of departing flights. Use COUNT to count the number of flights departing from each city. 2. Condition Structure: No specific filtering condition is required, as we are interested in all departing flights. 3. Join Structure: Use a JOIN between the ""flights"" and ""airports"" tables based on the relationship ""flights.SourceAirport = airports.AirportCode"" to link each flight with its source city. 4. Aggregation Structure: Use GROUP BY on ""airports.City"" to group the results by city. Use ORDER BY in descending order on the count of flights to rank cities by the number of departing flights. Use LIMIT 1 to get the city with the most departing flights.",[],[],,1.0,
Find the total amount of bonus given in all the evaluations.,[evaluation.Bonus],"Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,SELECT SUM(evaluation.Bonus) AS total_bonus FROM evaluation;,SELECT sum(bonus) FROM evaluation,employee_hire_evaluation,"1. Sequential Structure: Begin with the SELECT clause to specify the total amount of bonuses, which requires the use of the SUM function on the ""evaluation.Bonus"" field. 2. Condition Structure: No specific filtering condition is required as the query asks for the total bonus across all evaluations. 3. Join Structure: No JOIN is necessary since all the required data is available within the ""evaluation"" table. 4. Aggregation Structure: Use the SUM function to calculate the total bonus from the ""evaluation.Bonus"" field.","[(19500.0,)]","[(19500.0,)]",,1.0,
Which template type code has most number of templates?,"[Templates.Template_Type_Code, Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Template_Type_Code, COUNT(*) AS Template_Count FROM Templates GROUP BY Template_Type_Code ORDER BY Template_Count DESC LIMIT 1;",SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY count(*) DESC LIMIT 1,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Template_Type_Code"" and the count of templates for each type. Use COUNT to count the number of templates. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all template types. 3. Join Structure: No JOIN is required since the necessary data is available in the ""Templates"" table. 4. Aggregation Structure: Use GROUP BY on ""Template_Type_Code"" to group the templates by their type. Use ORDER BY in descending order of the count to rank the template types by the number of templates. Use LIMIT 1 to get the template type with the most templates.","[('PP', 6)]","[('PP',)]",,1.0,
Which template type code is used by most number of documents?,"[Documents.Template_ID,Templates.Template_Type_Code,Documents.Template_ID = Templates.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Templates.Template_Type_Code, COUNT(Documents.Document_ID) AS Document_Count FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID GROUP BY Templates.Template_Type_Code ORDER BY Document_Count DESC LIMIT 1;",SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY count(*) DESC LIMIT 1,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Templates.Template_Type_Code"" and the count of documents using it. Use COUNT to count the number of documents for each template type code. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Documents"" table and the ""Templates"" table on ""Documents.Template_ID = Templates.Template_ID"" to associate documents with their respective template type codes. 4. Aggregation Structure: Use GROUP BY on ""Templates.Template_Type_Code"" to group the results by template type code. Use ORDER BY in descending order of the count to find the template type code used by the most documents. Use LIMIT 1 to get the top result.","[('BK', 5)]","[('BK',)]",,1.0,
Return the different descriptions for templates that have been used in a document.,"[Templates.Template_Type_Code,Ref_Template_Types.Template_Type_Description,Documents.Template_ID = Templates.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT DISTINCT Ref_Template_Types.Template_Type_Description FROM Templates JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code JOIN Documents ON Documents.Template_ID = Templates.Template_ID;,SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct ""Ref_Template_Types.Template_Type_Description"" since we are asked for different descriptions. 2. Condition Structure: No specific filtering condition is required as we are interested in all templates that have been used in a document. 3. Join Structure: Use JOINs to connect ""Templates"" with ""Ref_Template_Types"" on ""Template_Type_Code"" and ""Templates"" with ""Documents"" on ""Template_ID"" to ensure we only consider templates that have been used in a document. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique descriptions are returned.","[('Presentation',), ('Paper',), ('Book',), ('Advertisement',)]","[('Presentation',), ('Paper',), ('Book',), ('Advertisement',)]",,1.0,
What are the type codes and descriptions for all template types?,"[Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description FROM Ref_Template_Types;","SELECT template_type_code ,  template_type_description FROM Ref_template_types",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Ref_Template_Types.Template_Type_Code"" and ""Ref_Template_Types.Template_Type_Description"". 2. Condition Structure: No specific filtering condition is required as the query asks for all template types. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Ref_Template_Types"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all type codes and descriptions.","[('PPT', 'Presentation'), ('CV', 'CV'), ('AD', 'Advertisement'), ('PP', 'Paper'), ('BK', 'Book')]","[('PPT', 'Presentation'), ('CV', 'CV'), ('AD', 'Advertisement'), ('PP', 'Paper'), ('BK', 'Book')]",,1.0,
What are the manager name and district of the shop that sells the largest number of products?,"[shop.Manager_name, shop.District, shop.Number_products]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NESTED,"SELECT Manager_name, District FROM shop WHERE Number_products = (SELECT MAX(Number_products) FROM shop);","SELECT manager_name ,  district FROM shop ORDER BY number_products DESC LIMIT 1",employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the manager name and district of the shop. Use the FROM clause to specify the shop table. Apply a WHERE clause to filter for the shop with the largest number of products. 2. Condition Structure: Use a WHERE clause with a subquery to filter for the shop with the maximum number of products. 3. Join Structure: Not required, as all the necessary data is available in the shop table. 4. Aggregation Structure: Use MAX in a subquery to find the maximum number of products and filter based on this value to retrieve the relevant shop details.","[('Ilkka Mäkelä', 'Lahden Stadion')]","[('Ilkka Mäkelä', 'Lahden Stadion')]",,1.0,
What is the total count of teachers?,[teacher.Teacher_ID],"Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,SELECT COUNT(teacher.Teacher_ID) AS total_teachers FROM teacher;,SELECT count(*) FROM teacher,course_teach,"1. Sequential Structure: Start with the SELECT clause to count the total number of teachers. 2. Condition Structure: No specific filtering condition is required since we want the total count of all teachers. 3. Join Structure: No JOIN is necessary as the required information is available in the ""teacher"" table. 4. Aggregation Structure: Use COUNT on ""teacher.Teacher_ID"" to calculate the total number of teachers.","[(7,)]","[(7,)]",,1.0,
What are the different template type codes?,[Ref_Template_Types.Template_Type_Code],"Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,SELECT DISTINCT Ref_Template_Types.Template_Type_Code FROM Ref_Template_Types;,SELECT DISTINCT template_type_code FROM Templates,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Template_Type_Code"" from the ""Ref_Template_Types"" table. 2. Condition Structure: No specific filtering condition is required as we want all distinct template type codes. 3. Join Structure: No JOIN is necessary since the required information is available within the ""Ref_Template_Types"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique template type codes are retrieved.","[('AD',), ('BK',), ('CV',), ('PP',), ('PPT',)]","[('PP',), ('BK',), ('PPT',), ('AD',), ('CV',)]",,1.0,
"Return the name, location and district of all shops in descending order of number of products.","[shop.Name, shop.Location, shop.District, shop.Number_products]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,"SELECT shop.Name, shop.Location, shop.District FROM shop ORDER BY shop.Number_products DESC;","SELECT name ,  LOCATION ,  district FROM shop ORDER BY number_products DESC",employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""shop.Name"", ""shop.Location"", and ""shop.District"" fields, as well as the ""shop.Number_products"" for ordering purposes. 2. Condition Structure: No specific filtering condition is required since we want all shops. 3. Join Structure: No JOIN is required since all necessary information is available in the ""shop"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in descending order based on ""shop.Number_products"".","[('FC Lahti', 'Lahti', 'Lahden Stadion'), ('HJK', 'Helsinki', 'Finnair Stadium'), ('FC Inter', 'Turku', 'Veritas Stadion'), ('FC Honka', 'Espoo', 'Tapiolan Urheilupuisto'), ('FF Jaro', 'Jakobstad', 'Jakobstads Centralplan'), ('FC KooTeePee', 'Kotka', 'Arto Tolsa Areena'), ('FC Haka', 'Valkeakoski', 'Tehtaan kenttä'), ('KuPS', 'Kuopio', 'Magnum Areena'), ('IFK Mariehamn', 'Mariehamn', 'Wiklöf Holding Arena')]","[('FC Lahti', 'Lahti', 'Lahden Stadion'), ('HJK', 'Helsinki', 'Finnair Stadium'), ('FC Inter', 'Turku', 'Veritas Stadion'), ('FC Honka', 'Espoo', 'Tapiolan Urheilupuisto'), ('FF Jaro', 'Jakobstad', 'Jakobstads Centralplan'), ('FC KooTeePee', 'Kotka', 'Arto Tolsa Areena'), ('FC Haka', 'Valkeakoski', 'Tehtaan kenttä'), ('KuPS', 'Kuopio', 'Magnum Areena'), ('IFK Mariehamn', 'Mariehamn', 'Wiklöf Holding Arena')]",,1.0,
How many different store locations are there?,[shop.Location],"Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,SELECT COUNT(DISTINCT shop.Location) AS unique_locations FROM shop;,SELECT count(DISTINCT LOCATION) FROM shop,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to count the distinct store locations. 2. Condition Structure: No specific filtering condition is required as we want to count all unique locations. 3. Join Structure: No JOIN is necessary since all the required data is available in the ""shop"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""shop.Location"" to count the number of unique store locations.","[(9,)]","[(9,)]",,1.0,
Show all distinct template type codes for all templates.,"[Templates.Template_Type_Code, Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT DISTINCT Templates.Template_Type_Code FROM Templates;,SELECT DISTINCT template_type_code FROM Templates,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct ""Template_Type_Code"" from the ""Templates"" table. 2. Condition Structure: No specific filtering condition is required as the question asks for all template type codes. 3. Join Structure: No JOIN is necessary because the required data is available directly in the ""Templates"" table. 4. Aggregation Structure: Use DISTINCT to ensure that only unique template type codes are returned.","[('PP',), ('BK',), ('PPT',), ('AD',), ('CV',)]","[('PP',), ('BK',), ('PPT',), ('AD',), ('CV',)]",,1.0,
How many templates do we have?,[Templates.Template_ID],"Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,SELECT COUNT(Templates.Template_ID) AS total_templates FROM Templates;,SELECT count(*) FROM Templates,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the number of templates, as the question asks for the total number of templates. 2. Condition Structure: No specific filtering condition is required since we want the total count of all templates. 3. Join Structure: No JOIN is necessary because the required information is available within the ""Templates"" table. 4. Aggregation Structure: Use COUNT on ""Templates.Template_ID"" to calculate the total number of templates.","[(20,)]","[(20,)]",,1.0,
Show ids for all templates that are used by more than one document.,"[Templates.Template_ID,Documents.Template_ID,Documents.Template_ID = Templates.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Templates.Template_ID FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID GROUP BY Templates.Template_ID HAVING COUNT(Documents.Template_ID) > 1;,SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Templates.Template_ID"" for templates used by more than one document. 2. Condition Structure: Use a HAVING clause to filter templates that are associated with more than one document. 3. Join Structure: Use an INNER JOIN between the ""Documents"" and ""Templates"" tables on ""Documents.Template_ID = Templates.Template_ID"" to link documents with their respective templates. 4. Aggregation Structure: Use COUNT on ""Documents.Template_ID"" to count the number of documents associated with each template, then filter with HAVING to select templates with a count greater than one.","[(11,), (14,), (25,)]","[(11,), (14,), (25,)]",,1.0,
Count the number of documents that use the PPT template type.,"[Documents.Document_ID,Documents.Template_ID = Templates.Template_ID,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Ref_Template_Types.Template_Type_Description,PPT]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT COUNT(Documents.Document_ID) FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code WHERE Ref_Template_Types.Template_Type_Description = 'PPT';,SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT',cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the number of documents. Use COUNT on ""Documents.Document_ID"" to get the total number of documents. 2. Condition Structure: Use a WHERE clause to filter for documents that use the ""PPT"" template type. This requires filtering on ""Ref_Template_Types.Template_Type_Description"" for the value ""PPT."" 3. Join Structure: Use JOINs to connect the ""Documents"" table with the ""Templates"" table on ""Documents.Template_ID = Templates.Template_ID,"" and then connect the ""Templates"" table with the ""Ref_Template_Types"" table on ""Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code."" 4. Aggregation Structure: Use COUNT to aggregate the total number of documents that meet the specified condition.","[(0,)]","[(3,)]",,0.0,
What are the ids of templates with template type code PP or PPT?,"[Templates.Template_ID,Templates.Template_Type_Code,Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code,PP,PPT]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Templates.Template_ID FROM Templates WHERE Templates.Template_Type_Code = 'PP' OR Templates.Template_Type_Code = 'PPT';,"SELECT template_id FROM Templates WHERE template_type_code  =  ""PP"" OR template_type_code  =  ""PPT""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Templates.Template_ID"" as the question asks for the IDs of templates. 2. Condition Structure: Use a WHERE clause to filter for records where ""Templates.Template_Type_Code"" is either 'PP' or 'PPT'. 3. Join Structure: No JOIN is required here since the filtering condition directly applies to the ""Templates"" table. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific template IDs based on the condition.","[(0,), (1,), (6,), (7,), (10,), (18,), (22,), (24,), (25,)]","[(0,), (1,), (6,), (7,), (10,), (18,), (22,), (24,), (25,)]",,1.0,
Show all template type codes that are not used by any document.,"[Ref_Template_Types.Template_Type_Code,Templates.Template_Type_Code,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID,Templates.Template_ID = Documents.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NESTED,SELECT Ref_Template_Types.Template_Type_Code FROM Ref_Template_Types WHERE Ref_Template_Types.Template_Type_Code NOT IN ( SELECT Templates.Template_Type_Code FROM Templates JOIN Documents ON Templates.Template_ID = Documents.Template_ID );,SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve all template type codes from the Ref_Template_Types table. Use the FROM clause to specify the Ref_Template_Types table. Apply a WHERE clause to filter template type codes that are not used by any document. 2. Condition Structure: Use the WHERE clause with a subquery to exclude template type codes that are associated with any document. The subquery retrieves all template type codes from the Templates table that are linked to documents via the Documents table. 3. Join Structure: Use the relationship between Templates and Documents to identify template type codes that are used by documents. The subquery ensures that only unused template type codes are selected. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('CV',)]","[('CV',)]",,1.0,
"Return the type code of the template type with the description ""Book"".","[Ref_Template_Types.Template_Type_Code,Ref_Template_Types.Template_Type_Description,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Book]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Ref_Template_Types.Template_Type_Code FROM Ref_Template_Types WHERE Ref_Template_Types.Template_Type_Description = 'Book';,"SELECT template_type_code FROM Ref_template_types WHERE template_type_description  =  ""Book""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Template_Type_Code"" from the ""Ref_Template_Types"" table. 2. Condition Structure: Use a WHERE clause to filter for the ""Template_Type_Description"" that matches ""Book."" 3. Join Structure: No JOIN is required since the required information is available in the ""Ref_Template_Types"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('BK',)]","[('BK',)]",,1.0,
Find the districts in which there are both shops selling less than 3000 products and shops selling more than 10000 products.,"[shop.District, shop.Number_products]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NESTED,SELECT District FROM shop WHERE Number_products < 3000 OR Number_products > 10000 GROUP BY District HAVING COUNT(CASE WHEN Number_products < 3000 THEN 1 END) > 0 AND COUNT(CASE WHEN Number_products > 10000 THEN 1 END) > 0;,SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct districts. Use the FROM clause to specify the shop table. Apply a WHERE clause to filter districts that have shops selling less than 3000 products and shops selling more than 10000 products. Use a GROUP BY clause to group by district and a HAVING clause to ensure both conditions are met. 2. Condition Structure: Use the WHERE clause to filter shops based on the number of products (less than 3000 or more than 10000). Use the HAVING clause to ensure that both conditions are satisfied within the same district. 3. Join Structure: Not required, as all data is available within the shop table. 4. Aggregation Structure: Use COUNT(*) in the HAVING clause to ensure that there are shops meeting both conditions in the same district.",[],[],,1.0,
Count the number of employees,[employee.Employee_ID],"Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,SELECT COUNT(employee.Employee_ID) AS total_employees FROM employee;,SELECT count(*) FROM employee,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to count the number of employees. 2. Condition Structure: No specific filtering condition is required as we want to count all employees. 3. Join Structure: No JOIN is required since the information is available in the ""employee"" table. 4. Aggregation Structure: Use COUNT on ""employee.Employee_ID"" to calculate the total number of employees.","[(10,)]","[(10,)]",,1.0,
Count the number of different templates used for documents.,"[Documents.Template_ID,Templates.Template_ID,Templates.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT COUNT(DISTINCT Templates.Template_ID) FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID;,SELECT count(DISTINCT template_id) FROM Documents,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""Templates.Template_ID"" since we are interested in the number of different templates used for documents. 2. Condition Structure: No specific filtering condition is required as the question asks for all templates used for documents. 3. Join Structure: Use a JOIN between the ""Documents"" and ""Templates"" tables based on ""Documents.Template_ID = Templates.Template_ID"" to link documents with their respective templates. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique templates used.","[(12,)]","[(12,)]",,1.0,
Find the name of the shops that do not hire any employee.,"[shop.Name, hiring.Shop_ID, shop.Shop_ID = hiring.Shop_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NESTED,SELECT Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM hiring);,SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring),employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of shops. Use the FROM clause to specify the shop table. Apply a WHERE clause to filter shops that do not hire any employees by ensuring their Shop_ID is not present in the hiring table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude shops whose Shop_ID appears in the hiring table, meaning they have hired employees. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Shop_ID entries in the hiring table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('FC Honka',), ('KuPS',), ('IFK Mariehamn',)]","[('FC Honka',), ('KuPS',), ('IFK Mariehamn',)]",,1.0,
What are the ids of documents that contain the paragraph text 'Brazil' and 'Ireland'?,"[Paragraphs.Paragraph_Text,Paragraphs.Document_ID,Documents.Document_ID = Paragraphs.Document_ID,'Brazil','Ireland']","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NESTED,"SELECT Document_ID FROM Paragraphs WHERE Paragraph_Text IN ('Brazil', 'Ireland') GROUP BY Document_ID HAVING COUNT(DISTINCT Paragraph_Text) = 2;",SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland',cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the document IDs. Use the FROM clause to specify the Paragraphs table, as it contains the paragraph text and document ID. Apply a WHERE clause to filter for paragraphs containing the text 'Brazil' and 'Ireland'. Use GROUP BY to group by document ID and HAVING to ensure both texts are present in the same document. 2. Condition Structure: Use the WHERE clause to filter for paragraph text containing 'Brazil' or 'Ireland'. Use the HAVING clause to ensure that both texts are associated with the same document ID. 3. Join Structure: Not required, as all necessary data is available in the Paragraphs table. 4. Aggregation Structure: Use COUNT with HAVING to ensure that both 'Brazil' and 'Ireland' are present for a document ID.","[(16514113,)]","[(16514113,)]",,1.0,
What are the minimum and maximum number of products across all the shops?,[shop.Number_products],"Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,"SELECT MIN(shop.Number_products) AS min_products, MAX(shop.Number_products) AS max_products FROM shop;","SELECT min(Number_products) ,  max(Number_products) FROM shop",employee_hire_evaluation,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the minimum and maximum number of products. 2. Aggregation Structure: Use MIN and MAX functions to calculate the minimum and maximum number of products across all shops. 3. Join Structure: No JOIN is required since all necessary data is within the ""shop"" table. 4. Condition Structure: No specific filtering condition is needed as the query requires data from all shops.","[(1600, 15000)]","[(1600, 15000)]",,1.0,
What is the document id with least number of paragraphs?,"[Paragraphs.Document_ID, Documents.Document_ID = Paragraphs.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Paragraphs.Document_ID FROM Paragraphs GROUP BY Paragraphs.Document_ID ORDER BY COUNT(Paragraphs.Paragraph_ID) ASC LIMIT 1;,SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_ID"" with the least number of paragraphs. Use COUNT to count the number of paragraphs for each document. 2. Condition Structure: No specific filtering condition is required, as we are interested in all documents. 3. Join Structure: No JOIN is necessary since the relevant data is within the ""Paragraphs"" table. 4. Aggregation Structure: Use GROUP BY on ""Paragraphs.Document_ID"" to group the paragraphs by document. Use ORDER BY with COUNT in ascending order to rank documents by the number of paragraphs, and LIMIT 1 to get the document with the least number of paragraphs.","[(3,)]","[(3,)]",,1.0,
Count the number of employees for each city.,"[employee.City, employee.Employee_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,"SELECT employee.City, COUNT(employee.Employee_ID) AS employee_count FROM employee GROUP BY employee.City;","SELECT count(*) ,  city FROM employee GROUP BY city",employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to specify the city and the count of employees. 2. Aggregation Structure: Use COUNT to calculate the number of employees for each city. 3. Grouping Structure: Use GROUP BY on ""employee.City"" to group the results by each city. 4. Join Structure: No JOIN is required since all necessary data is within the ""employee"" table.","[('Bath', 3), ('Bristol', 3), ('Leicester', 1), ('Sale', 1), ('Wasps', 2)]","[(3, 'Bath'), (3, 'Bristol'), (1, 'Leicester'), (1, 'Sale'), (2, 'Wasps')]",,1.0,
What are the ids of documents that have 2 or more paragraphs?,"[Documents.Document_ID,Paragraphs.Document_ID,Paragraphs.Document_ID = Documents.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Documents.Document_ID FROM Documents JOIN Paragraphs ON Paragraphs.Document_ID = Documents.Document_ID GROUP BY Documents.Document_ID HAVING COUNT(Paragraphs.Paragraph_ID) >= 2;,SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*)  >=  2,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Documents.Document_ID"" for documents that meet the condition. Use GROUP BY to group the results by ""Documents.Document_ID."" 2. Condition Structure: Use a HAVING clause to filter for documents that have 2 or more paragraphs. This is achieved by counting the number of ""Paragraphs.Paragraph_ID"" for each document. 3. Join Structure: Use an INNER JOIN between the ""Documents"" and ""Paragraphs"" tables based on the foreign key relationship ""Paragraphs.Document_ID = Documents.Document_ID."" 4. Aggregation Structure: Use COUNT on ""Paragraphs.Paragraph_ID"" to count the number of paragraphs for each document, and apply the HAVING clause to filter for counts greater than or equal to 2.","[(80,), (2394,), (651512,), (16514113,)]","[(80,), (2394,), (651512,), (16514113,)]",,1.0,
How many employees are there?,[employee.Employee_ID],"Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,SELECT COUNT(employee.Employee_ID) AS total_employees FROM employee;,SELECT count(*) FROM employee,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to count the number of employees. 2. Condition Structure: No specific filtering condition is required as we want the total count of employees. 3. Join Structure: No JOIN is required since all necessary information is in the ""employee"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of employees based on the ""employee.Employee_ID"".","[(10,)]","[(10,)]",,1.0,
"What are the ids and names of each document, as well as the number of paragraphs in each?","[Documents.Document_ID,Documents.Document_Name,Paragraphs.Document_ID = Documents.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Documents.Document_ID, Documents.Document_Name, COUNT(Paragraphs.Paragraph_ID) AS Paragraph_Count FROM Documents JOIN Paragraphs ON Paragraphs.Document_ID = Documents.Document_ID GROUP BY Documents.Document_ID, Documents.Document_Name;","SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Documents.Document_ID,"" ""Documents.Document_Name,"" and the count of paragraphs for each document. Use COUNT on ""Paragraphs.Paragraph_ID"" to count the number of paragraphs. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Documents"" and ""Paragraphs"" tables on ""Paragraphs.Document_ID = Documents.Document_ID"" to associate each document with its paragraphs. 4. Aggregation Structure: Use COUNT to calculate the number of paragraphs for each document and GROUP BY ""Documents.Document_ID"" and ""Documents.Document_Name"" to group the results by document.","[(3, 'Summer Show', 1), (80, 'Welcome to NY', 2), (2394, 'Customer reviews', 3), (3830, 'Do not panic', 1), (33930, 'How Google people work', 1), (50123, 'Learning French', 1), (651512, 'How to write a CV', 2), (3540024, 'Palm reading', 1), (16514113, 'A history of Arts', 2), (385906526, 'About Korea', 1)]","[(3, 'Summer Show', 1), (80, 'Welcome to NY', 2), (2394, 'Customer reviews', 3), (3830, 'Do not panic', 1), (33930, 'How Google people work', 1), (50123, 'Learning French', 1), (651512, 'How to write a CV', 2), (3540024, 'Palm reading', 1), (16514113, 'A history of Arts', 2), (385906526, 'About Korea', 1)]",,1.0,
What is the document id with 1 to 2 paragraphs?,"[Paragraphs.Document_ID,Documents.Document_ID = Paragraphs.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Paragraphs.Document_ID FROM Paragraphs GROUP BY Paragraphs.Document_ID HAVING COUNT(Paragraphs.Paragraph_ID) BETWEEN 1 AND 2;,SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paragraphs.Document_ID"" since we are interested in the document IDs. Use GROUP BY to group the paragraphs by their associated document IDs. 2. Condition Structure: Apply a HAVING clause to filter for documents that have between 1 and 2 paragraphs. This requires counting the number of paragraphs per document. 3. Join Structure: No explicit JOIN is needed as the ""Paragraphs"" table already contains the ""Document_ID"" field. 4. Aggregation Structure: Use COUNT on ""Paragraphs.Paragraph_ID"" to count the number of paragraphs for each document, and filter the results using the HAVING clause.","[(3,), (80,), (3830,), (33930,), (50123,), (651512,), (3540024,), (16514113,), (385906526,)]","[(3,), (80,), (3830,), (33930,), (50123,), (651512,), (3540024,), (16514113,), (385906526,)]",,1.0,
"Show template ids, version numbers, and template type codes for all templates.","[Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code FROM Templates;","SELECT template_id ,  version_number ,  template_type_code FROM Templates",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Templates.Template_ID"", ""Templates.Version_Number"", and ""Templates.Template_Type_Code"". 2. Condition Structure: No specific filtering condition is required as the query asks for all templates. 3. Join Structure: No JOIN is required since all the necessary data is within the ""Templates"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the specified fields.","[(0, 5, 'PP'), (1, 9, 'PP'), (4, 4, 'BK'), (6, 2, 'PPT'), (7, 8, 'PPT'), (8, 3, 'BK'), (9, 2, 'BK'), (10, 1, 'PPT'), (11, 6, 'BK'), (14, 7, 'AD'), (15, 9, 'CV'), (16, 5, 'CV'), (18, 5, 'PP'), (19, 7, 'AD'), (20, 6, 'BK'), (21, 9, 'AD'), (22, 0, 'PP'), (23, 2, 'BK'), (24, 8, 'PP'), (25, 5, 'PP')]","[(0, 5, 'PP'), (1, 9, 'PP'), (4, 4, 'BK'), (6, 2, 'PPT'), (7, 8, 'PPT'), (8, 3, 'BK'), (9, 2, 'BK'), (10, 1, 'PPT'), (11, 6, 'BK'), (14, 7, 'AD'), (15, 9, 'CV'), (16, 5, 'CV'), (18, 5, 'PP'), (19, 7, 'AD'), (20, 6, 'BK'), (21, 9, 'AD'), (22, 0, 'PP'), (23, 2, 'BK'), (24, 8, 'PP'), (25, 5, 'PP')]",,1.0,
Find the names of employees who never won any award in the evaluation.,"[employee.Name,employee.Employee_ID,evaluation.Employee_ID = employee.Employee_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NESTED,SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation);,SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation),employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of employees. Use the FROM clause to specify the employee table. Apply a WHERE clause to filter employees who never won any award by ensuring their Employee_ID is not present in the evaluation table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude employees whose Employee_ID appears in the evaluation table, indicating they have won an award. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Employee_ID entries in the evaluation table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Mark Regan',), ('Tim Payne',), ('Andrew Sheridan',), ('Phil Vickery',), ('Steve Borthwick',)]","[('Mark Regan',), ('Tim Payne',), ('Andrew Sheridan',), ('Phil Vickery',), ('Steve Borthwick',)]",,1.0,
find the name of employee who was awarded the most times in the evaluation.,"[employee.Name, evaluation.Employee_ID, evaluation.Year_awarded, evaluation.Employee_ID = employee.Employee_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NON-NESTED,SELECT employee.Name FROM employee JOIN evaluation ON evaluation.Employee_ID = employee.Employee_ID GROUP BY employee.Name ORDER BY COUNT(evaluation.Year_awarded) DESC LIMIT 1;,SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID GROUP BY t2.Employee_ID ORDER BY count(*) DESC LIMIT 1,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""employee.Name"" of the employee who was awarded the most times. Use COUNT on ""evaluation.Year_awarded"" to count the number of awards for each employee. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the employee with the highest count of awards. 3. Join Structure: Use a JOIN between the ""employee"" and ""evaluation"" tables based on ""evaluation.Employee_ID = employee.Employee_ID"" to associate each employee with their evaluation records. 4. Aggregation Structure: Use COUNT to calculate the number of awards for each employee, GROUP BY ""employee.Name"" to group the results by employee, and ORDER BY the count in descending order. Use LIMIT 1 to select the employee with the highest count.","[('George Chuter',)]","[('George Chuter',)]",,1.0,
Which district has both stores with less than 3000 products and stores with more than 10000 products?,"[shop.District, shop.Number_products]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NESTED,SELECT District FROM shop GROUP BY District HAVING COUNT(CASE WHEN Number_products < 3000 THEN 1 END) > 0 AND COUNT(CASE WHEN Number_products > 10000 THEN 1 END) > 0;,SELECT district FROM shop WHERE Number_products  <  3000 INTERSECT SELECT district FROM shop WHERE Number_products  >  10000,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the district names. Use the FROM clause to specify the shop table. Apply a WHERE clause to filter districts that have stores with less than 3000 products and stores with more than 10000 products. Use GROUP BY to group by district and HAVING to ensure both conditions are met. 2. Condition Structure: Use the HAVING clause with COUNT(*) to ensure that a district has at least one store with less than 3000 products and at least one store with more than 10000 products. 3. Join Structure: Not required, as all data is available within the shop table. 4. Aggregation Structure: Use COUNT(*) in the HAVING clause to check for the existence of stores meeting the specified conditions within each district.",[],[],,1.0,
Count the number of templates.,[Templates.Template_ID],"Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,SELECT COUNT(Templates.Template_ID) AS template_count FROM Templates;,SELECT count(*) FROM Templates,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the number of templates. 2. Aggregation Structure: Use the COUNT function on ""Templates.Template_ID"" to calculate the total number of templates. 3. Condition Structure: No specific filtering condition is required as we want to count all templates. 4. Join Structure: No JOIN is necessary since the required information is available within the ""Templates"" table.","[(20,)]","[(20,)]",,1.0,
Return the version numbers and template type codes of templates with a version number greater than 5.,"[Templates.Version_Number, Templates.Template_Type_Code, Templates.Version_Number > 5]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT Templates.Version_Number, Templates.Template_Type_Code FROM Templates WHERE Templates.Version_Number > 5;","SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Templates.Version_Number"" and ""Templates.Template_Type_Code"" fields. 2. Condition Structure: Use a WHERE clause to filter templates where ""Templates.Version_Number"" is greater than 5. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Templates"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving fields based on a specific condition.","[(9, 'PP'), (8, 'PPT'), (6, 'BK'), (7, 'AD'), (9, 'CV'), (7, 'AD'), (6, 'BK'), (9, 'AD'), (8, 'PP')]","[(9, 'PP'), (8, 'PPT'), (6, 'BK'), (7, 'AD'), (9, 'CV'), (7, 'AD'), (6, 'BK'), (9, 'AD'), (8, 'PP')]",,1.0,
"List document IDs, document names, and document descriptions for all documents.","[Documents.Document_ID, Documents.Document_Name, Documents.Document_Description]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT Documents.Document_ID, Documents.Document_Name, Documents.Document_Description FROM Documents;","SELECT document_id ,  document_name ,  document_description FROM Documents",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Documents.Document_ID,"" ""Documents.Document_Name,"" and ""Documents.Document_Description."" 2. Condition Structure: No specific filtering condition is required as the query asks for all documents. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Documents"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the specified fields for all documents.","[(0, 'Introduction of OS', 'n'), (1, 'Understanding DB', 'y'), (3, 'Summer Show', 'u'), (76, 'Robbin CV', 'y'), (80, 'Welcome to NY', 'h'), (82, 'Data base', 'w'), (2394, 'Customer reviews', 'y'), (3830, 'Do not panic', 'k'), (33930, 'How Google people work', 'z'), (50123, 'Learning French', 'r'), (651512, 'How to write a CV', 'f'), (801801, 'How to read a book', 'w'), (3540024, 'Palm reading', 'y'), (16514113, 'A history of Arts', 'h'), (385906526, 'About Korea', 'b')]","[(0, 'Introduction of OS', 'n'), (1, 'Understanding DB', 'y'), (3, 'Summer Show', 'u'), (76, 'Robbin CV', 'y'), (80, 'Welcome to NY', 'h'), (82, 'Data base', 'w'), (2394, 'Customer reviews', 'y'), (3830, 'Do not panic', 'k'), (33930, 'How Google people work', 'z'), (50123, 'Learning French', 'r'), (651512, 'How to write a CV', 'f'), (801801, 'How to read a book', 'w'), (3540024, 'Palm reading', 'y'), (16514113, 'A history of Arts', 'h'), (385906526, 'About Korea', 'b')]",,1.0,
"What is the document id, template id and description for document named ""Robbin CV""?","[Documents.Document_ID,Documents.Template_ID,Documents.Document_Description,Documents.Document_Name,""Robbin CV""]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT Documents.Document_ID, Documents.Template_ID, Documents.Document_Description FROM Documents WHERE Documents.Document_Name = 'Robbin CV';","SELECT document_id ,  template_id ,  Document_Description FROM Documents WHERE document_name  =  ""Robbin CV""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_ID"", ""Template_ID"", and ""Document_Description"" for the document named ""Robbin CV"". 2. Condition Structure: Use a WHERE clause to filter for the document where ""Document_Name"" is equal to ""Robbin CV"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Documents"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.","[(76, 20, 'y')]","[(76, 20, 'y')]",,1.0,
Which employee received the biggest bonus? Give me the employee name.,"[employee.Name, evaluation.Bonus, evaluation.Employee_ID = employee.Employee_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NON-NESTED,SELECT employee.Name FROM employee JOIN evaluation ON evaluation.Employee_ID = employee.Employee_ID WHERE evaluation.Bonus = (SELECT MAX(evaluation.Bonus) FROM evaluation);,SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID ORDER BY t2.bonus DESC LIMIT 1,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""employee.Name"" of the employee who received the biggest bonus. 2. Condition Structure: No specific filtering condition is needed, but we need to identify the maximum bonus. Use a subquery to find the maximum bonus and filter the employee(s) who received it. 3. Join Structure: Use a JOIN between the ""evaluation"" and ""employee"" tables based on ""evaluation.Employee_ID = employee.Employee_ID"" to associate bonuses with employee names. 4. Aggregation Structure: Use MAX in a subquery to determine the highest bonus, and then filter the main query to match this bonus.","[('Louis Deacon',)]","[('Louis Deacon',)]",,1.0,
What is the id and type code for the template used by the most documents?,"[Templates.Template_ID,Templates.Template_Type_Code,Documents.Template_ID,Documents.Document_ID = Paragraphs.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Templates.Template_ID, Templates.Template_Type_Code FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID GROUP BY Templates.Template_ID, Templates.Template_Type_Code ORDER BY COUNT(Documents.Document_ID) DESC LIMIT 1;","SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Templates.Template_ID"" and ""Templates.Template_Type_Code."" Use COUNT to count the number of documents associated with each template. 2. Condition Structure: No specific filtering condition is required, as we are interested in all templates. 3. Join Structure: Use a JOIN between ""Documents"" and ""Templates"" on ""Documents.Template_ID = Templates.Template_ID"" to associate documents with their respective templates. 4. Aggregation Structure: Use COUNT to count the number of documents for each template. Use GROUP BY on ""Templates.Template_ID"" and ""Templates.Template_Type_Code"" to group the results by template. Use ORDER BY in descending order of the document count and LIMIT 1 to get the template used by the most documents.","[(11, 'BK')]","[(25, 'PP')]",,0.0,
What are the ids for templates that are not used in any documents?,"[Templates.Template_ID,Documents.Template_ID,Templates.Template_ID = Documents.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NESTED,SELECT Template_ID FROM Templates WHERE Template_ID NOT IN (SELECT Template_ID FROM Documents);,SELECT template_id FROM Templates EXCEPT SELECT template_id FROM Documents,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the template IDs from the Templates table. Use the FROM clause to specify the Templates table. Apply a WHERE clause to filter for template IDs that are not present in the Documents table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude template IDs that appear in the Documents table, ensuring we only get template IDs that are not used in any documents. 3. Join Structure: Not required, as we only need to filter based on the absence of matching template IDs in the Documents table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[(0,), (9,), (15,), (16,), (18,), (19,), (23,), (24,)]","[(0,), (9,), (15,), (16,), (18,), (19,), (23,), (24,)]",,1.0,
Show all paragraph ids and texts for the document with name 'Welcome to NY'.,"[Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text, Documents.Document_Name, Paragraphs.Document_ID = Documents.Document_ID, Documents.Document_Name = 'Welcome to NY']","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text FROM Paragraphs JOIN Documents ON Paragraphs.Document_ID = Documents.Document_ID WHERE Documents.Document_Name = 'Welcome to NY';","SELECT T1.paragraph_id ,   T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.Document_Name  =  'Welcome to NY'",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Paragraphs.Paragraph_ID"" and ""Paragraphs.Paragraph_Text."" 2. Condition Structure: Use a WHERE clause to filter for the document with the name ""Welcome to NY."" 3. Join Structure: Use a JOIN between the ""Paragraphs"" and ""Documents"" tables based on ""Paragraphs.Document_ID = Documents.Document_ID"" to link paragraphs to their respective documents. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific paragraph details.","[(16615, 'Japan'), (608931827, 'Micronesia')]","[(16615, 'Japan'), (608931827, 'Micronesia')]",,1.0,
How many shops are there in each location?,"[shop.Location, shop.Shop_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,"SELECT shop.Location, COUNT(shop.Shop_ID) AS shop_count FROM shop GROUP BY shop.Location;","SELECT count(*) ,  LOCATION FROM shop GROUP BY LOCATION",employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the location and the count of shops. 2. Aggregation Structure: Use COUNT to calculate the number of shops in each location. 3. Grouping Structure: Use GROUP BY on ""shop.Location"" to count shops for each location. 4. Join Structure: No JOIN is required since all necessary data is within the ""shop"" table.","[('Espoo', 1), ('Helsinki', 1), ('Jakobstad', 1), ('Kotka', 1), ('Kuopio', 1), ('Lahti', 1), ('Mariehamn', 1), ('Turku', 1), ('Valkeakoski', 1)]","[(1, 'Espoo'), (1, 'Helsinki'), (1, 'Jakobstad'), (1, 'Kotka'), (1, 'Kuopio'), (1, 'Lahti'), (1, 'Mariehamn'), (1, 'Turku'), (1, 'Valkeakoski')]",,1.0,
What are the details for the paragraph that includes the text 'Korea ' ?,"[Paragraphs.Paragraph_Text,Paragraphs.Other_Details,Paragraphs.Document_ID = Documents.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Paragraphs.Other_Details FROM Paragraphs WHERE Paragraphs.Paragraph_Text LIKE '%Korea%';,select other_details from paragraphs where paragraph_text like 'korea',cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the required details, specifically ""Paragraphs.Other_Details"" and any other relevant fields. 2. Condition Structure: Use a WHERE clause to filter for paragraphs where ""Paragraphs.Paragraph_Text"" contains the text 'Korea'. 3. Join Structure: No JOIN is required since all the necessary information is available in the ""Paragraphs"" table. 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving specific paragraph details.","[(None,), (None,)]","[(None,), (None,)]",,1.0,
Return the type code of the template type that the most templates belong to.,"[Templates.Template_Type_Code, Ref_Template_Types.Template_Type_Code, Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Template_Type_Code FROM Templates GROUP BY Template_Type_Code ORDER BY COUNT(*) DESC LIMIT 1;,SELECT template_type_code FROM Templates GROUP BY template_type_code ORDER BY count(*) DESC LIMIT 1,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Template_Type_Code"" of the template type. Use COUNT to count the number of templates for each type. Use ORDER BY in descending order to rank the template types by the number of templates. Use LIMIT 1 to get the template type with the most templates. 2. Condition Structure: No specific filtering condition is required as we are considering all templates. 3. Join Structure: No JOIN is necessary since the required data is available in the ""Templates"" table. 4. Aggregation Structure: Use COUNT to count the number of templates for each ""Template_Type_Code"" and GROUP BY ""Template_Type_Code"" to group the results by template type.","[('PP',)]","[('PP',)]",,1.0,
Which employee received the most awards in evaluations? Give me the employee name.,"[employee.Name, evaluation.Employee_ID, evaluation.Year_awarded, evaluation.Employee_ID = employee.Employee_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NON-NESTED,SELECT employee.Name FROM employee JOIN evaluation ON evaluation.Employee_ID = employee.Employee_ID GROUP BY employee.Name ORDER BY COUNT(evaluation.Year_awarded) DESC LIMIT 1;,SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID GROUP BY t2.Employee_ID ORDER BY count(*) DESC LIMIT 1,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""employee.Name"" of the employee who received the most awards. Use COUNT on ""evaluation.Year_awarded"" to count the number of awards for each employee. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the employee with the highest count of awards. 3. Join Structure: Use a JOIN between the ""employee"" and ""evaluation"" tables based on ""evaluation.Employee_ID = employee.Employee_ID"" to associate each award with the corresponding employee. 4. Aggregation Structure: Use COUNT to calculate the number of awards for each employee, GROUP BY ""employee.Name"" to group the results by employee, and ORDER BY the count in descending order to rank employees by the number of awards. Use LIMIT 1 to select the employee with the most awards.","[('George Chuter',)]","[('George Chuter',)]",,1.0,
Show the document id with paragraph text 'Brazil' and 'Ireland'.,"[Paragraphs.Document_ID,Paragraphs.Paragraph_Text,Documents.Document_ID = Paragraphs.Document_ID,Brazil,Ireland]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Paragraphs.Document_ID FROM Paragraphs WHERE Paragraphs.Paragraph_Text IN ('Brazil', 'Ireland') GROUP BY Paragraphs.Document_ID HAVING COUNT(DISTINCT Paragraphs.Paragraph_Text) = 2;",SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Brazil' INTERSECT SELECT document_id FROM Paragraphs WHERE paragraph_text  =  'Ireland',cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Paragraphs.Document_ID"" as the question asks for document IDs. 2. Condition Structure: Use a WHERE clause to filter for records where ""Paragraphs.Paragraph_Text"" contains both 'Brazil' and 'Ireland'. This requires grouping by ""Paragraphs.Document_ID"" and using a HAVING clause to ensure both conditions are met. 3. Join Structure: No JOIN is required as the necessary data is available in the ""Paragraphs"" table. 4. Aggregation Structure: Use GROUP BY on ""Paragraphs.Document_ID"" and COUNT with a HAVING clause to ensure that both 'Brazil' and 'Ireland' are present for the same document ID.","[(16514113,)]","[(16514113,)]",,1.0,
"Show all document ids, names and the number of paragraphs in each document.","[Documents.Document_ID, Documents.Document_Name, Paragraphs.Document_ID = Documents.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Documents.Document_ID, Documents.Document_Name, COUNT(Paragraphs.Paragraph_ID) AS Paragraph_Count FROM Documents JOIN Paragraphs ON Paragraphs.Document_ID = Documents.Document_ID GROUP BY Documents.Document_ID, Documents.Document_Name;","SELECT T1.document_id ,  T2.document_name ,  count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Documents.Document_ID,"" ""Documents.Document_Name,"" and the count of paragraphs in each document. Use COUNT on ""Paragraphs.Paragraph_ID"" to count the number of paragraphs. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Documents"" and ""Paragraphs"" tables on ""Paragraphs.Document_ID = Documents.Document_ID"" to associate each document with its paragraphs. 4. Aggregation Structure: Use COUNT to aggregate the number of paragraphs for each document and GROUP BY ""Documents.Document_ID"" and ""Documents.Document_Name"" to group the results by document.","[(3, 'Summer Show', 1), (80, 'Welcome to NY', 2), (2394, 'Customer reviews', 3), (3830, 'Do not panic', 1), (33930, 'How Google people work', 1), (50123, 'Learning French', 1), (651512, 'How to write a CV', 2), (3540024, 'Palm reading', 1), (16514113, 'A history of Arts', 2), (385906526, 'About Korea', 1)]","[(3, 'Summer Show', 1), (80, 'Welcome to NY', 2), (2394, 'Customer reviews', 3), (3830, 'Do not panic', 1), (33930, 'How Google people work', 1), (50123, 'Learning French', 1), (651512, 'How to write a CV', 2), (3540024, 'Palm reading', 1), (16514113, 'A history of Arts', 2), (385906526, 'About Korea', 1)]",,1.0,
"What is the template type code of the template used by document with the name ""Data base""?","[Documents.Document_Name,Documents.Template_ID,Templates.Template_ID = Documents.Template_ID,Templates.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Templates.Template_Type_Code FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID WHERE Documents.Document_Name = 'Data base';,"SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  ""Data base""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Templates.Template_Type_Code."" 2. Condition Structure: Use a WHERE clause to filter for the document with the name ""Data base."" 3. Join Structure: Use an INNER JOIN to connect the ""Documents"" table with the ""Templates"" table based on the ""Template_ID"" field. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('BK',)]","[('BK',)]",,1.0,
"Return the lowest version number, along with its corresponding template type code.","[Templates.Version_Number, Templates.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT MIN(Templates.Version_Number) AS lowest_version, Templates.Template_Type_Code FROM Templates;","SELECT min(Version_Number) ,  template_type_code FROM Templates",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the lowest version number and its corresponding template type code. 2. Aggregation Structure: Use the MIN function to find the lowest version number. 3. Grouping Structure: No GROUP BY is required since we are only retrieving the lowest version number and its associated template type code. 4. Join Structure: No JOIN is required as all necessary information is available in the ""Templates"" table. 5. Condition Structure: No specific filtering condition is needed as we are looking for the minimum version number across all records.","[(0, 'PP')]","[(0, 'PP')]",,1.0,
"Return the document id, template id, and description for the document with the name Robbin CV.","[Documents.Document_ID,Documents.Template_ID,Documents.Document_Description,Documents.Document_Name,Documents.Document_Name = 'Robbin CV']","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT Documents.Document_ID, Documents.Template_ID, Documents.Document_Description FROM Documents WHERE Documents.Document_Name = 'Robbin CV';","SELECT document_id ,  template_id ,  Document_Description FROM Documents WHERE document_name  =  ""Robbin CV""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_ID"", ""Template_ID"", and ""Document_Description"" fields from the ""Documents"" table. 2. Condition Structure: Use a WHERE clause to filter for the document with the name ""Robbin CV"". 3. Join Structure: No JOIN is required since all necessary information is available in the ""Documents"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.","[(76, 20, 'y')]","[(76, 20, 'y')]",,1.0,
"What are the ids, names, and descriptions for all documents?","[Documents.Document_ID, Documents.Document_Name, Documents.Document_Description]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT Documents.Document_ID, Documents.Document_Name, Documents.Document_Description FROM Documents;","SELECT document_id ,  document_name ,  document_description FROM Documents",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Documents.Document_ID"", ""Documents.Document_Name"", and ""Documents.Document_Description"". 2. Condition Structure: No specific filtering condition is required as the query asks for all documents. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Documents"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all documents.","[(0, 'Introduction of OS', 'n'), (1, 'Understanding DB', 'y'), (3, 'Summer Show', 'u'), (76, 'Robbin CV', 'y'), (80, 'Welcome to NY', 'h'), (82, 'Data base', 'w'), (2394, 'Customer reviews', 'y'), (3830, 'Do not panic', 'k'), (33930, 'How Google people work', 'z'), (50123, 'Learning French', 'r'), (651512, 'How to write a CV', 'f'), (801801, 'How to read a book', 'w'), (3540024, 'Palm reading', 'y'), (16514113, 'A history of Arts', 'h'), (385906526, 'About Korea', 'b')]","[(0, 'Introduction of OS', 'n'), (1, 'Understanding DB', 'y'), (3, 'Summer Show', 'u'), (76, 'Robbin CV', 'y'), (80, 'Welcome to NY', 'h'), (82, 'Data base', 'w'), (2394, 'Customer reviews', 'y'), (3830, 'Do not panic', 'k'), (33930, 'How Google people work', 'z'), (50123, 'Learning French', 'r'), (651512, 'How to write a CV', 'f'), (801801, 'How to read a book', 'w'), (3540024, 'Palm reading', 'y'), (16514113, 'A history of Arts', 'h'), (385906526, 'About Korea', 'b')]",,1.0,
What are the codes of template types that have fewer than 3 templates?,"[Ref_Template_Types.Template_Type_Code,Templates.Template_Type_Code,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NESTED,SELECT Ref_Template_Types.Template_Type_Code FROM Ref_Template_Types JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code GROUP BY Ref_Template_Types.Template_Type_Code HAVING COUNT(*) < 3;,SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3,cre_Doc_Template_Mgt,1. Sequential Structure: Start with the SELECT clause to retrieve the template type codes. Use the FROM clause to specify the Ref_Template_Types table and join it with the Templates table to link template types with their templates. Use GROUP BY to group records by template type code and COUNT to count the number of templates for each type. Apply a HAVING clause to filter template types with fewer than 3 templates. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for template types that have fewer than 3 templates. 3. Join Structure: Use an INNER JOIN between the Ref_Template_Types and Templates tables based on Template_Type_Code to connect template types with their templates. 4. Aggregation Structure: Use COUNT(*) to count the number of templates for each template type and filter based on this count.,"[('CV',)]","[('CV',)]",,1.0,
Sort employee names by their age in ascending order.,"[employee.Name, employee.Age]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,SELECT employee.Name FROM employee ORDER BY employee.Age ASC;,SELECT name FROM employee ORDER BY age,employee_hire_evaluation,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the employee name. Include the age for sorting purposes. 2. Condition Structure: No specific filtering condition is required as we want all employees. 3. Join Structure: No JOIN is required since all necessary data is within the ""employee"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in ascending order based on ""employee.Age"".","[('George Chuter',), ('Andrew Sheridan',), ('Lee Mears',), ('Tim Payne',), ('Matt Stevens',), ('Jason Hobson',), ('Steve Borthwick',), ('Louis Deacon',), ('Phil Vickery',), ('Mark Regan',)]","[('George Chuter',), ('Andrew Sheridan',), ('Lee Mears',), ('Tim Payne',), ('Matt Stevens',), ('Jason Hobson',), ('Steve Borthwick',), ('Louis Deacon',), ('Phil Vickery',), ('Mark Regan',)]",,1.0,
Show all template type codes with less than three templates.,"[Templates.Template_Type_Code, Templates.Template_ID, Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NESTED,SELECT Template_Type_Code FROM Templates GROUP BY Template_Type_Code HAVING COUNT(Template_ID) < 3;,SELECT template_type_code FROM Templates GROUP BY template_type_code HAVING count(*)  <  3,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the template type codes. Use the FROM clause to specify the Templates table. Apply a GROUP BY clause to group records by Template_Type_Code, and use the HAVING clause to filter groups with less than three templates. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for template type codes that have fewer than three templates. 3. Join Structure: Not required, as all necessary data is available in the Templates table. 4. Aggregation Structure: Use COUNT(*) to count the number of templates for each Template_Type_Code and filter based on this count.","[('CV',)]","[('CV',)]",,1.0,
How many paragraphs in total?,[Paragraphs.Paragraph_ID],"Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,SELECT COUNT(Paragraphs.Paragraph_ID) AS total_paragraphs FROM Paragraphs;,SELECT count(*) FROM Paragraphs,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the total number of paragraphs. 2. Aggregation Structure: Use the COUNT function on ""Paragraphs.Paragraph_ID"" to calculate the total number of paragraphs. 3. Condition Structure: No specific filtering condition is required as we want the total count of all paragraphs. 4. Join Structure: No JOIN is required since the necessary data is within the ""Paragraphs"" table.","[(15,)]","[(15,)]",,1.0,
Find the name of the employee who got the highest one time bonus.,"[employee.Name, evaluation.Bonus, evaluation.Employee_ID = employee.Employee_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NON-NESTED,SELECT employee.Name FROM employee JOIN evaluation ON evaluation.Employee_ID = employee.Employee_ID WHERE evaluation.Bonus = (SELECT MAX(evaluation.Bonus) FROM evaluation);,SELECT t1.name FROM employee AS t1 JOIN evaluation AS t2 ON t1.Employee_ID  =  t2.Employee_ID ORDER BY t2.bonus DESC LIMIT 1,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""employee.Name"" of the employee with the highest one-time bonus. Use the MAX function on ""evaluation.Bonus"" to identify the highest bonus. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the maximum bonus across all employees. 3. Join Structure: Use a JOIN between the ""employee"" and ""evaluation"" tables based on ""evaluation.Employee_ID = employee.Employee_ID"" to associate each bonus with the corresponding employee. 4. Aggregation Structure: Use MAX to find the highest bonus and filter the employee(s) who received it.","[('Louis Deacon',)]","[('Louis Deacon',)]",,1.0,
List all document ids with at least two paragraphs.,"[Documents.Document_ID,Paragraphs.Document_ID,Paragraphs.Document_ID = Documents.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Documents.Document_ID FROM Documents JOIN Paragraphs ON Paragraphs.Document_ID = Documents.Document_ID GROUP BY Documents.Document_ID HAVING COUNT(Paragraphs.Paragraph_ID) >= 2;,SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*)  >=  2,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Documents.Document_ID."" Use GROUP BY to group the results by ""Documents.Document_ID."" 2. Condition Structure: Use a HAVING clause to filter for document IDs that have at least two paragraphs. 3. Join Structure: Use an INNER JOIN between the ""Documents"" and ""Paragraphs"" tables based on the relationship ""Paragraphs.Document_ID = Documents.Document_ID."" 4. Aggregation Structure: Use COUNT on ""Paragraphs.Paragraph_ID"" to count the number of paragraphs for each document, and filter with HAVING to include only those with at least two paragraphs.","[(80,), (2394,), (651512,), (16514113,)]","[(80,), (2394,), (651512,), (16514113,)]",,1.0,
Show all template type codes and number of templates for each.,"[Ref_Template_Types.Template_Type_Code, Templates.Template_Type_Code, Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Ref_Template_Types.Template_Type_Code, COUNT(Templates.Template_ID) AS Number_of_Templates FROM Ref_Template_Types JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code GROUP BY Ref_Template_Types.Template_Type_Code;","SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Ref_Template_Types.Template_Type_Code"" and the count of templates for each type. Use COUNT to count the number of templates. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between ""Ref_Template_Types"" and ""Templates"" on ""Template_Type_Code"" to associate each template type with its templates. 4. Aggregation Structure: Use COUNT to count the number of templates for each template type and GROUP BY ""Ref_Template_Types.Template_Type_Code"" to group the results by template type code.","[('AD', 3), ('BK', 6), ('CV', 2), ('PP', 6), ('PPT', 3)]","[('AD', 3), ('BK', 6), ('CV', 2), ('PP', 6), ('PPT', 3)]",,1.0,
Show ids for all templates not used by any document.,"[Templates.Template_ID,Documents.Template_ID,Templates.Template_ID != Documents.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NESTED,SELECT Template_ID FROM Templates WHERE Template_ID NOT IN (SELECT Template_ID FROM Documents);,SELECT template_id FROM Templates EXCEPT SELECT template_id FROM Documents,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the Template_IDs from the Templates table. Use the FROM clause to specify the Templates table. Apply a WHERE clause to filter for templates that are not used by any document. 2. Condition Structure: Use the WHERE clause with a subquery to exclude Template_IDs that appear in the Documents table, ensuring we only get templates not used by any document. 3. Join Structure: Not required, as the filtering is based on the absence of Template_IDs in the Documents table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[(0,), (9,), (15,), (16,), (18,), (19,), (23,), (24,)]","[(0,), (9,), (15,), (16,), (18,), (19,), (23,), (24,)]",,1.0,
Return the names and template ids for documents that contain the letter w in their description.,"[Documents.Document_Name,Documents.Template_ID,Documents.Document_Description]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT Documents.Document_Name, Documents.Template_ID FROM Documents WHERE Documents.Document_Description LIKE '%w%';","SELECT document_name ,  template_id FROM Documents WHERE Document_Description LIKE ""%w%""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Document_Name"" and ""Template_ID"" from the ""Documents"" table. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for documents whose ""Document_Description"" contains the letter 'w'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Documents"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving document names and template IDs based on a specific condition.","[('Data base', 11), ('How to read a book', 4)]","[('Data base', 11), ('How to read a book', 4)]",,1.0,
Find the names of stores whose number products is more than the average number of products.,"[shop.Name, shop.Number_products]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NESTED,SELECT Name FROM shop WHERE Number_products > (SELECT AVG(Number_products) FROM shop);,SELECT name FROM shop WHERE number_products  >  (SELECT avg(number_products) FROM shop),employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of stores. Use the FROM clause to specify the shop table. Apply a WHERE clause to filter stores whose number of products is greater than the average number of products. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average number of products across all stores and filter stores with a number of products exceeding this value. 3. Join Structure: Not required, as all data is in the shop table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average number of products.","[('HJK',), ('FC Inter',), ('FC Lahti',)]","[('HJK',), ('FC Inter',), ('FC Lahti',)]",,1.0,
Give me all the information about hiring.,"[hiring.Shop_ID, hiring.Employee_ID, hiring.Start_from, hiring.Is_full_time]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,SELECT * FROM hiring;,SELECT * FROM hiring,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve all columns from the ""hiring"" table, as the question asks for all information about hiring. 2. Condition Structure: No specific filtering condition is required since the query requests all information. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""hiring"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves all rows and columns from the ""hiring"" table.","[(1, 1, '2009', 'T'), (1, 2, '2003', 'T'), (8, 3, '2011', 'F'), (4, 4, '2012', 'T'), (5, 5, '2013', 'T'), (2, 6, '2010', 'F'), (6, 7, '2008', 'T')]","[(1, 1, '2009', 'T'), (1, 2, '2003', 'T'), (8, 3, '2011', 'F'), (4, 4, '2012', 'T'), (5, 5, '2013', 'T'), (2, 6, '2010', 'F'), (6, 7, '2008', 'T')]",,1.0,
"What are the ids, version numbers, and type codes for each template?","[Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT Templates.Template_ID, Templates.Version_Number, Templates.Template_Type_Code FROM Templates;","SELECT template_id ,  version_number ,  template_type_code FROM Templates",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Templates.Template_ID"", ""Templates.Version_Number"", and ""Templates.Template_Type_Code"". 2. Condition Structure: No specific filtering condition is required as the query asks for all templates. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Templates"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all templates.","[(0, 5, 'PP'), (1, 9, 'PP'), (4, 4, 'BK'), (6, 2, 'PPT'), (7, 8, 'PPT'), (8, 3, 'BK'), (9, 2, 'BK'), (10, 1, 'PPT'), (11, 6, 'BK'), (14, 7, 'AD'), (15, 9, 'CV'), (16, 5, 'CV'), (18, 5, 'PP'), (19, 7, 'AD'), (20, 6, 'BK'), (21, 9, 'AD'), (22, 0, 'PP'), (23, 2, 'BK'), (24, 8, 'PP'), (25, 5, 'PP')]","[(0, 5, 'PP'), (1, 9, 'PP'), (4, 4, 'BK'), (6, 2, 'PPT'), (7, 8, 'PPT'), (8, 3, 'BK'), (9, 2, 'BK'), (10, 1, 'PPT'), (11, 6, 'BK'), (14, 7, 'AD'), (15, 9, 'CV'), (16, 5, 'CV'), (18, 5, 'PP'), (19, 7, 'AD'), (20, 6, 'BK'), (21, 9, 'AD'), (22, 0, 'PP'), (23, 2, 'BK'), (24, 8, 'PP'), (25, 5, 'PP')]",,1.0,
Return the id of the document with the fewest paragraphs.,"[Documents.Document_ID,Paragraphs.Document_ID,Paragraphs.Document_ID = Documents.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Documents.Document_ID FROM Documents JOIN Paragraphs ON Documents.Document_ID = Paragraphs.Document_ID GROUP BY Documents.Document_ID ORDER BY COUNT(Paragraphs.Paragraph_ID) ASC LIMIT 1;,SELECT document_id FROM Paragraphs GROUP BY document_id ORDER BY count(*) ASC LIMIT 1,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Documents.Document_ID"" of the document with the fewest paragraphs. Use COUNT to count the number of paragraphs for each document. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all documents. 3. Join Structure: Use an INNER JOIN between the ""Documents"" and ""Paragraphs"" tables on ""Documents.Document_ID = Paragraphs.Document_ID"" to associate each document with its paragraphs. 4. Aggregation Structure: Use COUNT to count the number of paragraphs for each document, GROUP BY ""Documents.Document_ID"" to group the counts by document, and ORDER BY the count in ascending order to find the document with the fewest paragraphs. Use LIMIT 1 to return only the document with the fewest paragraphs.","[(3,)]","[(3,)]",,1.0,
How many documents do we have?,[Documents.Document_ID],"Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,SELECT COUNT(Documents.Document_ID) AS total_documents FROM Documents;,SELECT count(*) FROM Documents,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the number of documents. 2. Condition Structure: No specific filtering condition is required as we want the total count of all documents. 3. Join Structure: No JOIN is required since the information is available in the ""Documents"" table. 4. Aggregation Structure: Use COUNT on ""Documents.Document_ID"" to calculate the total number of documents.","[(15,)]","[(15,)]",,1.0,
What are the age and hometown of teachers?,"[teacher.Age, teacher.Hometown]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,"SELECT teacher.Age, teacher.Hometown FROM teacher;","SELECT Age ,  Hometown FROM teacher",course_teach,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""teacher.Age"" and ""teacher.Hometown"". 2. Condition Structure: No specific filtering condition is required as the query asks for all teachers' ages and hometowns. 3. Join Structure: No JOIN is required since all necessary information is available in the ""teacher"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all teachers.","[('32', 'Blackrod Urban District'), ('29', 'Bolton County Borough'), ('26', 'Farnworth Municipal Borough'), ('33', 'Horwich Urban District'), ('45', 'Kearsley Urban District'), ('41', 'Little Lever Urban District'), ('39', 'Turton Urban District')]","[('32', 'Blackrod Urban District'), ('29', 'Bolton County Borough'), ('26', 'Farnworth Municipal Borough'), ('33', 'Horwich Urban District'), ('45', 'Kearsley Urban District'), ('41', 'Little Lever Urban District'), ('39', 'Turton Urban District')]",,1.0,
What the smallest version number and its template type code?,"[Templates.Version_Number, Templates.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT MIN(Templates.Version_Number) AS smallest_version, Templates.Template_Type_Code FROM Templates;","SELECT min(Version_Number) ,  template_type_code FROM Templates",cre_Doc_Template_Mgt,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the smallest version number and its corresponding template type code. 2. Aggregation Structure: Use the MIN function to find the smallest version number. 3. Grouping Structure: No GROUP BY is required since we are only interested in the smallest version number and its associated template type code. 4. Join Structure: No JOIN is required as all necessary data is within the ""Templates"" table. 5. Condition Structure: No specific filtering condition is needed as we are retrieving the smallest version number and its template type code.","[(0, 'PP')]","[(0, 'PP')]",,1.0,
Which shops' number products is above the average? Give me the shop names.,"[shop.Name, shop.Number_products]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NESTED,SELECT Name FROM shop WHERE Number_products > (SELECT AVG(Number_products) FROM shop);,SELECT name FROM shop WHERE number_products  >  (SELECT avg(number_products) FROM shop),employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of shops. Use the FROM clause to specify the shop table. Apply a WHERE clause to filter shops whose number of products is above the average. 2. Condition Structure: Use the WHERE clause with a subquery to compare the number of products for each shop against the average number of products across all shops. 3. Join Structure: Not required, as all data is in the shop table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average number of products, which is then used in the filtering condition.","[('HJK',), ('FC Inter',), ('FC Lahti',)]","[('HJK',), ('FC Inter',), ('FC Lahti',)]",,1.0,
How many documents are using the template with type code 'PPT'?,"[Documents.Document_ID,Templates.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,'PPT']","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT COUNT(Documents.Document_ID) FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code WHERE Templates.Template_Type_Code = 'PPT';,SELECT count(*) FROM Documents AS T1 JOIN Templates AS T2 ON T1.Template_ID  =  T2.Template_ID WHERE T2.Template_Type_Code  =  'PPT',cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the number of documents using the specified template type code. Use COUNT on ""Documents.Document_ID"" to get the total number of documents. 2. Condition Structure: Use a WHERE clause to filter for templates with the type code 'PPT.' 3. Join Structure: Use JOINs to connect ""Documents"" with ""Templates"" on ""Documents.Template_ID = Templates.Template_ID"" and ""Templates"" with ""Ref_Template_Types"" on ""Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code"" to link documents with their respective template type codes. 4. Aggregation Structure: Use COUNT to aggregate the total number of documents that meet the specified condition.","[(3,)]","[(3,)]",,1.0,
How many teachers are there?,[teacher.Teacher_ID],"Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,SELECT COUNT(teacher.Teacher_ID) AS total_teachers FROM teacher;,SELECT count(*) FROM teacher,course_teach,"1. Sequential Structure: Start with the SELECT clause to count the number of teachers. 2. Condition Structure: No specific filtering condition is required since we want the total count of teachers. 3. Join Structure: No JOIN is necessary as the required information is available in the ""teacher"" table. 4. Aggregation Structure: Use COUNT on ""teacher.Teacher_ID"" to calculate the total number of teachers.","[(7,)]","[(7,)]",,1.0,
Count the number of templates of the type CV.,"[Templates.Template_Type_Code,Ref_Template_Types.Template_Type_Description,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,CV]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT COUNT(Templates.Template_ID) FROM Templates JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code WHERE Ref_Template_Types.Template_Type_Description = 'CV';,"SELECT count(*) FROM Templates WHERE template_type_code  =  ""CV""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the number of templates. Use COUNT on ""Templates.Template_ID"" to get the total number of templates. 2. Condition Structure: Use a WHERE clause to filter for templates of the type ""CV."" This requires filtering based on ""Ref_Template_Types.Template_Type_Description."" 3. Join Structure: Use an INNER JOIN between the ""Templates"" table and the ""Ref_Template_Types"" table on ""Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code"" to associate templates with their type descriptions. 4. Aggregation Structure: Use COUNT to aggregate the total number of templates matching the specified type.","[(2,)]","[(2,)]",,1.0,
What are the template ids of any templates used in more than a single document?,"[Templates.Template_ID, Documents.Template_ID, Documents.Template_ID = Templates.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Templates.Template_ID FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID GROUP BY Templates.Template_ID HAVING COUNT(Documents.Template_ID) > 1;,SELECT template_id FROM Documents GROUP BY template_id HAVING count(*)  >  1,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Templates.Template_ID"" for templates used in more than one document. 2. Condition Structure: Use a HAVING clause to filter templates that are associated with more than one document. 3. Join Structure: Use an INNER JOIN between the ""Documents"" table and the ""Templates"" table on ""Documents.Template_ID = Templates.Template_ID"" to link documents with their respective templates. 4. Aggregation Structure: Use COUNT on ""Documents.Template_ID"" to count the number of documents associated with each template, then filter with HAVING to select templates used in more than one document.","[(11,), (14,), (25,)]","[(11,), (14,), (25,)]",,1.0,
"What are all different template ids used for documents, and how many times were each of them used?","[Documents.Template_ID, Templates.Template_ID = Documents.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Documents.Template_ID, COUNT(*) AS Usage_Count FROM Documents GROUP BY Documents.Template_ID;","SELECT template_id ,  count(*) FROM Documents GROUP BY template_id",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Template_ID"" from the ""Documents"" table and count how many times each ""Template_ID"" is used. 2. Condition Structure: No specific filtering condition is required, as we need to consider all documents. 3. Join Structure: No JOIN is necessary because the required data is available in the ""Documents"" table. 4. Aggregation Structure: Use COUNT to count the occurrences of each ""Template_ID"" and GROUP BY ""Template_ID"" to group the results by each unique template ID.","[(1, 1), (4, 1), (6, 1), (7, 1), (8, 1), (10, 1), (11, 2), (14, 2), (20, 1), (21, 1), (22, 1), (25, 2)]","[(1, 1), (4, 1), (6, 1), (7, 1), (8, 1), (10, 1), (11, 2), (14, 2), (20, 1), (21, 1), (22, 1), (25, 2)]",,1.0,
What are the distinct template type descriptions for the templates ever used by any document?,"[Ref_Template_Types.Template_Type_Description,Templates.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT DISTINCT Ref_Template_Types.Template_Type_Description FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code;,SELECT DISTINCT T1.template_type_description FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code JOIN Documents AS T3 ON T2.Template_ID  =  T3.template_ID,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct ""Ref_Template_Types.Template_Type_Description."" 2. Condition Structure: No specific filtering condition is required since we are interested in all template type descriptions used by any document. 3. Join Structure: Use JOINs to connect the ""Documents"" table with the ""Templates"" table on ""Documents.Template_ID = Templates.Template_ID"" and the ""Templates"" table with the ""Ref_Template_Types"" table on ""Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code."" 4. Aggregation Structure: Use DISTINCT to ensure that only unique template type descriptions are returned.","[('Presentation',), ('Paper',), ('Book',), ('Advertisement',)]","[('Presentation',), ('Paper',), ('Book',), ('Advertisement',)]",,1.0,
"What is the template type descriptions for template type code ""AD"".","[Ref_Template_Types.Template_Type_Description,Ref_Template_Types.Template_Type_Code,AD]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,SELECT Ref_Template_Types.Template_Type_Description FROM Ref_Template_Types WHERE Ref_Template_Types.Template_Type_Code = 'AD';,"SELECT template_type_description FROM Ref_template_types WHERE template_type_code  =  ""AD""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Ref_Template_Types.Template_Type_Description"" for the given template type code. 2. Condition Structure: Use a WHERE clause to filter for the specific ""Ref_Template_Types.Template_Type_Code"" equal to ""AD"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Ref_Template_Types"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('Advertisement',)]","[('Advertisement',)]",,1.0,
Show all template ids and number of documents using each template.,"[Templates.Template_ID, Documents.Template_ID, Documents.Template_ID = Templates.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Templates.Template_ID, COUNT(Documents.Document_ID) AS Number_of_Documents FROM Templates JOIN Documents ON Templates.Template_ID = Documents.Template_ID GROUP BY Templates.Template_ID;","SELECT template_id ,  count(*) FROM Documents GROUP BY template_id",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Templates.Template_ID"" and the count of documents using each template. Use COUNT on ""Documents.Document_ID"" to count the number of documents for each template. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Templates"" and ""Documents"" tables on ""Templates.Template_ID = Documents.Template_ID"" to associate templates with their respective documents. 4. Aggregation Structure: Use GROUP BY on ""Templates.Template_ID"" to group the results by each template ID and apply COUNT to calculate the number of documents for each template.","[(1, 1), (4, 1), (6, 1), (7, 1), (8, 1), (10, 1), (11, 2), (14, 2), (20, 1), (21, 1), (22, 1), (25, 2)]","[(1, 1), (4, 1), (6, 1), (7, 1), (8, 1), (10, 1), (11, 2), (14, 2), (20, 1), (21, 1), (22, 1), (25, 2)]",,1.0,
"What are the different template type codes, and how many documents use each type?","[Ref_Template_Types.Template_Type_Code,Templates.Template_Type_Code,Documents.Template_ID,Templates.Template_ID,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Ref_Template_Types.Template_Type_Code, COUNT(Documents.Document_ID) AS Document_Count FROM Ref_Template_Types JOIN Templates ON Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code JOIN Documents ON Templates.Template_ID = Documents.Template_ID GROUP BY Ref_Template_Types.Template_Type_Code;","SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Template_Type_Code"" and the count of documents using each type. Use COUNT to count the number of documents for each template type. 2. Condition Structure: No specific filtering condition is required, as we need data for all template type codes. 3. Join Structure: Use JOINs to connect ""Ref_Template_Types"" with ""Templates"" on ""Template_Type_Code"" and ""Templates"" with ""Documents"" on ""Template_ID"" to associate template types with their respective documents. 4. Aggregation Structure: Use COUNT to count the number of documents for each template type and GROUP BY ""Template_Type_Code"" to group the results by template type.","[('AD', 3), ('BK', 5), ('PP', 4), ('PPT', 3)]","[('AD', 3), ('BK', 5), ('PP', 4), ('PPT', 3)]",,1.0,
Count the number of documents.,[Documents.Document_ID],"Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,SELECT COUNT(Documents.Document_ID) AS document_count FROM Documents;,SELECT count(*) FROM Documents,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the number of documents. 2. Condition Structure: No specific filtering condition is required as we want the total count of documents. 3. Join Structure: No JOIN is necessary since the required information is available within the ""Documents"" table. 4. Aggregation Structure: Use COUNT on ""Documents.Document_ID"" to calculate the total number of documents.","[(15,)]","[(15,)]",,1.0,
Return the id and type code of the template that is used for the greatest number of documents.,"[Templates.Template_ID,Templates.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Documents.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Templates.Template_ID, Templates.Template_Type_Code FROM Templates JOIN Documents ON Documents.Template_ID = Templates.Template_ID GROUP BY Templates.Template_ID, Templates.Template_Type_Code ORDER BY COUNT(Documents.Document_ID) DESC LIMIT 1;","SELECT T1.template_id ,  T2.Template_Type_Code FROM Documents AS T1 JOIN Templates AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_id ORDER BY count(*) DESC LIMIT 1",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Templates.Template_ID"" and ""Templates.Template_Type_Code."" Use COUNT to count the number of documents associated with each template. 2. Condition Structure: No specific filtering condition is required as we are interested in all templates. 3. Join Structure: Use a JOIN between the ""Documents"" and ""Templates"" tables based on ""Documents.Template_ID = Templates.Template_ID"" to associate documents with their respective templates. 4. Aggregation Structure: Use COUNT to count the number of documents for each template. Use GROUP BY on ""Templates.Template_ID"" and ""Templates.Template_Type_Code"" to group the results by template. Use ORDER BY in descending order of the document count and LIMIT 1 to get the template with the greatest number of documents.","[(11, 'BK')]","[(25, 'PP')]",,0.0,
What are the ids and texts of paragraphs in the document titled 'Welcome to NY'?,"[Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text, Documents.Document_Name, Paragraphs.Document_ID = Documents.Document_ID, Documents.Template_ID = Templates.Template_ID, Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code, 'Welcome to NY']","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Paragraphs.Paragraph_ID, Paragraphs.Paragraph_Text FROM Paragraphs JOIN Documents ON Paragraphs.Document_ID = Documents.Document_ID WHERE Documents.Document_Name = 'Welcome to NY';","SELECT T1.paragraph_id ,   T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.Document_Name  =  'Welcome to NY'",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Paragraphs.Paragraph_ID"" and ""Paragraphs.Paragraph_Text."" 2. Condition Structure: Use a WHERE clause to filter for the document with the title ""Welcome to NY"" by matching ""Documents.Document_Name."" 3. Join Structure: Use a JOIN between ""Paragraphs"" and ""Documents"" on ""Paragraphs.Document_ID = Documents.Document_ID"" to link paragraphs to their respective documents. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific paragraph details.","[(16615, 'Japan'), (608931827, 'Micronesia')]","[(16615, 'Japan'), (608931827, 'Micronesia')]",,1.0,
List the names of employees and sort in ascending order of age.,"[employee.Name, employee.Age]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,"SELECT employee.Name, employee.Age FROM employee ORDER BY employee.Age ASC;",SELECT name FROM employee ORDER BY age,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""employee.Name"" and ""employee.Age"" fields. 2. Condition Structure: No specific filtering condition is required as we want all employees. 3. Join Structure: No JOIN is required since all necessary information is available in the ""employee"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in ascending order based on ""employee.Age"".","[('George Chuter', 23), ('Andrew Sheridan', 28), ('Lee Mears', 29), ('Tim Payne', 29), ('Matt Stevens', 29), ('Jason Hobson', 30), ('Steve Borthwick', 32), ('Louis Deacon', 36), ('Phil Vickery', 40), ('Mark Regan', 43)]","[('George Chuter',), ('Andrew Sheridan',), ('Lee Mears',), ('Tim Payne',), ('Matt Stevens',), ('Jason Hobson',), ('Steve Borthwick',), ('Louis Deacon',), ('Phil Vickery',), ('Mark Regan',)]",,1.0,
Show all template type codes and the number of documents using each type.,"[Ref_Template_Types.Template_Type_Code,Documents.Template_ID,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Ref_Template_Types.Template_Type_Code, COUNT(Documents.Document_ID) AS Document_Count FROM Ref_Template_Types JOIN Templates ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code JOIN Documents ON Documents.Template_ID = Templates.Template_ID GROUP BY Ref_Template_Types.Template_Type_Code;","SELECT T1.template_type_code ,  count(*) FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Ref_Template_Types.Template_Type_Code"" and the count of documents using each type. Use COUNT to count the number of documents. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect ""Ref_Template_Types"" with ""Templates"" on ""Template_Type_Code"" and ""Templates"" with ""Documents"" on ""Template_ID"" to link template types with their associated documents. 4. Aggregation Structure: Use COUNT to count the number of documents for each template type and GROUP BY ""Ref_Template_Types.Template_Type_Code"" to group the results by template type code.","[('AD', 3), ('BK', 5), ('PP', 4), ('PPT', 3)]","[('AD', 3), ('BK', 5), ('PP', 4), ('PPT', 3)]",,1.0,
What are the paragraph texts for the document with the name 'Customer reviews'?,"[Paragraphs.Paragraph_Text,Documents.Document_Name,Paragraphs.Document_ID = Documents.Document_ID,'Customer reviews']","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Paragraphs.Paragraph_Text FROM Paragraphs JOIN Documents ON Paragraphs.Document_ID = Documents.Document_ID WHERE Documents.Document_Name = 'Customer reviews';,"SELECT T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  ""Customer reviews""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Paragraphs.Paragraph_Text."" 2. Condition Structure: Use a WHERE clause to filter for the document with the name ""Customer reviews."" 3. Join Structure: Use a JOIN between the ""Paragraphs"" and ""Documents"" tables based on ""Paragraphs.Document_ID = Documents.Document_ID"" to link paragraphs to their respective documents. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific paragraph texts.","[('Korea',), ('Ukraine',), ('Korea',)]","[('Korea',), ('Ukraine',), ('Korea',)]",,1.0,
Which shops run with no employees? Find the shop names,"[shop.Name, hiring.Shop_ID, shop.Shop_ID = hiring.Shop_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NESTED,SELECT Name FROM shop WHERE Shop_ID NOT IN (SELECT Shop_ID FROM hiring);,SELECT name FROM shop WHERE shop_id NOT IN (SELECT shop_id FROM hiring),employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of shops. Use the FROM clause to specify the shop table. Apply a WHERE clause to filter shops that do not have any employees associated with them in the hiring table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude shops whose Shop_ID appears in the hiring table, meaning they have employees. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Shop_ID entries in the hiring table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('FC Honka',), ('KuPS',), ('IFK Mariehamn',)]","[('FC Honka',), ('KuPS',), ('IFK Mariehamn',)]",,1.0,
"Return the different document ids along with the number of paragraphs corresponding to each, ordered by id.","[Documents.Document_ID, Paragraphs.Document_ID, Paragraphs.Document_ID = Documents.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Documents.Document_ID, COUNT(Paragraphs.Paragraph_ID) AS Paragraph_Count FROM Documents JOIN Paragraphs ON Documents.Document_ID = Paragraphs.Document_ID GROUP BY Documents.Document_ID ORDER BY Documents.Document_ID;","SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Documents.Document_ID"" and the count of paragraphs for each document. Use COUNT on ""Paragraphs.Paragraph_ID"" to count the number of paragraphs. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Documents"" and ""Paragraphs"" tables on ""Documents.Document_ID = Paragraphs.Document_ID"" to link documents with their corresponding paragraphs. 4. Aggregation Structure: Use GROUP BY on ""Documents.Document_ID"" to group the results by each document ID. Apply ORDER BY on ""Documents.Document_ID"" to sort the results by document ID.","[(3, 1), (80, 2), (2394, 3), (3830, 1), (33930, 1), (50123, 1), (651512, 2), (3540024, 1), (16514113, 2), (385906526, 1)]","[(3, 1), (80, 2), (2394, 3), (3830, 1), (33930, 1), (50123, 1), (651512, 2), (3540024, 1), (16514113, 2), (385906526, 1)]",,1.0,
List the names of teachers in ascending order of age.,"[teacher.Name, teacher.Age]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,"SELECT teacher.Name, teacher.Age FROM teacher ORDER BY teacher.Age ASC;",SELECT Name FROM teacher ORDER BY Age ASC,course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Name"" and ""teacher.Age"" fields. 2. Condition Structure: No specific filtering condition is required as we want all teachers. 3. Join Structure: No JOIN is required since all necessary information is available in the ""teacher"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in ascending order based on ""teacher.Age"".","[('Vicente Carretero', '26'), ('Gustaaf Deloor', '29'), ('Joseph Huts', '32'), ('John Deloor', '33'), ('Lucy Wong', '39'), ('Anne Walker', '41'), ('Kearsley Brown', '45')]","[('Vicente Carretero',), ('Gustaaf Deloor',), ('Joseph Huts',), ('John Deloor',), ('Lucy Wong',), ('Anne Walker',), ('Kearsley Brown',)]",,1.0,
Count the number of distinct store locations.,[shop.Location],"Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,SELECT COUNT(DISTINCT shop.Location) AS distinct_locations FROM shop;,SELECT count(DISTINCT LOCATION) FROM shop,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to count the number of distinct store locations. 2. Condition Structure: No specific filtering condition is required as we are counting all distinct locations. 3. Join Structure: No JOIN is required since all necessary information is in the ""shop"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""shop.Location"" to count the unique store locations.","[(9,)]","[(9,)]",,1.0,
Show all document names using templates with template type code BK.,"[Documents.Document_Name,Templates.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,BK]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Documents.Document_Name FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code WHERE Templates.Template_Type_Code = 'BK';,"SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T1.template_type_code  =  ""BK""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Documents.Document_Name."" 2. Condition Structure: Use a WHERE clause to filter for records where ""Templates.Template_Type_Code"" is 'BK.' 3. Join Structure: Use JOINs to connect ""Documents"" with ""Templates"" on ""Documents.Template_ID = Templates.Template_ID"" and ""Templates"" with ""Ref_Template_Types"" on ""Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code."" 4. Aggregation Structure: No aggregation is needed as the query only retrieves document names.","[('Robbin CV',), ('Data base',), ('How to read a book',), ('Palm reading',), ('About Korea',)]","[('Robbin CV',), ('Data base',), ('How to read a book',), ('Palm reading',), ('About Korea',)]",,1.0,
Return the template type description of the template type with the code AD.,"[Ref_Template_Types.Template_Type_Description,Ref_Template_Types.Template_Type_Code,AD]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,SELECT Ref_Template_Types.Template_Type_Description FROM Ref_Template_Types WHERE Ref_Template_Types.Template_Type_Code = 'AD';,"SELECT template_type_description FROM Ref_template_types WHERE template_type_code  =  ""AD""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Ref_Template_Types.Template_Type_Description"" for the template type with the specified code. 2. Condition Structure: Use a WHERE clause to filter for the template type code equal to 'AD'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Ref_Template_Types"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('Advertisement',)]","[('Advertisement',)]",,1.0,
What is the age and hometown of every teacher?,"[teacher.Age, teacher.Hometown]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,"SELECT teacher.Age, teacher.Hometown FROM teacher;","SELECT Age ,  Hometown FROM teacher",course_teach,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""teacher.Age"" and ""teacher.Hometown"". 2. Condition Structure: No specific filtering condition is required as the query asks for all teachers' ages and hometowns. 3. Join Structure: No JOIN is required since all necessary information is available in the ""teacher"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all teachers.","[('32', 'Blackrod Urban District'), ('29', 'Bolton County Borough'), ('26', 'Farnworth Municipal Borough'), ('33', 'Horwich Urban District'), ('45', 'Kearsley Urban District'), ('41', 'Little Lever Urban District'), ('39', 'Turton Urban District')]","[('32', 'Blackrod Urban District'), ('29', 'Bolton County Borough'), ('26', 'Farnworth Municipal Borough'), ('33', 'Horwich Urban District'), ('45', 'Kearsley Urban District'), ('41', 'Little Lever Urban District'), ('39', 'Turton Urban District')]",,1.0,
What is total bonus given in all evaluations?,[evaluation.Bonus],"Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,SELECT SUM(evaluation.Bonus) AS total_bonus FROM evaluation;,SELECT sum(bonus) FROM evaluation,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to specify the total bonus, which requires the use of the SUM function on the ""evaluation.Bonus"" field. 2. Condition Structure: No specific filtering condition is required since the query asks for the total bonus across all evaluations. 3. Join Structure: No JOIN is necessary as all the required data is available in the ""evaluation"" table. 4. Aggregation Structure: Use the SUM function to calculate the total bonus from the ""evaluation.Bonus"" field.","[(19500.0,)]","[(19500.0,)]",,1.0,
Return the ids corresponding to templates with the description 'Presentation'.,"[Templates.Template_ID,Ref_Template_Types.Template_Type_Description,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Presentation]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Templates.Template_ID FROM Templates JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code WHERE Ref_Template_Types.Template_Type_Description = 'Presentation';,"SELECT T2.template_id FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code WHERE T1.template_type_description  =  ""Presentation""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Templates.Template_ID"" as the question asks for template IDs. 2. Condition Structure: Use a WHERE clause to filter for templates where the ""Ref_Template_Types.Template_Type_Description"" is 'Presentation'. 3. Join Structure: Use an INNER JOIN to connect the ""Templates"" table with the ""Ref_Template_Types"" table based on the foreign key relationship ""Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code"". 4. Aggregation Structure: No aggregation is needed as the query only involves filtering and retrieving specific template IDs.","[(6,), (7,), (10,)]","[(6,), (7,), (10,)]",,1.0,
What is the document id and name with greatest number of paragraphs?,"[Documents.Document_ID, Documents.Document_Name, Paragraphs.Document_ID = Documents.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Documents.Document_ID, Documents.Document_Name FROM Documents JOIN Paragraphs ON Paragraphs.Document_ID = Documents.Document_ID GROUP BY Documents.Document_ID, Documents.Document_Name ORDER BY COUNT(Paragraphs.Paragraph_ID) DESC LIMIT 1;","SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Documents.Document_ID"" and ""Documents.Document_Name."" Additionally, count the number of paragraphs for each document using COUNT on ""Paragraphs.Paragraph_ID."" 2. Condition Structure: No specific filtering condition is required, as we are interested in all documents. 3. Join Structure: Use an INNER JOIN between the ""Documents"" and ""Paragraphs"" tables based on ""Paragraphs.Document_ID = Documents.Document_ID"" to associate each document with its paragraphs. 4. Aggregation Structure: Use COUNT to count the number of paragraphs for each document, GROUP BY ""Documents.Document_ID"" and ""Documents.Document_Name"" to group the results by document, and ORDER BY the count in descending order to rank documents by the number of paragraphs. Use LIMIT 1 to select the document with the greatest number of paragraphs.","[(2394, 'Customer reviews')]","[(2394, 'Customer reviews')]",,1.0,
What is the document name and template id for document with description with the letter 'w' in it?,"[Documents.Document_Name, Documents.Template_ID, Documents.Document_Description]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT Documents.Document_Name, Documents.Template_ID FROM Documents WHERE Documents.Document_Description LIKE '%w%';","SELECT document_name ,  template_id FROM Documents WHERE Document_Description LIKE ""%w%""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Documents.Document_Name"" and ""Documents.Template_ID"" for documents that meet the specified condition. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for documents where ""Documents.Document_Description"" contains the letter 'w'. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Documents"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.","[('Data base', 11), ('How to read a book', 4)]","[('Data base', 11), ('How to read a book', 4)]",,1.0,
What are the codes of template types that are not used for any document?,"[Ref_Template_Types.Template_Type_Code,Templates.Template_Type_Code,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID,Templates.Template_ID = Documents.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NESTED,SELECT Template_Type_Code FROM Ref_Template_Types WHERE Template_Type_Code NOT IN ( SELECT Templates.Template_Type_Code FROM Templates JOIN Documents ON Templates.Template_ID = Documents.Template_ID );,SELECT template_type_code FROM Templates EXCEPT SELECT template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the template type codes from the Ref_Template_Types table. Use the FROM clause to specify the Ref_Template_Types table. Apply a WHERE clause to filter template type codes that are not used in any document. 2. Condition Structure: Use a WHERE clause with a subquery to exclude template type codes that are associated with any document. The subquery retrieves all template type codes from the Templates table that are linked to documents via the Documents table. 3. Join Structure: Use the relationship between Templates.Template_ID and Documents.Template_ID to identify template type codes used in documents. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('CV',)]","[('CV',)]",,1.0,
Return the id and name of the document with the most paragraphs.,"[Documents.Document_ID,Documents.Document_Name,Paragraphs.Document_ID = Documents.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Documents.Document_ID, Documents.Document_Name FROM Documents JOIN Paragraphs ON Paragraphs.Document_ID = Documents.Document_ID GROUP BY Documents.Document_ID, Documents.Document_Name ORDER BY COUNT(Paragraphs.Paragraph_ID) DESC LIMIT 1;","SELECT T1.document_id ,  T2.document_name FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id GROUP BY T1.document_id ORDER BY count(*) DESC LIMIT 1",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Documents.Document_ID"" and ""Documents.Document_Name."" 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the document with the most paragraphs. 3. Join Structure: Use an INNER JOIN between the ""Documents"" and ""Paragraphs"" tables on ""Paragraphs.Document_ID = Documents.Document_ID"" to associate each document with its paragraphs. 4. Aggregation Structure: Use COUNT on ""Paragraphs.Paragraph_ID"" to count the number of paragraphs for each document. Use GROUP BY on ""Documents.Document_ID"" and ""Documents.Document_Name"" to group the results by document. Use ORDER BY in descending order on the count of paragraphs and LIMIT 1 to select the document with the most paragraphs.","[(2394, 'Customer reviews')]","[(2394, 'Customer reviews')]",,1.0,
find the minimum and maximum number of products of all stores.,[shop.Number_products],"Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,"SELECT MIN(shop.Number_products) AS min_products, MAX(shop.Number_products) AS max_products FROM shop;","SELECT min(Number_products) ,  max(Number_products) FROM shop",employee_hire_evaluation,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the minimum and maximum number of products. 2. Aggregation Structure: Use MIN and MAX functions to calculate the minimum and maximum number of products across all stores. 3. Grouping Structure: No GROUP BY is needed since the query is asking for the overall minimum and maximum values, not grouped by any specific field. 4. Join Structure: No JOIN is required since all necessary data is within the ""shop"" table.","[(1600, 15000)]","[(1600, 15000)]",,1.0,
Which airports do not have departing or arriving flights?,"[airports.AirportCode, flights.SourceAirport, flights.DestAirport, flights.SourceAirport = airports.AirportCode, flights.DestAirport = airports.AirportCode]","Table airlines, columns = [*,uid,Airline,Abbreviation,Country]
Table airports, columns = [*,City,AirportCode,AirportName,Country,CountryAbbrev]
Table flights, columns = [*,Airline,FlightNo,SourceAirport,DestAirport]
","Foreign_keys = [flights.DestAirport = airports.AirportCode,flights.SourceAirport = airports.AirportCode]
",NESTED,SELECT AirportCode FROM airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM flights) AND AirportCode NOT IN (SELECT DestAirport FROM flights);,SELECT AirportName FROM Airports WHERE AirportCode NOT IN (SELECT SourceAirport FROM Flights UNION SELECT DestAirport FROM Flights),flight_2,"1. Sequential Structure: Start with the SELECT clause to retrieve the airport codes from the airports table. Use the FROM clause to specify the airports table. Apply a WHERE clause to filter airports that do not have any departing or arriving flights. 2. Condition Structure: Use the WHERE clause with subqueries to exclude airports whose AirportCode appears in either the SourceAirport or DestAirport columns of the flights table. 3. Join Structure: Not required, as we only need to filter based on the absence of matching AirportCode entries in the flights table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('AAF',), ('ABI',), ('ABL',), ('ABQ',), ('ABR',), ('ABY',), ('ACV',), ('ADG',), ('ADK',), ('ADM',), ('ADR',), ('ADT',), ('AED',), ('AEL',), ('AET',), ('AEX',), ('AFO',), ('AGN',), ('AHD',), ('AHF',), ('AHH',), ('AHN',), ('AHT',), ('AIA',), ('AIB',), ('AID',), ('AIK',), ('AIV',), ('AKC',), ('AKI',), ('AKK',), ('AKO',), ('AKP',), ('ALB',), ('ALE',), ('ALI',), ('ALM',), ('ALN',), ('ALS',), ('ALX',), ('ALZ',), ('AMA',), ('AMN',), ('AMW',), ('ANA',), ('ANB',), ('ANC',), ('AND',), ('ANI',), ('ANN',), ('ANP',), ('ANQ',), ('ANV',), ('ANW',), ('ANY',), ('AOS',), ('APG',), ('APN',), ('APV',), ('AQY',), ('ARB',), ('ARC',), ('ARX',), ('ASE',), ('AST',), ('ASX',), ('ASY',), ('ATE',), ('ATO',), ('ATS',), ('ATW',), ('AUK',), ('AXB',), ('AXG',), ('AXN',), ('AXS',), ('AXX',), ('AYZ',), ('CAK',), ('CVO',), ('DYS',), ('EDF',), ('ESF',), ('HMN',), ('JLH',), ('KKI',), ('KQA',), ('LTS',), ('MMI',), ('MRI',), ('NAB',), ('NDV',), ('NGZ',), ('OTS',), ('QAW',), ('RFK',), ('RLI',), ('TDW',), ('VJI',), ('WKK',)]","[('Phillips AAF ',), ('Municipal ',), ('Dyess AFB ',), ('Municipal ',), ('Virginia Highlands ',), ('Ada ',), ('Adak Island Ns ',), ('Lenawee County ',), ('Municipal ',), ('Municipal ',), ('Ainsworth ',), ('Akhiok SPB ',), ('Spb ',), ('Akiak ',), ('Colorado Plains Regional Airport ',), ('Akron/canton Regional ',), ('Fulton International ',), ('Akutan ',), ('Alakanuk ',), ('NAS ',), ('Holloman AFB ',), ('Municipal ',), ('Municipal ',), ('Albany NAS ',), ('Dougherty County ',), ('Albany International ',), ('Albany ',), ('Albert Lea ',), ('Albuquerque International ',), ('Aleknagik ',), ('Aleneva ',), ('Thomas C Russell Fld ',), ('Alexandria International ',), ('Esler Field ',), ('Alexandria ',), ('Alexandria Bay ',), ('Algona ',), ('International ',), ('George Downer ',), ('Alitak SPB ',), ('Allakaket ',), ('Alliance ',), ('Gratiot Community ',), ('Alpena County Regional ',), ('Alpine ',), ('Alton ',), ('Altus AFB ',), ('Municipal ',), ('Alyeska ',), ('Rick Husband Amarillo International ',), ('Tradewind ',), ('Ambler ',), ('Amchitka ',), ('Municipal ',), ('Ames ',), ('Zahns ',), ('Amook ',), ('Anacortes ',), ('USN Heliport ',), ('Orange County Steel Salvage Heliport ',), ('Anaktuvuk ',), ('Elmendorf Afb ',), ('Ted Stevens Anchorage International Airport ',), ('Merrill Field ',), ('Municipal ',), ('Anderson ',), ('Andrews ',), ('Angel Fire ',), ('Tri-State Steuben Cty ',), ('Angoon ',), ('Rollang Field ',), ('Aniak ',), ('Anita Bay ',), ('Municipal ',), ('Lee ',), ('Annette Island ',), ('Anniston Metropolitan ',), ('Ft Mcclellan Bus Trml ',), ('Reilly AHP ',), ('Anthony ',), ('Antlers ',), ('Anvik ',), ('Municipal ',), ('Apple Valley ',), ('Outagamie County ',), ('Municipal ',), ('Arcata ',), ('Arctic Village ',), ('Downtown ',), ('Ardmore Municipal Arpt ',), ('US Army Heliport ',), ('Artesia ',), ('Asbury Park ',), ('Ashland ',), ('Ashley ',), ('Aspen ',), ('Astoria ',), ('Athens ',), ('Ohio University ',), ('McMinn County ',)]",,0.0,
Show paragraph details for paragraph with text 'Korea ' .,"[Paragraphs.Paragraph_Text, Paragraphs.Other_Details, Paragraphs.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,SELECT Paragraphs.Other_Details FROM Paragraphs WHERE Paragraphs.Paragraph_Text LIKE '%Korea%';,select other_details from paragraphs where paragraph_text like 'korea',cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the paragraph details, specifically ""Paragraphs.Other_Details"", for the paragraph with the specified text. 2. Condition Structure: Use a WHERE clause to filter for the paragraph where ""Paragraphs.Paragraph_Text"" contains the text 'Korea'. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Paragraphs"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific details for a single paragraph.","[(None,), (None,)]","[(None,), (None,)]",,1.0,
How many different templates do all document use?,"[Documents.Template_ID,Templates.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT COUNT(DISTINCT Documents.Template_ID) FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID;,SELECT count(DISTINCT template_id) FROM Documents,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""Template_ID"" values, as we are interested in the number of different templates used by all documents. 2. Condition Structure: No specific filtering condition is required since we are considering all documents. 3. Join Structure: Use an INNER JOIN between the ""Documents"" table and the ""Templates"" table on ""Documents.Template_ID = Templates.Template_ID"" to link documents with their respective templates. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique ""Template_ID"" values.","[(12,)]","[(12,)]",,1.0,
"Sort all the shops by number products in descending order, and return the name, location and district of each shop.","[shop.Name, shop.Location, shop.District, shop.Number_products]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,"SELECT shop.Name, shop.Location, shop.District FROM shop ORDER BY shop.Number_products DESC;","SELECT name ,  LOCATION ,  district FROM shop ORDER BY number_products DESC",employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the shop name, location, and district. Additionally, sort the results by the number of products in descending order. 2. Condition Structure: No specific filtering condition is required as the query involves all shops. 3. Join Structure: No JOIN is required since all necessary data is within the ""shop"" table. 4. Aggregation Structure: No aggregation is needed as we are simply sorting the shops based on the number of products.","[('FC Lahti', 'Lahti', 'Lahden Stadion'), ('HJK', 'Helsinki', 'Finnair Stadium'), ('FC Inter', 'Turku', 'Veritas Stadion'), ('FC Honka', 'Espoo', 'Tapiolan Urheilupuisto'), ('FF Jaro', 'Jakobstad', 'Jakobstads Centralplan'), ('FC KooTeePee', 'Kotka', 'Arto Tolsa Areena'), ('FC Haka', 'Valkeakoski', 'Tehtaan kenttä'), ('KuPS', 'Kuopio', 'Magnum Areena'), ('IFK Mariehamn', 'Mariehamn', 'Wiklöf Holding Arena')]","[('FC Lahti', 'Lahti', 'Lahden Stadion'), ('HJK', 'Helsinki', 'Finnair Stadium'), ('FC Inter', 'Turku', 'Veritas Stadion'), ('FC Honka', 'Espoo', 'Tapiolan Urheilupuisto'), ('FF Jaro', 'Jakobstad', 'Jakobstads Centralplan'), ('FC KooTeePee', 'Kotka', 'Arto Tolsa Areena'), ('FC Haka', 'Valkeakoski', 'Tehtaan kenttä'), ('KuPS', 'Kuopio', 'Magnum Areena'), ('IFK Mariehamn', 'Mariehamn', 'Wiklöf Holding Arena')]",,1.0,
Count the number of paragraphs.,[Paragraphs.Paragraph_ID],"Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,SELECT COUNT(Paragraphs.Paragraph_ID) AS paragraph_count FROM Paragraphs;,SELECT count(*) FROM Paragraphs,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the number of paragraphs. 2. Condition Structure: No specific filtering condition is required as we want the total count of all paragraphs. 3. Join Structure: No JOIN is necessary since the required information is available within the ""Paragraphs"" table. 4. Aggregation Structure: Use COUNT on ""Paragraphs.Paragraph_ID"" to calculate the total number of paragraphs.","[(15,)]","[(15,)]",,1.0,
"What is the template type code for template type description ""Book"".","[Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,SELECT Ref_Template_Types.Template_Type_Code FROM Ref_Template_Types WHERE Ref_Template_Types.Template_Type_Description = 'Book';,"SELECT template_type_code FROM Ref_template_types WHERE template_type_description  =  ""Book""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Template_Type_Code"" for the template type description ""Book"". 2. Condition Structure: Use a WHERE clause to filter for rows where ""Ref_Template_Types.Template_Type_Description"" is equal to ""Book"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Ref_Template_Types"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('BK',)]","[('BK',)]",,1.0,
What is the name of the shop that is hiring the largest number of employees?,"[shop.Name, hiring.Shop_ID, hiring.Employee_ID, hiring.Shop_ID = shop.Shop_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NON-NESTED,SELECT shop.Name FROM hiring JOIN shop ON hiring.Shop_ID = shop.Shop_ID GROUP BY hiring.Shop_ID ORDER BY COUNT(hiring.Employee_ID) DESC LIMIT 1;,SELECT t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t1.shop_id ORDER BY count(*) DESC LIMIT 1,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""shop.Name"" of the shop hiring the largest number of employees. Use COUNT on ""hiring.Employee_ID"" to count the number of employees hired by each shop. Use GROUP BY on ""hiring.Shop_ID"" to group the results by shop. Use ORDER BY in descending order to rank shops by the number of employees hired. Finally, use LIMIT 1 to select the shop with the largest number of employees. 2. Condition Structure: No specific filtering condition is required, as we are considering all shops and their hiring data. 3. Join Structure: Use a JOIN between the ""hiring"" and ""shop"" tables based on ""hiring.Shop_ID = shop.Shop_ID"" to associate each hiring record with its respective shop. 4. Aggregation Structure: Use COUNT to calculate the number of employees hired by each shop, and use ORDER BY and LIMIT to find the shop with the largest count.","[('FC Haka',)]","[('FC Haka',)]",,1.0,
Return the code of the template type that is most commonly used in documents.,"[Ref_Template_Types.Template_Type_Code,Templates.Template_Type_Code,Documents.Template_ID,Templates.Template_ID,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Ref_Template_Types.Template_Type_Code FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code GROUP BY Ref_Template_Types.Template_Type_Code ORDER BY COUNT(Ref_Template_Types.Template_Type_Code) DESC LIMIT 1;,SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id GROUP BY T1.template_type_code ORDER BY count(*) DESC LIMIT 1,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Template_Type_Code"" from the ""Ref_Template_Types"" table. Use COUNT to count the occurrences of each template type in the ""Documents"" table. 2. Condition Structure: No specific filtering condition is required as we are analyzing all documents. 3. Join Structure: Use JOINs to connect ""Documents"" with ""Templates"" on ""Template_ID"" and ""Templates"" with ""Ref_Template_Types"" on ""Template_Type_Code"" to link documents with their respective template types. 4. Aggregation Structure: Use COUNT to count the occurrences of each ""Template_Type_Code"" and GROUP BY ""Template_Type_Code"" to group the results by template type. Use ORDER BY in descending order to rank the template types by their count and LIMIT 1 to select the most commonly used template type.","[('BK',)]","[('BK',)]",,1.0,
Return the ids of templates that have the code PP or PPT.,"[Templates.Template_ID,Templates.Template_Type_Code,Ref_Template_Types.Template_Type_Code = Templates.Template_Type_Code,PP,PPT]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Templates.Template_ID FROM Templates WHERE Templates.Template_Type_Code = 'PP' OR Templates.Template_Type_Code = 'PPT';,"SELECT template_id FROM Templates WHERE template_type_code  =  ""PP"" OR template_type_code  =  ""PPT""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Templates.Template_ID"" as the question asks for template IDs. 2. Condition Structure: Use a WHERE clause to filter for templates where the ""Template_Type_Code"" is either 'PP' or 'PPT'. 3. Join Structure: No JOIN is required since the filtering condition is directly on the ""Templates"" table. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific template IDs based on the condition.","[(0,), (1,), (6,), (7,), (10,), (18,), (22,), (24,), (25,)]","[(0,), (1,), (6,), (7,), (10,), (18,), (22,), (24,), (25,)]",,1.0,
Give the ids of documents that have between one and two paragraphs.,"[Documents.Document_ID,Paragraphs.Document_ID,Paragraphs.Document_ID = Documents.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Documents.Document_ID FROM Documents JOIN Paragraphs ON Paragraphs.Document_ID = Documents.Document_ID GROUP BY Documents.Document_ID HAVING COUNT(Paragraphs.Paragraph_ID) BETWEEN 1 AND 2;,SELECT document_id FROM Paragraphs GROUP BY document_id HAVING count(*) BETWEEN 1 AND 2,cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Documents.Document_ID."" Use a GROUP BY clause to group the results by ""Documents.Document_ID"" since we need to count the number of paragraphs for each document. Apply a HAVING clause to filter documents with a paragraph count between one and two. 2. Condition Structure: Use a HAVING clause to filter for documents where the count of paragraphs is between one and two (inclusive). 3. Join Structure: Use an INNER JOIN between the ""Documents"" and ""Paragraphs"" tables on ""Paragraphs.Document_ID = Documents.Document_ID"" to associate each document with its paragraphs. 4. Aggregation Structure: Use COUNT on ""Paragraphs.Paragraph_ID"" to count the number of paragraphs for each document.","[(3,), (80,), (3830,), (33930,), (50123,), (651512,), (3540024,), (16514113,), (385906526,)]","[(3,), (80,), (3830,), (33930,), (50123,), (651512,), (3540024,), (16514113,), (385906526,)]",,1.0,
"What are the template ids with template type description ""Presentation"".","[Templates.Template_ID,Templates.Template_Type_Code,Ref_Template_Types.Template_Type_Description,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Presentation]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Templates.Template_ID FROM Templates JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code WHERE Ref_Template_Types.Template_Type_Description = 'Presentation';,"SELECT T2.template_id FROM Ref_template_types AS T1 JOIN Templates AS T2 ON T1.template_type_code  = T2.template_type_code WHERE T1.template_type_description  =  ""Presentation""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Templates.Template_ID."" 2. Condition Structure: Use a WHERE clause to filter for records where ""Ref_Template_Types.Template_Type_Description"" is ""Presentation."" 3. Join Structure: Use an INNER JOIN to connect the ""Templates"" table with the ""Ref_Template_Types"" table on the ""Template_Type_Code"" column to access the template type description. 4. Aggregation Structure: No aggregation is needed as we are only retrieving template IDs that match the condition.","[(6,), (7,), (10,)]","[(6,), (7,), (10,)]",,1.0,
Show all document ids and the number of paragraphs in each document. Order by document id.,"[Documents.Document_ID, Paragraphs.Document_ID, Paragraphs.Document_ID = Documents.Document_ID]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Documents.Document_ID, COUNT(Paragraphs.Paragraph_ID) AS Paragraph_Count FROM Documents JOIN Paragraphs ON Documents.Document_ID = Paragraphs.Document_ID GROUP BY Documents.Document_ID ORDER BY Documents.Document_ID;","SELECT document_id ,  count(*) FROM Paragraphs GROUP BY document_id ORDER BY document_id",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Documents.Document_ID"" and the count of paragraphs in each document. Use COUNT on ""Paragraphs.Paragraph_ID"" to count the number of paragraphs. Include GROUP BY to group the results by ""Documents.Document_ID."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Documents"" and ""Paragraphs"" tables on ""Documents.Document_ID = Paragraphs.Document_ID"" to associate each document with its paragraphs. 4. Aggregation Structure: Use COUNT to calculate the number of paragraphs for each document. Apply ORDER BY to sort the results by ""Documents.Document_ID.""","[(3, 1), (80, 2), (2394, 3), (3830, 1), (33930, 1), (50123, 1), (651512, 2), (3540024, 1), (16514113, 2), (385906526, 1)]","[(3, 1), (80, 2), (2394, 3), (3830, 1), (33930, 1), (50123, 1), (651512, 2), (3540024, 1), (16514113, 2), (385906526, 1)]",,1.0,
What is all the information about hiring?,"[hiring.Shop_ID, hiring.Employee_ID, hiring.Start_from, hiring.Is_full_time]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,SELECT * FROM hiring;,SELECT * FROM hiring,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve all columns from the ""hiring"" table, as the question asks for all information about hiring. 2. Condition Structure: No specific filtering condition is required since the query is asking for all information. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""hiring"" table. 4. Aggregation Structure: No aggregation is needed as the query is simply retrieving all rows and columns from the ""hiring"" table.","[(1, 1, '2009', 'T'), (1, 2, '2003', 'T'), (8, 3, '2011', 'F'), (4, 4, '2012', 'T'), (5, 5, '2013', 'T'), (2, 6, '2010', 'F'), (6, 7, '2008', 'T')]","[(1, 1, '2009', 'T'), (1, 2, '2003', 'T'), (8, 3, '2011', 'F'), (4, 4, '2012', 'T'), (5, 5, '2013', 'T'), (2, 6, '2010', 'F'), (6, 7, '2008', 'T')]",,1.0,
"What are the different template type codes, and how many templates correspond to each?","[Ref_Template_Types.Template_Type_Code,Templates.Template_Type_Code,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,"SELECT Ref_Template_Types.Template_Type_Code, COUNT(Templates.Template_ID) AS Template_Count FROM Ref_Template_Types JOIN Templates ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code GROUP BY Ref_Template_Types.Template_Type_Code;","SELECT template_type_code ,  count(*) FROM Templates GROUP BY template_type_code",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Ref_Template_Types.Template_Type_Code"" and the count of templates corresponding to each type. Use COUNT to calculate the number of templates. 2. Condition Structure: No specific filtering condition is required as the question asks for all template type codes and their corresponding counts. 3. Join Structure: Use an INNER JOIN to connect the ""Ref_Template_Types"" table with the ""Templates"" table based on the foreign key relationship ""Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code."" 4. Aggregation Structure: Use COUNT to count the number of templates for each template type code and GROUP BY ""Ref_Template_Types.Template_Type_Code"" to group the results by template type code.","[('AD', 3), ('BK', 6), ('CV', 2), ('PP', 6), ('PPT', 3)]","[('AD', 3), ('BK', 6), ('CV', 2), ('PP', 6), ('PPT', 3)]",,1.0,
"Show all paragraph texts for the document ""Customer reviews"".","[Paragraphs.Paragraph_Text,Documents.Document_Name,Paragraphs.Document_ID = Documents.Document_ID,Customer reviews]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Paragraphs.Paragraph_Text FROM Paragraphs JOIN Documents ON Paragraphs.Document_ID = Documents.Document_ID WHERE Documents.Document_Name = 'Customer reviews';,"SELECT T1.paragraph_text FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_id  =  T2.document_id WHERE T2.document_name  =  ""Customer reviews""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Paragraphs.Paragraph_Text."" 2. Condition Structure: Use a WHERE clause to filter for the document with the name ""Customer reviews."" 3. Join Structure: Use a JOIN between the ""Paragraphs"" and ""Documents"" tables based on ""Paragraphs.Document_ID = Documents.Document_ID"" to link paragraphs to their respective documents. 4. Aggregation Structure: No aggregation is needed as we are retrieving all paragraph texts for a specific document.","[('Korea',), ('Ukraine',), ('Korea',)]","[('Korea',), ('Ukraine',), ('Korea',)]",,1.0,
What are the names of the employees who never received any evaluation?,"[employee.Name,employee.Employee_ID,evaluation.Employee_ID = employee.Employee_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NESTED,SELECT Name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation);,SELECT name FROM employee WHERE Employee_ID NOT IN (SELECT Employee_ID FROM evaluation),employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of employees. Use the FROM clause to specify the employee table. Apply a WHERE clause to filter employees who never received any evaluation by ensuring their Employee_ID is not present in the evaluation table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude employees whose Employee_ID appears in the evaluation table, meaning they have received evaluations. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Employee_ID entries in the evaluation table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Mark Regan',), ('Tim Payne',), ('Andrew Sheridan',), ('Phil Vickery',), ('Steve Borthwick',)]","[('Mark Regan',), ('Tim Payne',), ('Andrew Sheridan',), ('Phil Vickery',), ('Steve Borthwick',)]",,1.0,
Show all template type codes and descriptions.,"[Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT Ref_Template_Types.Template_Type_Code, Ref_Template_Types.Template_Type_Description FROM Ref_Template_Types;","SELECT template_type_code ,  template_type_description FROM Ref_template_types",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Template_Type_Code"" and ""Template_Type_Description"". 2. Condition Structure: No specific filtering condition is required as the query asks for all template type codes and descriptions. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Ref_Template_Types"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all records from the table.","[('PPT', 'Presentation'), ('CV', 'CV'), ('AD', 'Advertisement'), ('PP', 'Paper'), ('BK', 'Book')]","[('PPT', 'Presentation'), ('CV', 'CV'), ('AD', 'Advertisement'), ('PP', 'Paper'), ('BK', 'Book')]",,1.0,
How many paragraphs for the document with name 'Summer Show'?,"[Documents.Document_ID,Documents.Document_Name,Paragraphs.Document_ID = Documents.Document_ID,Summer Show]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT COUNT(Paragraphs.Paragraph_ID) FROM Documents JOIN Paragraphs ON Paragraphs.Document_ID = Documents.Document_ID WHERE Documents.Document_Name = 'Summer Show';,SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show',cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the number of paragraphs. Use COUNT on ""Paragraphs.Paragraph_ID"" to get the total number of paragraphs. 2. Condition Structure: Use a WHERE clause to filter for the document with the name ""Summer Show."" This requires filtering ""Documents.Document_Name"" for the specified value. 3. Join Structure: Use an INNER JOIN between the ""Documents"" and ""Paragraphs"" tables based on the foreign key relationship ""Paragraphs.Document_ID = Documents.Document_ID"" to link paragraphs to their respective documents. 4. Aggregation Structure: Use COUNT to aggregate the number of paragraphs for the specified document.","[(1,)]","[(1,)]",,1.0,
Which cities do more than one employee under age 30 come from?,"[employee.City, employee.Age, employee.Employee_ID, hiring.Employee_ID = employee.Employee_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NESTED,SELECT City FROM employee WHERE Age < 30 GROUP BY City HAVING COUNT(*) > 1;,SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct cities. Use the FROM clause to specify the employee table. Apply a WHERE clause to filter employees under the age of 30. Use GROUP BY to group employees by city and apply a HAVING clause to filter cities with more than one employee. 2. Condition Structure: Use the WHERE clause to filter employees whose age is less than 30. Use the HAVING clause to ensure that only cities with more than one employee are included. 3. Join Structure: Not required, as all necessary data is available in the employee table. 4. Aggregation Structure: Use COUNT(*) in the HAVING clause to count the number of employees in each city and filter for cities with more than one employee.","[('Bath',)]","[('Bath',)]",,1.0,
Find the number of shops in each location.,"[shop.Location, shop.Shop_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,"SELECT shop.Location, COUNT(shop.Shop_ID) AS number_of_shops FROM shop GROUP BY shop.Location;","SELECT count(*) ,  LOCATION FROM shop GROUP BY LOCATION",employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the location and the count of shops. 2. Aggregation Structure: Use COUNT to calculate the number of shops in each location. 3. Grouping Structure: Use GROUP BY on ""shop.Location"" to group the results by each location. 4. Join Structure: No JOIN is required since all necessary data is within the ""shop"" table.","[('Espoo', 1), ('Helsinki', 1), ('Jakobstad', 1), ('Kotka', 1), ('Kuopio', 1), ('Lahti', 1), ('Mariehamn', 1), ('Turku', 1), ('Valkeakoski', 1)]","[(1, 'Espoo'), (1, 'Helsinki'), (1, 'Jakobstad'), (1, 'Kotka'), (1, 'Kuopio'), (1, 'Lahti'), (1, 'Mariehamn'), (1, 'Turku'), (1, 'Valkeakoski')]",,1.0,
Which shop has the most employees? Give me the shop name.,"[shop.Name, hiring.Shop_ID, hiring.Employee_ID, hiring.Shop_ID = shop.Shop_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NON-NESTED,SELECT shop.Name FROM shop JOIN hiring ON hiring.Shop_ID = shop.Shop_ID GROUP BY shop.Shop_ID ORDER BY COUNT(hiring.Employee_ID) DESC LIMIT 1;,SELECT t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t1.shop_id ORDER BY count(*) DESC LIMIT 1,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""shop.Name"" of the shop with the most employees. Use COUNT to count the number of employees per shop. 2. Condition Structure: No specific filtering condition is required, as we are interested in all shops. 3. Join Structure: Use a JOIN between the ""shop"" and ""hiring"" tables based on ""hiring.Shop_ID = shop.Shop_ID"" to associate each shop with its employees. 4. Aggregation Structure: Use COUNT on ""hiring.Employee_ID"" to count the number of employees per shop. Use GROUP BY to group results by ""shop.Shop_ID"" and ORDER BY in descending order of the count. Use LIMIT 1 to get the shop with the most employees.","[('FC Haka',)]","[('FC Haka',)]",,1.0,
Return the template type code of the template that is used by a document named Data base.,"[Documents.Document_Name,Documents.Template_ID,Templates.Template_ID = Documents.Template_ID,Templates.Template_Type_Code]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Templates.Template_Type_Code FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID WHERE Documents.Document_Name = 'Data base';,"SELECT T1.template_type_code FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T2.document_name  =  ""Data base""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Templates.Template_Type_Code."" 2. Condition Structure: Use a WHERE clause to filter for the document with the name ""Data base."" 3. Join Structure: Use a JOIN between the ""Documents"" and ""Templates"" tables based on ""Documents.Template_ID = Templates.Template_ID"" to link the document with its associated template. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('BK',)]","[('BK',)]",,1.0,
Find the cities that have more than one employee under age 30.,"[employee.City, employee.Age, employee.Employee_ID, hiring.Employee_ID = employee.Employee_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NESTED,SELECT City FROM employee WHERE Age < 30 GROUP BY City HAVING COUNT(*) > 1;,SELECT city FROM employee WHERE age  <  30 GROUP BY city HAVING count(*)  >  1,employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct cities. Use the FROM clause to specify the employee table. Apply a WHERE clause to filter employees under the age of 30. Use a GROUP BY clause to group employees by city and a HAVING clause to filter cities with more than one employee under the specified condition. 2. Condition Structure: Use the WHERE clause to filter employees whose age is less than 30. Then, use the HAVING clause to ensure that only cities with more than one such employee are included. 3. Join Structure: Not required, as all necessary data is available in the employee table. 4. Aggregation Structure: Use COUNT(*) in the HAVING clause to count the number of employees under 30 in each city and filter for cities with more than one such employee.","[('Bath',)]","[('Bath',)]",,1.0,
Find the number of employees hired in each shop; show the shop name as well.,"[shop.Name, hiring.Shop_ID, hiring.Employee_ID, shop.Shop_ID = hiring.Shop_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NON-NESTED,"SELECT shop.Name, COUNT(hiring.Employee_ID) AS Number_of_Employees FROM shop JOIN hiring ON shop.Shop_ID = hiring.Shop_ID GROUP BY shop.Name;","SELECT count(*) ,  t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t2.name",employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the shop name (""shop.Name"") and the count of employees hired in each shop. Use COUNT on ""hiring.Employee_ID"" to count the number of employees. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""shop"" and ""hiring"" tables on the shared key ""shop.Shop_ID = hiring.Shop_ID"" to associate each shop with its hiring records. 4. Aggregation Structure: Use GROUP BY on ""shop.Name"" to group the results by each shop and calculate the count of employees for each shop.","[('FC Haka', 2), ('FC Inter', 1), ('FC KooTeePee', 1), ('FC Lahti', 1), ('FF Jaro', 1), ('HJK', 1)]","[(2, 'FC Haka'), (1, 'FC Inter'), (1, 'FC KooTeePee'), (1, 'FC Lahti'), (1, 'FF Jaro'), (1, 'HJK')]",,1.0,
Find the manager name and district of the shop whose number of products is the largest.,"[shop.Manager_name, shop.District, shop.Number_products]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,"SELECT shop.Manager_name, shop.District FROM shop ORDER BY shop.Number_products DESC LIMIT 1;","SELECT manager_name ,  district FROM shop ORDER BY number_products DESC LIMIT 1",employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""shop.Manager_name"" and ""shop.District"" of the shop with the largest number of products. 2. Condition Structure: No specific filtering condition is required, as we are looking for the shop with the maximum number of products. 3. Join Structure: No JOIN is required since all necessary information is available in the ""shop"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""shop.Number_products"" to rank shops by the number of products and apply LIMIT 1 to select the shop with the largest number of products.","[('Ilkka Mäkelä', 'Lahden Stadion')]","[('Ilkka Mäkelä', 'Lahden Stadion')]",,1.0,
What are the names of the teachers ordered by ascending age?,"[teacher.Name, teacher.Age]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,"SELECT teacher.Name, teacher.Age FROM teacher ORDER BY teacher.Age ASC;",SELECT Name FROM teacher ORDER BY Age ASC,course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Name"" and ""teacher.Age"" fields. 2. Condition Structure: No specific filtering condition is required as we want all teacher names and their ages. 3. Join Structure: No JOIN is required since all necessary information is available in the ""teacher"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in ascending order based on ""teacher.Age"".","[('Vicente Carretero', '26'), ('Gustaaf Deloor', '29'), ('Joseph Huts', '32'), ('John Deloor', '33'), ('Lucy Wong', '39'), ('Anne Walker', '41'), ('Kearsley Brown', '45')]","[('Vicente Carretero',), ('Gustaaf Deloor',), ('Joseph Huts',), ('John Deloor',), ('Lucy Wong',), ('Anne Walker',), ('Kearsley Brown',)]",,1.0,
What is the version number and template type code for the template with version number later than 5?,"[Templates.Version_Number, Templates.Template_Type_Code, Templates.Version_Number]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",EASY,"SELECT Templates.Version_Number, Templates.Template_Type_Code FROM Templates WHERE Templates.Version_Number > 5;","SELECT version_number ,  template_type_code FROM Templates WHERE version_number  >  5",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Templates.Version_Number"" and ""Templates.Template_Type_Code"" for templates with a version number later than 5. 2. Condition Structure: Use a WHERE clause to filter templates where ""Templates.Version_Number"" is greater than 5. 3. Join Structure: No JOIN is required since all necessary information is in the ""Templates"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific fields based on a condition.","[(9, 'PP'), (8, 'PPT'), (6, 'BK'), (7, 'AD'), (9, 'CV'), (7, 'AD'), (6, 'BK'), (9, 'AD'), (8, 'PP')]","[(9, 'PP'), (8, 'PPT'), (6, 'BK'), (7, 'AD'), (9, 'CV'), (7, 'AD'), (6, 'BK'), (9, 'AD'), (8, 'PP')]",,1.0,
"For each shop, return the number of employees working there and the name of the shop.","[shop.Shop_ID, shop.Name, hiring.Shop_ID = shop.Shop_ID, hiring.Employee_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",NON-NESTED,"SELECT shop.Name, COUNT(hiring.Employee_ID) AS Number_of_Employees FROM shop JOIN hiring ON shop.Shop_ID = hiring.Shop_ID GROUP BY shop.Shop_ID;","SELECT count(*) ,  t2.name FROM hiring AS t1 JOIN shop AS t2 ON t1.shop_id  =  t2.shop_id GROUP BY t2.name",employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""shop.Name"" and the count of employees working in each shop. Use COUNT on ""hiring.Employee_ID"" to count the number of employees per shop. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""shop"" and ""hiring"" tables on ""shop.Shop_ID = hiring.Shop_ID"" to associate each shop with its employees. 4. Aggregation Structure: Use COUNT to aggregate the number of employees per shop and GROUP BY ""shop.Shop_ID"" to group the results by each shop.","[('FC Haka', 2), ('HJK', 1), ('FC Inter', 1), ('FF Jaro', 1), ('FC KooTeePee', 1), ('FC Lahti', 1)]","[(2, 'FC Haka'), (1, 'FC Inter'), (1, 'FC KooTeePee'), (1, 'FC Lahti'), (1, 'FF Jaro'), (1, 'HJK')]",,1.0,
Count the number of paragraphs in the document named 'Summer Show'.,"[Paragraphs.Document_ID,Documents.Document_Name,Paragraphs.Document_ID = Documents.Document_ID,'Summer Show']","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT COUNT(Paragraphs.Paragraph_ID) FROM Paragraphs JOIN Documents ON Paragraphs.Document_ID = Documents.Document_ID WHERE Documents.Document_Name = 'Summer Show';,SELECT count(*) FROM Paragraphs AS T1 JOIN Documents AS T2 ON T1.document_ID  =  T2.document_ID WHERE T2.document_name  =  'Summer Show',cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the number of paragraphs. Use COUNT on ""Paragraphs.Paragraph_ID"" to count the paragraphs. 2. Condition Structure: Use a WHERE clause to filter for the document named ""Summer Show."" This requires filtering on ""Documents.Document_Name."" 3. Join Structure: Use a JOIN between the ""Paragraphs"" and ""Documents"" tables based on ""Paragraphs.Document_ID = Documents.Document_ID"" to associate paragraphs with their respective documents. 4. Aggregation Structure: Use COUNT to aggregate the number of paragraphs for the specified document.","[(1,)]","[(1,)]",,1.0,
How many templates have template type code CV?,"[Templates.Template_Type_Code,Ref_Template_Types.Template_Type_Code,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,CV]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT COUNT(*) FROM Templates WHERE Templates.Template_Type_Code = 'CV';,"SELECT count(*) FROM Templates WHERE template_type_code  =  ""CV""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to count the number of templates. Use COUNT to calculate the total number of templates. 2. Condition Structure: Use a WHERE clause to filter for templates with the ""Template_Type_Code"" equal to 'CV'. 3. Join Structure: No JOIN is required since the ""Template_Type_Code"" is directly available in the ""Templates"" table. 4. Aggregation Structure: Use COUNT to aggregate the total number of templates that match the condition.","[(2,)]","[(2,)]",,1.0,
What are the names of documents that use templates with the code BK?,"[Documents.Document_Name,Templates.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,BK]","Table Documents, columns = [*,Document_ID,Template_ID,Document_Name,Document_Description,Other_Details]
Table Paragraphs, columns = [*,Paragraph_ID,Document_ID,Paragraph_Text,Other_Details]
Table Ref_Template_Types, columns = [*,Template_Type_Code,Template_Type_Description]
Table Templates, columns = [*,Template_ID,Version_Number,Template_Type_Code,Date_Effective_From,Date_Effective_To,Template_Details]
","Foreign_keys = [Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code,Documents.Template_ID = Templates.Template_ID,Paragraphs.Document_ID = Documents.Document_ID]
",NON-NESTED,SELECT Documents.Document_Name FROM Documents JOIN Templates ON Documents.Template_ID = Templates.Template_ID JOIN Ref_Template_Types ON Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code WHERE Templates.Template_Type_Code = 'BK';,"SELECT T2.document_name FROM Templates AS T1 JOIN Documents AS T2 ON T1.template_id  =  T2.template_id WHERE T1.template_type_code  =  ""BK""",cre_Doc_Template_Mgt,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Documents.Document_Name,"" as the question asks for the names of documents. 2. Condition Structure: Use a WHERE clause to filter for templates with the code ""BK."" This requires filtering on ""Templates.Template_Type_Code."" 3. Join Structure: Use JOINs to connect the ""Documents"" table with the ""Templates"" table on ""Documents.Template_ID = Templates.Template_ID"" and the ""Templates"" table with the ""Ref_Template_Types"" table on ""Templates.Template_Type_Code = Ref_Template_Types.Template_Type_Code."" 4. Aggregation Structure: No aggregation is needed, as the query only retrieves document names that meet the specified condition.","[('Robbin CV',), ('Data base',), ('How to read a book',), ('Palm reading',), ('About Korea',)]","[('Robbin CV',), ('Data base',), ('How to read a book',), ('Palm reading',), ('About Korea',)]",,1.0,
What is the number of employees from each city?,"[employee.City, employee.Employee_ID]","Table employee, columns = [*,Employee_ID,Name,Age,City]
Table evaluation, columns = [*,Employee_ID,Year_awarded,Bonus]
Table hiring, columns = [*,Shop_ID,Employee_ID,Start_from,Is_full_time]
Table shop, columns = [*,Shop_ID,Name,Location,District,Number_products,Manager_name]
","Foreign_keys = [hiring.Employee_ID = employee.Employee_ID,hiring.Shop_ID = shop.Shop_ID,evaluation.Employee_ID = employee.Employee_ID]
",EASY,"SELECT employee.City, COUNT(employee.Employee_ID) AS number_of_employees FROM employee GROUP BY employee.City;","SELECT count(*) ,  city FROM employee GROUP BY city",employee_hire_evaluation,"1. Sequential Structure: Start with the SELECT clause to specify the city and the count of employees from each city. 2. Aggregation Structure: Use COUNT to calculate the number of employees for each city. 3. Grouping Structure: Use GROUP BY on ""employee.City"" to group the results by each city. 4. Join Structure: No JOIN is required since all necessary data is within the ""employee"" table.","[('Bath', 3), ('Bristol', 3), ('Leicester', 1), ('Sale', 1), ('Wasps', 2)]","[(3, 'Bath'), (3, 'Bristol'), (1, 'Leicester'), (1, 'Sale'), (2, 'Wasps')]",,1.0,
What are the names of the teachers who are aged either 32 or 33?,"[teacher.Name, teacher.Age]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,"SELECT teacher.Name FROM teacher WHERE teacher.Age IN (32, 33);",SELECT Name FROM teacher WHERE Age  =  32 OR Age  =  33,course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Name"" of teachers who are aged either 32 or 33. 2. Condition Structure: Use a WHERE clause to filter for teachers whose ""teacher.Age"" is either 32 or 33. 3. Join Structure: No JOIN is required since all necessary information is in the ""teacher"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.","[('Joseph Huts',), ('John Deloor',)]","[('Joseph Huts',), ('John Deloor',)]",,1.0,
What are the first names and birth dates of players from the USA?,"[players.first_name, players.birth_date, players.country_code, USA]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT players.first_name, players.birth_date FROM players WHERE players.country_code = 'USA';","SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""players.first_name"" and ""players.birth_date"" of players. 2. Condition Structure: Use a WHERE clause to filter players whose ""players.country_code"" is 'USA'. 3. Join Structure: No JOIN is required since all necessary information is in the ""players"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific fields based on a condition.","[('Jolene', 19680831), ('Lisa', 19730810), ('Meilen', 19780117), ('Serena', 19810926), ('Chanda', 19760218), ('Amy', 19720919), ('Tara', 19770526), ('Meghann', 19790413), ('Erika', 19721014), ('Lilia', 19780407), ('Jane', 19740621), ('Jennifer', 19760329), ('Alexandra', 19801215), ('Linda', 19710211), ('Brie', 19800121), ('Corina', 19780126), ('Marissa', 19800623), ('Lindsay', 19760608), ('Kathleen', 19461027), ('Geri', ''), ('Rosie', 19480916), ('Joan', ''), ('Mary Ann', 19461125), ('Billie Jean', 19431122), ('Patti', 19491221), ('Sharon', 19520224), ('Mona', 19481128), ('Ann', 19510504), ('Chris', 19541221), ('Janet', 19530806), ('Jill', 19540519), ('Julie', 19451208), ('Ann', 19550822), ('Joy', 19540519), ('Pam', 19510417), ('Peggy', 19490202), ('Martina', 19561018), ('Laura', 19490504), ('Sally', 19550325), ('Cecilia', 19470524), ('Rene', 19570512), ('Beth', 19570613), ('Patricia', 19511125), ('Kim', 19561011), ('Betsy', 19561023), ('Barbara', 19570402), ('Dianne', 19580811), ('Felicia', 19570720), ('Lindsay', 19550124), ('Lele', 19560910), ('Diane', 19550615), ('Rosalyn', 19601102), ('Marcie', 19530910), ('Pam', 19620704), ('Barbara', 19570501), ('Candy', 19550324), ('Bonnie', 19630911), ('Barbara', 19611022), ('Anne', 19590701), ('Paula', 19570110), ('Nancy', 19550522), ('Andrea', 19650604), ('Anne', 19610928), ('Leslie', 19570312), ('Kathy', 19591203), ('Mary Lou', 19610806), ('Sherry', 19590606), ('Lea', 19590120), ('Kim', 19571222), ('Tracy', 19621212), ('Kate', 19521025), ('Wendy', 19600929), ('Andrea', 19640118), ('Zina', 19631116), ('Susan', 19640628), ('Camille', 19660602), ('Alycia', 19610218), ('Jane', 19531206), ('Vicki', 19620925), ('Heather', 19610611), ('Robin', 19631210), ('Gigi', 19640222), ('Kathy', 19670324), ('Anna Maria', 19601022), ('Beth', 19640528), ('Lori', 19631218), ('Laura', 19630317), ('Kim', 19570928), ('Shelley', 19630619), ('Barbara', 19640703), ('Michaela', 19660227), ('Shawn', 19671221), ('Elise', 19620305), ('Sandy', 19581013), ('Linda', 19691224), ('Lisa', 19620714), ('Terry', 19551128), ('Ann', 19591031), ('Lisa', 19651016), ('Molly', 19650312), ('Hu', 19630416), ('Dee Ann', 19620611), ('Jamie', 19620121), ('Beverly', 19650909), ('Louise', 19620107), ('Cammy', 19681011), ('Susan', 19590415), ('Caryn', 19610314), ('Tina', 19521124), ('Terry', 19661218), ('Marianne', 19671017), ('Gretchen', 19640207), ('Kathrin', 19621128), ('Pamela', 19630703), ('Lindsay', 19620731), ('Jennifer', 19670702), ('Jennifer', 19620426), ('Carol', 19621009), ('Jill', 19640904), ('Elizabeth', 19680826), ('Pam', 19631220), ('Melissa', 19680411), ('Cynthia', 19640326), ('Amy', 19690902), ('Sherri', 19640202), ('Stephanie', 19650206), ('Patty', 19650331), ('Penny', 19640411), ('Wendy', 19640420), ('Katrina', 19680805), ('Leigh Anne', 19641214), ('Donna', 19710705), ('Jennifer', 19690226), ('Andrea', 19710930), ('Anna', 19660117), ('Kimberly', 19730327), ('Laxmi', 19721109), ('Kathy', 19650825), ('Halle', 19690805), ('Ronni', 19660510), ('Ann', 19701013), ('Mary Joe', 19710819), ('Jeri', 19701211), ('Carrie', 19720428), ('Shaun', 19681213), ('Audra', 19711117), ('Stacey', 19701113), ('Tami', 19681113), ('Stacey', 19680319), ('Ginger', 19680914), ('Monica', 19731202), ('Patty', 19680118), ('Nicole', 19690826), ('Jessica', 19700913), ('Kimberly', 19711020), ('Stephanie', 19691105), ('Debbie', 19700825), ('Susan', 19701205), ('Caroline', 19660825), ('Elly', 19690825), ('Meredith', 19710428), ('Sandra', 19740910), ('Anne', 19770119), ('Lindsay', 19770628), ('Venus', 19800617), ('Samantha', 19790117), ('Karin', 19771210), ('Jill', 19740704), ('Bunny', 19570905), ('Rayni', 19560524), ('Jennifer', 19810210), ('Holly', 19790210), ('Nancy', 19420823), ('Dorothy', 19250703), ('Kristy', 19500815), ('Valerie', 19490629), ('Linda', 19501021), ('Peaches', 19490416), ('Tory Ann', 19420808), ('Pamela', 19500312), ('Denise', 19500731), ('Wendy', 19470331), ('Becky', ''), ('Nancy', 19520731), ('Barbara', 19540304), ('Kristien', 19520725), ('Janet', 19530628), ('Daryl', 19540507), ('Ching Ling', 19481008), ('Robin', 19580513), ('Patricia', 19410811), ('Laurie', 19551104), ('Donna', 19541109), ('Linda', 19521114), ('Julie', 19480113), ('Jeanne', 19571005), ('Laurie', 19550614), ('Kathy', 19560618), ('Janice', 19520710), ('Kathy', 19561123), ('Jane', 19530810), ('Marita', 19560219), ('Susie', 19570916), ('Mary', 19500721), ('Mary', 19540907), ('Mary', 19570312), ('Carrie', 19550822), ('Ruta', 19551118), ('Mareen', 19600815), ('Robin', 19560413), ('Caroline', 19601104), ('Emilse', 19571219), ('Kay', 19570925), ('Zenda', 19591212), ('Betty Ann', 19500226), ('Jeanne', 19591207), ('Linda', 19610605), ('Julie', 19620205), ('Stacy', 19590405), ('Dana', 19591126), ('Roberta', 19581103), ('Joyce', 19580503), ('Andrea', 19550406), ('Trey', 19591127), ('Jenny', 19650419), ('Leigh Anne', 19640108), ('Joanne', 19541030), ('Michelle', 19670627), ('Nancy', 19580418), ('Felicia', 19611231), ('Jean', 19581025), ('Barbi', 19640914), ('Amy', 19650405), ('Jill', 19600623), ('Ginny', 19661115), ('Grace', 19680416), ('Melissa', 19690624), ('Debbie', 19670809), ('Eileen', 19661201), ('Maeve', 19641116), ('Kathleen', 19610905), ('Niurka', 19690419), ('Cecilia', 19630628), ('Kristin', 19590827), ('Kate', 19630111), ('Liezel', 19760821), ('Mashona', 19760531), ('Stephanie', 19460308), ('Marilyn', 19480308), ('Mimi', ''), ('Alice', 19421122), ('Pixie', ''), ('Betty', 19250415), ('Nadine', 19441026), ('Victoria', ''), ('Stephanie', 19500703), ('Carole', 19430624), ('Gail', 19510421), ('Patricia', 19400101), ('Eliza', 19530102), ('Patricia', 19450828), ('Sandy', 19560501), ('Tam', 19520127), ('Wendy', 19520430), ('Kathy', 19461218), ('Lisa', ''), ('Judy', 19490816), ('Roberta', 19560702), ('Mary', 19450925), ('Aleida', 19550616), ('Erin', 19550720), ('Stephanie', 19560325), ('Karen', 19421211), ('Sheila', 19580222), ('Susie', 19620329), ('Micki', 19601129), ('Heather', 19610712), ('Jane', 19620121), ('Diane', 19611105), ('Shawna', ''), ('Tammy', 19651012), ('Tracy', 19791006), ('Allison', 19801114), ('Ansley', 19820105), ('Dawn', 19760529), ('Kristen', 19840628), ('Vija', ''), ('Farel', ''), ('Connie', 19510521), ('Marjorie', 19510503), ('Peggy', ''), ('Tish', ''), ('Jade', ''), ('Carole', ''), ('Emilie', ''), ('Diane', ''), ('Mary', ''), ('Ann', ''), ('Tina', ''), ('Maricaye', ''), ('Roylee', 19490526), ('Nancy', 19330421), ('Louise', 19470321), ('Mimi', 19390818), ('Raymonde', ''), ('Carol', ''), ('Joyce', 19420223), ('Pat', 19340819), ('Jane', 19510220), ('Darlene', 19360106), ('Pam', 19501025), ('Carol', ''), ('Emilie', ''), ('Margaret', 19500413), ('Pam', ''), ('Susan', 19531113), ('Shari', ''), ('Sue', 19540603), ('Jeanne', 19350721), ('Kathy', 19521219), ('Gertrude', 19230908), ('Judy', 19430402), ('Brenda', 19540211), ('Patricia', 19580516), ('Marcy', ''), ('Sally', ''), ('Lynne', 19580328), ('Margaret', 19530105), ('Renee', 19340819), ('Carol', 19501022), ('Chris', 19561026), ('Kelly', 19620418), ('Lisa', 19590305), ('Lucy', ''), ('Jody', 19560704), ('Phyllis', 19570326), ('Linda', 19631106), ('Karen', 19640323), ('Eleni', 19671023), ('Lisa', 19680718), ('Sandra', 19690903), ('Shannan', 19700519), ('Julie', 19760424), ('Nicole', 19760203), ('Angela', 19720404), ('Keri', 19740501), ('Jacqueline', 19801126), ('Laura', 19810512), ('Jean', 19740607), ('Melissa', 19820606), ('Amber', 19840706), ('Sarah', 19811106), ('Ashley', 19850502), ('Bethanie', 19850323), ('Allison', 19860410), ('Bea', 19801128), ('Alexandra', 19850902), ('Carly', 19861126), ('Theresa', 19850310), ('Gabriela', 19800607), ('Shenay', 19840706), ('Angela', 19840927), ('Kelly', 19830318), ('Teryn', 19781212), ('Abigail', 19810712), ('Jessica', 19871110), ('Jamea', 19860907), ('Mary', 19881218), ('Tiffany', 19800314), ('Alexa', 19890910), ('Vania', 19890303), ('Ahsha', 19850321), ('Lauren', 19891001), ('Varvara', 19860521), ('Madison', 19900403), ('Audra', 19860421), ('Ashley', 19890620), ('Julie', 19790104), ('Melanie', 19910923), ('Kristie', 19920615), ('Gail', 19910605), ('Asia', 19910404), ('Coco', 19911206), ('Christina', 19920511), ('Mallory', 19900718), ('Lauren', 19910110), ('Hilary', 19881117), ('Sloane', 19930320), ('Alison', 19900703), ('Jamie', 19900108), ('Chelsey', 19900829), ('Beatrice', 19920406), ('Shelby', 19921013), ('Irina', 19900504), ('Lauren', 19931009), ('Madison', 19950217), ('Nicole', 19740801), ('Michelle', 19731228), ('Akiko', 19720214), ('Joy', 19621006), ('Caryn', 19711005), ('Luanne', 19721228), ('Julie', 19720510), ('Rachel Ann', 19721119), ('Judy', 19620511), ('Noelle', 19701218), ('Alysia', 19710131), ('Laura', 19670517), ('Amanda', 19780620), ('Julie', 19721007), ('Ann', 19670822), ('Melissa', 19720621), ('Jan', 19531223), ('Mary', 19620121), ('Sylvia', 19640127), ('Gail', 19470116), ('Diedre', 19711011), ('Caroline', 19651129), ('Kerry', 19501002), ('Kathy', 19670904), ('Stella', 19690309), ('Karen', 19680705), ('Cynthia', 19580614), ('Marlie', 19501120), ('Rona', 19690708), ('Kylie', 19610519), ('Helena', 19610201), ('Cheryl', 19640503), ('Jennifer', 19690715), ('Elizabeth', 19660406), ('Anne', 19660205), ('Alix', 19721022), ('Erica', 19690716), ('Stephanie', 19700424), ('Jill', 19671011), ('Jane', 19630123), ('Kathy', ''), ('Jean', 19700510), ('Ann', 19651028), ('Kirsten', 19690327), ('Wendy', 19600327), ('Nicole', 19610906), ('Vicki', 19570325), ('Mary Ann', 19560424), ('Christine', 19680118), ('Jennifer', 19600326), ('Julie', 19570621), ('Penny', 19550826), ('Cathy', 19580310), ('June', 19630619), ('Pam', 19750701), ('Stephanie', 19791023), ('Jane', ''), ('Gretchen', 19650626), ('Jane', 19660324), ('Holyn', 19731012), ('Kristi', 19690910), ('Linley', 19620501), ('Shelby', 19500626), ('Andrea', 19700128), ('Kathy', 19591224), ('Danielle', 19700322), ('Carol', 19610705), ('Jean', 19550606), ('Lori', 19650330), ('Edie', ''), ('Robin', ''), ('Kerri', 19681001), ('Lisa', 19700324), ('Mary', 19660508), ('Carol', 19591113), ('Katie', 19750429), ('Michele', 19660606), ('Shannon', 19670527), ('Gina', 19490515), ('Clare', ''), ('Cathleen', 19570316), ('Janice', 19510522), ('Betsy', 19540503), ('Lucia', 19601022), ('Wendy', 19680715), ('Allyson', 19631007), ('Debbie', 19620722), ('Marsha', ''), ('Linda', 19690503), ('Page', 19740622), ('Heather', 19711011), ('Gigi', 19701007), ('Marilda', 19650222), ('Christine', 19720714), ('Cynthia Ann', 19521114), ('Jenny', 19710226), ('Shelley', 19650421), ('Jackie', 19640104), ('Stephanie', ''), ('Michelle', 19610116), ('Genevieve', 19630819), ('Glynis', ''), ('Ann', 19520526), ('Allegra', ''), ('Cricket', 19610507), ('Bunny', 19460729), ('Holly Ann', 19701218), ('Amy', 19721112), ('Kathy', 19631005), ('Monique', 19841006), ('Erica', 19721128), ('Susan', 19651125), ('Rita', 19601018), ('Nina', 19610207), ('Donna', 19591005), ('Cissie', 19600108), ('Nancy', 19640804), ('Erika', 19631007), ('Cristina', 19770210), ('Terri', 19680118), ('Patty', 19730928), ('Katrina', 19681104), ('Katrina', 19800530), ('Anne', 19810420), ('Cory Ann', 19850122), ('Nicole', 19861103), ('Diana', 19790704), ('Tanner', 19840803), ('Shadisha', 19850712), ('Leslie', 19870525), ('Neha', 19860206), ('Megan', 19850719), ('Elizabeth', 19880603), ('Jewel', 19810910), ('Lindsey', 19851118), ('Raquel', 19821208), ('Brittany', 19910919), ('Kirsten', 19880814), ('Chieh Yu', 19920114), ('Alexis', 19830331), ('Amanda', 19861204), ('Catherine', 19940409), ('Tetiana', 19840904), ('Julia', 19910909), ('Alexandra', 19880214), ('Zoe Gwen', 19930921), ('Julia', 19890323), ('Jessica', 19940224), ('Grace', 19940506), ('Chi Chi', 19920705), ('Nicole', 19930303), ('Mallory', 19910128), ('Jennifer', 19860922), ('Samantha', 19950218), ('Victoria', 19951130), ('Maria', 19891126), ('Anne', 19850828), ('Megan', 19850311), ('Lena', 19881115), ('Katie', 19830503), ('Courtney B', 19920325), ('Kimberly', 19890509), ('Jacqueline', 19910830), ('Ester', 19930704), ('Eleanor', 19880626), ('Yasmin', 19880504), ('Anne Liz', 19960526), ('Alessondra', 19900906), ('Ryann', 19960723), ('Lucie', 19720406), ('Kelly S', 19730905), ('Kristina', 19790811), ('Wendy', 19750131), ('Julie', 19751016), ('Aurandrea', 19791121), ('Brandis', 19800213), ('Megan', 19781224), ('Alyssa', 19821119), ('Jennifer', 19780807), ('Jennifer', 19840217), ('Candice', 19820331), ('Michelle', 19780119), ('Kristy', 19790517), ('Andrea', 19881006), ('Lauren', 19800829), ('Iris', 19850613), ('Jennifer', 19810718), ('Ali', 19870923), ('Nicole', 19851124), ('Kaysie', 19800411), ('Krystina', 19880510), ('Riza', 19860210), ('Sarah', 19810627), ('Megan', 19830326), ('Story', 19830502), ('Christina', 19801127), ('Stacia', 19850921), ('Kaitlyn', 19920113), ('Chloe', 19900201), ('Amanda', 19870902), ('Kelcy', 19890411), ('June', 19950619), ('Krista', 19940914), ('Adria', 19791221), ('Susie', 19721210), ('Kori', 19731101), ('Elizabeth', 19770823), ('Agnes', 19800801), ('Courtenay', 19770227), ('Dee Dee', 19790211), ('Aurora', 19741107), ('Keirsten', 19730917), ('Ingrid', 19730602), ('Stephanie', 19761207), ('Sara', 19770113), ('Lori', 19810731), ('Milangela', 19811209), ('Brooke', 19790101), ('Lauren', 19820521), ('Amanda', 19780119), ('Kelley', 19850922), ('Meredith', 19720604), ('Jackie', 19840111), ('Megan', 19780427), ('Amanda', 19811126), ('Cammy', 19701225), ('Ditta', 19751226), ('Jennifer', 19731228), ('Krissy', 19791211), ('Annica', 19780902), ('Tory', 19850618), ('Whitney', 19860123), ('Sarah', 19801121), ('Jessyca', 19800826), ('Beau', 19800626), ('Katrina', 19880707), ('Stephanie', 19790129), ('Jennifer', 19881123), ('Jessica', 19871124), ('Sarah', 19880209), ('Kim Anh', 19831004), ('Ellah', 19881122), ('Lauren', 19820914), ('Link', 19861125), ('Aleke', 19820427), ('Kendra', 19831118), ('Arpi', 19830612), ('Erin', 19900328), ('Tiffany', 19820909), ('Robin', 19830621), ('Kristi', 19851222), ('Jennifer Lee', 19870227), ('Veronica Ruo Qi', 19891110), ('Danielle', 19910328), ('Shilpa', 19840412), ('Elizabeth', 19880526), ('Megan', 19870701), ('Melissa', 19880408), ('Lauren', 19890522), ('Alana', 19851031), ('Riley', 19901114), ('Kristen', 19880323), ('Mami', 19790715), ('Kit', 19810726), ('Stacey', 19910718), ('Elizabeth', 19810315), ('Nina', 19890707), ('Nadja', 19900607), ('Erica', 19901127), ('Jenna', 19851126), ('Tiya', 19860611), ('Natalie', 19850322), ('Courtney', 19820929), ('Kristy', 19900108), ('Susanna', 19831103), ('Alexa', 19901117), ('Aeriel', 19900928), ('Maureen', 19820528), ('Allie', 19910420), ('Sanaz', 19880621), ('Lauren', 19760912), ('Alexis', 19840927), ('Libby', 19940124), ('Lauren', 19930723), ('Michaela', 19880722), ('Tori', 19871124), ('Gabrielle', 19930227), ('Danielle Rose', 19931213), ('Tarakaa', 19860811), ('Danielle', 19910528), ('Ellen', 19931008), ('Brooke', 19920408), ('Mccall', 19900315), ('Macall', 19860205), ('Megan', 19880705), ('Nicole', 19930729), ('Alexandra', 19911130), ('Elizabeth', 19860524), ('Jade', 19921028), ('Brie', 19890507), ('Jan', 19950301), ('Simone', 19891230), ('Elizabeth', 19860731), ('Gabrielle Faith', 19961223), ('Sachia', 19950511), ('Taylor', 19960416), ('Lindsey', 19900104), ('Alexandra', 19950630), ('Alexandra', 19910213), ('Robin', 19930412), ('Brianna', 19940219), ('Olivia', 19960122), ('Whitney', 19860811), ('Emily J', 19910615), ('Caroline B', 19941031), ('Chalena', 19950818), ('Elizabeth Anita Alexandria', 19960806), ('Breanna Alexa Bachini', 19930521), ('Mary', 19950817), ('Betsy', 19600427), ('Eve', 19621028), ('Janet', 19670405), ('Jaime', 19611001), ('Angel', 19610830), ('Donna', 19550626), ('Valerie', 19540813), ('Lucinda', 19520717), ('J', ''), ('J', ''), ('D', ''), ('K', ''), ('B', ''), ('J', ''), ('R', ''), ('N', ''), ('E', ''), ('F', ''), ('Caroline', 19560622), ('D', ''), ('Wendy', ''), ('Nancy', 19530830), ('Susan', 19570107), ('Gretchen', 19560201), ('Anne', ''), ('Holly', 19690811), ('Margaret', 19601012), ('Clare', 19671008), ('Kathy', 19641104), ('Rita', 19660512), ('Marlene', 19810731), ('Linda', 19570701), ('Beverly', 19530124), ('Ann', 19551013), ('Robin', 19540923), ('A', ''), ('Maria', ''), ('Karen', ''), ('Karen', ''), ('Jenny', ''), ('Lisa', ''), ('Kathy', ''), ('Maria', 19600424), ('Judith', ''), ('Becky', ''), ('Connie', ''), ('Lori', ''), ('Joni', 19651125), ('Lisa', ''), ('Suzanne', ''), ('Shandra', 19680519), ('Merrilee', ''), ('Jennifer', 19660615), ('Chris', ''), ('Trisha', 19690203), ('Stephanie', 19690818), ('Sonya', 19670825), ('Susan', 19710412), ('Tanya', 19690302), ('Tonya', 19690821), ('Kara', 19730105), ('Melissa', 19740402), ('Victoria', 19761230), ('Trina', 19821230), ('Kristine', 19720623), ('Martha', 19691215), ('Candice', 19800207), ('Cindy', 19790422), ('Elizabeth', 19740824), ('Valerie', 19731228), ('Tracey', 19710129), ('Diana', 19680410), ('Alice', 19770830), ('Allison', 19660804), ('Vickie', 19710827), ('Stacey', 19750105), ('Marissa', 19780613), ('Susanna', 19720303), ('Rebecca', 19721119), ('Ashley', 19720408), ('Varalee', 19760502), ('Stephanie', 19770408), ('Elizabeth', 19631112), ('Bridget', 19740207), ('Leslie', 19720209), ('Traci', 19780805), ('Alison', 19741125), ('Amy', 19681007), ('Vanessa', 19760513), ('Laura', 19720426), ('Anna', 19761021), ('Betsy', 19751127), ('Kristen', 19781002), ('Mugette', 19810424), ('Tu', 19780208), ('Irene', 19790612), ('Jennifer', 19720416), ('Diana', 19751029), ('Jody', 19711122), ('Samantha', 19890509), ('Tristen Z', 19940501), ('Rachel', 19920719), ('Ashley', 19871106), ('Alexandra', 19920223), ('Natalie', 19910801), ('Lindsay', 19880226), ('Amelia', 19920802), ('Caroline', 19930313), ('Camila', 19950929), ('Josie', 19951105), ('Skylar Alexandra', 19940424), ('Brooke', 19960212), ('Alexandra', 19910413), ('Daniella', 19971105), ('Hayley', 19950517), ('Jody', 19780930), ('Ella', 19760917), ('Emily Ann', 19820328), ('Jacquelyn', 19801117), ('Lesley', 19781011), ('Kristen', 19770518), ('Cara', 19720421), ('Zuzanna', 19800403), ('Katie', 19800911), ('Marilyn', 19740114), ('Lena', 19830510), ('Brandi', 19770612), ('Andrea', 19780204), ('Sara', 19801022), ('Hillary', 19820417), ('Mariel', 19800220), ('Whitney', 19800508), ('Darian', 19790615), ('Alexandra', 19820310), ('Prim', 19810115), ('Janet', 19800628), ('Rachel', 19690211), ('Lindsay', 19821207), ('Kirsty', 19780517), ('Raluca Daniela', 19830717), ('Mindy', 19720322), ('Erin', 19830419), ('Mary Carlisle', 19780716), ('Erin', 19800116), ('Keiko', 19800429), ('Maiko', 19820623), ('Paige', 19740714), ('Janet', 19790529), ('Briana', 19781221), ('Stacey', 19721219), ('Kristin', 19720204), ('Julia', 19810518), ('Rochelle', 19800430), ('Selin', 19780706), ('Jennifer', 19730117), ('Luana', 19821205), ('Whitney', 19850811), ('Paloma', 19720823), ('Tumeka', 19761226), ('Maria', 19830319), ('Hyacinth', 19610809), ('Eva', 19840706), ('Kara', 19790920), ('Katie', 19841110), ('Melissa', 19840613), ('Emmy', 19870722), ('Alexandria', 19860310), ('Shari', 19641103), ('Michelle', 19791212), ('Alexandra', 19841228), ('Nicole', 19860203), ('Monica', 19851212), ('Caitlin', 19850517), ('Lia', 19800922), ('Michelle', 19870304), ('Sybil', 19770106), ('Jodi', 19810822), ('Liberty', 19870409), ('Mimi', 19841030), ('Melissa', 19861211), ('Jessi', 19870221), ('Courtney', 19880501), ('Chrissie', 19870902), ('Yvette', 19880612), ('Audra', 19830331), ('Leila', 19860206), ('Tamara', 19790924), ('Rebekah', 19791012), ('Sabita', 19840927), ('Shannon', 19870109), ('Courtney', 19851011), ('Polina', 19860408), ('Anamika', 19890413), ('Jie', 19871101), ('Georgette', 19840709), ('Christy', 19871212), ('Suzanne', 19880117), ('Courtney', 19900327), ('Cammie', 19871122), ('Nelly', 19901113), ('Veronica', 19870514), ('Keilly', 19900505), ('Kate', 19831111), ('Reka', 19890708), ('Bianca', 19890514), ('Thien Trang', 19910918), ('Pamela', 19910101), ('Morgan', 19920220), ('Julianna', 19850107), ('Subbadharmi', 19890708), ('Stephanie', 19930216), ('Kelsey', 19910408), ('Alexandra', 19870719), ('Amanda', 19880314), ('Chelsea', 19891211), ('Anna', 19840821), ('Jill M', 19910313), ('Kady', 19860317), ('Phoebe', 19880520), ('Emily', 19921201), ('Christian', 19840913), ('Keri', 19891225), ('Sabrina', 19860112), ('Nataly', 19900913), ('Maria', 19920619), ('Noel', 19930203), ('April', 19920508), ('Ellie', 19930808), ('Stephanie', 19901027), ('Nicole', 19911031), ('Anna', 19940308), ('Veronika', 19900920), ('Annie', 19930330), ('Kyle', 19940405), ('Chanelle', 19940119), ('Yawna', 19860801), ('Hilary', 19910513), ('Ivana', 19861108), ('Gira', 19860829), ('Claire', 19891129), ('Erin', 19880609), ('Caitlin', 19880219), ('Alexandra', 19850703), ('Jennifer', 19950412), ('Kimberly', 19961015), ('Natalie', 19891102), ('Elizaveta Anna', 19930831), ('Veronica M', 19911207), ('Karina', 19950706), ('Sylvia', 19860904), ('Sherry', 19950208), ('Katrine Isabel', 19960315), ('Denise', 19950417), ('Courtney', 19940325), ('Christina', 19960529), ('Noelle', 19881205), ('Lauren', 19950517), ('Breaunna', 19941222), ('Nicole', 19941230), ('Meredith', 19970521), ('Nadia', 19950114), ('Jackie', 19710922), ('Antoinette', 19850107), ('Kathleen', 19740511), ('Kylene', 19790725), ('Dana', 19730725), ('Audra', 19720605), ('Tracee', 19731009), ('Amie', 19800517), ('Jennifer', 19811128), ('Lashawnn', 19740602), ('Jacqueline', 19820209), ('Jennifer', 19770119), ('Kristy', 19741230), ('Susan', 19741201), ('Bridget', 19761018), ('Amy', 19690628), ('Sandra', 19750116), ('Khristen', 19750803), ('Stefanie', 19810322), ('Barrie', 19730724), ('Kate', 19820415), ('Amy', 19731107), ('Anne', 19780520), ('Lauren', 19740830), ('Dewonder', 19590127), ('Kendra', 19790828), ('Jamie', 19801106), ('Jennifer', 19750823), ('Audrey', 19850430), ('Marjorie', 19750503), ('Katie', 19770527), ('Aimee', 19820110), ('Megan', 19810519), ('April', 19781129), ('Maren', 19791106), ('Sarah', 19780514), ('Marie Ange', 19780114), ('Dina', 19680406), ('Margaret', 19760707), ('Mary Beth', 19760329), ('Patricia', 19841020), ('Ashley', 19821229), ('Kathryn', 19790225), ('Leslie', 19810718), ('Becky', 19640801), ('Julie', 19811223), ('Danielle', 19781110), ('Terri', 19650402), ('Amy', 19681215), ('Douglas', 19840522), ('Sara', 19850621), ('Karla', 19770318), ('Kristin', 19841130), ('Kristin', 19810705), ('Bonnie', 19850503), ('Natalie', 19830401), ('Jennifer', 19830702), ('Claire', 19700527), ('Lauren', 19780316), ('Alison', 19791129), ('Laura', 19710624), ('Katia', 19810816), ('Kara', 19771202), ('Violette', 19790927), ('Lisa', 19740221), ('Evonne', 19740923), ('Mandy', 19790312), ('Jessica', 19800415), ('Emily', 19811119), ('Callie', 19770711), ('Maggie', 19750529), ('Elina', 19820521), ('Terry Ann', 19740428), ('Kimberly', 19790725), ('Bettina', 19820718), ('Lindsay', 19800519), ('Johanna', 19750518), ('Amy', 19790124), ('Meiling', 19791112), ('Jennifer', 19781020), ('Vania', 19810428), ('Megan', 19831014), ('Lindsey', 19800201), ('Megan', 19820411), ('Angela', 19840329), ('Megan', 19840920), ('Nicolette', 19831108), ('Anita', 19860219), ('Alessandra', 19870112), ('Aradhana', 19820709), ('Tiffany', 19831228), ('Macey', 19830224), ('Kelcy', 19861225), ('Caylan', 19820701), ('Stephanie', 19820923), ('Jan', 19580317), ('Kate', 19830530), ('Karen', 19671205), ('Sarah Jane', 19820802), ('Catrina', 19840913), ('Bethany', 19821129), ('Lindsay', 19820811), ('Kathleen', 19820917), ('Amy', 19810415), ('Emilia', 19820204), ('Colleen', 19790212), ('Ashlee', 19850522), ('Saras', 19830726), ('Brittany', 19850420), ('Laila', 19810805), ('Natalie', 19851103), ('Celena', 19790130), ('Marine', 19780929), ('Cara', 19730424), ('Loni', 19810928), ('Christyn', 19850210), ('Cassy', 19850802), ('Manisha', 19770513), ('Jennifer', 19811121), ('Michelle', 19801002), ('Brook', 19851231), ('Samantha', 19840807), ('Stephanie', 19870411), ('Courtney', 19820502), ('Melissa', 19840112), ('Kristin', 19790227), ('Adriana', 19780902), ('Christine', 19831216), ('Julie', 19840521), ('Cristina', 19860826), ('Nadia', 19850209), ('Amanda', 19821020), ('Camelia', 19860406), ('Emily', 19850201), ('Danielle', 19840717), ('Rochelle', 19800627), ('Brianna', 19851215), ('Zena', 19880717), ('Adina', 19870619), ('Lauren', 19880204), ('Lauren', 19870928), ('Meg', 19870811), ('Ristine', 19850116), ('Jennifer', 19841115), ('Lindsey', 19860101), ('Lindsay', 19880524), ('Gloriann', 19840228), ('Patricia', 19740119), ('Kelly', 19820223), ('Amanda', 19870813), ('Elizabeth', 19860128), ('Whitney', 19851225), ('Laura', 19850506), ('Masha', 19840211), ('Karina', 19880811), ('Erin', 19850113), ('Randi', 19870211), ('Kewa', 19860701), ('Hala', 19850809), ('Dasha', 19870606), ('Suzanna', 19861013), ('Colleen', 19880209), ('Blair', 19830904), ('Simone', 19881010), ('Jessica', 19870304), ('Austin', 19860601), ('Preethi', 19850629), ('Christala', 19890709), ('Krista', 19900423), ('Marie', 19830721), ('Ashley', 19861113), ('Latrell', 19891212), ('Sheryl', 19850920), ('Amanda', 19850319), ('Blakeley', 19841114), ('Ashley', 19870917), ('Whitney', 19890109), ('Marlene', 19880329), ('Melissa', 19860801), ('Alex', 19870117), ('Jessica', 19811223), ('Megan', 19890204), ('Jacqueline', 19830608), ('Melody', 19830708), ('Sarah', 19910314), ('Marie', 19910614), ('Daron', 19851128), ('Amy', 19790324), ('Dina', 19871014), ('Mia', 19910312), ('Valerie', 19851231), ('Amanda', 19880523), ('Connor', 19870922), ('Elizabeth', 19920114), ('Brittany', 19870208), ('Kristen A', 19880325), ('Julie', 19880331), ('Sarah', 19880129), ('Emily', 19890724), ('Christine', 19871225), ('Amanda', 19850511), ('Nicole', 19880620), ('Laurianne', 19881018), ('Pamela', 19901124), ('Miya', 19871114), ('Rachel', 19830708), ('Joanna', 19891009), ('Lynn', 19791216), ('Claire', 19871108), ('Paola', 19920827), ('Lauren', 19890512), ('Erin Carol', 19930506), ('Cameron', 19881224), ('Julie', 19870627), ('Stefanie', 19890130), ('Hannah', 19910812), ('Katherine', 19860305), ('Olivia', 19880423), ('Christina', 19880426), ('Christina', 19881212), ('Cierra', 19910927), ('Milena', 19850506), ('Christin J', 19870731), ('Stephanie', 19900327), ('Kaysara', 19910623), ('Nina', 19900115), ('Deirdre', 19901205), ('Kristin', 19841024), ('Jacqueline', 19900913), ('Stephany', 19900609), ('Erica', 19900702), ('Julia', 19910916), ('Grace', 19891211), ('C C', 19911009), ('Sarah', 19910422), ('Marianne', 19850906), ('Monica', 19920622), ('Kate', 19920109), ('Amanda Marie', 19860106), ('Alexa', 19900824), ('Denise', 19890731), ('Molly', 19890525), ('Nelo', 19920705), ('Farwa', 19891101), ('Millie', 19641005), ('Brooke Lindsey', 19940622), ('Lilly F', 19911101), ('Brynn', 19910801), ('Karina', 19831112), ('Tracy', 19740827), ('Desiree', 19931110), ('Rachael', 19910427), ('Alrissa', 19920724), ('Amanda', 19870317), ('Olivia', 19910711), ('Caryssa L', 19920413), ('Monica', 19930108), ('Joelle', 19910606), ('Malika', 19910709), ('Theresa', 19930607), ('Mary Anne', 19920215), ('Morocco', 19921107), ('Mara', 19920222), ('Alejandra Maria', 19950228), ('Catherine', 19880430), ('Kate', 19901106), ('Abigail', 19900209), ('Sabrina', 19930224), ('Heatherm', 19890925), ('Stephanie', 19940511), ('Leighann', 19931204), ('Lauren', 19880816), ('Kayla', 19920921), ('Kir', 19891031), ('Skylar', 19930914), ('Julia', 19931207), ('Meghan', 19930621), ('Nida', 19911029), ('Lauren', 19880905), ('Kelly K', 19910531), ('Alyssa Grace', 19950215), ('Mary', 19911122), ('Madeleine', 19920319), ('Rachel', 19840302), ('Alex', 19911229), ('Kyra', 19960510), ('Suzy', 19940830), ('Remeice', 19891112), ('Kate', 19940201), ('Courtney', 19891015), ('Molly', 19930810), ('Stephanie', 19940131), ('Alexandra M', 19870719), ('Aleksandra', 19960409), ('Erin', 19880709), ('Jessica', 19930428), ('Spencer', 19950125), ('Anik', 19910405), ('Simone', 19920717), ('Emma', 19930623), ('Melissa', 19921004), ('Tina', 19950427), ('Julia', 19940613), ('Rachael', 19931209), ('Shelby', 19930114), ('Epiphany B', 19921217), ('Kaitlin', 19921215), ('Mariana', 19950927), ('Hannah', 19951103), ('Casey', 19910613), ('Deborah', 19940514), ('Jessica', 19931117), ('Kelsey', 19940821), ('Samantha', 19930126), ('Blair', 19940814), ('Martha V', 19900628), ('Amanda', 19930322), ('Sarah', 19920729), ('Emily', 19931112), ('Jamie', 19950308), ('Kelly', 19770505), ('Quinn', 19941110), ('Sophia', 19930330), ('Sierra A', 19900816), ('Mckenzie', 19940107), ('Stacey', 19900117), ('Courtney', 19910226), ('Rosalia', 19900208), ('Sydney', 19950207), ('Mia', 19950406), ('Erin Kane', 19960512), ('Laura', 19841119), ('Eva', 19921222), ('Elizabeth', 19940706), ('Sarah', 19930713), ('Elyse', 19870910), ('Sabrina', 19920912), ('Julia', 19890114), ('Gabriella', 19951208), ('Tanya', 19930914), ('Nyla', 19960730), ('Louisa', 19960516), ('Zina', 19980402), ('Tornado Alicia', 19980512), ('Madison', 19970919), ('Rima', 19951116), ('Kourtney J', 19940907), ('Natasha', 19940823), ('Erin', 19901230), ('Rachel May', 19941113), ('Jillian', 19941210), ('Caroline', 19960315), ('Dominique', 19870203), ('Trelsie', 19890707), ('Angela', 19950604), ('Nicole', 19980429), ('Kim', 19951027), ('Emina', 19930330), ('Lynda', 19921123), ('Joanna Mary', 19930201), ('Caroline', 19960103), ('Julia', 19940403), ('Callie', 19910904), ('Maxine', 19910710), ('Katie', 19921211), ('Emma Christine', 19980201), ('Johnnise', 19960510), ('Katerina', 19970717), ('Jessica', 19970105), ('Marjorie', 19880420), ('Maci', 19931007), ('Kaitlyn', 19971204), ('Jacqueline', 19941203), ('Charity', 19870711), ('Parris', 19980708), ('Jamie', 19930819), ('Miriam Ruth', 19940724), ('Elizabeth', 19910118), ('Amanda', 19860130), ('Lindsay', 19780708), ('Erica', 19860327), ('Dina', 19711211), ('Robyn', 19850111), ('Anita', 19810402), ('Casey', 19840501), ('Emily', 19850224), ('Jamie', 19880415), ('Brittany', 19880627), ('Elizabeth', 19550921), ('Carolyn', 19900415), ('Cassandra', 19891211), ('Prissy', 19910807), ('Kristin', 19830420), ('Diamond', 19901226), ('Celia', 19860527), ('Tiffany', 19891126), ('Jennifer', 19890531), ('Komal', 19930108), ('Roxanne', 19890826), ('Mandy', 19810914), ('Amanda', 19800324), ('Alissa', 19671209), ('Kay', 19570927), ('Jane', 19661222), ('Tracie', 19610116), ('Elizabeth', 19630811), ('Cinda', 19710410), ('Tracy', 19611021), ('Dena', 19650928), ('Hemel', 19660108), ('Karen', 19630803), ('Reka', 19670612), ('Vincenza', 19660820), ('Lisa', 19640803), ('Lynn', 19661018), ('Jill', 19731226), ('Julie', 19710609), ('Kilmeny', 19660218), ('Kay', 19690131), ('Debbie', 19651129), ('Anne Marie', 19660720), ('Leslie', 19660908), ('Lisa', 19630604), ('Lisa', 19611106), ('Tory', 19660712), ('Kylie', 19700509), ('Anya', 19690220), ('Jennifer', 19670106), ('Diana', 19721007), ('Betsy', 19671127), ('Katrina', 19671129), ('Karen', 19701102), ('Susan', 19710206), ('Sherri', 19730118), ('Tonya', 19691110), ('Julie', 19680817), ('Susan', 19710206), ('Jamie', 19691029), ('Alita', 19630112), ('Tara', 19681223), ('Erika', 19720516), ('Kellie', 19670601), ('Happy', 19680605), ('Angie', 19710323), ('Bonnie', 19770412), ('Farley', 19741212), ('Tunecia', 19701023), ('Roseann', 19710227), ('Allison', 19710927), ('Hillery', 19610619), ('La Shawnn', 19740206), ('Sylvia', 19610419), ('Kathy', 19741105), ('Zuzanna', 19790726), ('Cassi', 19850902), ('Lejla', 19870206), ('Danielle', 19820120), ('Geneva', 19871225), ('Katie', 19891023), ('Katie', 19881216), ('Brittany', 19940406), ('Allie', 19950630), ('Sofia', 19981114), ('Mia', 19970723), ('Ty Ana', 19970313), ('Karina Kristina', 19981021), ('Jessica', 19890916), ('Trisha', 19981027), ('Ashley', 19881017), ('Tina', 19920831), ('Tatijana', 19971116), ('Taylor L', 19950117), ('Alexa', 19980707), ('Emerald', 19970905), ('Marie', 19970611), ('Alexandra', 19950224), ('Aleah', 19910923), ('Sarah', 19941219), ('Usue Maitane', 19981028), ('Ellie', 19970710), ('Maia A', 19960921), ('Raquel', 19980128), ('Peggy', 19951110), ('Rebecca', 19971004), ('Camila', 19961125), ('Karyn', 19940912), ('Ayla', 19960715), ('Rasheeda', 19950630), ('Amy', 19941028), ('Ariana', 19960126), ('Luisa', 19951005), ('Mary', 19910802), ('Kristi', 19900427), ('Ronit', 19931203), ('Julia Christine', 19921027), ('Kristina N', 19910125), ('Macie', 19941023), ('Jessica', 19950102), ('Rhiann', 19940622), ('Frances', 19940222), ('Kelly', 19960221), ('Hanna', 19980225), ('Natalie', 19960508), ('Dasha', 19961011), ('Elizabeth', 19910218), ('Brianna', 19951012), ('Kristin', 19951122), ('Kristina', 19951204), ('Maddie', 19971117), ('Raveena', 19980723), ('Daniella', 19971027), ('Laura', 19970305), ('Idia', 19930922), ('Chloe Michele', 19970905), ('Morgan', 19941219), ('Nikki', 19960418), ('Sianna', 19900804), ('Nicole', 19990508), ('Mercedes', 19970525), ('Lourdes', 19990531), ('Adi', 19951213), ('Anna', 19971103), ('Alexandra', 19980719), ('Katarina', 19960704), ('Michaela', 19990726), ('Ena', 19980212), ('Catherine Cartan', 19990408), ('Hadley', 19960311), ('Madison', 19960402), ('Jaeda', 19990728), ('Jeannez', 19960707), ('Erica', 19980316), ('Jessie', 19980419), ('Andie K', 19970107), ('Alexandria', 19960511), ('Gabriella', 19960709), ('Kelly', 19990509), ('Terri', 19960723), ('Angel', 19850125), ('Maria', 19970506), ('Alexis', 19980809), ('Rianna', 19960903), ('Megen', 19960709), ('Caroline', 19980905), ('Sophie', 19970528), ('Nicole', 19960504), ('Jacqueline', 19970531), ('Jessica', 19970709), ('Adriana', 19890308), ('Kylie', 19970606), ('Yuki Kristina', 19950819), ('Lexi', 19950525), ('Caroline', 19970726), ('Ingrid', 19980616), ('Alexandra', 19970301), ('Nada', 20000308), ('Alexis', 19950606), ('Felicity', 19970313), ('Tory', 19930105), ('Aimee', 19940907), ('Alli', 19961203), ('Claudia', 19961206), ('Brooke', 19951010), ('Marina', 19981123), ('Zoe Adeline', 19941217), ('Jessica', 19970605), ('Ashley', 19920829), ('Valerie', 19971122), ('Ashley', 19990208), ('Brittany', 19920303), ('Olivia', 19940623), ('Taylor', 19950731), ('Alexis', 19950724), ('Sara', 19971217), ('Lindsay', 19930107), ('Liza', 19950317), ('Jayci', 20000517), ('Marina', 19920314), ('Sydney', 19990430), ('Alyza', 19951122), ('Sophia', 19920113), ('Riley', 19990615), ('Delaney', 19981028), ('Jane', 19961112), ('Valerie Ann', 19980801), ('Carolyn', 19970524), ('Maegan', 19950416), ('Tamara', 19971129), ('Mary', 19981025), ('Victoria', 19990401), ('Kennedy', 19970521), ('Amy', 19970120), ('Makenna', 19980226), ('Stephanie', 19980415), ('Nicole Taylor', 19990426), ('Claire', 20000525), ('Jada', 19990129), ('Sara', 19970723), ('Hannah', 19960923), ('Sophia', 19971005), ('Akiko', 19930913), ('Karina', 19970808), ('Haley', 19910403), ('Paige', 19970222), ('Kayla', 19990928), ('Carson', 20000909), ('Amanda', 19940813), ('Maria', 19990721), ('Kylie', 19990321), ('Luciana', 19981001), ('Zoe', 20010308), ('Sachi', 19981129), ('Audrey', 19951029), ('Anna', 19970319), ('Abigail', 20010122), ('Cameron', 19990920), ('Katelyn', 19921211), ('Katharine', 19961019), ('Elyse', 19981014), ('Mimi', 19930430), ('Bess', 19971029), ('Ines Karmen', 19970615), ('Taylor', 19990615), ('Kristen', 19970407), ('Sabrina', 19971003), ('Desirae', 19940111), ('Sarah', 19960418), ('Rachel', 19961108), ('Victoria', 19990807), ('Nini', 19950909), ('Francesca', 19970722), ('Makenzie', 19990610), ('Chiara', 19980826), ('Melissa', 19930602), ('Morgan', 19990416), ('Jerricka', 19950116), ('Eva', 19961102), ('Miranda', 19990307), ('Teresia', 19990529), ('Julia', 19971217), ('Malkia', 20000808), ('Lorraine M', 19930615), ('Carol', 19960218), ('Jocelyn', 19900526), ('Roosh', 19920321), ('Alexa', 19980703), ('Alyvia', 20000503), ('Katie', 19990929), ('Meible', 19990519), ('Elizabeth', 20010712), ('Emma', 20010518), ('Arianna', 19950206), ('Kiah', 19950117), ('Alyssa', 20000210), ('Stephanie', 19880402), ('Sofia', 19990722), ('Sarah', 19930814), ('Melan', 19970406), ('Alexandra', 19990105), ('Dilara', 19990911), ('Hurricane Tyra', 20010302), ('Taylor', 19980222), ('Nami', 19980827), ('Marcella', 20001012), ('Sophia', 20010630), ('Delisha', ''), ('Haley', ''), ('Jenna', ''), ('Nikita', 19931021), ('Hoda', ''), ('Meredith', 19990310), ('Morgan', 19950317), ('Kirsten', 19940508), ('Maya', 19940527), ('Kat', 19930215), ('Alexandra', 19930215), ('Meghan', 19971028), ('Salma', 20000828), ('Madeline', 19990307), ('Lindsay', 19981217), ('Alexa', 20010908), ('Mary Catherine', 19971104), ('Cheyenne', 19960326), ('Neri', 19990902), ('Jesse', 20011004), ('Ann', 20000626), ('Natalia', 19930929), ('Whitney', 20020417), ('Christina', 19970725), ('Sofia', 19980703), ('Nicole', 20000805), ('Kenadi', 19970313), ('Paiton', 19980808), ('Shannon', 19950915), ('Elysia', 20000324), ('Ashley', 19991026), ('Alexis', 19970314), ('Caty', 20011120), ('Isabella', 20010706), ('Elizabeth', 20010519), ('Anna', 20020306), ('Dakota', 20020508), ('Janice', 19990105), ('Amanda', 20010831), ('Jada', 19980319), ('Hind', 19990228), ('Mikaela', 19890801), ('Micheline', 19970428), ('Kendal', 19940106), ('Anna', 19991008), ('Mia', 19981021), ('Chloe', 20010830), ('Abigail', 20010310), ('Ryan', 19990510), ('Maia', ''), ('Jana', 19941110), ('Shale', 20011015), ('Helen Abigail', 19980520), ('Kariann', 19990116), ('Kennedy', 19980903), ('Caroline', 19980929), ('Allison', 19981031), ('Melissa', 19970624), ('Ellyse', 19961109), ('Charleen', 19410918), ('Doris', 19250620), ('Patricia', 19370601), ('Pauline', 19190806), ('Helen', 19290507), ('Mary', ''), ('Althea', 19270825), ('Carrie', 19571026), ('Cathy', 19510822), ('Karen', 19570408), ('', ''), ('Barbara', ''), ('Susan', 19611219), ('Jan', 19630609), ('Diane', 19650626), ('Carol', 19620605), ('Leanne', ''), ('Shelley', 19631120), ('Maureen', ''), ('Lorrie', 19601015), ('Tiffany', 19600417), ('Sarah', 19741010), ('Meg', ''), ('Wendy', ''), ('Lynn', 19660819), ('Heidi', 19640507), ('Jacqueline', 19620329), ('Sheri', 19690629), ('Diane', 19710121), ('Angela', 19641211), ('Nancy', ''), ('Liz', 19640423), ('Jamie', 19630530), ('', ''), ('Laura', 19681210), ('Jill', ''), ('Courtney', 19560622), ('Tiffany', 19810121), ('Kristen', 19810501), ('Wendy', 19681001), ('Sheila', ''), ('Heidi', 19601007), ('Julie', 19610523), ('Deborah', 19701129), ('Jennifer', ''), ('Cindy', 19591207), ('Lynn', ''), ('I', ''), ('Lisa', 19600808), ('Jill', 19540907), ('Aschara', ''), ('Heidi', 19720713), ('Julie', 19710609), ('', ''), ('G', ''), ('Stephanie', 19661010), ('Lucy', 19540402), ('Cathy', ''), ('', ''), ('Emmy', ''), ('', ''), ('Claudette', ''), ('Lisa', ''), ('Lynn', 19631114), ('Lindsay', ''), ('Lisa', 19630218), ('Virginia', ''), ('Lloyd', 19451208), ('Suzanne', 19750612), ('Caren', 19611110), ('Allegra', 19720113), ('Molly', 19630215), ('Lori', 19600112), ('Lindsay', 19780417), ('Adrienne', 19680903), ('Quynh', 19710627), ('Kari', 19810120), ('Lisa', 19590212), ('Christa', 19790115), ('Kelly', 19770505), ('Massoumeh', 19770803), ('Louise', 19500119), ('Jayne', 19741006), ('Christine', ''), ('Kim', 19780329), ('Lani', 19600808), ('Julie', 19690425), ('Ruth Ann', 19700506), ('Lauren', 19830423), ('Tasha', 19760223), ('Kealy', 19801030), ('Courtney', 19721230), ('Julie Ann', 19750618), ('Nicole', 19741001), ('Ashlee', 19801005), ('Kelly', 19751106), ('Alexandra', 19790210), ('Mary', 19730912), ('Lisa', 19660204), ('Monty', 19650506), ('Julie Anne', 19800911), ('Lorrie', 19651203), ('Kendra', 19760621), ('Chris', 19610706), ('Christine', 19850303), ('Rankin', 19840126), ('Julia', 19850721), ('Sabaea', 19811125), ('Nicole', 19750602), ('Joyce', 19800628), ('Sarah', 19820410), ('Jean Marie', 19651109), ('Stacey', 19720110), ('Varita', 19820702), ('Shera', 19780910), ('Trisha', 19710617), ('Suzanne', 19680921), ('Lisa', 19801119), ('Martha', 19551005), ('Kandiss', 19770221), ('Brooke', 19780413), ('Cristina', 19750825), ('Jasmine', 19810102), ('Kathleen', 19830125), ('Melissa', 19770524), ('Michelle', 19731114), ('April', 19831011), ('Olivia', 19810310), ('Melissa', 19650221), ('Cami', 19720314), ('Marissa', 19780318), ('Kristin', 19720204), ('Christi', 19610509), ('Cindy', ''), ('Ashley', 19830506), ('Leigh', 19831014), ('Natalia', 19831110), ('Nikhila', 19850208), ('Rachel', 19820916), ('Alison', 19850118), ('Cameron', 19830328), ('Gretchen', 19820304), ('Cackie', 19661107), ('Stephanie', 19650104), ('Miriam', 19850925), ('Nicole', 19880219), ('Lilivette', 19800225), ('Jonni', 19791203), ('Amanda', 19850102), ('Weyli', 19800722), ('Helene', 19841215), ('Amanda', 19841101), ('Nicole', 19870615), ('Stefani', 19841215), ('Laura', 19860217), ('Tifanie', 19880920), ('Mary', 19651124), ('Katherine', 19730414), ('Monica', 19800204), ('Nicole', 19850105), ('Shanna', 19750428), ('Jane', 19890926), ('Estelle', 19890503), ('Maria', 19820204), ('Jessica', 19860812), ('Renata', 19650224), ('Laura', 19830408), ('Lindsey', 19840313), ('Christy', 19850925), ('Timberly', 19831209), ('Brooke', 19850423), ('Kelli Elizabeth', 19940409), ('Melanie', ''), ('Whitney P', 19930625), ('Sydni', 19880612), ('Jasmine Nicole', 19930826), ('Alexandra', 19920812), ('Amber', 19870605), ('Kelsey', 19920610), ('Alex', 19920225), ('Ashley M', 19940304), ('Lauren', 19940828), ('Stacia', 19930914), ('Alexandria', 19900111), ('Rozel Asuncion', 19950616), ('Bolan', 19890908), ('Annie', 19920829), ('Eva', 19941007), ('Whitney', 19900909), ('Hanna', 19911107), ('Mandy', 19910501), ('Gia', 19900614), ('Brooke', 19951105), ('Lisa', 19680519), ('Alexandra M', 19930120), ('Sonya Sheeran', 19940816), ('Shinann', 19900608), ('Nicolette', 19950824), ('Rebecca', 19921125), ('Ashley', 19960430), ('Savannah', 19950115), ('Margaret', 19570423), ('Carlee', 19950724), ('Sarah', 19850718), ('Caroline', 19840926), ('Alexia', 19940421), ('Micaela', 19890311), ('Tina', 19810116), ('Manon Cristina', 19941224), ('Hailey M', 19930127), ('Tiffany', 19911216), ('Devan', 19940528), ('Courtenay', 19770227), ('Christine', 19931110), ('Emily', 19900517), ('Leyla', 19930423), ('Alexis', 19880722), ('Di Andrea', 19950730), ('Jandayia', 19960303), ('Margarita', 19950317), ('Olivia', 19941211), ('Caitlin', 19910905), ('Kara', 19910629), ('Paloma', 19890313), ('Susie', 19491114), ('Emily', 19861118), ('Abbie', 19951121), ('Alanna', 19950107), ('Siobhan', 19871110), ('Kayla Symone', 19960110), ('Margie', 19901106), ('Jamie', 19820521), ('Adria', 19791221), ('Lynn', 19941106), ('Nadege', 19960527), ('Lauren', 19941203), ('Tiffany', 19881204), ('Sarah', 19880907), ('Victoria', 19941214), ('Natalia', 19950325), ('Alexandra', 19931013), ('Montana', 19970219), ('Samantha Rose', 19940410), ('Angela', 19980331), ('Samantha', 19950527), ('Elizabeth', 19890419), ('Sarah', 19941121), ('Gabriela', 19950418), ('Tina', 19911222), ('Mia', 19920116), ('Stephanie', 19920831), ('Kennan', 19960317), ('Madison', 19930602), ('Whitney', 19910815), ('Sarah', 19960925), ('Brooke', 19980614), ('Jessie Lynn', 19951228), ('Brittany', 19941212), ('Kylie', 19870826), ('Erin', 19861102), ('Lindsay', 19821118), ('Jessica', 19801107), ('Yuliya', 19860609), ('Kathryn', 19831129), ('Lyndsey', 19820509), ('Tiana', 19841014), ('Keri', 19870310), ('Sarah', 19871201), ('Alyssa', 19841006), ('Rachel', 19870205), ('Angelina', 19521229), ('Amy', 19540720), ('Bernadette', 19821015), ('Tarrin', 19820423), ('Christine', 19670817), ('Christian', 19870108), ('Emily', 19820728), ('Kelly', 19700330), ('Courtney', 19900729), ('Taylor', 19900818), ('Carissa', 19900507), ('Heather', 19810210), ('Georgiana', 19880624), ('Michelle', 19910127), ('Brintney', 19871008), ('Chisako', 19870720), ('Kristen', 19890819), ('Jessica', 19910223), ('Susie', 19700212), ('Ashley', 19830410), ('Megan', 19890818), ('Larraine', 19910713), ('Courtney', 19920503), ('Tiffany', 19860519), ('Olga', 19880819), ('Shauna', 19900424), ('Canna', 19860515), ('Jennifer', 19890525), ('Keri', ''), ('Lauren', 19890922), ('Whitney', 19880108), ('Caitlyn', 19891220), ('Stephanie', 19890627), ('Jacqueline', 19910905), ('Natalia Maria', 19880414), ('Katie', 19921222), ('Stephanie', 19880527), ('Kirsten', 19810703), ('Taylor', 19881121), ('Rebecca', 19880627), ('Maggie', 19881230), ('Arianna', 19910421), ('Katrina', 19860415), ('Jennifer', 19851029), ('Amber', 19920313), ('Kali A', 19880211), ('Merritt', 19890702), ('Whitney', 19860409), ('Jovana', 19900831), ('Daisy', 19841010), ('Danice', 19801001), ('Dana', 19870713), ('Kellie', 19871004), ('Magdalena', 19880701), ('Alison', 19900425), ('Myke', 19610608), ('Isadora', 19920421), ('Kelly', 19900622), ('Kristina', 19890516), ('Lindsey', 19930106), ('Emily Theresa', 19901123), ('Lauren', 19900423), ('Jenna', 19931127), ('Elizabeth', 19831216), ('Kelly', 19891215), ('Chelsea', 19880701), ('Sabrina', 19930104), ('Jamila', 19920114), ('Tracy', 19860926), ('Whitney', 19870831), ('Margaret', 19910927), ('Alexandra', 19920422), ('Mikayla', 19880525), ('Hailee', 19880530), ('Maureen', 19900314), ('Catherine R', 19910609), ('Erin', 19900530), ('Maryam', 19930203), ('Shabnam', 19910726), ('Caitlyn', 19931013), ('Chelsea', 19850919), ('Ashley', 19820703), ('Christina', 19890331), ('Chanel', 19930618), ('Amanda', 19890125), ('Alexandra', 19891129), ('Monica', 19901123), ('Lauren', 19890811), ('Jacquelyn', 19870304), ('Jacquelynn', 19890111), ('Courtney M', 19880916), ('Courtney', 19820114), ('Kristen', 19820114), ('Cameron', 19881217), ('Caroline', 19900110), ('Susanne', 19750213), ('Sarah', 19920801), ('Niltooli', 19900411), ('Victoria', 19891231), ('Hiromi', 19900510), ('Rachel', 19900209), ('Sena', 19970605), ('Christi', 19960204), ('Tatum', 19970428), ('Madeline', 19940911), ('Julia', 19890628), ('Kelly', 19941021), ('Jasmine Janelle', 19920519), ('Maria', 19950924), ('Monet', 19960106), ('Cordelia Currey', 19930607), ('Millie', 19911004), ('Madison', 19941227), ('Zaina', 19970519), ('Katelyn', 19870608), ('Amanda', 19961028), ('Anna Kate', 19941011), ('Tamijean', 19980616), ('Victoria', 19961202), ('Christiana', 19951116), ('Angie', 19750716), ('Kerry', 19680528), ('Anna', 19960128), ('Sabrina', 19920113), ('Brienne', 19971125), ('Sarah', 19960513), ('Stephanie J', 19960305), ('Alexus', 19970206), ('Alexandra', 19990630), ('Chloe', 19900921), ('Megan', 19960122), ('Erin', 19941226), ('Sydney', 19950909), ('Katherine', ''), ('Lauren', 19990905), ('Teresa', 19941010), ('Alix', 19950718), ('Alaina', 19980809), ('Cassie', 19950201), ('Morgan', 19940208), ('Kenna', 19930918), ('Kelli', 19931202), ('Lauren', 19940618), ('Katrina', 19920314), ('Taylor', 19921208), ('Sara Catherine', 19970130), ('Tamara', 19850418), ('Mckenna Alexandra', 19970303), ('Caroline', 19990809), ('Hada', 19980710), ('Lauren', 19970108), ('Jacara', 19980704), ('Ndindi Inziani', 19971224), ('Susanne', 19980505), ('Bianca', 19960804), ('Caitlin', 19960406), ('Iesha', 19911109), ('Chelsie Marie', 19920321), ('Aurora', 19921204), ('Alexandra', 19950811), ('Karolina', 19990305), ('Skylar', 19950616), ('Jillian', 20010513), ('Gabrielle', 19960114), ('Gabriella', 19971216), ('Allison', 19980324), ('Madeline', 19970403), ('Darya', 19981019), ('Seriana', 19980227), ('Erin', 19960312), ('Katherine', 20001206), ('Vivian', 20000111), ('Stephanie M', 19931110), ('Sabrina', 19971216), ('Kate', 19971013), ('Emma', 20000212), ('Lauren', 20010728), ('Kayla', 19930220), ('Khume', 19961023), ('Christiana', 19970614), ('Candace Olivia', 19800101), ('Alycia', 20001231), ('Mikayla', 19990722), ('Tiffany', 19971009), ('Sanyukta', 20010928), ('Karly', 19850115), ('Emma', 19940624), ('Arielle', 20000910), ('Marjorie', 19980202), ('Anastasiya', 19990324), ('Natasha', ''), ('Addison', ''), ('Mbalia', 19980107), ('Safiya', ''), ('Taylor', 20010406), ('Natasha', 19920609), ('Katherine', 20010213), ('Madison', 19961215), ('Omolola', 19840818), ('Reagan', 19980505), ('Katelyn', 19960909), ('Sophie', 20021031), ('Gabrielle', 19920202), ('Taylor', 19981203), ('Andrea', 19940728), ('Annie', 19870905), ('Olivia', 19990308), ('Imani', 20011220), ('Lauren', 20020523), ('Taylor', 20000807), ('Nicole', 20000304), ('Jane', 19881118), ('Chelsea', 20000819), ('Peyton', 19990915), ('Ellie', 20000523), ('Jane', 19931227), ('Anna', 20010815), ('Rosalyn', 19930622), ('Madison', 19990419), ('Sophia', 20010718), ('Jasmine', 19990813), ('Theresa', 19701102), ('Spirit', 19941027), ('Najah', 20010909), ('Sharmada', 19990810), ('Nicole', 20000812), ('Nina', 20020117), ('Alexa', 20020906), ('Naomi', 20020516), ('Sabina', 20010406), ('Katie', 20011231), ('Nikki', 20011019), ('Mccartney', 19990708), ('Tricia', 19920706), ('Peyton', 20011008), ('Anika', 20010807), ('Dalayna', 20001216), ('Kolie', 20000317), ('Cassie', 19960225), ('Anna', 20020102), ('Monica', 19950419), ('Taysia', 20000708), ('Kathleen', 19940728), ('Amanda', 19990718), ('Jimena', 20000707), ('Cassidy', 19950510), ('Brittany', 19950405)]","[('Jolene', 19680831), ('Lisa', 19730810), ('Meilen', 19780117), ('Serena', 19810926), ('Chanda', 19760218), ('Amy', 19720919), ('Tara', 19770526), ('Meghann', 19790413), ('Erika', 19721014), ('Lilia', 19780407), ('Jane', 19740621), ('Jennifer', 19760329), ('Alexandra', 19801215), ('Linda', 19710211), ('Brie', 19800121), ('Corina', 19780126), ('Marissa', 19800623), ('Lindsay', 19760608), ('Kathleen', 19461027), ('Geri', ''), ('Rosie', 19480916), ('Joan', ''), ('Mary Ann', 19461125), ('Billie Jean', 19431122), ('Patti', 19491221), ('Sharon', 19520224), ('Mona', 19481128), ('Ann', 19510504), ('Chris', 19541221), ('Janet', 19530806), ('Jill', 19540519), ('Julie', 19451208), ('Ann', 19550822), ('Joy', 19540519), ('Pam', 19510417), ('Peggy', 19490202), ('Martina', 19561018), ('Laura', 19490504), ('Sally', 19550325), ('Cecilia', 19470524), ('Rene', 19570512), ('Beth', 19570613), ('Patricia', 19511125), ('Kim', 19561011), ('Betsy', 19561023), ('Barbara', 19570402), ('Dianne', 19580811), ('Felicia', 19570720), ('Lindsay', 19550124), ('Lele', 19560910), ('Diane', 19550615), ('Rosalyn', 19601102), ('Marcie', 19530910), ('Pam', 19620704), ('Barbara', 19570501), ('Candy', 19550324), ('Bonnie', 19630911), ('Barbara', 19611022), ('Anne', 19590701), ('Paula', 19570110), ('Nancy', 19550522), ('Andrea', 19650604), ('Anne', 19610928), ('Leslie', 19570312), ('Kathy', 19591203), ('Mary Lou', 19610806), ('Sherry', 19590606), ('Lea', 19590120), ('Kim', 19571222), ('Tracy', 19621212), ('Kate', 19521025), ('Wendy', 19600929), ('Andrea', 19640118), ('Zina', 19631116), ('Susan', 19640628), ('Camille', 19660602), ('Alycia', 19610218), ('Jane', 19531206), ('Vicki', 19620925), ('Heather', 19610611), ('Robin', 19631210), ('Gigi', 19640222), ('Kathy', 19670324), ('Anna Maria', 19601022), ('Beth', 19640528), ('Lori', 19631218), ('Laura', 19630317), ('Kim', 19570928), ('Shelley', 19630619), ('Barbara', 19640703), ('Michaela', 19660227), ('Shawn', 19671221), ('Elise', 19620305), ('Sandy', 19581013), ('Linda', 19691224), ('Lisa', 19620714), ('Terry', 19551128), ('Ann', 19591031), ('Lisa', 19651016), ('Molly', 19650312), ('Hu', 19630416), ('Dee Ann', 19620611), ('Jamie', 19620121), ('Beverly', 19650909), ('Louise', 19620107), ('Cammy', 19681011), ('Susan', 19590415), ('Caryn', 19610314), ('Tina', 19521124), ('Terry', 19661218), ('Marianne', 19671017), ('Gretchen', 19640207), ('Kathrin', 19621128), ('Pamela', 19630703), ('Lindsay', 19620731), ('Jennifer', 19670702), ('Jennifer', 19620426), ('Carol', 19621009), ('Jill', 19640904), ('Elizabeth', 19680826), ('Pam', 19631220), ('Melissa', 19680411), ('Cynthia', 19640326), ('Amy', 19690902), ('Sherri', 19640202), ('Stephanie', 19650206), ('Patty', 19650331), ('Penny', 19640411), ('Wendy', 19640420), ('Katrina', 19680805), ('Leigh Anne', 19641214), ('Donna', 19710705), ('Jennifer', 19690226), ('Andrea', 19710930), ('Anna', 19660117), ('Kimberly', 19730327), ('Laxmi', 19721109), ('Kathy', 19650825), ('Halle', 19690805), ('Ronni', 19660510), ('Ann', 19701013), ('Mary Joe', 19710819), ('Jeri', 19701211), ('Carrie', 19720428), ('Shaun', 19681213), ('Audra', 19711117), ('Stacey', 19701113), ('Tami', 19681113), ('Stacey', 19680319), ('Ginger', 19680914), ('Monica', 19731202), ('Patty', 19680118), ('Nicole', 19690826), ('Jessica', 19700913), ('Kimberly', 19711020), ('Stephanie', 19691105), ('Debbie', 19700825), ('Susan', 19701205), ('Caroline', 19660825), ('Elly', 19690825), ('Meredith', 19710428), ('Sandra', 19740910), ('Anne', 19770119), ('Lindsay', 19770628), ('Venus', 19800617), ('Samantha', 19790117), ('Karin', 19771210), ('Jill', 19740704), ('Bunny', 19570905), ('Rayni', 19560524), ('Jennifer', 19810210), ('Holly', 19790210), ('Nancy', 19420823), ('Dorothy', 19250703), ('Kristy', 19500815), ('Valerie', 19490629), ('Linda', 19501021), ('Peaches', 19490416), ('Tory Ann', 19420808), ('Pamela', 19500312), ('Denise', 19500731), ('Wendy', 19470331), ('Becky', ''), ('Nancy', 19520731), ('Barbara', 19540304), ('Kristien', 19520725), ('Janet', 19530628), ('Daryl', 19540507), ('Ching Ling', 19481008), ('Robin', 19580513), ('Patricia', 19410811), ('Laurie', 19551104), ('Donna', 19541109), ('Linda', 19521114), ('Julie', 19480113), ('Jeanne', 19571005), ('Laurie', 19550614), ('Kathy', 19560618), ('Janice', 19520710), ('Kathy', 19561123), ('Jane', 19530810), ('Marita', 19560219), ('Susie', 19570916), ('Mary', 19500721), ('Mary', 19540907), ('Mary', 19570312), ('Carrie', 19550822), ('Ruta', 19551118), ('Mareen', 19600815), ('Robin', 19560413), ('Caroline', 19601104), ('Emilse', 19571219), ('Kay', 19570925), ('Zenda', 19591212), ('Betty Ann', 19500226), ('Jeanne', 19591207), ('Linda', 19610605), ('Julie', 19620205), ('Stacy', 19590405), ('Dana', 19591126), ('Roberta', 19581103), ('Joyce', 19580503), ('Andrea', 19550406), ('Trey', 19591127), ('Jenny', 19650419), ('Leigh Anne', 19640108), ('Joanne', 19541030), ('Michelle', 19670627), ('Nancy', 19580418), ('Felicia', 19611231), ('Jean', 19581025), ('Barbi', 19640914), ('Amy', 19650405), ('Jill', 19600623), ('Ginny', 19661115), ('Grace', 19680416), ('Melissa', 19690624), ('Debbie', 19670809), ('Eileen', 19661201), ('Maeve', 19641116), ('Kathleen', 19610905), ('Niurka', 19690419), ('Cecilia', 19630628), ('Kristin', 19590827), ('Kate', 19630111), ('Liezel', 19760821), ('Mashona', 19760531), ('Stephanie', 19460308), ('Marilyn', 19480308), ('Mimi', ''), ('Alice', 19421122), ('Pixie', ''), ('Betty', 19250415), ('Nadine', 19441026), ('Victoria', ''), ('Stephanie', 19500703), ('Carole', 19430624), ('Gail', 19510421), ('Patricia', 19400101), ('Eliza', 19530102), ('Patricia', 19450828), ('Sandy', 19560501), ('Tam', 19520127), ('Wendy', 19520430), ('Kathy', 19461218), ('Lisa', ''), ('Judy', 19490816), ('Roberta', 19560702), ('Mary', 19450925), ('Aleida', 19550616), ('Erin', 19550720), ('Stephanie', 19560325), ('Karen', 19421211), ('Sheila', 19580222), ('Susie', 19620329), ('Micki', 19601129), ('Heather', 19610712), ('Jane', 19620121), ('Diane', 19611105), ('Shawna', ''), ('Tammy', 19651012), ('Tracy', 19791006), ('Allison', 19801114), ('Ansley', 19820105), ('Dawn', 19760529), ('Kristen', 19840628), ('Vija', ''), ('Farel', ''), ('Connie', 19510521), ('Marjorie', 19510503), ('Peggy', ''), ('Tish', ''), ('Jade', ''), ('Carole', ''), ('Emilie', ''), ('Diane', ''), ('Mary', ''), ('Ann', ''), ('Tina', ''), ('Maricaye', ''), ('Roylee', 19490526), ('Nancy', 19330421), ('Louise', 19470321), ('Mimi', 19390818), ('Raymonde', ''), ('Carol', ''), ('Joyce', 19420223), ('Pat', 19340819), ('Jane', 19510220), ('Darlene', 19360106), ('Pam', 19501025), ('Carol', ''), ('Emilie', ''), ('Margaret', 19500413), ('Pam', ''), ('Susan', 19531113), ('Shari', ''), ('Sue', 19540603), ('Jeanne', 19350721), ('Kathy', 19521219), ('Gertrude', 19230908), ('Judy', 19430402), ('Brenda', 19540211), ('Patricia', 19580516), ('Marcy', ''), ('Sally', ''), ('Lynne', 19580328), ('Margaret', 19530105), ('Renee', 19340819), ('Carol', 19501022), ('Chris', 19561026), ('Kelly', 19620418), ('Lisa', 19590305), ('Lucy', ''), ('Jody', 19560704), ('Phyllis', 19570326), ('Linda', 19631106), ('Karen', 19640323), ('Eleni', 19671023), ('Lisa', 19680718), ('Sandra', 19690903), ('Shannan', 19700519), ('Julie', 19760424), ('Nicole', 19760203), ('Angela', 19720404), ('Keri', 19740501), ('Jacqueline', 19801126), ('Laura', 19810512), ('Jean', 19740607), ('Melissa', 19820606), ('Amber', 19840706), ('Sarah', 19811106), ('Ashley', 19850502), ('Bethanie', 19850323), ('Allison', 19860410), ('Bea', 19801128), ('Alexandra', 19850902), ('Carly', 19861126), ('Theresa', 19850310), ('Gabriela', 19800607), ('Shenay', 19840706), ('Angela', 19840927), ('Kelly', 19830318), ('Teryn', 19781212), ('Abigail', 19810712), ('Jessica', 19871110), ('Jamea', 19860907), ('Mary', 19881218), ('Tiffany', 19800314), ('Alexa', 19890910), ('Vania', 19890303), ('Ahsha', 19850321), ('Lauren', 19891001), ('Varvara', 19860521), ('Madison', 19900403), ('Audra', 19860421), ('Ashley', 19890620), ('Julie', 19790104), ('Melanie', 19910923), ('Kristie', 19920615), ('Gail', 19910605), ('Asia', 19910404), ('Coco', 19911206), ('Christina', 19920511), ('Mallory', 19900718), ('Lauren', 19910110), ('Hilary', 19881117), ('Sloane', 19930320), ('Alison', 19900703), ('Jamie', 19900108), ('Chelsey', 19900829), ('Beatrice', 19920406), ('Shelby', 19921013), ('Irina', 19900504), ('Lauren', 19931009), ('Madison', 19950217), ('Nicole', 19740801), ('Michelle', 19731228), ('Akiko', 19720214), ('Joy', 19621006), ('Caryn', 19711005), ('Luanne', 19721228), ('Julie', 19720510), ('Rachel Ann', 19721119), ('Judy', 19620511), ('Noelle', 19701218), ('Alysia', 19710131), ('Laura', 19670517), ('Amanda', 19780620), ('Julie', 19721007), ('Ann', 19670822), ('Melissa', 19720621), ('Jan', 19531223), ('Mary', 19620121), ('Sylvia', 19640127), ('Gail', 19470116), ('Diedre', 19711011), ('Caroline', 19651129), ('Kerry', 19501002), ('Kathy', 19670904), ('Stella', 19690309), ('Karen', 19680705), ('Cynthia', 19580614), ('Marlie', 19501120), ('Rona', 19690708), ('Kylie', 19610519), ('Helena', 19610201), ('Cheryl', 19640503), ('Jennifer', 19690715), ('Elizabeth', 19660406), ('Anne', 19660205), ('Alix', 19721022), ('Erica', 19690716), ('Stephanie', 19700424), ('Jill', 19671011), ('Jane', 19630123), ('Kathy', ''), ('Jean', 19700510), ('Ann', 19651028), ('Kirsten', 19690327), ('Wendy', 19600327), ('Nicole', 19610906), ('Vicki', 19570325), ('Mary Ann', 19560424), ('Christine', 19680118), ('Jennifer', 19600326), ('Julie', 19570621), ('Penny', 19550826), ('Cathy', 19580310), ('June', 19630619), ('Pam', 19750701), ('Stephanie', 19791023), ('Jane', ''), ('Gretchen', 19650626), ('Jane', 19660324), ('Holyn', 19731012), ('Kristi', 19690910), ('Linley', 19620501), ('Shelby', 19500626), ('Andrea', 19700128), ('Kathy', 19591224), ('Danielle', 19700322), ('Carol', 19610705), ('Jean', 19550606), ('Lori', 19650330), ('Edie', ''), ('Robin', ''), ('Kerri', 19681001), ('Lisa', 19700324), ('Mary', 19660508), ('Carol', 19591113), ('Katie', 19750429), ('Michele', 19660606), ('Shannon', 19670527), ('Gina', 19490515), ('Clare', ''), ('Cathleen', 19570316), ('Janice', 19510522), ('Betsy', 19540503), ('Lucia', 19601022), ('Wendy', 19680715), ('Allyson', 19631007), ('Debbie', 19620722), ('Marsha', ''), ('Linda', 19690503), ('Page', 19740622), ('Heather', 19711011), ('Gigi', 19701007), ('Marilda', 19650222), ('Christine', 19720714), ('Cynthia Ann', 19521114), ('Jenny', 19710226), ('Shelley', 19650421), ('Jackie', 19640104), ('Stephanie', ''), ('Michelle', 19610116), ('Genevieve', 19630819), ('Glynis', ''), ('Ann', 19520526), ('Allegra', ''), ('Cricket', 19610507), ('Bunny', 19460729), ('Holly Ann', 19701218), ('Amy', 19721112), ('Kathy', 19631005), ('Monique', 19841006), ('Erica', 19721128), ('Susan', 19651125), ('Rita', 19601018), ('Nina', 19610207), ('Donna', 19591005), ('Cissie', 19600108), ('Nancy', 19640804), ('Erika', 19631007), ('Cristina', 19770210), ('Terri', 19680118), ('Patty', 19730928), ('Katrina', 19681104), ('Katrina', 19800530), ('Anne', 19810420), ('Cory Ann', 19850122), ('Nicole', 19861103), ('Diana', 19790704), ('Tanner', 19840803), ('Shadisha', 19850712), ('Leslie', 19870525), ('Neha', 19860206), ('Megan', 19850719), ('Elizabeth', 19880603), ('Jewel', 19810910), ('Lindsey', 19851118), ('Raquel', 19821208), ('Brittany', 19910919), ('Kirsten', 19880814), ('Chieh Yu', 19920114), ('Alexis', 19830331), ('Amanda', 19861204), ('Catherine', 19940409), ('Tetiana', 19840904), ('Julia', 19910909), ('Alexandra', 19880214), ('Zoe Gwen', 19930921), ('Julia', 19890323), ('Jessica', 19940224), ('Grace', 19940506), ('Chi Chi', 19920705), ('Nicole', 19930303), ('Mallory', 19910128), ('Jennifer', 19860922), ('Samantha', 19950218), ('Victoria', 19951130), ('Maria', 19891126), ('Anne', 19850828), ('Megan', 19850311), ('Lena', 19881115), ('Katie', 19830503), ('Courtney B', 19920325), ('Kimberly', 19890509), ('Jacqueline', 19910830), ('Ester', 19930704), ('Eleanor', 19880626), ('Yasmin', 19880504), ('Anne Liz', 19960526), ('Alessondra', 19900906), ('Ryann', 19960723), ('Lucie', 19720406), ('Kelly S', 19730905), ('Kristina', 19790811), ('Wendy', 19750131), ('Julie', 19751016), ('Aurandrea', 19791121), ('Brandis', 19800213), ('Megan', 19781224), ('Alyssa', 19821119), ('Jennifer', 19780807), ('Jennifer', 19840217), ('Candice', 19820331), ('Michelle', 19780119), ('Kristy', 19790517), ('Andrea', 19881006), ('Lauren', 19800829), ('Iris', 19850613), ('Jennifer', 19810718), ('Ali', 19870923), ('Nicole', 19851124), ('Kaysie', 19800411), ('Krystina', 19880510), ('Riza', 19860210), ('Sarah', 19810627), ('Megan', 19830326), ('Story', 19830502), ('Christina', 19801127), ('Stacia', 19850921), ('Kaitlyn', 19920113), ('Chloe', 19900201), ('Amanda', 19870902), ('Kelcy', 19890411), ('June', 19950619), ('Krista', 19940914), ('Adria', 19791221), ('Susie', 19721210), ('Kori', 19731101), ('Elizabeth', 19770823), ('Agnes', 19800801), ('Courtenay', 19770227), ('Dee Dee', 19790211), ('Aurora', 19741107), ('Keirsten', 19730917), ('Ingrid', 19730602), ('Stephanie', 19761207), ('Sara', 19770113), ('Lori', 19810731), ('Milangela', 19811209), ('Brooke', 19790101), ('Lauren', 19820521), ('Amanda', 19780119), ('Kelley', 19850922), ('Meredith', 19720604), ('Jackie', 19840111), ('Megan', 19780427), ('Amanda', 19811126), ('Cammy', 19701225), ('Ditta', 19751226), ('Jennifer', 19731228), ('Krissy', 19791211), ('Annica', 19780902), ('Tory', 19850618), ('Whitney', 19860123), ('Sarah', 19801121), ('Jessyca', 19800826), ('Beau', 19800626), ('Katrina', 19880707), ('Stephanie', 19790129), ('Jennifer', 19881123), ('Jessica', 19871124), ('Sarah', 19880209), ('Kim Anh', 19831004), ('Ellah', 19881122), ('Lauren', 19820914), ('Link', 19861125), ('Aleke', 19820427), ('Kendra', 19831118), ('Arpi', 19830612), ('Erin', 19900328), ('Tiffany', 19820909), ('Robin', 19830621), ('Kristi', 19851222), ('Jennifer Lee', 19870227), ('Veronica Ruo Qi', 19891110), ('Danielle', 19910328), ('Shilpa', 19840412), ('Elizabeth', 19880526), ('Megan', 19870701), ('Melissa', 19880408), ('Lauren', 19890522), ('Alana', 19851031), ('Riley', 19901114), ('Kristen', 19880323), ('Mami', 19790715), ('Kit', 19810726), ('Stacey', 19910718), ('Elizabeth', 19810315), ('Nina', 19890707), ('Nadja', 19900607), ('Erica', 19901127), ('Jenna', 19851126), ('Tiya', 19860611), ('Natalie', 19850322), ('Courtney', 19820929), ('Kristy', 19900108), ('Susanna', 19831103), ('Alexa', 19901117), ('Aeriel', 19900928), ('Maureen', 19820528), ('Allie', 19910420), ('Sanaz', 19880621), ('Lauren', 19760912), ('Alexis', 19840927), ('Libby', 19940124), ('Lauren', 19930723), ('Michaela', 19880722), ('Tori', 19871124), ('Gabrielle', 19930227), ('Danielle Rose', 19931213), ('Tarakaa', 19860811), ('Danielle', 19910528), ('Ellen', 19931008), ('Brooke', 19920408), ('Mccall', 19900315), ('Macall', 19860205), ('Megan', 19880705), ('Nicole', 19930729), ('Alexandra', 19911130), ('Elizabeth', 19860524), ('Jade', 19921028), ('Brie', 19890507), ('Jan', 19950301), ('Simone', 19891230), ('Elizabeth', 19860731), ('Gabrielle Faith', 19961223), ('Sachia', 19950511), ('Taylor', 19960416), ('Lindsey', 19900104), ('Alexandra', 19950630), ('Alexandra', 19910213), ('Robin', 19930412), ('Brianna', 19940219), ('Olivia', 19960122), ('Whitney', 19860811), ('Emily J', 19910615), ('Caroline B', 19941031), ('Chalena', 19950818), ('Elizabeth Anita Alexandria', 19960806), ('Breanna Alexa Bachini', 19930521), ('Mary', 19950817), ('Betsy', 19600427), ('Eve', 19621028), ('Janet', 19670405), ('Jaime', 19611001), ('Angel', 19610830), ('Donna', 19550626), ('Valerie', 19540813), ('Lucinda', 19520717), ('J', ''), ('J', ''), ('D', ''), ('K', ''), ('B', ''), ('J', ''), ('R', ''), ('N', ''), ('E', ''), ('F', ''), ('Caroline', 19560622), ('D', ''), ('Wendy', ''), ('Nancy', 19530830), ('Susan', 19570107), ('Gretchen', 19560201), ('Anne', ''), ('Holly', 19690811), ('Margaret', 19601012), ('Clare', 19671008), ('Kathy', 19641104), ('Rita', 19660512), ('Marlene', 19810731), ('Linda', 19570701), ('Beverly', 19530124), ('Ann', 19551013), ('Robin', 19540923), ('A', ''), ('Maria', ''), ('Karen', ''), ('Karen', ''), ('Jenny', ''), ('Lisa', ''), ('Kathy', ''), ('Maria', 19600424), ('Judith', ''), ('Becky', ''), ('Connie', ''), ('Lori', ''), ('Joni', 19651125), ('Lisa', ''), ('Suzanne', ''), ('Shandra', 19680519), ('Merrilee', ''), ('Jennifer', 19660615), ('Chris', ''), ('Trisha', 19690203), ('Stephanie', 19690818), ('Sonya', 19670825), ('Susan', 19710412), ('Tanya', 19690302), ('Tonya', 19690821), ('Kara', 19730105), ('Melissa', 19740402), ('Victoria', 19761230), ('Trina', 19821230), ('Kristine', 19720623), ('Martha', 19691215), ('Candice', 19800207), ('Cindy', 19790422), ('Elizabeth', 19740824), ('Valerie', 19731228), ('Tracey', 19710129), ('Diana', 19680410), ('Alice', 19770830), ('Allison', 19660804), ('Vickie', 19710827), ('Stacey', 19750105), ('Marissa', 19780613), ('Susanna', 19720303), ('Rebecca', 19721119), ('Ashley', 19720408), ('Varalee', 19760502), ('Stephanie', 19770408), ('Elizabeth', 19631112), ('Bridget', 19740207), ('Leslie', 19720209), ('Traci', 19780805), ('Alison', 19741125), ('Amy', 19681007), ('Vanessa', 19760513), ('Laura', 19720426), ('Anna', 19761021), ('Betsy', 19751127), ('Kristen', 19781002), ('Mugette', 19810424), ('Tu', 19780208), ('Irene', 19790612), ('Jennifer', 19720416), ('Diana', 19751029), ('Jody', 19711122), ('Samantha', 19890509), ('Tristen Z', 19940501), ('Rachel', 19920719), ('Ashley', 19871106), ('Alexandra', 19920223), ('Natalie', 19910801), ('Lindsay', 19880226), ('Amelia', 19920802), ('Caroline', 19930313), ('Camila', 19950929), ('Josie', 19951105), ('Skylar Alexandra', 19940424), ('Brooke', 19960212), ('Alexandra', 19910413), ('Daniella', 19971105), ('Hayley', 19950517), ('Jody', 19780930), ('Ella', 19760917), ('Emily Ann', 19820328), ('Jacquelyn', 19801117), ('Lesley', 19781011), ('Kristen', 19770518), ('Cara', 19720421), ('Zuzanna', 19800403), ('Katie', 19800911), ('Marilyn', 19740114), ('Lena', 19830510), ('Brandi', 19770612), ('Andrea', 19780204), ('Sara', 19801022), ('Hillary', 19820417), ('Mariel', 19800220), ('Whitney', 19800508), ('Darian', 19790615), ('Alexandra', 19820310), ('Prim', 19810115), ('Janet', 19800628), ('Rachel', 19690211), ('Lindsay', 19821207), ('Kirsty', 19780517), ('Raluca Daniela', 19830717), ('Mindy', 19720322), ('Erin', 19830419), ('Mary Carlisle', 19780716), ('Erin', 19800116), ('Keiko', 19800429), ('Maiko', 19820623), ('Paige', 19740714), ('Janet', 19790529), ('Briana', 19781221), ('Stacey', 19721219), ('Kristin', 19720204), ('Julia', 19810518), ('Rochelle', 19800430), ('Selin', 19780706), ('Jennifer', 19730117), ('Luana', 19821205), ('Whitney', 19850811), ('Paloma', 19720823), ('Tumeka', 19761226), ('Maria', 19830319), ('Hyacinth', 19610809), ('Eva', 19840706), ('Kara', 19790920), ('Katie', 19841110), ('Melissa', 19840613), ('Emmy', 19870722), ('Alexandria', 19860310), ('Shari', 19641103), ('Michelle', 19791212), ('Alexandra', 19841228), ('Nicole', 19860203), ('Monica', 19851212), ('Caitlin', 19850517), ('Lia', 19800922), ('Michelle', 19870304), ('Sybil', 19770106), ('Jodi', 19810822), ('Liberty', 19870409), ('Mimi', 19841030), ('Melissa', 19861211), ('Jessi', 19870221), ('Courtney', 19880501), ('Chrissie', 19870902), ('Yvette', 19880612), ('Audra', 19830331), ('Leila', 19860206), ('Tamara', 19790924), ('Rebekah', 19791012), ('Sabita', 19840927), ('Shannon', 19870109), ('Courtney', 19851011), ('Polina', 19860408), ('Anamika', 19890413), ('Jie', 19871101), ('Georgette', 19840709), ('Christy', 19871212), ('Suzanne', 19880117), ('Courtney', 19900327), ('Cammie', 19871122), ('Nelly', 19901113), ('Veronica', 19870514), ('Keilly', 19900505), ('Kate', 19831111), ('Reka', 19890708), ('Bianca', 19890514), ('Thien Trang', 19910918), ('Pamela', 19910101), ('Morgan', 19920220), ('Julianna', 19850107), ('Subbadharmi', 19890708), ('Stephanie', 19930216), ('Kelsey', 19910408), ('Alexandra', 19870719), ('Amanda', 19880314), ('Chelsea', 19891211), ('Anna', 19840821), ('Jill M', 19910313), ('Kady', 19860317), ('Phoebe', 19880520), ('Emily', 19921201), ('Christian', 19840913), ('Keri', 19891225), ('Sabrina', 19860112), ('Nataly', 19900913), ('Maria', 19920619), ('Noel', 19930203), ('April', 19920508), ('Ellie', 19930808), ('Stephanie', 19901027), ('Nicole', 19911031), ('Anna', 19940308), ('Veronika', 19900920), ('Annie', 19930330), ('Kyle', 19940405), ('Chanelle', 19940119), ('Yawna', 19860801), ('Hilary', 19910513), ('Ivana', 19861108), ('Gira', 19860829), ('Claire', 19891129), ('Erin', 19880609), ('Caitlin', 19880219), ('Alexandra', 19850703), ('Jennifer', 19950412), ('Kimberly', 19961015), ('Natalie', 19891102), ('Elizaveta Anna', 19930831), ('Veronica M', 19911207), ('Karina', 19950706), ('Sylvia', 19860904), ('Sherry', 19950208), ('Katrine Isabel', 19960315), ('Denise', 19950417), ('Courtney', 19940325), ('Christina', 19960529), ('Noelle', 19881205), ('Lauren', 19950517), ('Breaunna', 19941222), ('Nicole', 19941230), ('Meredith', 19970521), ('Nadia', 19950114), ('Jackie', 19710922), ('Antoinette', 19850107), ('Kathleen', 19740511), ('Kylene', 19790725), ('Dana', 19730725), ('Audra', 19720605), ('Tracee', 19731009), ('Amie', 19800517), ('Jennifer', 19811128), ('Lashawnn', 19740602), ('Jacqueline', 19820209), ('Jennifer', 19770119), ('Kristy', 19741230), ('Susan', 19741201), ('Bridget', 19761018), ('Amy', 19690628), ('Sandra', 19750116), ('Khristen', 19750803), ('Stefanie', 19810322), ('Barrie', 19730724), ('Kate', 19820415), ('Amy', 19731107), ('Anne', 19780520), ('Lauren', 19740830), ('Dewonder', 19590127), ('Kendra', 19790828), ('Jamie', 19801106), ('Jennifer', 19750823), ('Audrey', 19850430), ('Marjorie', 19750503), ('Katie', 19770527), ('Aimee', 19820110), ('Megan', 19810519), ('April', 19781129), ('Maren', 19791106), ('Sarah', 19780514), ('Marie Ange', 19780114), ('Dina', 19680406), ('Margaret', 19760707), ('Mary Beth', 19760329), ('Patricia', 19841020), ('Ashley', 19821229), ('Kathryn', 19790225), ('Leslie', 19810718), ('Becky', 19640801), ('Julie', 19811223), ('Danielle', 19781110), ('Terri', 19650402), ('Amy', 19681215), ('Douglas', 19840522), ('Sara', 19850621), ('Karla', 19770318), ('Kristin', 19841130), ('Kristin', 19810705), ('Bonnie', 19850503), ('Natalie', 19830401), ('Jennifer', 19830702), ('Claire', 19700527), ('Lauren', 19780316), ('Alison', 19791129), ('Laura', 19710624), ('Katia', 19810816), ('Kara', 19771202), ('Violette', 19790927), ('Lisa', 19740221), ('Evonne', 19740923), ('Mandy', 19790312), ('Jessica', 19800415), ('Emily', 19811119), ('Callie', 19770711), ('Maggie', 19750529), ('Elina', 19820521), ('Terry Ann', 19740428), ('Kimberly', 19790725), ('Bettina', 19820718), ('Lindsay', 19800519), ('Johanna', 19750518), ('Amy', 19790124), ('Meiling', 19791112), ('Jennifer', 19781020), ('Vania', 19810428), ('Megan', 19831014), ('Lindsey', 19800201), ('Megan', 19820411), ('Angela', 19840329), ('Megan', 19840920), ('Nicolette', 19831108), ('Anita', 19860219), ('Alessandra', 19870112), ('Aradhana', 19820709), ('Tiffany', 19831228), ('Macey', 19830224), ('Kelcy', 19861225), ('Caylan', 19820701), ('Stephanie', 19820923), ('Jan', 19580317), ('Kate', 19830530), ('Karen', 19671205), ('Sarah Jane', 19820802), ('Catrina', 19840913), ('Bethany', 19821129), ('Lindsay', 19820811), ('Kathleen', 19820917), ('Amy', 19810415), ('Emilia', 19820204), ('Colleen', 19790212), ('Ashlee', 19850522), ('Saras', 19830726), ('Brittany', 19850420), ('Laila', 19810805), ('Natalie', 19851103), ('Celena', 19790130), ('Marine', 19780929), ('Cara', 19730424), ('Loni', 19810928), ('Christyn', 19850210), ('Cassy', 19850802), ('Manisha', 19770513), ('Jennifer', 19811121), ('Michelle', 19801002), ('Brook', 19851231), ('Samantha', 19840807), ('Stephanie', 19870411), ('Courtney', 19820502), ('Melissa', 19840112), ('Kristin', 19790227), ('Adriana', 19780902), ('Christine', 19831216), ('Julie', 19840521), ('Cristina', 19860826), ('Nadia', 19850209), ('Amanda', 19821020), ('Camelia', 19860406), ('Emily', 19850201), ('Danielle', 19840717), ('Rochelle', 19800627), ('Brianna', 19851215), ('Zena', 19880717), ('Adina', 19870619), ('Lauren', 19880204), ('Lauren', 19870928), ('Meg', 19870811), ('Ristine', 19850116), ('Jennifer', 19841115), ('Lindsey', 19860101), ('Lindsay', 19880524), ('Gloriann', 19840228), ('Patricia', 19740119), ('Kelly', 19820223), ('Amanda', 19870813), ('Elizabeth', 19860128), ('Whitney', 19851225), ('Laura', 19850506), ('Masha', 19840211), ('Karina', 19880811), ('Erin', 19850113), ('Randi', 19870211), ('Kewa', 19860701), ('Hala', 19850809), ('Dasha', 19870606), ('Suzanna', 19861013), ('Colleen', 19880209), ('Blair', 19830904), ('Simone', 19881010), ('Jessica', 19870304), ('Austin', 19860601), ('Preethi', 19850629), ('Christala', 19890709), ('Krista', 19900423), ('Marie', 19830721), ('Ashley', 19861113), ('Latrell', 19891212), ('Sheryl', 19850920), ('Amanda', 19850319), ('Blakeley', 19841114), ('Ashley', 19870917), ('Whitney', 19890109), ('Marlene', 19880329), ('Melissa', 19860801), ('Alex', 19870117), ('Jessica', 19811223), ('Megan', 19890204), ('Jacqueline', 19830608), ('Melody', 19830708), ('Sarah', 19910314), ('Marie', 19910614), ('Daron', 19851128), ('Amy', 19790324), ('Dina', 19871014), ('Mia', 19910312), ('Valerie', 19851231), ('Amanda', 19880523), ('Connor', 19870922), ('Elizabeth', 19920114), ('Brittany', 19870208), ('Kristen A', 19880325), ('Julie', 19880331), ('Sarah', 19880129), ('Emily', 19890724), ('Christine', 19871225), ('Amanda', 19850511), ('Nicole', 19880620), ('Laurianne', 19881018), ('Pamela', 19901124), ('Miya', 19871114), ('Rachel', 19830708), ('Joanna', 19891009), ('Lynn', 19791216), ('Claire', 19871108), ('Paola', 19920827), ('Lauren', 19890512), ('Erin Carol', 19930506), ('Cameron', 19881224), ('Julie', 19870627), ('Stefanie', 19890130), ('Hannah', 19910812), ('Katherine', 19860305), ('Olivia', 19880423), ('Christina', 19880426), ('Christina', 19881212), ('Cierra', 19910927), ('Milena', 19850506), ('Christin J', 19870731), ('Stephanie', 19900327), ('Kaysara', 19910623), ('Nina', 19900115), ('Deirdre', 19901205), ('Kristin', 19841024), ('Jacqueline', 19900913), ('Stephany', 19900609), ('Erica', 19900702), ('Julia', 19910916), ('Grace', 19891211), ('C C', 19911009), ('Sarah', 19910422), ('Marianne', 19850906), ('Monica', 19920622), ('Kate', 19920109), ('Amanda Marie', 19860106), ('Alexa', 19900824), ('Denise', 19890731), ('Molly', 19890525), ('Nelo', 19920705), ('Farwa', 19891101), ('Millie', 19641005), ('Brooke Lindsey', 19940622), ('Lilly F', 19911101), ('Brynn', 19910801), ('Karina', 19831112), ('Tracy', 19740827), ('Desiree', 19931110), ('Rachael', 19910427), ('Alrissa', 19920724), ('Amanda', 19870317), ('Olivia', 19910711), ('Caryssa L', 19920413), ('Monica', 19930108), ('Joelle', 19910606), ('Malika', 19910709), ('Theresa', 19930607), ('Mary Anne', 19920215), ('Morocco', 19921107), ('Mara', 19920222), ('Alejandra Maria', 19950228), ('Catherine', 19880430), ('Kate', 19901106), ('Abigail', 19900209), ('Sabrina', 19930224), ('Heatherm', 19890925), ('Stephanie', 19940511), ('Leighann', 19931204), ('Lauren', 19880816), ('Kayla', 19920921), ('Kir', 19891031), ('Skylar', 19930914), ('Julia', 19931207), ('Meghan', 19930621), ('Nida', 19911029), ('Lauren', 19880905), ('Kelly K', 19910531), ('Alyssa Grace', 19950215), ('Mary', 19911122), ('Madeleine', 19920319), ('Rachel', 19840302), ('Alex', 19911229), ('Kyra', 19960510), ('Suzy', 19940830), ('Remeice', 19891112), ('Kate', 19940201), ('Courtney', 19891015), ('Molly', 19930810), ('Stephanie', 19940131), ('Alexandra M', 19870719), ('Aleksandra', 19960409), ('Erin', 19880709), ('Jessica', 19930428), ('Spencer', 19950125), ('Anik', 19910405), ('Simone', 19920717), ('Emma', 19930623), ('Melissa', 19921004), ('Tina', 19950427), ('Julia', 19940613), ('Rachael', 19931209), ('Shelby', 19930114), ('Epiphany B', 19921217), ('Kaitlin', 19921215), ('Mariana', 19950927), ('Hannah', 19951103), ('Casey', 19910613), ('Deborah', 19940514), ('Jessica', 19931117), ('Kelsey', 19940821), ('Samantha', 19930126), ('Blair', 19940814), ('Martha V', 19900628), ('Amanda', 19930322), ('Sarah', 19920729), ('Emily', 19931112), ('Jamie', 19950308), ('Kelly', 19770505), ('Quinn', 19941110), ('Sophia', 19930330), ('Sierra A', 19900816), ('Mckenzie', 19940107), ('Stacey', 19900117), ('Courtney', 19910226), ('Rosalia', 19900208), ('Sydney', 19950207), ('Mia', 19950406), ('Erin Kane', 19960512), ('Laura', 19841119), ('Eva', 19921222), ('Elizabeth', 19940706), ('Sarah', 19930713), ('Elyse', 19870910), ('Sabrina', 19920912), ('Julia', 19890114), ('Gabriella', 19951208), ('Tanya', 19930914), ('Nyla', 19960730), ('Louisa', 19960516), ('Zina', 19980402), ('Tornado Alicia', 19980512), ('Madison', 19970919), ('Rima', 19951116), ('Kourtney J', 19940907), ('Natasha', 19940823), ('Erin', 19901230), ('Rachel May', 19941113), ('Jillian', 19941210), ('Caroline', 19960315), ('Dominique', 19870203), ('Trelsie', 19890707), ('Angela', 19950604), ('Nicole', 19980429), ('Kim', 19951027), ('Emina', 19930330), ('Lynda', 19921123), ('Joanna Mary', 19930201), ('Caroline', 19960103), ('Julia', 19940403), ('Callie', 19910904), ('Maxine', 19910710), ('Katie', 19921211), ('Emma Christine', 19980201), ('Johnnise', 19960510), ('Katerina', 19970717), ('Jessica', 19970105), ('Marjorie', 19880420), ('Maci', 19931007), ('Kaitlyn', 19971204), ('Jacqueline', 19941203), ('Charity', 19870711), ('Parris', 19980708), ('Jamie', 19930819), ('Miriam Ruth', 19940724), ('Elizabeth', 19910118), ('Amanda', 19860130), ('Lindsay', 19780708), ('Erica', 19860327), ('Dina', 19711211), ('Robyn', 19850111), ('Anita', 19810402), ('Casey', 19840501), ('Emily', 19850224), ('Jamie', 19880415), ('Brittany', 19880627), ('Elizabeth', 19550921), ('Carolyn', 19900415), ('Cassandra', 19891211), ('Prissy', 19910807), ('Kristin', 19830420), ('Diamond', 19901226), ('Celia', 19860527), ('Tiffany', 19891126), ('Jennifer', 19890531), ('Komal', 19930108), ('Roxanne', 19890826), ('Mandy', 19810914), ('Amanda', 19800324), ('Alissa', 19671209), ('Kay', 19570927), ('Jane', 19661222), ('Tracie', 19610116), ('Elizabeth', 19630811), ('Cinda', 19710410), ('Tracy', 19611021), ('Dena', 19650928), ('Hemel', 19660108), ('Karen', 19630803), ('Reka', 19670612), ('Vincenza', 19660820), ('Lisa', 19640803), ('Lynn', 19661018), ('Jill', 19731226), ('Julie', 19710609), ('Kilmeny', 19660218), ('Kay', 19690131), ('Debbie', 19651129), ('Anne Marie', 19660720), ('Leslie', 19660908), ('Lisa', 19630604), ('Lisa', 19611106), ('Tory', 19660712), ('Kylie', 19700509), ('Anya', 19690220), ('Jennifer', 19670106), ('Diana', 19721007), ('Betsy', 19671127), ('Katrina', 19671129), ('Karen', 19701102), ('Susan', 19710206), ('Sherri', 19730118), ('Tonya', 19691110), ('Julie', 19680817), ('Susan', 19710206), ('Jamie', 19691029), ('Alita', 19630112), ('Tara', 19681223), ('Erika', 19720516), ('Kellie', 19670601), ('Happy', 19680605), ('Angie', 19710323), ('Bonnie', 19770412), ('Farley', 19741212), ('Tunecia', 19701023), ('Roseann', 19710227), ('Allison', 19710927), ('Hillery', 19610619), ('La Shawnn', 19740206), ('Sylvia', 19610419), ('Kathy', 19741105), ('Zuzanna', 19790726), ('Cassi', 19850902), ('Lejla', 19870206), ('Danielle', 19820120), ('Geneva', 19871225), ('Katie', 19891023), ('Katie', 19881216), ('Brittany', 19940406), ('Allie', 19950630), ('Sofia', 19981114), ('Mia', 19970723), ('Ty Ana', 19970313), ('Karina Kristina', 19981021), ('Jessica', 19890916), ('Trisha', 19981027), ('Ashley', 19881017), ('Tina', 19920831), ('Tatijana', 19971116), ('Taylor L', 19950117), ('Alexa', 19980707), ('Emerald', 19970905), ('Marie', 19970611), ('Alexandra', 19950224), ('Aleah', 19910923), ('Sarah', 19941219), ('Usue Maitane', 19981028), ('Ellie', 19970710), ('Maia A', 19960921), ('Raquel', 19980128), ('Peggy', 19951110), ('Rebecca', 19971004), ('Camila', 19961125), ('Karyn', 19940912), ('Ayla', 19960715), ('Rasheeda', 19950630), ('Amy', 19941028), ('Ariana', 19960126), ('Luisa', 19951005), ('Mary', 19910802), ('Kristi', 19900427), ('Ronit', 19931203), ('Julia Christine', 19921027), ('Kristina N', 19910125), ('Macie', 19941023), ('Jessica', 19950102), ('Rhiann', 19940622), ('Frances', 19940222), ('Kelly', 19960221), ('Hanna', 19980225), ('Natalie', 19960508), ('Dasha', 19961011), ('Elizabeth', 19910218), ('Brianna', 19951012), ('Kristin', 19951122), ('Kristina', 19951204), ('Maddie', 19971117), ('Raveena', 19980723), ('Daniella', 19971027), ('Laura', 19970305), ('Idia', 19930922), ('Chloe Michele', 19970905), ('Morgan', 19941219), ('Nikki', 19960418), ('Sianna', 19900804), ('Nicole', 19990508), ('Mercedes', 19970525), ('Lourdes', 19990531), ('Adi', 19951213), ('Anna', 19971103), ('Alexandra', 19980719), ('Katarina', 19960704), ('Michaela', 19990726), ('Ena', 19980212), ('Catherine Cartan', 19990408), ('Hadley', 19960311), ('Madison', 19960402), ('Jaeda', 19990728), ('Jeannez', 19960707), ('Erica', 19980316), ('Jessie', 19980419), ('Andie K', 19970107), ('Alexandria', 19960511), ('Gabriella', 19960709), ('Kelly', 19990509), ('Terri', 19960723), ('Angel', 19850125), ('Maria', 19970506), ('Alexis', 19980809), ('Rianna', 19960903), ('Megen', 19960709), ('Caroline', 19980905), ('Sophie', 19970528), ('Nicole', 19960504), ('Jacqueline', 19970531), ('Jessica', 19970709), ('Adriana', 19890308), ('Kylie', 19970606), ('Yuki Kristina', 19950819), ('Lexi', 19950525), ('Caroline', 19970726), ('Ingrid', 19980616), ('Alexandra', 19970301), ('Nada', 20000308), ('Alexis', 19950606), ('Felicity', 19970313), ('Tory', 19930105), ('Aimee', 19940907), ('Alli', 19961203), ('Claudia', 19961206), ('Brooke', 19951010), ('Marina', 19981123), ('Zoe Adeline', 19941217), ('Jessica', 19970605), ('Ashley', 19920829), ('Valerie', 19971122), ('Ashley', 19990208), ('Brittany', 19920303), ('Olivia', 19940623), ('Taylor', 19950731), ('Alexis', 19950724), ('Sara', 19971217), ('Lindsay', 19930107), ('Liza', 19950317), ('Jayci', 20000517), ('Marina', 19920314), ('Sydney', 19990430), ('Alyza', 19951122), ('Sophia', 19920113), ('Riley', 19990615), ('Delaney', 19981028), ('Jane', 19961112), ('Valerie Ann', 19980801), ('Carolyn', 19970524), ('Maegan', 19950416), ('Tamara', 19971129), ('Mary', 19981025), ('Victoria', 19990401), ('Kennedy', 19970521), ('Amy', 19970120), ('Makenna', 19980226), ('Stephanie', 19980415), ('Nicole Taylor', 19990426), ('Claire', 20000525), ('Jada', 19990129), ('Sara', 19970723), ('Hannah', 19960923), ('Sophia', 19971005), ('Akiko', 19930913), ('Karina', 19970808), ('Haley', 19910403), ('Paige', 19970222), ('Kayla', 19990928), ('Carson', 20000909), ('Amanda', 19940813), ('Maria', 19990721), ('Kylie', 19990321), ('Luciana', 19981001), ('Zoe', 20010308), ('Sachi', 19981129), ('Audrey', 19951029), ('Anna', 19970319), ('Abigail', 20010122), ('Cameron', 19990920), ('Katelyn', 19921211), ('Katharine', 19961019), ('Elyse', 19981014), ('Mimi', 19930430), ('Bess', 19971029), ('Ines Karmen', 19970615), ('Taylor', 19990615), ('Kristen', 19970407), ('Sabrina', 19971003), ('Desirae', 19940111), ('Sarah', 19960418), ('Rachel', 19961108), ('Victoria', 19990807), ('Nini', 19950909), ('Francesca', 19970722), ('Makenzie', 19990610), ('Chiara', 19980826), ('Melissa', 19930602), ('Morgan', 19990416), ('Jerricka', 19950116), ('Eva', 19961102), ('Miranda', 19990307), ('Teresia', 19990529), ('Julia', 19971217), ('Malkia', 20000808), ('Lorraine M', 19930615), ('Carol', 19960218), ('Jocelyn', 19900526), ('Roosh', 19920321), ('Alexa', 19980703), ('Alyvia', 20000503), ('Katie', 19990929), ('Meible', 19990519), ('Elizabeth', 20010712), ('Emma', 20010518), ('Arianna', 19950206), ('Kiah', 19950117), ('Alyssa', 20000210), ('Stephanie', 19880402), ('Sofia', 19990722), ('Sarah', 19930814), ('Melan', 19970406), ('Alexandra', 19990105), ('Dilara', 19990911), ('Hurricane Tyra', 20010302), ('Taylor', 19980222), ('Nami', 19980827), ('Marcella', 20001012), ('Sophia', 20010630), ('Delisha', ''), ('Haley', ''), ('Jenna', ''), ('Nikita', 19931021), ('Hoda', ''), ('Meredith', 19990310), ('Morgan', 19950317), ('Kirsten', 19940508), ('Maya', 19940527), ('Kat', 19930215), ('Alexandra', 19930215), ('Meghan', 19971028), ('Salma', 20000828), ('Madeline', 19990307), ('Lindsay', 19981217), ('Alexa', 20010908), ('Mary Catherine', 19971104), ('Cheyenne', 19960326), ('Neri', 19990902), ('Jesse', 20011004), ('Ann', 20000626), ('Natalia', 19930929), ('Whitney', 20020417), ('Christina', 19970725), ('Sofia', 19980703), ('Nicole', 20000805), ('Kenadi', 19970313), ('Paiton', 19980808), ('Shannon', 19950915), ('Elysia', 20000324), ('Ashley', 19991026), ('Alexis', 19970314), ('Caty', 20011120), ('Isabella', 20010706), ('Elizabeth', 20010519), ('Anna', 20020306), ('Dakota', 20020508), ('Janice', 19990105), ('Amanda', 20010831), ('Jada', 19980319), ('Hind', 19990228), ('Mikaela', 19890801), ('Micheline', 19970428), ('Kendal', 19940106), ('Anna', 19991008), ('Mia', 19981021), ('Chloe', 20010830), ('Abigail', 20010310), ('Ryan', 19990510), ('Maia', ''), ('Jana', 19941110), ('Shale', 20011015), ('Helen Abigail', 19980520), ('Kariann', 19990116), ('Kennedy', 19980903), ('Caroline', 19980929), ('Allison', 19981031), ('Melissa', 19970624), ('Ellyse', 19961109), ('Charleen', 19410918), ('Doris', 19250620), ('Patricia', 19370601), ('Pauline', 19190806), ('Helen', 19290507), ('Mary', ''), ('Althea', 19270825), ('Carrie', 19571026), ('Cathy', 19510822), ('Karen', 19570408), ('', ''), ('Barbara', ''), ('Susan', 19611219), ('Jan', 19630609), ('Diane', 19650626), ('Carol', 19620605), ('Leanne', ''), ('Shelley', 19631120), ('Maureen', ''), ('Lorrie', 19601015), ('Tiffany', 19600417), ('Sarah', 19741010), ('Meg', ''), ('Wendy', ''), ('Lynn', 19660819), ('Heidi', 19640507), ('Jacqueline', 19620329), ('Sheri', 19690629), ('Diane', 19710121), ('Angela', 19641211), ('Nancy', ''), ('Liz', 19640423), ('Jamie', 19630530), ('', ''), ('Laura', 19681210), ('Jill', ''), ('Courtney', 19560622), ('Tiffany', 19810121), ('Kristen', 19810501), ('Wendy', 19681001), ('Sheila', ''), ('Heidi', 19601007), ('Julie', 19610523), ('Deborah', 19701129), ('Jennifer', ''), ('Cindy', 19591207), ('Lynn', ''), ('I', ''), ('Lisa', 19600808), ('Jill', 19540907), ('Aschara', ''), ('Heidi', 19720713), ('Julie', 19710609), ('', ''), ('G', ''), ('Stephanie', 19661010), ('Lucy', 19540402), ('Cathy', ''), ('', ''), ('Emmy', ''), ('', ''), ('Claudette', ''), ('Lisa', ''), ('Lynn', 19631114), ('Lindsay', ''), ('Lisa', 19630218), ('Virginia', ''), ('Lloyd', 19451208), ('Suzanne', 19750612), ('Caren', 19611110), ('Allegra', 19720113), ('Molly', 19630215), ('Lori', 19600112), ('Lindsay', 19780417), ('Adrienne', 19680903), ('Quynh', 19710627), ('Kari', 19810120), ('Lisa', 19590212), ('Christa', 19790115), ('Kelly', 19770505), ('Massoumeh', 19770803), ('Louise', 19500119), ('Jayne', 19741006), ('Christine', ''), ('Kim', 19780329), ('Lani', 19600808), ('Julie', 19690425), ('Ruth Ann', 19700506), ('Lauren', 19830423), ('Tasha', 19760223), ('Kealy', 19801030), ('Courtney', 19721230), ('Julie Ann', 19750618), ('Nicole', 19741001), ('Ashlee', 19801005), ('Kelly', 19751106), ('Alexandra', 19790210), ('Mary', 19730912), ('Lisa', 19660204), ('Monty', 19650506), ('Julie Anne', 19800911), ('Lorrie', 19651203), ('Kendra', 19760621), ('Chris', 19610706), ('Christine', 19850303), ('Rankin', 19840126), ('Julia', 19850721), ('Sabaea', 19811125), ('Nicole', 19750602), ('Joyce', 19800628), ('Sarah', 19820410), ('Jean Marie', 19651109), ('Stacey', 19720110), ('Varita', 19820702), ('Shera', 19780910), ('Trisha', 19710617), ('Suzanne', 19680921), ('Lisa', 19801119), ('Martha', 19551005), ('Kandiss', 19770221), ('Brooke', 19780413), ('Cristina', 19750825), ('Jasmine', 19810102), ('Kathleen', 19830125), ('Melissa', 19770524), ('Michelle', 19731114), ('April', 19831011), ('Olivia', 19810310), ('Melissa', 19650221), ('Cami', 19720314), ('Marissa', 19780318), ('Kristin', 19720204), ('Christi', 19610509), ('Cindy', ''), ('Ashley', 19830506), ('Leigh', 19831014), ('Natalia', 19831110), ('Nikhila', 19850208), ('Rachel', 19820916), ('Alison', 19850118), ('Cameron', 19830328), ('Gretchen', 19820304), ('Cackie', 19661107), ('Stephanie', 19650104), ('Miriam', 19850925), ('Nicole', 19880219), ('Lilivette', 19800225), ('Jonni', 19791203), ('Amanda', 19850102), ('Weyli', 19800722), ('Helene', 19841215), ('Amanda', 19841101), ('Nicole', 19870615), ('Stefani', 19841215), ('Laura', 19860217), ('Tifanie', 19880920), ('Mary', 19651124), ('Katherine', 19730414), ('Monica', 19800204), ('Nicole', 19850105), ('Shanna', 19750428), ('Jane', 19890926), ('Estelle', 19890503), ('Maria', 19820204), ('Jessica', 19860812), ('Renata', 19650224), ('Laura', 19830408), ('Lindsey', 19840313), ('Christy', 19850925), ('Timberly', 19831209), ('Brooke', 19850423), ('Kelli Elizabeth', 19940409), ('Melanie', ''), ('Whitney P', 19930625), ('Sydni', 19880612), ('Jasmine Nicole', 19930826), ('Alexandra', 19920812), ('Amber', 19870605), ('Kelsey', 19920610), ('Alex', 19920225), ('Ashley M', 19940304), ('Lauren', 19940828), ('Stacia', 19930914), ('Alexandria', 19900111), ('Rozel Asuncion', 19950616), ('Bolan', 19890908), ('Annie', 19920829), ('Eva', 19941007), ('Whitney', 19900909), ('Hanna', 19911107), ('Mandy', 19910501), ('Gia', 19900614), ('Brooke', 19951105), ('Lisa', 19680519), ('Alexandra M', 19930120), ('Sonya Sheeran', 19940816), ('Shinann', 19900608), ('Nicolette', 19950824), ('Rebecca', 19921125), ('Ashley', 19960430), ('Savannah', 19950115), ('Margaret', 19570423), ('Carlee', 19950724), ('Sarah', 19850718), ('Caroline', 19840926), ('Alexia', 19940421), ('Micaela', 19890311), ('Tina', 19810116), ('Manon Cristina', 19941224), ('Hailey M', 19930127), ('Tiffany', 19911216), ('Devan', 19940528), ('Courtenay', 19770227), ('Christine', 19931110), ('Emily', 19900517), ('Leyla', 19930423), ('Alexis', 19880722), ('Di Andrea', 19950730), ('Jandayia', 19960303), ('Margarita', 19950317), ('Olivia', 19941211), ('Caitlin', 19910905), ('Kara', 19910629), ('Paloma', 19890313), ('Susie', 19491114), ('Emily', 19861118), ('Abbie', 19951121), ('Alanna', 19950107), ('Siobhan', 19871110), ('Kayla Symone', 19960110), ('Margie', 19901106), ('Jamie', 19820521), ('Adria', 19791221), ('Lynn', 19941106), ('Nadege', 19960527), ('Lauren', 19941203), ('Tiffany', 19881204), ('Sarah', 19880907), ('Victoria', 19941214), ('Natalia', 19950325), ('Alexandra', 19931013), ('Montana', 19970219), ('Samantha Rose', 19940410), ('Angela', 19980331), ('Samantha', 19950527), ('Elizabeth', 19890419), ('Sarah', 19941121), ('Gabriela', 19950418), ('Tina', 19911222), ('Mia', 19920116), ('Stephanie', 19920831), ('Kennan', 19960317), ('Madison', 19930602), ('Whitney', 19910815), ('Sarah', 19960925), ('Brooke', 19980614), ('Jessie Lynn', 19951228), ('Brittany', 19941212), ('Kylie', 19870826), ('Erin', 19861102), ('Lindsay', 19821118), ('Jessica', 19801107), ('Yuliya', 19860609), ('Kathryn', 19831129), ('Lyndsey', 19820509), ('Tiana', 19841014), ('Keri', 19870310), ('Sarah', 19871201), ('Alyssa', 19841006), ('Rachel', 19870205), ('Angelina', 19521229), ('Amy', 19540720), ('Bernadette', 19821015), ('Tarrin', 19820423), ('Christine', 19670817), ('Christian', 19870108), ('Emily', 19820728), ('Kelly', 19700330), ('Courtney', 19900729), ('Taylor', 19900818), ('Carissa', 19900507), ('Heather', 19810210), ('Georgiana', 19880624), ('Michelle', 19910127), ('Brintney', 19871008), ('Chisako', 19870720), ('Kristen', 19890819), ('Jessica', 19910223), ('Susie', 19700212), ('Ashley', 19830410), ('Megan', 19890818), ('Larraine', 19910713), ('Courtney', 19920503), ('Tiffany', 19860519), ('Olga', 19880819), ('Shauna', 19900424), ('Canna', 19860515), ('Jennifer', 19890525), ('Keri', ''), ('Lauren', 19890922), ('Whitney', 19880108), ('Caitlyn', 19891220), ('Stephanie', 19890627), ('Jacqueline', 19910905), ('Natalia Maria', 19880414), ('Katie', 19921222), ('Stephanie', 19880527), ('Kirsten', 19810703), ('Taylor', 19881121), ('Rebecca', 19880627), ('Maggie', 19881230), ('Arianna', 19910421), ('Katrina', 19860415), ('Jennifer', 19851029), ('Amber', 19920313), ('Kali A', 19880211), ('Merritt', 19890702), ('Whitney', 19860409), ('Jovana', 19900831), ('Daisy', 19841010), ('Danice', 19801001), ('Dana', 19870713), ('Kellie', 19871004), ('Magdalena', 19880701), ('Alison', 19900425), ('Myke', 19610608), ('Isadora', 19920421), ('Kelly', 19900622), ('Kristina', 19890516), ('Lindsey', 19930106), ('Emily Theresa', 19901123), ('Lauren', 19900423), ('Jenna', 19931127), ('Elizabeth', 19831216), ('Kelly', 19891215), ('Chelsea', 19880701), ('Sabrina', 19930104), ('Jamila', 19920114), ('Tracy', 19860926), ('Whitney', 19870831), ('Margaret', 19910927), ('Alexandra', 19920422), ('Mikayla', 19880525), ('Hailee', 19880530), ('Maureen', 19900314), ('Catherine R', 19910609), ('Erin', 19900530), ('Maryam', 19930203), ('Shabnam', 19910726), ('Caitlyn', 19931013), ('Chelsea', 19850919), ('Ashley', 19820703), ('Christina', 19890331), ('Chanel', 19930618), ('Amanda', 19890125), ('Alexandra', 19891129), ('Monica', 19901123), ('Lauren', 19890811), ('Jacquelyn', 19870304), ('Jacquelynn', 19890111), ('Courtney M', 19880916), ('Courtney', 19820114), ('Kristen', 19820114), ('Cameron', 19881217), ('Caroline', 19900110), ('Susanne', 19750213), ('Sarah', 19920801), ('Niltooli', 19900411), ('Victoria', 19891231), ('Hiromi', 19900510), ('Rachel', 19900209), ('Sena', 19970605), ('Christi', 19960204), ('Tatum', 19970428), ('Madeline', 19940911), ('Julia', 19890628), ('Kelly', 19941021), ('Jasmine Janelle', 19920519), ('Maria', 19950924), ('Monet', 19960106), ('Cordelia Currey', 19930607), ('Millie', 19911004), ('Madison', 19941227), ('Zaina', 19970519), ('Katelyn', 19870608), ('Amanda', 19961028), ('Anna Kate', 19941011), ('Tamijean', 19980616), ('Victoria', 19961202), ('Christiana', 19951116), ('Angie', 19750716), ('Kerry', 19680528), ('Anna', 19960128), ('Sabrina', 19920113), ('Brienne', 19971125), ('Sarah', 19960513), ('Stephanie J', 19960305), ('Alexus', 19970206), ('Alexandra', 19990630), ('Chloe', 19900921), ('Megan', 19960122), ('Erin', 19941226), ('Sydney', 19950909), ('Katherine', ''), ('Lauren', 19990905), ('Teresa', 19941010), ('Alix', 19950718), ('Alaina', 19980809), ('Cassie', 19950201), ('Morgan', 19940208), ('Kenna', 19930918), ('Kelli', 19931202), ('Lauren', 19940618), ('Katrina', 19920314), ('Taylor', 19921208), ('Sara Catherine', 19970130), ('Tamara', 19850418), ('Mckenna Alexandra', 19970303), ('Caroline', 19990809), ('Hada', 19980710), ('Lauren', 19970108), ('Jacara', 19980704), ('Ndindi Inziani', 19971224), ('Susanne', 19980505), ('Bianca', 19960804), ('Caitlin', 19960406), ('Iesha', 19911109), ('Chelsie Marie', 19920321), ('Aurora', 19921204), ('Alexandra', 19950811), ('Karolina', 19990305), ('Skylar', 19950616), ('Jillian', 20010513), ('Gabrielle', 19960114), ('Gabriella', 19971216), ('Allison', 19980324), ('Madeline', 19970403), ('Darya', 19981019), ('Seriana', 19980227), ('Erin', 19960312), ('Katherine', 20001206), ('Vivian', 20000111), ('Stephanie M', 19931110), ('Sabrina', 19971216), ('Kate', 19971013), ('Emma', 20000212), ('Lauren', 20010728), ('Kayla', 19930220), ('Khume', 19961023), ('Christiana', 19970614), ('Candace Olivia', 19800101), ('Alycia', 20001231), ('Mikayla', 19990722), ('Tiffany', 19971009), ('Sanyukta', 20010928), ('Karly', 19850115), ('Emma', 19940624), ('Arielle', 20000910), ('Marjorie', 19980202), ('Anastasiya', 19990324), ('Natasha', ''), ('Addison', ''), ('Mbalia', 19980107), ('Safiya', ''), ('Taylor', 20010406), ('Natasha', 19920609), ('Katherine', 20010213), ('Madison', 19961215), ('Omolola', 19840818), ('Reagan', 19980505), ('Katelyn', 19960909), ('Sophie', 20021031), ('Gabrielle', 19920202), ('Taylor', 19981203), ('Andrea', 19940728), ('Annie', 19870905), ('Olivia', 19990308), ('Imani', 20011220), ('Lauren', 20020523), ('Taylor', 20000807), ('Nicole', 20000304), ('Jane', 19881118), ('Chelsea', 20000819), ('Peyton', 19990915), ('Ellie', 20000523), ('Jane', 19931227), ('Anna', 20010815), ('Rosalyn', 19930622), ('Madison', 19990419), ('Sophia', 20010718), ('Jasmine', 19990813), ('Theresa', 19701102), ('Spirit', 19941027), ('Najah', 20010909), ('Sharmada', 19990810), ('Nicole', 20000812), ('Nina', 20020117), ('Alexa', 20020906), ('Naomi', 20020516), ('Sabina', 20010406), ('Katie', 20011231), ('Nikki', 20011019), ('Mccartney', 19990708), ('Tricia', 19920706), ('Peyton', 20011008), ('Anika', 20010807), ('Dalayna', 20001216), ('Kolie', 20000317), ('Cassie', 19960225), ('Anna', 20020102), ('Monica', 19950419), ('Taysia', 20000708), ('Kathleen', 19940728), ('Amanda', 19990718), ('Jimena', 20000707), ('Cassidy', 19950510), ('Brittany', 19950405)]",,1.0,
What are the notes of the death events which has substring 'East'?,[death.note],"Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",EASY,SELECT death.note FROM death WHERE death.note LIKE '%East%';,SELECT note FROM death WHERE note LIKE '%East%',battle_death,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""death.note"" field, as the question asks for the notes of death events. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for notes that contain the substring 'East'. 3. Join Structure: No JOIN is required since all necessary information is in the ""death"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific notes based on a condition.","[('East Champaran, Bihar',)]","[('East Champaran, Bihar',)]",,1.0,
"Find the first name, country code and birth date of the winner who has the highest rank points in all matches.","[players.first_name, players.country_code, players.birth_date, matches.winner_id = players.player_id, matches.winner_rank_points]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT players.first_name, players.country_code, players.birth_date FROM matches JOIN players ON matches.winner_id = players.player_id WHERE matches.winner_rank_points = (SELECT MAX(winner_rank_points) FROM matches);","SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""players.first_name,"" ""players.country_code,"" and ""players.birth_date."" 2. Condition Structure: Use a WHERE clause to filter for the winner with the highest rank points. This requires finding the maximum value of ""matches.winner_rank_points."" 3. Join Structure: Use an INNER JOIN between the ""matches"" table and the ""players"" table on ""matches.winner_id = players.player_id"" to link match winners with their player details. 4. Aggregation Structure: Use a subquery to calculate the maximum ""matches.winner_rank_points"" and filter the results in the WHERE clause to find the winner with the highest rank points.","[('Serena', 'USA', 19810926), ('Serena', 'USA', 19810926), ('Serena', 'USA', 19810926)]","[('Serena', 'USA', 19810926)]",,1.0,
What are the average and maximum number of tickets bought in all visits?,[visit.Num_of_Ticket],"Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",EASY,"SELECT AVG(visit.Num_of_Ticket) AS avg_tickets, MAX(visit.Num_of_Ticket) AS max_tickets FROM visit;","SELECT avg(num_of_ticket) ,  max(num_of_ticket) FROM visit",museum_visit,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average and maximum number of tickets bought in all visits. 2. Aggregation Structure: Use AVG and MAX functions to calculate the average and maximum number of tickets bought. 3. Condition Structure: No specific filtering condition is required as the query involves all visits. 4. Join Structure: No JOIN is required since all necessary data is within the ""visit"" table.","[(10.5, 24)]","[(10.5, 24)]",,1.0,
What are the towns from which at least two teachers come from?,"[teacher.Hometown, teacher.Teacher_ID, teacher.Hometown]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,SELECT teacher.Hometown FROM teacher GROUP BY teacher.Hometown HAVING COUNT(teacher.Teacher_ID) >= 2;,SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2,course_teach,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the hometown of the teachers. 2. Aggregation Structure: Use COUNT to determine the number of teachers from each hometown. 3. Grouping Structure: Use GROUP BY on ""teacher.Hometown"" to aggregate the results by each hometown. 4. Condition Structure: Apply the HAVING clause to filter for hometowns where the count of teachers is at least 2. 5. Join Structure: No JOIN is required since all necessary data is within the ""teacher"" table.",[],[],,1.0,
What are the names of the teachers whose courses have not been arranged?,"[teacher.Name,course_arrange.Teacher_ID = teacher.Teacher_ID,course.Course_ID = course_arrange.Course_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NESTED,SELECT teacher.Name FROM teacher WHERE teacher.Teacher_ID NOT IN (SELECT course_arrange.Teacher_ID FROM course_arrange);,SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange),course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of teachers. Use the FROM clause to specify the teacher table. Apply a WHERE clause to filter for teachers whose courses have not been arranged. 2. Condition Structure: Use the WHERE clause with a subquery to exclude teachers whose Teacher_ID appears in the course_arrange table, as this indicates their courses have been arranged. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Teacher_ID entries in the course_arrange table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Joseph Huts',), ('John Deloor',)]","[('Joseph Huts',), ('John Deloor',)]",,1.0,
List the name and date the battle that has lost the ship named 'Lettice' and the ship named 'HMS Atalanta',"[battle.name, battle.date, ship.name, ship.lost_in_battle = battle.id, Lettice, HMS Atalanta]","Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",NESTED,"SELECT battle.name, battle.date FROM battle JOIN ship ON ship.lost_in_battle = battle.id WHERE battle.id IN ( SELECT lost_in_battle FROM ship WHERE name = 'Lettice' ) AND battle.id IN ( SELECT lost_in_battle FROM ship WHERE name = 'HMS Atalanta' );","SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'Lettice' INTERSECT SELECT T1.name ,  T1.date FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.name  =  'HMS Atalanta'",battle_death,"1. Sequential Structure: Start with the SELECT clause to retrieve the name and date of the battle. Use the FROM clause to specify the battle table and JOIN it with the ship table to connect battles with the ships lost in them. Apply a WHERE clause to filter for battles where both ships named 'Lettice' and 'HMS Atalanta' were lost. 2. Condition Structure: Use the WHERE clause to filter for ships with the names 'Lettice' and 'HMS Atalanta'. Use a subquery to ensure that the battle includes both ships. 3. Join Structure: Use an INNER JOIN between the ship and battle tables based on the foreign key relationship ship.lost_in_battle = battle.id to connect ships with the battles they were lost in. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('Siege of Constantinople', '1235'), ('Siege of Constantinople', '1235')]","[('Siege of Constantinople', '1235')]",,1.0,
find the names of loser and winner who played in the match with greatest number of minutes.,"[matches.minutes, matches.loser_name, matches.winner_name]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NESTED,"SELECT loser_name, winner_name FROM matches WHERE minutes = (SELECT MAX(minutes) FROM matches);","SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the loser and winner. Use the FROM clause to specify the matches table. Apply a WHERE clause to filter for the match with the greatest number of minutes. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the match where the minutes are equal to the maximum value in the minutes column. 3. Join Structure: Not required, as all the necessary data is available in the matches table. 4. Aggregation Structure: Use the MAX function in a subquery to find the greatest number of minutes, which is then used in the filtering condition.","[('Angelique Kerber', 'Petra Kvitova')]","[('Petra Kvitova', 'Angelique Kerber')]",,1.0,
Which year had the most matches?,[matches.year],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT matches.year FROM matches GROUP BY matches.year ORDER BY COUNT(*) DESC LIMIT 1;,SELECT YEAR FROM matches GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1,wta_1,"1. Sequential Structure: Begin with the SELECT clause to retrieve the ""year"" from the ""matches"" table since the question asks for the year with the most matches. 2. Condition Structure: No specific filtering condition is required, as the query aims to find the year with the maximum number of matches. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""matches"" table. 4. Aggregation Structure: Use the COUNT function to count the number of matches for each year. Use ORDER BY in descending order on the count and LIMIT 1 to retrieve the year with the most matches.","[(2016,)]","[(2016,)]",,1.0,
List the first and last name of all players who are left / L hand in the order of birth date.,"[players.first_name, players.last_name, players.hand, players.birth_date, L]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT players.first_name, players.last_name FROM players WHERE players.hand = 'L' ORDER BY players.birth_date;","SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""players.first_name"" and ""players.last_name"" of players who are left-handed ('L') and include their ""players.birth_date"" for ordering. 2. Condition Structure: Use a WHERE clause to filter players whose ""players.hand"" is 'L'. 3. Join Structure: No JOIN is required since all necessary information is in the ""players"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data. 5. Ordering Structure: Use ORDER BY on ""players.birth_date"" to sort the results by birth date.","[('Ann', 'Jones'), ('Wendy', 'Gilchrist'), ('Martina', 'Navratilova'), ('Mary', 'Carillo'), ('Katerina', 'Bohmova'), ('Petra', 'Delhees Jauch'), ('Nancy', 'Loeffler Caro'), ('Lise', 'Gregory'), ('Rene', 'Collins'), ('Nicole', 'Arendt'), ('Florencia', 'Labat'), ('Sabine', 'Appelmans'), ('Andreea', 'Ehritt Vanc'), ('Monica', 'Seles'), ('Gala', 'Leon Garcia'), ('Karen', 'Cross'), ('Julie', 'Pullin'), ('Vanessa', 'Webb'), ('Elena', 'Tatarkova'), ('Anca', 'Barna'), ('Francesca', 'Lubiani'), ('Gaelle', 'Widmer'), ('Amanda', 'Keen'), ('Amanda', 'Augustus'), ('Rita', 'Kuti Kis'), ('Amelie', 'Cocheteux'), ('Amelie', 'Castera'), ('Saori', 'Obata'), ('Marine', 'Nizri Spiegel'), ('Patty', 'Schnyder'), ('Julie', 'Ditty'), ('Joana', 'Cortez'), ('Barbara', 'Schwartz'), ('Ludmilla', 'Varmuza'), ('Magui', 'Serna'), ('Amanda', 'Grahame'), ('Kim', 'Kilsdonk'), ('Emilie', 'Loit'), ('Erika', 'Pineider'), ('Anne Gaelle', 'Sidot'), ('Erica', 'Biro'), ('Stephanie', 'Kovacic'), ('Sybille', 'Bammer'), ('Lisa', 'Fritz'), ('Maja', 'Matevzic'), ('Leanne', 'Baker'), ('Aurelie', 'Vedy'), ('Carla', 'Tiene'), ('Erika', 'Venere'), ('Jelena', 'Kostanic Tosic'), ('Clarisa', 'Fernandez'), ('Ansley', 'Cargill'), ('Dimana', 'Krastevitch'), ('Maria Jose', 'Martinez Sanchez'), ('Zerene', 'Reyes'), ('Melinda', 'Czink'), ('Sandra', 'Klemenschits'), ('Maria Elizabeth', 'Lopez'), ('Salome', 'Llaguno'), ('Lindsay', 'Cox'), ('Iveta', 'Benesova'), ('Eugenia', 'Chialvo'), ('Chun Yan', 'He'), ('Maria Fernanda', 'Alves'), ('Emily', 'Quin'), ('Fernanda', 'Oliveira Da Silva'), ('Annabel', 'Blow'), ('Julia', 'Smith'), ('Ana Lucia', 'Migliarini De Leon'), ('Elizabeth', 'Bondi'), ('Galina', 'Fokina'), ('Elise', 'Tamaela'), ('Bit Na', 'Lee'), ('Sonia', 'Iacovacci'), ('Mariana Pires', 'Junqueira'), ('Natalia', 'Bogdanova'), ('Irina', 'Smirnova'), ('Meghha', 'Vakaria'), ('Angela', 'Haynes'), ('Karly', 'Olson'), ('Casey', 'Dellacqua'), ('Kathrin', 'Hegel'), ('Beatrix', 'Csordas'), ('Zsuzsanna', 'Babos'), ('Emily', 'Applegate'), ('Olga', 'Pasichnichenko'), ('Theresa', 'Logar'), ('Jin A', 'Lee'), ('Hannah', 'Kuervers'), ('Andreea', 'Novaceanu'), ('Valentina', 'Tizzano'), ('Helen', 'Fritche'), ('Sandra', 'Sasidharan'), ('Isha', 'Lakhani'), ('Krushmi', 'Chheda'), ('Ljubica', 'Avramovic'), ('Avel Romaly', 'Coronado'), ('Shadisha', 'Robinson'), ('Carla', 'Zabaleta'), ('Diana', 'Arutyunova'), ('Cecile', 'Baijot'), ('Laura', 'Rocchi'), ('Rie', 'Imai'), ('Danielle', 'Harmsen'), ('Alejandra', 'Obregon'), ('Ariela', 'Perez'), ('Vasilisa', 'Davydova'), ('Emilia', 'Yorio'), ('Lizaan', 'Du Plessis'), ('Claire', 'Feuerstein'), ('Alexandria', 'Liles'), ('Katharine', 'Baker'), ('Emma', 'Laine'), ('Geraldine', 'Roma'), ('Aya', 'El Akkad'), ('Alexandra', 'Kazanova'), ('Allison', 'Baker'), ('Lucy', 'Fletcher'), ('Monika', 'Musilova'), ('Jitka', 'Gavdunova'), ('Elena', 'Petrucciano'), ('Varvara', 'Lepchenko'), ('Claire', 'De Gubernatis'), ('Seheno', 'Razafindramaso'), ('Karolina', 'Soor'), ('Melisa', 'Cabrera Handt'), ('Shraddha', 'Lodha'), ('Sylvia', 'Krywacz'), ('Amina', 'El Sahn'), ('Hendrike Lea', 'Heitmann'), ('Dunja', 'Antunovic'), ('Micaela', 'Acosta'), ('Katerina', 'Bohmova'), ('Catherine', 'Grotz'), ('Yurika', 'Sema'), ('Sheng Nan', 'Sun'), ('Lucie', 'Safarova'), ('Jitka', 'Kleisnerova'), ('Carolina', 'Escamilla'), ('Tapiwa', 'Marobela'), ('Punam', 'Reddy'), ('Katia', 'Sabate Orera'), ('Shana', 'Claes'), ('Chrissie', 'Seredni'), ('Yui', 'Nagasawa'), ('Marcela', 'Vojtiskova'), ('Seul Ki', 'Chin'), ('Nina', 'Munch Soegaard'), ('Hannah', 'Grady'), ('Karen', 'Castiblanco'), ('Angelique', 'Kerber'), ('Lauren', 'Lui'), ('Rana', 'Tharwat Hafez'), ('Nicole', 'Grunwald'), ('Ana', 'Veselinovic'), ('Sanaa', 'Bhambri'), ('Diana Andreea', 'Gae'), ('Ana', 'Beltran Trigueros'), ('Barbora', 'Bozkova'), ('Camila', 'Belassi'), ('Violette', 'Huck'), ('Megumi', 'Fukui'), ('Rita', 'Gouveia'), ('Mihaela', 'Buzarnescu'), ('Liset', 'Brito Herrera'), ('Paulina', 'Jorquera'), ('Ekaterina', 'Makarova'), ('Dessislava', 'Mladenova'), ('Sanaz', 'Marand'), ('Cristina', 'Greco Naccarato'), ('Cagla', 'Urcu'), ('Liege', 'Vieira'), ('Chang', 'Xu'), ('Jessica', 'Sweeting'), ('Yi Fan', 'Xu'), ('Eloisa Maria', 'Compostizo De Andres'), ('Karina', 'Porushkevich'), ('Ornella', 'Gentile'), ('Valeria', 'Casillo'), ('Bianca Ioana', 'Bonifate'), ('Michelle', 'Russ'), ('Monika', 'Lalewicz'), ('Amandine', 'Cazeaux'), ('Fatima', 'El Allami'), ('Simonetta', 'Miori'), ('Gabriela', 'Roux'), ('Sherazad', 'Benamar'), ('Sherazad', 'Reix'), ('Zora', 'Vlckova'), ('Naomi', 'Cavaday'), ('Nathalia', 'Rossi'), ('Maria Eugenia', 'Roca Recarey'), ('Lauren', 'Jones'), ('Roxane', 'Vaisemberg'), ('Ivana', 'Belejova'), ('Petra', 'Vogel'), ('Majdouline', 'Akrate'), ('Laura', 'Sadria'), ('Ia', 'Jikia'), ('Alessandra', 'Caprara'), ('Guadalupe', 'Moreno'), ('Lucie', 'Sipkova'), ('Xenia', 'Samoilova'), ('Kotomi', 'Takahata'), ('Stephanie', 'Theiler'), ('Maria', 'Prishlyak'), ('Grace', 'Leake'), ('Ioana Alexandra', 'Oprea'), ('Sanne', 'Bakker'), ('Katerina', 'Vankova'), ('Kristy', 'Frilling'), ('Tatiana', 'Bua'), ('Anastasia', 'Kontratevidi'), ('Chane', 'Hines'), ('Julia', 'Gavenko'), ('Yuuki', 'Tanaka'), ('Petra', 'Kvitova'), ('Leticia', 'Costas'), ('Sandra', 'Roma'), ('Nina', 'Mujezinovic'), ('Stella', 'Papaspyrou'), ('Chinami', 'Ogi'), ('Martina', 'Balogova'), ('Xinyun', 'Han'), ('Nicole', 'Riner'), ('Lara', 'Meccico'), ('Mai', 'Iwasaki'), ('Oksana', 'Kalashnikova'), ('Dipti', 'Srivastava'), ('Claudia', 'Mercado'), ('Margarita', 'Lazareva'), ('Shaozhuo', 'Liu'), ('Ana Maria', 'Chavez Franco'), ('Arantxa', 'Rus'), ('Ekaterina', 'Kamendova'), ('Monika', 'Tumova'), ('Gabriella', 'Boboc'), ('Ganna', 'Lukianchykova'), ('Sofia', 'Medina'), ('Ekaterina', 'Abaeva'), ('Andressa', 'Garcia'), ('Giulia', 'Bruzzone'), ('Catia', 'Rodrigues'), ('Danielle', 'Mills'), ('Flavia', 'Borges'), ('Misaki', 'Doi'), ('Veronika', 'Domagala'), ('Cindy', 'Chala'), ('Ksenia', 'Pervak'), ('Bianca', 'Botto'), ('Marianna', 'Natali'), ('Carolina', 'Orsi'), ('Aleksandra', 'Vukadinovic'), ('Elixane', 'Lechemia'), ('Sonya', 'Dayal'), ('Francesca', 'Campigotto'), ('Cristina Bianca', 'Danaila'), ('Tereza', 'Budilova'), ('Gemma', 'Praditngam'), ('Ekaterine', 'Gorgodze'), ('Dejana', 'Raickovic'), ('Alena', 'Gerasimova'), ('Quirine', 'Lemoine'), ('Chieh Yu', 'Hsu'), ('Anastasiya', 'Vasylyeva'), ('Alexia', 'Quartetto'), ('Joanna', 'Bougon'), ('Kristyna', 'Pliskova'), ('Elena', 'Bogdan'), ('Fiorella', 'Jerardino'), ('Julie', 'Gonzalez Rodriguez'), ('Alejandra', 'Barragan'), ('Renata', 'Bakieva'), ('Ashley', 'Krysiak'), ('Sarah Rebecca', 'Sekulic'), ('Na Lae', 'Han'), ('Natali', 'Coronel'), ('Kristyna', 'Hancarova'), ('Doroteja', 'Eric'), ('Chanel', 'Simmonds'), ('Kobkanok', 'Upapong'), ('Annie', 'Sullivan'), ('Jenny Thuy', 'Le'), ('Xenia', 'Knoll'), ('Francisca', 'Matos'), ('Christina', 'Madenoglou'), ('Alexandra', 'Avirvarei'), ('Georgina', 'Fedosenkova'), ('Alicia', 'Doms Golobart'), ('Amy', 'Hoburn'), ('Monica', 'Turewicz'), ('Martina', 'Zerbola'), ('Mashaal', 'Hameed'), ('Sabrina', 'Dos Reis'), ('Maria Sol', 'Carrasco'), ('Ruxandra', 'Ababii'), ('Daniella', 'Patton'), ('Veronika', 'Zavodska'), ('Briar', 'Preston'), ('Gabriela', 'Ce'), ('Amanda', 'Rodgers'), ('Constanze', 'Lotz'), ('Paula', 'Mocete Talamantes'), ('Verena', 'Gantschnig'), ('Ainhoa', 'Atucha Gomez'), ('Katarzyna', 'Kossowska'), ('Julia', 'Stamatova'), ('Vorranavaporn', 'Vorrarattanamongkol'), ('Michaela', 'Jasenakova'), ('Agustina Sol', 'Eskenazi'), ('Maja', 'Mladenovic'), ('Sandra', 'Garriga Catala'), ('Rita', 'Vilaca'), ('Zanmarie', 'Pienaar'), ('Julia', 'Kimmelmann'), ('Martina', 'Trevisan'), ('Charitomeni', 'Matoula'), ('Andreea', 'Istrate'), ('Sowjanya', 'Bavisetti'), ('Gabrielle', 'Moxey'), ('Viktoryia', 'Kisialeva'), ('Sarahi', 'Garcia Carrera'), ('Rachel', 'Girard'), ('Laura', 'Robson'), ('Kate', 'Vialle'), ('Anna', 'Montserrat Sanchez'), ('Elena Teodora', 'Cadar'), ('Carol', 'Augustine Benito'), ('Kamila', 'Pavelkova'), ('Arantxa', 'Sanchez'), ('Ana Sofia', 'Sanchez'), ('Julia', 'Wachaczyk'), ('Ecaterina', 'Oproiu'), ('Snigdha', 'Padamata'), ('Rona', 'Berisha'), ('Olga', 'Doroshina'), ('So Ra', 'Lee'), ('Brandy', 'Mina'), ('Natalie', 'Novakova'), ('Storm', 'Sanders'), ('Alexandra', 'Martinez'), ('Ysaline', 'Bonaventure'), ('Barbora', 'Trestikova'), ('Stefania', 'Hristov'), ('Ana Maria', 'Crisan'), ('Elpida', 'Papanelopoulou'), ('Tereza', 'Jankovska'), ('Rebecca', 'Andrade'), ('Kelly', 'Williford'), ('Tina', 'Rupert'), ('Mia Nicole', 'Eklund'), ('Bernarda', 'Pera'), ('Montserrat', 'Alonso'), ('Rosalie', 'Van Der Hoek'), ('Hedda', 'Odegaard'), ('Samira', 'Radjaa'), ('Zuzanna', 'Maciejewska'), ('Saumya', 'Vig'), ('Marie', 'Benoit'), ('Iga', 'Odrzywolek'), ('Shakhlo', 'Saidova'), ('Irina', 'Khromacheva'), ('Yuliya', 'Lysa'), ('Sophie', 'Blom'), ('Jennifer', 'Zerbone'), ('Kristina', 'Chasovskikh'), ('Maria Camila', 'Trujillo Hoyos'), ('Karina', 'Rovira'), ('Teodora Adina', 'Ardeleanu'), ('Yasmine', 'Rashad'), ('Judit', 'Vives Joan'), ('Sarah Beth', 'Askew'), ('Yasmine', 'Xantos'), ('Lea', 'Tholey'), ('Hikari', 'Yamamoto'), ('Ines Miren', 'De Pablo'), ('Stuti', 'Singh Tomar'), ('Naomi', 'Totka'), ('Polina', 'Bezsmertnaya'), ('Hannah', 'King'), ('Gabriele', 'Bertasiute'), ('Rebecca', 'Smaller'), ('Busra', 'Kayrun'), ('Stephani', 'Rodriguez'), ('Raquel', 'Montalvo'), ('Oana', 'Irimescu'), ('Taylor', 'Townsend'), ('Carmen', 'Blasco Robaina'), ('Giulia', 'Della Cioppa'), ('Nadege', 'Jorda'), ('Beatriz', 'Haddad Maia'), ('Nelise', 'Verster'), ('Eleonore', 'Barrere'), ('Anastasia', 'Prokopenko'), ('Dzina', 'Milovanovic'), ('Isabelle', 'Wallace'), ('Katelyn', 'Jackson'), ('Polina', 'Novoselova'), ('Maite', 'Cano'), ('Ria', 'Vaidya'), ('Ana Lorena', 'Garcia Navas'), ('Aayushi', 'Chouhan'), ('Ivona', 'Cudina'), ('Karina', 'Gurgenyan'), ('Maria', 'Patrascu'), ('Denisa', 'Chereches'), ('Mirabelle', 'Njoze'), ('Vasanti', 'Shinde'), ('Amanda', 'Schneider'), ('Katharina', 'Herpertz'), ('Tayisiya', 'Morderger'), ('Tamara', 'Tomic'), ('Maria Fernanda', 'Herazo Gonzalez'), ('Andra Maria', 'Nitescu'), ('Micheline', 'Aubuchon'), ('Ilayda', 'Yondem'), ('Birgit', 'Burk'), ('Kanako', 'Osafune'), ('Anastasiya', 'Komardina'), ('Nina', 'Holanova'), ('Jil Belen', 'Teichmann'), ('Francesca', 'Di Lorenzo'), ('Natsuho', 'Arakawa'), ('Emerald', 'Able'), ('Manca', 'Pislak'), ('Irys', 'Ekani'), ('Veronica', 'Miroshnichenko'), ('Martina', 'Capurro Taborda'), ('Mariam', 'Bolkvadze'), ('Diana', 'Valverde'), ('Do Hee', 'Bae'), ('Daniela', 'Morales Beckmann'), ('Ioana Diana', 'Pietroiu'), ('Luisa Fernanda', 'Echeverry Rodriguez'), ('Mayuka', 'Aikawa'), ('Nicole', 'Frenkel'), ('Daria', 'Kruzhkova'), ('Alejandra', 'Tamayo Gomez'), ('Tereza', 'Koplova'), ('Chiara', 'Lommer'), ('Laura', 'Illanes'), ('Olga', 'Fridman'), ('Ana Paula', 'Leal'), ('Shiraz', 'Bronstein'), ('Nicole', 'Bunea'), ('Charlotte', 'Robillard Millette'), ('Ashley', 'Kratzer'), ('Momoka', 'Chimura'), ('Anna', 'Slovakova'), ('Ai Qi', 'Chen'), ('Jiaying', 'He'), ('Ysabel', 'Gonzalez Rico'), ('Andreea', 'Stanescu'), ('Marketa', 'Vondrousova'), ('Ecaterina', 'Ivasco'), ('Ivon', 'Mihaleva'), ('Jasmine', 'Boyd'), ('Andrea', 'Arratia Fernandez'), ('Kayla', 'Day'), ('Ekaterina', 'Davletova'), ('Irina', 'Cantos Siemers'), ('Oceane', 'Mialon'), ('Watsachol', 'Sawasdee'), ('Ellen', 'Ashley'), ('Mila', 'Mejic'), ('Natalia', 'Nikolopoulou'), ('Marta', 'Del Pino Maturano'), ('Jayci', 'Goldsmith'), ('Yang', 'Lee'), ('Isabella', 'Tcherkes Zade'), ('Mara', 'Vidal'), ('Taylor', 'Johnson'), ('Julia', 'Vulpio'), ('Dagmar', 'Zdrubecka'), ('Olga', 'Danilovic'), ('Xiyu', 'Wang'), ('Lina', 'Shokry'), ('Ya Hsin', 'Lee'), ('Ruxandra', 'Schech'), ('Yasmina', 'Karimjanova'), ('Lara', 'Biter'), ('Najah', 'Dawson'), ('Giulia', 'Morlet'), ('Matilde', 'Mariani'), ('Isabella', 'Nunez'), ('Betina', 'Tokac'), ('Noa', 'Krznaric')]","[('Ann', 'Jones'), ('Wendy', 'Gilchrist'), ('Martina', 'Navratilova'), ('Mary', 'Carillo'), ('Katerina', 'Bohmova'), ('Petra', 'Delhees Jauch'), ('Nancy', 'Loeffler Caro'), ('Lise', 'Gregory'), ('Rene', 'Collins'), ('Nicole', 'Arendt'), ('Florencia', 'Labat'), ('Sabine', 'Appelmans'), ('Andreea', 'Ehritt Vanc'), ('Monica', 'Seles'), ('Gala', 'Leon Garcia'), ('Karen', 'Cross'), ('Julie', 'Pullin'), ('Vanessa', 'Webb'), ('Elena', 'Tatarkova'), ('Anca', 'Barna'), ('Francesca', 'Lubiani'), ('Gaelle', 'Widmer'), ('Amanda', 'Keen'), ('Amanda', 'Augustus'), ('Rita', 'Kuti Kis'), ('Amelie', 'Cocheteux'), ('Amelie', 'Castera'), ('Saori', 'Obata'), ('Marine', 'Nizri Spiegel'), ('Patty', 'Schnyder'), ('Julie', 'Ditty'), ('Joana', 'Cortez'), ('Barbara', 'Schwartz'), ('Ludmilla', 'Varmuza'), ('Magui', 'Serna'), ('Amanda', 'Grahame'), ('Kim', 'Kilsdonk'), ('Emilie', 'Loit'), ('Erika', 'Pineider'), ('Anne Gaelle', 'Sidot'), ('Erica', 'Biro'), ('Stephanie', 'Kovacic'), ('Sybille', 'Bammer'), ('Lisa', 'Fritz'), ('Maja', 'Matevzic'), ('Leanne', 'Baker'), ('Aurelie', 'Vedy'), ('Carla', 'Tiene'), ('Erika', 'Venere'), ('Jelena', 'Kostanic Tosic'), ('Clarisa', 'Fernandez'), ('Ansley', 'Cargill'), ('Dimana', 'Krastevitch'), ('Maria Jose', 'Martinez Sanchez'), ('Zerene', 'Reyes'), ('Melinda', 'Czink'), ('Sandra', 'Klemenschits'), ('Maria Elizabeth', 'Lopez'), ('Salome', 'Llaguno'), ('Lindsay', 'Cox'), ('Iveta', 'Benesova'), ('Eugenia', 'Chialvo'), ('Chun Yan', 'He'), ('Maria Fernanda', 'Alves'), ('Emily', 'Quin'), ('Fernanda', 'Oliveira Da Silva'), ('Annabel', 'Blow'), ('Julia', 'Smith'), ('Ana Lucia', 'Migliarini De Leon'), ('Elizabeth', 'Bondi'), ('Galina', 'Fokina'), ('Elise', 'Tamaela'), ('Bit Na', 'Lee'), ('Sonia', 'Iacovacci'), ('Mariana Pires', 'Junqueira'), ('Natalia', 'Bogdanova'), ('Irina', 'Smirnova'), ('Meghha', 'Vakaria'), ('Angela', 'Haynes'), ('Karly', 'Olson'), ('Casey', 'Dellacqua'), ('Kathrin', 'Hegel'), ('Beatrix', 'Csordas'), ('Zsuzsanna', 'Babos'), ('Emily', 'Applegate'), ('Olga', 'Pasichnichenko'), ('Theresa', 'Logar'), ('Jin A', 'Lee'), ('Hannah', 'Kuervers'), ('Andreea', 'Novaceanu'), ('Valentina', 'Tizzano'), ('Helen', 'Fritche'), ('Sandra', 'Sasidharan'), ('Isha', 'Lakhani'), ('Krushmi', 'Chheda'), ('Ljubica', 'Avramovic'), ('Avel Romaly', 'Coronado'), ('Shadisha', 'Robinson'), ('Carla', 'Zabaleta'), ('Diana', 'Arutyunova'), ('Cecile', 'Baijot'), ('Laura', 'Rocchi'), ('Rie', 'Imai'), ('Danielle', 'Harmsen'), ('Alejandra', 'Obregon'), ('Ariela', 'Perez'), ('Vasilisa', 'Davydova'), ('Emilia', 'Yorio'), ('Lizaan', 'Du Plessis'), ('Claire', 'Feuerstein'), ('Alexandria', 'Liles'), ('Katharine', 'Baker'), ('Emma', 'Laine'), ('Geraldine', 'Roma'), ('Aya', 'El Akkad'), ('Alexandra', 'Kazanova'), ('Allison', 'Baker'), ('Lucy', 'Fletcher'), ('Monika', 'Musilova'), ('Jitka', 'Gavdunova'), ('Elena', 'Petrucciano'), ('Varvara', 'Lepchenko'), ('Claire', 'De Gubernatis'), ('Seheno', 'Razafindramaso'), ('Karolina', 'Soor'), ('Melisa', 'Cabrera Handt'), ('Shraddha', 'Lodha'), ('Sylvia', 'Krywacz'), ('Amina', 'El Sahn'), ('Hendrike Lea', 'Heitmann'), ('Dunja', 'Antunovic'), ('Micaela', 'Acosta'), ('Katerina', 'Bohmova'), ('Catherine', 'Grotz'), ('Yurika', 'Sema'), ('Sheng Nan', 'Sun'), ('Lucie', 'Safarova'), ('Jitka', 'Kleisnerova'), ('Carolina', 'Escamilla'), ('Tapiwa', 'Marobela'), ('Punam', 'Reddy'), ('Katia', 'Sabate Orera'), ('Shana', 'Claes'), ('Chrissie', 'Seredni'), ('Yui', 'Nagasawa'), ('Marcela', 'Vojtiskova'), ('Seul Ki', 'Chin'), ('Nina', 'Munch Soegaard'), ('Hannah', 'Grady'), ('Karen', 'Castiblanco'), ('Angelique', 'Kerber'), ('Lauren', 'Lui'), ('Rana', 'Tharwat Hafez'), ('Nicole', 'Grunwald'), ('Ana', 'Veselinovic'), ('Sanaa', 'Bhambri'), ('Diana Andreea', 'Gae'), ('Ana', 'Beltran Trigueros'), ('Barbora', 'Bozkova'), ('Camila', 'Belassi'), ('Violette', 'Huck'), ('Megumi', 'Fukui'), ('Rita', 'Gouveia'), ('Mihaela', 'Buzarnescu'), ('Liset', 'Brito Herrera'), ('Paulina', 'Jorquera'), ('Ekaterina', 'Makarova'), ('Dessislava', 'Mladenova'), ('Sanaz', 'Marand'), ('Cristina', 'Greco Naccarato'), ('Cagla', 'Urcu'), ('Liege', 'Vieira'), ('Chang', 'Xu'), ('Jessica', 'Sweeting'), ('Yi Fan', 'Xu'), ('Eloisa Maria', 'Compostizo De Andres'), ('Karina', 'Porushkevich'), ('Ornella', 'Gentile'), ('Valeria', 'Casillo'), ('Bianca Ioana', 'Bonifate'), ('Michelle', 'Russ'), ('Monika', 'Lalewicz'), ('Amandine', 'Cazeaux'), ('Fatima', 'El Allami'), ('Simonetta', 'Miori'), ('Gabriela', 'Roux'), ('Sherazad', 'Benamar'), ('Sherazad', 'Reix'), ('Zora', 'Vlckova'), ('Naomi', 'Cavaday'), ('Nathalia', 'Rossi'), ('Maria Eugenia', 'Roca Recarey'), ('Lauren', 'Jones'), ('Roxane', 'Vaisemberg'), ('Ivana', 'Belejova'), ('Petra', 'Vogel'), ('Majdouline', 'Akrate'), ('Laura', 'Sadria'), ('Ia', 'Jikia'), ('Alessandra', 'Caprara'), ('Guadalupe', 'Moreno'), ('Lucie', 'Sipkova'), ('Xenia', 'Samoilova'), ('Kotomi', 'Takahata'), ('Stephanie', 'Theiler'), ('Maria', 'Prishlyak'), ('Grace', 'Leake'), ('Ioana Alexandra', 'Oprea'), ('Sanne', 'Bakker'), ('Katerina', 'Vankova'), ('Kristy', 'Frilling'), ('Tatiana', 'Bua'), ('Anastasia', 'Kontratevidi'), ('Chane', 'Hines'), ('Julia', 'Gavenko'), ('Yuuki', 'Tanaka'), ('Petra', 'Kvitova'), ('Leticia', 'Costas'), ('Sandra', 'Roma'), ('Nina', 'Mujezinovic'), ('Stella', 'Papaspyrou'), ('Chinami', 'Ogi'), ('Martina', 'Balogova'), ('Xinyun', 'Han'), ('Nicole', 'Riner'), ('Lara', 'Meccico'), ('Mai', 'Iwasaki'), ('Oksana', 'Kalashnikova'), ('Dipti', 'Srivastava'), ('Claudia', 'Mercado'), ('Margarita', 'Lazareva'), ('Shaozhuo', 'Liu'), ('Ana Maria', 'Chavez Franco'), ('Arantxa', 'Rus'), ('Ekaterina', 'Kamendova'), ('Monika', 'Tumova'), ('Gabriella', 'Boboc'), ('Ganna', 'Lukianchykova'), ('Sofia', 'Medina'), ('Ekaterina', 'Abaeva'), ('Andressa', 'Garcia'), ('Giulia', 'Bruzzone'), ('Catia', 'Rodrigues'), ('Danielle', 'Mills'), ('Flavia', 'Borges'), ('Misaki', 'Doi'), ('Veronika', 'Domagala'), ('Cindy', 'Chala'), ('Ksenia', 'Pervak'), ('Bianca', 'Botto'), ('Marianna', 'Natali'), ('Carolina', 'Orsi'), ('Aleksandra', 'Vukadinovic'), ('Elixane', 'Lechemia'), ('Sonya', 'Dayal'), ('Francesca', 'Campigotto'), ('Cristina Bianca', 'Danaila'), ('Tereza', 'Budilova'), ('Gemma', 'Praditngam'), ('Ekaterine', 'Gorgodze'), ('Dejana', 'Raickovic'), ('Alena', 'Gerasimova'), ('Quirine', 'Lemoine'), ('Chieh Yu', 'Hsu'), ('Anastasiya', 'Vasylyeva'), ('Alexia', 'Quartetto'), ('Joanna', 'Bougon'), ('Kristyna', 'Pliskova'), ('Elena', 'Bogdan'), ('Fiorella', 'Jerardino'), ('Julie', 'Gonzalez Rodriguez'), ('Alejandra', 'Barragan'), ('Renata', 'Bakieva'), ('Ashley', 'Krysiak'), ('Sarah Rebecca', 'Sekulic'), ('Na Lae', 'Han'), ('Natali', 'Coronel'), ('Kristyna', 'Hancarova'), ('Doroteja', 'Eric'), ('Chanel', 'Simmonds'), ('Kobkanok', 'Upapong'), ('Annie', 'Sullivan'), ('Jenny Thuy', 'Le'), ('Xenia', 'Knoll'), ('Francisca', 'Matos'), ('Christina', 'Madenoglou'), ('Alexandra', 'Avirvarei'), ('Georgina', 'Fedosenkova'), ('Alicia', 'Doms Golobart'), ('Amy', 'Hoburn'), ('Monica', 'Turewicz'), ('Martina', 'Zerbola'), ('Mashaal', 'Hameed'), ('Sabrina', 'Dos Reis'), ('Maria Sol', 'Carrasco'), ('Ruxandra', 'Ababii'), ('Daniella', 'Patton'), ('Veronika', 'Zavodska'), ('Briar', 'Preston'), ('Gabriela', 'Ce'), ('Amanda', 'Rodgers'), ('Constanze', 'Lotz'), ('Paula', 'Mocete Talamantes'), ('Verena', 'Gantschnig'), ('Ainhoa', 'Atucha Gomez'), ('Katarzyna', 'Kossowska'), ('Julia', 'Stamatova'), ('Vorranavaporn', 'Vorrarattanamongkol'), ('Michaela', 'Jasenakova'), ('Agustina Sol', 'Eskenazi'), ('Maja', 'Mladenovic'), ('Sandra', 'Garriga Catala'), ('Rita', 'Vilaca'), ('Zanmarie', 'Pienaar'), ('Julia', 'Kimmelmann'), ('Martina', 'Trevisan'), ('Charitomeni', 'Matoula'), ('Andreea', 'Istrate'), ('Sowjanya', 'Bavisetti'), ('Gabrielle', 'Moxey'), ('Viktoryia', 'Kisialeva'), ('Sarahi', 'Garcia Carrera'), ('Rachel', 'Girard'), ('Laura', 'Robson'), ('Kate', 'Vialle'), ('Anna', 'Montserrat Sanchez'), ('Elena Teodora', 'Cadar'), ('Carol', 'Augustine Benito'), ('Kamila', 'Pavelkova'), ('Arantxa', 'Sanchez'), ('Ana Sofia', 'Sanchez'), ('Julia', 'Wachaczyk'), ('Ecaterina', 'Oproiu'), ('Snigdha', 'Padamata'), ('Rona', 'Berisha'), ('Olga', 'Doroshina'), ('So Ra', 'Lee'), ('Brandy', 'Mina'), ('Natalie', 'Novakova'), ('Storm', 'Sanders'), ('Alexandra', 'Martinez'), ('Ysaline', 'Bonaventure'), ('Barbora', 'Trestikova'), ('Stefania', 'Hristov'), ('Ana Maria', 'Crisan'), ('Elpida', 'Papanelopoulou'), ('Tereza', 'Jankovska'), ('Rebecca', 'Andrade'), ('Kelly', 'Williford'), ('Tina', 'Rupert'), ('Mia Nicole', 'Eklund'), ('Bernarda', 'Pera'), ('Montserrat', 'Alonso'), ('Rosalie', 'Van Der Hoek'), ('Hedda', 'Odegaard'), ('Samira', 'Radjaa'), ('Zuzanna', 'Maciejewska'), ('Saumya', 'Vig'), ('Marie', 'Benoit'), ('Iga', 'Odrzywolek'), ('Shakhlo', 'Saidova'), ('Irina', 'Khromacheva'), ('Yuliya', 'Lysa'), ('Sophie', 'Blom'), ('Jennifer', 'Zerbone'), ('Kristina', 'Chasovskikh'), ('Maria Camila', 'Trujillo Hoyos'), ('Karina', 'Rovira'), ('Teodora Adina', 'Ardeleanu'), ('Yasmine', 'Rashad'), ('Judit', 'Vives Joan'), ('Sarah Beth', 'Askew'), ('Yasmine', 'Xantos'), ('Lea', 'Tholey'), ('Hikari', 'Yamamoto'), ('Ines Miren', 'De Pablo'), ('Stuti', 'Singh Tomar'), ('Naomi', 'Totka'), ('Polina', 'Bezsmertnaya'), ('Hannah', 'King'), ('Gabriele', 'Bertasiute'), ('Rebecca', 'Smaller'), ('Busra', 'Kayrun'), ('Stephani', 'Rodriguez'), ('Raquel', 'Montalvo'), ('Oana', 'Irimescu'), ('Taylor', 'Townsend'), ('Carmen', 'Blasco Robaina'), ('Giulia', 'Della Cioppa'), ('Nadege', 'Jorda'), ('Beatriz', 'Haddad Maia'), ('Nelise', 'Verster'), ('Eleonore', 'Barrere'), ('Anastasia', 'Prokopenko'), ('Dzina', 'Milovanovic'), ('Isabelle', 'Wallace'), ('Katelyn', 'Jackson'), ('Polina', 'Novoselova'), ('Maite', 'Cano'), ('Ria', 'Vaidya'), ('Ana Lorena', 'Garcia Navas'), ('Aayushi', 'Chouhan'), ('Ivona', 'Cudina'), ('Karina', 'Gurgenyan'), ('Maria', 'Patrascu'), ('Denisa', 'Chereches'), ('Mirabelle', 'Njoze'), ('Vasanti', 'Shinde'), ('Amanda', 'Schneider'), ('Katharina', 'Herpertz'), ('Tayisiya', 'Morderger'), ('Tamara', 'Tomic'), ('Maria Fernanda', 'Herazo Gonzalez'), ('Andra Maria', 'Nitescu'), ('Micheline', 'Aubuchon'), ('Ilayda', 'Yondem'), ('Birgit', 'Burk'), ('Kanako', 'Osafune'), ('Anastasiya', 'Komardina'), ('Nina', 'Holanova'), ('Jil Belen', 'Teichmann'), ('Francesca', 'Di Lorenzo'), ('Natsuho', 'Arakawa'), ('Emerald', 'Able'), ('Manca', 'Pislak'), ('Irys', 'Ekani'), ('Veronica', 'Miroshnichenko'), ('Martina', 'Capurro Taborda'), ('Mariam', 'Bolkvadze'), ('Diana', 'Valverde'), ('Do Hee', 'Bae'), ('Daniela', 'Morales Beckmann'), ('Ioana Diana', 'Pietroiu'), ('Luisa Fernanda', 'Echeverry Rodriguez'), ('Mayuka', 'Aikawa'), ('Nicole', 'Frenkel'), ('Daria', 'Kruzhkova'), ('Alejandra', 'Tamayo Gomez'), ('Tereza', 'Koplova'), ('Chiara', 'Lommer'), ('Laura', 'Illanes'), ('Olga', 'Fridman'), ('Ana Paula', 'Leal'), ('Shiraz', 'Bronstein'), ('Nicole', 'Bunea'), ('Charlotte', 'Robillard Millette'), ('Ashley', 'Kratzer'), ('Momoka', 'Chimura'), ('Anna', 'Slovakova'), ('Ai Qi', 'Chen'), ('Jiaying', 'He'), ('Ysabel', 'Gonzalez Rico'), ('Andreea', 'Stanescu'), ('Marketa', 'Vondrousova'), ('Ecaterina', 'Ivasco'), ('Ivon', 'Mihaleva'), ('Jasmine', 'Boyd'), ('Andrea', 'Arratia Fernandez'), ('Kayla', 'Day'), ('Ekaterina', 'Davletova'), ('Irina', 'Cantos Siemers'), ('Oceane', 'Mialon'), ('Watsachol', 'Sawasdee'), ('Ellen', 'Ashley'), ('Mila', 'Mejic'), ('Natalia', 'Nikolopoulou'), ('Marta', 'Del Pino Maturano'), ('Jayci', 'Goldsmith'), ('Yang', 'Lee'), ('Isabella', 'Tcherkes Zade'), ('Mara', 'Vidal'), ('Taylor', 'Johnson'), ('Julia', 'Vulpio'), ('Dagmar', 'Zdrubecka'), ('Olga', 'Danilovic'), ('Xiyu', 'Wang'), ('Lina', 'Shokry'), ('Ya Hsin', 'Lee'), ('Ruxandra', 'Schech'), ('Yasmina', 'Karimjanova'), ('Lara', 'Biter'), ('Najah', 'Dawson'), ('Giulia', 'Morlet'), ('Matilde', 'Mariani'), ('Isabella', 'Nunez'), ('Betina', 'Tokac'), ('Noa', 'Krznaric')]",,1.0,
Show names of teachers that teach at least two courses.,"[teacher.Name, course_arrange.Teacher_ID, course_arrange.Course_ID, course_arrange.Teacher_ID = teacher.Teacher_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NON-NESTED,SELECT teacher.Name FROM course_arrange JOIN teacher ON course_arrange.Teacher_ID = teacher.Teacher_ID GROUP BY course_arrange.Teacher_ID HAVING COUNT(course_arrange.Course_ID) >= 2;,SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2,course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Name."" Use GROUP BY to group records by ""course_arrange.Teacher_ID"" since we need to count the number of courses each teacher teaches. Use HAVING to filter teachers who teach at least two courses. 2. Condition Structure: Use a HAVING clause to filter for teachers who teach two or more courses by counting distinct ""course_arrange.Course_ID."" 3. Join Structure: Use an INNER JOIN between ""course_arrange"" and ""teacher"" on ""course_arrange.Teacher_ID = teacher.Teacher_ID"" to associate each teacher with their courses. 4. Aggregation Structure: Use COUNT on ""course_arrange.Course_ID"" to count the number of courses each teacher teaches, and filter using HAVING COUNT >= 2.","[('Anne Walker',)]","[('Anne Walker',)]",,1.0,
List the most common hometown of teachers.,[teacher.Hometown],"Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,SELECT teacher.Hometown FROM teacher GROUP BY teacher.Hometown ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1,course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Hometown"" as we are looking for the most common hometown of teachers. 2. Aggregation Structure: Use COUNT to calculate the number of teachers from each hometown. 3. Grouping Structure: Use GROUP BY on ""teacher.Hometown"" to group the results by each hometown. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank hometowns by the number of teachers. 5. Limiting Structure: Use LIMIT 1 to retrieve the hometown with the highest count. 6. Join Structure: No JOIN is required since all necessary data is within the ""teacher"" table.","[('Turton Urban District',)]","[('Turton Urban District',)]",,1.0,
"What are the full names of all left handed players, in order of birth date?","[players.first_name, players.last_name, players.hand, players.birth_date, players.player_id, players.hand = 'L']","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT players.first_name, players.last_name FROM players WHERE players.hand = 'L' ORDER BY players.birth_date ASC;","SELECT first_name ,  last_name FROM players WHERE hand  =  'L' ORDER BY birth_date",wta_1,"1. Sequential Structure: Begin with the SELECT clause to retrieve the full names of players, which are ""players.first_name"" and ""players.last_name"", along with their ""players.birth_date"" for sorting purposes. 2. Condition Structure: Use a WHERE clause to filter for players whose ""players.hand"" is 'L' (left-handed). 3. Join Structure: No JOIN is required since all necessary information is available in the ""players"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY on ""players.birth_date"" to sort the results in ascending order of birth date.","[('Ann', 'Jones'), ('Wendy', 'Gilchrist'), ('Martina', 'Navratilova'), ('Mary', 'Carillo'), ('Katerina', 'Bohmova'), ('Petra', 'Delhees Jauch'), ('Nancy', 'Loeffler Caro'), ('Lise', 'Gregory'), ('Rene', 'Collins'), ('Nicole', 'Arendt'), ('Florencia', 'Labat'), ('Sabine', 'Appelmans'), ('Andreea', 'Ehritt Vanc'), ('Monica', 'Seles'), ('Gala', 'Leon Garcia'), ('Karen', 'Cross'), ('Julie', 'Pullin'), ('Vanessa', 'Webb'), ('Elena', 'Tatarkova'), ('Anca', 'Barna'), ('Francesca', 'Lubiani'), ('Gaelle', 'Widmer'), ('Amanda', 'Keen'), ('Amanda', 'Augustus'), ('Rita', 'Kuti Kis'), ('Amelie', 'Cocheteux'), ('Amelie', 'Castera'), ('Saori', 'Obata'), ('Marine', 'Nizri Spiegel'), ('Patty', 'Schnyder'), ('Julie', 'Ditty'), ('Joana', 'Cortez'), ('Barbara', 'Schwartz'), ('Ludmilla', 'Varmuza'), ('Magui', 'Serna'), ('Amanda', 'Grahame'), ('Kim', 'Kilsdonk'), ('Emilie', 'Loit'), ('Erika', 'Pineider'), ('Anne Gaelle', 'Sidot'), ('Erica', 'Biro'), ('Stephanie', 'Kovacic'), ('Sybille', 'Bammer'), ('Lisa', 'Fritz'), ('Maja', 'Matevzic'), ('Leanne', 'Baker'), ('Aurelie', 'Vedy'), ('Carla', 'Tiene'), ('Erika', 'Venere'), ('Jelena', 'Kostanic Tosic'), ('Clarisa', 'Fernandez'), ('Ansley', 'Cargill'), ('Dimana', 'Krastevitch'), ('Maria Jose', 'Martinez Sanchez'), ('Zerene', 'Reyes'), ('Melinda', 'Czink'), ('Sandra', 'Klemenschits'), ('Maria Elizabeth', 'Lopez'), ('Salome', 'Llaguno'), ('Lindsay', 'Cox'), ('Iveta', 'Benesova'), ('Eugenia', 'Chialvo'), ('Chun Yan', 'He'), ('Maria Fernanda', 'Alves'), ('Emily', 'Quin'), ('Fernanda', 'Oliveira Da Silva'), ('Annabel', 'Blow'), ('Julia', 'Smith'), ('Ana Lucia', 'Migliarini De Leon'), ('Elizabeth', 'Bondi'), ('Galina', 'Fokina'), ('Elise', 'Tamaela'), ('Bit Na', 'Lee'), ('Sonia', 'Iacovacci'), ('Mariana Pires', 'Junqueira'), ('Natalia', 'Bogdanova'), ('Irina', 'Smirnova'), ('Meghha', 'Vakaria'), ('Angela', 'Haynes'), ('Karly', 'Olson'), ('Casey', 'Dellacqua'), ('Kathrin', 'Hegel'), ('Beatrix', 'Csordas'), ('Zsuzsanna', 'Babos'), ('Emily', 'Applegate'), ('Olga', 'Pasichnichenko'), ('Theresa', 'Logar'), ('Jin A', 'Lee'), ('Hannah', 'Kuervers'), ('Andreea', 'Novaceanu'), ('Valentina', 'Tizzano'), ('Helen', 'Fritche'), ('Sandra', 'Sasidharan'), ('Isha', 'Lakhani'), ('Krushmi', 'Chheda'), ('Ljubica', 'Avramovic'), ('Avel Romaly', 'Coronado'), ('Shadisha', 'Robinson'), ('Carla', 'Zabaleta'), ('Diana', 'Arutyunova'), ('Cecile', 'Baijot'), ('Laura', 'Rocchi'), ('Rie', 'Imai'), ('Danielle', 'Harmsen'), ('Alejandra', 'Obregon'), ('Ariela', 'Perez'), ('Vasilisa', 'Davydova'), ('Emilia', 'Yorio'), ('Lizaan', 'Du Plessis'), ('Claire', 'Feuerstein'), ('Alexandria', 'Liles'), ('Katharine', 'Baker'), ('Emma', 'Laine'), ('Geraldine', 'Roma'), ('Aya', 'El Akkad'), ('Alexandra', 'Kazanova'), ('Allison', 'Baker'), ('Lucy', 'Fletcher'), ('Monika', 'Musilova'), ('Jitka', 'Gavdunova'), ('Elena', 'Petrucciano'), ('Varvara', 'Lepchenko'), ('Claire', 'De Gubernatis'), ('Seheno', 'Razafindramaso'), ('Karolina', 'Soor'), ('Melisa', 'Cabrera Handt'), ('Shraddha', 'Lodha'), ('Sylvia', 'Krywacz'), ('Amina', 'El Sahn'), ('Hendrike Lea', 'Heitmann'), ('Dunja', 'Antunovic'), ('Micaela', 'Acosta'), ('Katerina', 'Bohmova'), ('Catherine', 'Grotz'), ('Yurika', 'Sema'), ('Sheng Nan', 'Sun'), ('Lucie', 'Safarova'), ('Jitka', 'Kleisnerova'), ('Carolina', 'Escamilla'), ('Tapiwa', 'Marobela'), ('Punam', 'Reddy'), ('Katia', 'Sabate Orera'), ('Shana', 'Claes'), ('Chrissie', 'Seredni'), ('Yui', 'Nagasawa'), ('Marcela', 'Vojtiskova'), ('Seul Ki', 'Chin'), ('Nina', 'Munch Soegaard'), ('Hannah', 'Grady'), ('Karen', 'Castiblanco'), ('Angelique', 'Kerber'), ('Lauren', 'Lui'), ('Rana', 'Tharwat Hafez'), ('Nicole', 'Grunwald'), ('Ana', 'Veselinovic'), ('Sanaa', 'Bhambri'), ('Diana Andreea', 'Gae'), ('Ana', 'Beltran Trigueros'), ('Barbora', 'Bozkova'), ('Camila', 'Belassi'), ('Violette', 'Huck'), ('Megumi', 'Fukui'), ('Rita', 'Gouveia'), ('Mihaela', 'Buzarnescu'), ('Liset', 'Brito Herrera'), ('Paulina', 'Jorquera'), ('Ekaterina', 'Makarova'), ('Dessislava', 'Mladenova'), ('Sanaz', 'Marand'), ('Cristina', 'Greco Naccarato'), ('Cagla', 'Urcu'), ('Liege', 'Vieira'), ('Chang', 'Xu'), ('Jessica', 'Sweeting'), ('Yi Fan', 'Xu'), ('Eloisa Maria', 'Compostizo De Andres'), ('Karina', 'Porushkevich'), ('Ornella', 'Gentile'), ('Valeria', 'Casillo'), ('Bianca Ioana', 'Bonifate'), ('Michelle', 'Russ'), ('Monika', 'Lalewicz'), ('Amandine', 'Cazeaux'), ('Fatima', 'El Allami'), ('Simonetta', 'Miori'), ('Gabriela', 'Roux'), ('Sherazad', 'Benamar'), ('Sherazad', 'Reix'), ('Zora', 'Vlckova'), ('Naomi', 'Cavaday'), ('Nathalia', 'Rossi'), ('Maria Eugenia', 'Roca Recarey'), ('Lauren', 'Jones'), ('Roxane', 'Vaisemberg'), ('Ivana', 'Belejova'), ('Petra', 'Vogel'), ('Majdouline', 'Akrate'), ('Laura', 'Sadria'), ('Ia', 'Jikia'), ('Alessandra', 'Caprara'), ('Guadalupe', 'Moreno'), ('Lucie', 'Sipkova'), ('Xenia', 'Samoilova'), ('Kotomi', 'Takahata'), ('Stephanie', 'Theiler'), ('Maria', 'Prishlyak'), ('Grace', 'Leake'), ('Ioana Alexandra', 'Oprea'), ('Sanne', 'Bakker'), ('Katerina', 'Vankova'), ('Kristy', 'Frilling'), ('Tatiana', 'Bua'), ('Anastasia', 'Kontratevidi'), ('Chane', 'Hines'), ('Julia', 'Gavenko'), ('Yuuki', 'Tanaka'), ('Petra', 'Kvitova'), ('Leticia', 'Costas'), ('Sandra', 'Roma'), ('Nina', 'Mujezinovic'), ('Stella', 'Papaspyrou'), ('Chinami', 'Ogi'), ('Martina', 'Balogova'), ('Xinyun', 'Han'), ('Nicole', 'Riner'), ('Lara', 'Meccico'), ('Mai', 'Iwasaki'), ('Oksana', 'Kalashnikova'), ('Dipti', 'Srivastava'), ('Claudia', 'Mercado'), ('Margarita', 'Lazareva'), ('Shaozhuo', 'Liu'), ('Ana Maria', 'Chavez Franco'), ('Arantxa', 'Rus'), ('Ekaterina', 'Kamendova'), ('Monika', 'Tumova'), ('Gabriella', 'Boboc'), ('Ganna', 'Lukianchykova'), ('Sofia', 'Medina'), ('Ekaterina', 'Abaeva'), ('Andressa', 'Garcia'), ('Giulia', 'Bruzzone'), ('Catia', 'Rodrigues'), ('Danielle', 'Mills'), ('Flavia', 'Borges'), ('Misaki', 'Doi'), ('Veronika', 'Domagala'), ('Cindy', 'Chala'), ('Ksenia', 'Pervak'), ('Bianca', 'Botto'), ('Marianna', 'Natali'), ('Carolina', 'Orsi'), ('Aleksandra', 'Vukadinovic'), ('Elixane', 'Lechemia'), ('Sonya', 'Dayal'), ('Francesca', 'Campigotto'), ('Cristina Bianca', 'Danaila'), ('Tereza', 'Budilova'), ('Gemma', 'Praditngam'), ('Ekaterine', 'Gorgodze'), ('Dejana', 'Raickovic'), ('Alena', 'Gerasimova'), ('Quirine', 'Lemoine'), ('Chieh Yu', 'Hsu'), ('Anastasiya', 'Vasylyeva'), ('Alexia', 'Quartetto'), ('Joanna', 'Bougon'), ('Kristyna', 'Pliskova'), ('Elena', 'Bogdan'), ('Fiorella', 'Jerardino'), ('Julie', 'Gonzalez Rodriguez'), ('Alejandra', 'Barragan'), ('Renata', 'Bakieva'), ('Ashley', 'Krysiak'), ('Sarah Rebecca', 'Sekulic'), ('Na Lae', 'Han'), ('Natali', 'Coronel'), ('Kristyna', 'Hancarova'), ('Doroteja', 'Eric'), ('Chanel', 'Simmonds'), ('Kobkanok', 'Upapong'), ('Annie', 'Sullivan'), ('Jenny Thuy', 'Le'), ('Xenia', 'Knoll'), ('Francisca', 'Matos'), ('Christina', 'Madenoglou'), ('Alexandra', 'Avirvarei'), ('Georgina', 'Fedosenkova'), ('Alicia', 'Doms Golobart'), ('Amy', 'Hoburn'), ('Monica', 'Turewicz'), ('Martina', 'Zerbola'), ('Mashaal', 'Hameed'), ('Sabrina', 'Dos Reis'), ('Maria Sol', 'Carrasco'), ('Ruxandra', 'Ababii'), ('Daniella', 'Patton'), ('Veronika', 'Zavodska'), ('Briar', 'Preston'), ('Gabriela', 'Ce'), ('Amanda', 'Rodgers'), ('Constanze', 'Lotz'), ('Paula', 'Mocete Talamantes'), ('Verena', 'Gantschnig'), ('Ainhoa', 'Atucha Gomez'), ('Katarzyna', 'Kossowska'), ('Julia', 'Stamatova'), ('Vorranavaporn', 'Vorrarattanamongkol'), ('Michaela', 'Jasenakova'), ('Agustina Sol', 'Eskenazi'), ('Maja', 'Mladenovic'), ('Sandra', 'Garriga Catala'), ('Rita', 'Vilaca'), ('Zanmarie', 'Pienaar'), ('Julia', 'Kimmelmann'), ('Martina', 'Trevisan'), ('Charitomeni', 'Matoula'), ('Andreea', 'Istrate'), ('Sowjanya', 'Bavisetti'), ('Gabrielle', 'Moxey'), ('Viktoryia', 'Kisialeva'), ('Sarahi', 'Garcia Carrera'), ('Rachel', 'Girard'), ('Laura', 'Robson'), ('Kate', 'Vialle'), ('Anna', 'Montserrat Sanchez'), ('Elena Teodora', 'Cadar'), ('Carol', 'Augustine Benito'), ('Kamila', 'Pavelkova'), ('Arantxa', 'Sanchez'), ('Ana Sofia', 'Sanchez'), ('Julia', 'Wachaczyk'), ('Ecaterina', 'Oproiu'), ('Snigdha', 'Padamata'), ('Rona', 'Berisha'), ('Olga', 'Doroshina'), ('So Ra', 'Lee'), ('Brandy', 'Mina'), ('Natalie', 'Novakova'), ('Storm', 'Sanders'), ('Alexandra', 'Martinez'), ('Ysaline', 'Bonaventure'), ('Barbora', 'Trestikova'), ('Stefania', 'Hristov'), ('Ana Maria', 'Crisan'), ('Elpida', 'Papanelopoulou'), ('Tereza', 'Jankovska'), ('Rebecca', 'Andrade'), ('Kelly', 'Williford'), ('Tina', 'Rupert'), ('Mia Nicole', 'Eklund'), ('Bernarda', 'Pera'), ('Montserrat', 'Alonso'), ('Rosalie', 'Van Der Hoek'), ('Hedda', 'Odegaard'), ('Samira', 'Radjaa'), ('Zuzanna', 'Maciejewska'), ('Saumya', 'Vig'), ('Marie', 'Benoit'), ('Iga', 'Odrzywolek'), ('Shakhlo', 'Saidova'), ('Irina', 'Khromacheva'), ('Yuliya', 'Lysa'), ('Sophie', 'Blom'), ('Jennifer', 'Zerbone'), ('Kristina', 'Chasovskikh'), ('Maria Camila', 'Trujillo Hoyos'), ('Karina', 'Rovira'), ('Teodora Adina', 'Ardeleanu'), ('Yasmine', 'Rashad'), ('Judit', 'Vives Joan'), ('Sarah Beth', 'Askew'), ('Yasmine', 'Xantos'), ('Lea', 'Tholey'), ('Hikari', 'Yamamoto'), ('Ines Miren', 'De Pablo'), ('Stuti', 'Singh Tomar'), ('Naomi', 'Totka'), ('Polina', 'Bezsmertnaya'), ('Hannah', 'King'), ('Gabriele', 'Bertasiute'), ('Rebecca', 'Smaller'), ('Busra', 'Kayrun'), ('Stephani', 'Rodriguez'), ('Raquel', 'Montalvo'), ('Oana', 'Irimescu'), ('Taylor', 'Townsend'), ('Carmen', 'Blasco Robaina'), ('Giulia', 'Della Cioppa'), ('Nadege', 'Jorda'), ('Beatriz', 'Haddad Maia'), ('Nelise', 'Verster'), ('Eleonore', 'Barrere'), ('Anastasia', 'Prokopenko'), ('Dzina', 'Milovanovic'), ('Isabelle', 'Wallace'), ('Katelyn', 'Jackson'), ('Polina', 'Novoselova'), ('Maite', 'Cano'), ('Ria', 'Vaidya'), ('Ana Lorena', 'Garcia Navas'), ('Aayushi', 'Chouhan'), ('Ivona', 'Cudina'), ('Karina', 'Gurgenyan'), ('Maria', 'Patrascu'), ('Denisa', 'Chereches'), ('Mirabelle', 'Njoze'), ('Vasanti', 'Shinde'), ('Amanda', 'Schneider'), ('Katharina', 'Herpertz'), ('Tayisiya', 'Morderger'), ('Tamara', 'Tomic'), ('Maria Fernanda', 'Herazo Gonzalez'), ('Andra Maria', 'Nitescu'), ('Micheline', 'Aubuchon'), ('Ilayda', 'Yondem'), ('Birgit', 'Burk'), ('Kanako', 'Osafune'), ('Anastasiya', 'Komardina'), ('Nina', 'Holanova'), ('Jil Belen', 'Teichmann'), ('Francesca', 'Di Lorenzo'), ('Natsuho', 'Arakawa'), ('Emerald', 'Able'), ('Manca', 'Pislak'), ('Irys', 'Ekani'), ('Veronica', 'Miroshnichenko'), ('Martina', 'Capurro Taborda'), ('Mariam', 'Bolkvadze'), ('Diana', 'Valverde'), ('Do Hee', 'Bae'), ('Daniela', 'Morales Beckmann'), ('Ioana Diana', 'Pietroiu'), ('Luisa Fernanda', 'Echeverry Rodriguez'), ('Mayuka', 'Aikawa'), ('Nicole', 'Frenkel'), ('Daria', 'Kruzhkova'), ('Alejandra', 'Tamayo Gomez'), ('Tereza', 'Koplova'), ('Chiara', 'Lommer'), ('Laura', 'Illanes'), ('Olga', 'Fridman'), ('Ana Paula', 'Leal'), ('Shiraz', 'Bronstein'), ('Nicole', 'Bunea'), ('Charlotte', 'Robillard Millette'), ('Ashley', 'Kratzer'), ('Momoka', 'Chimura'), ('Anna', 'Slovakova'), ('Ai Qi', 'Chen'), ('Jiaying', 'He'), ('Ysabel', 'Gonzalez Rico'), ('Andreea', 'Stanescu'), ('Marketa', 'Vondrousova'), ('Ecaterina', 'Ivasco'), ('Ivon', 'Mihaleva'), ('Jasmine', 'Boyd'), ('Andrea', 'Arratia Fernandez'), ('Kayla', 'Day'), ('Ekaterina', 'Davletova'), ('Irina', 'Cantos Siemers'), ('Oceane', 'Mialon'), ('Watsachol', 'Sawasdee'), ('Ellen', 'Ashley'), ('Mila', 'Mejic'), ('Natalia', 'Nikolopoulou'), ('Marta', 'Del Pino Maturano'), ('Jayci', 'Goldsmith'), ('Yang', 'Lee'), ('Isabella', 'Tcherkes Zade'), ('Mara', 'Vidal'), ('Taylor', 'Johnson'), ('Julia', 'Vulpio'), ('Dagmar', 'Zdrubecka'), ('Olga', 'Danilovic'), ('Xiyu', 'Wang'), ('Lina', 'Shokry'), ('Ya Hsin', 'Lee'), ('Ruxandra', 'Schech'), ('Yasmina', 'Karimjanova'), ('Lara', 'Biter'), ('Najah', 'Dawson'), ('Giulia', 'Morlet'), ('Matilde', 'Mariani'), ('Isabella', 'Nunez'), ('Betina', 'Tokac'), ('Noa', 'Krznaric')]","[('Ann', 'Jones'), ('Wendy', 'Gilchrist'), ('Martina', 'Navratilova'), ('Mary', 'Carillo'), ('Katerina', 'Bohmova'), ('Petra', 'Delhees Jauch'), ('Nancy', 'Loeffler Caro'), ('Lise', 'Gregory'), ('Rene', 'Collins'), ('Nicole', 'Arendt'), ('Florencia', 'Labat'), ('Sabine', 'Appelmans'), ('Andreea', 'Ehritt Vanc'), ('Monica', 'Seles'), ('Gala', 'Leon Garcia'), ('Karen', 'Cross'), ('Julie', 'Pullin'), ('Vanessa', 'Webb'), ('Elena', 'Tatarkova'), ('Anca', 'Barna'), ('Francesca', 'Lubiani'), ('Gaelle', 'Widmer'), ('Amanda', 'Keen'), ('Amanda', 'Augustus'), ('Rita', 'Kuti Kis'), ('Amelie', 'Cocheteux'), ('Amelie', 'Castera'), ('Saori', 'Obata'), ('Marine', 'Nizri Spiegel'), ('Patty', 'Schnyder'), ('Julie', 'Ditty'), ('Joana', 'Cortez'), ('Barbara', 'Schwartz'), ('Ludmilla', 'Varmuza'), ('Magui', 'Serna'), ('Amanda', 'Grahame'), ('Kim', 'Kilsdonk'), ('Emilie', 'Loit'), ('Erika', 'Pineider'), ('Anne Gaelle', 'Sidot'), ('Erica', 'Biro'), ('Stephanie', 'Kovacic'), ('Sybille', 'Bammer'), ('Lisa', 'Fritz'), ('Maja', 'Matevzic'), ('Leanne', 'Baker'), ('Aurelie', 'Vedy'), ('Carla', 'Tiene'), ('Erika', 'Venere'), ('Jelena', 'Kostanic Tosic'), ('Clarisa', 'Fernandez'), ('Ansley', 'Cargill'), ('Dimana', 'Krastevitch'), ('Maria Jose', 'Martinez Sanchez'), ('Zerene', 'Reyes'), ('Melinda', 'Czink'), ('Sandra', 'Klemenschits'), ('Maria Elizabeth', 'Lopez'), ('Salome', 'Llaguno'), ('Lindsay', 'Cox'), ('Iveta', 'Benesova'), ('Eugenia', 'Chialvo'), ('Chun Yan', 'He'), ('Maria Fernanda', 'Alves'), ('Emily', 'Quin'), ('Fernanda', 'Oliveira Da Silva'), ('Annabel', 'Blow'), ('Julia', 'Smith'), ('Ana Lucia', 'Migliarini De Leon'), ('Elizabeth', 'Bondi'), ('Galina', 'Fokina'), ('Elise', 'Tamaela'), ('Bit Na', 'Lee'), ('Sonia', 'Iacovacci'), ('Mariana Pires', 'Junqueira'), ('Natalia', 'Bogdanova'), ('Irina', 'Smirnova'), ('Meghha', 'Vakaria'), ('Angela', 'Haynes'), ('Karly', 'Olson'), ('Casey', 'Dellacqua'), ('Kathrin', 'Hegel'), ('Beatrix', 'Csordas'), ('Zsuzsanna', 'Babos'), ('Emily', 'Applegate'), ('Olga', 'Pasichnichenko'), ('Theresa', 'Logar'), ('Jin A', 'Lee'), ('Hannah', 'Kuervers'), ('Andreea', 'Novaceanu'), ('Valentina', 'Tizzano'), ('Helen', 'Fritche'), ('Sandra', 'Sasidharan'), ('Isha', 'Lakhani'), ('Krushmi', 'Chheda'), ('Ljubica', 'Avramovic'), ('Avel Romaly', 'Coronado'), ('Shadisha', 'Robinson'), ('Carla', 'Zabaleta'), ('Diana', 'Arutyunova'), ('Cecile', 'Baijot'), ('Laura', 'Rocchi'), ('Rie', 'Imai'), ('Danielle', 'Harmsen'), ('Alejandra', 'Obregon'), ('Ariela', 'Perez'), ('Vasilisa', 'Davydova'), ('Emilia', 'Yorio'), ('Lizaan', 'Du Plessis'), ('Claire', 'Feuerstein'), ('Alexandria', 'Liles'), ('Katharine', 'Baker'), ('Emma', 'Laine'), ('Geraldine', 'Roma'), ('Aya', 'El Akkad'), ('Alexandra', 'Kazanova'), ('Allison', 'Baker'), ('Lucy', 'Fletcher'), ('Monika', 'Musilova'), ('Jitka', 'Gavdunova'), ('Elena', 'Petrucciano'), ('Varvara', 'Lepchenko'), ('Claire', 'De Gubernatis'), ('Seheno', 'Razafindramaso'), ('Karolina', 'Soor'), ('Melisa', 'Cabrera Handt'), ('Shraddha', 'Lodha'), ('Sylvia', 'Krywacz'), ('Amina', 'El Sahn'), ('Hendrike Lea', 'Heitmann'), ('Dunja', 'Antunovic'), ('Micaela', 'Acosta'), ('Katerina', 'Bohmova'), ('Catherine', 'Grotz'), ('Yurika', 'Sema'), ('Sheng Nan', 'Sun'), ('Lucie', 'Safarova'), ('Jitka', 'Kleisnerova'), ('Carolina', 'Escamilla'), ('Tapiwa', 'Marobela'), ('Punam', 'Reddy'), ('Katia', 'Sabate Orera'), ('Shana', 'Claes'), ('Chrissie', 'Seredni'), ('Yui', 'Nagasawa'), ('Marcela', 'Vojtiskova'), ('Seul Ki', 'Chin'), ('Nina', 'Munch Soegaard'), ('Hannah', 'Grady'), ('Karen', 'Castiblanco'), ('Angelique', 'Kerber'), ('Lauren', 'Lui'), ('Rana', 'Tharwat Hafez'), ('Nicole', 'Grunwald'), ('Ana', 'Veselinovic'), ('Sanaa', 'Bhambri'), ('Diana Andreea', 'Gae'), ('Ana', 'Beltran Trigueros'), ('Barbora', 'Bozkova'), ('Camila', 'Belassi'), ('Violette', 'Huck'), ('Megumi', 'Fukui'), ('Rita', 'Gouveia'), ('Mihaela', 'Buzarnescu'), ('Liset', 'Brito Herrera'), ('Paulina', 'Jorquera'), ('Ekaterina', 'Makarova'), ('Dessislava', 'Mladenova'), ('Sanaz', 'Marand'), ('Cristina', 'Greco Naccarato'), ('Cagla', 'Urcu'), ('Liege', 'Vieira'), ('Chang', 'Xu'), ('Jessica', 'Sweeting'), ('Yi Fan', 'Xu'), ('Eloisa Maria', 'Compostizo De Andres'), ('Karina', 'Porushkevich'), ('Ornella', 'Gentile'), ('Valeria', 'Casillo'), ('Bianca Ioana', 'Bonifate'), ('Michelle', 'Russ'), ('Monika', 'Lalewicz'), ('Amandine', 'Cazeaux'), ('Fatima', 'El Allami'), ('Simonetta', 'Miori'), ('Gabriela', 'Roux'), ('Sherazad', 'Benamar'), ('Sherazad', 'Reix'), ('Zora', 'Vlckova'), ('Naomi', 'Cavaday'), ('Nathalia', 'Rossi'), ('Maria Eugenia', 'Roca Recarey'), ('Lauren', 'Jones'), ('Roxane', 'Vaisemberg'), ('Ivana', 'Belejova'), ('Petra', 'Vogel'), ('Majdouline', 'Akrate'), ('Laura', 'Sadria'), ('Ia', 'Jikia'), ('Alessandra', 'Caprara'), ('Guadalupe', 'Moreno'), ('Lucie', 'Sipkova'), ('Xenia', 'Samoilova'), ('Kotomi', 'Takahata'), ('Stephanie', 'Theiler'), ('Maria', 'Prishlyak'), ('Grace', 'Leake'), ('Ioana Alexandra', 'Oprea'), ('Sanne', 'Bakker'), ('Katerina', 'Vankova'), ('Kristy', 'Frilling'), ('Tatiana', 'Bua'), ('Anastasia', 'Kontratevidi'), ('Chane', 'Hines'), ('Julia', 'Gavenko'), ('Yuuki', 'Tanaka'), ('Petra', 'Kvitova'), ('Leticia', 'Costas'), ('Sandra', 'Roma'), ('Nina', 'Mujezinovic'), ('Stella', 'Papaspyrou'), ('Chinami', 'Ogi'), ('Martina', 'Balogova'), ('Xinyun', 'Han'), ('Nicole', 'Riner'), ('Lara', 'Meccico'), ('Mai', 'Iwasaki'), ('Oksana', 'Kalashnikova'), ('Dipti', 'Srivastava'), ('Claudia', 'Mercado'), ('Margarita', 'Lazareva'), ('Shaozhuo', 'Liu'), ('Ana Maria', 'Chavez Franco'), ('Arantxa', 'Rus'), ('Ekaterina', 'Kamendova'), ('Monika', 'Tumova'), ('Gabriella', 'Boboc'), ('Ganna', 'Lukianchykova'), ('Sofia', 'Medina'), ('Ekaterina', 'Abaeva'), ('Andressa', 'Garcia'), ('Giulia', 'Bruzzone'), ('Catia', 'Rodrigues'), ('Danielle', 'Mills'), ('Flavia', 'Borges'), ('Misaki', 'Doi'), ('Veronika', 'Domagala'), ('Cindy', 'Chala'), ('Ksenia', 'Pervak'), ('Bianca', 'Botto'), ('Marianna', 'Natali'), ('Carolina', 'Orsi'), ('Aleksandra', 'Vukadinovic'), ('Elixane', 'Lechemia'), ('Sonya', 'Dayal'), ('Francesca', 'Campigotto'), ('Cristina Bianca', 'Danaila'), ('Tereza', 'Budilova'), ('Gemma', 'Praditngam'), ('Ekaterine', 'Gorgodze'), ('Dejana', 'Raickovic'), ('Alena', 'Gerasimova'), ('Quirine', 'Lemoine'), ('Chieh Yu', 'Hsu'), ('Anastasiya', 'Vasylyeva'), ('Alexia', 'Quartetto'), ('Joanna', 'Bougon'), ('Kristyna', 'Pliskova'), ('Elena', 'Bogdan'), ('Fiorella', 'Jerardino'), ('Julie', 'Gonzalez Rodriguez'), ('Alejandra', 'Barragan'), ('Renata', 'Bakieva'), ('Ashley', 'Krysiak'), ('Sarah Rebecca', 'Sekulic'), ('Na Lae', 'Han'), ('Natali', 'Coronel'), ('Kristyna', 'Hancarova'), ('Doroteja', 'Eric'), ('Chanel', 'Simmonds'), ('Kobkanok', 'Upapong'), ('Annie', 'Sullivan'), ('Jenny Thuy', 'Le'), ('Xenia', 'Knoll'), ('Francisca', 'Matos'), ('Christina', 'Madenoglou'), ('Alexandra', 'Avirvarei'), ('Georgina', 'Fedosenkova'), ('Alicia', 'Doms Golobart'), ('Amy', 'Hoburn'), ('Monica', 'Turewicz'), ('Martina', 'Zerbola'), ('Mashaal', 'Hameed'), ('Sabrina', 'Dos Reis'), ('Maria Sol', 'Carrasco'), ('Ruxandra', 'Ababii'), ('Daniella', 'Patton'), ('Veronika', 'Zavodska'), ('Briar', 'Preston'), ('Gabriela', 'Ce'), ('Amanda', 'Rodgers'), ('Constanze', 'Lotz'), ('Paula', 'Mocete Talamantes'), ('Verena', 'Gantschnig'), ('Ainhoa', 'Atucha Gomez'), ('Katarzyna', 'Kossowska'), ('Julia', 'Stamatova'), ('Vorranavaporn', 'Vorrarattanamongkol'), ('Michaela', 'Jasenakova'), ('Agustina Sol', 'Eskenazi'), ('Maja', 'Mladenovic'), ('Sandra', 'Garriga Catala'), ('Rita', 'Vilaca'), ('Zanmarie', 'Pienaar'), ('Julia', 'Kimmelmann'), ('Martina', 'Trevisan'), ('Charitomeni', 'Matoula'), ('Andreea', 'Istrate'), ('Sowjanya', 'Bavisetti'), ('Gabrielle', 'Moxey'), ('Viktoryia', 'Kisialeva'), ('Sarahi', 'Garcia Carrera'), ('Rachel', 'Girard'), ('Laura', 'Robson'), ('Kate', 'Vialle'), ('Anna', 'Montserrat Sanchez'), ('Elena Teodora', 'Cadar'), ('Carol', 'Augustine Benito'), ('Kamila', 'Pavelkova'), ('Arantxa', 'Sanchez'), ('Ana Sofia', 'Sanchez'), ('Julia', 'Wachaczyk'), ('Ecaterina', 'Oproiu'), ('Snigdha', 'Padamata'), ('Rona', 'Berisha'), ('Olga', 'Doroshina'), ('So Ra', 'Lee'), ('Brandy', 'Mina'), ('Natalie', 'Novakova'), ('Storm', 'Sanders'), ('Alexandra', 'Martinez'), ('Ysaline', 'Bonaventure'), ('Barbora', 'Trestikova'), ('Stefania', 'Hristov'), ('Ana Maria', 'Crisan'), ('Elpida', 'Papanelopoulou'), ('Tereza', 'Jankovska'), ('Rebecca', 'Andrade'), ('Kelly', 'Williford'), ('Tina', 'Rupert'), ('Mia Nicole', 'Eklund'), ('Bernarda', 'Pera'), ('Montserrat', 'Alonso'), ('Rosalie', 'Van Der Hoek'), ('Hedda', 'Odegaard'), ('Samira', 'Radjaa'), ('Zuzanna', 'Maciejewska'), ('Saumya', 'Vig'), ('Marie', 'Benoit'), ('Iga', 'Odrzywolek'), ('Shakhlo', 'Saidova'), ('Irina', 'Khromacheva'), ('Yuliya', 'Lysa'), ('Sophie', 'Blom'), ('Jennifer', 'Zerbone'), ('Kristina', 'Chasovskikh'), ('Maria Camila', 'Trujillo Hoyos'), ('Karina', 'Rovira'), ('Teodora Adina', 'Ardeleanu'), ('Yasmine', 'Rashad'), ('Judit', 'Vives Joan'), ('Sarah Beth', 'Askew'), ('Yasmine', 'Xantos'), ('Lea', 'Tholey'), ('Hikari', 'Yamamoto'), ('Ines Miren', 'De Pablo'), ('Stuti', 'Singh Tomar'), ('Naomi', 'Totka'), ('Polina', 'Bezsmertnaya'), ('Hannah', 'King'), ('Gabriele', 'Bertasiute'), ('Rebecca', 'Smaller'), ('Busra', 'Kayrun'), ('Stephani', 'Rodriguez'), ('Raquel', 'Montalvo'), ('Oana', 'Irimescu'), ('Taylor', 'Townsend'), ('Carmen', 'Blasco Robaina'), ('Giulia', 'Della Cioppa'), ('Nadege', 'Jorda'), ('Beatriz', 'Haddad Maia'), ('Nelise', 'Verster'), ('Eleonore', 'Barrere'), ('Anastasia', 'Prokopenko'), ('Dzina', 'Milovanovic'), ('Isabelle', 'Wallace'), ('Katelyn', 'Jackson'), ('Polina', 'Novoselova'), ('Maite', 'Cano'), ('Ria', 'Vaidya'), ('Ana Lorena', 'Garcia Navas'), ('Aayushi', 'Chouhan'), ('Ivona', 'Cudina'), ('Karina', 'Gurgenyan'), ('Maria', 'Patrascu'), ('Denisa', 'Chereches'), ('Mirabelle', 'Njoze'), ('Vasanti', 'Shinde'), ('Amanda', 'Schneider'), ('Katharina', 'Herpertz'), ('Tayisiya', 'Morderger'), ('Tamara', 'Tomic'), ('Maria Fernanda', 'Herazo Gonzalez'), ('Andra Maria', 'Nitescu'), ('Micheline', 'Aubuchon'), ('Ilayda', 'Yondem'), ('Birgit', 'Burk'), ('Kanako', 'Osafune'), ('Anastasiya', 'Komardina'), ('Nina', 'Holanova'), ('Jil Belen', 'Teichmann'), ('Francesca', 'Di Lorenzo'), ('Natsuho', 'Arakawa'), ('Emerald', 'Able'), ('Manca', 'Pislak'), ('Irys', 'Ekani'), ('Veronica', 'Miroshnichenko'), ('Martina', 'Capurro Taborda'), ('Mariam', 'Bolkvadze'), ('Diana', 'Valverde'), ('Do Hee', 'Bae'), ('Daniela', 'Morales Beckmann'), ('Ioana Diana', 'Pietroiu'), ('Luisa Fernanda', 'Echeverry Rodriguez'), ('Mayuka', 'Aikawa'), ('Nicole', 'Frenkel'), ('Daria', 'Kruzhkova'), ('Alejandra', 'Tamayo Gomez'), ('Tereza', 'Koplova'), ('Chiara', 'Lommer'), ('Laura', 'Illanes'), ('Olga', 'Fridman'), ('Ana Paula', 'Leal'), ('Shiraz', 'Bronstein'), ('Nicole', 'Bunea'), ('Charlotte', 'Robillard Millette'), ('Ashley', 'Kratzer'), ('Momoka', 'Chimura'), ('Anna', 'Slovakova'), ('Ai Qi', 'Chen'), ('Jiaying', 'He'), ('Ysabel', 'Gonzalez Rico'), ('Andreea', 'Stanescu'), ('Marketa', 'Vondrousova'), ('Ecaterina', 'Ivasco'), ('Ivon', 'Mihaleva'), ('Jasmine', 'Boyd'), ('Andrea', 'Arratia Fernandez'), ('Kayla', 'Day'), ('Ekaterina', 'Davletova'), ('Irina', 'Cantos Siemers'), ('Oceane', 'Mialon'), ('Watsachol', 'Sawasdee'), ('Ellen', 'Ashley'), ('Mila', 'Mejic'), ('Natalia', 'Nikolopoulou'), ('Marta', 'Del Pino Maturano'), ('Jayci', 'Goldsmith'), ('Yang', 'Lee'), ('Isabella', 'Tcherkes Zade'), ('Mara', 'Vidal'), ('Taylor', 'Johnson'), ('Julia', 'Vulpio'), ('Dagmar', 'Zdrubecka'), ('Olga', 'Danilovic'), ('Xiyu', 'Wang'), ('Lina', 'Shokry'), ('Ya Hsin', 'Lee'), ('Ruxandra', 'Schech'), ('Yasmina', 'Karimjanova'), ('Lara', 'Biter'), ('Najah', 'Dawson'), ('Giulia', 'Morlet'), ('Matilde', 'Mariani'), ('Isabella', 'Nunez'), ('Betina', 'Tokac'), ('Noa', 'Krznaric')]",,1.0,
Show the name of the teacher for the math course.,"[teacher.Name,course.Course,course_arrange.Course_ID = course.Course_ID,course_arrange.Teacher_ID = teacher.Teacher_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NON-NESTED,SELECT teacher.Name FROM course JOIN course_arrange ON course.Course_ID = course_arrange.Course_ID JOIN teacher ON course_arrange.Teacher_ID = teacher.Teacher_ID WHERE course.Course = 'math';,"SELECT T3.Name FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID WHERE T2.Course  =  ""Math""",course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Name"" field, as the question asks for the name of the teacher. 2. Condition Structure: Use a WHERE clause to filter for the course name ""math"" in the ""course.Course"" field. 3. Join Structure: Use JOINs to connect the ""course"" table with the ""course_arrange"" table on ""course.Course_ID = course_arrange.Course_ID"" and the ""course_arrange"" table with the ""teacher"" table on ""course_arrange.Teacher_ID = teacher.Teacher_ID."" 4. Aggregation Structure: No aggregation is needed since the query only retrieves the teacher's name for a specific course.",[],"[('Kearsley Brown',), ('Vicente Carretero',)]",,0.0,
How many courses are there?,[Courses.course_id],"Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT COUNT(Courses.course_id) AS total_courses FROM Courses;,SELECT count(*) FROM Courses,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to count the total number of courses. 2. Condition Structure: No specific filtering condition is required as we want the total count of all courses. 3. Join Structure: No JOIN is necessary since all required information is available in the ""Courses"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of courses based on the ""Courses.course_id"".","[(15,)]","[(15,)]",,1.0,
How many museums were opened after 2013 or before 2008?,"[museum.Museum_ID, museum.Open_Year, 2013, 2008]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",EASY,SELECT COUNT(*) AS museum_count FROM museum WHERE museum.Open_Year > 2013 OR museum.Open_Year < 2008;,SELECT count(*) FROM museum WHERE open_year  >  2013 OR open_year  <  2008,museum_visit,"1. Sequential Structure: Start with the SELECT clause to count the number of museums that meet the specified condition. 2. Condition Structure: Use a WHERE clause to filter museums where the ""museum.Open_Year"" is either after 2013 or before 2008. 3. Join Structure: No JOIN is required since all necessary information is in the ""museum"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of museums that satisfy the condition.","[(1,)]","[(1,)]",,1.0,
What are the death and injury situations caused by the ship with tonnage 't'?,"[ship.tonnage,ship.id,death.caused_by_ship_id = ship.id,death.killed,death.injured]","Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",NON-NESTED,"SELECT death.killed, death.injured FROM ship JOIN death ON death.caused_by_ship_id = ship.id WHERE ship.tonnage = 't';","SELECT T1.killed ,  T1.injured FROM death AS T1 JOIN ship AS t2 ON T1.caused_by_ship_id  =  T2.id WHERE T2.tonnage  =  't'",battle_death,"1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""death.killed"" and ""death.injured"" to describe the death and injury situations. 2. Condition Structure: Use a WHERE clause to filter for the specific ship with the given tonnage 't'. 3. Join Structure: Use an INNER JOIN between the ""ship"" and ""death"" tables based on the foreign key ""death.caused_by_ship_id = ship.id"" to link deaths to the corresponding ship. 4. Aggregation Structure: No aggregation is needed as the query is focused on retrieving specific details without summarization.","[(8, 0), (3, 0), (25, 0), (2, 0), (0, 0), (4, 5), (0, 0), (29, 0), (0, 0), (0, 0), (14, 0)]","[(8, 0), (3, 0), (25, 0), (2, 0), (0, 0), (4, 5), (0, 0), (29, 0), (0, 0), (0, 0), (14, 0)]",,1.0,
What are the average ages of losers and winners across matches?,"[matches.loser_age, matches.winner_age]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT AVG(matches.loser_age) AS avg_loser_age, AVG(matches.winner_age) AS avg_winner_age FROM matches;","SELECT avg(loser_age) ,  avg(winner_age) FROM matches",wta_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the average ages of losers and winners. 2. Aggregation Structure: Use the AVG function to calculate the average age for both losers and winners across all matches. 3. Grouping Structure: No GROUP BY is required since we are calculating overall averages for losers and winners. 4. Join Structure: No JOIN is required as all necessary data is within the ""matches"" table.","[(27.311213862584534, 27.062177773183812)]","[(27.311213862584534, 27.062177773183812)]",,1.0,
Find the first name and country code of the player who did the most number of tours.,"[players.first_name, players.country_code, rankings.player_id, rankings.tours, rankings.player_id = players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT players.first_name, players.country_code FROM players JOIN rankings ON rankings.player_id = players.player_id WHERE rankings.tours = (SELECT MAX(rankings.tours) FROM rankings);","SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve ""players.first_name"" and ""players.country_code."" Use an aggregate function (MAX) to find the player with the most number of tours. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the player with the maximum tours. 3. Join Structure: Use a JOIN between the ""rankings"" and ""players"" tables based on ""rankings.player_id = players.player_id"" to associate each player's details with their ranking data. 4. Aggregation Structure: Use MAX to find the maximum number of tours and filter the player with this maximum value using a subquery or a WHERE clause.","[('Julia', 'USA')]","[('USA', 'Julia')]",,1.0,
How many players are from each country?,"[players.player_id, players.country_code]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT players.country_code, COUNT(*) AS player_count FROM players GROUP BY players.country_code;","SELECT count(*) ,  country_code FROM players GROUP BY country_code",wta_1,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the country code and the count of players. 2. Aggregation Structure: Use COUNT to calculate the number of players from each country. 3. Grouping Structure: Use GROUP BY on ""players.country_code"" to group the results by each country. 4. Join Structure: No JOIN is required since all necessary data is within the ""players"" table.","[('AHO', 6), ('ALB', 2), ('ALG', 63), ('AND', 1), ('ANG', 1), ('ANT', 8), ('ARG', 456), ('ARM', 27), ('AUS', 742), ('AUT', 236), ('AZE', 10), ('BAH', 22), ('BAR', 20), ('BDI', 5), ('BEL', 247), ('BEN', 2), ('BER', 20), ('BIH', 75), ('BLR', 144), ('BOL', 97), ('BOT', 17), ('BRA', 456), ('BRN', 5), ('BRU', 4), ('BUL', 181), ('CAN', 331), ('CGO', 2), ('CHI', 114), ('CHN', 391), ('CMR', 8), ('COL', 240), ('CRC', 24), ('CRO', 240), ('CUB', 39), ('CYP', 22), ('CZE', 456), ('DEN', 79), ('DOM', 38), ('ECA', 3), ('ECU', 90), ('EGY', 112), ('ESA', 33), ('ESP', 853), ('EST', 48), ('ETH', 8), ('FIJ', 5), ('FIN', 103), ('FRA', 736), ('FRG', 22), ('GBR', 660), ('GEO', 91), ('GER', 833), ('GHA', 4), ('GRE', 163), ('GRN', 1), ('GUA', 29), ('GUD', 8), ('HAI', 5), ('HKG', 56), ('HON', 8), ('HUN', 169), ('INA', 181), ('IND', 478), ('IRI', 15), ('IRL', 68), ('IRQ', 7), ('ISL', 18), ('ISR', 232), ('ITA', 866), ('JAM', 19), ('JOR', 6), ('JPN', 823), ('KAZ', 99), ('KEN', 23), ('KGZ', 23), ('KOR', 274), ('KUW', 3), ('LAT', 56), ('LES', 3), ('LIB', 11), ('LIE', 15), ('LTU', 31), ('LUX', 37), ('MAD', 21), ('MAR', 97), ('MAS', 35), ('MDA', 45), ('MEX', 416), ('MGL', 1), ('MKD', 23), ('MLT', 17), ('MNE', 25), ('MON', 2), ('MRI', 15), ('MRN', 4), ('NAM', 13), ('NCA', 3), ('NED', 342), ('NGR', 80), ('NOR', 68), ('NZL', 104), ('OMA', 3), ('PAK', 18), ('PAN', 22), ('PAR', 56), ('PER', 76), ('PHI', 70), ('PNG', 1), ('POC', 12), ('POL', 266), ('POR', 142), ('PUR', 43), ('QAT', 1), ('REU', 17), ('RHO', 3), ('ROU', 422), ('RSA', 283), ('RUS', 810), ('SAM', 3), ('SCG', 16), ('SEN', 7), ('SIN', 44), ('SLO', 145), ('SMR', 4), ('SRB', 224), ('SRI', 32), ('SUI', 243), ('SVK', 247), ('SWE', 324), ('SYR', 21), ('TCH', 21), ('THA', 171), ('TJK', 6), ('TKM', 12), ('TOG', 2), ('TPE', 146), ('TRI', 29), ('TTO', 1), ('TUN', 57), ('TUR', 203), ('UAE', 1), ('UKR', 311), ('UNK', 11), ('URS', 22), ('URU', 56), ('USA', 2217), ('UZB', 123), ('VEN', 150), ('VIE', 19), ('YUG', 48), ('ZAM', 1), ('ZIM', 26), ('rc=', 4)]","[(6, 'AHO'), (2, 'ALB'), (63, 'ALG'), (1, 'AND'), (1, 'ANG'), (8, 'ANT'), (456, 'ARG'), (27, 'ARM'), (742, 'AUS'), (236, 'AUT'), (10, 'AZE'), (22, 'BAH'), (20, 'BAR'), (5, 'BDI'), (247, 'BEL'), (2, 'BEN'), (20, 'BER'), (75, 'BIH'), (144, 'BLR'), (97, 'BOL'), (17, 'BOT'), (456, 'BRA'), (5, 'BRN'), (4, 'BRU'), (181, 'BUL'), (331, 'CAN'), (2, 'CGO'), (114, 'CHI'), (391, 'CHN'), (8, 'CMR'), (240, 'COL'), (24, 'CRC'), (240, 'CRO'), (39, 'CUB'), (22, 'CYP'), (456, 'CZE'), (79, 'DEN'), (38, 'DOM'), (3, 'ECA'), (90, 'ECU'), (112, 'EGY'), (33, 'ESA'), (853, 'ESP'), (48, 'EST'), (8, 'ETH'), (5, 'FIJ'), (103, 'FIN'), (736, 'FRA'), (22, 'FRG'), (660, 'GBR'), (91, 'GEO'), (833, 'GER'), (4, 'GHA'), (163, 'GRE'), (1, 'GRN'), (29, 'GUA'), (8, 'GUD'), (5, 'HAI'), (56, 'HKG'), (8, 'HON'), (169, 'HUN'), (181, 'INA'), (478, 'IND'), (15, 'IRI'), (68, 'IRL'), (7, 'IRQ'), (18, 'ISL'), (232, 'ISR'), (866, 'ITA'), (19, 'JAM'), (6, 'JOR'), (823, 'JPN'), (99, 'KAZ'), (23, 'KEN'), (23, 'KGZ'), (274, 'KOR'), (3, 'KUW'), (56, 'LAT'), (3, 'LES'), (11, 'LIB'), (15, 'LIE'), (31, 'LTU'), (37, 'LUX'), (21, 'MAD'), (97, 'MAR'), (35, 'MAS'), (45, 'MDA'), (416, 'MEX'), (1, 'MGL'), (23, 'MKD'), (17, 'MLT'), (25, 'MNE'), (2, 'MON'), (15, 'MRI'), (4, 'MRN'), (13, 'NAM'), (3, 'NCA'), (342, 'NED'), (80, 'NGR'), (68, 'NOR'), (104, 'NZL'), (3, 'OMA'), (18, 'PAK'), (22, 'PAN'), (56, 'PAR'), (76, 'PER'), (70, 'PHI'), (1, 'PNG'), (12, 'POC'), (266, 'POL'), (142, 'POR'), (43, 'PUR'), (1, 'QAT'), (17, 'REU'), (3, 'RHO'), (422, 'ROU'), (283, 'RSA'), (810, 'RUS'), (3, 'SAM'), (16, 'SCG'), (7, 'SEN'), (44, 'SIN'), (145, 'SLO'), (4, 'SMR'), (224, 'SRB'), (32, 'SRI'), (243, 'SUI'), (247, 'SVK'), (324, 'SWE'), (21, 'SYR'), (21, 'TCH'), (171, 'THA'), (6, 'TJK'), (12, 'TKM'), (2, 'TOG'), (146, 'TPE'), (29, 'TRI'), (1, 'TTO'), (57, 'TUN'), (203, 'TUR'), (1, 'UAE'), (311, 'UKR'), (11, 'UNK'), (22, 'URS'), (56, 'URU'), (2217, 'USA'), (123, 'UZB'), (150, 'VEN'), (19, 'VIE'), (48, 'YUG'), (1, 'ZAM'), (26, 'ZIM'), (4, 'rc=')]",,1.0,
How many different loser names are there?,[matches.loser_name],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT COUNT(DISTINCT matches.loser_name) FROM matches;,SELECT count(DISTINCT loser_name) FROM matches,wta_1,"1. Sequential Structure: Start with the SELECT clause to count the distinct loser names, as the question asks for the number of different loser names. 2. Condition Structure: No specific filtering condition is required since we are counting all distinct loser names. 3. Join Structure: No JOIN is necessary because the required data is available within the ""matches"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""matches.loser_name"" to count the unique loser names.","[(49,)]","[(49,)]",,1.0,
What are the country code and first name of the players who won in both tourney WTA Championships and Australian Open?,"[players.country_code, players.first_name, matches.winner_id = players.player_id, matches.tourney_name, WTA Championships, Australian Open]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NESTED,"SELECT DISTINCT players.country_code, players.first_name FROM players JOIN matches ON players.player_id = matches.winner_id WHERE matches.tourney_name = 'WTA Championships' AND players.player_id IN ( SELECT winner_id FROM matches WHERE tourney_name = 'Australian Open' );","SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the country code and first name of players. Use the FROM clause to specify the players table and JOIN it with the matches table to link players with their match records. Apply a WHERE clause to filter for players who won in both the ""WTA Championships"" and ""Australian Open"" tournaments. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the player won matches in both tournaments. The subquery will check for the existence of wins in each of the two tournaments. 3. Join Structure: Use an INNER JOIN between the players and matches tables based on the winner_id and player_id to connect player details with their match records. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('USA', 'Serena'), ('GER', 'Angelique')]","[('GER', 'Angelique'), ('USA', 'Serena')]",,1.0,
List the first and last name of all players in the order of birth date.,"[players.first_name, players.last_name, players.birth_date]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT players.first_name, players.last_name FROM players ORDER BY players.birth_date ASC;","SELECT first_name ,  last_name FROM players ORDER BY birth_date",wta_1,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""players.first_name"", ""players.last_name"", and ""players.birth_date"". 2. Condition Structure: No specific filtering condition is required as we want all players. 3. Join Structure: No JOIN is required since all necessary information is available in the ""players"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by ""players.birth_date"" in ascending order.",[],[],Could not decode to UTF-8 column 'last_name' with text 'Treyes Albarrac��N',1.0,Could not decode to UTF-8 column 'last_name' with text 'Treyes Albarrac��N'
Find the average ranking for each player and their first name.,"[rankings.ranking,rankings.player_id,players.first_name,rankings.player_id = players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT players.first_name, AVG(rankings.ranking) AS average_ranking FROM rankings JOIN players ON rankings.player_id = players.player_id GROUP BY players.first_name;","SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the player's first name and their average ranking. Use the AVG function to calculate the average ranking for each player. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""rankings"" table and the ""players"" table on ""rankings.player_id = players.player_id"" to associate rankings with player details. 4. Aggregation Structure: Use AVG on ""rankings.ranking"" to calculate the average ranking for each player and GROUP BY ""players.first_name"" to group the results by player.","[('Aastha', 1199.8235294117646), ('Abbi', 1110.0434782608695), ('Abbie', 808.4545454545455), ('Abigail', 387.66706161137444), ('Abiodun', 1039.6744186046512), ('Abir', 1228.75), ('Adeliya', 790.1538461538462), ('Adnya', 1122.4423076923076), ('Adriana', 619.6814159292036), ('Adrienn', 1213.1666666666667), ('Adrijana', 627.12), ('Adva', 1255.3333333333333), ('Afroditi', 1155.0392156862745), ('Agata', 960.6770186335403), ('Agata Jadwiga', 1082.3548387096773), ('Agne', 1231.5), ('Agnes', 391.3003629764065), ('Agnese', 694.0659898477157), ('Agni', 940.2125603864735), ('Agnieszka', 122.19587628865979), ('Agustina', 684.8497652582159), ('Agustina Elena', 1154.25), ('Ah', 1156.340425531915), ('Ahlam', 1248.72), ('Ahsha', 728.5), ('Ai', 890.8728448275862), ('Ai Wen', 912.1523178807947), ('Aida', 1110.3333333333333), ('Aiko', 284.8724727838258), ('Ailen', 1034.5833333333333), ('Aimee', 1200.2), ('Aina', 1164.95), ('Ainhoa', 943.7397959183673), ('Aishwarya', 1024.625), ('Ajla', 302.84831460674155), ('Akari', 704.9618138424821), ('Akgul', 215.25185185185185), ('Aki', 710.9617224880383), ('Akiho', 1145.8235294117646), ('Akiko', 493.98205383848455), ('Akilah', 772.8571428571429), ('Akvile', 1038.35), ('Alana', 1119.1639344262296), ('Alba', 843.7260273972603), ('Alberta', 343.22432701894314), ('Albina', 775.2734375), ('Aldana', 1185.7142857142858), ('Alejandra', 1067.019801980198), ('Aleksandra', 450.22998544395927), ('Aleksandrina', 578.07962529274), ('Alena', 820.4563492063492), ('Alessandra', 1123.4864864864865), ('Alessia', 1057.628205128205), ('Alessondra', 1145.1641791044776), ('Alexa', 383.9921465968586), ('Alexandra', 569.2647632558965), ('Alexandria', 945.625), ('Alexia', 718.5202702702703), ('Alexis', 604.15), ('Aliaksandra', 441.9846743295019), ('Alice', 710.3822682786414), ('Alice Andrada', 951.9764150943396), ('Alicia', 1105.1298701298701), ('Alicja', 855.813627254509), ('Alina', 925.0028776978418), ('Aliona', 611.35), ('Alisa', 453.01556420233464), ('Alison', 403.48784576697403), ('Alix', 822.3459915611814), ('Alize', 252.11485774499474), ('Alla', 217.85922330097088), ('Allie', 557.9232456140351), ('Almudena', 1157.8), ('Alona', 871.6926829268293), ('Alory Regina Elorriaga', 1181.6078431372548), ('Alyona', 496.9431818181818), ('Amanda', 650.6240276577355), ('Amandine', 747.4375), ('Amelie', 1011.3666666666667), ('Amina', 803.9764705882353), ('Aminat', 613.195652173913), ('Amira', 1075.8260869565217), ('Amra', 415.9078341013825), ('Amrita', 1209.4), ('Amy', 763.888198757764), ('An Sophie', 460.8932038834951), ('Ana', 396.2893280632411), ('Ana Bianca', 842.8446601941747), ('Ana Clara', 524.9192825112108), ('Ana Gabriela', 1084.7916666666667), ('Ana Luisa', 1243.4285714285713), ('Ana Paula', 1031.228855721393), ('Ana Sofia', 496.7156398104265), ('Ana Victoria', 961.2631578947369), ('Anabel', 144.3264367816092), ('Anaeve', 922.2255639097745), ('Anais', 482.26169844020797), ('Anamika', 859.3059701492538), ('Anastasia', 430.0872542522642), ('Anastasia Evgenyevna', 956.5754716981132), ('Anastasiia', 1245.75), ('Anastasija', 221.66153846153847), ('Anastasiya', 671.2584369449378), ('Anca', 1127.7368421052631), ('Anda', 1150.0), ('Andie K', 970.3620689655172), ('Andjela', 1063.4736842105262), ('Andra Maria', 1275.8235294117646), ('Andrea', 414.4332292750607), ('Andrea Renee', 878.3939393939394), ('Andreea', 956.0333333333333), ('Andreea Amalia', 801.84375), ('Andreea Roxana', 726.2657657657658), ('Andreja', 424.64521739130436), ('Andressa Cristina', 1184.0416666666667), ('Andrina', 1045.6666666666667), ('Aneta', 1152.0857142857142), ('Anett', 367.2274678111588), ('Anette', 969.8181818181819), ('Ange Oby', 1226.3333333333333), ('Angela', 1128.7272727272727), ('Angelica', 686.2234432234433), ('Angeliki', 1089.1603773584907), ('Angelina', 750.3207810320781), ('Angelique', 308.56833824975416), ('Anhelina', 432.6949152542373), ('Anhzelika', 850.9791666666666), ('Ani', 720.1431870669746), ('Anita', 947.472972972973), ('Anja', 725.3893333333333), ('Anke', 1228.388888888889), ('Ankita', 618.4714285714285), ('Ann', 907.4), ('Anna', 551.5557158312297), ('Anna Arina', 760.639175257732), ('Anna Giulia', 428.5496828752643), ('Anna Karolina', 345.51020408163265), ('Anna Katalina', 916.7115384615385), ('Anna Lena', 201.87700534759358), ('Anna Maria', 1070.3967391304348), ('Annalisa', 583.9347826086956), ('Anne', 248.74237737516572), ('Anne Liz', 762.7606382978723), ('Anne Marie', 1237.6363636363637), ('Anne Sophie', 1252.0), ('Annie', 1042.037037037037), ('Annika', 265.79487179487177), ('Anouk', 969.5882352941177), ('Antonela', 1051.7096774193549), ('Antonia', 589.1298076923077), ('Antonina', 1049.4655172413793), ('Anushka', 1037.0833333333333), ('Ao', 617.3333333333334), ('Apichaya', 1016.5714285714286), ('Arabela', 658.5074074074074), ('Arantxa', 279.23336006415394), ('Aranza', 490.4144736842105), ('Aravane', 200.97080291970804), ('Ariadna', 951.4146341463414), ('Arina', 560.6778190830236), ('Arina Gabriela', 1224.0), ('Arlinda', 1074.3333333333333), ('Arthi', 1281.8461538461538), ('Aryna', 349.54794520547944), ('Aselya', 1181.27868852459), ('Asha', 1151.95), ('Ashleigh', 331.3681818181818), ('Ashley', 638.88), ('Ashling', 823.0909090909091), ('Ashmitha', 1018.6637931034483), ('Ashvarya', 803.3904761904762), ('Asia', 453.43392070484583), ('Asiya', 790.46875), ('Assia', 1172.5531914893618), ('Astra', 829.5625), ('Astrid Wanja', 1086.45), ('Audrey', 591.2544731610338), ('Avgusta', 1208.4285714285713), ('Axana', 1064.0), ('Ayaka', 552.4653465346535), ('Ayan', 901.8717948717949), ('Ayano', 597.6981132075472), ('Ayla', 397.83561643835617), ('Aymet', 915.5932203389831), ('Ayu Fani', 479.5530612244898), ('Ayumi', 412.74466019417474), ('Azra', 556.2303370786517), ('Barbara', 763.8900651465798), ('Barbora', 252.6093155893536), ('Basak', 656.2932551319648), ('Beatrice', 785.0707482993197), ('Beatriz', 457.4050279329609), ('Beatriz Magdalena', 1253.4), ('Beatriz Maria', 971.2865853658536), ('Beauty', 1382.1538461538462), ('Belen', 1167.3368421052633), ('Belinda', 681.7736842105263), ('Benedetta', 705.4688346883469), ('Berfu', 625.013698630137), ('Bermet', 717.7932330827068), ('Bernarda', 541.273631840796), ('Bernice', 834.1005025125628), ('Berta', 1005.75), ('Bethanie', 146.59709379128137), ('Betina', 1229.5714285714287), ('Bhuvana', 878.0138888888889), ('Bianca', 653.2805383022775), ('Bianka', 696.952380952381), ('Bibiane', 550.1941544885177), ('Blair', 912.71875), ('Blanca', 904.6538461538462), ('Blessing', 1221.8333333333333), ('Boba', 1254.6341463414635), ('Bojana', 392.7313829787234), ('Borislava', 834.2066115702479), ('Boyan', 992.4222222222222), ('Brandy', 970.9846153846154), ('Breaunna', 872.0930232558139), ('Brenda', 211.01377118644066), ('Brianna', 854.3170731707318), ('Brienne', 917.0), ('Brindtha', 1126.3333333333333), ('Britt', 647.5205479452055), ('Brittany', 990.5210084033613), ('Brooke', 804.6277056277056), ('Brynn', 952.5619834710744), ('Bunyawi', 555.3384615384615), ('Busra', 1140.981981981982), ('Cagla', 311.87854251012146), ('Caitlin', 709.4247787610619), ('Camelia Elena', 803.7139479905437), ('Cameron', 1192.1818181818182), ('Camila', 539.7944621938232), ('Camila Vital', 1192.3783783783783), ('Camilla', 801.6850649350649), ('Camille', 1112.9450549450548), ('Cara', 236.07412398921832), ('Carina', 416.3666666666667), ('Carla', 411.70779777206513), ('Carlota', 1236.7777777777778), ('Carlotta', 1127.9338842975208), ('Carly', 318.69978858350953), ('Carmen', 890.6351351351351), ('Carmen Raluca', 842.1553398058253), ('Carol', 564.1434426229508), ('Carolin', 645.2279792746114), ('Carolina', 718.725321888412), ('Carolina Meligeni Rodrigues', 799.0650406504066), ('Caroline', 342.40130505709624), ('Caroline B', 1161.5675675675675), ('Carolyn', 1197.578947368421), ('Carson', 1020.6), ('Casey', 378.0163727959698), ('Catalina', 293.76942355889724), ('Catherine', 941.4724409448819), ('Catherine Cartan', 134.21917808219177), ('Caty', 744.0), ('Cecilia', 755.4649681528663), ('Cecilie Lundgaard', 1141.842105263158), ('Celine', 708.618398637138), ('Cemre', 1123.3855421686746), ('Chalena', 650.1367521367522), ('Chanel', 343.2835365853659), ('Chanelle', 215.6615811373093), ('Chang', 575.4626436781609), ('Chanikarn', 1281.8461538461538), ('Chantal', 609.90625), ('Chantelle', 1128.030303030303), ('Chaoyi', 1232.8), ('Charlene', 766.4794520547945), ('Charlotte', 927.7647058823529), ('Chayenne', 593.9759036144578), ('Chelsea', 1132.0), ('Chelsey', 719.3061224489796), ('Chen', 524.7444668008048), ('Chengyiyi', 789.2857142857143), ('Chi Chi', 464.1367781155015), ('Chi Fan', 1039.3902439024391), ('Chia Hsien', 950.8813559322034), ('Chia Jung', 359.3764705882353), ('Chiaki', 437.73858921161826), ('Chiara', 977.9640591966173), ('Chieh Yu', 533.9586374695864), ('Chihiro', 848.9908952959029), ('Chin Wei', 385.2651515151515), ('Chinami', 615.2230215827338), ('Ching Wen', 583.530303030303), ('Chiraz', 749.3582089552239), ('Chisa', 874.8181818181819), ('Chloe', 675.2445414847161), ('Chompoothip', 1112.1458333333333), ('Christie', 1112.875), ('Christina', 454.9920529801324), ('Christine', 841.4051724137931), ('Chun Mei', 692.390625), ('Chun Yan', 986.3944099378882), ('Cindy', 659.3055555555555), ('Claire', 443.45754716981133), ('Clara', 1190.7307692307693), ('Claudia', 826.2619047619048), ('Claudia Antonia', 967.2978723404256), ('Claudia Gianina', 996.2574257425742), ('Claudine', 383.6413199426112), ('Clelia', 823.6306306306307), ('Clemence', 875.9772727272727), ('Clementina Eugenia', 964.1224489795918), ('Clothilde', 620.4120171673819), ('Coco', 270.5896860986547), ('Colomba', 1165.093023255814), ('Conny', 390.0), ('Constance', 570.2723004694835), ('Constanza', 835.1132075471698), ('Constanze', 1245.3333333333333), ('Corina', 832.7818181818182), ('Corinna', 356.8219696969697), ('Cornelia', 757.2253521126761), ('Cory Ann', 406.5511363636364), ('Costanza', 1049.0), ('Cristiana', 554.5376344086021), ('Cristina', 643.616049382716), ('Cristina Andreea', 439.5747863247863), ('Cristina Madalina', 720.6428571428571), ('Csilla', 949.7944444444445), ('Cynthia', 998.7722772277227), ('Da Hye', 1010.3333333333334), ('Dabin', 920.1276595744681), ('Dagmara', 1159.1818181818182), ('Daiana', 720.7490039840637), ('Dajana', 1181.4736842105262), ('Dalia', 801.6933333333334), ('Dalila', 525.9552572706936), ('Dalma', 279.16438356164383), ('Damilola', 1493.0), ('Damini', 1242.0), ('Damira', 1198.3333333333333), ('Dan Ni', 994.4769230769231), ('Dana', 805.7028985507246), ('Daneika', 977.4539007092199), ('Danica', 380.609375), ('Daniela', 348.6364892881825), ('Daniella', 643.9216101694915), ('Danielle', 744.7453250222618), ('Danielle Rose', 434.68), ('Danijela', 1107.0919540229886), ('Danka', 302.83268482490274), ('Daphne', 1226.5454545454545), ('Daria', 629.6443987667009), ('Darija', 464.95631067961165), ('Dariya', 1132.1744186046512), ('Darya', 531.1829405162739), ('Dasha', 722.6986301369863), ('Dayana', 576.4307692307692), ('Dea', 550.9545454545455), ('Deborah', 764.6785714285714), ('Deeon', 1115.0851063829787), ('Dejana', 758.5342960288808), ('Demi', 983.4174757281553), ('Denisa', 419.1633466135458), ('Denise', 949.1239316239316), ('Denise Antonela', 1160.3125), ('Deniz', 551.5304659498208), ('Deria', 1123.6486486486488), ('Desirae', 863.7826086956521), ('Desiree', 1032.2666666666667), ('Despina', 665.686684073107), ('Despoina', 746.0962962962963), ('Destanee', 483.77464788732397), ('Dewi', 1154.2857142857142), ('Dhruthi', 615.1506849315068), ('Di', 736.1650485436893), ('Dia', 383.7832512315271), ('Diana', 654.3773657782928), ('Diana Maria', 1205.7692307692307), ('Dianne', 809.697247706422), ('Dijana', 669.2982456140351), ('Dilara', 1248.2), ('Dina', 1094.4583333333333), ('Dinah', 268.05945945945945), ('Doga Selen', 1234.6176470588234), ('Domenica', 803.8666666666667), ('Dominika', 171.71134020618555), ('Dominique', 1042.7843137254902), ('Donika', 1131.6333333333334), ('Donna', 223.50900900900902), ('Dorien', 1196.56), ('Doroteja', 520.9397993311037), ('Draginja', 913.7272727272727), ('Dunja', 929.0599369085173), ('Ebony', 1073.1752577319587), ('Eden', 1029.6888888888889), ('Edina', 211.67325428194994), ('Eduarda', 656.2851711026616), ('Eetee', 842.7045454545455), ('Ege', 1214.857142857143), ('Ekaterina', 471.8367290748899), ('Ekaterine', 553.9434782608696), ('Elaine', 1221.7931034482758), ('Eleanor', 1066.5343511450383), ('Elena', 324.3720930232558), ('Elena Gabriela', 392.44444444444446), ('Elena Teodora', 686.6470588235294), ('Eleni', 249.5244140625), ('Eleonora', 950.0277777777778), ('Eleonore', 1087.372340425532), ('Eliessa', 876.1730769230769), ('Elina', 421.6573033707865), ('Elisabeth', 888.2213114754098), ('Elise', 334.7118644067797), ('Elitsa', 418.39748953974896), ('Elixane', 579.5214723926381), ('Eliza', 978.2708333333334), ('Elizabeta', 1154.2714285714285), ('Elizabeth', 736.9747747747748), ('Elizabeth Anita Alexandria', 1006.2982456140351), ('Elizaveta', 489.5307517084282), ('Elizaveta Anna', 981.9814814814815), ('Elke', 1011.9433962264151), ('Ella', 1168.7967479674796), ('Ellen', 750.9460093896714), ('Ellie', 508.340206185567), ('Elodie', 1211.2333333333333), ('Elyne', 652.1984732824427), ('Ema', 819.3400503778338), ('Emelyn', 672.730407523511), ('Emi', 770.8472222222222), ('Emilia', 1232.0), ('Emiliana', 1022.9174311926605), ('Emilie', 705.4716981132076), ('Emilija', 1209.625), ('Emiliya', 1092.2771084337348), ('Emily', 585.093851132686), ('Emily J', 1041.948717948718), ('Emina', 682.0972222222222), ('Emma', 641.046992481203), ('Emma Christine', 1193.3529411764705), ('Emmanuelle', 943.7716535433071), ('En Pei', 1229.7333333333333), ('Ena', 980.3333333333334), ('Eri', 321.23595505617976), ('Erica', 788.0384615384615), ('Erika', 544.5041866028708), ('Erin', 942.7969696969697), ('Erina', 733.1351351351351), ('Esen', 1218.5652173913043), ('Estela', 966.0540540540541), ('Estelle', 617.4935251798561), ('Ester', 950.9090909090909), ('Estrella', 347.34943639291464), ('Etsuko', 781.3218390804598), ('Eudice Wong', 911.7241379310345), ('Eugenia', 1157.5), ('Eugenie', 477.62886597938143), ('Eugeniya', 620.6746411483253), ('Eva', 500.29483037156706), ('Eva Marie', 1083.8333333333333), ('Eveliina', 1023.8690476190476), ('Evelyn', 471.5439093484419), ('Evgenia', 414.66339869281046), ('Evgeniya', 442.0344827586207), ('Fang Ying', 612.0185185185185), ('Fangzhou', 406.9281767955801), ('Fanny', 569.1904761904761), ('Farah', 1106.3076923076924), ('Fatima', 673.7509157509157), ('Fatimah', 1070.9463414634147), ('Fatma', 648.2984054669704), ('Fatyha', 1015.5), ('Federica', 722.7286493034525), ('Federica Joe', 1204.7272727272727), ('Fernanda', 647.922077922078), ('Ferny', 1187.0384615384614), ('Fiona', 853.3908045977012), ('Flavia', 376.47888446215137), ('Florencia', 451.5810397553517), ('Frances', 999.2), ('Francesca', 570.534951862704), ('Francisca', 903.1666666666666), ('Francoise', 437.05298013245033), ('Franziska', 949.6575342465753), ('Frederikke', 1244.3333333333333), ('Freya', 544.1627906976744), ('Gabriela', 696.7697332607512), ('Gabriela Nicole', 994.0612244897959), ('Gabriella', 792.5), ('Gabrielle Faith', 985.7211538461538), ('Gaelle', 1052.8314606741574), ('Gaia', 759.5352697095435), ('Gail', 526.2644836272041), ('Galina', 305.19563522992985), ('Ganna', 606.7211740041929), ('Garbine', 229.3774193548387), ('Gebriela', 1152.142857142857), ('Genevieve', 772.2857142857143), ('Georgia', 533.5940594059406), ('Georgia Andreea', 763.1014492753624), ('Georgiana', 1153.9166666666667), ('Georgina', 396.225), ('Ghislaine', 1150.6607142857142), ('Giada', 813.1351351351351), ('Gioia', 567.8518518518518), ('Giorgia', 960.4941860465116), ('Giorgie', 1226.5), ('Giovanna', 1197.0), ('Giulia', 693.6215943491422), ('Giuliana', 584.359375), ('Gloria', 794.7118644067797), ('Gozal', 716.3150684931506), ('Grace', 454.06233062330625), ('Gracia', 783.8288043478261), ('Greetje', 547.277108433735), ('Greta', 296.8219584569733), ('Guadalupe', 797.383606557377), ('Guillermina', 1027.0), ('Guiomar', 957.9512195121952), ('Gulben', 1168.3396226415093), ('Gulchekhra', 1196.0), ('Gulnaz', 1236.6153846153845), ('Guzal', 995.4074074074074), ('Gyulnara', 1087.6216216216217), ('Habiba', 1051.623188405797), ('Hae Sung', 844.3856812933026), ('Haine', 1179.4153846153847), ('Hana', 1110.5376344086021), ('Hanna', 957.2), ('Hanyu', 543.968253968254), ('Hao Chen', 680.1050228310502), ('Hao Ching', 1153.936507936508), ('Harmony', 574.8723404255319), ('Harriet', 694.341935483871), ('Haruka', 774.6837606837607), ('Haruna', 512.1515151515151), ('Hayley', 914.5321100917431), ('Hazal', 1214.7692307692307), ('Heather', 167.50632911392404), ('Heidi', 417.44323483670297), ('Helen', 1019.4107142857143), ('Helene', 696.4752475247525), ('Hikari', 1095.1176470588234), ('Hilda', 673.6635071090047), ('Himari', 1219.0), ('Hiroko', 534.890243902439), ('Hirono', 860.8104265402843), ('Ho Ching', 925.9865771812081), ('Hollie', 1185.75), ('Hongrui', 914.8607594936709), ('Hortencia', 1251.1333333333334), ('Hsin Yuan', 1107.7142857142858), ('Hua Chen', 726.1737089201878), ('Huijie', 1118.904761904762), ('Hulya', 888.0055096418732), ('Hye Min', 1020.28125), ('Hyojung', 1069.3208955223881), ('Hyun Hui', 729.0671936758894), ('I Hsuan', 1038.6911764705883), ('Iana', 1085.581818181818), ('Ida', 962.5), ('Idia', 1232.2), ('Iga', 705.5625), ('Ilay', 1135.5), ('Ilka', 868.2191780821918), ('Ilona', 452.625), ('Ilze', 847.0941176470589), ('Imane Maelle', 845.375), ('Ina', 1165.5573770491803), ('Inci', 1069.0925925925926), ('India', 954.046875), ('Indire', 627.7027027027027), ('Indy', 485.9559748427673), ('Ineke', 919.6147540983607), ('Ines', 687.0229885057471), ('Inger', 1039.0), ('Ingrid', 766.2549019607843), ('Ingrid Alexandra', 869.3571428571429), ('Ingrid Esperanza', 748.6622691292876), ('Intissar', 1192.5454545454545), ('Ioana', 980.2232142857143), ('Ioana Diana', 482.43243243243245), ('Ioana Loredana', 646.0441176470588), ('Ionela Andreea', 799.0552486187845), ('Ipek', 655.7828348504552), ('Irena', 288.74423480083857), ('Irene', 579.2153846153847), ('Irina', 436.84339509862525), ('Irina Camelia', 285.84388185654007), ('Irina Maria', 578.1381578947369), ('Iris', 866.1075949367089), ('Iryna', 489.5294964028777), ('Isabel', 724.9178743961353), ('Isabela', 1114.99375), ('Isabella', 566.7873931623932), ('Isabelle', 781.6993464052288), ('Iulia Maria', 1170.9411764705883), ('Iva', 732.7386018237082), ('Ivana', 439.81414868105514), ('Ivania', 871.109375), ('Ivanka', 1079.05), ('Iveta', 117.95684523809524), ('Ivette', 1136.8535031847134), ('Ivone', 872.0), ('Ivonne', 591.3809523809524), ('Jacqueline', 624.6089494163424), ('Jada', 909.2), ('Jade', 739.04802259887), ('Jaeda', 760.4920634920635), ('Jaimee', 562.8450704225352), ('Jaimy Gayle', 1243.875), ('Jainy', 1037.5274725274726), ('Jamie', 402.36756756756756), ('Jamilya', 1247.3333333333333), ('Jan', 592.5990783410139), ('Jana', 406.6258503401361), ('Janette', 240.5306603773585), ('Janina', 699.7864583333334), ('Janja', 1262.5416666666667), ('Janneke', 861.5102040816327), ('Jaqueline Adina', 748.7238095238096), ('Jara', 1121.767857142857), ('Jarmila', 149.46360759493672), ('Jasmin', 633.027027027027), ('Jasmina', 642.1811989100818), ('Jasmine', 437.86915887850466), ('Jasmine Amber', 1117.64), ('Jawairiah', 1070.5648854961833), ('Jazmin', 1035.46), ('Jazzamay', 983.1290322580645), ('Jeannine', 767.7730496453901), ('Jelena', 348.19338235294117), ('Jennifer', 556.7936681222708), ('Jenny', 902.1470588235294), ('Jesika', 501.5860215053763), ('Jessica', 655.7464059804486), ('Jessika', 818.2043795620438), ('Jessy', 967.6708860759494), ('Ji Hee', 823.9789029535865), ('Ji Young', 833.5061082024433), ('Jia', 1169.6923076923076), ('Jia Jing', 682.961038961039), ('Jia Qi', 529.7777777777778), ('Jiahui', 794.4931506849315), ('Jiakang', 1230.6), ('Jiatian', 1232.032258064516), ('Jiaxi', 578.5), ('Jiaxue', 1161.0), ('Jie', 114.05571428571429), ('Jil Belen', 501.0619469026549), ('Jil Nora', 1116.4190476190477), ('Jill', 121.9579326923077), ('Jillian', 721.14), ('Jin', 1267.0), ('Jin A', 492.8915187376726), ('Jin Ju', 1035.6470588235295), ('Jing Jing', 369.1620469083156), ('Joana', 863.3225806451613), ('Joanna', 931.025641025641), ('Joanne', 1227.8), ('Jodie Anna', 925.4230769230769), ('Johana', 1111.8333333333333), ('Johanna', 310.3405299313052), ('Jordana', 1022.6198347107438), ('Josepha', 924.9325842696629), ('Josephine', 684.4892086330935), ('Josie', 993.2105263157895), ('Jovana', 601.9846625766871), ('Ju Eun', 812.6), ('Judith', 1224.0), ('Jule', 1243.904761904762), ('Julia', 576.9173467252564), ('Julia Mansano', 1024.6666666666667), ('Juliana', 1110.0816326530612), ('Juliana Rocha', 1175.7666666666667), ('Julie', 512.3787128712871), ('Julieta Lara', 707.1467889908257), ('Julita', 1019.9411764705883), ('Julyette Maria Josephine', 732.1666666666666), ('June', 1189.0), ('Junri', 262.30884808013354), ('Justina', 1212.9166666666667), ('Justine', 521.5358361774744), ('Justyna', 585.8517745302714), ('Kady', 1055.020202020202), ('Kai Chen', 272.08855291576674), ('Kai Lin', 522.6561403508772), ('Kaia', 127.06775067750678), ('Kaitlin', 901.3333333333334), ('Kaitlyn', 756.2549019607843), ('Kaja', 633.5454545454545), ('Kajsa', 661.9589041095891), ('Kamila', 568.2547169811321), ('Kamilla', 1162.8301886792453), ('Kamonwan', 765.1395348837209), ('Kana', 924.2782608695652), ('Kanae', 635.346516007533), ('Kanako', 1105.3125), ('Kanami', 799.9940828402367), ('Kanika', 962.8536585365854), ('Kaori', 871.0790513833992), ('Karen', 674.9672514619883), ('Kariann', 1068.9166666666667), ('Karin', 472.338003502627), ('Karina', 883.6090909090909), ('Karina Ildor', 696.9606060606061), ('Karina Kristina', 1062.795918367347), ('Karine', 868.8904109589041), ('Karis', 1001.0679611650486), ('Karla', 807.616), ('Karman', 652.917808219178), ('Karola Patricia', 928.3333333333334), ('Karolayne', 1077.8095238095239), ('Karolina', 586.9412296564195), ('Karoline', 873.6229508196722), ('Karyn', 903.5769230769231), ('Kassandra', 927.0350877192982), ('Katalin', 331.93949394939494), ('Katarina', 401.0998263888889), ('Katarzyna', 459.29286608260327), ('Kate', 1117.7142857142858), ('Katerina', 491.8507295173962), ('Kateryna', 294.33209990749305), ('Katharina', 680.677700348432), ('Katharine', 882.1071428571429), ('Katherine', 836.6804511278195), ('Katherine Gabriela', 910.396694214876), ('Kathinka', 415.7), ('Kathrin', 291.4792817679558), ('Katie', 620.9404580152672), ('Katrine Isabel', 1111.08), ('Katy', 492.6608695652174), ('Katya', 1050.7), ('Katyarina', 1010.1818181818181), ('Kayla', 583.1686746987951), ('Kaylah', 1163.3478260869565), ('Kazusa', 772.2402912621359), ('Kei', 1003.1212121212121), ('Kelia', 1114.9433962264152), ('Kelly', 804.873831775701), ('Kelly S', 312.7584269662921), ('Kelsey', 1012.325), ('Kennedy', 807.7222222222222), ('Keren', 643.422641509434), ('Keri', 1018.6534653465346), ('Kerstin', 1020.4271844660194), ('Khristina', 978.0229885057471), ('Ki Ryang', 1164.090909090909), ('Kiki', 287.71625344352617), ('Kim', 687.3120567375887), ('Kim Alice', 762.4081632653061), ('Kimberley', 846.9154228855722), ('Kimberly', 618.6923076923077), ('Kimika', 1097.219512195122), ('Kimiko', 95.03465982028241), ('Kinnie', 606.1467576791808), ('Kirsten', 308.64912280701753), ('Kirsten Andrea', 1035.0384615384614), ('Klaartje', 576.9), ('Klara', 235.31431431431432), ('Klaudia', 780.7905027932961), ('Komola', 826.0238095238095), ('Korina', 567.0507399577167), ('Kotomi', 844.7460317460317), ('Krista', 522.984693877551), ('Kristie', 445.18918918918916), ('Kristina', 343.25546975546973), ('Kristina N', 1060.5633802816901), ('Kristy', 837.7730496453901), ('Kristyna', 443.8467908902692), ('Ksenia', 482.36648501362396), ('Kseniia', 990.6), ('Ksenija', 975.6271186440678), ('Kumiko', 488.76107382550333), ('Kurumi', 165.96132596685084), ('Kveta', 159.62397820163488), ('Kwan Yau', 1070.0377358490566), ('Kyle', 887.502487562189), ('Kylie', 798.3181818181819), ('Kyoka', 348.54794520547944), ('Kyra', 443.76148409893995), ('Kyung Mi', 533.433770014556), ('Laetitia', 677.4458598726114), ('Laili', 996.8148148148148), ('Lamis', 1062.3666666666666), ('Lara', 643.6939163498099), ('Larikah', 1054.9019607843138), ('Laura', 504.4145867098865), ('Laura D', 910.5714285714286), ('Laura Ioana', 516.1982942430703), ('Laura Sofia', 1198.1538461538462), ('Lauren', 484.9442231075697), ('Lauryn', 1107.0882352941176), ('Lavinia', 612.736), ('Laylo', 1226.076923076923), ('Layne', 1184.0), ('Lea', 858.4107142857143), ('Leah', 1179.6216216216217), ('Lee', 908.156862745098), ('Lena', 594.9436936936937), ('Lena Marie', 657.8934169278997), ('Lenka', 451.33577981651376), ('Leolia', 773.5666666666667), ('Leonie', 825.972972972973), ('Lesedi Sheya', 887.4545454545455), ('Lesia', 205.17590361445784), ('Lesley', 514.7174515235457), ('Leslie', 1180.5454545454545), ('Leticia', 481.3229166666667), ('Leticia Garcia', 1072.4), ('Leylah Annie', 1030.5), ('Li', 988.7425149700599), ('Liana Gabriela', 387.87113402061857), ('Libby', 899.9150326797386), ('Libi', 1035.327868852459), ('Lidia', 1147.8529411764705), ('Lidziya', 797.2128378378378), ('Liezel', 284.8326771653543), ('Liga', 567.9464544138929), ('Lilla', 722.5087719298245), ('Lin', 497.42124542124543), ('Lina', 574.9808362369338), ('Linda', 929.4398496240601), ('Lindsay', 275.6055900621118), ('Lindsey', 986.82), ('Ling', 418.81925343811395), ('Liniques', 1184.7222222222222), ('Linnea', 959.6981132075472), ('Lisa', 356.0105210420842), ('Lisa Maria', 758.06), ('Lisa Marie', 996.0408163265306), ('Lisanne', 673.6507936507936), ('Liubov', 887.2875), ('Livia', 1179.875), ('Liz Tatiane', 870.9007633587786), ('Lizaveta', 1120.5652173913043), ('Lizette', 666.1496062992126), ('Lorenza', 1231.2727272727273), ('Lorraine M', 972.75), ('Lou', 680.1724137931035), ('Loudmilla', 1220.0), ('Louisa', 380.5308641975309), ('Louise', 1070.1025641025642), ('Lourdes', 188.06095041322314), ('Lu', 907.3557312252965), ('Luca', 859.8644067796611), ('Lucia', 845.740638002774), ('Luciana', 885.7495107632094), ('Lucie', 322.62611607142856), ('Lucrezia', 845.986301369863), ('Lucy', 756.3141592920354), ('Ludmila', 846.2727272727273), ('Ludmilla', 787.5416666666666), ('Luisa', 981.7517730496454), ('Luisa Marie', 820.59375), ('Luksika', 284.22813688212926), ('Lulu', 1098.2888888888888), ('Luna', 1139.0), ('Lusine', 974.2702702702703), ('Lutfiye', 1190.0629921259842), ('Lyann', 982.6666666666666), ('Lynn', 952.4411764705883), ('Lyudmyla', 382.82479784366575), ('Macall', 607.3360995850622), ('Macarena', 692.1515151515151), ('Madalina', 324.63613231552165), ('Maddison', 748.0), ('Madeleine', 1028.0365853658536), ('Madeline', 1217.469387755102), ('Madina', 1203.5), ('Madison', 290.64452214452217), ('Madrie', 958.0955414012739), ('Maegan', 787.0), ('Mafalda', 1139.7), ('Maftuna', 1173.75), ('Magali', 734.0), ('Magalie', 1036.1214953271028), ('Magda', 300.3974358974359), ('Magdalena', 443.6296006264683), ('Magy', 1092.7621951219512), ('Mahak', 875.0), ('Mahitha', 1007.15), ('Mai', 687.25), ('Maia', 745.433962264151), ('Maia A', 1206.6666666666667), ('Maiko', 438.4245810055866), ('Maileen', 1152.888888888889), ('Mailen', 410.8463541666667), ('Maja', 896.7413793103449), ('Makiho', 784.8009049773756), ('Makoto', 516.6615384615385), ('Malene', 999.15625), ('Malika', 1004.7428571428571), ('Malin', 825.039603960396), ('Mallaurie', 1031.5342465753424), ('Mallory', 143.48235294117646), ('Malou', 947.3333333333334), ('Mami', 1153.590909090909), ('Man Ying Maggie', 1202.2692307692307), ('Mana', 689.891129032258), ('Mananchaya', 1230.6), ('Manca', 838.1780821917808), ('Mandy', 361.0), ('Manisha', 897.0974358974358), ('Manon', 622.7673469387755), ('Manya', 1181.3548387096773), ('Mara', 908.3962264150944), ('Marcela', 774.64), ('Marcela Guimaraes', 1143.7957746478874), ('Marcelina', 1247.3636363636363), ('Marcella', 657.0171919770773), ('Margalita', 325.5912596401028), ('Margarida', 987.6739130434783), ('Margarita', 611.4060995184591), ('Margaux', 1051.1224489795918), ('Margot', 753.8346456692914), ('Mari', 526.3698630136986), ('Maria', 426.6002565198803), ('Maria Agustina', 1190.0833333333333), ('Maria Andrea', 1072.9591836734694), ('Maria Camila', 1188.5277777777778), ('Maria Constanza De Las Mercedes', 861.5050505050505), ('Maria Del Rosario', 1119.4897959183672), ('Maria Elena', 194.2392065344224), ('Maria Fernanda', 443.0228531855956), ('Maria Jesus', 1170.1830985915492), ('Maria Joao', 486.6092544987147), ('Maria Jose', 306.1794310722101), ('Maria Lourdes', 918.0769230769231), ('Maria Paulina', 1047.98224852071), ('Maria Teresa', 359.81081081081084), ('Mariam', 662.1182795698925), ('Mariana', 556.0428051001821), ('Marianna', 730.3831168831168), ('Marianne', 993.175925925926), ('Mariaryeni', 1085.4242424242425), ('Marie', 695.574074074074), ('Marie Eve', 300.56296296296296), ('Mariia', 1148.9166666666667), ('Marija', 544.2636655948553), ('Marijana', 1215.0), ('Marina', 532.6881807180315), ('Marine', 774.5654761904761), ('Marion', 279.78655282817505), ('Mariona', 1163.0), ('Marisa', 1067.3413173652696), ('Mariya', 281.871335504886), ('Marketa', 353.44444444444446), ('Marlies', 946.8934426229508), ('Marrit', 783.1711711711712), ('Marta', 419.32988047808766), ('Marta Huqi', 851.1224489795918), ('Martha', 1056.0588235294117), ('Martina', 751.8679119412942), ('Mary', 869.1666666666666), ('Mary Ann', 1188.7096774193549), ('Maryna', 323.86176470588236), ('Masa', 355.7223168654174), ('Mathilde', 437.11396648044695), ('Matilda', 799.1875), ('Maud', 1013.4761904761905), ('Maureen', 1070.21875), ('Maurien', 1121.0869565217392), ('Maxine', 973.8717948717949), ('May', 1084.0294117647059), ('Maya', 732.4260679079956), ('Mayar', 891.6309523809524), ('Mayo', 407.029702970297), ('Mayya', 619.9064748201439), ('Megan', 736.4809523809524), ('Megumi', 1025.0), ('Mei Xu', 1031.6), ('Meiling', 812.85), ('Meiqi', 1029.1666666666667), ('Melanie', 372.32502965599053), ('Melany Solange', 1039.8333333333333), ('Melina', 1017.2560553633218), ('Melinda', 169.13578500707214), ('Melis', 634.7950310559006), ('Melisa', 993.1351351351351), ('Melissa', 1154.093023255814), ('Melissa Ishuan', 1104.357142857143), ('Meng Ning', 1035.95), ('Mercedes', 1213.2142857142858), ('Merel', 900.75), ('Meritxell', 1182.9107142857142), ('Mervana', 337.5292682926829), ('Mi', 554.3953934740883), ('Mi Jeong', 1071.3076923076924), ('Mi Rae', 992.7225433526012), ('Mi Zhuoma', 999.375), ('Mia Nicole', 987.504761904762), ('Micaela', 1332.0737704918033), ('Michaela', 676.90589198036), ('Michaella', 185.3469387755102), ('Michela', 1228.9285714285713), ('Michele Alexandra', 946.8846153846154), ('Michelle', 280.79959100204496), ('Michika', 718.047619047619), ('Mihaela', 376.7356115107914), ('Mihaela Lorena', 1223.4), ('Miharu', 523.2788844621514), ('Mihika', 1064.142857142857), ('Mihoki', 1110.4411764705883), ('Miki', 586.2250489236791), ('Mila', 1201.16), ('Milagros', 1234.2857142857142), ('Milana', 626.441935483871), ('Milena', 1114.4074074074074), ('Milica', 1221.904761904762), ('Min', 866.0693069306931), ('Min Hwa', 819.8425531914894), ('Minami', 1238.0625), ('Mira', 788.2622950819672), ('Mirabelle', 721.1643835616438), ('Miranda', 1169.4864864864865), ('Miriam', 912.120218579235), ('Miriam Bianca', 628.075), ('Miriana', 950.6263736263736), ('Mirjam', 843.6428571428571), ('Mirjana', 186.76587795765877), ('Misa', 617.0379241516966), ('Misaki', 208.95263157894738), ('Mitsumi', 1121.04), ('Miyabi', 447.93283582089555), ('Miyu', 594.9036697247707), ('Mizuno', 593.1506849315068), ('Molly', 1029.0), ('Momoko', 772.6981132075472), ('Mona', 273.57517899761336), ('Monica', 210.0846394984326), ('Monika', 980.575), ('Monique', 462.4270462633452), ('Montserrat', 541.952380952381), ('Morgane', 880.6527777777778), ('Moulika', 1243.4), ('Mouna', 1258.5), ('Moyuka', 1198.25), ('Muazzez', 1227.0), ('Muge', 1186.9444444444443), ('Myrtille', 485.40168539325845), ('Na', 82.13112391930835), ('Na Lae', 608.7791798107255), ('Na Ri', 573.5197368421053), ('Nadezda', 868.6521739130435), ('Nadia', 407.5463976945245), ('Nadiya', 637.4607407407408), ('Nadja', 631.8181818181819), ('Nagi', 828.0675675675676), ('Naiktha', 767.4963503649635), ('Naima', 930.7027027027027), ('Nam Yeon', 878.6666666666666), ('Nan Nan', 890.4455445544554), ('Nanuli', 542.7168141592921), ('Nao', 313.45625), ('Naoko', 1180.3828125), ('Naomi', 483.97225572979494), ('Napatsakorn', 929.4388489208633), ('Nastassia', 1138.9166666666667), ('Nastassja', 554.5290322580645), ('Nastja', 593.1772853185596), ('Natalia', 720.132932166302), ('Natalie', 577.9677419354839), ('Natalija', 634.3620689655172), ('Nataliya', 1247.909090909091), ('Natasa', 666.2853403141361), ('Natasha', 883.0777142857143), ('Natela', 566.4943396226415), ('Natella', 962.0188679245283), ('Nathalia', 543.031185031185), ('Nathaly', 617.4615384615385), ('Natia', 929.6928104575163), ('Natsumi', 547.7037037037037), ('Nattawadee', 1177.622641509434), ('Naz', 1087.3823529411766), ('Nazari', 825.7291666666666), ('Neda', 745.421052631579), ('Nelise', 1164.107142857143), ('Nermeen', 1069.15), ('Nevena', 1031.0), ('Nicha', 515.3191489361702), ('Nicky', 843.9007633587786), ('Nicola', 753.2253164556962), ('Nicole', 499.4127634660422), ('Nicoleta Catalina', 485.46875), ('Nicolette', 778.1648648648649), ('Nidhi', 762.1578947368421), ('Nigina', 376.7617554858934), ('Nika', 913.4380165289256), ('Nikita', 1174.0), ('Nikki', 1017.3134328358209), ('Nikol', 1054.0813953488373), ('Nikola', 723.484076433121), ('Nina', 528.8673050615595), ('Nina Isabella', 1124.1666666666667), ('Nives', 841.0514705882352), ('Noel', 965.5343511450382), ('Noelia', 1049.834745762712), ('Noelle', 883.7787610619469), ('Nonna', 1167.2758620689656), ('Noppawan', 374.93926247288505), ('Nora', 921.6216216216217), ('Nour', 1096.1140350877192), ('Nozomi', 936.3392857142857), ('Nudnida', 436.66881028938906), ('Nungnadda', 537.577922077922), ('Nuria', 395.6680227827502), ('Oana', 1027.1382978723404), ('Oana Georgeta', 686.3047619047619), ('Oceane', 728.7630208333334), ('Ofri', 839.4923664122138), ('Oksana', 533.9652351738241), ('Ola', 660.8924731182796), ('Olawaseun', 1397.5), ('Olaya', 1112.75), ('Oleksandra', 903.4289156626506), ('Olena', 1179.1555555555556), ('Olesya', 501.44444444444446), ('Olga', 432.6511627906977), ('Olivia', 446.7231833910035), ('Oliwia', 1006.5128205128206), ('Ons', 435.1470588235294), ('Ornella', 978.7321428571429), ('Oyku', 866.0454545454545), ('Paige Mary', 1156.28125), ('Pamela', 989.1904761904761), ('Panna', 683.1081081081081), ('Paola', 132.12638580931264), ('Parris', 1099.625), ('Patcharin', 863.5507246376811), ('Patricia', 572.8059701492538), ('Patricia Maria', 403.935), ('Patrycja', 657.3816155988858), ('Patty', 385.8135593220339), ('Paula', 558.0162601626016), ('Paula Andrea', 1175.909090909091), ('Paula Catalina', 868.7624113475177), ('Paula Cristina', 508.4679802955665), ('Paulina', 1035.7780678851175), ('Pauline', 298.1861898890259), ('Pavla', 915.5892857142857), ('Peangtarn', 514.586319218241), ('Peggy', 755.5813953488372), ('Pei Chi', 673.9809523809524), ('Pei Hsuan', 1106.5), ('Pei Ju', 1061.3076923076924), ('Pemra', 465.24962852897477), ('Pernilla', 619.4154929577464), ('Petia', 710.3972602739726), ('Petra', 365.50280484204313), ('Phenomena', 1211.0), ('Phillis', 826.6486486486486), ('Pia', 737.862676056338), ('Piia', 668.2581196581197), ('Pilar', 740.5879828326181), ('Pippa', 1041.0740740740741), ('Plobrung', 937.7945205479452), ('Polina', 630.7953529937444), ('Polona', 478.30369515011546), ('Poojashree', 729.1047904191616), ('Pranjala', 795.4736842105264), ('Prarthana G', 653.5070422535211), ('Prerna', 740.5361842105264), ('Priscila', 1137.19), ('Priscilla', 675.4124293785311), ('Qiang', 383.4714587737844), ('Qianhui', 826.1388888888889), ('Qianqian', 943.421052631579), ('Qiu Yu', 705.8493150684932), ('Quinn', 883.2352941176471), ('Quirine', 633.9770491803279), ('Rachael', 859.2706766917294), ('Rachel', 1147.8526315789475), ('Radina', 955.7833333333333), ('Rafaela', 1121.2432432432433), ('Ralina', 1176.5), ('Raluca', 304.4619771863118), ('Raluca Elena', 672.2258064516129), ('Raluca Georgiana', 539.6164383561644), ('Ramu', 1010.4545454545455), ('Ramya', 1121.8846153846155), ('Ran', 598.2655172413793), ('Rana', 1117.6666666666667), ('Raquel', 700.7644444444444), ('Rashmi', 1089.2100840336134), ('Ratnika', 1021.6504854368932), ('Raveena', 487.6268656716418), ('Rebeca', 1145.4333333333334), ('Rebecca', 568.3374316939891), ('Rebeka', 676.1090909090909), ('Regina', 289.60283687943263), ('Reina', 1019.0), ('Reka Luca', 323.1388101983003), ('Remi', 494.6111111111111), ('Renata', 274.85317919075146), ('Ria', 669.448275862069), ('Rianna', 638.6666666666666), ('Richel', 246.19871794871796), ('Rika', 290.0614657210402), ('Riko', 495.22641509433964), ('Rio', 1125.0363636363636), ('Risa', 489.65909090909093), ('Rishika', 775.7269624573379), ('Rita', 1051.7349397590363), ('Riya', 651.4246575342465), ('Roberta', 150.96681415929203), ('Robin', 431.19607843137254), ('Robyn', 1054.606896551724), ('Rocio', 795.6201232032854), ('Romana', 402.49931972789113), ('Romana Caroline', 669.8542372881356), ('Romina', 283.63246554364474), ('Romy', 758.1714285714286), ('Rona', 1125.5471698113208), ('Ronit', 427.0), ('Ronke', 1072.857142857143), ('Roosh', 1168.2857142857142), ('Rosa', 965.0), ('Rosalia', 1059.73), ('Rosalie', 1066.5887096774193), ('Rosie', 984.1714285714286), ('Roxane', 479.51738241308794), ('Rui', 1209.625), ('Rushmi', 573.8729603729604), ('Rutuja', 808.5096774193548), ('Ryann', 1069.0379746835442), ('Saana', 1117.88), ('Sabastiani', 982.7397260273973), ('Sabina', 682.2005532503458), ('Sabina Elena', 1184.6666666666667), ('Sabine', 203.5871080139373), ('Sabrina', 905.6324786324786), ('Sacha', 340.2890442890443), ('Sachia', 400.8093385214008), ('Sachie', 368.26881720430106), ('Sadafmoh', 665.8219178082192), ('Sai Samhitha', 998.5238095238095), ('Saisai', 297.39032258064515), ('Sakiko', 832.9585365853659), ('Sally', 529.583908045977), ('Salma', 1204.6666666666667), ('Samantha', 406.21702404158543), ('Samira', 932.8940397350993), ('Sanae', 1105.171875), ('Sanaz', 703.1372549019608), ('Sandra', 563.964505613908), ('Sandy', 1028.9565217391305), ('Sang Hee', 857.9508196721312), ('Sania', 177.22695035460993), ('Sara', 509.80945757997216), ('Sarah', 546.5551763367463), ('Sarah Beth', 875.9277108433735), ('Sarah Rebecca', 743.6062176165804), ('Sarahi', 1139.2340425531916), ('Sarai Delfina', 1191.6470588235295), ('Saray', 840.0776699029126), ('Sari', 1081.1666666666667), ('Sarlota', 1209.7777777777778), ('Sarvinoz', 1235.1960784313726), ('Sasa', 1033.027027027027), ('Saska', 747.3695652173913), ('Satsuki', 888.7272727272727), ('Savannah', 1142.9285714285713), ('Schena', 1188.2941176470588), ('Se Hyun', 1210.2571428571428), ('Se Jin', 1122.4545454545455), ('Sean', 1240.92), ('Seda', 1003.5367647058823), ('Seira', 1115.72), ('Selin', 1168.6571428571428), ('Seo Kyung', 858.9173789173789), ('Seone', 889.8028169014085), ('Serena', 14.654294803817603), ('Sesil', 162.3505747126437), ('Seung Yeon', 784.0465949820789), ('Severine', 218.4701086956522), ('Shahar', 166.41358024691357), ('Shakhlo', 924.8818897637796), ('Shakhnoza', 1236.7627118644068), ('Shangqing', 1228.3235294117646), ('Shanshan', 694.2), ('Shao Yuan', 967.9034090909091), ('Sharmada', 851.5633802816901), ('Sharon', 296.5792682926829), ('Sharon Sanchana', 1097.0), ('Shelby', 372.89398280802294), ('Shelly', 1171.0), ('Sheng Nan', 451.8657487091222), ('Sherazad', 649.5154639175257), ('Sherry', 1024.0116279069769), ('Shiho', 500.688679245283), ('Shilin', 632.2824427480916), ('Shiori', 1070.6666666666667), ('Shir', 1154.4166666666667), ('Shiran', 1187.9245283018868), ('Shivika', 935.2322946175638), ('Shou Na', 1120.388888888889), ('Shreya', 1148.0), ('Shu Ying', 1042.6802325581396), ('Shuai', 167.90740740740742), ('Shuko', 421.44179894179894), ('Shuo', 864.1538461538462), ('Shuyue', 966.0588235294117), ('Shweta', 897.6951219512196), ('Si Qi', 1047.7575757575758), ('Silvia', 565.8211508553654), ('Simona', 542.2382851445662), ('Simone', 1070.3417721518988), ('Simran Kaur', 974.8), ('Sina', 728.7443609022556), ('Sinead', 975.3484848484849), ('Sing Le', 1141.842105263158), ('Siqi', 980.9076923076923), ('Sirui', 949.7916666666666), ('Siyu', 1241.1379310344828), ('Sloane', 259.63589743589745), ('Smriti', 1184.8260869565217), ('Sneha', 1225.388888888889), ('Snehadevi S', 632.3150684931506), ('So Jung', 514.1732026143791), ('So Ra', 572.2654545454545), ('Sofia', 526.3535641547861), ('Sofico', 1084.107142857143), ('Sofie', 724.5), ('Sofiya', 541.1570881226054), ('Sofya', 640.8727272727273), ('Sohyun', 1004.6666666666666), ('Sonia', 1029.0980392156862), ('Sonja', 885.0976744186047), ('Sophia', 1221.3333333333333), ('Sophie', 600.6881091617934), ('Sorana', 213.75043630017453), ('Sowjanya', 813.1357142857142), ('Spurti', 1149.3125), ('Sri Vaishnavi', 792.1927710843373), ('Stamatia', 841.8387096774194), ('Stanislava', 312.54158964879855), ('Stefana', 993.4255319148937), ('Stefani', 1167.3333333333333), ('Stefania', 759.2894995093228), ('Stefanie', 387.73412112259973), ('Steffi', 939.746835443038), ('Stephanie', 439.87772357723577), ('Stephanie Mariel', 1035.5548387096774), ('Storm', 573.6708333333333), ('Su Jeong', 426.3886462882096), ('Su Wei', 217.2493188010899), ('Suellen', 911.7619047619048), ('Sultan', 944.2432432432432), ('Sun Jung', 812.4581005586592), ('Sunae', 1229.8), ('Sunam', 611.0757575757576), ('Sung Hee', 635.7449168207024), ('Susan', 1015.6792452830189), ('Susanne', 417.8053097345133), ('Suzan', 982.7222222222222), ('Suzuho', 980.6666666666666), ('Suzy', 698.7567567567568), ('Svenja', 844.203007518797), ('Svetlana', 267.03227571115974), ('Sviatlana', 691.9934640522875), ('Sybille', 1002.6792452830189), ('Sylvia', 869.1702127659574), ('Sylwia', 787.7645348837209), ('Syna', 791.1240506329113), ('Szabina', 772.3186813186813), ('Tadeja', 343.0985324947589), ('Taisiya', 969.6588235294117), ('Talya', 1230.2), ('Tamachan', 949.8059701492538), ('Tamar', 1118.4166666666667), ('Tamara', 614.0434782608696), ('Tamari', 1146.3934426229507), ('Tamarine', 121.82273948075202), ('Tamaryn', 386.7025316455696), ('Tamira', 135.88910505836577), ('Tammi', 601.906914893617), ('Tanaporn', 1113.2325581395348), ('Tanya', 1023.089430894309), ('Tara', 475.2979683972912), ('Tatia', 1075.0), ('Tatiana', 681.9417582417583), ('Tatjana', 247.7449768160742), ('Tatsiana', 912.1077844311377), ('Tayisiya', 747.3172413793103), ('Taylor', 387.5662100456621), ('Tea', 1068.7457627118645), ('Teliana', 461.06702898550725), ('Tena', 614.9346733668342), ('Teodora', 489.27513227513225), ('Tereza', 557.241418764302), ('Terri', 963.5), ('Tess', 696.2878787878788), ('Tessah', 390.2361111111111), ('Tetiana', 437.4119658119658), ('Tetyana', 398.83478260869566), ('Thai Sa Grana', 802.7222222222222), ('Theo', 650.1206896551724), ('Theresa', 1159.5632183908046), ('Tijana', 1017.7777777777778), ('Timea', 182.02426160337552), ('Tina', 425.82394366197184), ('Tinatin', 810.6666666666666), ('Ting Fei', 739.7727272727273), ('Ting Jr', 789.6113989637306), ('Tingting', 1015.2352941176471), ('Tjasa', 743.1953125), ('Tomoko', 838.8065217391304), ('Tori', 841.7167381974249), ('Tornado Alicia', 878.1666666666666), ('Trang', 1029.3196721311476), ('Treta', 1009.8666666666667), ('Tsvetana', 131.02074074074073), ('Tyra', 992.4870588235294), ('Ulrikke', 506.39344262295083), ('Ulyana', 844.0692307692308), ('Urszula', 229.35687022900763), ('Ushna', 1132.4109589041095), ('Usue Maitane', 411.5068493150685), ('Valentina', 921.3333333333334), ('Valentine', 751.2668918918919), ('Valentini', 479.8914728682171), ('Valentyna', 368.14331210191085), ('Valeria', 661.8474576271186), ('Valerie', 806.2648401826484), ('Valeriya', 799.8668224299065), ('Vanda', 696.4126984126984), ('Vanesa', 579.437984496124), ('Vanessa', 398.3106546854942), ('Vania', 185.75), ('Vaniya', 1130.6037735849056), ('Vanja', 1089.7111111111112), ('Varatchaya', 450.4642082429501), ('Varunya', 894.3846153846154), ('Varvara', 382.6888217522659), ('Vasilisa', 613.5330490405117), ('Vaszilisza', 859.8103448275862), ('Vendula', 729.0117647058823), ('Venus', 32.984862819299906), ('Vera', 195.66923570969814), ('Verena', 958.1327800829876), ('Veronica', 726.1852387843704), ('Veronica M', 951.0075757575758), ('Veronika', 734.6018957345972), ('Vesna', 240.0448979591837), ('Vicky', 1252.9130434782608), ('Victoire', 1138.8490566037735), ('Victoria', 444.9760935910478), ('Victoria Ariadna', 1236.0), ('Viktoria', 566.9148936170212), ('Viktoriia', 1236.5333333333333), ('Viktorija', 507.4), ('Viktoriya', 736.2288557213931), ('Viktoryia', 966.4671052631579), ('Vilma Y', 1243.0), ('Vincenza', 1214.1142857142856), ('Vinciane', 1150.0), ('Violetta', 1170.840579710145), ('Virginie', 355.88102893890675), ('Vishesh', 1208.952380952381), ('Vita', 1201.25), ('Vitalia', 296.2025641025641), ('Vivian', 670.9108527131783), ('Vivien', 607.2810218978102), ('Vivienne', 659.2103004291846), ('Vlada', 595.3291666666667), ('Vladica', 943.5432098765432), ('Vladimira', 823.8770833333333), ('Vladislava', 1006.1769911504425), ('Vladyslava', 856.0782608695653), ('Vojislava', 555.6572164948453), ('Voni', 999.0215053763441), ('Wan Ting', 701.4009009009009), ('Wan Yi', 1081.142857142857), ('Warona', 1249.3333333333333), ('Wen Hsin', 440.35214446952597), ('Wen Ling', 1117.55), ('Wendy Qi Wen', 1011.469696969697), ('Weronika Jasmina', 1152.7837837837837), ('Whitney', 886.1407407407407), ('Wiktoria', 1083.1454545454546), ('Wing Yau Venise', 585.2589641434263), ('Wushuang', 937.7878787878788), ('Xenia', 661.2222222222222), ('Xi Yao', 714.8653846153846), ('Xiao', 814.4171122994652), ('Xiaodi', 467.24657534246575), ('Xiaorong', 848.4418604651163), ('Xiaoxi', 737.7547169811321), ('Ximena', 712.2780373831775), ('Xin', 694.4808743169399), ('Xin Yu', 1022.3333333333334), ('Xinyu', 480.646017699115), ('Xinyun', 309.35767790262173), ('Xiyu', 954.6), ('Xu Liu', 488.7671232876712), ('Ya', 1225.75), ('Ya Hsuan', 586.865), ('Yafan', 325.6162790697674), ('Yan', 768.560975609756), ('Yana', 740.0214504596527), ('Yang', 1177.8823529411766), ('Yanina', 381.2581602373887), ('Yanni', 1059.2702702702702), ('Yarden', 1166.875), ('Yaroslava', 211.41240310077518), ('Yasmin', 702.1784386617101), ('Yasmina', 1227.7777777777778), ('Yasmine', 983.0410958904109), ('Yasmyn', 1261.8181818181818), ('Yawna', 1110.4594594594594), ('Yayuk', 114.78806907378336), ('Ye Ra', 431.3144424131627), ('Ye Xin', 1048.081081081081), ('Yekaterina', 1155.8191489361702), ('Yelena', 897.4873949579832), ('Yeong Won', 973.8617021276596), ('Yevgeniya', 724.8712871287129), ('Yi', 791.0756207674943), ('Yi Fan', 381.5512572533849), ('Yi Jing', 656.8787276341948), ('Yi Miao', 418.2566137566138), ('Yidi', 1185.030303030303), ('Yihong', 1209.625), ('Yijia', 1063.9411764705883), ('Ying', 661.3972602739726), ('Ying Ying', 403.8775981524249), ('Yixuan', 801.6712328767123), ('Ylena', 892.3561643835617), ('Ylona Georgiana', 642.9487179487179), ('Yoko', 1128.901098901099), ('Yolande', 1068.4619883040937), ('Yoo Ri', 1263.7666666666667), ('Yoon Young', 844.9310344827586), ('Yoshimi', 1096.9130434782608), ('Yosr', 1222.24), ('You Na', 1170.3461538461538), ('Ysaline', 458.86633663366337), ('Yu Jin', 1098.357142857143), ('Yu Tong', 1239.6666666666667), ('Yuan', 1054.0), ('Yuanyi', 891.2340425531914), ('Yue', 983.359649122807), ('Yue Yue', 444.96190476190475), ('Yuenu', 961.876923076923), ('Yujia', 1034.1304347826087), ('Yuka', 748.8250591016548), ('Yukako', 1071.5833333333333), ('Yuki', 876.7428571428571), ('Yuki Kristina', 698.8285714285714), ('Yukina', 857.1692307692308), ('Yukun', 824.3936170212766), ('Yulia', 485.35135135135135), ('Yuliana', 725.5322195704057), ('Yuliya', 384.87776983559684), ('Yumi', 799.1332586786115), ('Yung Jan', 166.6586270871985), ('Yuqi', 1047.3529411764705), ('Yurika', 322.17758620689654), ('Yuriko', 1041.5367231638418), ('Yurina', 746.4803493449782), ('Yuuki', 608.1309090909091), ('Yuval', 1230.2), ('Yuxuan', 545.449074074074), ('Yvonne', 318.2867132867133), ('Zaineb', 1227.344827586207), ('Zalina', 867.5288461538462), ('Zarah', 709.625), ('Zarina', 222.81428571428572), ('Zeel', 791.2352941176471), ('Zeynep  Sena', 1229.5714285714287), ('Zhanlan', 627.7777777777778), ('Zhaoxuan', 629.0081967213115), ('Zhibek', 1058.0), ('Zhima', 1144.45), ('Zhou', 1237.9), ('Zhuoma', 989.75), ('Zi', 391.4656290531777), ('Zinovia', 1221.5), ('Ziyue', 878.4606741573034), ('Zoe', 765.3777777777777), ('Zoe Gwen', 935.081081081081), ('Zsofia', 916.559633027523), ('Zuzana', 451.92875448487956), ('Zuzanna', 794.5416666666666)]","[(1199.8235294117646, 'Aastha'), (1110.0434782608695, 'Abbi'), (808.4545454545455, 'Abbie'), (387.66706161137444, 'Abigail'), (1039.6744186046512, 'Abiodun'), (1228.75, 'Abir'), (790.1538461538462, 'Adeliya'), (1122.4423076923076, 'Adnya'), (619.6814159292036, 'Adriana'), (1213.1666666666667, 'Adrienn'), (627.12, 'Adrijana'), (1255.3333333333333, 'Adva'), (1155.0392156862745, 'Afroditi'), (960.6770186335403, 'Agata'), (1082.3548387096773, 'Agata Jadwiga'), (1231.5, 'Agne'), (391.3003629764065, 'Agnes'), (694.0659898477157, 'Agnese'), (940.2125603864735, 'Agni'), (122.19587628865979, 'Agnieszka'), (684.8497652582159, 'Agustina'), (1154.25, 'Agustina Elena'), (1156.340425531915, 'Ah'), (1248.72, 'Ahlam'), (728.5, 'Ahsha'), (890.8728448275862, 'Ai'), (912.1523178807947, 'Ai Wen'), (1110.3333333333333, 'Aida'), (284.8724727838258, 'Aiko'), (1034.5833333333333, 'Ailen'), (1200.2, 'Aimee'), (1164.95, 'Aina'), (943.7397959183673, 'Ainhoa'), (1024.625, 'Aishwarya'), (302.84831460674155, 'Ajla'), (704.9618138424821, 'Akari'), (215.25185185185185, 'Akgul'), (710.9617224880383, 'Aki'), (1145.8235294117646, 'Akiho'), (493.98205383848455, 'Akiko'), (772.8571428571429, 'Akilah'), (1038.35, 'Akvile'), (1119.1639344262296, 'Alana'), (843.7260273972603, 'Alba'), (343.22432701894314, 'Alberta'), (775.2734375, 'Albina'), (1185.7142857142858, 'Aldana'), (1067.019801980198, 'Alejandra'), (450.22998544395927, 'Aleksandra'), (578.07962529274, 'Aleksandrina'), (820.4563492063492, 'Alena'), (1123.4864864864865, 'Alessandra'), (1057.628205128205, 'Alessia'), (1145.1641791044776, 'Alessondra'), (383.9921465968586, 'Alexa'), (569.2647632558965, 'Alexandra'), (945.625, 'Alexandria'), (718.5202702702703, 'Alexia'), (604.15, 'Alexis'), (441.9846743295019, 'Aliaksandra'), (710.3822682786414, 'Alice'), (951.9764150943396, 'Alice Andrada'), (1105.1298701298701, 'Alicia'), (855.813627254509, 'Alicja'), (925.0028776978418, 'Alina'), (611.35, 'Aliona'), (453.01556420233464, 'Alisa'), (403.48784576697403, 'Alison'), (822.3459915611814, 'Alix'), (252.11485774499474, 'Alize'), (217.85922330097088, 'Alla'), (557.9232456140351, 'Allie'), (1157.8, 'Almudena'), (871.6926829268293, 'Alona'), (1181.6078431372548, 'Alory Regina Elorriaga'), (496.9431818181818, 'Alyona'), (650.6240276577355, 'Amanda'), (747.4375, 'Amandine'), (1011.3666666666667, 'Amelie'), (803.9764705882353, 'Amina'), (613.195652173913, 'Aminat'), (1075.8260869565217, 'Amira'), (415.9078341013825, 'Amra'), (1209.4, 'Amrita'), (763.888198757764, 'Amy'), (460.8932038834951, 'An Sophie'), (396.2893280632411, 'Ana'), (842.8446601941747, 'Ana Bianca'), (524.9192825112108, 'Ana Clara'), (1084.7916666666667, 'Ana Gabriela'), (1243.4285714285713, 'Ana Luisa'), (1031.228855721393, 'Ana Paula'), (496.7156398104265, 'Ana Sofia'), (961.2631578947369, 'Ana Victoria'), (144.3264367816092, 'Anabel'), (922.2255639097745, 'Anaeve'), (482.26169844020797, 'Anais'), (859.3059701492538, 'Anamika'), (430.0872542522642, 'Anastasia'), (956.5754716981132, 'Anastasia Evgenyevna'), (1245.75, 'Anastasiia'), (221.66153846153847, 'Anastasija'), (671.2584369449378, 'Anastasiya'), (1127.7368421052631, 'Anca'), (1150.0, 'Anda'), (970.3620689655172, 'Andie K'), (1063.4736842105262, 'Andjela'), (1275.8235294117646, 'Andra Maria'), (414.4332292750607, 'Andrea'), (878.3939393939394, 'Andrea Renee'), (956.0333333333333, 'Andreea'), (801.84375, 'Andreea Amalia'), (726.2657657657658, 'Andreea Roxana'), (424.64521739130436, 'Andreja'), (1184.0416666666667, 'Andressa Cristina'), (1045.6666666666667, 'Andrina'), (1152.0857142857142, 'Aneta'), (367.2274678111588, 'Anett'), (969.8181818181819, 'Anette'), (1226.3333333333333, 'Ange Oby'), (1128.7272727272727, 'Angela'), (686.2234432234433, 'Angelica'), (1089.1603773584907, 'Angeliki'), (750.3207810320781, 'Angelina'), (308.56833824975416, 'Angelique'), (432.6949152542373, 'Anhelina'), (850.9791666666666, 'Anhzelika'), (720.1431870669746, 'Ani'), (947.472972972973, 'Anita'), (725.3893333333333, 'Anja'), (1228.388888888889, 'Anke'), (618.4714285714285, 'Ankita'), (907.4, 'Ann'), (551.5557158312297, 'Anna'), (760.639175257732, 'Anna Arina'), (428.5496828752643, 'Anna Giulia'), (345.51020408163265, 'Anna Karolina'), (916.7115384615385, 'Anna Katalina'), (201.87700534759358, 'Anna Lena'), (1070.3967391304348, 'Anna Maria'), (583.9347826086956, 'Annalisa'), (248.74237737516572, 'Anne'), (762.7606382978723, 'Anne Liz'), (1237.6363636363637, 'Anne Marie'), (1252.0, 'Anne Sophie'), (1042.037037037037, 'Annie'), (265.79487179487177, 'Annika'), (969.5882352941177, 'Anouk'), (1051.7096774193549, 'Antonela'), (589.1298076923077, 'Antonia'), (1049.4655172413793, 'Antonina'), (1037.0833333333333, 'Anushka'), (617.3333333333334, 'Ao'), (1016.5714285714286, 'Apichaya'), (658.5074074074074, 'Arabela'), (279.23336006415394, 'Arantxa'), (490.4144736842105, 'Aranza'), (200.97080291970804, 'Aravane'), (951.4146341463414, 'Ariadna'), (560.6778190830236, 'Arina'), (1224.0, 'Arina Gabriela'), (1074.3333333333333, 'Arlinda'), (1281.8461538461538, 'Arthi'), (349.54794520547944, 'Aryna'), (1181.27868852459, 'Aselya'), (1151.95, 'Asha'), (331.3681818181818, 'Ashleigh'), (638.88, 'Ashley'), (823.0909090909091, 'Ashling'), (1018.6637931034483, 'Ashmitha'), (803.3904761904762, 'Ashvarya'), (453.43392070484583, 'Asia'), (790.46875, 'Asiya'), (1172.5531914893618, 'Assia'), (829.5625, 'Astra'), (1086.45, 'Astrid Wanja'), (591.2544731610338, 'Audrey'), (1208.4285714285713, 'Avgusta'), (1064.0, 'Axana'), (552.4653465346535, 'Ayaka'), (901.8717948717949, 'Ayan'), (597.6981132075472, 'Ayano'), (397.83561643835617, 'Ayla'), (915.5932203389831, 'Aymet'), (479.5530612244898, 'Ayu Fani'), (412.74466019417474, 'Ayumi'), (556.2303370786517, 'Azra'), (763.8900651465798, 'Barbara'), (252.6093155893536, 'Barbora'), (656.2932551319648, 'Basak'), (785.0707482993197, 'Beatrice'), (457.4050279329609, 'Beatriz'), (1253.4, 'Beatriz Magdalena'), (971.2865853658536, 'Beatriz Maria'), (1382.1538461538462, 'Beauty'), (1167.3368421052633, 'Belen'), (681.7736842105263, 'Belinda'), (705.4688346883469, 'Benedetta'), (625.013698630137, 'Berfu'), (717.7932330827068, 'Bermet'), (541.273631840796, 'Bernarda'), (834.1005025125628, 'Bernice'), (1005.75, 'Berta'), (146.59709379128137, 'Bethanie'), (1229.5714285714287, 'Betina'), (878.0138888888889, 'Bhuvana'), (653.2805383022775, 'Bianca'), (696.952380952381, 'Bianka'), (550.1941544885177, 'Bibiane'), (912.71875, 'Blair'), (904.6538461538462, 'Blanca'), (1221.8333333333333, 'Blessing'), (1254.6341463414635, 'Boba'), (392.7313829787234, 'Bojana'), (834.2066115702479, 'Borislava'), (992.4222222222222, 'Boyan'), (970.9846153846154, 'Brandy'), (872.0930232558139, 'Breaunna'), (211.01377118644066, 'Brenda'), (854.3170731707318, 'Brianna'), (917.0, 'Brienne'), (1126.3333333333333, 'Brindtha'), (647.5205479452055, 'Britt'), (990.5210084033613, 'Brittany'), (804.6277056277056, 'Brooke'), (952.5619834710744, 'Brynn'), (555.3384615384615, 'Bunyawi'), (1140.981981981982, 'Busra'), (311.87854251012146, 'Cagla'), (709.4247787610619, 'Caitlin'), (803.7139479905437, 'Camelia Elena'), (1192.1818181818182, 'Cameron'), (539.7944621938232, 'Camila'), (1192.3783783783783, 'Camila Vital'), (801.6850649350649, 'Camilla'), (1112.9450549450548, 'Camille'), (236.07412398921832, 'Cara'), (416.3666666666667, 'Carina'), (411.70779777206513, 'Carla'), (1236.7777777777778, 'Carlota'), (1127.9338842975208, 'Carlotta'), (318.69978858350953, 'Carly'), (890.6351351351351, 'Carmen'), (842.1553398058253, 'Carmen Raluca'), (564.1434426229508, 'Carol'), (645.2279792746114, 'Carolin'), (718.725321888412, 'Carolina'), (799.0650406504066, 'Carolina Meligeni Rodrigues'), (342.40130505709624, 'Caroline'), (1161.5675675675675, 'Caroline B'), (1197.578947368421, 'Carolyn'), (1020.6, 'Carson'), (378.0163727959698, 'Casey'), (293.76942355889724, 'Catalina'), (941.4724409448819, 'Catherine'), (134.21917808219177, 'Catherine Cartan'), (744.0, 'Caty'), (755.4649681528663, 'Cecilia'), (1141.842105263158, 'Cecilie Lundgaard'), (708.618398637138, 'Celine'), (1123.3855421686746, 'Cemre'), (650.1367521367522, 'Chalena'), (343.2835365853659, 'Chanel'), (215.6615811373093, 'Chanelle'), (575.4626436781609, 'Chang'), (1281.8461538461538, 'Chanikarn'), (609.90625, 'Chantal'), (1128.030303030303, 'Chantelle'), (1232.8, 'Chaoyi'), (766.4794520547945, 'Charlene'), (927.7647058823529, 'Charlotte'), (593.9759036144578, 'Chayenne'), (1132.0, 'Chelsea'), (719.3061224489796, 'Chelsey'), (524.7444668008048, 'Chen'), (789.2857142857143, 'Chengyiyi'), (464.1367781155015, 'Chi Chi'), (1039.3902439024391, 'Chi Fan'), (950.8813559322034, 'Chia Hsien'), (359.3764705882353, 'Chia Jung'), (437.73858921161826, 'Chiaki'), (977.9640591966173, 'Chiara'), (533.9586374695864, 'Chieh Yu'), (848.9908952959029, 'Chihiro'), (385.2651515151515, 'Chin Wei'), (615.2230215827338, 'Chinami'), (583.530303030303, 'Ching Wen'), (749.3582089552239, 'Chiraz'), (874.8181818181819, 'Chisa'), (675.2445414847161, 'Chloe'), (1112.1458333333333, 'Chompoothip'), (1112.875, 'Christie'), (454.9920529801324, 'Christina'), (841.4051724137931, 'Christine'), (692.390625, 'Chun Mei'), (986.3944099378882, 'Chun Yan'), (659.3055555555555, 'Cindy'), (443.45754716981133, 'Claire'), (1190.7307692307693, 'Clara'), (826.2619047619048, 'Claudia'), (967.2978723404256, 'Claudia Antonia'), (996.2574257425742, 'Claudia Gianina'), (383.6413199426112, 'Claudine'), (823.6306306306307, 'Clelia'), (875.9772727272727, 'Clemence'), (964.1224489795918, 'Clementina Eugenia'), (620.4120171673819, 'Clothilde'), (270.5896860986547, 'Coco'), (1165.093023255814, 'Colomba'), (390.0, 'Conny'), (570.2723004694835, 'Constance'), (835.1132075471698, 'Constanza'), (1245.3333333333333, 'Constanze'), (832.7818181818182, 'Corina'), (356.8219696969697, 'Corinna'), (757.2253521126761, 'Cornelia'), (406.5511363636364, 'Cory Ann'), (1049.0, 'Costanza'), (554.5376344086021, 'Cristiana'), (643.616049382716, 'Cristina'), (439.5747863247863, 'Cristina Andreea'), (720.6428571428571, 'Cristina Madalina'), (949.7944444444445, 'Csilla'), (998.7722772277227, 'Cynthia'), (1010.3333333333334, 'Da Hye'), (920.1276595744681, 'Dabin'), (1159.1818181818182, 'Dagmara'), (720.7490039840637, 'Daiana'), (1181.4736842105262, 'Dajana'), (801.6933333333334, 'Dalia'), (525.9552572706936, 'Dalila'), (279.16438356164383, 'Dalma'), (1493.0, 'Damilola'), (1242.0, 'Damini'), (1198.3333333333333, 'Damira'), (994.4769230769231, 'Dan Ni'), (805.7028985507246, 'Dana'), (977.4539007092199, 'Daneika'), (380.609375, 'Danica'), (348.6364892881825, 'Daniela'), (643.9216101694915, 'Daniella'), (744.7453250222618, 'Danielle'), (434.68, 'Danielle Rose'), (1107.0919540229886, 'Danijela'), (302.83268482490274, 'Danka'), (1226.5454545454545, 'Daphne'), (629.6443987667009, 'Daria'), (464.95631067961165, 'Darija'), (1132.1744186046512, 'Dariya'), (531.1829405162739, 'Darya'), (722.6986301369863, 'Dasha'), (576.4307692307692, 'Dayana'), (550.9545454545455, 'Dea'), (764.6785714285714, 'Deborah'), (1115.0851063829787, 'Deeon'), (758.5342960288808, 'Dejana'), (983.4174757281553, 'Demi'), (419.1633466135458, 'Denisa'), (949.1239316239316, 'Denise'), (1160.3125, 'Denise Antonela'), (551.5304659498208, 'Deniz'), (1123.6486486486488, 'Deria'), (863.7826086956521, 'Desirae'), (1032.2666666666667, 'Desiree'), (665.686684073107, 'Despina'), (746.0962962962963, 'Despoina'), (483.77464788732397, 'Destanee'), (1154.2857142857142, 'Dewi'), (615.1506849315068, 'Dhruthi'), (736.1650485436893, 'Di'), (383.7832512315271, 'Dia'), (654.3773657782928, 'Diana'), (1205.7692307692307, 'Diana Maria'), (809.697247706422, 'Dianne'), (669.2982456140351, 'Dijana'), (1248.2, 'Dilara'), (1094.4583333333333, 'Dina'), (268.05945945945945, 'Dinah'), (1234.6176470588234, 'Doga Selen'), (803.8666666666667, 'Domenica'), (171.71134020618555, 'Dominika'), (1042.7843137254902, 'Dominique'), (1131.6333333333334, 'Donika'), (223.50900900900902, 'Donna'), (1196.56, 'Dorien'), (520.9397993311037, 'Doroteja'), (913.7272727272727, 'Draginja'), (929.0599369085173, 'Dunja'), (1073.1752577319587, 'Ebony'), (1029.6888888888889, 'Eden'), (211.67325428194994, 'Edina'), (656.2851711026616, 'Eduarda'), (842.7045454545455, 'Eetee'), (1214.857142857143, 'Ege'), (471.8367290748899, 'Ekaterina'), (553.9434782608696, 'Ekaterine'), (1221.7931034482758, 'Elaine'), (1066.5343511450383, 'Eleanor'), (324.3720930232558, 'Elena'), (392.44444444444446, 'Elena Gabriela'), (686.6470588235294, 'Elena Teodora'), (249.5244140625, 'Eleni'), (950.0277777777778, 'Eleonora'), (1087.372340425532, 'Eleonore'), (876.1730769230769, 'Eliessa'), (421.6573033707865, 'Elina'), (888.2213114754098, 'Elisabeth'), (334.7118644067797, 'Elise'), (418.39748953974896, 'Elitsa'), (579.5214723926381, 'Elixane'), (978.2708333333334, 'Eliza'), (1154.2714285714285, 'Elizabeta'), (736.9747747747748, 'Elizabeth'), (1006.2982456140351, 'Elizabeth Anita Alexandria'), (489.5307517084282, 'Elizaveta'), (981.9814814814815, 'Elizaveta Anna'), (1011.9433962264151, 'Elke'), (1168.7967479674796, 'Ella'), (750.9460093896714, 'Ellen'), (508.340206185567, 'Ellie'), (1211.2333333333333, 'Elodie'), (652.1984732824427, 'Elyne'), (819.3400503778338, 'Ema'), (672.730407523511, 'Emelyn'), (770.8472222222222, 'Emi'), (1232.0, 'Emilia'), (1022.9174311926605, 'Emiliana'), (705.4716981132076, 'Emilie'), (1209.625, 'Emilija'), (1092.2771084337348, 'Emiliya'), (585.093851132686, 'Emily'), (1041.948717948718, 'Emily J'), (682.0972222222222, 'Emina'), (641.046992481203, 'Emma'), (1193.3529411764705, 'Emma Christine'), (943.7716535433071, 'Emmanuelle'), (1229.7333333333333, 'En Pei'), (980.3333333333334, 'Ena'), (321.23595505617976, 'Eri'), (788.0384615384615, 'Erica'), (544.5041866028708, 'Erika'), (942.7969696969697, 'Erin'), (733.1351351351351, 'Erina'), (1218.5652173913043, 'Esen'), (966.0540540540541, 'Estela'), (617.4935251798561, 'Estelle'), (950.9090909090909, 'Ester'), (347.34943639291464, 'Estrella'), (781.3218390804598, 'Etsuko'), (911.7241379310345, 'Eudice Wong'), (1157.5, 'Eugenia'), (477.62886597938143, 'Eugenie'), (620.6746411483253, 'Eugeniya'), (500.29483037156706, 'Eva'), (1083.8333333333333, 'Eva Marie'), (1023.8690476190476, 'Eveliina'), (471.5439093484419, 'Evelyn'), (414.66339869281046, 'Evgenia'), (442.0344827586207, 'Evgeniya'), (612.0185185185185, 'Fang Ying'), (406.9281767955801, 'Fangzhou'), (569.1904761904761, 'Fanny'), (1106.3076923076924, 'Farah'), (673.7509157509157, 'Fatima'), (1070.9463414634147, 'Fatimah'), (648.2984054669704, 'Fatma'), (1015.5, 'Fatyha'), (722.7286493034525, 'Federica'), (1204.7272727272727, 'Federica Joe'), (647.922077922078, 'Fernanda'), (1187.0384615384614, 'Ferny'), (853.3908045977012, 'Fiona'), (376.47888446215137, 'Flavia'), (451.5810397553517, 'Florencia'), (999.2, 'Frances'), (570.534951862704, 'Francesca'), (903.1666666666666, 'Francisca'), (437.05298013245033, 'Francoise'), (949.6575342465753, 'Franziska'), (1244.3333333333333, 'Frederikke'), (544.1627906976744, 'Freya'), (696.7697332607512, 'Gabriela'), (994.0612244897959, 'Gabriela Nicole'), (792.5, 'Gabriella'), (985.7211538461538, 'Gabrielle Faith'), (1052.8314606741574, 'Gaelle'), (759.5352697095435, 'Gaia'), (526.2644836272041, 'Gail'), (305.19563522992985, 'Galina'), (606.7211740041929, 'Ganna'), (229.3774193548387, 'Garbine'), (1152.142857142857, 'Gebriela'), (772.2857142857143, 'Genevieve'), (533.5940594059406, 'Georgia'), (763.1014492753624, 'Georgia Andreea'), (1153.9166666666667, 'Georgiana'), (396.225, 'Georgina'), (1150.6607142857142, 'Ghislaine'), (813.1351351351351, 'Giada'), (567.8518518518518, 'Gioia'), (960.4941860465116, 'Giorgia'), (1226.5, 'Giorgie'), (1197.0, 'Giovanna'), (693.6215943491422, 'Giulia'), (584.359375, 'Giuliana'), (794.7118644067797, 'Gloria'), (716.3150684931506, 'Gozal'), (454.06233062330625, 'Grace'), (783.8288043478261, 'Gracia'), (547.277108433735, 'Greetje'), (296.8219584569733, 'Greta'), (797.383606557377, 'Guadalupe'), (1027.0, 'Guillermina'), (957.9512195121952, 'Guiomar'), (1168.3396226415093, 'Gulben'), (1196.0, 'Gulchekhra'), (1236.6153846153845, 'Gulnaz'), (995.4074074074074, 'Guzal'), (1087.6216216216217, 'Gyulnara'), (1051.623188405797, 'Habiba'), (844.3856812933026, 'Hae Sung'), (1179.4153846153847, 'Haine'), (1110.5376344086021, 'Hana'), (957.2, 'Hanna'), (543.968253968254, 'Hanyu'), (680.1050228310502, 'Hao Chen'), (1153.936507936508, 'Hao Ching'), (574.8723404255319, 'Harmony'), (694.341935483871, 'Harriet'), (774.6837606837607, 'Haruka'), (512.1515151515151, 'Haruna'), (914.5321100917431, 'Hayley'), (1214.7692307692307, 'Hazal'), (167.50632911392404, 'Heather'), (417.44323483670297, 'Heidi'), (1019.4107142857143, 'Helen'), (696.4752475247525, 'Helene'), (1095.1176470588234, 'Hikari'), (673.6635071090047, 'Hilda'), (1219.0, 'Himari'), (534.890243902439, 'Hiroko'), (860.8104265402843, 'Hirono'), (925.9865771812081, 'Ho Ching'), (1185.75, 'Hollie'), (914.8607594936709, 'Hongrui'), (1251.1333333333334, 'Hortencia'), (1107.7142857142858, 'Hsin Yuan'), (726.1737089201878, 'Hua Chen'), (1118.904761904762, 'Huijie'), (888.0055096418732, 'Hulya'), (1020.28125, 'Hye Min'), (1069.3208955223881, 'Hyojung'), (729.0671936758894, 'Hyun Hui'), (1038.6911764705883, 'I Hsuan'), (1085.581818181818, 'Iana'), (962.5, 'Ida'), (1232.2, 'Idia'), (705.5625, 'Iga'), (1135.5, 'Ilay'), (868.2191780821918, 'Ilka'), (452.625, 'Ilona'), (847.0941176470589, 'Ilze'), (845.375, 'Imane Maelle'), (1165.5573770491803, 'Ina'), (1069.0925925925926, 'Inci'), (954.046875, 'India'), (627.7027027027027, 'Indire'), (485.9559748427673, 'Indy'), (919.6147540983607, 'Ineke'), (687.0229885057471, 'Ines'), (1039.0, 'Inger'), (766.2549019607843, 'Ingrid'), (869.3571428571429, 'Ingrid Alexandra'), (748.6622691292876, 'Ingrid Esperanza'), (1192.5454545454545, 'Intissar'), (980.2232142857143, 'Ioana'), (482.43243243243245, 'Ioana Diana'), (646.0441176470588, 'Ioana Loredana'), (799.0552486187845, 'Ionela Andreea'), (655.7828348504552, 'Ipek'), (288.74423480083857, 'Irena'), (579.2153846153847, 'Irene'), (436.84339509862525, 'Irina'), (285.84388185654007, 'Irina Camelia'), (578.1381578947369, 'Irina Maria'), (866.1075949367089, 'Iris'), (489.5294964028777, 'Iryna'), (724.9178743961353, 'Isabel'), (1114.99375, 'Isabela'), (566.7873931623932, 'Isabella'), (781.6993464052288, 'Isabelle'), (1170.9411764705883, 'Iulia Maria'), (732.7386018237082, 'Iva'), (439.81414868105514, 'Ivana'), (871.109375, 'Ivania'), (1079.05, 'Ivanka'), (117.95684523809524, 'Iveta'), (1136.8535031847134, 'Ivette'), (872.0, 'Ivone'), (591.3809523809524, 'Ivonne'), (624.6089494163424, 'Jacqueline'), (909.2, 'Jada'), (739.04802259887, 'Jade'), (760.4920634920635, 'Jaeda'), (562.8450704225352, 'Jaimee'), (1243.875, 'Jaimy Gayle'), (1037.5274725274726, 'Jainy'), (402.36756756756756, 'Jamie'), (1247.3333333333333, 'Jamilya'), (592.5990783410139, 'Jan'), (406.6258503401361, 'Jana'), (240.5306603773585, 'Janette'), (699.7864583333334, 'Janina'), (1262.5416666666667, 'Janja'), (861.5102040816327, 'Janneke'), (748.7238095238096, 'Jaqueline Adina'), (1121.767857142857, 'Jara'), (149.46360759493672, 'Jarmila'), (633.027027027027, 'Jasmin'), (642.1811989100818, 'Jasmina'), (437.86915887850466, 'Jasmine'), (1117.64, 'Jasmine Amber'), (1070.5648854961833, 'Jawairiah'), (1035.46, 'Jazmin'), (983.1290322580645, 'Jazzamay'), (767.7730496453901, 'Jeannine'), (348.19338235294117, 'Jelena'), (556.7936681222708, 'Jennifer'), (902.1470588235294, 'Jenny'), (501.5860215053763, 'Jesika'), (655.7464059804486, 'Jessica'), (818.2043795620438, 'Jessika'), (967.6708860759494, 'Jessy'), (823.9789029535865, 'Ji Hee'), (833.5061082024433, 'Ji Young'), (1169.6923076923076, 'Jia'), (682.961038961039, 'Jia Jing'), (529.7777777777778, 'Jia Qi'), (794.4931506849315, 'Jiahui'), (1230.6, 'Jiakang'), (1232.032258064516, 'Jiatian'), (578.5, 'Jiaxi'), (1161.0, 'Jiaxue'), (114.05571428571429, 'Jie'), (501.0619469026549, 'Jil Belen'), (1116.4190476190477, 'Jil Nora'), (121.9579326923077, 'Jill'), (721.14, 'Jillian'), (1267.0, 'Jin'), (492.8915187376726, 'Jin A'), (1035.6470588235295, 'Jin Ju'), (369.1620469083156, 'Jing Jing'), (863.3225806451613, 'Joana'), (931.025641025641, 'Joanna'), (1227.8, 'Joanne'), (925.4230769230769, 'Jodie Anna'), (1111.8333333333333, 'Johana'), (310.3405299313052, 'Johanna'), (1022.6198347107438, 'Jordana'), (924.9325842696629, 'Josepha'), (684.4892086330935, 'Josephine'), (993.2105263157895, 'Josie'), (601.9846625766871, 'Jovana'), (812.6, 'Ju Eun'), (1224.0, 'Judith'), (1243.904761904762, 'Jule'), (576.9173467252564, 'Julia'), (1024.6666666666667, 'Julia Mansano'), (1110.0816326530612, 'Juliana'), (1175.7666666666667, 'Juliana Rocha'), (512.3787128712871, 'Julie'), (707.1467889908257, 'Julieta Lara'), (1019.9411764705883, 'Julita'), (732.1666666666666, 'Julyette Maria Josephine'), (1189.0, 'June'), (262.30884808013354, 'Junri'), (1212.9166666666667, 'Justina'), (521.5358361774744, 'Justine'), (585.8517745302714, 'Justyna'), (1055.020202020202, 'Kady'), (272.08855291576674, 'Kai Chen'), (522.6561403508772, 'Kai Lin'), (127.06775067750678, 'Kaia'), (901.3333333333334, 'Kaitlin'), (756.2549019607843, 'Kaitlyn'), (633.5454545454545, 'Kaja'), (661.9589041095891, 'Kajsa'), (568.2547169811321, 'Kamila'), (1162.8301886792453, 'Kamilla'), (765.1395348837209, 'Kamonwan'), (924.2782608695652, 'Kana'), (635.346516007533, 'Kanae'), (1105.3125, 'Kanako'), (799.9940828402367, 'Kanami'), (962.8536585365854, 'Kanika'), (871.0790513833992, 'Kaori'), (674.9672514619883, 'Karen'), (1068.9166666666667, 'Kariann'), (472.338003502627, 'Karin'), (883.6090909090909, 'Karina'), (696.9606060606061, 'Karina Ildor'), (1062.795918367347, 'Karina Kristina'), (868.8904109589041, 'Karine'), (1001.0679611650486, 'Karis'), (807.616, 'Karla'), (652.917808219178, 'Karman'), (928.3333333333334, 'Karola Patricia'), (1077.8095238095239, 'Karolayne'), (586.9412296564195, 'Karolina'), (873.6229508196722, 'Karoline'), (903.5769230769231, 'Karyn'), (927.0350877192982, 'Kassandra'), (331.93949394939494, 'Katalin'), (401.0998263888889, 'Katarina'), (459.29286608260327, 'Katarzyna'), (1117.7142857142858, 'Kate'), (491.8507295173962, 'Katerina'), (294.33209990749305, 'Kateryna'), (680.677700348432, 'Katharina'), (882.1071428571429, 'Katharine'), (836.6804511278195, 'Katherine'), (910.396694214876, 'Katherine Gabriela'), (415.7, 'Kathinka'), (291.4792817679558, 'Kathrin'), (620.9404580152672, 'Katie'), (1111.08, 'Katrine Isabel'), (492.6608695652174, 'Katy'), (1050.7, 'Katya'), (1010.1818181818181, 'Katyarina'), (583.1686746987951, 'Kayla'), (1163.3478260869565, 'Kaylah'), (772.2402912621359, 'Kazusa'), (1003.1212121212121, 'Kei'), (1114.9433962264152, 'Kelia'), (804.873831775701, 'Kelly'), (312.7584269662921, 'Kelly S'), (1012.325, 'Kelsey'), (807.7222222222222, 'Kennedy'), (643.422641509434, 'Keren'), (1018.6534653465346, 'Keri'), (1020.4271844660194, 'Kerstin'), (978.0229885057471, 'Khristina'), (1164.090909090909, 'Ki Ryang'), (287.71625344352617, 'Kiki'), (687.3120567375887, 'Kim'), (762.4081632653061, 'Kim Alice'), (846.9154228855722, 'Kimberley'), (618.6923076923077, 'Kimberly'), (1097.219512195122, 'Kimika'), (95.03465982028241, 'Kimiko'), (606.1467576791808, 'Kinnie'), (308.64912280701753, 'Kirsten'), (1035.0384615384614, 'Kirsten Andrea'), (576.9, 'Klaartje'), (235.31431431431432, 'Klara'), (780.7905027932961, 'Klaudia'), (826.0238095238095, 'Komola'), (567.0507399577167, 'Korina'), (844.7460317460317, 'Kotomi'), (522.984693877551, 'Krista'), (445.18918918918916, 'Kristie'), (343.25546975546973, 'Kristina'), (1060.5633802816901, 'Kristina N'), (837.7730496453901, 'Kristy'), (443.8467908902692, 'Kristyna'), (482.36648501362396, 'Ksenia'), (990.6, 'Kseniia'), (975.6271186440678, 'Ksenija'), (488.76107382550333, 'Kumiko'), (165.96132596685084, 'Kurumi'), (159.62397820163488, 'Kveta'), (1070.0377358490566, 'Kwan Yau'), (887.502487562189, 'Kyle'), (798.3181818181819, 'Kylie'), (348.54794520547944, 'Kyoka'), (443.76148409893995, 'Kyra'), (533.433770014556, 'Kyung Mi'), (677.4458598726114, 'Laetitia'), (996.8148148148148, 'Laili'), (1062.3666666666666, 'Lamis'), (643.6939163498099, 'Lara'), (1054.9019607843138, 'Larikah'), (504.4145867098865, 'Laura'), (910.5714285714286, 'Laura D'), (516.1982942430703, 'Laura Ioana'), (1198.1538461538462, 'Laura Sofia'), (484.9442231075697, 'Lauren'), (1107.0882352941176, 'Lauryn'), (612.736, 'Lavinia'), (1226.076923076923, 'Laylo'), (1184.0, 'Layne'), (858.4107142857143, 'Lea'), (1179.6216216216217, 'Leah'), (908.156862745098, 'Lee'), (594.9436936936937, 'Lena'), (657.8934169278997, 'Lena Marie'), (451.33577981651376, 'Lenka'), (773.5666666666667, 'Leolia'), (825.972972972973, 'Leonie'), (887.4545454545455, 'Lesedi Sheya'), (205.17590361445784, 'Lesia'), (514.7174515235457, 'Lesley'), (1180.5454545454545, 'Leslie'), (481.3229166666667, 'Leticia'), (1072.4, 'Leticia Garcia'), (1030.5, 'Leylah Annie'), (988.7425149700599, 'Li'), (387.87113402061857, 'Liana Gabriela'), (899.9150326797386, 'Libby'), (1035.327868852459, 'Libi'), (1147.8529411764705, 'Lidia'), (797.2128378378378, 'Lidziya'), (284.8326771653543, 'Liezel'), (567.9464544138929, 'Liga'), (722.5087719298245, 'Lilla'), (497.42124542124543, 'Lin'), (574.9808362369338, 'Lina'), (929.4398496240601, 'Linda'), (275.6055900621118, 'Lindsay'), (986.82, 'Lindsey'), (418.81925343811395, 'Ling'), (1184.7222222222222, 'Liniques'), (959.6981132075472, 'Linnea'), (356.0105210420842, 'Lisa'), (758.06, 'Lisa Maria'), (996.0408163265306, 'Lisa Marie'), (673.6507936507936, 'Lisanne'), (887.2875, 'Liubov'), (1179.875, 'Livia'), (870.9007633587786, 'Liz Tatiane'), (1120.5652173913043, 'Lizaveta'), (666.1496062992126, 'Lizette'), (1231.2727272727273, 'Lorenza'), (972.75, 'Lorraine M'), (680.1724137931035, 'Lou'), (1220.0, 'Loudmilla'), (380.5308641975309, 'Louisa'), (1070.1025641025642, 'Louise'), (188.06095041322314, 'Lourdes'), (907.3557312252965, 'Lu'), (859.8644067796611, 'Luca'), (845.740638002774, 'Lucia'), (885.7495107632094, 'Luciana'), (322.62611607142856, 'Lucie'), (845.986301369863, 'Lucrezia'), (756.3141592920354, 'Lucy'), (846.2727272727273, 'Ludmila'), (787.5416666666666, 'Ludmilla'), (981.7517730496454, 'Luisa'), (820.59375, 'Luisa Marie'), (284.22813688212926, 'Luksika'), (1098.2888888888888, 'Lulu'), (1139.0, 'Luna'), (974.2702702702703, 'Lusine'), (1190.0629921259842, 'Lutfiye'), (982.6666666666666, 'Lyann'), (952.4411764705883, 'Lynn'), (382.82479784366575, 'Lyudmyla'), (607.3360995850622, 'Macall'), (692.1515151515151, 'Macarena'), (324.63613231552165, 'Madalina'), (748.0, 'Maddison'), (1028.0365853658536, 'Madeleine'), (1217.469387755102, 'Madeline'), (1203.5, 'Madina'), (290.64452214452217, 'Madison'), (958.0955414012739, 'Madrie'), (787.0, 'Maegan'), (1139.7, 'Mafalda'), (1173.75, 'Maftuna'), (734.0, 'Magali'), (1036.1214953271028, 'Magalie'), (300.3974358974359, 'Magda'), (443.6296006264683, 'Magdalena'), (1092.7621951219512, 'Magy'), (875.0, 'Mahak'), (1007.15, 'Mahitha'), (687.25, 'Mai'), (745.433962264151, 'Maia'), (1206.6666666666667, 'Maia A'), (438.4245810055866, 'Maiko'), (1152.888888888889, 'Maileen'), (410.8463541666667, 'Mailen'), (896.7413793103449, 'Maja'), (784.8009049773756, 'Makiho'), (516.6615384615385, 'Makoto'), (999.15625, 'Malene'), (1004.7428571428571, 'Malika'), (825.039603960396, 'Malin'), (1031.5342465753424, 'Mallaurie'), (143.48235294117646, 'Mallory'), (947.3333333333334, 'Malou'), (1153.590909090909, 'Mami'), (1202.2692307692307, 'Man Ying Maggie'), (689.891129032258, 'Mana'), (1230.6, 'Mananchaya'), (838.1780821917808, 'Manca'), (361.0, 'Mandy'), (897.0974358974358, 'Manisha'), (622.7673469387755, 'Manon'), (1181.3548387096773, 'Manya'), (908.3962264150944, 'Mara'), (774.64, 'Marcela'), (1143.7957746478874, 'Marcela Guimaraes'), (1247.3636363636363, 'Marcelina'), (657.0171919770773, 'Marcella'), (325.5912596401028, 'Margalita'), (987.6739130434783, 'Margarida'), (611.4060995184591, 'Margarita'), (1051.1224489795918, 'Margaux'), (753.8346456692914, 'Margot'), (526.3698630136986, 'Mari'), (426.6002565198803, 'Maria'), (1190.0833333333333, 'Maria Agustina'), (1072.9591836734694, 'Maria Andrea'), (1188.5277777777778, 'Maria Camila'), (861.5050505050505, 'Maria Constanza De Las Mercedes'), (1119.4897959183672, 'Maria Del Rosario'), (194.2392065344224, 'Maria Elena'), (443.0228531855956, 'Maria Fernanda'), (1170.1830985915492, 'Maria Jesus'), (486.6092544987147, 'Maria Joao'), (306.1794310722101, 'Maria Jose'), (918.0769230769231, 'Maria Lourdes'), (1047.98224852071, 'Maria Paulina'), (359.81081081081084, 'Maria Teresa'), (662.1182795698925, 'Mariam'), (556.0428051001821, 'Mariana'), (730.3831168831168, 'Marianna'), (993.175925925926, 'Marianne'), (1085.4242424242425, 'Mariaryeni'), (695.574074074074, 'Marie'), (300.56296296296296, 'Marie Eve'), (1148.9166666666667, 'Mariia'), (544.2636655948553, 'Marija'), (1215.0, 'Marijana'), (532.6881807180315, 'Marina'), (774.5654761904761, 'Marine'), (279.78655282817505, 'Marion'), (1163.0, 'Mariona'), (1067.3413173652696, 'Marisa'), (281.871335504886, 'Mariya'), (353.44444444444446, 'Marketa'), (946.8934426229508, 'Marlies'), (783.1711711711712, 'Marrit'), (419.32988047808766, 'Marta'), (851.1224489795918, 'Marta Huqi'), (1056.0588235294117, 'Martha'), (751.8679119412942, 'Martina'), (869.1666666666666, 'Mary'), (1188.7096774193549, 'Mary Ann'), (323.86176470588236, 'Maryna'), (355.7223168654174, 'Masa'), (437.11396648044695, 'Mathilde'), (799.1875, 'Matilda'), (1013.4761904761905, 'Maud'), (1070.21875, 'Maureen'), (1121.0869565217392, 'Maurien'), (973.8717948717949, 'Maxine'), (1084.0294117647059, 'May'), (732.4260679079956, 'Maya'), (891.6309523809524, 'Mayar'), (407.029702970297, 'Mayo'), (619.9064748201439, 'Mayya'), (736.4809523809524, 'Megan'), (1025.0, 'Megumi'), (1031.6, 'Mei Xu'), (812.85, 'Meiling'), (1029.1666666666667, 'Meiqi'), (372.32502965599053, 'Melanie'), (1039.8333333333333, 'Melany Solange'), (1017.2560553633218, 'Melina'), (169.13578500707214, 'Melinda'), (634.7950310559006, 'Melis'), (993.1351351351351, 'Melisa'), (1154.093023255814, 'Melissa'), (1104.357142857143, 'Melissa Ishuan'), (1035.95, 'Meng Ning'), (1213.2142857142858, 'Mercedes'), (900.75, 'Merel'), (1182.9107142857142, 'Meritxell'), (337.5292682926829, 'Mervana'), (554.3953934740883, 'Mi'), (1071.3076923076924, 'Mi Jeong'), (992.7225433526012, 'Mi Rae'), (999.375, 'Mi Zhuoma'), (987.504761904762, 'Mia Nicole'), (1332.0737704918033, 'Micaela'), (676.90589198036, 'Michaela'), (185.3469387755102, 'Michaella'), (1228.9285714285713, 'Michela'), (946.8846153846154, 'Michele Alexandra'), (280.79959100204496, 'Michelle'), (718.047619047619, 'Michika'), (376.7356115107914, 'Mihaela'), (1223.4, 'Mihaela Lorena'), (523.2788844621514, 'Miharu'), (1064.142857142857, 'Mihika'), (1110.4411764705883, 'Mihoki'), (586.2250489236791, 'Miki'), (1201.16, 'Mila'), (1234.2857142857142, 'Milagros'), (626.441935483871, 'Milana'), (1114.4074074074074, 'Milena'), (1221.904761904762, 'Milica'), (866.0693069306931, 'Min'), (819.8425531914894, 'Min Hwa'), (1238.0625, 'Minami'), (788.2622950819672, 'Mira'), (721.1643835616438, 'Mirabelle'), (1169.4864864864865, 'Miranda'), (912.120218579235, 'Miriam'), (628.075, 'Miriam Bianca'), (950.6263736263736, 'Miriana'), (843.6428571428571, 'Mirjam'), (186.76587795765877, 'Mirjana'), (617.0379241516966, 'Misa'), (208.95263157894738, 'Misaki'), (1121.04, 'Mitsumi'), (447.93283582089555, 'Miyabi'), (594.9036697247707, 'Miyu'), (593.1506849315068, 'Mizuno'), (1029.0, 'Molly'), (772.6981132075472, 'Momoko'), (273.57517899761336, 'Mona'), (210.0846394984326, 'Monica'), (980.575, 'Monika'), (462.4270462633452, 'Monique'), (541.952380952381, 'Montserrat'), (880.6527777777778, 'Morgane'), (1243.4, 'Moulika'), (1258.5, 'Mouna'), (1198.25, 'Moyuka'), (1227.0, 'Muazzez'), (1186.9444444444443, 'Muge'), (485.40168539325845, 'Myrtille'), (82.13112391930835, 'Na'), (608.7791798107255, 'Na Lae'), (573.5197368421053, 'Na Ri'), (868.6521739130435, 'Nadezda'), (407.5463976945245, 'Nadia'), (637.4607407407408, 'Nadiya'), (631.8181818181819, 'Nadja'), (828.0675675675676, 'Nagi'), (767.4963503649635, 'Naiktha'), (930.7027027027027, 'Naima'), (878.6666666666666, 'Nam Yeon'), (890.4455445544554, 'Nan Nan'), (542.7168141592921, 'Nanuli'), (313.45625, 'Nao'), (1180.3828125, 'Naoko'), (483.97225572979494, 'Naomi'), (929.4388489208633, 'Napatsakorn'), (1138.9166666666667, 'Nastassia'), (554.5290322580645, 'Nastassja'), (593.1772853185596, 'Nastja'), (720.132932166302, 'Natalia'), (577.9677419354839, 'Natalie'), (634.3620689655172, 'Natalija'), (1247.909090909091, 'Nataliya'), (666.2853403141361, 'Natasa'), (883.0777142857143, 'Natasha'), (566.4943396226415, 'Natela'), (962.0188679245283, 'Natella'), (543.031185031185, 'Nathalia'), (617.4615384615385, 'Nathaly'), (929.6928104575163, 'Natia'), (547.7037037037037, 'Natsumi'), (1177.622641509434, 'Nattawadee'), (1087.3823529411766, 'Naz'), (825.7291666666666, 'Nazari'), (745.421052631579, 'Neda'), (1164.107142857143, 'Nelise'), (1069.15, 'Nermeen'), (1031.0, 'Nevena'), (515.3191489361702, 'Nicha'), (843.9007633587786, 'Nicky'), (753.2253164556962, 'Nicola'), (499.4127634660422, 'Nicole'), (485.46875, 'Nicoleta Catalina'), (778.1648648648649, 'Nicolette'), (762.1578947368421, 'Nidhi'), (376.7617554858934, 'Nigina'), (913.4380165289256, 'Nika'), (1174.0, 'Nikita'), (1017.3134328358209, 'Nikki'), (1054.0813953488373, 'Nikol'), (723.484076433121, 'Nikola'), (528.8673050615595, 'Nina'), (1124.1666666666667, 'Nina Isabella'), (841.0514705882352, 'Nives'), (965.5343511450382, 'Noel'), (1049.834745762712, 'Noelia'), (883.7787610619469, 'Noelle'), (1167.2758620689656, 'Nonna'), (374.93926247288505, 'Noppawan'), (921.6216216216217, 'Nora'), (1096.1140350877192, 'Nour'), (936.3392857142857, 'Nozomi'), (436.66881028938906, 'Nudnida'), (537.577922077922, 'Nungnadda'), (395.6680227827502, 'Nuria'), (1027.1382978723404, 'Oana'), (686.3047619047619, 'Oana Georgeta'), (728.7630208333334, 'Oceane'), (839.4923664122138, 'Ofri'), (533.9652351738241, 'Oksana'), (660.8924731182796, 'Ola'), (1397.5, 'Olawaseun'), (1112.75, 'Olaya'), (903.4289156626506, 'Oleksandra'), (1179.1555555555556, 'Olena'), (501.44444444444446, 'Olesya'), (432.6511627906977, 'Olga'), (446.7231833910035, 'Olivia'), (1006.5128205128206, 'Oliwia'), (435.1470588235294, 'Ons'), (978.7321428571429, 'Ornella'), (866.0454545454545, 'Oyku'), (1156.28125, 'Paige Mary'), (989.1904761904761, 'Pamela'), (683.1081081081081, 'Panna'), (132.12638580931264, 'Paola'), (1099.625, 'Parris'), (863.5507246376811, 'Patcharin'), (572.8059701492538, 'Patricia'), (403.935, 'Patricia Maria'), (657.3816155988858, 'Patrycja'), (385.8135593220339, 'Patty'), (558.0162601626016, 'Paula'), (1175.909090909091, 'Paula Andrea'), (868.7624113475177, 'Paula Catalina'), (508.4679802955665, 'Paula Cristina'), (1035.7780678851175, 'Paulina'), (298.1861898890259, 'Pauline'), (915.5892857142857, 'Pavla'), (514.586319218241, 'Peangtarn'), (755.5813953488372, 'Peggy'), (673.9809523809524, 'Pei Chi'), (1106.5, 'Pei Hsuan'), (1061.3076923076924, 'Pei Ju'), (465.24962852897477, 'Pemra'), (619.4154929577464, 'Pernilla'), (710.3972602739726, 'Petia'), (365.50280484204313, 'Petra'), (1211.0, 'Phenomena'), (826.6486486486486, 'Phillis'), (737.862676056338, 'Pia'), (668.2581196581197, 'Piia'), (740.5879828326181, 'Pilar'), (1041.0740740740741, 'Pippa'), (937.7945205479452, 'Plobrung'), (630.7953529937444, 'Polina'), (478.30369515011546, 'Polona'), (729.1047904191616, 'Poojashree'), (795.4736842105264, 'Pranjala'), (653.5070422535211, 'Prarthana G'), (740.5361842105264, 'Prerna'), (1137.19, 'Priscila'), (675.4124293785311, 'Priscilla'), (383.4714587737844, 'Qiang'), (826.1388888888889, 'Qianhui'), (943.421052631579, 'Qianqian'), (705.8493150684932, 'Qiu Yu'), (883.2352941176471, 'Quinn'), (633.9770491803279, 'Quirine'), (859.2706766917294, 'Rachael'), (1147.8526315789475, 'Rachel'), (955.7833333333333, 'Radina'), (1121.2432432432433, 'Rafaela'), (1176.5, 'Ralina'), (304.4619771863118, 'Raluca'), (672.2258064516129, 'Raluca Elena'), (539.6164383561644, 'Raluca Georgiana'), (1010.4545454545455, 'Ramu'), (1121.8846153846155, 'Ramya'), (598.2655172413793, 'Ran'), (1117.6666666666667, 'Rana'), (700.7644444444444, 'Raquel'), (1089.2100840336134, 'Rashmi'), (1021.6504854368932, 'Ratnika'), (487.6268656716418, 'Raveena'), (1145.4333333333334, 'Rebeca'), (568.3374316939891, 'Rebecca'), (676.1090909090909, 'Rebeka'), (289.60283687943263, 'Regina'), (1019.0, 'Reina'), (323.1388101983003, 'Reka Luca'), (494.6111111111111, 'Remi'), (274.85317919075146, 'Renata'), (669.448275862069, 'Ria'), (638.6666666666666, 'Rianna'), (246.19871794871796, 'Richel'), (290.0614657210402, 'Rika'), (495.22641509433964, 'Riko'), (1125.0363636363636, 'Rio'), (489.65909090909093, 'Risa'), (775.7269624573379, 'Rishika'), (1051.7349397590363, 'Rita'), (651.4246575342465, 'Riya'), (150.96681415929203, 'Roberta'), (431.19607843137254, 'Robin'), (1054.606896551724, 'Robyn'), (795.6201232032854, 'Rocio'), (402.49931972789113, 'Romana'), (669.8542372881356, 'Romana Caroline'), (283.63246554364474, 'Romina'), (758.1714285714286, 'Romy'), (1125.5471698113208, 'Rona'), (427.0, 'Ronit'), (1072.857142857143, 'Ronke'), (1168.2857142857142, 'Roosh'), (965.0, 'Rosa'), (1059.73, 'Rosalia'), (1066.5887096774193, 'Rosalie'), (984.1714285714286, 'Rosie'), (479.51738241308794, 'Roxane'), (1209.625, 'Rui'), (573.8729603729604, 'Rushmi'), (808.5096774193548, 'Rutuja'), (1069.0379746835442, 'Ryann'), (1117.88, 'Saana'), (982.7397260273973, 'Sabastiani'), (682.2005532503458, 'Sabina'), (1184.6666666666667, 'Sabina Elena'), (203.5871080139373, 'Sabine'), (905.6324786324786, 'Sabrina'), (340.2890442890443, 'Sacha'), (400.8093385214008, 'Sachia'), (368.26881720430106, 'Sachie'), (665.8219178082192, 'Sadafmoh'), (998.5238095238095, 'Sai Samhitha'), (297.39032258064515, 'Saisai'), (832.9585365853659, 'Sakiko'), (529.583908045977, 'Sally'), (1204.6666666666667, 'Salma'), (406.21702404158543, 'Samantha'), (932.8940397350993, 'Samira'), (1105.171875, 'Sanae'), (703.1372549019608, 'Sanaz'), (563.964505613908, 'Sandra'), (1028.9565217391305, 'Sandy'), (857.9508196721312, 'Sang Hee'), (177.22695035460993, 'Sania'), (509.80945757997216, 'Sara'), (546.5551763367463, 'Sarah'), (875.9277108433735, 'Sarah Beth'), (743.6062176165804, 'Sarah Rebecca'), (1139.2340425531916, 'Sarahi'), (1191.6470588235295, 'Sarai Delfina'), (840.0776699029126, 'Saray'), (1081.1666666666667, 'Sari'), (1209.7777777777778, 'Sarlota'), (1235.1960784313726, 'Sarvinoz'), (1033.027027027027, 'Sasa'), (747.3695652173913, 'Saska'), (888.7272727272727, 'Satsuki'), (1142.9285714285713, 'Savannah'), (1188.2941176470588, 'Schena'), (1210.2571428571428, 'Se Hyun'), (1122.4545454545455, 'Se Jin'), (1240.92, 'Sean'), (1003.5367647058823, 'Seda'), (1115.72, 'Seira'), (1168.6571428571428, 'Selin'), (858.9173789173789, 'Seo Kyung'), (889.8028169014085, 'Seone'), (14.654294803817603, 'Serena'), (162.3505747126437, 'Sesil'), (784.0465949820789, 'Seung Yeon'), (218.4701086956522, 'Severine'), (166.41358024691357, 'Shahar'), (924.8818897637796, 'Shakhlo'), (1236.7627118644068, 'Shakhnoza'), (1228.3235294117646, 'Shangqing'), (694.2, 'Shanshan'), (967.9034090909091, 'Shao Yuan'), (851.5633802816901, 'Sharmada'), (296.5792682926829, 'Sharon'), (1097.0, 'Sharon Sanchana'), (372.89398280802294, 'Shelby'), (1171.0, 'Shelly'), (451.8657487091222, 'Sheng Nan'), (649.5154639175257, 'Sherazad'), (1024.0116279069769, 'Sherry'), (500.688679245283, 'Shiho'), (632.2824427480916, 'Shilin'), (1070.6666666666667, 'Shiori'), (1154.4166666666667, 'Shir'), (1187.9245283018868, 'Shiran'), (935.2322946175638, 'Shivika'), (1120.388888888889, 'Shou Na'), (1148.0, 'Shreya'), (1042.6802325581396, 'Shu Ying'), (167.90740740740742, 'Shuai'), (421.44179894179894, 'Shuko'), (864.1538461538462, 'Shuo'), (966.0588235294117, 'Shuyue'), (897.6951219512196, 'Shweta'), (1047.7575757575758, 'Si Qi'), (565.8211508553654, 'Silvia'), (542.2382851445662, 'Simona'), (1070.3417721518988, 'Simone'), (974.8, 'Simran Kaur'), (728.7443609022556, 'Sina'), (975.3484848484849, 'Sinead'), (1141.842105263158, 'Sing Le'), (980.9076923076923, 'Siqi'), (949.7916666666666, 'Sirui'), (1241.1379310344828, 'Siyu'), (259.63589743589745, 'Sloane'), (1184.8260869565217, 'Smriti'), (1225.388888888889, 'Sneha'), (632.3150684931506, 'Snehadevi S'), (514.1732026143791, 'So Jung'), (572.2654545454545, 'So Ra'), (526.3535641547861, 'Sofia'), (1084.107142857143, 'Sofico'), (724.5, 'Sofie'), (541.1570881226054, 'Sofiya'), (640.8727272727273, 'Sofya'), (1004.6666666666666, 'Sohyun'), (1029.0980392156862, 'Sonia'), (885.0976744186047, 'Sonja'), (1221.3333333333333, 'Sophia'), (600.6881091617934, 'Sophie'), (213.75043630017453, 'Sorana'), (813.1357142857142, 'Sowjanya'), (1149.3125, 'Spurti'), (792.1927710843373, 'Sri Vaishnavi'), (841.8387096774194, 'Stamatia'), (312.54158964879855, 'Stanislava'), (993.4255319148937, 'Stefana'), (1167.3333333333333, 'Stefani'), (759.2894995093228, 'Stefania'), (387.73412112259973, 'Stefanie'), (939.746835443038, 'Steffi'), (439.87772357723577, 'Stephanie'), (1035.5548387096774, 'Stephanie Mariel'), (573.6708333333333, 'Storm'), (426.3886462882096, 'Su Jeong'), (217.2493188010899, 'Su Wei'), (911.7619047619048, 'Suellen'), (944.2432432432432, 'Sultan'), (812.4581005586592, 'Sun Jung'), (1229.8, 'Sunae'), (611.0757575757576, 'Sunam'), (635.7449168207024, 'Sung Hee'), (1015.6792452830189, 'Susan'), (417.8053097345133, 'Susanne'), (982.7222222222222, 'Suzan'), (980.6666666666666, 'Suzuho'), (698.7567567567568, 'Suzy'), (844.203007518797, 'Svenja'), (267.03227571115974, 'Svetlana'), (691.9934640522875, 'Sviatlana'), (1002.6792452830189, 'Sybille'), (869.1702127659574, 'Sylvia'), (787.7645348837209, 'Sylwia'), (791.1240506329113, 'Syna'), (772.3186813186813, 'Szabina'), (343.0985324947589, 'Tadeja'), (969.6588235294117, 'Taisiya'), (1230.2, 'Talya'), (949.8059701492538, 'Tamachan'), (1118.4166666666667, 'Tamar'), (614.0434782608696, 'Tamara'), (1146.3934426229507, 'Tamari'), (121.82273948075202, 'Tamarine'), (386.7025316455696, 'Tamaryn'), (135.88910505836577, 'Tamira'), (601.906914893617, 'Tammi'), (1113.2325581395348, 'Tanaporn'), (1023.089430894309, 'Tanya'), (475.2979683972912, 'Tara'), (1075.0, 'Tatia'), (681.9417582417583, 'Tatiana'), (247.7449768160742, 'Tatjana'), (912.1077844311377, 'Tatsiana'), (747.3172413793103, 'Tayisiya'), (387.5662100456621, 'Taylor'), (1068.7457627118645, 'Tea'), (461.06702898550725, 'Teliana'), (614.9346733668342, 'Tena'), (489.27513227513225, 'Teodora'), (557.241418764302, 'Tereza'), (963.5, 'Terri'), (696.2878787878788, 'Tess'), (390.2361111111111, 'Tessah'), (437.4119658119658, 'Tetiana'), (398.83478260869566, 'Tetyana'), (802.7222222222222, 'Thai Sa Grana'), (650.1206896551724, 'Theo'), (1159.5632183908046, 'Theresa'), (1017.7777777777778, 'Tijana'), (182.02426160337552, 'Timea'), (425.82394366197184, 'Tina'), (810.6666666666666, 'Tinatin'), (739.7727272727273, 'Ting Fei'), (789.6113989637306, 'Ting Jr'), (1015.2352941176471, 'Tingting'), (743.1953125, 'Tjasa'), (838.8065217391304, 'Tomoko'), (841.7167381974249, 'Tori'), (878.1666666666666, 'Tornado Alicia'), (1029.3196721311476, 'Trang'), (1009.8666666666667, 'Treta'), (131.02074074074073, 'Tsvetana'), (992.4870588235294, 'Tyra'), (506.39344262295083, 'Ulrikke'), (844.0692307692308, 'Ulyana'), (229.35687022900763, 'Urszula'), (1132.4109589041095, 'Ushna'), (411.5068493150685, 'Usue Maitane'), (921.3333333333334, 'Valentina'), (751.2668918918919, 'Valentine'), (479.8914728682171, 'Valentini'), (368.14331210191085, 'Valentyna'), (661.8474576271186, 'Valeria'), (806.2648401826484, 'Valerie'), (799.8668224299065, 'Valeriya'), (696.4126984126984, 'Vanda'), (579.437984496124, 'Vanesa'), (398.3106546854942, 'Vanessa'), (185.75, 'Vania'), (1130.6037735849056, 'Vaniya'), (1089.7111111111112, 'Vanja'), (450.4642082429501, 'Varatchaya'), (894.3846153846154, 'Varunya'), (382.6888217522659, 'Varvara'), (613.5330490405117, 'Vasilisa'), (859.8103448275862, 'Vaszilisza'), (729.0117647058823, 'Vendula'), (32.984862819299906, 'Venus'), (195.66923570969814, 'Vera'), (958.1327800829876, 'Verena'), (726.1852387843704, 'Veronica'), (951.0075757575758, 'Veronica M'), (734.6018957345972, 'Veronika'), (240.0448979591837, 'Vesna'), (1252.9130434782608, 'Vicky'), (1138.8490566037735, 'Victoire'), (444.9760935910478, 'Victoria'), (1236.0, 'Victoria Ariadna'), (566.9148936170212, 'Viktoria'), (1236.5333333333333, 'Viktoriia'), (507.4, 'Viktorija'), (736.2288557213931, 'Viktoriya'), (966.4671052631579, 'Viktoryia'), (1243.0, 'Vilma Y'), (1214.1142857142856, 'Vincenza'), (1150.0, 'Vinciane'), (1170.840579710145, 'Violetta'), (355.88102893890675, 'Virginie'), (1208.952380952381, 'Vishesh'), (1201.25, 'Vita'), (296.2025641025641, 'Vitalia'), (670.9108527131783, 'Vivian'), (607.2810218978102, 'Vivien'), (659.2103004291846, 'Vivienne'), (595.3291666666667, 'Vlada'), (943.5432098765432, 'Vladica'), (823.8770833333333, 'Vladimira'), (1006.1769911504425, 'Vladislava'), (856.0782608695653, 'Vladyslava'), (555.6572164948453, 'Vojislava'), (999.0215053763441, 'Voni'), (701.4009009009009, 'Wan Ting'), (1081.142857142857, 'Wan Yi'), (1249.3333333333333, 'Warona'), (440.35214446952597, 'Wen Hsin'), (1117.55, 'Wen Ling'), (1011.469696969697, 'Wendy Qi Wen'), (1152.7837837837837, 'Weronika Jasmina'), (886.1407407407407, 'Whitney'), (1083.1454545454546, 'Wiktoria'), (585.2589641434263, 'Wing Yau Venise'), (937.7878787878788, 'Wushuang'), (661.2222222222222, 'Xenia'), (714.8653846153846, 'Xi Yao'), (814.4171122994652, 'Xiao'), (467.24657534246575, 'Xiaodi'), (848.4418604651163, 'Xiaorong'), (737.7547169811321, 'Xiaoxi'), (712.2780373831775, 'Ximena'), (694.4808743169399, 'Xin'), (1022.3333333333334, 'Xin Yu'), (480.646017699115, 'Xinyu'), (309.35767790262173, 'Xinyun'), (954.6, 'Xiyu'), (488.7671232876712, 'Xu Liu'), (1225.75, 'Ya'), (586.865, 'Ya Hsuan'), (325.6162790697674, 'Yafan'), (768.560975609756, 'Yan'), (740.0214504596527, 'Yana'), (1177.8823529411766, 'Yang'), (381.2581602373887, 'Yanina'), (1059.2702702702702, 'Yanni'), (1166.875, 'Yarden'), (211.41240310077518, 'Yaroslava'), (702.1784386617101, 'Yasmin'), (1227.7777777777778, 'Yasmina'), (983.0410958904109, 'Yasmine'), (1261.8181818181818, 'Yasmyn'), (1110.4594594594594, 'Yawna'), (114.78806907378336, 'Yayuk'), (431.3144424131627, 'Ye Ra'), (1048.081081081081, 'Ye Xin'), (1155.8191489361702, 'Yekaterina'), (897.4873949579832, 'Yelena'), (973.8617021276596, 'Yeong Won'), (724.8712871287129, 'Yevgeniya'), (791.0756207674943, 'Yi'), (381.5512572533849, 'Yi Fan'), (656.8787276341948, 'Yi Jing'), (418.2566137566138, 'Yi Miao'), (1185.030303030303, 'Yidi'), (1209.625, 'Yihong'), (1063.9411764705883, 'Yijia'), (661.3972602739726, 'Ying'), (403.8775981524249, 'Ying Ying'), (801.6712328767123, 'Yixuan'), (892.3561643835617, 'Ylena'), (642.9487179487179, 'Ylona Georgiana'), (1128.901098901099, 'Yoko'), (1068.4619883040937, 'Yolande'), (1263.7666666666667, 'Yoo Ri'), (844.9310344827586, 'Yoon Young'), (1096.9130434782608, 'Yoshimi'), (1222.24, 'Yosr'), (1170.3461538461538, 'You Na'), (458.86633663366337, 'Ysaline'), (1098.357142857143, 'Yu Jin'), (1239.6666666666667, 'Yu Tong'), (1054.0, 'Yuan'), (891.2340425531914, 'Yuanyi'), (983.359649122807, 'Yue'), (444.96190476190475, 'Yue Yue'), (961.876923076923, 'Yuenu'), (1034.1304347826087, 'Yujia'), (748.8250591016548, 'Yuka'), (1071.5833333333333, 'Yukako'), (876.7428571428571, 'Yuki'), (698.8285714285714, 'Yuki Kristina'), (857.1692307692308, 'Yukina'), (824.3936170212766, 'Yukun'), (485.35135135135135, 'Yulia'), (725.5322195704057, 'Yuliana'), (384.87776983559684, 'Yuliya'), (799.1332586786115, 'Yumi'), (166.6586270871985, 'Yung Jan'), (1047.3529411764705, 'Yuqi'), (322.17758620689654, 'Yurika'), (1041.5367231638418, 'Yuriko'), (746.4803493449782, 'Yurina'), (608.1309090909091, 'Yuuki'), (1230.2, 'Yuval'), (545.449074074074, 'Yuxuan'), (318.2867132867133, 'Yvonne'), (1227.344827586207, 'Zaineb'), (867.5288461538462, 'Zalina'), (709.625, 'Zarah'), (222.81428571428572, 'Zarina'), (791.2352941176471, 'Zeel'), (1229.5714285714287, 'Zeynep  Sena'), (627.7777777777778, 'Zhanlan'), (629.0081967213115, 'Zhaoxuan'), (1058.0, 'Zhibek'), (1144.45, 'Zhima'), (1237.9, 'Zhou'), (989.75, 'Zhuoma'), (391.4656290531777, 'Zi'), (1221.5, 'Zinovia'), (878.4606741573034, 'Ziyue'), (765.3777777777777, 'Zoe'), (935.081081081081, 'Zoe Gwen'), (916.559633027523, 'Zsofia'), (451.92875448487956, 'Zuzana'), (794.5416666666666, 'Zuzanna')]",,1.0,
What is the first name and country code of the oldest player?,"[players.first_name, players.country_code, players.birth_date]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT players.first_name, players.country_code FROM players ORDER BY players.birth_date ASC LIMIT 1;","SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""players.first_name"" and ""players.country_code"" of the oldest player. 2. Condition Structure: No specific filtering condition is required, as we are looking for the player with the earliest birth date. 3. Join Structure: No JOIN is required since all necessary information is in the ""players"" table. 4. Aggregation Structure: Use ORDER BY on ""players.birth_date"" in ascending order to find the oldest player (earliest birth date) and apply LIMIT 1 to select only the oldest player.","[('Thelma', 'AUS')]","[('Thelma', 'AUS')]",,1.0,
"find the id, name and age for visitors who visited some museums more than once.","[visitor.ID, visitor.Name, visitor.Age, visit.visitor_ID, visit.Museum_ID, visit.visitor_ID = visitor.ID]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",NESTED,"SELECT visitor.ID, visitor.Name, visitor.Age FROM visitor JOIN visit ON visitor.ID = visit.visitor_ID GROUP BY visitor.ID, visitor.Name, visitor.Age HAVING COUNT(visit.Museum_ID) > 1;","SELECT t1.id ,  t1.name ,  t1.age FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id GROUP BY t1.id HAVING count(*)  >  1",museum_visit,"1. Sequential Structure: Start with the SELECT clause to retrieve the ID, name, and age of visitors. Use the FROM clause to specify the visitor table and JOIN it with the visit table to link visitors with their museum visits. Apply a GROUP BY clause on visitor_ID to count the number of visits for each visitor. Use the HAVING clause to filter visitors who visited museums more than once. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for visitors who have visited museums more than once. 3. Join Structure: Use an INNER JOIN between the visitor and visit tables based on visitor_ID to connect visitor details with their visit records. 4. Aggregation Structure: Use COUNT(*) within HAVING to aggregate the number of visits per visitor and filter out those with only one visit.","[(3, 'Arjen Robben', 27), (5, 'Fernando Gago', 36), (6, 'Rafael van der Vaart', 25)]","[(3, 'Arjen Robben', 27), (5, 'Fernando Gago', 36), (6, 'Rafael van der Vaart', 25)]",,1.0,
What is maximum and minimum death toll caused each time?,"[death.killed, death.caused_by_ship_id, ship.id = death.caused_by_ship_id]","Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",EASY,"SELECT death.caused_by_ship_id, MAX(death.killed) AS max_death_toll, MIN(death.killed) AS min_death_toll FROM death GROUP BY death.caused_by_ship_id;","SELECT max(killed) ,  min(killed) FROM death",battle_death,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum death tolls caused each time. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum death tolls. 3. Grouping Structure: Use GROUP BY on ""death.caused_by_ship_id"" to calculate these aggregate values for each instance of a ship causing deaths. 4. Join Structure: No JOIN is required since all necessary data is within the ""death"" table.","[(1, 29, 8), (2, 3, 0), (3, 25, 0), (4, 3, 0), (5, 14, 0), (6, 0, 0)]","[(29, 0)]",,1.0,
Show names of teachers and the courses they are arranged to teach in ascending alphabetical order of the teacher's name.,"[teacher.Name, course.Course, course_arrange.Teacher_ID = teacher.Teacher_ID, course_arrange.Course_ID = course.Course_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NON-NESTED,"SELECT teacher.Name, course.Course FROM teacher JOIN course_arrange ON teacher.Teacher_ID = course_arrange.Teacher_ID JOIN course ON course_arrange.Course_ID = course.Course_ID ORDER BY teacher.Name ASC;","SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID ORDER BY T3.Name",course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve ""teacher.Name"" and ""course.Course."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""teacher"" table with ""course_arrange"" on ""Teacher_ID"" and ""course_arrange"" with ""course"" on ""Course_ID"" to link each teacher with their respective courses. 4. Aggregation Structure: No aggregation is needed, but apply ORDER BY to list results in ascending alphabetical order of the teacher's name.","[('Anne Walker', 'History'), ('Anne Walker', 'Bible'), ('Gustaaf Deloor', 'Science'), ('Kearsley Brown', 'Math'), ('Lucy Wong', 'Music'), ('Vicente Carretero', 'Math')]","[('Anne Walker', 'History'), ('Anne Walker', 'Bible'), ('Gustaaf Deloor', 'Science'), ('Kearsley Brown', 'Math'), ('Lucy Wong', 'Music'), ('Vicente Carretero', 'Math')]",,1.0,
What is the most commmon hometowns for teachers?,[teacher.Hometown],"Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,SELECT teacher.Hometown FROM teacher GROUP BY teacher.Hometown ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Hometown FROM teacher GROUP BY Hometown ORDER BY COUNT(*) DESC LIMIT 1,course_teach,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""teacher.Hometown"". 2. Aggregation Structure: Use COUNT to determine the number of teachers from each hometown. 3. Grouping Structure: Use GROUP BY on ""teacher.Hometown"" to aggregate the results by each hometown. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank hometowns by the number of teachers. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common hometown. 6. Join Structure: No JOIN is required since all necessary data is within the ""teacher"" table.","[('Turton Urban District',)]","[('Turton Urban District',)]",,1.0,
What is the ship id and name that caused most total injuries?,"[ship.id, ship.name, death.injured, death.caused_by_ship_id = ship.id]","Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",NON-NESTED,"SELECT ship.id, ship.name FROM ship JOIN death ON death.caused_by_ship_id = ship.id GROUP BY ship.id, ship.name ORDER BY SUM(death.injured) DESC LIMIT 1;","SELECT T2.id ,  T2.name FROM death AS T1 JOIN ship AS t2 ON T1.caused_by_ship_id  =  T2.id GROUP BY T2.id ORDER BY count(*) DESC LIMIT 1",battle_death,"1. Sequential Structure: Start with the SELECT clause to retrieve ""ship.id"" and ""ship.name."" Use an aggregate function (SUM) on ""death.injured"" to calculate the total injuries caused by each ship. 2. Condition Structure: No specific filtering condition is required, as we are interested in all ships. 3. Join Structure: Use a JOIN between the ""ship"" and ""death"" tables based on ""death.caused_by_ship_id = ship.id"" to associate each ship with its corresponding injury records. 4. Aggregation Structure: Use SUM to calculate the total injuries caused by each ship. Use GROUP BY on ""ship.id"" and ""ship.name"" to group the results by ship. Use ORDER BY in descending order on the total injuries to rank ships by the number of injuries caused, and LIMIT 1 to select the ship with the most injuries.","[(4, 'HMS Avon')]","[(5, 'Three Brothers')]",,0.0,
Find the number of players for each hand type.,[players.hand],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT players.hand, COUNT(*) AS player_count FROM players GROUP BY players.hand;","SELECT count(*) ,  hand FROM players GROUP BY hand",wta_1,"1. Sequential Structure: Start with the SELECT clause to specify the hand type and the count of players for each hand type. 2. Aggregation Structure: Use COUNT to calculate the number of players for each hand type. 3. Grouping Structure: Use GROUP BY on ""players.hand"" to group the results by hand type. 4. Join Structure: No JOIN is required since all necessary data is within the ""players"" table.","[('', 954), ('L', 487), ('R', 5028), ('U', 14193)]","[(954, ''), (487, 'L'), (5028, 'R'), (14193, 'U')]",,1.0,
Find the average age of losers and winners of all matches.,"[matches.winner_age, matches.loser_age]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT AVG(matches.winner_age) AS avg_winner_age, AVG(matches.loser_age) AS avg_loser_age FROM matches;","SELECT avg(loser_age) ,  avg(winner_age) FROM matches",wta_1,"1. Sequential Structure: Begin with the SELECT clause to calculate the average age of winners and losers. 2. Aggregation Structure: Use the AVG function to calculate the average of ""matches.winner_age"" and ""matches.loser_age"". 3. Join Structure: No JOIN is required since all necessary data is within the ""matches"" table. 4. Condition Structure: No specific filtering condition is required as the query involves all matches.","[(27.062177773183812, 27.311213862584534)]","[(27.311213862584534, 27.062177773183812)]",,1.0,
How many matches were played in each year?,[matches.year],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT matches.year, COUNT(*) AS match_count FROM matches GROUP BY matches.year;","SELECT count(*) ,  YEAR FROM matches GROUP BY YEAR",wta_1,"1. Sequential Structure: Start with the SELECT clause to specify the year and the count of matches played in each year. 2. Aggregation Structure: Use COUNT to calculate the total number of matches for each year. 3. Grouping Structure: Use GROUP BY on ""matches.year"" to group the results by year. 4. Join Structure: No JOIN is required since all necessary data is within the ""matches"" table.","[(2013, 12), (2016, 158), (2017, 108)]","[(12, 2013), (158, 2016), (108, 2017)]",,1.0,
Show the name of teachers aged either 32 or 33?,"[teacher.Name, teacher.Age]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,"SELECT teacher.Name FROM teacher WHERE teacher.Age IN (32, 33);",SELECT Name FROM teacher WHERE Age  =  32 OR Age  =  33,course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Name"" of teachers aged either 32 or 33. 2. Condition Structure: Use a WHERE clause to filter for teachers whose ""teacher.Age"" is either 32 or 33. 3. Join Structure: No JOIN is required since all necessary information is in the ""teacher"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.","[('Joseph Huts',), ('John Deloor',)]","[('Joseph Huts',), ('John Deloor',)]",,1.0,
What is the first and second line for all addresses?,"[Addresses.line_1, Addresses.line_2]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT Addresses.line_1, Addresses.line_2 FROM Addresses;","SELECT line_1 ,  line_2 FROM addresses",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the first and second lines of all addresses, which are ""Addresses.line_1"" and ""Addresses.line_2"". 2. Condition Structure: No specific filtering condition is required as the query asks for all addresses. 3. Join Structure: No JOIN is necessary since all required data is available in the ""Addresses"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all records.","[('2294 Grant Square Apt. 235', 'Apt. 370'), ('3999 Aufderhar Ways Suite 593', 'Apt. 388'), ('67942 Carlotta Ferry Apt. 686', 'Apt. 583'), ('0144 Lamar Plaza Apt. 346', 'Suite 703'), ('858 Peggie Bypass Suite 212', 'Apt. 335'), ('16998 Mraz Lodge', 'Apt. 689'), ('193 Marlin Brook', 'Apt. 406'), ('202 Hessel Views Apt. 468', 'Apt. 305'), ('0643 Muller Vista', 'Suite 383'), ('7081 Eda Center', 'Suite 830'), ('9283 Schulist Falls Apt. 037', 'Suite 239'), ('979 Haag Shores Suite 656', 'Apt. 468'), ('492 Wilkinson Route', 'Suite 865'), ('186 Evan Motorway Apt. 409', 'Suite 079'), ('74046 Metz Walk Apt. 113', 'Suite 674')]","[('2294 Grant Square Apt. 235', 'Apt. 370'), ('3999 Aufderhar Ways Suite 593', 'Apt. 388'), ('67942 Carlotta Ferry Apt. 686', 'Apt. 583'), ('0144 Lamar Plaza Apt. 346', 'Suite 703'), ('858 Peggie Bypass Suite 212', 'Apt. 335'), ('16998 Mraz Lodge', 'Apt. 689'), ('193 Marlin Brook', 'Apt. 406'), ('202 Hessel Views Apt. 468', 'Apt. 305'), ('0643 Muller Vista', 'Suite 383'), ('7081 Eda Center', 'Suite 830'), ('9283 Schulist Falls Apt. 037', 'Suite 239'), ('979 Haag Shores Suite 656', 'Apt. 468'), ('492 Wilkinson Route', 'Suite 865'), ('186 Evan Motorway Apt. 409', 'Suite 079'), ('74046 Metz Walk Apt. 113', 'Suite 674')]",,1.0,
What are the names of the teachers whose hometown is not `` Little Lever Urban District '' ?,"[teacher.Name,teacher.Hometown]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,SELECT teacher.Name FROM teacher WHERE teacher.Hometown != 'Little Lever Urban District';,"select name from teacher where hometown != ""little lever urban district""",course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Name"" of teachers whose hometown is not ""Little Lever Urban District"". 2. Condition Structure: Use a WHERE clause to filter out teachers whose ""teacher.Hometown"" is ""Little Lever Urban District"". 3. Join Structure: No JOIN is required since all necessary information is in the ""teacher"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.","[('Joseph Huts',), ('Gustaaf Deloor',), ('Vicente Carretero',), ('John Deloor',), ('Kearsley Brown',), ('Lucy Wong',)]","[('Joseph Huts',), ('Gustaaf Deloor',), ('Vicente Carretero',), ('John Deloor',), ('Kearsley Brown',), ('Anne Walker',), ('Lucy Wong',)]",,0.0,
What is the hometown of the youngest teacher?,"[teacher.Hometown, teacher.Age]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,SELECT teacher.Hometown FROM teacher ORDER BY teacher.Age ASC LIMIT 1;,SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1,course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Hometown"" of the youngest teacher. 2. Condition Structure: No specific filtering condition is required other than identifying the youngest teacher. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""teacher"" table. 4. Aggregation Structure: Use ORDER BY on ""teacher.Age"" in ascending order to find the youngest teacher and apply LIMIT 1 to select only the youngest teacher's hometown.","[('Farnworth Municipal Borough',)]","[('Farnworth Municipal Borough',)]",,1.0,
How many players are there for each hand type?,[players.hand],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT players.hand, COUNT(*) AS player_count FROM players GROUP BY players.hand;","SELECT count(*) ,  hand FROM players GROUP BY hand",wta_1,"1. Sequential Structure: Start with the SELECT clause to specify the hand type and the count of players for each hand type. 2. Aggregation Structure: Use COUNT to calculate the number of players for each hand type. 3. Grouping Structure: Use GROUP BY on ""players.hand"" to group the results by hand type. 4. Join Structure: No JOIN is required since all necessary data is within the ""players"" table.","[('', 954), ('L', 487), ('R', 5028), ('U', 14193)]","[(954, ''), (487, 'L'), (5028, 'R'), (14193, 'U')]",,1.0,
Find the total ranking points for each player and their first name.,"[rankings.ranking_points,rankings.player_id,players.first_name,rankings.player_id = players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT players.first_name, SUM(rankings.ranking_points) AS total_ranking_points FROM rankings JOIN players ON rankings.player_id = players.player_id GROUP BY players.first_name;","SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the total ranking points for each player and their first name. Use SUM to calculate the total ranking points and include ""players.first_name"" in the SELECT clause. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""rankings"" and ""players"" tables on ""rankings.player_id = players.player_id"" to associate ranking points with player names. 4. Aggregation Structure: Use SUM to aggregate the ranking points for each player and GROUP BY ""players.first_name"" to group the results by player name.","[('Aastha', 68), ('Abbi', 304), ('Abbie', 5214), ('Abigail', 115293), ('Abiodun', 120), ('Abir', 72), ('Adeliya', 490), ('Adnya', 219), ('Adriana', 28045), ('Adrienn', 107), ('Adrijana', 4619), ('Adva', 9), ('Afroditi', 156), ('Agata', 1901), ('Agata Jadwiga', 219), ('Agne', 110), ('Agnes', 390148), ('Agnese', 13717), ('Agni', 2929), ('Agnieszka', 1801033), ('Agustina', 21728), ('Agustina Elena', 158), ('Ah', 141), ('Ahlam', 85), ('Ahsha', 52), ('Ai', 10751), ('Ai Wen', 2217), ('Aida', 703), ('Aiko', 140108), ('Ailen', 288), ('Aimee', 226), ('Aina', 92), ('Ainhoa', 2433), ('Aishwarya', 96), ('Ajla', 116548), ('Akari', 11873), ('Akgul', 228538), ('Aki', 14838), ('Akiho', 83), ('Akiko', 84446), ('Akilah', 742), ('Akvile', 640), ('Alana', 385), ('Alba', 1424), ('Alberta', 238803), ('Albina', 10507), ('Aldana', 71), ('Alejandra', 1578), ('Aleksandra', 451414), ('Aleksandrina', 35957), ('Alena', 8832), ('Alessandra', 235), ('Alessia', 2524), ('Alessondra', 265), ('Alexa', 138782), ('Alexandra', 955267), ('Alexandria', 191), ('Alexia', 12829), ('Alexis', 13389), ('Aliaksandra', 61196), ('Alice', 57745), ('Alice Andrada', 2358), ('Alicia', 993), ('Alicja', 5216), ('Alina', 11393), ('Aliona', 2369), ('Alisa', 369810), ('Alison', 323527), ('Alix', 5422), ('Alize', 596901), ('Alla', 253320), ('Allie', 33054), ('Almudena', 206), ('Alona', 4052), ('Alory Regina Elorriaga', 155), ('Alyona', 25183), ('Amanda', 68207), ('Amandine', 41575), ('Amelie', 887), ('Amina', 1990), ('Aminat', 12708), ('Amira', 157), ('Amra', 60702), ('Amrita', 159), ('Amy', 10616), ('An Sophie', 51803), ('Ana', 1589674), ('Ana Bianca', 2421), ('Ana Clara', 36696), ('Ana Gabriela', 288), ('Ana Luisa', 21), ('Ana Paula', 2141), ('Ana Sofia', 15955), ('Ana Victoria', 1367), ('Anabel', 678793), ('Anaeve', 1962), ('Anais', 46908), ('Anamika', 2338), ('Anastasia', 1433335), ('Anastasia Evgenyevna', 1235), ('Anastasiia', 12), ('Anastasija', 268277), ('Anastasiya', 75850), ('Anca', 101), ('Anda', 160), ('Andie K', 605), ('Andjela', 228), ('Andra Maria', 51), ('Andrea', 920433), ('Andrea Renee', 464), ('Andreea', 1484), ('Andreea Amalia', 1365), ('Andreea Roxana', 12727), ('Andreja', 74453), ('Andressa Cristina', 72), ('Andrina', 159), ('Aneta', 202), ('Anett', 71072), ('Anette', 1657), ('Ange Oby', 36), ('Angela', 245), ('Angelica', 13643), ('Angeliki', 677), ('Angelina', 19048), ('Angelique', 1132514), ('Anhelina', 17967), ('Anhzelika', 836), ('Ani', 48811), ('Anita', 2177), ('Anja', 11596), ('Anke', 54), ('Ankita', 21599), ('Ann', 62), ('Anna', 1017069), ('Anna Arina', 6650), ('Anna Giulia', 49207), ('Anna Karolina', 107880), ('Anna Katalina', 907), ('Anna Lena', 359374), ('Anna Maria', 1427), ('Annalisa', 29442), ('Anne', 647811), ('Anne Liz', 5269), ('Anne Marie', 99), ('Anne Sophie', 33), ('Annie', 172), ('Annika', 169371), ('Anouk', 3621), ('Antonela', 280), ('Antonia', 21624), ('Antonina', 484), ('Anushka', 480), ('Ao', 4941), ('Apichaya', 126), ('Arabela', 11608), ('Arantxa', 434692), ('Aranza', 24184), ('Aravane', 383495), ('Ariadna', 980), ('Arina', 96852), ('Arina Gabriela', 3), ('Arlinda', 154), ('Arthi', 39), ('Aryna', 19446), ('Aselya', 238), ('Asha', 99), ('Ashleigh', 58741), ('Ashley', 49980), ('Ashling', 5155), ('Ashmitha', 648), ('Ashvarya', 2321), ('Asia', 48788), ('Asiya', 802), ('Assia', 141), ('Astra', 1083), ('Astrid Wanja', 269), ('Audrey', 33624), ('Avgusta', 21), ('Axana', 7), ('Ayaka', 7996), ('Ayan', 571), ('Ayano', 5173), ('Ayla', 7444), ('Aymet', 791), ('Ayu Fani', 38501), ('Ayumi', 309990), ('Azra', 11721), ('Barbara', 53401), ('Barbora', 515957), ('Basak', 26624), ('Beatrice', 27061), ('Beatriz', 98798), ('Beatriz Magdalena', 75), ('Beatriz Maria', 1920), ('Beauty', 26), ('Belen', 351), ('Belinda', 137327), ('Benedetta', 11032), ('Berfu', 2850), ('Bermet', 8441), ('Bernarda', 19092), ('Bernice', 3894), ('Berta', 814), ('Bethanie', 371662), ('Betina', 21), ('Bhuvana', 1152), ('Bianca', 63998), ('Bianka', 1213), ('Bibiane', 50184), ('Blair', 905), ('Blanca', 312), ('Blessing', 662), ('Boba', 123), ('Bojana', 283166), ('Borislava', 3470), ('Boyan', 1465), ('Brandy', 725), ('Breaunna', 676), ('Brenda', 166760), ('Brianna', 2922), ('Brienne', 12), ('Brindtha', 30), ('Britt', 2487), ('Brittany', 1119), ('Brooke', 7062), ('Brynn', 1344), ('Bunyawi', 3187), ('Busra', 537), ('Cagla', 119797), ('Caitlin', 15218), ('Camelia Elena', 9147), ('Cameron', 38), ('Camila', 202172), ('Camila Vital', 136), ('Camilla', 11714), ('Camille', 574), ('Cara', 240762), ('Carina', 90451), ('Carla', 669546), ('Carlota', 27), ('Carlotta', 562), ('Carly', 67459), ('Carmen', 8174), ('Carmen Raluca', 1077), ('Carol', 14213), ('Carolin', 9093), ('Carolina', 36889), ('Carolina Meligeni Rodrigues', 3627), ('Caroline', 2076949), ('Caroline B', 111), ('Carolyn', 72), ('Carson', 289), ('Casey', 202697), ('Catalina', 250056), ('Catherine', 4987), ('Catherine Cartan', 45884), ('Caty', 22), ('Cecilia', 11954), ('Cecilie Lundgaard', 95), ('Celine', 18824), ('Cemre', 958), ('Chalena', 4914), ('Chanel', 62861), ('Chanelle', 275364), ('Chang', 26585), ('Chanikarn', 39), ('Chantal', 15001), ('Chantelle', 187), ('Chaoyi', 15), ('Charlene', 5683), ('Charlotte', 4356), ('Chayenne', 20132), ('Chelsea', 5), ('Chelsey', 6777), ('Chen', 26779), ('Chengyiyi', 277), ('Chi Chi', 49122), ('Chi Fan', 667), ('Chia Hsien', 679), ('Chia Jung', 33301), ('Chiaki', 42773), ('Chiara', 6159), ('Chieh Yu', 34796), ('Chihiro', 15401), ('Chin Wei', 70504), ('Chinami', 13141), ('Ching Wen', 7975), ('Chiraz', 1726), ('Chisa', 358), ('Chloe', 15190), ('Chompoothip', 276), ('Christie', 24), ('Christina', 310215), ('Christine', 2438), ('Chun Mei', 12519), ('Chun Yan', 3374), ('Cindy', 31620), ('Claire', 141876), ('Clara', 116), ('Claudia', 32581), ('Claudia Antonia', 1227), ('Claudia Gianina', 934), ('Claudine', 106762), ('Clelia', 2221), ('Clemence', 1622), ('Clementina Eugenia', 538), ('Clothilde', 12304), ('Coco', 235721), ('Colomba', 129), ('Conny', 52274), ('Constance', 25166), ('Constanza', 907), ('Constanze', 18), ('Corina', 1002), ('Corinna', 102260), ('Cornelia', 4053), ('Cory Ann', 20869), ('Costanza', 1236), ('Cristiana', 7486), ('Cristina', 59412), ('Cristina Andreea', 75414), ('Cristina Madalina', 317), ('Csilla', 6256), ('Cynthia', 1034), ('Da Hye', 1417), ('Dabin', 1261), ('Dagmara', 160), ('Daiana', 8589), ('Dajana', 150), ('Dalia', 8939), ('Dalila', 48857), ('Dalma', 15935), ('Damilola', 0), ('Damini', 12), ('Damira', 30), ('Dan Ni', 639), ('Dana', 3121), ('Daneika', 1607), ('Danica', 17597), ('Daniela', 1165205), ('Daniella', 16663), ('Danielle', 40823), ('Danielle Rose', 8507), ('Danijela', 545), ('Danka', 87958), ('Daphne', 33), ('Daria', 170617), ('Darija', 41925), ('Dariya', 857), ('Darya', 163036), ('Dasha', 1923), ('Dayana', 5619), ('Dea', 7027), ('Deborah', 7605), ('Deeon', 141), ('Dejana', 9846), ('Demi', 1192), ('Denisa', 65522), ('Denise', 3298), ('Denise Antonela', 168), ('Deniz', 23620), ('Deria', 215), ('Desirae', 354), ('Desiree', 709), ('Despina', 19065), ('Despoina', 3942), ('Destanee', 9227), ('Dewi', 134), ('Dhruthi', 2738), ('Di', 9780), ('Dia', 79958), ('Diana', 119279), ('Diana Maria', 99), ('Dianne', 6369), ('Dijana', 7353), ('Dilara', 85), ('Dina', 149), ('Dinah', 67017), ('Doga Selen', 117), ('Domenica', 1614), ('Dominika', 918746), ('Dominique', 455), ('Donika', 164), ('Donna', 114098), ('Dorien', 109), ('Doroteja', 23976), ('Draginja', 392), ('Dunja', 4703), ('Ebony', 713), ('Eden', 1978), ('Edina', 249446), ('Eduarda', 11216), ('Eetee', 2446), ('Ege', 50), ('Ekaterina', 1005319), ('Ekaterine', 26897), ('Elaine', 103), ('Eleanor', 2287), ('Elena', 1247887), ('Elena Gabriela', 7772), ('Elena Teodora', 6547), ('Eleni', 439179), ('Eleonora', 405), ('Eleonore', 567), ('Eliessa', 882), ('Elina', 314747), ('Elisabeth', 4709), ('Elise', 43779), ('Elitsa', 87263), ('Elixane', 18211), ('Eliza', 480), ('Elizabeta', 536), ('Elizabeth', 20368), ('Elizabeth Anita Alexandria', 1103), ('Elizaveta', 62977), ('Elizaveta Anna', 636), ('Elke', 960), ('Ella', 526), ('Ellen', 13761), ('Ellie', 8079), ('Elodie', 90), ('Elyne', 12554), ('Ema', 11218), ('Emelyn', 12728), ('Emi', 3880), ('Emilia', 43), ('Emiliana', 1258), ('Emilie', 1440), ('Emilija', 24), ('Emiliya', 541), ('Emily', 52889), ('Emily J', 964), ('Emina', 3029), ('Emma', 85022), ('Emma Christine', 65), ('Emmanuelle', 1609), ('En Pei', 52), ('Ena', 823), ('Eri', 34570), ('Erica', 472), ('Erika', 165477), ('Erin', 5356), ('Erina', 1225), ('Esen', 69), ('Estela', 376), ('Estelle', 39989), ('Ester', 3908), ('Estrella', 126811), ('Etsuko', 7147), ('Eudice Wong', 976), ('Eugenia', 36), ('Eugenie', 204801), ('Eugeniya', 20989), ('Eva', 320083), ('Eva Marie', 41), ('Eveliina', 744), ('Evelyn', 27011), ('Evgenia', 59775), ('Evgeniya', 206981), ('Fang Ying', 7755), ('Fangzhou', 33388), ('Fanny', 11260), ('Farah', 167), ('Fatima', 10865), ('Fatimah', 898), ('Fatma', 21261), ('Fatyha', 80), ('Federica', 56817), ('Federica Joe', 44), ('Fernanda', 17587), ('Ferny', 78), ('Fiona', 18219), ('Flavia', 1011058), ('Florencia', 89361), ('Frances', 359), ('Francesca', 1306087), ('Francisca', 157), ('Francoise', 21685), ('Franziska', 994), ('Frederikke', 9), ('Freya', 6525), ('Gabriela', 102623), ('Gabriela Nicole', 468), ('Gabriella', 6179), ('Gabrielle Faith', 1093), ('Gaelle', 1000), ('Gaia', 7998), ('Gail', 38651), ('Galina', 302957), ('Ganna', 30136), ('Garbine', 412872), ('Gebriela', 143), ('Genevieve', 440), ('Georgia', 9600), ('Georgia Andreea', 1848), ('Georgiana', 48), ('Georgina', 11569), ('Ghislaine', 290), ('Giada', 677), ('Gioia', 31741), ('Giorgia', 2484), ('Giorgie', 13), ('Giovanna', 289), ('Giulia', 106520), ('Giuliana', 2935), ('Gloria', 1297), ('Gozal', 2864), ('Grace', 70613), ('Gracia', 7999), ('Greetje', 6168), ('Greta', 240195), ('Guadalupe', 14277), ('Guillermina', 576), ('Guiomar', 687), ('Gulben', 410), ('Gulchekhra', 18), ('Gulnaz', 39), ('Guzal', 775), ('Gyulnara', 238), ('Habiba', 811), ('Hae Sung', 8180), ('Haine', 294), ('Hana', 413), ('Hanna', 2782), ('Hanyu', 4643), ('Hao Chen', 9631), ('Hao Ching', 224), ('Harmony', 5944), ('Harriet', 8608), ('Haruka', 3633), ('Haruna', 1873), ('Hayley', 1679), ('Hazal', 78), ('Heather', 202780), ('Heidi', 88542), ('Helen', 1039), ('Helene', 3928), ('Hikari', 122), ('Hilda', 10191), ('Himari', 3), ('Hiroko', 27580), ('Hirono', 4368), ('Ho Ching', 2371), ('Hollie', 24), ('Hongrui', 1063), ('Hortencia', 98), ('Hsin Yuan', 120), ('Hua Chen', 7367), ('Huijie', 118), ('Hulya', 7797), ('Hye Min', 1222), ('Hyojung', 870), ('Hyun Hui', 8301), ('I Hsuan', 511), ('Iana', 395), ('Ida', 467), ('Idia', 45), ('Iga', 916), ('Ilay', 52), ('Ilka', 1142), ('Ilona', 26950), ('Ilze', 1527), ('Imane Maelle', 1676), ('Ina', 292), ('Inci', 406), ('India', 762), ('Indire', 12633), ('Indy', 17382), ('Ineke', 1358), ('Ines', 40410), ('Inger', 221), ('Ingrid', 3471), ('Ingrid Alexandra', 4766), ('Ingrid Esperanza', 10133), ('Intissar', 33), ('Ioana', 1225), ('Ioana Diana', 2403), ('Ioana Loredana', 5425), ('Ionela Andreea', 6948), ('Ipek', 39352), ('Irena', 88369), ('Irene', 3133), ('Irina', 299698), ('Irina Camelia', 293366), ('Irina Maria', 13843), ('Iris', 4743), ('Iryna', 87844), ('Isabel', 6688), ('Isabela', 714), ('Isabella', 83476), ('Isabelle', 4777), ('Iulia Maria', 74), ('Iva', 10322), ('Ivana', 100848), ('Ivania', 2094), ('Ivanka', 291), ('Iveta', 443695), ('Ivette', 543), ('Ivone', 253), ('Ivonne', 13010), ('Jacqueline', 27462), ('Jada', 64), ('Jade', 26209), ('Jaeda', 1375), ('Jaimee', 5007), ('Jaimy Gayle', 24), ('Jainy', 761), ('Jamie', 190997), ('Jamilya', 18), ('Jan', 10947), ('Jana', 268372), ('Janette', 143422), ('Janina', 12525), ('Janja', 72), ('Janneke', 861), ('Jaqueline Adina', 5416), ('Jara', 464), ('Jarmila', 333150), ('Jasmin', 34453), ('Jasmina', 43862), ('Jasmine', 14865), ('Jasmine Amber', 142), ('Jawairiah', 822), ('Jazmin', 908), ('Jazzamay', 628), ('Jeannine', 3426), ('Jelena', 2515436), ('Jennifer', 81222), ('Jenny', 1002), ('Jesika', 17819), ('Jessica', 154599), ('Jessika', 4122), ('Jessy', 923), ('Ji Hee', 7179), ('Ji Young', 8592), ('Jia', 52), ('Jia Jing', 48117), ('Jia Qi', 4612), ('Jiahui', 1553), ('Jiakang', 15), ('Jiatian', 100), ('Jiaxi', 3002), ('Jiaxue', 96), ('Jie', 610820), ('Jil Belen', 13978), ('Jil Nora', 611), ('Jill', 359013), ('Jillian', 1991), ('Jin', 15), ('Jin A', 46355), ('Jin Ju', 414), ('Jing Jing', 68925), ('Joana', 1955), ('Joanna', 472), ('Joanne', 15), ('Jodie Anna', 355), ('Johana', 40), ('Johanna', 553107), ('Jordana', 1092), ('Josepha', 2710), ('Josephine', 4980), ('Josie', 804), ('Jovana', 39270), ('Ju Eun', 3453), ('Judith', 3), ('Jule', 63), ('Julia', 891796), ('Julia Mansano', 21), ('Juliana', 414), ('Juliana Rocha', 129), ('Julie', 156531), ('Julieta Lara', 4093), ('Julita', 286), ('Julyette Maria Josephine', 1446), ('June', 114), ('Junri', 128183), ('Justina', 36), ('Justine', 39418), ('Justyna', 30304), ('Kady', 467), ('Kai Chen', 172004), ('Kai Lin', 37817), ('Kaia', 625836), ('Kaitlin', 416), ('Kaitlyn', 3905), ('Kaja', 1176), ('Kajsa', 2280), ('Kamila', 12906), ('Kamilla', 249), ('Kamonwan', 5866), ('Kana', 1536), ('Kanae', 20142), ('Kanako', 229), ('Kanami', 3724), ('Kanika', 919), ('Kaori', 8406), ('Karen', 32169), ('Kariann', 85), ('Karin', 254520), ('Karina', 9355), ('Karina Ildor', 5493), ('Karina Kristina', 410), ('Karine', 1936), ('Karis', 1003), ('Karla', 3127), ('Karman', 3193), ('Karola Patricia', 776), ('Karolayne', 465), ('Karolina', 512490), ('Karoline', 910), ('Karyn', 330), ('Kassandra', 704), ('Katalin', 112562), ('Katarina', 444303), ('Katarzyna', 93730), ('Kate', 34), ('Katerina', 160945), ('Kateryna', 435038), ('Katharina', 24595), ('Katharine', 363), ('Katherine', 7843), ('Katherine Gabriela', 1894), ('Kathinka', 15970), ('Kathrin', 141281), ('Katie', 30035), ('Katrine Isabel', 308), ('Katy', 11572), ('Katya', 515), ('Katyarina', 97), ('Kayla', 13697), ('Kaylah', 237), ('Kazusa', 10107), ('Kei', 294), ('Kelia', 324), ('Kelly', 4705), ('Kelly S', 5880), ('Kelsey', 410), ('Kennedy', 653), ('Keren', 24062), ('Keri', 894), ('Kerstin', 942), ('Khristina', 3748), ('Ki Ryang', 86), ('Kiki', 214121), ('Kim', 4580), ('Kim Alice', 12388), ('Kimberley', 5393), ('Kimberly', 4831), ('Kimika', 272), ('Kimiko', 270102), ('Kinnie', 15102), ('Kirsten', 383077), ('Kirsten Andrea', 462), ('Klaartje', 5818), ('Klara', 568191), ('Klaudia', 4809), ('Komola', 701), ('Korina', 21417), ('Kotomi', 4962), ('Krista', 17577), ('Kristie', 34647), ('Kristina', 601693), ('Kristina N', 555), ('Kristy', 1899), ('Kristyna', 148728), ('Ksenia', 371140), ('Kseniia', 298), ('Ksenija', 625), ('Kumiko', 56212), ('Kurumi', 177170), ('Kveta', 210101), ('Kwan Yau', 403), ('Kyle', 3200), ('Kylie', 1236), ('Kyoka', 9036), ('Kyra', 102022), ('Kyung Mi', 26059), ('Laetitia', 6078), ('Laili', 595), ('Lamis', 456), ('Lara', 177458), ('Larikah', 255), ('Laura', 578964), ('Laura D', 281), ('Laura Ioana', 33822), ('Laura Sofia', 97), ('Lauren', 244807), ('Lauryn', 207), ('Lavinia', 23897), ('Laylo', 39), ('Layne', 22), ('Lea', 4197), ('Leah', 152), ('Lee', 733), ('Lena', 27997), ('Lena Marie', 14942), ('Lenka', 164900), ('Leolia', 750), ('Leonie', 672), ('Lesedi Sheya', 286), ('Lesia', 225987), ('Lesley', 42925), ('Leslie', 173), ('Leticia', 45115), ('Leticia Garcia', 87), ('Leylah Annie', 48), ('Li', 1696), ('Liana Gabriela', 59997), ('Libby', 2362), ('Libi', 522), ('Lidia', 169), ('Lidziya', 6809), ('Liezel', 39782), ('Liga', 23411), ('Lilla', 1960), ('Lin', 40341), ('Lina', 91117), ('Linda', 4216), ('Lindsay', 142454), ('Lindsey', 500), ('Ling', 64525), ('Liniques', 72), ('Linnea', 697), ('Lisa', 594217), ('Lisa Maria', 7898), ('Lisa Marie', 1583), ('Lisanne', 8284), ('Liubov', 2662), ('Livia', 128), ('Liz Tatiane', 2216), ('Lizaveta', 135), ('Lizette', 11623), ('Lorenza', 33), ('Lorraine M', 40), ('Lou', 10167), ('Loudmilla', 6), ('Louisa', 50700), ('Louise', 1633), ('Lourdes', 371035), ('Lu', 3445), ('Luca', 1013), ('Lucia', 17185), ('Luciana', 8305), ('Lucie', 1108372), ('Lucrezia', 1589), ('Lucy', 6542), ('Ludmila', 645), ('Ludmilla', 1187), ('Luisa', 1671), ('Luisa Marie', 1822), ('Luksika', 77519), ('Lulu', 304), ('Luna', 15), ('Lusine', 377), ('Lutfiye', 876), ('Lyann', 30), ('Lynn', 837), ('Lyudmyla', 54172), ('Macall', 12379), ('Macarena', 2133), ('Madalina', 62938), ('Maddison', 2434), ('Madeleine', 715), ('Madeline', 147), ('Madina', 6), ('Madison', 476768), ('Madrie', 2266), ('Maegan', 525), ('Mafalda', 163), ('Maftuna', 54), ('Magali', 1917), ('Magalie', 511), ('Magda', 103659), ('Magdalena', 401857), ('Magy', 756), ('Mahak', 154), ('Mahitha', 395), ('Mai', 19173), ('Maia', 1235), ('Maia A', 12), ('Maiko', 11320), ('Maileen', 83), ('Mailen', 39523), ('Maja', 1067), ('Makiho', 5592), ('Makoto', 14129), ('Malene', 316), ('Malika', 323), ('Malin', 2489), ('Mallaurie', 688), ('Mallory', 44497), ('Malou', 3073), ('Mami', 96), ('Man Ying Maggie', 102), ('Mana', 9593), ('Mananchaya', 15), ('Manca', 2070), ('Mandy', 193767), ('Manisha', 3112), ('Manon', 14608), ('Manya', 93), ('Mara', 702), ('Marcela', 16790), ('Marcela Guimaraes', 683), ('Marcelina', 33), ('Marcella', 13037), ('Margalita', 99836), ('Margarida', 1997), ('Margarita', 78265), ('Margaux', 905), ('Margot', 4787), ('Mari', 38086), ('Maria', 3613355), ('Maria Agustina', 185), ('Maria Andrea', 323), ('Maria Camila', 148), ('Maria Constanza De Las Mercedes', 1892), ('Maria Del Rosario', 296), ('Maria Elena', 296736), ('Maria Fernanda', 141257), ('Maria Jesus', 294), ('Maria Joao', 72682), ('Maria Jose', 413759), ('Maria Lourdes', 156), ('Maria Paulina', 1388), ('Maria Teresa', 106375), ('Mariam', 4060), ('Mariana', 201258), ('Marianna', 10178), ('Marianne', 1090), ('Mariaryeni', 226), ('Marie', 25496), ('Marie Eve', 114687), ('Mariia', 206), ('Marija', 20481), ('Marijana', 3), ('Marina', 362372), ('Marine', 4314), ('Marion', 1272285), ('Mariona', 4), ('Marisa', 1026), ('Mariya', 154484), ('Marketa', 18286), ('Marlies', 1624), ('Marrit', 1339), ('Marta', 267679), ('Marta Huqi', 778), ('Martha', 153), ('Martina', 109192), ('Mary', 653), ('Mary Ann', 102), ('Maryna', 85425), ('Masa', 117472), ('Mathilde', 245139), ('Matilda', 3466), ('Maud', 210), ('Maureen', 219), ('Maurien', 138), ('Maxine', 390), ('May', 225), ('Maya', 23668), ('Mayar', 1788), ('Mayo', 32445), ('Mayya', 9064), ('Megan', 13254), ('Megumi', 407), ('Mei Xu', 40), ('Meiling', 417), ('Meiqi', 96), ('Melanie', 385636), ('Melany Solange', 97), ('Melina', 2609), ('Melinda', 290299), ('Melis', 20196), ('Melisa', 340), ('Melissa', 200), ('Melissa Ishuan', 171), ('Meng Ning', 542), ('Mercedes', 48), ('Merel', 101), ('Meritxell', 284), ('Mervana', 102693), ('Mi', 24569), ('Mi Jeong', 176), ('Mi Rae', 1858), ('Mi Zhuoma', 72), ('Mia Nicole', 1098), ('Micaela', 230), ('Michaela', 76586), ('Michaella', 242619), ('Michela', 90), ('Michele Alexandra', 596), ('Michelle', 160164), ('Michika', 3657), ('Mihaela', 69242), ('Mihaela Lorena', 15), ('Miharu', 21205), ('Mihika', 427), ('Mihoki', 201), ('Miki', 24542), ('Mila', 107), ('Milagros', 42), ('Milana', 14123), ('Milena', 279), ('Milica', 63), ('Min', 1884), ('Min Hwa', 9938), ('Minami', 96), ('Mira', 1626), ('Mirabelle', 1977), ('Miranda', 180), ('Miriam', 3825), ('Miriam Bianca', 1458), ('Miriana', 1180), ('Mirjam', 272), ('Mirjana', 331434), ('Misa', 55981), ('Misaki', 203782), ('Mitsumi', 309), ('Miyabi', 22840), ('Miyu', 23968), ('Mizuno', 2927), ('Molly', 565), ('Momoko', 2061), ('Mona', 282445), ('Monica', 587309), ('Monika', 1240), ('Monique', 114104), ('Montserrat', 23564), ('Morgane', 6906), ('Moulika', 15), ('Mouna', 12), ('Moyuka', 32), ('Muazzez', 6), ('Muge', 162), ('Myrtille', 43550), ('Na', 1358928), ('Na Lae', 26185), ('Na Ri', 19223), ('Nadezda', 5027), ('Nadia', 1401125), ('Nadiya', 56596), ('Nadja', 2661), ('Nagi', 1535), ('Naiktha', 4380), ('Naima', 440), ('Nam Yeon', 259), ('Nan Nan', 3094), ('Nanuli', 16494), ('Nao', 59671), ('Naoko', 857), ('Naomi', 163239), ('Napatsakorn', 1945), ('Nastassia', 72), ('Nastassja', 65152), ('Nastja', 29250), ('Natalia', 97400), ('Natalie', 120995), ('Natalija', 13686), ('Nataliya', 33), ('Natasa', 14212), ('Natasha', 15365), ('Natela', 16303), ('Natella', 649), ('Nathalia', 28098), ('Nathaly', 13241), ('Natia', 2526), ('Natsumi', 37981), ('Nattawadee', 224), ('Naz', 251), ('Nazari', 980), ('Neda', 9536), ('Nelise', 142), ('Nermeen', 279), ('Nevena', 170), ('Nicha', 30972), ('Nicky', 2531), ('Nicola', 33550), ('Nicole', 447434), ('Nicoleta Catalina', 8146), ('Nicolette', 9627), ('Nidhi', 5425), ('Nigina', 47651), ('Nika', 9120), ('Nikita', 22), ('Nikki', 614), ('Nikol', 491), ('Nikola', 78513), ('Nina', 201173), ('Nina Isabella', 115), ('Nives', 2706), ('Noel', 1558), ('Noelia', 2025), ('Noelle', 1795), ('Nonna', 134), ('Noppawan', 73589), ('Nora', 1082), ('Nour', 760), ('Nozomi', 1333), ('Nudnida', 63013), ('Nungnadda', 24523), ('Nuria', 259116), ('Oana', 1096), ('Oana Georgeta', 4294), ('Oceane', 56853), ('Ofri', 5372), ('Oksana', 58279), ('Ola', 3497), ('Olawaseun', 2), ('Olaya', 40), ('Oleksandra', 8700), ('Olena', 484), ('Olesya', 3811), ('Olga', 773929), ('Olivia', 119756), ('Oliwia', 363), ('Ons', 56242), ('Ornella', 2133), ('Oyku', 382), ('Paige Mary', 147), ('Pamela', 241), ('Panna', 1446), ('Paola', 403127), ('Parris', 209), ('Patcharin', 1188), ('Patricia', 197904), ('Patricia Maria', 43755), ('Patrycja', 17514), ('Patty', 7323), ('Paula', 172431), ('Paula Andrea', 269), ('Paula Catalina', 3714), ('Paula Cristina', 37384), ('Paulina', 3208), ('Pauline', 313187), ('Pavla', 4128), ('Peangtarn', 26280), ('Peggy', 1016), ('Pei Chi', 8900), ('Pei Hsuan', 24), ('Pei Ju', 181), ('Pemra', 60908), ('Pernilla', 6573), ('Petia', 1832), ('Petra', 1958404), ('Phenomena', 3), ('Phillis', 664), ('Pia', 10859), ('Piia', 21340), ('Pilar', 6404), ('Pippa', 243), ('Plobrung', 934), ('Polina', 76747), ('Polona', 325216), ('Poojashree', 13006), ('Pranjala', 1214), ('Prarthana G', 5687), ('Prerna', 9318), ('Priscila', 510), ('Priscilla', 8203), ('Qiang', 116857), ('Qianhui', 683), ('Qianqian', 641), ('Qiu Yu', 2034), ('Quinn', 646), ('Quirine', 22978), ('Rachael', 2592), ('Rachel', 469), ('Radina', 699), ('Rafaela', 228), ('Ralina', 40), ('Raluca', 148701), ('Raluca Elena', 9202), ('Raluca Georgiana', 4258), ('Ramu', 443), ('Ramya', 161), ('Ran', 14709), ('Rana', 9), ('Raquel', 30401), ('Rashmi', 741), ('Ratnika', 957), ('Raveena', 5387), ('Rebeca', 168), ('Rebecca', 165013), ('Rebeka', 5803), ('Regina', 122331), ('Reina', 64), ('Reka Luca', 66271), ('Remi', 38116), ('Renata', 201856), ('Ria', 5566), ('Rianna', 984), ('Richel', 84184), ('Rika', 141257), ('Riko', 23195), ('Rio', 556), ('Risa', 62252), ('Rishika', 8448), ('Rita', 1401), ('Riya', 2634), ('Roberta', 809611), ('Robin', 12295), ('Robyn', 1103), ('Rocio', 16886), ('Romana', 29214), ('Romana Caroline', 17020), ('Romina', 253471), ('Romy', 911), ('Rona', 308), ('Ronit', 3165), ('Ronke', 49), ('Roosh', 28), ('Rosa', 111), ('Rosalia', 803), ('Rosalie', 880), ('Rosie', 336), ('Roxane', 38793), ('Rui', 24), ('Rushmi', 27452), ('Rutuja', 3642), ('Ryann', 597), ('Saana', 195), ('Sabastiani', 780), ('Sabina', 49784), ('Sabina Elena', 27), ('Sabine', 590911), ('Sabrina', 6810), ('Sacha', 78204), ('Sachia', 49767), ('Sachie', 42676), ('Sadafmoh', 2275), ('Sai Samhitha', 1034), ('Saisai', 113359), ('Sakiko', 9338), ('Sally', 53480), ('Salma', 66), ('Samantha', 1437656), ('Samira', 2020), ('Sanae', 354), ('Sanaz', 17975), ('Sandra', 266197), ('Sandy', 224), ('Sang Hee', 1277), ('Sania', 272889), ('Sara', 914981), ('Sarah', 78461), ('Sarah Beth', 1270), ('Sarah Rebecca', 13064), ('Sarahi', 461), ('Sarai Delfina', 148), ('Saray', 2061), ('Sari', 464), ('Sarlota', 27), ('Sarvinoz', 178), ('Sasa', 316), ('Saska', 2641), ('Satsuki', 906), ('Savannah', 70), ('Schena', 148), ('Se Hyun', 143), ('Se Jin', 681), ('Sean', 75), ('Seda', 1469), ('Seira', 144), ('Selin', 169), ('Seo Kyung', 6564), ('Seone', 1312), ('Serena', 4232828), ('Sesil', 208108), ('Seung Yeon', 6650), ('Severine', 192296), ('Shahar', 662926), ('Shakhlo', 2122), ('Shakhnoza', 198), ('Shangqing', 111), ('Shanshan', 2378), ('Shao Yuan', 1363), ('Sharmada', 4106), ('Sharon', 117825), ('Sharon Sanchana', 522), ('Shelby', 102140), ('Shelly', 142), ('Sheng Nan', 53610), ('Sherazad', 22977), ('Sherry', 801), ('Shiho', 39960), ('Shilin', 9634), ('Shiori', 18), ('Shir', 117), ('Shiran', 236), ('Shivika', 4611), ('Shou Na', 105), ('Shreya', 6), ('Shu Ying', 1483), ('Shuai', 913829), ('Shuko', 46124), ('Shuo', 597), ('Shuyue', 336), ('Shweta', 3255), ('Si Qi', 531), ('Silvia', 221695), ('Simona', 724638), ('Simone', 1149), ('Simran Kaur', 467), ('Sina', 10360), ('Sinead', 688), ('Sing Le', 95), ('Siqi', 716), ('Sirui', 276), ('Siyu', 87), ('Sloane', 352458), ('Smriti', 96), ('Sneha', 134), ('Snehadevi S', 2820), ('So Jung', 47282), ('So Ra', 18210), ('Sofia', 484140), ('Sofico', 336), ('Sofie', 10539), ('Sofiya', 18371), ('Sofya', 9180), ('Sohyun', 108), ('Sonia', 480), ('Sonja', 4499), ('Sophia', 96), ('Sophie', 39307), ('Sorana', 457043), ('Sowjanya', 2961), ('Spurti', 159), ('Sri Vaishnavi', 1744), ('Stamatia', 8072), ('Stanislava', 49412), ('Stefana', 497), ('Stefani', 126), ('Stefania', 24897), ('Stefanie', 247237), ('Steffi', 3085), ('Stephanie', 608309), ('Stephanie Mariel', 1397), ('Storm', 21152), ('Su Jeong', 33672), ('Su Wei', 274936), ('Suellen', 320), ('Sultan', 1544), ('Sun Jung', 6591), ('Sunae', 15), ('Sunam', 3594), ('Sung Hee', 29852), ('Susan', 502), ('Susanne', 16276), ('Suzan', 344), ('Suzuho', 324), ('Suzy', 1054), ('Svenja', 6341), ('Svetlana', 1906587), ('Sviatlana', 11201), ('Sybille', 581), ('Sylvia', 1626), ('Sylwia', 8268), ('Syna', 9001), ('Szabina', 2127), ('Tadeja', 83659), ('Taisiya', 1050), ('Talya', 45), ('Tamachan', 843), ('Tamar', 60), ('Tamara', 54140), ('Tamari', 304), ('Tamarine', 594281), ('Tamaryn', 40060), ('Tamira', 322202), ('Tammi', 26077), ('Tanaporn', 764), ('Tanya', 1229), ('Tara', 54798), ('Tatia', 42), ('Tatiana', 34795), ('Tatjana', 230262), ('Tatsiana', 1289), ('Tayisiya', 5051), ('Taylor', 38850), ('Tea', 2127), ('Teliana', 112570), ('Tena', 12402), ('Teodora', 41792), ('Tereza', 193362), ('Terri', 18), ('Tess', 7165), ('Tessah', 9116), ('Tetiana', 75337), ('Tetyana', 43020), ('Thai Sa Grana', 706), ('Theo', 2249), ('Theresa', 377), ('Tijana', 333), ('Timea', 612072), ('Tina', 57585), ('Tinatin', 476), ('Ting Fei', 8145), ('Ting Jr', 8676), ('Tingting', 151), ('Tjasa', 3361), ('Tomoko', 7431), ('Tori', 10630), ('Tornado Alicia', 1864), ('Trang', 1884), ('Treta', 736), ('Tsvetana', 456422), ('Tyra', 4543), ('Ulrikke', 27118), ('Ulyana', 2400), ('Urszula', 275255), ('Ushna', 413), ('Usue Maitane', 7874), ('Valentina', 338), ('Valentine', 9926), ('Valentini', 15198), ('Valentyna', 47854), ('Valeria', 159155), ('Valerie', 6146), ('Valeriya', 16621), ('Vanda', 10087), ('Vanesa', 30669), ('Vanessa', 71645), ('Vania', 299530), ('Vaniya', 255), ('Vanja', 291), ('Varatchaya', 54340), ('Varunya', 3623), ('Varvara', 401409), ('Vasilisa', 42527), ('Vaszilisza', 3763), ('Vendula', 2221), ('Venus', 2875425), ('Vera', 1929137), ('Verena', 3018), ('Veronica', 84543), ('Veronica M', 1678), ('Veronika', 73192), ('Vesna', 169500), ('Vicky', 77), ('Victoire', 454), ('Victoria', 2142854), ('Victoria Ariadna', 106), ('Viktoria', 30191), ('Viktoriia', 90), ('Viktorija', 79511), ('Viktoriya', 26226), ('Viktoryia', 1987), ('Vilma Y', 27), ('Vincenza', 105), ('Vinciane', 37), ('Violetta', 298), ('Virginie', 519208), ('Vishesh', 71), ('Vita', 64), ('Vitalia', 106927), ('Vivian', 36714), ('Vivien', 13041), ('Vivienne', 8918), ('Vlada', 22578), ('Vladica', 997), ('Vladimira', 6470), ('Vladislava', 1254), ('Vladyslava', 2570), ('Vojislava', 18781), ('Voni', 1036), ('Wan Ting', 11653), ('Wan Yi', 42), ('Warona', 9), ('Wen Hsin', 40633), ('Wen Ling', 120), ('Wendy Qi Wen', 613), ('Weronika Jasmina', 179), ('Whitney', 5604), ('Wiktoria', 363), ('Wing Yau Venise', 11694), ('Wushuang', 879), ('Xenia', 14578), ('Xi Yao', 1445), ('Xiao', 4789), ('Xiaodi', 5057), ('Xiaorong', 717), ('Xiaoxi', 1352), ('Ximena', 19495), ('Xin', 8744), ('Xin Yu', 187), ('Xinyu', 10705), ('Xinyun', 109256), ('Xiyu', 315), ('Xu Liu', 4535), ('Ya', 24), ('Ya Hsuan', 17078), ('Yafan', 39687), ('Yan', 4196), ('Yana', 39102), ('Yang', 73), ('Yanina', 602453), ('Yanni', 275), ('Yarden', 32), ('Yaroslava', 404915), ('Yasmin', 11251), ('Yasmina', 27), ('Yasmine', 1748), ('Yasmyn', 71), ('Yawna', 648), ('Yayuk', 128509), ('Ye Ra', 47867), ('Ye Xin', 281), ('Yekaterina', 376), ('Yelena', 1856), ('Yeong Won', 966), ('Yevgeniya', 6288), ('Yi', 19989), ('Yi Fan', 60646), ('Yi Jing', 22443), ('Yi Miao', 61839), ('Yidi', 136), ('Yihong', 24), ('Yijia', 366), ('Ying', 3783), ('Ying Ying', 107595), ('Yixuan', 1380), ('Ylena', 1546), ('Ylona Georgiana', 1453), ('Yoko', 285), ('Yolande', 1381), ('Yoo Ri', 182), ('Yoon Young', 3592), ('Yoshimi', 677), ('Yosr', 75), ('You Na', 242), ('Ysaline', 27804), ('Yu Jin', 452), ('Yu Tong', 9), ('Yuan', 281), ('Yuanyi', 772), ('Yue', 1259), ('Yue Yue', 21360), ('Yuenu', 682), ('Yujia', 184), ('Yuka', 12474), ('Yukako', 84), ('Yuki', 505), ('Yuki Kristina', 2191), ('Yukina', 998), ('Yukun', 1828), ('Yulia', 155143), ('Yuliana', 15248), ('Yuliya', 206375), ('Yumi', 20269), ('Yung Jan', 229391), ('Yuqi', 559), ('Yurika', 101816), ('Yuriko', 1728), ('Yurina', 12693), ('Yuuki', 15071), ('Yuval', 45), ('Yuxuan', 24279), ('Yvonne', 254491), ('Zaineb', 87), ('Zalina', 2052), ('Zarah', 3809), ('Zarina', 123243), ('Zeel', 702), ('Zeynep  Sena', 21), ('Zhanlan', 2166), ('Zhaoxuan', 20236), ('Zhibek', 7), ('Zhima', 99), ('Zhou', 30), ('Zhuoma', 121), ('Zi', 110290), ('Zinovia', 74), ('Ziyue', 1420), ('Zoe', 2772), ('Zoe Gwen', 2877), ('Zsofia', 1501), ('Zuzana', 266251), ('Zuzanna', 2258)]","[(68, 'Aastha'), (304, 'Abbi'), (5214, 'Abbie'), (115293, 'Abigail'), (120, 'Abiodun'), (72, 'Abir'), (490, 'Adeliya'), (219, 'Adnya'), (28045, 'Adriana'), (107, 'Adrienn'), (4619, 'Adrijana'), (9, 'Adva'), (156, 'Afroditi'), (1901, 'Agata'), (219, 'Agata Jadwiga'), (110, 'Agne'), (390148, 'Agnes'), (13717, 'Agnese'), (2929, 'Agni'), (1801033, 'Agnieszka'), (21728, 'Agustina'), (158, 'Agustina Elena'), (141, 'Ah'), (85, 'Ahlam'), (52, 'Ahsha'), (10751, 'Ai'), (2217, 'Ai Wen'), (703, 'Aida'), (140108, 'Aiko'), (288, 'Ailen'), (226, 'Aimee'), (92, 'Aina'), (2433, 'Ainhoa'), (96, 'Aishwarya'), (116548, 'Ajla'), (11873, 'Akari'), (228538, 'Akgul'), (14838, 'Aki'), (83, 'Akiho'), (84446, 'Akiko'), (742, 'Akilah'), (640, 'Akvile'), (385, 'Alana'), (1424, 'Alba'), (238803, 'Alberta'), (10507, 'Albina'), (71, 'Aldana'), (1578, 'Alejandra'), (451414, 'Aleksandra'), (35957, 'Aleksandrina'), (8832, 'Alena'), (235, 'Alessandra'), (2524, 'Alessia'), (265, 'Alessondra'), (138782, 'Alexa'), (955267, 'Alexandra'), (191, 'Alexandria'), (12829, 'Alexia'), (13389, 'Alexis'), (61196, 'Aliaksandra'), (57745, 'Alice'), (2358, 'Alice Andrada'), (993, 'Alicia'), (5216, 'Alicja'), (11393, 'Alina'), (2369, 'Aliona'), (369810, 'Alisa'), (323527, 'Alison'), (5422, 'Alix'), (596901, 'Alize'), (253320, 'Alla'), (33054, 'Allie'), (206, 'Almudena'), (4052, 'Alona'), (155, 'Alory Regina Elorriaga'), (25183, 'Alyona'), (68207, 'Amanda'), (41575, 'Amandine'), (887, 'Amelie'), (1990, 'Amina'), (12708, 'Aminat'), (157, 'Amira'), (60702, 'Amra'), (159, 'Amrita'), (10616, 'Amy'), (51803, 'An Sophie'), (1589674, 'Ana'), (2421, 'Ana Bianca'), (36696, 'Ana Clara'), (288, 'Ana Gabriela'), (21, 'Ana Luisa'), (2141, 'Ana Paula'), (15955, 'Ana Sofia'), (1367, 'Ana Victoria'), (678793, 'Anabel'), (1962, 'Anaeve'), (46908, 'Anais'), (2338, 'Anamika'), (1433335, 'Anastasia'), (1235, 'Anastasia Evgenyevna'), (12, 'Anastasiia'), (268277, 'Anastasija'), (75850, 'Anastasiya'), (101, 'Anca'), (160, 'Anda'), (605, 'Andie K'), (228, 'Andjela'), (51, 'Andra Maria'), (920433, 'Andrea'), (464, 'Andrea Renee'), (1484, 'Andreea'), (1365, 'Andreea Amalia'), (12727, 'Andreea Roxana'), (74453, 'Andreja'), (72, 'Andressa Cristina'), (159, 'Andrina'), (202, 'Aneta'), (71072, 'Anett'), (1657, 'Anette'), (36, 'Ange Oby'), (245, 'Angela'), (13643, 'Angelica'), (677, 'Angeliki'), (19048, 'Angelina'), (1132514, 'Angelique'), (17967, 'Anhelina'), (836, 'Anhzelika'), (48811, 'Ani'), (2177, 'Anita'), (11596, 'Anja'), (54, 'Anke'), (21599, 'Ankita'), (62, 'Ann'), (1017069, 'Anna'), (6650, 'Anna Arina'), (49207, 'Anna Giulia'), (107880, 'Anna Karolina'), (907, 'Anna Katalina'), (359374, 'Anna Lena'), (1427, 'Anna Maria'), (29442, 'Annalisa'), (647811, 'Anne'), (5269, 'Anne Liz'), (99, 'Anne Marie'), (33, 'Anne Sophie'), (172, 'Annie'), (169371, 'Annika'), (3621, 'Anouk'), (280, 'Antonela'), (21624, 'Antonia'), (484, 'Antonina'), (480, 'Anushka'), (4941, 'Ao'), (126, 'Apichaya'), (11608, 'Arabela'), (434692, 'Arantxa'), (24184, 'Aranza'), (383495, 'Aravane'), (980, 'Ariadna'), (96852, 'Arina'), (3, 'Arina Gabriela'), (154, 'Arlinda'), (39, 'Arthi'), (19446, 'Aryna'), (238, 'Aselya'), (99, 'Asha'), (58741, 'Ashleigh'), (49980, 'Ashley'), (5155, 'Ashling'), (648, 'Ashmitha'), (2321, 'Ashvarya'), (48788, 'Asia'), (802, 'Asiya'), (141, 'Assia'), (1083, 'Astra'), (269, 'Astrid Wanja'), (33624, 'Audrey'), (21, 'Avgusta'), (7, 'Axana'), (7996, 'Ayaka'), (571, 'Ayan'), (5173, 'Ayano'), (7444, 'Ayla'), (791, 'Aymet'), (38501, 'Ayu Fani'), (309990, 'Ayumi'), (11721, 'Azra'), (53401, 'Barbara'), (515957, 'Barbora'), (26624, 'Basak'), (27061, 'Beatrice'), (98798, 'Beatriz'), (75, 'Beatriz Magdalena'), (1920, 'Beatriz Maria'), (26, 'Beauty'), (351, 'Belen'), (137327, 'Belinda'), (11032, 'Benedetta'), (2850, 'Berfu'), (8441, 'Bermet'), (19092, 'Bernarda'), (3894, 'Bernice'), (814, 'Berta'), (371662, 'Bethanie'), (21, 'Betina'), (1152, 'Bhuvana'), (63998, 'Bianca'), (1213, 'Bianka'), (50184, 'Bibiane'), (905, 'Blair'), (312, 'Blanca'), (662, 'Blessing'), (123, 'Boba'), (283166, 'Bojana'), (3470, 'Borislava'), (1465, 'Boyan'), (725, 'Brandy'), (676, 'Breaunna'), (166760, 'Brenda'), (2922, 'Brianna'), (12, 'Brienne'), (30, 'Brindtha'), (2487, 'Britt'), (1119, 'Brittany'), (7062, 'Brooke'), (1344, 'Brynn'), (3187, 'Bunyawi'), (537, 'Busra'), (119797, 'Cagla'), (15218, 'Caitlin'), (9147, 'Camelia Elena'), (38, 'Cameron'), (202172, 'Camila'), (136, 'Camila Vital'), (11714, 'Camilla'), (574, 'Camille'), (240762, 'Cara'), (90451, 'Carina'), (669546, 'Carla'), (27, 'Carlota'), (562, 'Carlotta'), (67459, 'Carly'), (8174, 'Carmen'), (1077, 'Carmen Raluca'), (14213, 'Carol'), (9093, 'Carolin'), (36889, 'Carolina'), (3627, 'Carolina Meligeni Rodrigues'), (2076949, 'Caroline'), (111, 'Caroline B'), (72, 'Carolyn'), (289, 'Carson'), (202697, 'Casey'), (250056, 'Catalina'), (4987, 'Catherine'), (45884, 'Catherine Cartan'), (22, 'Caty'), (11954, 'Cecilia'), (95, 'Cecilie Lundgaard'), (18824, 'Celine'), (958, 'Cemre'), (4914, 'Chalena'), (62861, 'Chanel'), (275364, 'Chanelle'), (26585, 'Chang'), (39, 'Chanikarn'), (15001, 'Chantal'), (187, 'Chantelle'), (15, 'Chaoyi'), (5683, 'Charlene'), (4356, 'Charlotte'), (20132, 'Chayenne'), (5, 'Chelsea'), (6777, 'Chelsey'), (26779, 'Chen'), (277, 'Chengyiyi'), (49122, 'Chi Chi'), (667, 'Chi Fan'), (679, 'Chia Hsien'), (33301, 'Chia Jung'), (42773, 'Chiaki'), (6159, 'Chiara'), (34796, 'Chieh Yu'), (15401, 'Chihiro'), (70504, 'Chin Wei'), (13141, 'Chinami'), (7975, 'Ching Wen'), (1726, 'Chiraz'), (358, 'Chisa'), (15190, 'Chloe'), (276, 'Chompoothip'), (24, 'Christie'), (310215, 'Christina'), (2438, 'Christine'), (12519, 'Chun Mei'), (3374, 'Chun Yan'), (31620, 'Cindy'), (141876, 'Claire'), (116, 'Clara'), (32581, 'Claudia'), (1227, 'Claudia Antonia'), (934, 'Claudia Gianina'), (106762, 'Claudine'), (2221, 'Clelia'), (1622, 'Clemence'), (538, 'Clementina Eugenia'), (12304, 'Clothilde'), (235721, 'Coco'), (129, 'Colomba'), (52274, 'Conny'), (25166, 'Constance'), (907, 'Constanza'), (18, 'Constanze'), (1002, 'Corina'), (102260, 'Corinna'), (4053, 'Cornelia'), (20869, 'Cory Ann'), (1236, 'Costanza'), (7486, 'Cristiana'), (59412, 'Cristina'), (75414, 'Cristina Andreea'), (317, 'Cristina Madalina'), (6256, 'Csilla'), (1034, 'Cynthia'), (1417, 'Da Hye'), (1261, 'Dabin'), (160, 'Dagmara'), (8589, 'Daiana'), (150, 'Dajana'), (8939, 'Dalia'), (48857, 'Dalila'), (15935, 'Dalma'), (0, 'Damilola'), (12, 'Damini'), (30, 'Damira'), (639, 'Dan Ni'), (3121, 'Dana'), (1607, 'Daneika'), (17597, 'Danica'), (1165205, 'Daniela'), (16663, 'Daniella'), (40823, 'Danielle'), (8507, 'Danielle Rose'), (545, 'Danijela'), (87958, 'Danka'), (33, 'Daphne'), (170617, 'Daria'), (41925, 'Darija'), (857, 'Dariya'), (163036, 'Darya'), (1923, 'Dasha'), (5619, 'Dayana'), (7027, 'Dea'), (7605, 'Deborah'), (141, 'Deeon'), (9846, 'Dejana'), (1192, 'Demi'), (65522, 'Denisa'), (3298, 'Denise'), (168, 'Denise Antonela'), (23620, 'Deniz'), (215, 'Deria'), (354, 'Desirae'), (709, 'Desiree'), (19065, 'Despina'), (3942, 'Despoina'), (9227, 'Destanee'), (134, 'Dewi'), (2738, 'Dhruthi'), (9780, 'Di'), (79958, 'Dia'), (119279, 'Diana'), (99, 'Diana Maria'), (6369, 'Dianne'), (7353, 'Dijana'), (85, 'Dilara'), (149, 'Dina'), (67017, 'Dinah'), (117, 'Doga Selen'), (1614, 'Domenica'), (918746, 'Dominika'), (455, 'Dominique'), (164, 'Donika'), (114098, 'Donna'), (109, 'Dorien'), (23976, 'Doroteja'), (392, 'Draginja'), (4703, 'Dunja'), (713, 'Ebony'), (1978, 'Eden'), (249446, 'Edina'), (11216, 'Eduarda'), (2446, 'Eetee'), (50, 'Ege'), (1005319, 'Ekaterina'), (26897, 'Ekaterine'), (103, 'Elaine'), (2287, 'Eleanor'), (1247887, 'Elena'), (7772, 'Elena Gabriela'), (6547, 'Elena Teodora'), (439179, 'Eleni'), (405, 'Eleonora'), (567, 'Eleonore'), (882, 'Eliessa'), (314747, 'Elina'), (4709, 'Elisabeth'), (43779, 'Elise'), (87263, 'Elitsa'), (18211, 'Elixane'), (480, 'Eliza'), (536, 'Elizabeta'), (20368, 'Elizabeth'), (1103, 'Elizabeth Anita Alexandria'), (62977, 'Elizaveta'), (636, 'Elizaveta Anna'), (960, 'Elke'), (526, 'Ella'), (13761, 'Ellen'), (8079, 'Ellie'), (90, 'Elodie'), (12554, 'Elyne'), (11218, 'Ema'), (12728, 'Emelyn'), (3880, 'Emi'), (43, 'Emilia'), (1258, 'Emiliana'), (1440, 'Emilie'), (24, 'Emilija'), (541, 'Emiliya'), (52889, 'Emily'), (964, 'Emily J'), (3029, 'Emina'), (85022, 'Emma'), (65, 'Emma Christine'), (1609, 'Emmanuelle'), (52, 'En Pei'), (823, 'Ena'), (34570, 'Eri'), (472, 'Erica'), (165477, 'Erika'), (5356, 'Erin'), (1225, 'Erina'), (69, 'Esen'), (376, 'Estela'), (39989, 'Estelle'), (3908, 'Ester'), (126811, 'Estrella'), (7147, 'Etsuko'), (976, 'Eudice Wong'), (36, 'Eugenia'), (204801, 'Eugenie'), (20989, 'Eugeniya'), (320083, 'Eva'), (41, 'Eva Marie'), (744, 'Eveliina'), (27011, 'Evelyn'), (59775, 'Evgenia'), (206981, 'Evgeniya'), (7755, 'Fang Ying'), (33388, 'Fangzhou'), (11260, 'Fanny'), (167, 'Farah'), (10865, 'Fatima'), (898, 'Fatimah'), (21261, 'Fatma'), (80, 'Fatyha'), (56817, 'Federica'), (44, 'Federica Joe'), (17587, 'Fernanda'), (78, 'Ferny'), (18219, 'Fiona'), (1011058, 'Flavia'), (89361, 'Florencia'), (359, 'Frances'), (1306087, 'Francesca'), (157, 'Francisca'), (21685, 'Francoise'), (994, 'Franziska'), (9, 'Frederikke'), (6525, 'Freya'), (102623, 'Gabriela'), (468, 'Gabriela Nicole'), (6179, 'Gabriella'), (1093, 'Gabrielle Faith'), (1000, 'Gaelle'), (7998, 'Gaia'), (38651, 'Gail'), (302957, 'Galina'), (30136, 'Ganna'), (412872, 'Garbine'), (143, 'Gebriela'), (440, 'Genevieve'), (9600, 'Georgia'), (1848, 'Georgia Andreea'), (48, 'Georgiana'), (11569, 'Georgina'), (290, 'Ghislaine'), (677, 'Giada'), (31741, 'Gioia'), (2484, 'Giorgia'), (13, 'Giorgie'), (289, 'Giovanna'), (106520, 'Giulia'), (2935, 'Giuliana'), (1297, 'Gloria'), (2864, 'Gozal'), (70613, 'Grace'), (7999, 'Gracia'), (6168, 'Greetje'), (240195, 'Greta'), (14277, 'Guadalupe'), (576, 'Guillermina'), (687, 'Guiomar'), (410, 'Gulben'), (18, 'Gulchekhra'), (39, 'Gulnaz'), (775, 'Guzal'), (238, 'Gyulnara'), (811, 'Habiba'), (8180, 'Hae Sung'), (294, 'Haine'), (413, 'Hana'), (2782, 'Hanna'), (4643, 'Hanyu'), (9631, 'Hao Chen'), (224, 'Hao Ching'), (5944, 'Harmony'), (8608, 'Harriet'), (3633, 'Haruka'), (1873, 'Haruna'), (1679, 'Hayley'), (78, 'Hazal'), (202780, 'Heather'), (88542, 'Heidi'), (1039, 'Helen'), (3928, 'Helene'), (122, 'Hikari'), (10191, 'Hilda'), (3, 'Himari'), (27580, 'Hiroko'), (4368, 'Hirono'), (2371, 'Ho Ching'), (24, 'Hollie'), (1063, 'Hongrui'), (98, 'Hortencia'), (120, 'Hsin Yuan'), (7367, 'Hua Chen'), (118, 'Huijie'), (7797, 'Hulya'), (1222, 'Hye Min'), (870, 'Hyojung'), (8301, 'Hyun Hui'), (511, 'I Hsuan'), (395, 'Iana'), (467, 'Ida'), (45, 'Idia'), (916, 'Iga'), (52, 'Ilay'), (1142, 'Ilka'), (26950, 'Ilona'), (1527, 'Ilze'), (1676, 'Imane Maelle'), (292, 'Ina'), (406, 'Inci'), (762, 'India'), (12633, 'Indire'), (17382, 'Indy'), (1358, 'Ineke'), (40410, 'Ines'), (221, 'Inger'), (3471, 'Ingrid'), (4766, 'Ingrid Alexandra'), (10133, 'Ingrid Esperanza'), (33, 'Intissar'), (1225, 'Ioana'), (2403, 'Ioana Diana'), (5425, 'Ioana Loredana'), (6948, 'Ionela Andreea'), (39352, 'Ipek'), (88369, 'Irena'), (3133, 'Irene'), (299698, 'Irina'), (293366, 'Irina Camelia'), (13843, 'Irina Maria'), (4743, 'Iris'), (87844, 'Iryna'), (6688, 'Isabel'), (714, 'Isabela'), (83476, 'Isabella'), (4777, 'Isabelle'), (74, 'Iulia Maria'), (10322, 'Iva'), (100848, 'Ivana'), (2094, 'Ivania'), (291, 'Ivanka'), (443695, 'Iveta'), (543, 'Ivette'), (253, 'Ivone'), (13010, 'Ivonne'), (27462, 'Jacqueline'), (64, 'Jada'), (26209, 'Jade'), (1375, 'Jaeda'), (5007, 'Jaimee'), (24, 'Jaimy Gayle'), (761, 'Jainy'), (190997, 'Jamie'), (18, 'Jamilya'), (10947, 'Jan'), (268372, 'Jana'), (143422, 'Janette'), (12525, 'Janina'), (72, 'Janja'), (861, 'Janneke'), (5416, 'Jaqueline Adina'), (464, 'Jara'), (333150, 'Jarmila'), (34453, 'Jasmin'), (43862, 'Jasmina'), (14865, 'Jasmine'), (142, 'Jasmine Amber'), (822, 'Jawairiah'), (908, 'Jazmin'), (628, 'Jazzamay'), (3426, 'Jeannine'), (2515436, 'Jelena'), (81222, 'Jennifer'), (1002, 'Jenny'), (17819, 'Jesika'), (154599, 'Jessica'), (4122, 'Jessika'), (923, 'Jessy'), (7179, 'Ji Hee'), (8592, 'Ji Young'), (52, 'Jia'), (48117, 'Jia Jing'), (4612, 'Jia Qi'), (1553, 'Jiahui'), (15, 'Jiakang'), (100, 'Jiatian'), (3002, 'Jiaxi'), (96, 'Jiaxue'), (610820, 'Jie'), (13978, 'Jil Belen'), (611, 'Jil Nora'), (359013, 'Jill'), (1991, 'Jillian'), (15, 'Jin'), (46355, 'Jin A'), (414, 'Jin Ju'), (68925, 'Jing Jing'), (1955, 'Joana'), (472, 'Joanna'), (15, 'Joanne'), (355, 'Jodie Anna'), (40, 'Johana'), (553107, 'Johanna'), (1092, 'Jordana'), (2710, 'Josepha'), (4980, 'Josephine'), (804, 'Josie'), (39270, 'Jovana'), (3453, 'Ju Eun'), (3, 'Judith'), (63, 'Jule'), (891796, 'Julia'), (21, 'Julia Mansano'), (414, 'Juliana'), (129, 'Juliana Rocha'), (156531, 'Julie'), (4093, 'Julieta Lara'), (286, 'Julita'), (1446, 'Julyette Maria Josephine'), (114, 'June'), (128183, 'Junri'), (36, 'Justina'), (39418, 'Justine'), (30304, 'Justyna'), (467, 'Kady'), (172004, 'Kai Chen'), (37817, 'Kai Lin'), (625836, 'Kaia'), (416, 'Kaitlin'), (3905, 'Kaitlyn'), (1176, 'Kaja'), (2280, 'Kajsa'), (12906, 'Kamila'), (249, 'Kamilla'), (5866, 'Kamonwan'), (1536, 'Kana'), (20142, 'Kanae'), (229, 'Kanako'), (3724, 'Kanami'), (919, 'Kanika'), (8406, 'Kaori'), (32169, 'Karen'), (85, 'Kariann'), (254520, 'Karin'), (9355, 'Karina'), (5493, 'Karina Ildor'), (410, 'Karina Kristina'), (1936, 'Karine'), (1003, 'Karis'), (3127, 'Karla'), (3193, 'Karman'), (776, 'Karola Patricia'), (465, 'Karolayne'), (512490, 'Karolina'), (910, 'Karoline'), (330, 'Karyn'), (704, 'Kassandra'), (112562, 'Katalin'), (444303, 'Katarina'), (93730, 'Katarzyna'), (34, 'Kate'), (160945, 'Katerina'), (435038, 'Kateryna'), (24595, 'Katharina'), (363, 'Katharine'), (7843, 'Katherine'), (1894, 'Katherine Gabriela'), (15970, 'Kathinka'), (141281, 'Kathrin'), (30035, 'Katie'), (308, 'Katrine Isabel'), (11572, 'Katy'), (515, 'Katya'), (97, 'Katyarina'), (13697, 'Kayla'), (237, 'Kaylah'), (10107, 'Kazusa'), (294, 'Kei'), (324, 'Kelia'), (4705, 'Kelly'), (5880, 'Kelly S'), (410, 'Kelsey'), (653, 'Kennedy'), (24062, 'Keren'), (894, 'Keri'), (942, 'Kerstin'), (3748, 'Khristina'), (86, 'Ki Ryang'), (214121, 'Kiki'), (4580, 'Kim'), (12388, 'Kim Alice'), (5393, 'Kimberley'), (4831, 'Kimberly'), (272, 'Kimika'), (270102, 'Kimiko'), (15102, 'Kinnie'), (383077, 'Kirsten'), (462, 'Kirsten Andrea'), (5818, 'Klaartje'), (568191, 'Klara'), (4809, 'Klaudia'), (701, 'Komola'), (21417, 'Korina'), (4962, 'Kotomi'), (17577, 'Krista'), (34647, 'Kristie'), (601693, 'Kristina'), (555, 'Kristina N'), (1899, 'Kristy'), (148728, 'Kristyna'), (371140, 'Ksenia'), (298, 'Kseniia'), (625, 'Ksenija'), (56212, 'Kumiko'), (177170, 'Kurumi'), (210101, 'Kveta'), (403, 'Kwan Yau'), (3200, 'Kyle'), (1236, 'Kylie'), (9036, 'Kyoka'), (102022, 'Kyra'), (26059, 'Kyung Mi'), (6078, 'Laetitia'), (595, 'Laili'), (456, 'Lamis'), (177458, 'Lara'), (255, 'Larikah'), (578964, 'Laura'), (281, 'Laura D'), (33822, 'Laura Ioana'), (97, 'Laura Sofia'), (244807, 'Lauren'), (207, 'Lauryn'), (23897, 'Lavinia'), (39, 'Laylo'), (22, 'Layne'), (4197, 'Lea'), (152, 'Leah'), (733, 'Lee'), (27997, 'Lena'), (14942, 'Lena Marie'), (164900, 'Lenka'), (750, 'Leolia'), (672, 'Leonie'), (286, 'Lesedi Sheya'), (225987, 'Lesia'), (42925, 'Lesley'), (173, 'Leslie'), (45115, 'Leticia'), (87, 'Leticia Garcia'), (48, 'Leylah Annie'), (1696, 'Li'), (59997, 'Liana Gabriela'), (2362, 'Libby'), (522, 'Libi'), (169, 'Lidia'), (6809, 'Lidziya'), (39782, 'Liezel'), (23411, 'Liga'), (1960, 'Lilla'), (40341, 'Lin'), (91117, 'Lina'), (4216, 'Linda'), (142454, 'Lindsay'), (500, 'Lindsey'), (64525, 'Ling'), (72, 'Liniques'), (697, 'Linnea'), (594217, 'Lisa'), (7898, 'Lisa Maria'), (1583, 'Lisa Marie'), (8284, 'Lisanne'), (2662, 'Liubov'), (128, 'Livia'), (2216, 'Liz Tatiane'), (135, 'Lizaveta'), (11623, 'Lizette'), (33, 'Lorenza'), (40, 'Lorraine M'), (10167, 'Lou'), (6, 'Loudmilla'), (50700, 'Louisa'), (1633, 'Louise'), (371035, 'Lourdes'), (3445, 'Lu'), (1013, 'Luca'), (17185, 'Lucia'), (8305, 'Luciana'), (1108372, 'Lucie'), (1589, 'Lucrezia'), (6542, 'Lucy'), (645, 'Ludmila'), (1187, 'Ludmilla'), (1671, 'Luisa'), (1822, 'Luisa Marie'), (77519, 'Luksika'), (304, 'Lulu'), (15, 'Luna'), (377, 'Lusine'), (876, 'Lutfiye'), (30, 'Lyann'), (837, 'Lynn'), (54172, 'Lyudmyla'), (12379, 'Macall'), (2133, 'Macarena'), (62938, 'Madalina'), (2434, 'Maddison'), (715, 'Madeleine'), (147, 'Madeline'), (6, 'Madina'), (476768, 'Madison'), (2266, 'Madrie'), (525, 'Maegan'), (163, 'Mafalda'), (54, 'Maftuna'), (1917, 'Magali'), (511, 'Magalie'), (103659, 'Magda'), (401857, 'Magdalena'), (756, 'Magy'), (154, 'Mahak'), (395, 'Mahitha'), (19173, 'Mai'), (1235, 'Maia'), (12, 'Maia A'), (11320, 'Maiko'), (83, 'Maileen'), (39523, 'Mailen'), (1067, 'Maja'), (5592, 'Makiho'), (14129, 'Makoto'), (316, 'Malene'), (323, 'Malika'), (2489, 'Malin'), (688, 'Mallaurie'), (44497, 'Mallory'), (3073, 'Malou'), (96, 'Mami'), (102, 'Man Ying Maggie'), (9593, 'Mana'), (15, 'Mananchaya'), (2070, 'Manca'), (193767, 'Mandy'), (3112, 'Manisha'), (14608, 'Manon'), (93, 'Manya'), (702, 'Mara'), (16790, 'Marcela'), (683, 'Marcela Guimaraes'), (33, 'Marcelina'), (13037, 'Marcella'), (99836, 'Margalita'), (1997, 'Margarida'), (78265, 'Margarita'), (905, 'Margaux'), (4787, 'Margot'), (38086, 'Mari'), (3613355, 'Maria'), (185, 'Maria Agustina'), (323, 'Maria Andrea'), (148, 'Maria Camila'), (1892, 'Maria Constanza De Las Mercedes'), (296, 'Maria Del Rosario'), (296736, 'Maria Elena'), (141257, 'Maria Fernanda'), (294, 'Maria Jesus'), (72682, 'Maria Joao'), (413759, 'Maria Jose'), (156, 'Maria Lourdes'), (1388, 'Maria Paulina'), (106375, 'Maria Teresa'), (4060, 'Mariam'), (201258, 'Mariana'), (10178, 'Marianna'), (1090, 'Marianne'), (226, 'Mariaryeni'), (25496, 'Marie'), (114687, 'Marie Eve'), (206, 'Mariia'), (20481, 'Marija'), (3, 'Marijana'), (362372, 'Marina'), (4314, 'Marine'), (1272285, 'Marion'), (4, 'Mariona'), (1026, 'Marisa'), (154484, 'Mariya'), (18286, 'Marketa'), (1624, 'Marlies'), (1339, 'Marrit'), (267679, 'Marta'), (778, 'Marta Huqi'), (153, 'Martha'), (109192, 'Martina'), (653, 'Mary'), (102, 'Mary Ann'), (85425, 'Maryna'), (117472, 'Masa'), (245139, 'Mathilde'), (3466, 'Matilda'), (210, 'Maud'), (219, 'Maureen'), (138, 'Maurien'), (390, 'Maxine'), (225, 'May'), (23668, 'Maya'), (1788, 'Mayar'), (32445, 'Mayo'), (9064, 'Mayya'), (13254, 'Megan'), (407, 'Megumi'), (40, 'Mei Xu'), (417, 'Meiling'), (96, 'Meiqi'), (385636, 'Melanie'), (97, 'Melany Solange'), (2609, 'Melina'), (290299, 'Melinda'), (20196, 'Melis'), (340, 'Melisa'), (200, 'Melissa'), (171, 'Melissa Ishuan'), (542, 'Meng Ning'), (48, 'Mercedes'), (101, 'Merel'), (284, 'Meritxell'), (102693, 'Mervana'), (24569, 'Mi'), (176, 'Mi Jeong'), (1858, 'Mi Rae'), (72, 'Mi Zhuoma'), (1098, 'Mia Nicole'), (230, 'Micaela'), (76586, 'Michaela'), (242619, 'Michaella'), (90, 'Michela'), (596, 'Michele Alexandra'), (160164, 'Michelle'), (3657, 'Michika'), (69242, 'Mihaela'), (15, 'Mihaela Lorena'), (21205, 'Miharu'), (427, 'Mihika'), (201, 'Mihoki'), (24542, 'Miki'), (107, 'Mila'), (42, 'Milagros'), (14123, 'Milana'), (279, 'Milena'), (63, 'Milica'), (1884, 'Min'), (9938, 'Min Hwa'), (96, 'Minami'), (1626, 'Mira'), (1977, 'Mirabelle'), (180, 'Miranda'), (3825, 'Miriam'), (1458, 'Miriam Bianca'), (1180, 'Miriana'), (272, 'Mirjam'), (331434, 'Mirjana'), (55981, 'Misa'), (203782, 'Misaki'), (309, 'Mitsumi'), (22840, 'Miyabi'), (23968, 'Miyu'), (2927, 'Mizuno'), (565, 'Molly'), (2061, 'Momoko'), (282445, 'Mona'), (587309, 'Monica'), (1240, 'Monika'), (114104, 'Monique'), (23564, 'Montserrat'), (6906, 'Morgane'), (15, 'Moulika'), (12, 'Mouna'), (32, 'Moyuka'), (6, 'Muazzez'), (162, 'Muge'), (43550, 'Myrtille'), (1358928, 'Na'), (26185, 'Na Lae'), (19223, 'Na Ri'), (5027, 'Nadezda'), (1401125, 'Nadia'), (56596, 'Nadiya'), (2661, 'Nadja'), (1535, 'Nagi'), (4380, 'Naiktha'), (440, 'Naima'), (259, 'Nam Yeon'), (3094, 'Nan Nan'), (16494, 'Nanuli'), (59671, 'Nao'), (857, 'Naoko'), (163239, 'Naomi'), (1945, 'Napatsakorn'), (72, 'Nastassia'), (65152, 'Nastassja'), (29250, 'Nastja'), (97400, 'Natalia'), (120995, 'Natalie'), (13686, 'Natalija'), (33, 'Nataliya'), (14212, 'Natasa'), (15365, 'Natasha'), (16303, 'Natela'), (649, 'Natella'), (28098, 'Nathalia'), (13241, 'Nathaly'), (2526, 'Natia'), (37981, 'Natsumi'), (224, 'Nattawadee'), (251, 'Naz'), (980, 'Nazari'), (9536, 'Neda'), (142, 'Nelise'), (279, 'Nermeen'), (170, 'Nevena'), (30972, 'Nicha'), (2531, 'Nicky'), (33550, 'Nicola'), (447434, 'Nicole'), (8146, 'Nicoleta Catalina'), (9627, 'Nicolette'), (5425, 'Nidhi'), (47651, 'Nigina'), (9120, 'Nika'), (22, 'Nikita'), (614, 'Nikki'), (491, 'Nikol'), (78513, 'Nikola'), (201173, 'Nina'), (115, 'Nina Isabella'), (2706, 'Nives'), (1558, 'Noel'), (2025, 'Noelia'), (1795, 'Noelle'), (134, 'Nonna'), (73589, 'Noppawan'), (1082, 'Nora'), (760, 'Nour'), (1333, 'Nozomi'), (63013, 'Nudnida'), (24523, 'Nungnadda'), (259116, 'Nuria'), (1096, 'Oana'), (4294, 'Oana Georgeta'), (56853, 'Oceane'), (5372, 'Ofri'), (58279, 'Oksana'), (3497, 'Ola'), (2, 'Olawaseun'), (40, 'Olaya'), (8700, 'Oleksandra'), (484, 'Olena'), (3811, 'Olesya'), (773929, 'Olga'), (119756, 'Olivia'), (363, 'Oliwia'), (56242, 'Ons'), (2133, 'Ornella'), (382, 'Oyku'), (147, 'Paige Mary'), (241, 'Pamela'), (1446, 'Panna'), (403127, 'Paola'), (209, 'Parris'), (1188, 'Patcharin'), (197904, 'Patricia'), (43755, 'Patricia Maria'), (17514, 'Patrycja'), (7323, 'Patty'), (172431, 'Paula'), (269, 'Paula Andrea'), (3714, 'Paula Catalina'), (37384, 'Paula Cristina'), (3208, 'Paulina'), (313187, 'Pauline'), (4128, 'Pavla'), (26280, 'Peangtarn'), (1016, 'Peggy'), (8900, 'Pei Chi'), (24, 'Pei Hsuan'), (181, 'Pei Ju'), (60908, 'Pemra'), (6573, 'Pernilla'), (1832, 'Petia'), (1958404, 'Petra'), (3, 'Phenomena'), (664, 'Phillis'), (10859, 'Pia'), (21340, 'Piia'), (6404, 'Pilar'), (243, 'Pippa'), (934, 'Plobrung'), (76747, 'Polina'), (325216, 'Polona'), (13006, 'Poojashree'), (1214, 'Pranjala'), (5687, 'Prarthana G'), (9318, 'Prerna'), (510, 'Priscila'), (8203, 'Priscilla'), (116857, 'Qiang'), (683, 'Qianhui'), (641, 'Qianqian'), (2034, 'Qiu Yu'), (646, 'Quinn'), (22978, 'Quirine'), (2592, 'Rachael'), (469, 'Rachel'), (699, 'Radina'), (228, 'Rafaela'), (40, 'Ralina'), (148701, 'Raluca'), (9202, 'Raluca Elena'), (4258, 'Raluca Georgiana'), (443, 'Ramu'), (161, 'Ramya'), (14709, 'Ran'), (9, 'Rana'), (30401, 'Raquel'), (741, 'Rashmi'), (957, 'Ratnika'), (5387, 'Raveena'), (168, 'Rebeca'), (165013, 'Rebecca'), (5803, 'Rebeka'), (122331, 'Regina'), (64, 'Reina'), (66271, 'Reka Luca'), (38116, 'Remi'), (201856, 'Renata'), (5566, 'Ria'), (984, 'Rianna'), (84184, 'Richel'), (141257, 'Rika'), (23195, 'Riko'), (556, 'Rio'), (62252, 'Risa'), (8448, 'Rishika'), (1401, 'Rita'), (2634, 'Riya'), (809611, 'Roberta'), (12295, 'Robin'), (1103, 'Robyn'), (16886, 'Rocio'), (29214, 'Romana'), (17020, 'Romana Caroline'), (253471, 'Romina'), (911, 'Romy'), (308, 'Rona'), (3165, 'Ronit'), (49, 'Ronke'), (28, 'Roosh'), (111, 'Rosa'), (803, 'Rosalia'), (880, 'Rosalie'), (336, 'Rosie'), (38793, 'Roxane'), (24, 'Rui'), (27452, 'Rushmi'), (3642, 'Rutuja'), (597, 'Ryann'), (195, 'Saana'), (780, 'Sabastiani'), (49784, 'Sabina'), (27, 'Sabina Elena'), (590911, 'Sabine'), (6810, 'Sabrina'), (78204, 'Sacha'), (49767, 'Sachia'), (42676, 'Sachie'), (2275, 'Sadafmoh'), (1034, 'Sai Samhitha'), (113359, 'Saisai'), (9338, 'Sakiko'), (53480, 'Sally'), (66, 'Salma'), (1437656, 'Samantha'), (2020, 'Samira'), (354, 'Sanae'), (17975, 'Sanaz'), (266197, 'Sandra'), (224, 'Sandy'), (1277, 'Sang Hee'), (272889, 'Sania'), (914981, 'Sara'), (78461, 'Sarah'), (1270, 'Sarah Beth'), (13064, 'Sarah Rebecca'), (461, 'Sarahi'), (148, 'Sarai Delfina'), (2061, 'Saray'), (464, 'Sari'), (27, 'Sarlota'), (178, 'Sarvinoz'), (316, 'Sasa'), (2641, 'Saska'), (906, 'Satsuki'), (70, 'Savannah'), (148, 'Schena'), (143, 'Se Hyun'), (681, 'Se Jin'), (75, 'Sean'), (1469, 'Seda'), (144, 'Seira'), (169, 'Selin'), (6564, 'Seo Kyung'), (1312, 'Seone'), (4232828, 'Serena'), (208108, 'Sesil'), (6650, 'Seung Yeon'), (192296, 'Severine'), (662926, 'Shahar'), (2122, 'Shakhlo'), (198, 'Shakhnoza'), (111, 'Shangqing'), (2378, 'Shanshan'), (1363, 'Shao Yuan'), (4106, 'Sharmada'), (117825, 'Sharon'), (522, 'Sharon Sanchana'), (102140, 'Shelby'), (142, 'Shelly'), (53610, 'Sheng Nan'), (22977, 'Sherazad'), (801, 'Sherry'), (39960, 'Shiho'), (9634, 'Shilin'), (18, 'Shiori'), (117, 'Shir'), (236, 'Shiran'), (4611, 'Shivika'), (105, 'Shou Na'), (6, 'Shreya'), (1483, 'Shu Ying'), (913829, 'Shuai'), (46124, 'Shuko'), (597, 'Shuo'), (336, 'Shuyue'), (3255, 'Shweta'), (531, 'Si Qi'), (221695, 'Silvia'), (724638, 'Simona'), (1149, 'Simone'), (467, 'Simran Kaur'), (10360, 'Sina'), (688, 'Sinead'), (95, 'Sing Le'), (716, 'Siqi'), (276, 'Sirui'), (87, 'Siyu'), (352458, 'Sloane'), (96, 'Smriti'), (134, 'Sneha'), (2820, 'Snehadevi S'), (47282, 'So Jung'), (18210, 'So Ra'), (484140, 'Sofia'), (336, 'Sofico'), (10539, 'Sofie'), (18371, 'Sofiya'), (9180, 'Sofya'), (108, 'Sohyun'), (480, 'Sonia'), (4499, 'Sonja'), (96, 'Sophia'), (39307, 'Sophie'), (457043, 'Sorana'), (2961, 'Sowjanya'), (159, 'Spurti'), (1744, 'Sri Vaishnavi'), (8072, 'Stamatia'), (49412, 'Stanislava'), (497, 'Stefana'), (126, 'Stefani'), (24897, 'Stefania'), (247237, 'Stefanie'), (3085, 'Steffi'), (608309, 'Stephanie'), (1397, 'Stephanie Mariel'), (21152, 'Storm'), (33672, 'Su Jeong'), (274936, 'Su Wei'), (320, 'Suellen'), (1544, 'Sultan'), (6591, 'Sun Jung'), (15, 'Sunae'), (3594, 'Sunam'), (29852, 'Sung Hee'), (502, 'Susan'), (16276, 'Susanne'), (344, 'Suzan'), (324, 'Suzuho'), (1054, 'Suzy'), (6341, 'Svenja'), (1906587, 'Svetlana'), (11201, 'Sviatlana'), (581, 'Sybille'), (1626, 'Sylvia'), (8268, 'Sylwia'), (9001, 'Syna'), (2127, 'Szabina'), (83659, 'Tadeja'), (1050, 'Taisiya'), (45, 'Talya'), (843, 'Tamachan'), (60, 'Tamar'), (54140, 'Tamara'), (304, 'Tamari'), (594281, 'Tamarine'), (40060, 'Tamaryn'), (322202, 'Tamira'), (26077, 'Tammi'), (764, 'Tanaporn'), (1229, 'Tanya'), (54798, 'Tara'), (42, 'Tatia'), (34795, 'Tatiana'), (230262, 'Tatjana'), (1289, 'Tatsiana'), (5051, 'Tayisiya'), (38850, 'Taylor'), (2127, 'Tea'), (112570, 'Teliana'), (12402, 'Tena'), (41792, 'Teodora'), (193362, 'Tereza'), (18, 'Terri'), (7165, 'Tess'), (9116, 'Tessah'), (75337, 'Tetiana'), (43020, 'Tetyana'), (706, 'Thai Sa Grana'), (2249, 'Theo'), (377, 'Theresa'), (333, 'Tijana'), (612072, 'Timea'), (57585, 'Tina'), (476, 'Tinatin'), (8145, 'Ting Fei'), (8676, 'Ting Jr'), (151, 'Tingting'), (3361, 'Tjasa'), (7431, 'Tomoko'), (10630, 'Tori'), (1864, 'Tornado Alicia'), (1884, 'Trang'), (736, 'Treta'), (456422, 'Tsvetana'), (4543, 'Tyra'), (27118, 'Ulrikke'), (2400, 'Ulyana'), (275255, 'Urszula'), (413, 'Ushna'), (7874, 'Usue Maitane'), (338, 'Valentina'), (9926, 'Valentine'), (15198, 'Valentini'), (47854, 'Valentyna'), (159155, 'Valeria'), (6146, 'Valerie'), (16621, 'Valeriya'), (10087, 'Vanda'), (30669, 'Vanesa'), (71645, 'Vanessa'), (299530, 'Vania'), (255, 'Vaniya'), (291, 'Vanja'), (54340, 'Varatchaya'), (3623, 'Varunya'), (401409, 'Varvara'), (42527, 'Vasilisa'), (3763, 'Vaszilisza'), (2221, 'Vendula'), (2875425, 'Venus'), (1929137, 'Vera'), (3018, 'Verena'), (84543, 'Veronica'), (1678, 'Veronica M'), (73192, 'Veronika'), (169500, 'Vesna'), (77, 'Vicky'), (454, 'Victoire'), (2142854, 'Victoria'), (106, 'Victoria Ariadna'), (30191, 'Viktoria'), (90, 'Viktoriia'), (79511, 'Viktorija'), (26226, 'Viktoriya'), (1987, 'Viktoryia'), (27, 'Vilma Y'), (105, 'Vincenza'), (37, 'Vinciane'), (298, 'Violetta'), (519208, 'Virginie'), (71, 'Vishesh'), (64, 'Vita'), (106927, 'Vitalia'), (36714, 'Vivian'), (13041, 'Vivien'), (8918, 'Vivienne'), (22578, 'Vlada'), (997, 'Vladica'), (6470, 'Vladimira'), (1254, 'Vladislava'), (2570, 'Vladyslava'), (18781, 'Vojislava'), (1036, 'Voni'), (11653, 'Wan Ting'), (42, 'Wan Yi'), (9, 'Warona'), (40633, 'Wen Hsin'), (120, 'Wen Ling'), (613, 'Wendy Qi Wen'), (179, 'Weronika Jasmina'), (5604, 'Whitney'), (363, 'Wiktoria'), (11694, 'Wing Yau Venise'), (879, 'Wushuang'), (14578, 'Xenia'), (1445, 'Xi Yao'), (4789, 'Xiao'), (5057, 'Xiaodi'), (717, 'Xiaorong'), (1352, 'Xiaoxi'), (19495, 'Ximena'), (8744, 'Xin'), (187, 'Xin Yu'), (10705, 'Xinyu'), (109256, 'Xinyun'), (315, 'Xiyu'), (4535, 'Xu Liu'), (24, 'Ya'), (17078, 'Ya Hsuan'), (39687, 'Yafan'), (4196, 'Yan'), (39102, 'Yana'), (73, 'Yang'), (602453, 'Yanina'), (275, 'Yanni'), (32, 'Yarden'), (404915, 'Yaroslava'), (11251, 'Yasmin'), (27, 'Yasmina'), (1748, 'Yasmine'), (71, 'Yasmyn'), (648, 'Yawna'), (128509, 'Yayuk'), (47867, 'Ye Ra'), (281, 'Ye Xin'), (376, 'Yekaterina'), (1856, 'Yelena'), (966, 'Yeong Won'), (6288, 'Yevgeniya'), (19989, 'Yi'), (60646, 'Yi Fan'), (22443, 'Yi Jing'), (61839, 'Yi Miao'), (136, 'Yidi'), (24, 'Yihong'), (366, 'Yijia'), (3783, 'Ying'), (107595, 'Ying Ying'), (1380, 'Yixuan'), (1546, 'Ylena'), (1453, 'Ylona Georgiana'), (285, 'Yoko'), (1381, 'Yolande'), (182, 'Yoo Ri'), (3592, 'Yoon Young'), (677, 'Yoshimi'), (75, 'Yosr'), (242, 'You Na'), (27804, 'Ysaline'), (452, 'Yu Jin'), (9, 'Yu Tong'), (281, 'Yuan'), (772, 'Yuanyi'), (1259, 'Yue'), (21360, 'Yue Yue'), (682, 'Yuenu'), (184, 'Yujia'), (12474, 'Yuka'), (84, 'Yukako'), (505, 'Yuki'), (2191, 'Yuki Kristina'), (998, 'Yukina'), (1828, 'Yukun'), (155143, 'Yulia'), (15248, 'Yuliana'), (206375, 'Yuliya'), (20269, 'Yumi'), (229391, 'Yung Jan'), (559, 'Yuqi'), (101816, 'Yurika'), (1728, 'Yuriko'), (12693, 'Yurina'), (15071, 'Yuuki'), (45, 'Yuval'), (24279, 'Yuxuan'), (254491, 'Yvonne'), (87, 'Zaineb'), (2052, 'Zalina'), (3809, 'Zarah'), (123243, 'Zarina'), (702, 'Zeel'), (21, 'Zeynep  Sena'), (2166, 'Zhanlan'), (20236, 'Zhaoxuan'), (7, 'Zhibek'), (99, 'Zhima'), (30, 'Zhou'), (121, 'Zhuoma'), (110290, 'Zi'), (74, 'Zinovia'), (1420, 'Ziyue'), (2772, 'Zoe'), (2877, 'Zoe Gwen'), (1501, 'Zsofia'), (266251, 'Zuzana'), (2258, 'Zuzanna')]",,1.0,
What is the average number of injuries caused each time?,[death.injured],"Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",EASY,SELECT AVG(death.injured) AS average_injuries FROM death;,SELECT avg(injured) FROM death,battle_death,"1. Sequential Structure: Begin with the SELECT clause to calculate the average number of injuries caused each time. 2. Aggregation Structure: Use the AVG function on the ""death.injured"" column to compute the average number of injuries. 3. Condition Structure: No specific filtering condition is required as the query aims to calculate the overall average. 4. Join Structure: No JOIN is necessary since all the required data is available in the ""death"" table.","[(1.0769230769230769,)]","[(1.0769230769230769,)]",,1.0,
Find the number of distinct name of losers.,[matches.loser_name],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT COUNT(DISTINCT matches.loser_name) FROM matches;,SELECT count(DISTINCT loser_name) FROM matches,wta_1,"1. Sequential Structure: Start with the SELECT clause to count the distinct names of losers. 2. Condition Structure: No specific filtering condition is required as we are counting all distinct loser names. 3. Join Structure: No JOIN is required since the necessary information is available in the ""matches"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""matches.loser_name"" to count the unique names of losers.","[(49,)]","[(49,)]",,1.0,
What is the zip code of the address in the city Port Chelsea?,"[Addresses.zip_postcode, Addresses.city, Port Chelsea]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Addresses.zip_postcode FROM Addresses WHERE Addresses.city = 'Port Chelsea';,SELECT zip_postcode FROM Addresses WHERE city  =  'Port Chelsea',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Addresses.zip_postcode"" for the address in the specified city. 2. Condition Structure: Use a WHERE clause to filter for rows where ""Addresses.city"" is equal to 'Port Chelsea'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Addresses"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('148',)]","[('148',)]",,1.0,
find the names of museums which have more staff than the minimum staff number of all museums opened after 2010.,"[museum.Name, museum.Num_of_Staff, museum.Open_Year]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",NESTED,SELECT Name FROM museum WHERE Num_of_Staff > (SELECT MIN(Num_of_Staff) FROM museum WHERE Open_Year > 2010);,SELECT name FROM museum WHERE num_of_staff  >  (SELECT min(num_of_staff) FROM museum WHERE open_year  >  2010),museum_visit,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of museums. Use the FROM clause to specify the museum table. Apply a WHERE clause to filter museums with staff numbers greater than the minimum staff number of museums opened after 2010. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the minimum staff number of museums opened after 2010. The main query filters museums whose staff numbers exceed this value. 3. Join Structure: Not required, as all data is from the museum table. 4. Aggregation Structure: Use the MIN function in a subquery to find the minimum staff number of museums opened after 2010.","[('Plaza Museum',), ('Capital Plaza Museum',), ('Jefferson Development Museum',)]","[('Plaza Museum',), ('Capital Plaza Museum',), ('Jefferson Development Museum',)]",,1.0,
What is the name of each teacher and what course they teach?,"[teacher.Name, course.Course, course_arrange.Teacher_ID = teacher.Teacher_ID, course_arrange.Course_ID = course.Course_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NON-NESTED,"SELECT teacher.Name, course.Course FROM teacher JOIN course_arrange ON teacher.Teacher_ID = course_arrange.Teacher_ID JOIN course ON course_arrange.Course_ID = course.Course_ID;","SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID",course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Name"" and ""course.Course"" fields. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""teacher"" table with ""course_arrange"" on ""Teacher_ID"" and ""course_arrange"" with ""course"" on ""Course_ID"" to link each teacher with the courses they teach. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the names of teachers and the courses they teach.","[('Kearsley Brown', 'Math'), ('Vicente Carretero', 'Math'), ('Gustaaf Deloor', 'Science'), ('Anne Walker', 'History'), ('Anne Walker', 'Bible'), ('Lucy Wong', 'Music')]","[('Kearsley Brown', 'Math'), ('Vicente Carretero', 'Math'), ('Gustaaf Deloor', 'Science'), ('Anne Walker', 'History'), ('Anne Walker', 'Bible'), ('Lucy Wong', 'Music')]",,1.0,
Count the number of matches.,[matches.match_num],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT COUNT(matches.match_num) AS total_matches FROM matches;,SELECT count(*) FROM matches,wta_1,"1. Sequential Structure: Start with the SELECT clause to count the number of matches. 2. Condition Structure: No specific filtering condition is required since we want the total count of matches. 3. Join Structure: No JOIN is necessary as the required information is available within the ""matches"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of matches.","[(278,)]","[(278,)]",,1.0,
What is the best rank of losers across all matches?,[matches.loser_rank],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT MIN(matches.loser_rank) AS best_loser_rank FROM matches;,SELECT min(loser_rank) FROM matches,wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the best rank of losers across all matches. Since ""best"" implies the lowest rank value, we will use the MIN function. 2. Condition Structure: No specific filtering condition is required as we are considering all matches. 3. Join Structure: No JOIN is required since the relevant information is available in the ""matches"" table. 4. Aggregation Structure: Use the MIN function to find the lowest value of ""matches.loser_rank"" across all matches.","[(1,)]","[(1,)]",,1.0,
find the code of the country where has the greatest number of players.,"[players.country_code, players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT players.country_code FROM players GROUP BY players.country_code ORDER BY COUNT(players.player_id) DESC LIMIT 1;,SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1,wta_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the country code. 2. Aggregation Structure: Use COUNT to calculate the number of players for each country. 3. Grouping Structure: Use GROUP BY on ""players.country_code"" to group the results by each country. 4. Ordering Structure: Use ORDER BY in descending order on the count of players to rank countries by the number of players. 5. Limiting Structure: Use LIMIT 1 to retrieve the country code with the greatest number of players. 6. Join Structure: No JOIN is required since all necessary data is within the ""players"" table.","[('USA',)]","[('USA',)]",,1.0,
"Show names, results and bulgarian commanders of the battles with no ships lost in the 'English Channel'.","[battle.name, battle.result, battle.bulgarian_commander, ship.lost_in_battle, ship.location, ship.lost_in_battle = battle.id, 'English Channel']","Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",NESTED,"SELECT battle.name, battle.result, battle.bulgarian_commander FROM battle LEFT JOIN ship ON ship.lost_in_battle = battle.id WHERE ship.location = 'English Channel' AND ship.lost_in_battle IS NULL;","SELECT name ,  RESULT ,  bulgarian_commander FROM battle EXCEPT SELECT T1.name ,  T1.result ,  T1.bulgarian_commander FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.location  =  'English Channel'",battle_death,"1. Sequential Structure: Start with the SELECT clause to retrieve the battle name, result, and Bulgarian commander. Use the FROM clause to specify the battle table. Join it with the ship table to identify battles with associated ships. Apply a WHERE clause to filter for battles where no ships were lost and the location is 'English Channel'. 2. Condition Structure: Use the WHERE clause to filter for ships with a location of 'English Channel' and ensure no ships were lost by checking for NULL in the lost_in_battle column. 3. Join Structure: Use an INNER JOIN between the battle and ship tables based on the relationship ship.lost_in_battle = battle.id to connect battles with their associated ships. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",[],"[('Battle of Adrianople', 'Bulgarian victory', 'Kaloyan'), ('Battle of Rusion', 'Bulgarian victory', 'Kaloyan'), ('Battle of Serres', 'Bulgarian victory', 'Kaloyan')]",,0.0,
"For each hometown, how many teachers are there?","[teacher.Hometown, teacher.Teacher_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,"SELECT teacher.Hometown, COUNT(teacher.Teacher_ID) AS teacher_count FROM teacher GROUP BY teacher.Hometown;","SELECT Hometown ,  COUNT(*) FROM teacher GROUP BY Hometown",course_teach,"1. Sequential Structure: Start with the SELECT clause to specify the hometown and the count of teachers for each hometown. 2. Aggregation Structure: Use COUNT to calculate the number of teachers for each hometown. 3. Grouping Structure: Use GROUP BY on ""teacher.Hometown"" to group the results by each hometown. 4. Join Structure: No JOIN is required since all necessary data is within the ""teacher"" table.","[('Blackrod Urban District', 1), ('Bolton County Borough', 1), ('Farnworth Municipal Borough', 1), ('Horwich Urban District', 1), ('Kearsley Urban District', 1), ('Little Lever Urban District', 1), ('Turton Urban District', 1)]","[('Blackrod Urban District', 1), ('Bolton County Borough', 1), ('Farnworth Municipal Borough', 1), ('Horwich Urban District', 1), ('Kearsley Urban District', 1), ('Little Lever Urban District', 1), ('Turton Urban District', 1)]",,1.0,
Find the highest rank of losers in all matches.,[matches.loser_rank],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT MAX(matches.loser_rank) AS highest_loser_rank FROM matches;,SELECT min(loser_rank) FROM matches,wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the highest rank of losers in all matches. 2. Aggregation Structure: Use the MAX function to find the maximum value of ""matches.loser_rank"". 3. Condition Structure: No specific filtering condition is required since we are considering all matches. 4. Join Structure: No JOIN is required as the necessary information is available in the ""matches"" table.","[(112,)]","[(1,)]",,1.0,
find the number of distinct country codes of all players.,[players.country_code],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT COUNT(DISTINCT players.country_code) FROM players;,SELECT count(DISTINCT country_code) FROM players,wta_1,"1. Sequential Structure: Start with the SELECT clause to count the distinct country codes of all players. 2. Condition Structure: No specific filtering condition is required as we want to consider all players. 3. Join Structure: No JOIN is necessary since the required information is available within the ""players"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""players.country_code"" to count the unique country codes.","[(153,)]","[(153,)]",,1.0,
Find the average number of staff working for the museums that were open before 2009.,"[museum.Num_of_Staff, museum.Open_Year]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",EASY,SELECT AVG(museum.Num_of_Staff) AS avg_staff FROM museum WHERE museum.Open_Year < 2009;,SELECT avg(num_of_staff) FROM museum WHERE open_year  <  2009,museum_visit,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average number of staff. 2. Condition Structure: Use a WHERE clause to filter museums that were open before 2009. 3. Aggregation Structure: Use the AVG function to calculate the average number of staff for the filtered museums. 4. Join Structure: No JOIN is required since all necessary data is within the ""museum"" table.","[(31.333333333333332,)]","[(31.333333333333332,)]",,1.0,
"What are the first names of all players, and their total ranking points?","[players.first_name, rankings.ranking_points, players.player_id = rankings.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT players.first_name, SUM(rankings.ranking_points) AS total_ranking_points FROM players JOIN rankings ON players.player_id = rankings.player_id GROUP BY players.first_name;","SELECT sum(ranking_points) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""players.first_name"" and the total ""rankings.ranking_points"" for each player. Use an aggregate function (SUM) to calculate the total ranking points. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""players"" and ""rankings"" tables based on the foreign key relationship ""players.player_id = rankings.player_id"" to associate players with their ranking points. 4. Aggregation Structure: Use SUM to calculate the total ranking points for each player and GROUP BY ""players.first_name"" to group the results by player.","[('Aastha', 68), ('Abbi', 304), ('Abbie', 5214), ('Abigail', 115293), ('Abiodun', 120), ('Abir', 72), ('Adeliya', 490), ('Adnya', 219), ('Adriana', 28045), ('Adrienn', 107), ('Adrijana', 4619), ('Adva', 9), ('Afroditi', 156), ('Agata', 1901), ('Agata Jadwiga', 219), ('Agne', 110), ('Agnes', 390148), ('Agnese', 13717), ('Agni', 2929), ('Agnieszka', 1801033), ('Agustina', 21728), ('Agustina Elena', 158), ('Ah', 141), ('Ahlam', 85), ('Ahsha', 52), ('Ai', 10751), ('Ai Wen', 2217), ('Aida', 703), ('Aiko', 140108), ('Ailen', 288), ('Aimee', 226), ('Aina', 92), ('Ainhoa', 2433), ('Aishwarya', 96), ('Ajla', 116548), ('Akari', 11873), ('Akgul', 228538), ('Aki', 14838), ('Akiho', 83), ('Akiko', 84446), ('Akilah', 742), ('Akvile', 640), ('Alana', 385), ('Alba', 1424), ('Alberta', 238803), ('Albina', 10507), ('Aldana', 71), ('Alejandra', 1578), ('Aleksandra', 451414), ('Aleksandrina', 35957), ('Alena', 8832), ('Alessandra', 235), ('Alessia', 2524), ('Alessondra', 265), ('Alexa', 138782), ('Alexandra', 955267), ('Alexandria', 191), ('Alexia', 12829), ('Alexis', 13389), ('Aliaksandra', 61196), ('Alice', 57745), ('Alice Andrada', 2358), ('Alicia', 993), ('Alicja', 5216), ('Alina', 11393), ('Aliona', 2369), ('Alisa', 369810), ('Alison', 323527), ('Alix', 5422), ('Alize', 596901), ('Alla', 253320), ('Allie', 33054), ('Almudena', 206), ('Alona', 4052), ('Alory Regina Elorriaga', 155), ('Alyona', 25183), ('Amanda', 68207), ('Amandine', 41575), ('Amelie', 887), ('Amina', 1990), ('Aminat', 12708), ('Amira', 157), ('Amra', 60702), ('Amrita', 159), ('Amy', 10616), ('An Sophie', 51803), ('Ana', 1589674), ('Ana Bianca', 2421), ('Ana Clara', 36696), ('Ana Gabriela', 288), ('Ana Luisa', 21), ('Ana Paula', 2141), ('Ana Sofia', 15955), ('Ana Victoria', 1367), ('Anabel', 678793), ('Anaeve', 1962), ('Anais', 46908), ('Anamika', 2338), ('Anastasia', 1433335), ('Anastasia Evgenyevna', 1235), ('Anastasiia', 12), ('Anastasija', 268277), ('Anastasiya', 75850), ('Anca', 101), ('Anda', 160), ('Andie K', 605), ('Andjela', 228), ('Andra Maria', 51), ('Andrea', 920433), ('Andrea Renee', 464), ('Andreea', 1484), ('Andreea Amalia', 1365), ('Andreea Roxana', 12727), ('Andreja', 74453), ('Andressa Cristina', 72), ('Andrina', 159), ('Aneta', 202), ('Anett', 71072), ('Anette', 1657), ('Ange Oby', 36), ('Angela', 245), ('Angelica', 13643), ('Angeliki', 677), ('Angelina', 19048), ('Angelique', 1132514), ('Anhelina', 17967), ('Anhzelika', 836), ('Ani', 48811), ('Anita', 2177), ('Anja', 11596), ('Anke', 54), ('Ankita', 21599), ('Ann', 62), ('Anna', 1017069), ('Anna Arina', 6650), ('Anna Giulia', 49207), ('Anna Karolina', 107880), ('Anna Katalina', 907), ('Anna Lena', 359374), ('Anna Maria', 1427), ('Annalisa', 29442), ('Anne', 647811), ('Anne Liz', 5269), ('Anne Marie', 99), ('Anne Sophie', 33), ('Annie', 172), ('Annika', 169371), ('Anouk', 3621), ('Antonela', 280), ('Antonia', 21624), ('Antonina', 484), ('Anushka', 480), ('Ao', 4941), ('Apichaya', 126), ('Arabela', 11608), ('Arantxa', 434692), ('Aranza', 24184), ('Aravane', 383495), ('Ariadna', 980), ('Arina', 96852), ('Arina Gabriela', 3), ('Arlinda', 154), ('Arthi', 39), ('Aryna', 19446), ('Aselya', 238), ('Asha', 99), ('Ashleigh', 58741), ('Ashley', 49980), ('Ashling', 5155), ('Ashmitha', 648), ('Ashvarya', 2321), ('Asia', 48788), ('Asiya', 802), ('Assia', 141), ('Astra', 1083), ('Astrid Wanja', 269), ('Audrey', 33624), ('Avgusta', 21), ('Axana', 7), ('Ayaka', 7996), ('Ayan', 571), ('Ayano', 5173), ('Ayla', 7444), ('Aymet', 791), ('Ayu Fani', 38501), ('Ayumi', 309990), ('Azra', 11721), ('Barbara', 53401), ('Barbora', 515957), ('Basak', 26624), ('Beatrice', 27061), ('Beatriz', 98798), ('Beatriz Magdalena', 75), ('Beatriz Maria', 1920), ('Beauty', 26), ('Belen', 351), ('Belinda', 137327), ('Benedetta', 11032), ('Berfu', 2850), ('Bermet', 8441), ('Bernarda', 19092), ('Bernice', 3894), ('Berta', 814), ('Bethanie', 371662), ('Betina', 21), ('Bhuvana', 1152), ('Bianca', 63998), ('Bianka', 1213), ('Bibiane', 50184), ('Blair', 905), ('Blanca', 312), ('Blessing', 662), ('Boba', 123), ('Bojana', 283166), ('Borislava', 3470), ('Boyan', 1465), ('Brandy', 725), ('Breaunna', 676), ('Brenda', 166760), ('Brianna', 2922), ('Brienne', 12), ('Brindtha', 30), ('Britt', 2487), ('Brittany', 1119), ('Brooke', 7062), ('Brynn', 1344), ('Bunyawi', 3187), ('Busra', 537), ('Cagla', 119797), ('Caitlin', 15218), ('Camelia Elena', 9147), ('Cameron', 38), ('Camila', 202172), ('Camila Vital', 136), ('Camilla', 11714), ('Camille', 574), ('Cara', 240762), ('Carina', 90451), ('Carla', 669546), ('Carlota', 27), ('Carlotta', 562), ('Carly', 67459), ('Carmen', 8174), ('Carmen Raluca', 1077), ('Carol', 14213), ('Carolin', 9093), ('Carolina', 36889), ('Carolina Meligeni Rodrigues', 3627), ('Caroline', 2076949), ('Caroline B', 111), ('Carolyn', 72), ('Carson', 289), ('Casey', 202697), ('Catalina', 250056), ('Catherine', 4987), ('Catherine Cartan', 45884), ('Caty', 22), ('Cecilia', 11954), ('Cecilie Lundgaard', 95), ('Celine', 18824), ('Cemre', 958), ('Chalena', 4914), ('Chanel', 62861), ('Chanelle', 275364), ('Chang', 26585), ('Chanikarn', 39), ('Chantal', 15001), ('Chantelle', 187), ('Chaoyi', 15), ('Charlene', 5683), ('Charlotte', 4356), ('Chayenne', 20132), ('Chelsea', 5), ('Chelsey', 6777), ('Chen', 26779), ('Chengyiyi', 277), ('Chi Chi', 49122), ('Chi Fan', 667), ('Chia Hsien', 679), ('Chia Jung', 33301), ('Chiaki', 42773), ('Chiara', 6159), ('Chieh Yu', 34796), ('Chihiro', 15401), ('Chin Wei', 70504), ('Chinami', 13141), ('Ching Wen', 7975), ('Chiraz', 1726), ('Chisa', 358), ('Chloe', 15190), ('Chompoothip', 276), ('Christie', 24), ('Christina', 310215), ('Christine', 2438), ('Chun Mei', 12519), ('Chun Yan', 3374), ('Cindy', 31620), ('Claire', 141876), ('Clara', 116), ('Claudia', 32581), ('Claudia Antonia', 1227), ('Claudia Gianina', 934), ('Claudine', 106762), ('Clelia', 2221), ('Clemence', 1622), ('Clementina Eugenia', 538), ('Clothilde', 12304), ('Coco', 235721), ('Colomba', 129), ('Conny', 52274), ('Constance', 25166), ('Constanza', 907), ('Constanze', 18), ('Corina', 1002), ('Corinna', 102260), ('Cornelia', 4053), ('Cory Ann', 20869), ('Costanza', 1236), ('Cristiana', 7486), ('Cristina', 59412), ('Cristina Andreea', 75414), ('Cristina Madalina', 317), ('Csilla', 6256), ('Cynthia', 1034), ('Da Hye', 1417), ('Dabin', 1261), ('Dagmara', 160), ('Daiana', 8589), ('Dajana', 150), ('Dalia', 8939), ('Dalila', 48857), ('Dalma', 15935), ('Damilola', 0), ('Damini', 12), ('Damira', 30), ('Dan Ni', 639), ('Dana', 3121), ('Daneika', 1607), ('Danica', 17597), ('Daniela', 1165205), ('Daniella', 16663), ('Danielle', 40823), ('Danielle Rose', 8507), ('Danijela', 545), ('Danka', 87958), ('Daphne', 33), ('Daria', 170617), ('Darija', 41925), ('Dariya', 857), ('Darya', 163036), ('Dasha', 1923), ('Dayana', 5619), ('Dea', 7027), ('Deborah', 7605), ('Deeon', 141), ('Dejana', 9846), ('Demi', 1192), ('Denisa', 65522), ('Denise', 3298), ('Denise Antonela', 168), ('Deniz', 23620), ('Deria', 215), ('Desirae', 354), ('Desiree', 709), ('Despina', 19065), ('Despoina', 3942), ('Destanee', 9227), ('Dewi', 134), ('Dhruthi', 2738), ('Di', 9780), ('Dia', 79958), ('Diana', 119279), ('Diana Maria', 99), ('Dianne', 6369), ('Dijana', 7353), ('Dilara', 85), ('Dina', 149), ('Dinah', 67017), ('Doga Selen', 117), ('Domenica', 1614), ('Dominika', 918746), ('Dominique', 455), ('Donika', 164), ('Donna', 114098), ('Dorien', 109), ('Doroteja', 23976), ('Draginja', 392), ('Dunja', 4703), ('Ebony', 713), ('Eden', 1978), ('Edina', 249446), ('Eduarda', 11216), ('Eetee', 2446), ('Ege', 50), ('Ekaterina', 1005319), ('Ekaterine', 26897), ('Elaine', 103), ('Eleanor', 2287), ('Elena', 1247887), ('Elena Gabriela', 7772), ('Elena Teodora', 6547), ('Eleni', 439179), ('Eleonora', 405), ('Eleonore', 567), ('Eliessa', 882), ('Elina', 314747), ('Elisabeth', 4709), ('Elise', 43779), ('Elitsa', 87263), ('Elixane', 18211), ('Eliza', 480), ('Elizabeta', 536), ('Elizabeth', 20368), ('Elizabeth Anita Alexandria', 1103), ('Elizaveta', 62977), ('Elizaveta Anna', 636), ('Elke', 960), ('Ella', 526), ('Ellen', 13761), ('Ellie', 8079), ('Elodie', 90), ('Elyne', 12554), ('Ema', 11218), ('Emelyn', 12728), ('Emi', 3880), ('Emilia', 43), ('Emiliana', 1258), ('Emilie', 1440), ('Emilija', 24), ('Emiliya', 541), ('Emily', 52889), ('Emily J', 964), ('Emina', 3029), ('Emma', 85022), ('Emma Christine', 65), ('Emmanuelle', 1609), ('En Pei', 52), ('Ena', 823), ('Eri', 34570), ('Erica', 472), ('Erika', 165477), ('Erin', 5356), ('Erina', 1225), ('Esen', 69), ('Estela', 376), ('Estelle', 39989), ('Ester', 3908), ('Estrella', 126811), ('Etsuko', 7147), ('Eudice Wong', 976), ('Eugenia', 36), ('Eugenie', 204801), ('Eugeniya', 20989), ('Eva', 320083), ('Eva Marie', 41), ('Eveliina', 744), ('Evelyn', 27011), ('Evgenia', 59775), ('Evgeniya', 206981), ('Fang Ying', 7755), ('Fangzhou', 33388), ('Fanny', 11260), ('Farah', 167), ('Fatima', 10865), ('Fatimah', 898), ('Fatma', 21261), ('Fatyha', 80), ('Federica', 56817), ('Federica Joe', 44), ('Fernanda', 17587), ('Ferny', 78), ('Fiona', 18219), ('Flavia', 1011058), ('Florencia', 89361), ('Frances', 359), ('Francesca', 1306087), ('Francisca', 157), ('Francoise', 21685), ('Franziska', 994), ('Frederikke', 9), ('Freya', 6525), ('Gabriela', 102623), ('Gabriela Nicole', 468), ('Gabriella', 6179), ('Gabrielle Faith', 1093), ('Gaelle', 1000), ('Gaia', 7998), ('Gail', 38651), ('Galina', 302957), ('Ganna', 30136), ('Garbine', 412872), ('Gebriela', 143), ('Genevieve', 440), ('Georgia', 9600), ('Georgia Andreea', 1848), ('Georgiana', 48), ('Georgina', 11569), ('Ghislaine', 290), ('Giada', 677), ('Gioia', 31741), ('Giorgia', 2484), ('Giorgie', 13), ('Giovanna', 289), ('Giulia', 106520), ('Giuliana', 2935), ('Gloria', 1297), ('Gozal', 2864), ('Grace', 70613), ('Gracia', 7999), ('Greetje', 6168), ('Greta', 240195), ('Guadalupe', 14277), ('Guillermina', 576), ('Guiomar', 687), ('Gulben', 410), ('Gulchekhra', 18), ('Gulnaz', 39), ('Guzal', 775), ('Gyulnara', 238), ('Habiba', 811), ('Hae Sung', 8180), ('Haine', 294), ('Hana', 413), ('Hanna', 2782), ('Hanyu', 4643), ('Hao Chen', 9631), ('Hao Ching', 224), ('Harmony', 5944), ('Harriet', 8608), ('Haruka', 3633), ('Haruna', 1873), ('Hayley', 1679), ('Hazal', 78), ('Heather', 202780), ('Heidi', 88542), ('Helen', 1039), ('Helene', 3928), ('Hikari', 122), ('Hilda', 10191), ('Himari', 3), ('Hiroko', 27580), ('Hirono', 4368), ('Ho Ching', 2371), ('Hollie', 24), ('Hongrui', 1063), ('Hortencia', 98), ('Hsin Yuan', 120), ('Hua Chen', 7367), ('Huijie', 118), ('Hulya', 7797), ('Hye Min', 1222), ('Hyojung', 870), ('Hyun Hui', 8301), ('I Hsuan', 511), ('Iana', 395), ('Ida', 467), ('Idia', 45), ('Iga', 916), ('Ilay', 52), ('Ilka', 1142), ('Ilona', 26950), ('Ilze', 1527), ('Imane Maelle', 1676), ('Ina', 292), ('Inci', 406), ('India', 762), ('Indire', 12633), ('Indy', 17382), ('Ineke', 1358), ('Ines', 40410), ('Inger', 221), ('Ingrid', 3471), ('Ingrid Alexandra', 4766), ('Ingrid Esperanza', 10133), ('Intissar', 33), ('Ioana', 1225), ('Ioana Diana', 2403), ('Ioana Loredana', 5425), ('Ionela Andreea', 6948), ('Ipek', 39352), ('Irena', 88369), ('Irene', 3133), ('Irina', 299698), ('Irina Camelia', 293366), ('Irina Maria', 13843), ('Iris', 4743), ('Iryna', 87844), ('Isabel', 6688), ('Isabela', 714), ('Isabella', 83476), ('Isabelle', 4777), ('Iulia Maria', 74), ('Iva', 10322), ('Ivana', 100848), ('Ivania', 2094), ('Ivanka', 291), ('Iveta', 443695), ('Ivette', 543), ('Ivone', 253), ('Ivonne', 13010), ('Jacqueline', 27462), ('Jada', 64), ('Jade', 26209), ('Jaeda', 1375), ('Jaimee', 5007), ('Jaimy Gayle', 24), ('Jainy', 761), ('Jamie', 190997), ('Jamilya', 18), ('Jan', 10947), ('Jana', 268372), ('Janette', 143422), ('Janina', 12525), ('Janja', 72), ('Janneke', 861), ('Jaqueline Adina', 5416), ('Jara', 464), ('Jarmila', 333150), ('Jasmin', 34453), ('Jasmina', 43862), ('Jasmine', 14865), ('Jasmine Amber', 142), ('Jawairiah', 822), ('Jazmin', 908), ('Jazzamay', 628), ('Jeannine', 3426), ('Jelena', 2515436), ('Jennifer', 81222), ('Jenny', 1002), ('Jesika', 17819), ('Jessica', 154599), ('Jessika', 4122), ('Jessy', 923), ('Ji Hee', 7179), ('Ji Young', 8592), ('Jia', 52), ('Jia Jing', 48117), ('Jia Qi', 4612), ('Jiahui', 1553), ('Jiakang', 15), ('Jiatian', 100), ('Jiaxi', 3002), ('Jiaxue', 96), ('Jie', 610820), ('Jil Belen', 13978), ('Jil Nora', 611), ('Jill', 359013), ('Jillian', 1991), ('Jin', 15), ('Jin A', 46355), ('Jin Ju', 414), ('Jing Jing', 68925), ('Joana', 1955), ('Joanna', 472), ('Joanne', 15), ('Jodie Anna', 355), ('Johana', 40), ('Johanna', 553107), ('Jordana', 1092), ('Josepha', 2710), ('Josephine', 4980), ('Josie', 804), ('Jovana', 39270), ('Ju Eun', 3453), ('Judith', 3), ('Jule', 63), ('Julia', 891796), ('Julia Mansano', 21), ('Juliana', 414), ('Juliana Rocha', 129), ('Julie', 156531), ('Julieta Lara', 4093), ('Julita', 286), ('Julyette Maria Josephine', 1446), ('June', 114), ('Junri', 128183), ('Justina', 36), ('Justine', 39418), ('Justyna', 30304), ('Kady', 467), ('Kai Chen', 172004), ('Kai Lin', 37817), ('Kaia', 625836), ('Kaitlin', 416), ('Kaitlyn', 3905), ('Kaja', 1176), ('Kajsa', 2280), ('Kamila', 12906), ('Kamilla', 249), ('Kamonwan', 5866), ('Kana', 1536), ('Kanae', 20142), ('Kanako', 229), ('Kanami', 3724), ('Kanika', 919), ('Kaori', 8406), ('Karen', 32169), ('Kariann', 85), ('Karin', 254520), ('Karina', 9355), ('Karina Ildor', 5493), ('Karina Kristina', 410), ('Karine', 1936), ('Karis', 1003), ('Karla', 3127), ('Karman', 3193), ('Karola Patricia', 776), ('Karolayne', 465), ('Karolina', 512490), ('Karoline', 910), ('Karyn', 330), ('Kassandra', 704), ('Katalin', 112562), ('Katarina', 444303), ('Katarzyna', 93730), ('Kate', 34), ('Katerina', 160945), ('Kateryna', 435038), ('Katharina', 24595), ('Katharine', 363), ('Katherine', 7843), ('Katherine Gabriela', 1894), ('Kathinka', 15970), ('Kathrin', 141281), ('Katie', 30035), ('Katrine Isabel', 308), ('Katy', 11572), ('Katya', 515), ('Katyarina', 97), ('Kayla', 13697), ('Kaylah', 237), ('Kazusa', 10107), ('Kei', 294), ('Kelia', 324), ('Kelly', 4705), ('Kelly S', 5880), ('Kelsey', 410), ('Kennedy', 653), ('Keren', 24062), ('Keri', 894), ('Kerstin', 942), ('Khristina', 3748), ('Ki Ryang', 86), ('Kiki', 214121), ('Kim', 4580), ('Kim Alice', 12388), ('Kimberley', 5393), ('Kimberly', 4831), ('Kimika', 272), ('Kimiko', 270102), ('Kinnie', 15102), ('Kirsten', 383077), ('Kirsten Andrea', 462), ('Klaartje', 5818), ('Klara', 568191), ('Klaudia', 4809), ('Komola', 701), ('Korina', 21417), ('Kotomi', 4962), ('Krista', 17577), ('Kristie', 34647), ('Kristina', 601693), ('Kristina N', 555), ('Kristy', 1899), ('Kristyna', 148728), ('Ksenia', 371140), ('Kseniia', 298), ('Ksenija', 625), ('Kumiko', 56212), ('Kurumi', 177170), ('Kveta', 210101), ('Kwan Yau', 403), ('Kyle', 3200), ('Kylie', 1236), ('Kyoka', 9036), ('Kyra', 102022), ('Kyung Mi', 26059), ('Laetitia', 6078), ('Laili', 595), ('Lamis', 456), ('Lara', 177458), ('Larikah', 255), ('Laura', 578964), ('Laura D', 281), ('Laura Ioana', 33822), ('Laura Sofia', 97), ('Lauren', 244807), ('Lauryn', 207), ('Lavinia', 23897), ('Laylo', 39), ('Layne', 22), ('Lea', 4197), ('Leah', 152), ('Lee', 733), ('Lena', 27997), ('Lena Marie', 14942), ('Lenka', 164900), ('Leolia', 750), ('Leonie', 672), ('Lesedi Sheya', 286), ('Lesia', 225987), ('Lesley', 42925), ('Leslie', 173), ('Leticia', 45115), ('Leticia Garcia', 87), ('Leylah Annie', 48), ('Li', 1696), ('Liana Gabriela', 59997), ('Libby', 2362), ('Libi', 522), ('Lidia', 169), ('Lidziya', 6809), ('Liezel', 39782), ('Liga', 23411), ('Lilla', 1960), ('Lin', 40341), ('Lina', 91117), ('Linda', 4216), ('Lindsay', 142454), ('Lindsey', 500), ('Ling', 64525), ('Liniques', 72), ('Linnea', 697), ('Lisa', 594217), ('Lisa Maria', 7898), ('Lisa Marie', 1583), ('Lisanne', 8284), ('Liubov', 2662), ('Livia', 128), ('Liz Tatiane', 2216), ('Lizaveta', 135), ('Lizette', 11623), ('Lorenza', 33), ('Lorraine M', 40), ('Lou', 10167), ('Loudmilla', 6), ('Louisa', 50700), ('Louise', 1633), ('Lourdes', 371035), ('Lu', 3445), ('Luca', 1013), ('Lucia', 17185), ('Luciana', 8305), ('Lucie', 1108372), ('Lucrezia', 1589), ('Lucy', 6542), ('Ludmila', 645), ('Ludmilla', 1187), ('Luisa', 1671), ('Luisa Marie', 1822), ('Luksika', 77519), ('Lulu', 304), ('Luna', 15), ('Lusine', 377), ('Lutfiye', 876), ('Lyann', 30), ('Lynn', 837), ('Lyudmyla', 54172), ('Macall', 12379), ('Macarena', 2133), ('Madalina', 62938), ('Maddison', 2434), ('Madeleine', 715), ('Madeline', 147), ('Madina', 6), ('Madison', 476768), ('Madrie', 2266), ('Maegan', 525), ('Mafalda', 163), ('Maftuna', 54), ('Magali', 1917), ('Magalie', 511), ('Magda', 103659), ('Magdalena', 401857), ('Magy', 756), ('Mahak', 154), ('Mahitha', 395), ('Mai', 19173), ('Maia', 1235), ('Maia A', 12), ('Maiko', 11320), ('Maileen', 83), ('Mailen', 39523), ('Maja', 1067), ('Makiho', 5592), ('Makoto', 14129), ('Malene', 316), ('Malika', 323), ('Malin', 2489), ('Mallaurie', 688), ('Mallory', 44497), ('Malou', 3073), ('Mami', 96), ('Man Ying Maggie', 102), ('Mana', 9593), ('Mananchaya', 15), ('Manca', 2070), ('Mandy', 193767), ('Manisha', 3112), ('Manon', 14608), ('Manya', 93), ('Mara', 702), ('Marcela', 16790), ('Marcela Guimaraes', 683), ('Marcelina', 33), ('Marcella', 13037), ('Margalita', 99836), ('Margarida', 1997), ('Margarita', 78265), ('Margaux', 905), ('Margot', 4787), ('Mari', 38086), ('Maria', 3613355), ('Maria Agustina', 185), ('Maria Andrea', 323), ('Maria Camila', 148), ('Maria Constanza De Las Mercedes', 1892), ('Maria Del Rosario', 296), ('Maria Elena', 296736), ('Maria Fernanda', 141257), ('Maria Jesus', 294), ('Maria Joao', 72682), ('Maria Jose', 413759), ('Maria Lourdes', 156), ('Maria Paulina', 1388), ('Maria Teresa', 106375), ('Mariam', 4060), ('Mariana', 201258), ('Marianna', 10178), ('Marianne', 1090), ('Mariaryeni', 226), ('Marie', 25496), ('Marie Eve', 114687), ('Mariia', 206), ('Marija', 20481), ('Marijana', 3), ('Marina', 362372), ('Marine', 4314), ('Marion', 1272285), ('Mariona', 4), ('Marisa', 1026), ('Mariya', 154484), ('Marketa', 18286), ('Marlies', 1624), ('Marrit', 1339), ('Marta', 267679), ('Marta Huqi', 778), ('Martha', 153), ('Martina', 109192), ('Mary', 653), ('Mary Ann', 102), ('Maryna', 85425), ('Masa', 117472), ('Mathilde', 245139), ('Matilda', 3466), ('Maud', 210), ('Maureen', 219), ('Maurien', 138), ('Maxine', 390), ('May', 225), ('Maya', 23668), ('Mayar', 1788), ('Mayo', 32445), ('Mayya', 9064), ('Megan', 13254), ('Megumi', 407), ('Mei Xu', 40), ('Meiling', 417), ('Meiqi', 96), ('Melanie', 385636), ('Melany Solange', 97), ('Melina', 2609), ('Melinda', 290299), ('Melis', 20196), ('Melisa', 340), ('Melissa', 200), ('Melissa Ishuan', 171), ('Meng Ning', 542), ('Mercedes', 48), ('Merel', 101), ('Meritxell', 284), ('Mervana', 102693), ('Mi', 24569), ('Mi Jeong', 176), ('Mi Rae', 1858), ('Mi Zhuoma', 72), ('Mia Nicole', 1098), ('Micaela', 230), ('Michaela', 76586), ('Michaella', 242619), ('Michela', 90), ('Michele Alexandra', 596), ('Michelle', 160164), ('Michika', 3657), ('Mihaela', 69242), ('Mihaela Lorena', 15), ('Miharu', 21205), ('Mihika', 427), ('Mihoki', 201), ('Miki', 24542), ('Mila', 107), ('Milagros', 42), ('Milana', 14123), ('Milena', 279), ('Milica', 63), ('Min', 1884), ('Min Hwa', 9938), ('Minami', 96), ('Mira', 1626), ('Mirabelle', 1977), ('Miranda', 180), ('Miriam', 3825), ('Miriam Bianca', 1458), ('Miriana', 1180), ('Mirjam', 272), ('Mirjana', 331434), ('Misa', 55981), ('Misaki', 203782), ('Mitsumi', 309), ('Miyabi', 22840), ('Miyu', 23968), ('Mizuno', 2927), ('Molly', 565), ('Momoko', 2061), ('Mona', 282445), ('Monica', 587309), ('Monika', 1240), ('Monique', 114104), ('Montserrat', 23564), ('Morgane', 6906), ('Moulika', 15), ('Mouna', 12), ('Moyuka', 32), ('Muazzez', 6), ('Muge', 162), ('Myrtille', 43550), ('Na', 1358928), ('Na Lae', 26185), ('Na Ri', 19223), ('Nadezda', 5027), ('Nadia', 1401125), ('Nadiya', 56596), ('Nadja', 2661), ('Nagi', 1535), ('Naiktha', 4380), ('Naima', 440), ('Nam Yeon', 259), ('Nan Nan', 3094), ('Nanuli', 16494), ('Nao', 59671), ('Naoko', 857), ('Naomi', 163239), ('Napatsakorn', 1945), ('Nastassia', 72), ('Nastassja', 65152), ('Nastja', 29250), ('Natalia', 97400), ('Natalie', 120995), ('Natalija', 13686), ('Nataliya', 33), ('Natasa', 14212), ('Natasha', 15365), ('Natela', 16303), ('Natella', 649), ('Nathalia', 28098), ('Nathaly', 13241), ('Natia', 2526), ('Natsumi', 37981), ('Nattawadee', 224), ('Naz', 251), ('Nazari', 980), ('Neda', 9536), ('Nelise', 142), ('Nermeen', 279), ('Nevena', 170), ('Nicha', 30972), ('Nicky', 2531), ('Nicola', 33550), ('Nicole', 447434), ('Nicoleta Catalina', 8146), ('Nicolette', 9627), ('Nidhi', 5425), ('Nigina', 47651), ('Nika', 9120), ('Nikita', 22), ('Nikki', 614), ('Nikol', 491), ('Nikola', 78513), ('Nina', 201173), ('Nina Isabella', 115), ('Nives', 2706), ('Noel', 1558), ('Noelia', 2025), ('Noelle', 1795), ('Nonna', 134), ('Noppawan', 73589), ('Nora', 1082), ('Nour', 760), ('Nozomi', 1333), ('Nudnida', 63013), ('Nungnadda', 24523), ('Nuria', 259116), ('Oana', 1096), ('Oana Georgeta', 4294), ('Oceane', 56853), ('Ofri', 5372), ('Oksana', 58279), ('Ola', 3497), ('Olawaseun', 2), ('Olaya', 40), ('Oleksandra', 8700), ('Olena', 484), ('Olesya', 3811), ('Olga', 773929), ('Olivia', 119756), ('Oliwia', 363), ('Ons', 56242), ('Ornella', 2133), ('Oyku', 382), ('Paige Mary', 147), ('Pamela', 241), ('Panna', 1446), ('Paola', 403127), ('Parris', 209), ('Patcharin', 1188), ('Patricia', 197904), ('Patricia Maria', 43755), ('Patrycja', 17514), ('Patty', 7323), ('Paula', 172431), ('Paula Andrea', 269), ('Paula Catalina', 3714), ('Paula Cristina', 37384), ('Paulina', 3208), ('Pauline', 313187), ('Pavla', 4128), ('Peangtarn', 26280), ('Peggy', 1016), ('Pei Chi', 8900), ('Pei Hsuan', 24), ('Pei Ju', 181), ('Pemra', 60908), ('Pernilla', 6573), ('Petia', 1832), ('Petra', 1958404), ('Phenomena', 3), ('Phillis', 664), ('Pia', 10859), ('Piia', 21340), ('Pilar', 6404), ('Pippa', 243), ('Plobrung', 934), ('Polina', 76747), ('Polona', 325216), ('Poojashree', 13006), ('Pranjala', 1214), ('Prarthana G', 5687), ('Prerna', 9318), ('Priscila', 510), ('Priscilla', 8203), ('Qiang', 116857), ('Qianhui', 683), ('Qianqian', 641), ('Qiu Yu', 2034), ('Quinn', 646), ('Quirine', 22978), ('Rachael', 2592), ('Rachel', 469), ('Radina', 699), ('Rafaela', 228), ('Ralina', 40), ('Raluca', 148701), ('Raluca Elena', 9202), ('Raluca Georgiana', 4258), ('Ramu', 443), ('Ramya', 161), ('Ran', 14709), ('Rana', 9), ('Raquel', 30401), ('Rashmi', 741), ('Ratnika', 957), ('Raveena', 5387), ('Rebeca', 168), ('Rebecca', 165013), ('Rebeka', 5803), ('Regina', 122331), ('Reina', 64), ('Reka Luca', 66271), ('Remi', 38116), ('Renata', 201856), ('Ria', 5566), ('Rianna', 984), ('Richel', 84184), ('Rika', 141257), ('Riko', 23195), ('Rio', 556), ('Risa', 62252), ('Rishika', 8448), ('Rita', 1401), ('Riya', 2634), ('Roberta', 809611), ('Robin', 12295), ('Robyn', 1103), ('Rocio', 16886), ('Romana', 29214), ('Romana Caroline', 17020), ('Romina', 253471), ('Romy', 911), ('Rona', 308), ('Ronit', 3165), ('Ronke', 49), ('Roosh', 28), ('Rosa', 111), ('Rosalia', 803), ('Rosalie', 880), ('Rosie', 336), ('Roxane', 38793), ('Rui', 24), ('Rushmi', 27452), ('Rutuja', 3642), ('Ryann', 597), ('Saana', 195), ('Sabastiani', 780), ('Sabina', 49784), ('Sabina Elena', 27), ('Sabine', 590911), ('Sabrina', 6810), ('Sacha', 78204), ('Sachia', 49767), ('Sachie', 42676), ('Sadafmoh', 2275), ('Sai Samhitha', 1034), ('Saisai', 113359), ('Sakiko', 9338), ('Sally', 53480), ('Salma', 66), ('Samantha', 1437656), ('Samira', 2020), ('Sanae', 354), ('Sanaz', 17975), ('Sandra', 266197), ('Sandy', 224), ('Sang Hee', 1277), ('Sania', 272889), ('Sara', 914981), ('Sarah', 78461), ('Sarah Beth', 1270), ('Sarah Rebecca', 13064), ('Sarahi', 461), ('Sarai Delfina', 148), ('Saray', 2061), ('Sari', 464), ('Sarlota', 27), ('Sarvinoz', 178), ('Sasa', 316), ('Saska', 2641), ('Satsuki', 906), ('Savannah', 70), ('Schena', 148), ('Se Hyun', 143), ('Se Jin', 681), ('Sean', 75), ('Seda', 1469), ('Seira', 144), ('Selin', 169), ('Seo Kyung', 6564), ('Seone', 1312), ('Serena', 4232828), ('Sesil', 208108), ('Seung Yeon', 6650), ('Severine', 192296), ('Shahar', 662926), ('Shakhlo', 2122), ('Shakhnoza', 198), ('Shangqing', 111), ('Shanshan', 2378), ('Shao Yuan', 1363), ('Sharmada', 4106), ('Sharon', 117825), ('Sharon Sanchana', 522), ('Shelby', 102140), ('Shelly', 142), ('Sheng Nan', 53610), ('Sherazad', 22977), ('Sherry', 801), ('Shiho', 39960), ('Shilin', 9634), ('Shiori', 18), ('Shir', 117), ('Shiran', 236), ('Shivika', 4611), ('Shou Na', 105), ('Shreya', 6), ('Shu Ying', 1483), ('Shuai', 913829), ('Shuko', 46124), ('Shuo', 597), ('Shuyue', 336), ('Shweta', 3255), ('Si Qi', 531), ('Silvia', 221695), ('Simona', 724638), ('Simone', 1149), ('Simran Kaur', 467), ('Sina', 10360), ('Sinead', 688), ('Sing Le', 95), ('Siqi', 716), ('Sirui', 276), ('Siyu', 87), ('Sloane', 352458), ('Smriti', 96), ('Sneha', 134), ('Snehadevi S', 2820), ('So Jung', 47282), ('So Ra', 18210), ('Sofia', 484140), ('Sofico', 336), ('Sofie', 10539), ('Sofiya', 18371), ('Sofya', 9180), ('Sohyun', 108), ('Sonia', 480), ('Sonja', 4499), ('Sophia', 96), ('Sophie', 39307), ('Sorana', 457043), ('Sowjanya', 2961), ('Spurti', 159), ('Sri Vaishnavi', 1744), ('Stamatia', 8072), ('Stanislava', 49412), ('Stefana', 497), ('Stefani', 126), ('Stefania', 24897), ('Stefanie', 247237), ('Steffi', 3085), ('Stephanie', 608309), ('Stephanie Mariel', 1397), ('Storm', 21152), ('Su Jeong', 33672), ('Su Wei', 274936), ('Suellen', 320), ('Sultan', 1544), ('Sun Jung', 6591), ('Sunae', 15), ('Sunam', 3594), ('Sung Hee', 29852), ('Susan', 502), ('Susanne', 16276), ('Suzan', 344), ('Suzuho', 324), ('Suzy', 1054), ('Svenja', 6341), ('Svetlana', 1906587), ('Sviatlana', 11201), ('Sybille', 581), ('Sylvia', 1626), ('Sylwia', 8268), ('Syna', 9001), ('Szabina', 2127), ('Tadeja', 83659), ('Taisiya', 1050), ('Talya', 45), ('Tamachan', 843), ('Tamar', 60), ('Tamara', 54140), ('Tamari', 304), ('Tamarine', 594281), ('Tamaryn', 40060), ('Tamira', 322202), ('Tammi', 26077), ('Tanaporn', 764), ('Tanya', 1229), ('Tara', 54798), ('Tatia', 42), ('Tatiana', 34795), ('Tatjana', 230262), ('Tatsiana', 1289), ('Tayisiya', 5051), ('Taylor', 38850), ('Tea', 2127), ('Teliana', 112570), ('Tena', 12402), ('Teodora', 41792), ('Tereza', 193362), ('Terri', 18), ('Tess', 7165), ('Tessah', 9116), ('Tetiana', 75337), ('Tetyana', 43020), ('Thai Sa Grana', 706), ('Theo', 2249), ('Theresa', 377), ('Tijana', 333), ('Timea', 612072), ('Tina', 57585), ('Tinatin', 476), ('Ting Fei', 8145), ('Ting Jr', 8676), ('Tingting', 151), ('Tjasa', 3361), ('Tomoko', 7431), ('Tori', 10630), ('Tornado Alicia', 1864), ('Trang', 1884), ('Treta', 736), ('Tsvetana', 456422), ('Tyra', 4543), ('Ulrikke', 27118), ('Ulyana', 2400), ('Urszula', 275255), ('Ushna', 413), ('Usue Maitane', 7874), ('Valentina', 338), ('Valentine', 9926), ('Valentini', 15198), ('Valentyna', 47854), ('Valeria', 159155), ('Valerie', 6146), ('Valeriya', 16621), ('Vanda', 10087), ('Vanesa', 30669), ('Vanessa', 71645), ('Vania', 299530), ('Vaniya', 255), ('Vanja', 291), ('Varatchaya', 54340), ('Varunya', 3623), ('Varvara', 401409), ('Vasilisa', 42527), ('Vaszilisza', 3763), ('Vendula', 2221), ('Venus', 2875425), ('Vera', 1929137), ('Verena', 3018), ('Veronica', 84543), ('Veronica M', 1678), ('Veronika', 73192), ('Vesna', 169500), ('Vicky', 77), ('Victoire', 454), ('Victoria', 2142854), ('Victoria Ariadna', 106), ('Viktoria', 30191), ('Viktoriia', 90), ('Viktorija', 79511), ('Viktoriya', 26226), ('Viktoryia', 1987), ('Vilma Y', 27), ('Vincenza', 105), ('Vinciane', 37), ('Violetta', 298), ('Virginie', 519208), ('Vishesh', 71), ('Vita', 64), ('Vitalia', 106927), ('Vivian', 36714), ('Vivien', 13041), ('Vivienne', 8918), ('Vlada', 22578), ('Vladica', 997), ('Vladimira', 6470), ('Vladislava', 1254), ('Vladyslava', 2570), ('Vojislava', 18781), ('Voni', 1036), ('Wan Ting', 11653), ('Wan Yi', 42), ('Warona', 9), ('Wen Hsin', 40633), ('Wen Ling', 120), ('Wendy Qi Wen', 613), ('Weronika Jasmina', 179), ('Whitney', 5604), ('Wiktoria', 363), ('Wing Yau Venise', 11694), ('Wushuang', 879), ('Xenia', 14578), ('Xi Yao', 1445), ('Xiao', 4789), ('Xiaodi', 5057), ('Xiaorong', 717), ('Xiaoxi', 1352), ('Ximena', 19495), ('Xin', 8744), ('Xin Yu', 187), ('Xinyu', 10705), ('Xinyun', 109256), ('Xiyu', 315), ('Xu Liu', 4535), ('Ya', 24), ('Ya Hsuan', 17078), ('Yafan', 39687), ('Yan', 4196), ('Yana', 39102), ('Yang', 73), ('Yanina', 602453), ('Yanni', 275), ('Yarden', 32), ('Yaroslava', 404915), ('Yasmin', 11251), ('Yasmina', 27), ('Yasmine', 1748), ('Yasmyn', 71), ('Yawna', 648), ('Yayuk', 128509), ('Ye Ra', 47867), ('Ye Xin', 281), ('Yekaterina', 376), ('Yelena', 1856), ('Yeong Won', 966), ('Yevgeniya', 6288), ('Yi', 19989), ('Yi Fan', 60646), ('Yi Jing', 22443), ('Yi Miao', 61839), ('Yidi', 136), ('Yihong', 24), ('Yijia', 366), ('Ying', 3783), ('Ying Ying', 107595), ('Yixuan', 1380), ('Ylena', 1546), ('Ylona Georgiana', 1453), ('Yoko', 285), ('Yolande', 1381), ('Yoo Ri', 182), ('Yoon Young', 3592), ('Yoshimi', 677), ('Yosr', 75), ('You Na', 242), ('Ysaline', 27804), ('Yu Jin', 452), ('Yu Tong', 9), ('Yuan', 281), ('Yuanyi', 772), ('Yue', 1259), ('Yue Yue', 21360), ('Yuenu', 682), ('Yujia', 184), ('Yuka', 12474), ('Yukako', 84), ('Yuki', 505), ('Yuki Kristina', 2191), ('Yukina', 998), ('Yukun', 1828), ('Yulia', 155143), ('Yuliana', 15248), ('Yuliya', 206375), ('Yumi', 20269), ('Yung Jan', 229391), ('Yuqi', 559), ('Yurika', 101816), ('Yuriko', 1728), ('Yurina', 12693), ('Yuuki', 15071), ('Yuval', 45), ('Yuxuan', 24279), ('Yvonne', 254491), ('Zaineb', 87), ('Zalina', 2052), ('Zarah', 3809), ('Zarina', 123243), ('Zeel', 702), ('Zeynep  Sena', 21), ('Zhanlan', 2166), ('Zhaoxuan', 20236), ('Zhibek', 7), ('Zhima', 99), ('Zhou', 30), ('Zhuoma', 121), ('Zi', 110290), ('Zinovia', 74), ('Ziyue', 1420), ('Zoe', 2772), ('Zoe Gwen', 2877), ('Zsofia', 1501), ('Zuzana', 266251), ('Zuzanna', 2258)]","[(68, 'Aastha'), (304, 'Abbi'), (5214, 'Abbie'), (115293, 'Abigail'), (120, 'Abiodun'), (72, 'Abir'), (490, 'Adeliya'), (219, 'Adnya'), (28045, 'Adriana'), (107, 'Adrienn'), (4619, 'Adrijana'), (9, 'Adva'), (156, 'Afroditi'), (1901, 'Agata'), (219, 'Agata Jadwiga'), (110, 'Agne'), (390148, 'Agnes'), (13717, 'Agnese'), (2929, 'Agni'), (1801033, 'Agnieszka'), (21728, 'Agustina'), (158, 'Agustina Elena'), (141, 'Ah'), (85, 'Ahlam'), (52, 'Ahsha'), (10751, 'Ai'), (2217, 'Ai Wen'), (703, 'Aida'), (140108, 'Aiko'), (288, 'Ailen'), (226, 'Aimee'), (92, 'Aina'), (2433, 'Ainhoa'), (96, 'Aishwarya'), (116548, 'Ajla'), (11873, 'Akari'), (228538, 'Akgul'), (14838, 'Aki'), (83, 'Akiho'), (84446, 'Akiko'), (742, 'Akilah'), (640, 'Akvile'), (385, 'Alana'), (1424, 'Alba'), (238803, 'Alberta'), (10507, 'Albina'), (71, 'Aldana'), (1578, 'Alejandra'), (451414, 'Aleksandra'), (35957, 'Aleksandrina'), (8832, 'Alena'), (235, 'Alessandra'), (2524, 'Alessia'), (265, 'Alessondra'), (138782, 'Alexa'), (955267, 'Alexandra'), (191, 'Alexandria'), (12829, 'Alexia'), (13389, 'Alexis'), (61196, 'Aliaksandra'), (57745, 'Alice'), (2358, 'Alice Andrada'), (993, 'Alicia'), (5216, 'Alicja'), (11393, 'Alina'), (2369, 'Aliona'), (369810, 'Alisa'), (323527, 'Alison'), (5422, 'Alix'), (596901, 'Alize'), (253320, 'Alla'), (33054, 'Allie'), (206, 'Almudena'), (4052, 'Alona'), (155, 'Alory Regina Elorriaga'), (25183, 'Alyona'), (68207, 'Amanda'), (41575, 'Amandine'), (887, 'Amelie'), (1990, 'Amina'), (12708, 'Aminat'), (157, 'Amira'), (60702, 'Amra'), (159, 'Amrita'), (10616, 'Amy'), (51803, 'An Sophie'), (1589674, 'Ana'), (2421, 'Ana Bianca'), (36696, 'Ana Clara'), (288, 'Ana Gabriela'), (21, 'Ana Luisa'), (2141, 'Ana Paula'), (15955, 'Ana Sofia'), (1367, 'Ana Victoria'), (678793, 'Anabel'), (1962, 'Anaeve'), (46908, 'Anais'), (2338, 'Anamika'), (1433335, 'Anastasia'), (1235, 'Anastasia Evgenyevna'), (12, 'Anastasiia'), (268277, 'Anastasija'), (75850, 'Anastasiya'), (101, 'Anca'), (160, 'Anda'), (605, 'Andie K'), (228, 'Andjela'), (51, 'Andra Maria'), (920433, 'Andrea'), (464, 'Andrea Renee'), (1484, 'Andreea'), (1365, 'Andreea Amalia'), (12727, 'Andreea Roxana'), (74453, 'Andreja'), (72, 'Andressa Cristina'), (159, 'Andrina'), (202, 'Aneta'), (71072, 'Anett'), (1657, 'Anette'), (36, 'Ange Oby'), (245, 'Angela'), (13643, 'Angelica'), (677, 'Angeliki'), (19048, 'Angelina'), (1132514, 'Angelique'), (17967, 'Anhelina'), (836, 'Anhzelika'), (48811, 'Ani'), (2177, 'Anita'), (11596, 'Anja'), (54, 'Anke'), (21599, 'Ankita'), (62, 'Ann'), (1017069, 'Anna'), (6650, 'Anna Arina'), (49207, 'Anna Giulia'), (107880, 'Anna Karolina'), (907, 'Anna Katalina'), (359374, 'Anna Lena'), (1427, 'Anna Maria'), (29442, 'Annalisa'), (647811, 'Anne'), (5269, 'Anne Liz'), (99, 'Anne Marie'), (33, 'Anne Sophie'), (172, 'Annie'), (169371, 'Annika'), (3621, 'Anouk'), (280, 'Antonela'), (21624, 'Antonia'), (484, 'Antonina'), (480, 'Anushka'), (4941, 'Ao'), (126, 'Apichaya'), (11608, 'Arabela'), (434692, 'Arantxa'), (24184, 'Aranza'), (383495, 'Aravane'), (980, 'Ariadna'), (96852, 'Arina'), (3, 'Arina Gabriela'), (154, 'Arlinda'), (39, 'Arthi'), (19446, 'Aryna'), (238, 'Aselya'), (99, 'Asha'), (58741, 'Ashleigh'), (49980, 'Ashley'), (5155, 'Ashling'), (648, 'Ashmitha'), (2321, 'Ashvarya'), (48788, 'Asia'), (802, 'Asiya'), (141, 'Assia'), (1083, 'Astra'), (269, 'Astrid Wanja'), (33624, 'Audrey'), (21, 'Avgusta'), (7, 'Axana'), (7996, 'Ayaka'), (571, 'Ayan'), (5173, 'Ayano'), (7444, 'Ayla'), (791, 'Aymet'), (38501, 'Ayu Fani'), (309990, 'Ayumi'), (11721, 'Azra'), (53401, 'Barbara'), (515957, 'Barbora'), (26624, 'Basak'), (27061, 'Beatrice'), (98798, 'Beatriz'), (75, 'Beatriz Magdalena'), (1920, 'Beatriz Maria'), (26, 'Beauty'), (351, 'Belen'), (137327, 'Belinda'), (11032, 'Benedetta'), (2850, 'Berfu'), (8441, 'Bermet'), (19092, 'Bernarda'), (3894, 'Bernice'), (814, 'Berta'), (371662, 'Bethanie'), (21, 'Betina'), (1152, 'Bhuvana'), (63998, 'Bianca'), (1213, 'Bianka'), (50184, 'Bibiane'), (905, 'Blair'), (312, 'Blanca'), (662, 'Blessing'), (123, 'Boba'), (283166, 'Bojana'), (3470, 'Borislava'), (1465, 'Boyan'), (725, 'Brandy'), (676, 'Breaunna'), (166760, 'Brenda'), (2922, 'Brianna'), (12, 'Brienne'), (30, 'Brindtha'), (2487, 'Britt'), (1119, 'Brittany'), (7062, 'Brooke'), (1344, 'Brynn'), (3187, 'Bunyawi'), (537, 'Busra'), (119797, 'Cagla'), (15218, 'Caitlin'), (9147, 'Camelia Elena'), (38, 'Cameron'), (202172, 'Camila'), (136, 'Camila Vital'), (11714, 'Camilla'), (574, 'Camille'), (240762, 'Cara'), (90451, 'Carina'), (669546, 'Carla'), (27, 'Carlota'), (562, 'Carlotta'), (67459, 'Carly'), (8174, 'Carmen'), (1077, 'Carmen Raluca'), (14213, 'Carol'), (9093, 'Carolin'), (36889, 'Carolina'), (3627, 'Carolina Meligeni Rodrigues'), (2076949, 'Caroline'), (111, 'Caroline B'), (72, 'Carolyn'), (289, 'Carson'), (202697, 'Casey'), (250056, 'Catalina'), (4987, 'Catherine'), (45884, 'Catherine Cartan'), (22, 'Caty'), (11954, 'Cecilia'), (95, 'Cecilie Lundgaard'), (18824, 'Celine'), (958, 'Cemre'), (4914, 'Chalena'), (62861, 'Chanel'), (275364, 'Chanelle'), (26585, 'Chang'), (39, 'Chanikarn'), (15001, 'Chantal'), (187, 'Chantelle'), (15, 'Chaoyi'), (5683, 'Charlene'), (4356, 'Charlotte'), (20132, 'Chayenne'), (5, 'Chelsea'), (6777, 'Chelsey'), (26779, 'Chen'), (277, 'Chengyiyi'), (49122, 'Chi Chi'), (667, 'Chi Fan'), (679, 'Chia Hsien'), (33301, 'Chia Jung'), (42773, 'Chiaki'), (6159, 'Chiara'), (34796, 'Chieh Yu'), (15401, 'Chihiro'), (70504, 'Chin Wei'), (13141, 'Chinami'), (7975, 'Ching Wen'), (1726, 'Chiraz'), (358, 'Chisa'), (15190, 'Chloe'), (276, 'Chompoothip'), (24, 'Christie'), (310215, 'Christina'), (2438, 'Christine'), (12519, 'Chun Mei'), (3374, 'Chun Yan'), (31620, 'Cindy'), (141876, 'Claire'), (116, 'Clara'), (32581, 'Claudia'), (1227, 'Claudia Antonia'), (934, 'Claudia Gianina'), (106762, 'Claudine'), (2221, 'Clelia'), (1622, 'Clemence'), (538, 'Clementina Eugenia'), (12304, 'Clothilde'), (235721, 'Coco'), (129, 'Colomba'), (52274, 'Conny'), (25166, 'Constance'), (907, 'Constanza'), (18, 'Constanze'), (1002, 'Corina'), (102260, 'Corinna'), (4053, 'Cornelia'), (20869, 'Cory Ann'), (1236, 'Costanza'), (7486, 'Cristiana'), (59412, 'Cristina'), (75414, 'Cristina Andreea'), (317, 'Cristina Madalina'), (6256, 'Csilla'), (1034, 'Cynthia'), (1417, 'Da Hye'), (1261, 'Dabin'), (160, 'Dagmara'), (8589, 'Daiana'), (150, 'Dajana'), (8939, 'Dalia'), (48857, 'Dalila'), (15935, 'Dalma'), (0, 'Damilola'), (12, 'Damini'), (30, 'Damira'), (639, 'Dan Ni'), (3121, 'Dana'), (1607, 'Daneika'), (17597, 'Danica'), (1165205, 'Daniela'), (16663, 'Daniella'), (40823, 'Danielle'), (8507, 'Danielle Rose'), (545, 'Danijela'), (87958, 'Danka'), (33, 'Daphne'), (170617, 'Daria'), (41925, 'Darija'), (857, 'Dariya'), (163036, 'Darya'), (1923, 'Dasha'), (5619, 'Dayana'), (7027, 'Dea'), (7605, 'Deborah'), (141, 'Deeon'), (9846, 'Dejana'), (1192, 'Demi'), (65522, 'Denisa'), (3298, 'Denise'), (168, 'Denise Antonela'), (23620, 'Deniz'), (215, 'Deria'), (354, 'Desirae'), (709, 'Desiree'), (19065, 'Despina'), (3942, 'Despoina'), (9227, 'Destanee'), (134, 'Dewi'), (2738, 'Dhruthi'), (9780, 'Di'), (79958, 'Dia'), (119279, 'Diana'), (99, 'Diana Maria'), (6369, 'Dianne'), (7353, 'Dijana'), (85, 'Dilara'), (149, 'Dina'), (67017, 'Dinah'), (117, 'Doga Selen'), (1614, 'Domenica'), (918746, 'Dominika'), (455, 'Dominique'), (164, 'Donika'), (114098, 'Donna'), (109, 'Dorien'), (23976, 'Doroteja'), (392, 'Draginja'), (4703, 'Dunja'), (713, 'Ebony'), (1978, 'Eden'), (249446, 'Edina'), (11216, 'Eduarda'), (2446, 'Eetee'), (50, 'Ege'), (1005319, 'Ekaterina'), (26897, 'Ekaterine'), (103, 'Elaine'), (2287, 'Eleanor'), (1247887, 'Elena'), (7772, 'Elena Gabriela'), (6547, 'Elena Teodora'), (439179, 'Eleni'), (405, 'Eleonora'), (567, 'Eleonore'), (882, 'Eliessa'), (314747, 'Elina'), (4709, 'Elisabeth'), (43779, 'Elise'), (87263, 'Elitsa'), (18211, 'Elixane'), (480, 'Eliza'), (536, 'Elizabeta'), (20368, 'Elizabeth'), (1103, 'Elizabeth Anita Alexandria'), (62977, 'Elizaveta'), (636, 'Elizaveta Anna'), (960, 'Elke'), (526, 'Ella'), (13761, 'Ellen'), (8079, 'Ellie'), (90, 'Elodie'), (12554, 'Elyne'), (11218, 'Ema'), (12728, 'Emelyn'), (3880, 'Emi'), (43, 'Emilia'), (1258, 'Emiliana'), (1440, 'Emilie'), (24, 'Emilija'), (541, 'Emiliya'), (52889, 'Emily'), (964, 'Emily J'), (3029, 'Emina'), (85022, 'Emma'), (65, 'Emma Christine'), (1609, 'Emmanuelle'), (52, 'En Pei'), (823, 'Ena'), (34570, 'Eri'), (472, 'Erica'), (165477, 'Erika'), (5356, 'Erin'), (1225, 'Erina'), (69, 'Esen'), (376, 'Estela'), (39989, 'Estelle'), (3908, 'Ester'), (126811, 'Estrella'), (7147, 'Etsuko'), (976, 'Eudice Wong'), (36, 'Eugenia'), (204801, 'Eugenie'), (20989, 'Eugeniya'), (320083, 'Eva'), (41, 'Eva Marie'), (744, 'Eveliina'), (27011, 'Evelyn'), (59775, 'Evgenia'), (206981, 'Evgeniya'), (7755, 'Fang Ying'), (33388, 'Fangzhou'), (11260, 'Fanny'), (167, 'Farah'), (10865, 'Fatima'), (898, 'Fatimah'), (21261, 'Fatma'), (80, 'Fatyha'), (56817, 'Federica'), (44, 'Federica Joe'), (17587, 'Fernanda'), (78, 'Ferny'), (18219, 'Fiona'), (1011058, 'Flavia'), (89361, 'Florencia'), (359, 'Frances'), (1306087, 'Francesca'), (157, 'Francisca'), (21685, 'Francoise'), (994, 'Franziska'), (9, 'Frederikke'), (6525, 'Freya'), (102623, 'Gabriela'), (468, 'Gabriela Nicole'), (6179, 'Gabriella'), (1093, 'Gabrielle Faith'), (1000, 'Gaelle'), (7998, 'Gaia'), (38651, 'Gail'), (302957, 'Galina'), (30136, 'Ganna'), (412872, 'Garbine'), (143, 'Gebriela'), (440, 'Genevieve'), (9600, 'Georgia'), (1848, 'Georgia Andreea'), (48, 'Georgiana'), (11569, 'Georgina'), (290, 'Ghislaine'), (677, 'Giada'), (31741, 'Gioia'), (2484, 'Giorgia'), (13, 'Giorgie'), (289, 'Giovanna'), (106520, 'Giulia'), (2935, 'Giuliana'), (1297, 'Gloria'), (2864, 'Gozal'), (70613, 'Grace'), (7999, 'Gracia'), (6168, 'Greetje'), (240195, 'Greta'), (14277, 'Guadalupe'), (576, 'Guillermina'), (687, 'Guiomar'), (410, 'Gulben'), (18, 'Gulchekhra'), (39, 'Gulnaz'), (775, 'Guzal'), (238, 'Gyulnara'), (811, 'Habiba'), (8180, 'Hae Sung'), (294, 'Haine'), (413, 'Hana'), (2782, 'Hanna'), (4643, 'Hanyu'), (9631, 'Hao Chen'), (224, 'Hao Ching'), (5944, 'Harmony'), (8608, 'Harriet'), (3633, 'Haruka'), (1873, 'Haruna'), (1679, 'Hayley'), (78, 'Hazal'), (202780, 'Heather'), (88542, 'Heidi'), (1039, 'Helen'), (3928, 'Helene'), (122, 'Hikari'), (10191, 'Hilda'), (3, 'Himari'), (27580, 'Hiroko'), (4368, 'Hirono'), (2371, 'Ho Ching'), (24, 'Hollie'), (1063, 'Hongrui'), (98, 'Hortencia'), (120, 'Hsin Yuan'), (7367, 'Hua Chen'), (118, 'Huijie'), (7797, 'Hulya'), (1222, 'Hye Min'), (870, 'Hyojung'), (8301, 'Hyun Hui'), (511, 'I Hsuan'), (395, 'Iana'), (467, 'Ida'), (45, 'Idia'), (916, 'Iga'), (52, 'Ilay'), (1142, 'Ilka'), (26950, 'Ilona'), (1527, 'Ilze'), (1676, 'Imane Maelle'), (292, 'Ina'), (406, 'Inci'), (762, 'India'), (12633, 'Indire'), (17382, 'Indy'), (1358, 'Ineke'), (40410, 'Ines'), (221, 'Inger'), (3471, 'Ingrid'), (4766, 'Ingrid Alexandra'), (10133, 'Ingrid Esperanza'), (33, 'Intissar'), (1225, 'Ioana'), (2403, 'Ioana Diana'), (5425, 'Ioana Loredana'), (6948, 'Ionela Andreea'), (39352, 'Ipek'), (88369, 'Irena'), (3133, 'Irene'), (299698, 'Irina'), (293366, 'Irina Camelia'), (13843, 'Irina Maria'), (4743, 'Iris'), (87844, 'Iryna'), (6688, 'Isabel'), (714, 'Isabela'), (83476, 'Isabella'), (4777, 'Isabelle'), (74, 'Iulia Maria'), (10322, 'Iva'), (100848, 'Ivana'), (2094, 'Ivania'), (291, 'Ivanka'), (443695, 'Iveta'), (543, 'Ivette'), (253, 'Ivone'), (13010, 'Ivonne'), (27462, 'Jacqueline'), (64, 'Jada'), (26209, 'Jade'), (1375, 'Jaeda'), (5007, 'Jaimee'), (24, 'Jaimy Gayle'), (761, 'Jainy'), (190997, 'Jamie'), (18, 'Jamilya'), (10947, 'Jan'), (268372, 'Jana'), (143422, 'Janette'), (12525, 'Janina'), (72, 'Janja'), (861, 'Janneke'), (5416, 'Jaqueline Adina'), (464, 'Jara'), (333150, 'Jarmila'), (34453, 'Jasmin'), (43862, 'Jasmina'), (14865, 'Jasmine'), (142, 'Jasmine Amber'), (822, 'Jawairiah'), (908, 'Jazmin'), (628, 'Jazzamay'), (3426, 'Jeannine'), (2515436, 'Jelena'), (81222, 'Jennifer'), (1002, 'Jenny'), (17819, 'Jesika'), (154599, 'Jessica'), (4122, 'Jessika'), (923, 'Jessy'), (7179, 'Ji Hee'), (8592, 'Ji Young'), (52, 'Jia'), (48117, 'Jia Jing'), (4612, 'Jia Qi'), (1553, 'Jiahui'), (15, 'Jiakang'), (100, 'Jiatian'), (3002, 'Jiaxi'), (96, 'Jiaxue'), (610820, 'Jie'), (13978, 'Jil Belen'), (611, 'Jil Nora'), (359013, 'Jill'), (1991, 'Jillian'), (15, 'Jin'), (46355, 'Jin A'), (414, 'Jin Ju'), (68925, 'Jing Jing'), (1955, 'Joana'), (472, 'Joanna'), (15, 'Joanne'), (355, 'Jodie Anna'), (40, 'Johana'), (553107, 'Johanna'), (1092, 'Jordana'), (2710, 'Josepha'), (4980, 'Josephine'), (804, 'Josie'), (39270, 'Jovana'), (3453, 'Ju Eun'), (3, 'Judith'), (63, 'Jule'), (891796, 'Julia'), (21, 'Julia Mansano'), (414, 'Juliana'), (129, 'Juliana Rocha'), (156531, 'Julie'), (4093, 'Julieta Lara'), (286, 'Julita'), (1446, 'Julyette Maria Josephine'), (114, 'June'), (128183, 'Junri'), (36, 'Justina'), (39418, 'Justine'), (30304, 'Justyna'), (467, 'Kady'), (172004, 'Kai Chen'), (37817, 'Kai Lin'), (625836, 'Kaia'), (416, 'Kaitlin'), (3905, 'Kaitlyn'), (1176, 'Kaja'), (2280, 'Kajsa'), (12906, 'Kamila'), (249, 'Kamilla'), (5866, 'Kamonwan'), (1536, 'Kana'), (20142, 'Kanae'), (229, 'Kanako'), (3724, 'Kanami'), (919, 'Kanika'), (8406, 'Kaori'), (32169, 'Karen'), (85, 'Kariann'), (254520, 'Karin'), (9355, 'Karina'), (5493, 'Karina Ildor'), (410, 'Karina Kristina'), (1936, 'Karine'), (1003, 'Karis'), (3127, 'Karla'), (3193, 'Karman'), (776, 'Karola Patricia'), (465, 'Karolayne'), (512490, 'Karolina'), (910, 'Karoline'), (330, 'Karyn'), (704, 'Kassandra'), (112562, 'Katalin'), (444303, 'Katarina'), (93730, 'Katarzyna'), (34, 'Kate'), (160945, 'Katerina'), (435038, 'Kateryna'), (24595, 'Katharina'), (363, 'Katharine'), (7843, 'Katherine'), (1894, 'Katherine Gabriela'), (15970, 'Kathinka'), (141281, 'Kathrin'), (30035, 'Katie'), (308, 'Katrine Isabel'), (11572, 'Katy'), (515, 'Katya'), (97, 'Katyarina'), (13697, 'Kayla'), (237, 'Kaylah'), (10107, 'Kazusa'), (294, 'Kei'), (324, 'Kelia'), (4705, 'Kelly'), (5880, 'Kelly S'), (410, 'Kelsey'), (653, 'Kennedy'), (24062, 'Keren'), (894, 'Keri'), (942, 'Kerstin'), (3748, 'Khristina'), (86, 'Ki Ryang'), (214121, 'Kiki'), (4580, 'Kim'), (12388, 'Kim Alice'), (5393, 'Kimberley'), (4831, 'Kimberly'), (272, 'Kimika'), (270102, 'Kimiko'), (15102, 'Kinnie'), (383077, 'Kirsten'), (462, 'Kirsten Andrea'), (5818, 'Klaartje'), (568191, 'Klara'), (4809, 'Klaudia'), (701, 'Komola'), (21417, 'Korina'), (4962, 'Kotomi'), (17577, 'Krista'), (34647, 'Kristie'), (601693, 'Kristina'), (555, 'Kristina N'), (1899, 'Kristy'), (148728, 'Kristyna'), (371140, 'Ksenia'), (298, 'Kseniia'), (625, 'Ksenija'), (56212, 'Kumiko'), (177170, 'Kurumi'), (210101, 'Kveta'), (403, 'Kwan Yau'), (3200, 'Kyle'), (1236, 'Kylie'), (9036, 'Kyoka'), (102022, 'Kyra'), (26059, 'Kyung Mi'), (6078, 'Laetitia'), (595, 'Laili'), (456, 'Lamis'), (177458, 'Lara'), (255, 'Larikah'), (578964, 'Laura'), (281, 'Laura D'), (33822, 'Laura Ioana'), (97, 'Laura Sofia'), (244807, 'Lauren'), (207, 'Lauryn'), (23897, 'Lavinia'), (39, 'Laylo'), (22, 'Layne'), (4197, 'Lea'), (152, 'Leah'), (733, 'Lee'), (27997, 'Lena'), (14942, 'Lena Marie'), (164900, 'Lenka'), (750, 'Leolia'), (672, 'Leonie'), (286, 'Lesedi Sheya'), (225987, 'Lesia'), (42925, 'Lesley'), (173, 'Leslie'), (45115, 'Leticia'), (87, 'Leticia Garcia'), (48, 'Leylah Annie'), (1696, 'Li'), (59997, 'Liana Gabriela'), (2362, 'Libby'), (522, 'Libi'), (169, 'Lidia'), (6809, 'Lidziya'), (39782, 'Liezel'), (23411, 'Liga'), (1960, 'Lilla'), (40341, 'Lin'), (91117, 'Lina'), (4216, 'Linda'), (142454, 'Lindsay'), (500, 'Lindsey'), (64525, 'Ling'), (72, 'Liniques'), (697, 'Linnea'), (594217, 'Lisa'), (7898, 'Lisa Maria'), (1583, 'Lisa Marie'), (8284, 'Lisanne'), (2662, 'Liubov'), (128, 'Livia'), (2216, 'Liz Tatiane'), (135, 'Lizaveta'), (11623, 'Lizette'), (33, 'Lorenza'), (40, 'Lorraine M'), (10167, 'Lou'), (6, 'Loudmilla'), (50700, 'Louisa'), (1633, 'Louise'), (371035, 'Lourdes'), (3445, 'Lu'), (1013, 'Luca'), (17185, 'Lucia'), (8305, 'Luciana'), (1108372, 'Lucie'), (1589, 'Lucrezia'), (6542, 'Lucy'), (645, 'Ludmila'), (1187, 'Ludmilla'), (1671, 'Luisa'), (1822, 'Luisa Marie'), (77519, 'Luksika'), (304, 'Lulu'), (15, 'Luna'), (377, 'Lusine'), (876, 'Lutfiye'), (30, 'Lyann'), (837, 'Lynn'), (54172, 'Lyudmyla'), (12379, 'Macall'), (2133, 'Macarena'), (62938, 'Madalina'), (2434, 'Maddison'), (715, 'Madeleine'), (147, 'Madeline'), (6, 'Madina'), (476768, 'Madison'), (2266, 'Madrie'), (525, 'Maegan'), (163, 'Mafalda'), (54, 'Maftuna'), (1917, 'Magali'), (511, 'Magalie'), (103659, 'Magda'), (401857, 'Magdalena'), (756, 'Magy'), (154, 'Mahak'), (395, 'Mahitha'), (19173, 'Mai'), (1235, 'Maia'), (12, 'Maia A'), (11320, 'Maiko'), (83, 'Maileen'), (39523, 'Mailen'), (1067, 'Maja'), (5592, 'Makiho'), (14129, 'Makoto'), (316, 'Malene'), (323, 'Malika'), (2489, 'Malin'), (688, 'Mallaurie'), (44497, 'Mallory'), (3073, 'Malou'), (96, 'Mami'), (102, 'Man Ying Maggie'), (9593, 'Mana'), (15, 'Mananchaya'), (2070, 'Manca'), (193767, 'Mandy'), (3112, 'Manisha'), (14608, 'Manon'), (93, 'Manya'), (702, 'Mara'), (16790, 'Marcela'), (683, 'Marcela Guimaraes'), (33, 'Marcelina'), (13037, 'Marcella'), (99836, 'Margalita'), (1997, 'Margarida'), (78265, 'Margarita'), (905, 'Margaux'), (4787, 'Margot'), (38086, 'Mari'), (3613355, 'Maria'), (185, 'Maria Agustina'), (323, 'Maria Andrea'), (148, 'Maria Camila'), (1892, 'Maria Constanza De Las Mercedes'), (296, 'Maria Del Rosario'), (296736, 'Maria Elena'), (141257, 'Maria Fernanda'), (294, 'Maria Jesus'), (72682, 'Maria Joao'), (413759, 'Maria Jose'), (156, 'Maria Lourdes'), (1388, 'Maria Paulina'), (106375, 'Maria Teresa'), (4060, 'Mariam'), (201258, 'Mariana'), (10178, 'Marianna'), (1090, 'Marianne'), (226, 'Mariaryeni'), (25496, 'Marie'), (114687, 'Marie Eve'), (206, 'Mariia'), (20481, 'Marija'), (3, 'Marijana'), (362372, 'Marina'), (4314, 'Marine'), (1272285, 'Marion'), (4, 'Mariona'), (1026, 'Marisa'), (154484, 'Mariya'), (18286, 'Marketa'), (1624, 'Marlies'), (1339, 'Marrit'), (267679, 'Marta'), (778, 'Marta Huqi'), (153, 'Martha'), (109192, 'Martina'), (653, 'Mary'), (102, 'Mary Ann'), (85425, 'Maryna'), (117472, 'Masa'), (245139, 'Mathilde'), (3466, 'Matilda'), (210, 'Maud'), (219, 'Maureen'), (138, 'Maurien'), (390, 'Maxine'), (225, 'May'), (23668, 'Maya'), (1788, 'Mayar'), (32445, 'Mayo'), (9064, 'Mayya'), (13254, 'Megan'), (407, 'Megumi'), (40, 'Mei Xu'), (417, 'Meiling'), (96, 'Meiqi'), (385636, 'Melanie'), (97, 'Melany Solange'), (2609, 'Melina'), (290299, 'Melinda'), (20196, 'Melis'), (340, 'Melisa'), (200, 'Melissa'), (171, 'Melissa Ishuan'), (542, 'Meng Ning'), (48, 'Mercedes'), (101, 'Merel'), (284, 'Meritxell'), (102693, 'Mervana'), (24569, 'Mi'), (176, 'Mi Jeong'), (1858, 'Mi Rae'), (72, 'Mi Zhuoma'), (1098, 'Mia Nicole'), (230, 'Micaela'), (76586, 'Michaela'), (242619, 'Michaella'), (90, 'Michela'), (596, 'Michele Alexandra'), (160164, 'Michelle'), (3657, 'Michika'), (69242, 'Mihaela'), (15, 'Mihaela Lorena'), (21205, 'Miharu'), (427, 'Mihika'), (201, 'Mihoki'), (24542, 'Miki'), (107, 'Mila'), (42, 'Milagros'), (14123, 'Milana'), (279, 'Milena'), (63, 'Milica'), (1884, 'Min'), (9938, 'Min Hwa'), (96, 'Minami'), (1626, 'Mira'), (1977, 'Mirabelle'), (180, 'Miranda'), (3825, 'Miriam'), (1458, 'Miriam Bianca'), (1180, 'Miriana'), (272, 'Mirjam'), (331434, 'Mirjana'), (55981, 'Misa'), (203782, 'Misaki'), (309, 'Mitsumi'), (22840, 'Miyabi'), (23968, 'Miyu'), (2927, 'Mizuno'), (565, 'Molly'), (2061, 'Momoko'), (282445, 'Mona'), (587309, 'Monica'), (1240, 'Monika'), (114104, 'Monique'), (23564, 'Montserrat'), (6906, 'Morgane'), (15, 'Moulika'), (12, 'Mouna'), (32, 'Moyuka'), (6, 'Muazzez'), (162, 'Muge'), (43550, 'Myrtille'), (1358928, 'Na'), (26185, 'Na Lae'), (19223, 'Na Ri'), (5027, 'Nadezda'), (1401125, 'Nadia'), (56596, 'Nadiya'), (2661, 'Nadja'), (1535, 'Nagi'), (4380, 'Naiktha'), (440, 'Naima'), (259, 'Nam Yeon'), (3094, 'Nan Nan'), (16494, 'Nanuli'), (59671, 'Nao'), (857, 'Naoko'), (163239, 'Naomi'), (1945, 'Napatsakorn'), (72, 'Nastassia'), (65152, 'Nastassja'), (29250, 'Nastja'), (97400, 'Natalia'), (120995, 'Natalie'), (13686, 'Natalija'), (33, 'Nataliya'), (14212, 'Natasa'), (15365, 'Natasha'), (16303, 'Natela'), (649, 'Natella'), (28098, 'Nathalia'), (13241, 'Nathaly'), (2526, 'Natia'), (37981, 'Natsumi'), (224, 'Nattawadee'), (251, 'Naz'), (980, 'Nazari'), (9536, 'Neda'), (142, 'Nelise'), (279, 'Nermeen'), (170, 'Nevena'), (30972, 'Nicha'), (2531, 'Nicky'), (33550, 'Nicola'), (447434, 'Nicole'), (8146, 'Nicoleta Catalina'), (9627, 'Nicolette'), (5425, 'Nidhi'), (47651, 'Nigina'), (9120, 'Nika'), (22, 'Nikita'), (614, 'Nikki'), (491, 'Nikol'), (78513, 'Nikola'), (201173, 'Nina'), (115, 'Nina Isabella'), (2706, 'Nives'), (1558, 'Noel'), (2025, 'Noelia'), (1795, 'Noelle'), (134, 'Nonna'), (73589, 'Noppawan'), (1082, 'Nora'), (760, 'Nour'), (1333, 'Nozomi'), (63013, 'Nudnida'), (24523, 'Nungnadda'), (259116, 'Nuria'), (1096, 'Oana'), (4294, 'Oana Georgeta'), (56853, 'Oceane'), (5372, 'Ofri'), (58279, 'Oksana'), (3497, 'Ola'), (2, 'Olawaseun'), (40, 'Olaya'), (8700, 'Oleksandra'), (484, 'Olena'), (3811, 'Olesya'), (773929, 'Olga'), (119756, 'Olivia'), (363, 'Oliwia'), (56242, 'Ons'), (2133, 'Ornella'), (382, 'Oyku'), (147, 'Paige Mary'), (241, 'Pamela'), (1446, 'Panna'), (403127, 'Paola'), (209, 'Parris'), (1188, 'Patcharin'), (197904, 'Patricia'), (43755, 'Patricia Maria'), (17514, 'Patrycja'), (7323, 'Patty'), (172431, 'Paula'), (269, 'Paula Andrea'), (3714, 'Paula Catalina'), (37384, 'Paula Cristina'), (3208, 'Paulina'), (313187, 'Pauline'), (4128, 'Pavla'), (26280, 'Peangtarn'), (1016, 'Peggy'), (8900, 'Pei Chi'), (24, 'Pei Hsuan'), (181, 'Pei Ju'), (60908, 'Pemra'), (6573, 'Pernilla'), (1832, 'Petia'), (1958404, 'Petra'), (3, 'Phenomena'), (664, 'Phillis'), (10859, 'Pia'), (21340, 'Piia'), (6404, 'Pilar'), (243, 'Pippa'), (934, 'Plobrung'), (76747, 'Polina'), (325216, 'Polona'), (13006, 'Poojashree'), (1214, 'Pranjala'), (5687, 'Prarthana G'), (9318, 'Prerna'), (510, 'Priscila'), (8203, 'Priscilla'), (116857, 'Qiang'), (683, 'Qianhui'), (641, 'Qianqian'), (2034, 'Qiu Yu'), (646, 'Quinn'), (22978, 'Quirine'), (2592, 'Rachael'), (469, 'Rachel'), (699, 'Radina'), (228, 'Rafaela'), (40, 'Ralina'), (148701, 'Raluca'), (9202, 'Raluca Elena'), (4258, 'Raluca Georgiana'), (443, 'Ramu'), (161, 'Ramya'), (14709, 'Ran'), (9, 'Rana'), (30401, 'Raquel'), (741, 'Rashmi'), (957, 'Ratnika'), (5387, 'Raveena'), (168, 'Rebeca'), (165013, 'Rebecca'), (5803, 'Rebeka'), (122331, 'Regina'), (64, 'Reina'), (66271, 'Reka Luca'), (38116, 'Remi'), (201856, 'Renata'), (5566, 'Ria'), (984, 'Rianna'), (84184, 'Richel'), (141257, 'Rika'), (23195, 'Riko'), (556, 'Rio'), (62252, 'Risa'), (8448, 'Rishika'), (1401, 'Rita'), (2634, 'Riya'), (809611, 'Roberta'), (12295, 'Robin'), (1103, 'Robyn'), (16886, 'Rocio'), (29214, 'Romana'), (17020, 'Romana Caroline'), (253471, 'Romina'), (911, 'Romy'), (308, 'Rona'), (3165, 'Ronit'), (49, 'Ronke'), (28, 'Roosh'), (111, 'Rosa'), (803, 'Rosalia'), (880, 'Rosalie'), (336, 'Rosie'), (38793, 'Roxane'), (24, 'Rui'), (27452, 'Rushmi'), (3642, 'Rutuja'), (597, 'Ryann'), (195, 'Saana'), (780, 'Sabastiani'), (49784, 'Sabina'), (27, 'Sabina Elena'), (590911, 'Sabine'), (6810, 'Sabrina'), (78204, 'Sacha'), (49767, 'Sachia'), (42676, 'Sachie'), (2275, 'Sadafmoh'), (1034, 'Sai Samhitha'), (113359, 'Saisai'), (9338, 'Sakiko'), (53480, 'Sally'), (66, 'Salma'), (1437656, 'Samantha'), (2020, 'Samira'), (354, 'Sanae'), (17975, 'Sanaz'), (266197, 'Sandra'), (224, 'Sandy'), (1277, 'Sang Hee'), (272889, 'Sania'), (914981, 'Sara'), (78461, 'Sarah'), (1270, 'Sarah Beth'), (13064, 'Sarah Rebecca'), (461, 'Sarahi'), (148, 'Sarai Delfina'), (2061, 'Saray'), (464, 'Sari'), (27, 'Sarlota'), (178, 'Sarvinoz'), (316, 'Sasa'), (2641, 'Saska'), (906, 'Satsuki'), (70, 'Savannah'), (148, 'Schena'), (143, 'Se Hyun'), (681, 'Se Jin'), (75, 'Sean'), (1469, 'Seda'), (144, 'Seira'), (169, 'Selin'), (6564, 'Seo Kyung'), (1312, 'Seone'), (4232828, 'Serena'), (208108, 'Sesil'), (6650, 'Seung Yeon'), (192296, 'Severine'), (662926, 'Shahar'), (2122, 'Shakhlo'), (198, 'Shakhnoza'), (111, 'Shangqing'), (2378, 'Shanshan'), (1363, 'Shao Yuan'), (4106, 'Sharmada'), (117825, 'Sharon'), (522, 'Sharon Sanchana'), (102140, 'Shelby'), (142, 'Shelly'), (53610, 'Sheng Nan'), (22977, 'Sherazad'), (801, 'Sherry'), (39960, 'Shiho'), (9634, 'Shilin'), (18, 'Shiori'), (117, 'Shir'), (236, 'Shiran'), (4611, 'Shivika'), (105, 'Shou Na'), (6, 'Shreya'), (1483, 'Shu Ying'), (913829, 'Shuai'), (46124, 'Shuko'), (597, 'Shuo'), (336, 'Shuyue'), (3255, 'Shweta'), (531, 'Si Qi'), (221695, 'Silvia'), (724638, 'Simona'), (1149, 'Simone'), (467, 'Simran Kaur'), (10360, 'Sina'), (688, 'Sinead'), (95, 'Sing Le'), (716, 'Siqi'), (276, 'Sirui'), (87, 'Siyu'), (352458, 'Sloane'), (96, 'Smriti'), (134, 'Sneha'), (2820, 'Snehadevi S'), (47282, 'So Jung'), (18210, 'So Ra'), (484140, 'Sofia'), (336, 'Sofico'), (10539, 'Sofie'), (18371, 'Sofiya'), (9180, 'Sofya'), (108, 'Sohyun'), (480, 'Sonia'), (4499, 'Sonja'), (96, 'Sophia'), (39307, 'Sophie'), (457043, 'Sorana'), (2961, 'Sowjanya'), (159, 'Spurti'), (1744, 'Sri Vaishnavi'), (8072, 'Stamatia'), (49412, 'Stanislava'), (497, 'Stefana'), (126, 'Stefani'), (24897, 'Stefania'), (247237, 'Stefanie'), (3085, 'Steffi'), (608309, 'Stephanie'), (1397, 'Stephanie Mariel'), (21152, 'Storm'), (33672, 'Su Jeong'), (274936, 'Su Wei'), (320, 'Suellen'), (1544, 'Sultan'), (6591, 'Sun Jung'), (15, 'Sunae'), (3594, 'Sunam'), (29852, 'Sung Hee'), (502, 'Susan'), (16276, 'Susanne'), (344, 'Suzan'), (324, 'Suzuho'), (1054, 'Suzy'), (6341, 'Svenja'), (1906587, 'Svetlana'), (11201, 'Sviatlana'), (581, 'Sybille'), (1626, 'Sylvia'), (8268, 'Sylwia'), (9001, 'Syna'), (2127, 'Szabina'), (83659, 'Tadeja'), (1050, 'Taisiya'), (45, 'Talya'), (843, 'Tamachan'), (60, 'Tamar'), (54140, 'Tamara'), (304, 'Tamari'), (594281, 'Tamarine'), (40060, 'Tamaryn'), (322202, 'Tamira'), (26077, 'Tammi'), (764, 'Tanaporn'), (1229, 'Tanya'), (54798, 'Tara'), (42, 'Tatia'), (34795, 'Tatiana'), (230262, 'Tatjana'), (1289, 'Tatsiana'), (5051, 'Tayisiya'), (38850, 'Taylor'), (2127, 'Tea'), (112570, 'Teliana'), (12402, 'Tena'), (41792, 'Teodora'), (193362, 'Tereza'), (18, 'Terri'), (7165, 'Tess'), (9116, 'Tessah'), (75337, 'Tetiana'), (43020, 'Tetyana'), (706, 'Thai Sa Grana'), (2249, 'Theo'), (377, 'Theresa'), (333, 'Tijana'), (612072, 'Timea'), (57585, 'Tina'), (476, 'Tinatin'), (8145, 'Ting Fei'), (8676, 'Ting Jr'), (151, 'Tingting'), (3361, 'Tjasa'), (7431, 'Tomoko'), (10630, 'Tori'), (1864, 'Tornado Alicia'), (1884, 'Trang'), (736, 'Treta'), (456422, 'Tsvetana'), (4543, 'Tyra'), (27118, 'Ulrikke'), (2400, 'Ulyana'), (275255, 'Urszula'), (413, 'Ushna'), (7874, 'Usue Maitane'), (338, 'Valentina'), (9926, 'Valentine'), (15198, 'Valentini'), (47854, 'Valentyna'), (159155, 'Valeria'), (6146, 'Valerie'), (16621, 'Valeriya'), (10087, 'Vanda'), (30669, 'Vanesa'), (71645, 'Vanessa'), (299530, 'Vania'), (255, 'Vaniya'), (291, 'Vanja'), (54340, 'Varatchaya'), (3623, 'Varunya'), (401409, 'Varvara'), (42527, 'Vasilisa'), (3763, 'Vaszilisza'), (2221, 'Vendula'), (2875425, 'Venus'), (1929137, 'Vera'), (3018, 'Verena'), (84543, 'Veronica'), (1678, 'Veronica M'), (73192, 'Veronika'), (169500, 'Vesna'), (77, 'Vicky'), (454, 'Victoire'), (2142854, 'Victoria'), (106, 'Victoria Ariadna'), (30191, 'Viktoria'), (90, 'Viktoriia'), (79511, 'Viktorija'), (26226, 'Viktoriya'), (1987, 'Viktoryia'), (27, 'Vilma Y'), (105, 'Vincenza'), (37, 'Vinciane'), (298, 'Violetta'), (519208, 'Virginie'), (71, 'Vishesh'), (64, 'Vita'), (106927, 'Vitalia'), (36714, 'Vivian'), (13041, 'Vivien'), (8918, 'Vivienne'), (22578, 'Vlada'), (997, 'Vladica'), (6470, 'Vladimira'), (1254, 'Vladislava'), (2570, 'Vladyslava'), (18781, 'Vojislava'), (1036, 'Voni'), (11653, 'Wan Ting'), (42, 'Wan Yi'), (9, 'Warona'), (40633, 'Wen Hsin'), (120, 'Wen Ling'), (613, 'Wendy Qi Wen'), (179, 'Weronika Jasmina'), (5604, 'Whitney'), (363, 'Wiktoria'), (11694, 'Wing Yau Venise'), (879, 'Wushuang'), (14578, 'Xenia'), (1445, 'Xi Yao'), (4789, 'Xiao'), (5057, 'Xiaodi'), (717, 'Xiaorong'), (1352, 'Xiaoxi'), (19495, 'Ximena'), (8744, 'Xin'), (187, 'Xin Yu'), (10705, 'Xinyu'), (109256, 'Xinyun'), (315, 'Xiyu'), (4535, 'Xu Liu'), (24, 'Ya'), (17078, 'Ya Hsuan'), (39687, 'Yafan'), (4196, 'Yan'), (39102, 'Yana'), (73, 'Yang'), (602453, 'Yanina'), (275, 'Yanni'), (32, 'Yarden'), (404915, 'Yaroslava'), (11251, 'Yasmin'), (27, 'Yasmina'), (1748, 'Yasmine'), (71, 'Yasmyn'), (648, 'Yawna'), (128509, 'Yayuk'), (47867, 'Ye Ra'), (281, 'Ye Xin'), (376, 'Yekaterina'), (1856, 'Yelena'), (966, 'Yeong Won'), (6288, 'Yevgeniya'), (19989, 'Yi'), (60646, 'Yi Fan'), (22443, 'Yi Jing'), (61839, 'Yi Miao'), (136, 'Yidi'), (24, 'Yihong'), (366, 'Yijia'), (3783, 'Ying'), (107595, 'Ying Ying'), (1380, 'Yixuan'), (1546, 'Ylena'), (1453, 'Ylona Georgiana'), (285, 'Yoko'), (1381, 'Yolande'), (182, 'Yoo Ri'), (3592, 'Yoon Young'), (677, 'Yoshimi'), (75, 'Yosr'), (242, 'You Na'), (27804, 'Ysaline'), (452, 'Yu Jin'), (9, 'Yu Tong'), (281, 'Yuan'), (772, 'Yuanyi'), (1259, 'Yue'), (21360, 'Yue Yue'), (682, 'Yuenu'), (184, 'Yujia'), (12474, 'Yuka'), (84, 'Yukako'), (505, 'Yuki'), (2191, 'Yuki Kristina'), (998, 'Yukina'), (1828, 'Yukun'), (155143, 'Yulia'), (15248, 'Yuliana'), (206375, 'Yuliya'), (20269, 'Yumi'), (229391, 'Yung Jan'), (559, 'Yuqi'), (101816, 'Yurika'), (1728, 'Yuriko'), (12693, 'Yurina'), (15071, 'Yuuki'), (45, 'Yuval'), (24279, 'Yuxuan'), (254491, 'Yvonne'), (87, 'Zaineb'), (2052, 'Zalina'), (3809, 'Zarah'), (123243, 'Zarina'), (702, 'Zeel'), (21, 'Zeynep  Sena'), (2166, 'Zhanlan'), (20236, 'Zhaoxuan'), (7, 'Zhibek'), (99, 'Zhima'), (30, 'Zhou'), (121, 'Zhuoma'), (110290, 'Zi'), (74, 'Zinovia'), (1420, 'Ziyue'), (2772, 'Zoe'), (2877, 'Zoe Gwen'), (1501, 'Zsofia'), (266251, 'Zuzana'), (2258, 'Zuzanna')]",,1.0,
Find the number of visitors who did not visit any museum opened after 2010.,"[museum.Museum_ID, museum.Open_Year, visit.Museum_ID = museum.Museum_ID, visit.visitor_ID, visitor.ID]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",NESTED,SELECT COUNT(DISTINCT visitor.ID) AS num_visitors FROM visitor WHERE visitor.ID NOT IN ( SELECT visit.visitor_ID FROM visit JOIN museum ON visit.Museum_ID = museum.Museum_ID WHERE museum.Open_Year > 2010 );,SELECT count(*) FROM visitor WHERE id NOT IN (SELECT t2.visitor_id FROM museum AS t1 JOIN visit AS t2 ON t1.Museum_ID  =  t2.Museum_ID WHERE t1.open_year  >  2010),museum_visit,"1. Sequential Structure: Start with the SELECT clause to count the number of visitors. Use the FROM clause to specify the visitor table. Apply a WHERE clause to filter visitors who did not visit any museum opened after 2010. 2. Condition Structure: Use a subquery in the WHERE clause to identify museums opened after 2010 and ensure that the visitor IDs are not present in the visit records for those museums. 3. Join Structure: Use the relationship between the visit and museum tables to filter visits based on museum opening year. No explicit join is needed for the main query, as the subquery handles the filtering. 4. Aggregation Structure: Use COUNT to calculate the total number of visitors who meet the specified condition.","[(3,)]","[(3,)]",,1.0,
What is the average age of the visitors whose membership level is not higher than 4?,"[visitor.Age, visitor.Level_of_membership]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",EASY,SELECT AVG(visitor.Age) AS average_age FROM visitor WHERE visitor.Level_of_membership <= 4;,SELECT avg(age) FROM visitor WHERE Level_of_membership  <=  4,museum_visit,"1. Sequential Structure: Begin with the SELECT clause to calculate the average age of visitors. 2. Condition Structure: Use a WHERE clause to filter visitors whose ""Level_of_membership"" is not higher than 4 (i.e., less than or equal to 4). 3. Join Structure: No JOIN is required since all necessary data is within the ""visitor"" table. 4. Aggregation Structure: Use the AVG function to calculate the average age of the filtered visitors.","[(36.0,)]","[(36.0,)]",,1.0,
What is the name of the winner with the most rank points who participated in the Australian Open tournament?,"[players.player_id, players.first_name, players.last_name, matches.winner_id, matches.winner_rank_points, matches.tourney_name, matches.winner_id = players.player_id, Australian Open]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT players.first_name, players.last_name FROM matches JOIN players ON matches.winner_id = players.player_id WHERE matches.tourney_name = 'Australian Open' AND matches.winner_rank_points = ( SELECT MAX(matches.winner_rank_points) FROM matches WHERE matches.tourney_name = 'Australian Open' );",SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1,wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the winner's first and last name. Use an aggregate function (MAX) to find the maximum rank points among winners who participated in the ""Australian Open"" tournament. 2. Condition Structure: Use a WHERE clause to filter matches where the ""tourney_name"" is ""Australian Open."" 3. Join Structure: Use a JOIN between the ""matches"" and ""players"" tables on ""matches.winner_id = players.player_id"" to link the winner's details with their match records. 4. Aggregation Structure: Use MAX to find the highest ""winner_rank_points"" and filter the corresponding winner using a subquery or a filtering condition.","[('Serena', 'Williams')]","[('Serena Williams',)]",,1.0,
List the name and tonnage ordered by in descending alphaetical order for the names.,"[ship.name, ship.tonnage]","Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",EASY,"SELECT ship.name, ship.tonnage FROM ship ORDER BY ship.name DESC;","SELECT name ,  tonnage FROM ship ORDER BY name DESC",battle_death,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""ship.name"" and ""ship.tonnage"". 2. Condition Structure: No specific filtering condition is required as the query asks for all ships. 3. Join Structure: No JOIN is required since all necessary data is within the ""ship"" table. 4. Aggregation Structure: No aggregation is needed as the query does not involve any summarization or grouping. 5. Ordering Structure: Use ORDER BY on ""ship.name"" in descending alphabetical order.","[('Three Brothers', 't'), ('Mary', 't'), ('Lettice', 't'), ('HMS Avon', '391'), ('HMS Atalanta', '225'), ('Bon Accord', 't'), ('Bacchus', 't')]","[('Three Brothers', 't'), ('Mary', 't'), ('Lettice', 't'), ('HMS Avon', '391'), ('HMS Atalanta', '225'), ('Bon Accord', 't'), ('Bacchus', 't')]",,1.0,
Find the average rank of winners in all matches.,"[matches.winner_id,players.player_id = matches.winner_id,players.player_id,players.first_name,players.last_name,matches.winner_rank]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT AVG(matches.winner_rank) AS average_winner_rank FROM matches;,SELECT avg(winner_rank) FROM matches,wta_1,"1. Sequential Structure: Begin with the SELECT clause to calculate the average rank of winners in all matches. The field of interest is ""matches.winner_rank"". 2. Condition Structure: No specific filtering condition is required since the query asks for the average rank of all winners. 3. Join Structure: No JOIN is required because the ""winner_rank"" field is already present in the ""matches"" table. 4. Aggregation Structure: Use the AVG function to calculate the average rank of winners.","[(13.715827338129497,)]","[(13.715827338129497,)]",,1.0,
"List the name, date and result of each battle.","[battle.name, battle.date, battle.result]","Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",EASY,"SELECT battle.name, battle.date, battle.result FROM battle;","SELECT name ,  date FROM battle",battle_death,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""battle.name"", ""battle.date"", and ""battle.result"". 2. Condition Structure: No specific filtering condition is required as the query asks for all battles. 3. Join Structure: No JOIN is required since all necessary information is available in the ""battle"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for each battle.","[('Battle of Adrianople', '14 April 1205', 'Bulgarian victory'), ('Battle of Serres', 'June 1205', 'Bulgarian victory'), ('Battle of Rusion', '31 January 1206', 'Bulgarian victory'), ('Battle of Rodosto', 'February 1206', 'Bulgarian victory'), ('Battle of Messinopolis', '4 September 1207', 'Bulgarian victory'), ('Battle of Boruy', 'June 1205', 'Bulgarian victory'), ('Battle of Philippopolis', '31 June 1208', 'Latin victory'), ('Siege of Constantinople', '1235', 'Two Year Truce')]","[('Battle of Adrianople', '14 April 1205'), ('Battle of Serres', 'June 1205'), ('Battle of Rusion', '31 January 1206'), ('Battle of Rodosto', 'February 1206'), ('Battle of Messinopolis', '4 September 1207'), ('Battle of Boruy', 'June 1205'), ('Battle of Philippopolis', '31 June 1208'), ('Siege of Constantinople', '1235')]",,1.0,
Find the name of tourney that has more than 10 matches.,"[matches.tourney_name, matches.tourney_id, matches.match_num]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT matches.tourney_name FROM matches GROUP BY matches.tourney_name HAVING COUNT(matches.match_num) > 10;,SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*)  >  10,wta_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the tournament name (""matches.tourney_name""). 2. Aggregation Structure: Use COUNT to calculate the number of matches for each tournament. 3. Grouping Structure: Use GROUP BY on ""matches.tourney_name"" to aggregate the results by each tournament. 4. Condition Structure: Apply the HAVING clause to filter for tournaments that have more than 10 matches. 5. Join Structure: No JOIN is required since all necessary data is within the ""matches"" table.","[('Australian Open',), ('Cincinnati',), ('French Open',), ('Indian Wells',), ('Miami',), ('Singapore',), ('Us Open',), ('WTA Championships',), ('Wimbledon',)]","[('Australian Open',), ('Cincinnati',), ('French Open',), ('Indian Wells',), ('Miami',), ('Singapore',), ('Us Open',), ('WTA Championships',), ('Wimbledon',)]",,1.0,
Show names of teachers and the courses they are arranged to teach.,"[teacher.Name, course.Course, course_arrange.Teacher_ID = teacher.Teacher_ID, course_arrange.Course_ID = course.Course_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NON-NESTED,"SELECT teacher.Name, course.Course FROM teacher JOIN course_arrange ON teacher.Teacher_ID = course_arrange.Teacher_ID JOIN course ON course_arrange.Course_ID = course.Course_ID;","SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID",course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Name"" and ""course.Course"" fields. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""teacher"" table with ""course_arrange"" on ""teacher.Teacher_ID"" and then connect ""course_arrange"" with ""course"" on ""course.Course_ID"" to link teachers with the courses they are arranged to teach. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the names of teachers and the courses they teach.","[('Kearsley Brown', 'Math'), ('Vicente Carretero', 'Math'), ('Gustaaf Deloor', 'Science'), ('Anne Walker', 'History'), ('Anne Walker', 'Bible'), ('Lucy Wong', 'Music')]","[('Kearsley Brown', 'Math'), ('Vicente Carretero', 'Math'), ('Gustaaf Deloor', 'Science'), ('Anne Walker', 'History'), ('Anne Walker', 'Bible'), ('Lucy Wong', 'Music')]",,1.0,
What are the name and results of the battles when the bulgarian commander is not 'Boril',"[battle.name, battle.result, battle.bulgarian_commander]","Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",EASY,"SELECT battle.name, battle.result FROM battle WHERE battle.bulgarian_commander != 'Boril';","SELECT name ,  RESULT FROM battle WHERE bulgarian_commander != 'Boril'",battle_death,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""battle.name"" and ""battle.result"" fields. 2. Condition Structure: Use a WHERE clause to filter battles where the ""battle.bulgarian_commander"" is not 'Boril'. 3. Join Structure: No JOIN is required since all necessary information is in the ""battle"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and results of battles that meet the specified condition.","[('Battle of Adrianople', 'Bulgarian victory'), ('Battle of Serres', 'Bulgarian victory'), ('Battle of Rusion', 'Bulgarian victory'), ('Battle of Rodosto', 'Bulgarian victory'), ('Battle of Messinopolis', 'Bulgarian victory'), ('Siege of Constantinople', 'Two Year Truce')]","[('Battle of Adrianople', 'Bulgarian victory'), ('Battle of Serres', 'Bulgarian victory'), ('Battle of Rusion', 'Bulgarian victory'), ('Battle of Rodosto', 'Bulgarian victory'), ('Battle of Messinopolis', 'Bulgarian victory'), ('Siege of Constantinople', 'Two Year Truce')]",,1.0,
List the name of teachers whose hometown is not `` Little Lever Urban District '' .,"[teacher.Name, teacher.Hometown]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,SELECT teacher.Name FROM teacher WHERE teacher.Hometown != 'Little Lever Urban District';,"select name from teacher where hometown != ""little lever urban district""",course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Name"" of teachers whose hometown is not ""Little Lever Urban District"". 2. Condition Structure: Use a WHERE clause to filter out teachers whose ""teacher.Hometown"" is ""Little Lever Urban District"". 3. Join Structure: No JOIN is required since all necessary information is in the ""teacher"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.","[('Joseph Huts',), ('Gustaaf Deloor',), ('Vicente Carretero',), ('John Deloor',), ('Kearsley Brown',), ('Lucy Wong',)]","[('Joseph Huts',), ('Gustaaf Deloor',), ('Vicente Carretero',), ('John Deloor',), ('Kearsley Brown',), ('Anne Walker',), ('Lucy Wong',)]",,0.0,
What are the codes of countries with more than 50 players?,"[players.country_code, players.player_id, 50]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT players.country_code FROM players GROUP BY players.country_code HAVING COUNT(players.player_id) > 50;,SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50,wta_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""players.country_code"". 2. Aggregation Structure: Use COUNT to calculate the number of players for each country. 3. Grouping Structure: Use GROUP BY on ""players.country_code"" to group the results by country code. 4. Condition Structure: Apply the HAVING clause to filter for countries with more than 50 players. 5. Join Structure: No JOIN is required since all necessary data is within the ""players"" table.","[('ALG',), ('ARG',), ('AUS',), ('AUT',), ('BEL',), ('BIH',), ('BLR',), ('BOL',), ('BRA',), ('BUL',), ('CAN',), ('CHI',), ('CHN',), ('COL',), ('CRO',), ('CZE',), ('DEN',), ('ECU',), ('EGY',), ('ESP',), ('FIN',), ('FRA',), ('GBR',), ('GEO',), ('GER',), ('GRE',), ('HKG',), ('HUN',), ('INA',), ('IND',), ('IRL',), ('ISR',), ('ITA',), ('JPN',), ('KAZ',), ('KOR',), ('LAT',), ('MAR',), ('MEX',), ('NED',), ('NGR',), ('NOR',), ('NZL',), ('PAR',), ('PER',), ('PHI',), ('POL',), ('POR',), ('ROU',), ('RSA',), ('RUS',), ('SLO',), ('SRB',), ('SUI',), ('SVK',), ('SWE',), ('THA',), ('TPE',), ('TUN',), ('TUR',), ('UKR',), ('URU',), ('USA',), ('UZB',), ('VEN',)]","[('ALG',), ('ARG',), ('AUS',), ('AUT',), ('BEL',), ('BIH',), ('BLR',), ('BOL',), ('BRA',), ('BUL',), ('CAN',), ('CHI',), ('CHN',), ('COL',), ('CRO',), ('CZE',), ('DEN',), ('ECU',), ('EGY',), ('ESP',), ('FIN',), ('FRA',), ('GBR',), ('GEO',), ('GER',), ('GRE',), ('HKG',), ('HUN',), ('INA',), ('IND',), ('IRL',), ('ISR',), ('ITA',), ('JPN',), ('KAZ',), ('KOR',), ('LAT',), ('MAR',), ('MEX',), ('NED',), ('NGR',), ('NOR',), ('NZL',), ('PAR',), ('PER',), ('PHI',), ('POL',), ('POR',), ('ROU',), ('RSA',), ('RUS',), ('SLO',), ('SRB',), ('SUI',), ('SVK',), ('SWE',), ('THA',), ('TPE',), ('TUN',), ('TUR',), ('UKR',), ('URU',), ('USA',), ('UZB',), ('VEN',)]",,1.0,
What are the names of the winner and loser who played in the longest match?,"[matches.minutes, matches.winner_id, matches.loser_id, matches.winner_name, matches.loser_name, matches.winner_id = players.player_id, matches.loser_id = players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT matches.winner_name, matches.loser_name FROM matches ORDER BY matches.minutes DESC LIMIT 1;","SELECT winner_name ,  loser_name FROM matches ORDER BY minutes DESC LIMIT 1",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the winner and loser, i.e., ""matches.winner_name"" and ""matches.loser_name."" 2. Condition Structure: Use a WHERE clause to filter for the match with the longest duration. This can be achieved by ordering the matches by ""matches.minutes"" in descending order and selecting the top record using LIMIT 1. 3. Join Structure: No JOIN is required since the winner and loser names are already present in the ""matches"" table. 4. Aggregation Structure: No aggregation is needed as we are only retrieving the names for a single match.","[('Petra Kvitova', 'Angelique Kerber')]","[('Petra Kvitova', 'Angelique Kerber')]",,1.0,
What is the code of the country with the most players?,"[players.country_code, players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT players.country_code FROM players GROUP BY players.country_code ORDER BY COUNT(players.player_id) DESC LIMIT 1;,SELECT country_code FROM players GROUP BY country_code ORDER BY count(*) DESC LIMIT 1,wta_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""players.country_code"". 2. Aggregation Structure: Use COUNT to calculate the number of players for each country. 3. Grouping Structure: Use GROUP BY on ""players.country_code"" to group the results by each country code. 4. Ordering Structure: Use ORDER BY in descending order on the count of players to rank countries by the number of players. 5. Limiting Structure: Use LIMIT 1 to retrieve the country code with the most players. 6. Join Structure: No JOIN is required since all necessary data is within the ""players"" table.","[('USA',)]","[('USA',)]",,1.0,
Which department offers the most number of degrees? List department name and id.,"[Departments.department_id, Departments.department_name, Degree_Programs.department_id = Departments.department_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Departments.department_name, Departments.department_id FROM Departments JOIN Degree_Programs ON Departments.department_id = Degree_Programs.department_id GROUP BY Departments.department_id, Departments.department_name ORDER BY COUNT(Degree_Programs.degree_program_id) DESC LIMIT 1;","SELECT T2.department_name ,  T1.department_id FROM Degree_Programs AS T1 JOIN Departments AS T2 ON T1.department_id  =  T2.department_id GROUP BY T1.department_id ORDER BY count(*) DESC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Departments.department_name"" and ""Departments.department_id."" Use COUNT to calculate the number of degrees offered by each department. 2. Condition Structure: No specific filtering condition is required as we are interested in all departments. 3. Join Structure: Use an INNER JOIN between ""Departments"" and ""Degree_Programs"" on ""Departments.department_id = Degree_Programs.department_id"" to associate each department with its degree programs. 4. Aggregation Structure: Use COUNT to count the number of degree programs for each department. Use GROUP BY to group results by department. Use ORDER BY in descending order of the count and LIMIT 1 to get the department with the most degrees.","[('statistics', 8)]","[('statistics', 8)]",,1.0,
Find the name and rank points of the winner who won the most times.,"[players.player_id, players.first_name, players.last_name, matches.winner_id, matches.winner_name, matches.winner_id = players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT CONCAT(players.first_name, ' ', players.last_name) AS winner_name, COUNT(matches.winner_id) AS win_count FROM matches JOIN players ON matches.winner_id = players.player_id GROUP BY matches.winner_id ORDER BY win_count DESC LIMIT 1;","SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the winner's name and rank points. Use CONCAT or equivalent to combine ""players.first_name"" and ""players.last_name"" for the full name. Also include the COUNT of matches won by each winner. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all winners to determine the one with the most wins. 3. Join Structure: Use a JOIN between the ""matches"" table and the ""players"" table on ""matches.winner_id = players.player_id"" to link each match with the corresponding winner's details. 4. Aggregation Structure: Use COUNT to count the number of matches won by each winner. Use ORDER BY in descending order of the count to rank winners by the number of wins, and LIMIT 1 to select the winner with the most wins.","[('Angelique Kerber', 22)]","[('Angelique Kerber', 3715)]",,0.0,
"What are the full names of all players, sorted by birth date?","[players.first_name, players.last_name, players.birth_date]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT players.first_name || ' ' || players.last_name AS full_name, players.birth_date FROM players ORDER BY players.birth_date ASC;","SELECT first_name ,  last_name FROM players ORDER BY birth_date",wta_1,"1. Sequential Structure: Begin with the SELECT clause to retrieve the full names of players, which can be constructed by combining ""players.first_name"" and ""players.last_name"", along with their ""players.birth_date"". 2. Condition Structure: No specific filtering condition is required as we want all players. 3. Join Structure: No JOIN is necessary since all required information is available in the ""players"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by ""players.birth_date"" in ascending order.",[],[],Could not decode to UTF-8 column 'full_name' with text 'Joselyn Margarita Treyes Albarrac��N',1.0,Could not decode to UTF-8 column 'last_name' with text 'Treyes Albarrac��N'
What is the name of the museum that had no visitor yet?,"[museum.Name,visit.Museum_ID = museum.Museum_ID,visit.visitor_ID]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",NESTED,SELECT Name FROM museum WHERE Museum_ID NOT IN (SELECT Museum_ID FROM visit);,SELECT name FROM museum WHERE Museum_ID NOT IN (SELECT museum_id FROM visit),museum_visit,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the museum. Use the FROM clause to specify the museum table. Apply a WHERE clause to filter museums that have no visitors by ensuring their Museum_ID is not present in the visit table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude museums whose Museum_ID appears in the visit table, meaning they have visitors. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Museum_ID entries in the visit table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Jefferson Development Museum',), ('RiverPark Museum',), ('Place Tower Museum',), ('Central City District Residential Museum',)]","[('Jefferson Development Museum',), ('RiverPark Museum',), ('Place Tower Museum',), ('Central City District Residential Museum',)]",,1.0,
What is the first name and country code of the player with the most tours?,"[players.first_name, players.country_code, rankings.tours, rankings.player_id = players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT players.first_name, players.country_code FROM players JOIN rankings ON rankings.player_id = players.player_id WHERE rankings.tours = (SELECT MAX(rankings.tours) FROM rankings);","SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id ORDER BY T2.tours DESC LIMIT 1",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve ""players.first_name"" and ""players.country_code."" Since we are looking for the player with the most tours, we will use an aggregate function (MAX) on ""rankings.tours."" 2. Condition Structure: No specific filtering condition is needed, but we will use a subquery to find the player_id with the maximum number of tours. 3. Join Structure: Use a JOIN between the ""rankings"" and ""players"" tables based on ""rankings.player_id = players.player_id"" to associate each player's details with their ranking information. 4. Aggregation Structure: Use MAX to find the maximum number of tours and filter the player with this value using a subquery.","[('Julia', 'USA')]","[('USA', 'Julia')]",,1.0,
"Find the name and membership level of the visitors whose membership level is higher than 4, and sort by their age from old to young.","[visitor.Name, visitor.Level_of_membership, visitor.Age]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",EASY,"SELECT visitor.Name, visitor.Level_of_membership, visitor.Age FROM visitor WHERE visitor.Level_of_membership > 4 ORDER BY visitor.Age DESC;","SELECT name ,  Level_of_membership FROM visitor WHERE Level_of_membership  >  4 ORDER BY age DESC",museum_visit,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""visitor.Name"" and ""visitor.Level_of_membership"" fields, as well as ""visitor.Age"" for sorting purposes. 2. Condition Structure: Use a WHERE clause to filter visitors whose ""visitor.Level_of_membership"" is greater than 4. 3. Join Structure: No JOIN is required since all necessary information is available in the ""visitor"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by ""visitor.Age"" in descending order (from old to young).","[('Fernando Gago', 6, 36), ('Gonzalo Higuaín ', 8, 35), ('Guti Midfielder', 5, 28)]","[('Fernando Gago', 6), ('Gonzalo Higuaín ', 8), ('Guti Midfielder', 5)]",,1.0,
Find the first name and country code of the oldest player.,"[players.first_name, players.country_code, players.birth_date]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT players.first_name, players.country_code FROM players ORDER BY players.birth_date ASC LIMIT 1;","SELECT first_name ,  country_code FROM players ORDER BY birth_date LIMIT 1",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""players.first_name"" and ""players.country_code"" of the oldest player. 2. Condition Structure: No specific filtering condition is required, as we are looking for the player with the earliest birth date. 3. Join Structure: No JOIN is required since all necessary information is in the ""players"" table. 4. Aggregation Structure: Use ORDER BY on ""players.birth_date"" in ascending order to find the oldest player (earliest birth date) and apply LIMIT 1 to select only the oldest player.","[('Thelma', 'AUS')]","[('Thelma', 'AUS')]",,1.0,
"What is the first name, country code, and birth date of the player with the most winner rank points across all matches?","[players.first_name, players.country_code, players.birth_date, matches.winner_rank_points, matches.winner_id = players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT players.first_name, players.country_code, players.birth_date FROM matches JOIN players ON matches.winner_id = players.player_id WHERE matches.winner_rank_points = (SELECT MAX(winner_rank_points) FROM matches);","SELECT T1.first_name ,  T1.country_code ,  T1.birth_date FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id ORDER BY T2.winner_rank_points DESC LIMIT 1",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""players.first_name,"" ""players.country_code,"" and ""players.birth_date."" 2. Condition Structure: No specific filtering condition is needed, but we need to identify the player with the maximum ""winner_rank_points."" Use a subquery to find the maximum ""winner_rank_points"" and filter the player associated with it. 3. Join Structure: Use a JOIN between the ""matches"" and ""players"" tables on ""matches.winner_id = players.player_id"" to link the winner's rank points with their personal details. 4. Aggregation Structure: Use MAX to find the maximum ""winner_rank_points"" and filter the player with this value.","[('Serena', 'USA', 19810926), ('Serena', 'USA', 19810926), ('Serena', 'USA', 19810926)]","[('Serena', 'USA', 19810926)]",,1.0,
What are the names of tournaments that have more than 10 matches?,"[matches.tourney_name, matches.tourney_id, matches.match_num]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT matches.tourney_name FROM matches GROUP BY matches.tourney_id, matches.tourney_name HAVING COUNT(matches.match_num) > 10;",SELECT tourney_name FROM matches GROUP BY tourney_name HAVING count(*)  >  10,wta_1,"1. Sequential Structure: Begin with the SELECT clause to specify the tournament names, as the question asks for the names of tournaments. 2. Aggregation Structure: Use COUNT to calculate the number of matches for each tournament. 3. Grouping Structure: Use GROUP BY on ""matches.tourney_id"" and ""matches.tourney_name"" to aggregate the results by each tournament. 4. Condition Structure: Apply the HAVING clause to filter for tournaments that have more than 10 matches. 5. Join Structure: No JOIN is required since all necessary data is within the ""matches"" table.","[('WTA Championships',), ('Singapore',), ('French Open',), ('Wimbledon',), ('Us Open',), ('Indian Wells',), ('Indian Wells',)]","[('Australian Open',), ('Cincinnati',), ('French Open',), ('Indian Wells',), ('Miami',), ('Singapore',), ('Us Open',), ('WTA Championships',), ('Wimbledon',)]",,0.0,
What are the names of the teachers and the courses they teach in ascending alphabetical order by the name of the teacher?,"[teacher.Name, course.Course, course_arrange.Teacher_ID = teacher.Teacher_ID, course_arrange.Course_ID = course.Course_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NON-NESTED,"SELECT teacher.Name, course.Course FROM teacher JOIN course_arrange ON teacher.Teacher_ID = course_arrange.Teacher_ID JOIN course ON course_arrange.Course_ID = course.Course_ID ORDER BY teacher.Name ASC;","SELECT T3.Name ,  T2.Course FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID ORDER BY T3.Name",course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve ""teacher.Name"" and ""course.Course"" as the required fields. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""teacher"" table with ""course_arrange"" on ""Teacher_ID"" and ""course_arrange"" with ""course"" on ""Course_ID"" to link each teacher with the courses they teach. 4. Aggregation Structure: No aggregation is needed, but apply ORDER BY to sort the results in ascending alphabetical order by the name of the teacher.","[('Anne Walker', 'History'), ('Anne Walker', 'Bible'), ('Gustaaf Deloor', 'Science'), ('Kearsley Brown', 'Math'), ('Lucy Wong', 'Music'), ('Vicente Carretero', 'Math')]","[('Anne Walker', 'History'), ('Anne Walker', 'Bible'), ('Gustaaf Deloor', 'Science'), ('Kearsley Brown', 'Math'), ('Lucy Wong', 'Music'), ('Vicente Carretero', 'Math')]",,1.0,
How many different winners both participated in the WTA Championships and were left handed?,"[matches.winner_id, matches.tourney_name, matches.winner_hand, players.player_id, matches.winner_id = players.player_id, WTA Championships, left]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NESTED,SELECT COUNT(DISTINCT matches.winner_id) AS num_winners FROM matches JOIN players ON matches.winner_id = players.player_id WHERE matches.tourney_name = 'WTA Championships' AND players.hand = 'left';,SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L',wta_1,"1. Sequential Structure: Start with the SELECT clause to count distinct winners. Use the FROM clause to specify the matches table and JOIN it with the players table to access player details. Apply a WHERE clause to filter for matches in the ""WTA Championships"" tournament and winners who are left-handed. 2. Condition Structure: Use the WHERE clause to filter for matches where the tourney_name is ""WTA Championships"" and the winner's hand is ""left"". 3. Join Structure: Use an INNER JOIN between the matches and players tables based on the winner_id and player_id to connect match data with player details. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique winners who meet the specified conditions.","[(0,)]","[(2,)]",,0.0,
What are the descriptions for all the math courses?,"[Courses.course_description, Courses.course_name]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Courses.course_description FROM Courses WHERE Courses.course_name LIKE '%math%';,SELECT course_description FROM Courses WHERE course_name  =  'math',student_transcripts_tracking,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is ""Courses.course_description"". 2. Condition Structure: Use a WHERE clause to filter courses where the ""Courses.course_name"" contains the word ""math"". 3. Join Structure: No JOIN is required since all necessary data is within the ""Courses"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving descriptions for specific courses.","[('q',)]","[('q',)]",,1.0,
What are the names and ranks of the three youngest winners across all matches?,"[matches.winner_id, matches.winner_name, matches.winner_age, players.player_id, players.player_id = matches.winner_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT matches.winner_name, matches.winner_rank, matches.winner_age FROM matches JOIN players ON matches.winner_id = players.player_id ORDER BY matches.winner_age ASC LIMIT 3;","SELECT DISTINCT winner_name ,  winner_rank FROM matches ORDER BY winner_age LIMIT 3",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names and ranks of winners. Since we are interested in the three youngest winners, include ""matches.winner_name,"" ""matches.winner_rank,"" and ""matches.winner_age"" in the SELECT clause. Use ORDER BY to sort the results by ""matches.winner_age"" in ascending order and LIMIT 3 to get the youngest three winners. 2. Condition Structure: No specific filtering condition is required, as we are considering all matches. 3. Join Structure: Use an INNER JOIN between the ""matches"" table and the ""players"" table on ""matches.winner_id = players.player_id"" to ensure we are working with valid player data. 4. Aggregation Structure: No aggregation is needed, as we are only sorting and limiting the results.","[('Madison Keys', 17, 20.917180013699998), ('Madison Keys', 24, 21.0896646133), ('Madison Keys', 16, 21.3196440794)]","[('Madison Keys', 17), ('Madison Keys', 24), ('Madison Keys', 16)]",,1.0,
"Find the names of the visitors whose membership level is higher than 4, and order the results by the level from high to low.","[visitor.Name, visitor.Level_of_membership]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",EASY,"SELECT visitor.Name, visitor.Level_of_membership FROM visitor WHERE visitor.Level_of_membership > 4 ORDER BY visitor.Level_of_membership DESC;",SELECT name FROM visitor WHERE Level_of_membership  >  4 ORDER BY Level_of_membership DESC,museum_visit,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""visitor.Name"" and ""visitor.Level_of_membership"" of visitors whose membership level is higher than 4. 2. Condition Structure: Use a WHERE clause to filter for visitors with ""visitor.Level_of_membership"" greater than 4. 3. Join Structure: No JOIN is required since all necessary information is in the ""visitor"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by ""visitor.Level_of_membership"" in descending order.","[('Gonzalo Higuaín ', 8), ('Fernando Gago', 6), ('Guti Midfielder', 5)]","[('Gonzalo Higuaín ',), ('Fernando Gago',), ('Guti Midfielder',)]",,1.0,
Find the total number of players.,[players.player_id],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT COUNT(players.player_id) AS total_players FROM players;,SELECT count(*) FROM players,wta_1,"1. Sequential Structure: Start with the SELECT clause to count the total number of players. 2. Condition Structure: No specific filtering condition is required as we want the total count of all players. 3. Join Structure: No JOIN is necessary since the required information is available within the ""players"" table. 4. Aggregation Structure: Use COUNT on ""players.player_id"" to calculate the total number of players.","[(20662,)]","[(20662,)]",,1.0,
How many battles did not lose any ship with tonnage '225'?,"[battle.id, ship.lost_in_battle, ship.tonnage, ship.lost_in_battle = battle.id, 225]","Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",NESTED,SELECT COUNT(*) FROM battle WHERE id NOT IN ( SELECT lost_in_battle FROM ship WHERE tonnage = 225 );,SELECT count(*) FROM battle WHERE id NOT IN ( SELECT lost_in_battle FROM ship WHERE tonnage  =  '225' );,battle_death,"1. Sequential Structure: Start with the SELECT clause to count the number of battles. Use the FROM clause to specify the battle table. Apply a WHERE clause to filter battles that did not lose any ship with a tonnage of '225'. 2. Condition Structure: Use a WHERE clause with a subquery to exclude battles where a ship with a tonnage of '225' is lost. The subquery identifies battles where such ships are lost by checking the ship table for tonnage '225' and matching lost_in_battle with battle.id. 3. Join Structure: Not required, as the filtering is done using a subquery and the main query only involves the battle table. 4. Aggregation Structure: Use COUNT to count the number of battles that meet the condition.","[(7,)]","[(7,)]",,1.0,
Find the total number of tours for each ranking date.,"[rankings.ranking_date, rankings.tours]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT rankings.ranking_date, SUM(rankings.tours) AS total_tours FROM rankings GROUP BY rankings.ranking_date;","SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date",wta_1,"1. Sequential Structure: Begin with the SELECT clause to specify the ranking date and the total number of tours. 2. Aggregation Structure: Use SUM to calculate the total number of tours for each ranking date. 3. Grouping Structure: Use GROUP BY on ""rankings.ranking_date"" to calculate the total tours for each ranking date. 4. Join Structure: No JOIN is required since all necessary data is within the ""rankings"" table.","[(19870119, 0), (19870126, 0), (19870202, 0), (19870209, 0), (19870302, 0), (19870330, 0), (19870406, 0), (19870413, 0), (19870420, 0), (19870427, 0), (19870504, 0), (19870511, 0), (19870518, 0), (19870525, 0), (19870601, 0), (19870608, 0), (19870615, 0), (19870622, 0), (19870629, 0), (19870706, 0), (19870713, 0), (19870720, 0), (19870727, 0), (19870803, 0), (19870810, 0), (19870817, 0), (19870824, 0), (19870831, 0), (19870907, 0), (19870914, 0), (19870921, 0), (19870928, 0), (19871005, 0), (19871012, 0), (19871019, 0), (19871026, 0), (19871102, 0), (19871109, 0), (19871116, 0), (19871123, 0), (19871130, 0), (19871207, 0), (19871214, 0), (19871221, 0), (19871228, 0), (19880101, 0), (19880104, 0), (19880111, 0), (19880118, 0), (19880125, 0), (19880201, 0), (19880208, 0), (19880215, 0), (19880222, 0), (19880229, 0), (19880307, 0), (19880314, 0), (19880321, 0), (19880328, 0), (19880404, 0), (19880411, 0), (19880418, 0), (19880425, 0), (19880502, 0), (19880509, 0), (19880516, 0), (19880523, 0), (19880530, 0), (19880606, 0), (19880613, 0), (19880620, 0), (19880627, 0), (19880704, 0), (19880711, 0), (19880718, 0), (19880725, 0), (19880801, 0), (19880808, 0), (19880815, 0), (19880822, 0), (19880829, 0), (19880905, 0), (19880912, 0), (19880919, 0), (19880926, 0), (19881003, 0), (19881010, 0), (19881017, 0), (19881024, 0), (19881031, 0), (19881107, 0), (19881114, 0), (19881121, 29), (19881128, 29), (19881205, 29), (19881212, 29), (19881219, 29), (19881226, 29), (19890101, 28), (19890102, 29), (19890109, 29), (19890116, 29), (19890123, 29), (19890130, 29), (19890206, 29), (19890213, 0), (19890220, 0), (19890227, 0), (19890306, 0), (19890313, 29), (19890320, 29), (19890327, 0), (19890403, 0), (19890410, 29), (19890417, 29), (19890424, 29), (19890501, 29), (19890508, 29), (19890515, 29), (19890522, 29), (19890529, 29), (19890605, 29), (19890612, 29), (19890619, 29), (19890626, 29), (19890703, 29), (19890710, 29), (19890717, 29), (19890724, 29), (19890731, 29), (19890807, 29), (19890814, 29), (19890821, 29), (19890828, 29), (19890904, 29), (19890911, 29), (19890918, 29), (19890925, 29), (19891002, 29), (19891009, 29), (19891016, 29), (19891023, 29), (19891030, 29), (19891106, 29), (19891113, 29), (19891120, 29), (19891127, 29), (19891204, 29), (19891211, 29), (19891218, 29), (19891225, 29), (19900101, 28), (19900108, 29), (19900115, 29), (19900122, 29), (19900129, 29), (19900205, 29), (19900212, 29), (19900219, 29), (19900226, 29), (19900305, 29), (19900312, 29), (19900319, 29), (19900326, 29), (19900402, 29), (19900409, 29), (19900416, 29), (19900423, 29), (19900430, 29), (19900507, 29), (19900514, 29), (19900521, 29), (19900528, 29), (19900604, 29), (19900611, 29), (19900618, 30), (19900625, 30), (19900702, 30), (19900709, 30), (19900716, 30), (19900723, 30), (19900730, 30), (19900806, 30), (19900813, 30), (19900820, 30), (19900827, 30), (19900903, 30), (19900910, 30), (19900917, 30), (19900924, 30), (19901001, 30), (19901008, 30), (19901015, 30), (19901022, 30), (19901029, 30), (19901105, 30), (19901112, 30), (19901119, 30), (19901126, 30), (19901203, 30), (19901210, 30), (19901217, 30), (19901224, 30), (19901231, 30), (19910101, 29), (19910107, 30), (19910114, 30), (19910121, 30), (19910128, 30), (19910204, 30), (19910211, 30), (19910218, 30), (19910225, 30), (19910304, 30), (19910311, 29), (19910318, 29), (19910325, 29), (19910401, 29), (19910408, 29), (19910415, 29), (19910422, 29), (19910429, 29), (19910506, 29), (19910513, 29), (19910520, 29), (19910527, 29), (19910603, 29), (19910610, 29), (19910617, 29), (19910624, 29), (19910701, 29), (19910708, 30), (19910715, 29), (19910722, 29), (19910729, 29), (19910805, 29), (19910812, 29), (19910819, 29), (19910826, 30), (19910902, 30), (19910909, 30), (19910916, 30), (19910923, 30), (19910930, 30), (19911007, 31), (19911014, 31), (19911021, 31), (19911028, 31), (19911104, 44), (19911111, 44), (19911118, 44), (19911125, 44), (19911202, 31), (19911209, 44), (19911216, 45), (19911223, 45), (19911230, 45), (19920101, 44), (19920106, 45), (19920113, 45), (19920120, 45), (19920127, 45), (19920203, 45), (19920210, 29), (19920217, 45), (19920224, 45), (19920302, 45), (19920309, 45), (19920316, 45), (19920323, 45), (19920330, 45), (19920406, 45), (19920413, 45), (19920420, 45), (19920427, 45), (19920504, 45), (19920511, 45), (19920518, 45), (19920525, 45), (19920601, 45), (19920608, 45), (19920615, 45), (19920622, 45), (19920629, 45), (19920706, 45), (19920713, 46), (19920720, 46), (19920727, 45), (19920803, 73), (19920810, 73), (19920817, 73), (19920824, 119), (19920831, 90), (19920907, 90), (19920914, 90), (19920921, 90), (19920928, 90), (19921005, 62), (19921012, 62), (19921019, 62), (19921026, 62), (19921102, 62), (19921109, 62), (19921116, 62), (19921123, 62), (19921130, 62), (19921207, 62), (19921214, 62), (19921221, 62), (19921228, 45), (19930101, 44), (19930104, 45), (19930111, 45), (19930118, 45), (19930125, 45), (19930201, 45), (19930208, 32), (19930215, 45), (19930222, 45), (19930301, 45), (19930308, 45), (19930315, 45), (19930322, 45), (19930329, 45), (19930405, 45), (19930412, 62), (19930419, 62), (19930426, 62), (19930503, 62), (19930510, 62), (19930517, 44), (19930524, 44), (19930531, 44), (19930607, 44), (19930614, 44), (19930621, 44), (19930628, 44), (19930705, 62), (19930712, 62), (19930719, 62), (19930726, 62), (19930802, 43), (19930809, 43), (19930816, 43), (19930823, 43), (19930830, 43), (19930906, 43), (19930913, 43), (19930920, 76), (19930927, 75), (19931004, 58), (19931011, 58), (19931018, 58), (19931025, 58), (19931101, 58), (19931108, 58), (19931115, 75), (19931122, 75), (19931129, 75), (19931206, 75), (19931213, 75), (19931220, 75), (19931227, 75), (19940101, 73), (19940103, 75), (19940110, 75), (19940117, 75), (19940124, 75), (19940131, 62), (19940207, 63), (19940214, 63), (19940221, 63), (19940228, 62), (19940307, 62), (19940314, 62), (19940321, 62), (19940328, 61), (19940404, 62), (19940411, 61), (19940418, 44), (19940425, 57), (19940502, 57), (19940509, 57), (19940516, 57), (19940523, 57), (19940530, 57), (19940606, 65), (19940613, 65), (19940620, 65), (19940627, 65), (19940704, 67), (19940711, 67), (19940718, 60), (19940725, 60), (19940801, 60), (19940808, 60), (19940815, 60), (19940822, 60), (19940829, 60), (19940905, 60), (19940912, 68), (19940919, 68), (19940926, 69), (19941003, 69), (19941010, 69), (19941017, 69), (19941024, 59), (19941031, 59), (19941107, 69), (19941114, 69), (19941121, 69), (19941128, 69), (19941205, 69), (19941212, 69), (19941219, 69), (19941226, 69), (19950101, 69), (19950102, 69), (19950109, 69), (19950116, 69), (19950123, 69), (19950130, 69), (19950206, 69), (19950213, 69), (19950220, 69), (19950227, 69), (19950306, 69), (19950313, 69), (19950320, 69), (19950327, 69), (19950403, 69), (19950410, 69), (19950417, 69), (19950424, 69), (19950501, 69), (19950508, 69), (19950515, 69), (19950522, 69), (19950529, 69), (19950605, 69), (19950612, 96), (19950619, 96), (19950626, 96), (19950703, 96), (19950710, 97), (19950717, 118), (19950724, 118), (19950731, 118), (19950807, 118), (19950814, 118), (19950821, 131), (19950828, 131), (19950904, 131), (19950911, 131), (19950918, 131), (19950925, 131), (19951002, 131), (19951009, 131), (19951016, 131), (19951023, 131), (19951030, 131), (19951106, 131), (19951113, 138), (19951120, 138), (19951127, 138), (19951204, 138), (19951211, 138), (19951218, 138), (19951225, 138), (19960101, 138), (19960108, 125), (19960115, 125), (19960122, 125), (19960129, 125), (19960205, 125), (19960212, 125), (19960219, 125), (19960226, 147), (19960304, 147), (19960311, 147), (19960318, 147), (19960325, 147), (19960401, 147), (19960408, 147), (19960415, 147), (19960422, 147), (19960429, 147), (19960506, 147), (19960513, 147), (19960520, 147), (19960527, 147), (19960603, 147), (19960610, 147), (19960617, 147), (19960624, 147), (19960701, 147), (19960708, 171), (19960715, 171), (19960722, 171), (19960729, 171), (19960805, 171), (19960812, 171), (19960819, 171), (19960826, 171), (19960902, 171), (19960909, 194), (19960916, 172), (19960923, 172), (19960930, 172), (19961007, 172), (19961014, 175), (19961021, 175), (19961028, 191), (19961104, 191), (19961111, 213), (19961118, 213), (19961125, 213), (19961202, 213), (19961209, 213), (19961216, 213), (19961223, 185), (19961230, 185), (19970101, 185), (19970106, 185), (19970113, 185), (19970120, 185), (19970127, 209), (19970203, 209), (19970210, 209), (19970217, 209), (19970224, 223), (19970303, 223), (19970310, 223), (19970317, 223), (19970324, 223), (19970331, 223), (19970407, 223), (19970414, 225), (19970421, 225), (19970428, 225), (19970505, 225), (19970512, 225), (19970519, 225), (19970526, 225), (19970602, 225), (19970609, 225), (19970616, 225), (19970623, 225), (19970630, 225), (19970707, 164), (19970714, 257), (19970721, 257), (19970728, 257), (19970804, 273), (19970811, 273), (19970818, 273), (19970825, 273), (19970901, 273), (19970908, 273), (19970915, 273), (19970922, 273), (19970929, 273), (19971006, 273), (19971013, 299), (19971020, 314), (19971027, 314), (19971103, 337), (19971110, 337), (19971117, 363), (19971124, 363), (19971201, 363), (19971208, 394), (19971215, 394), (19971222, 394), (19971229, 394), (19980101, 394), (19980105, 394), (19980112, 394), (19980119, 394), (19980126, 394), (19980202, 394), (19980209, 394), (19980216, 394), (19980223, 394), (19980302, 394), (19980309, 394), (19980316, 394), (19980323, 394), (19980330, 426), (19980406, 426), (19980413, 459), (19980420, 459), (19980427, 459), (19980504, 459), (19980511, 459), (19980518, 459), (19980525, 459), (19980601, 459), (19980608, 543), (19980615, 569), (19980622, 590), (19980629, 590), (19980706, 633), (19980713, 633), (19980720, 633), (19980727, 634), (19980803, 634), (19980810, 634), (19980817, 631), (19980824, 631), (19980831, 660), (19980907, 660), (19980914, 663), (19980921, 663), (19980928, 683), (19981005, 688), (19981012, 688), (19981019, 696), (19981026, 693), (19981102, 693), (19981109, 692), (19981116, 692), (19981123, 692), (19981130, 709), (19981207, 703), (19981214, 703), (19981221, 703), (19981228, 703), (19990101, 703), (19990104, 722), (19990111, 722), (19990118, 722), (19990125, 722), (19990201, 728), (19990208, 723), (19990215, 723), (19990222, 723), (19990301, 723), (19990308, 723), (19990315, 728), (19990322, 728), (19990329, 728), (19990405, 728), (19990412, 728), (19990419, 728), (19990426, 752), (19990503, 761), (19990510, 761), (19990517, 777), (19990524, 777), (19990531, 777), (19990607, 804), (19990614, 804), (19990621, 804), (19990628, 804), (19990705, 804), (19990712, 829), (19990719, 829), (19990726, 829), (19990802, 829), (19990809, 870), (19990816, 873), (19990823, 853), (19990830, 861), (19990906, 861), (19990913, 879), (19990920, 879), (19990927, 899), (19991004, 927), (19991011, 941), (19991018, 964), (19991025, 941), (19991101, 941), (19991108, 941), (19991115, 941), (19991122, 941), (19991129, 966), (19991206, 966), (19991213, 989), (19991220, 989), (19991227, 989), (20000101, 989), (20000103, 989), (20000110, 989), (20000117, 989), (20000124, 989), (20000131, 1013), (20000207, 1038), (20000214, 1038), (20000221, 1038), (20000228, 1038), (20000306, 1065), (20000313, 1065), (20000320, 1065), (20000327, 1065), (20000403, 1065), (20000410, 1093), (20000417, 1093), (20000424, 1093), (20000501, 1122), (20000508, 1122), (20000515, 1106), (20000522, 1106), (20000529, 1106), (20000605, 1106), (20000612, 1160), (20000619, 1160), (20000626, 1188), (20000703, 1188), (20000710, 1204), (20000717, 1205), (20000724, 1212), (20000731, 1276), (20000807, 1276), (20000814, 1224), (20000821, 1224), (20000828, 1224), (20000904, 1224), (20000911, 1241), (20000918, 1265), (20000925, 1231), (20001002, 1223), (20001009, 1232), (20001016, 1253), (20001023, 1245), (20001030, 1247), (20001106, 1173), (20001113, 964), (20001120, 961), (20001127, 961), (20001204, 961), (20001211, 964), (20001218, 964), (20001225, 964), (20010101, 964), (20010108, 964), (20010115, 964), (20010122, 964), (20010129, 977), (20010205, 977), (20010212, 1004), (20010219, 1027), (20010226, 1027), (20010305, 1027), (20010312, 1027), (20010319, 1101), (20010326, 1101), (20010402, 914), (20010409, 930), (20010416, 952), (20010423, 961), (20010430, 988), (20010507, 1011), (20010514, 1011), (20010521, 1029), (20010528, 1067), (20010604, 1067), (20010611, 1094), (20010618, 1094), (20010625, 1073), (20010702, 1073), (20010709, 1113), (20010716, 1135), (20010723, 1149), (20010730, 1149), (20010806, 1175), (20010813, 1175), (20010820, 1175), (20010827, 1201), (20010903, 1201), (20010910, 1228), (20010917, 1231), (20010924, 1263), (20011001, 1287), (20011008, 1267), (20011015, 1288), (20011022, 1291), (20011029, 1312), (20011105, 1312), (20011112, 1412), (20011119, 1412), (20011126, 1437), (20011203, 1437), (20011210, 1437), (20011217, 1430), (20011224, 1430), (20011231, 1430), (20020101, 1430), (20020107, 1430), (20020114, 1430), (20020121, 1430), (20020128, 1430), (20020204, 1422), (20020211, 1422), (20020218, 1422), (20020225, 1424), (20020304, 1424), (20020311, 1424), (20020318, 1448), (20020325, 1448), (20020401, 1573), (20020408, 1574), (20020415, 1574), (20020422, 1574), (20020429, 1577), (20020506, 1730), (20020513, 1577), (20020520, 1577), (20020527, 1577), (20020603, 1577), (20020610, 1783), (20020617, 1803), (20020624, 1783), (20020701, 1783), (20020708, 1834), (20020715, 1835), (20020722, 1828), (20020729, 1853), (20020805, 1853), (20020812, 1925), (20020819, 1915), (20020826, 2111), (20020902, 2111), (20020909, 2451), (20020916, 2457), (20020923, 2462), (20020930, 2496), (20021007, 2526), (20021014, 2520), (20021021, 2505), (20021028, 2505), (20021104, 2498), (20021111, 2497), (20021118, 2497), (20021125, 2497), (20021202, 2497), (20021209, 2497), (20021216, 2497), (20021223, 2497), (20021230, 2497), (20030101, 2497), (20030106, 2497), (20030113, 2497), (20030120, 2497), (20030127, 2497), (20030203, 2517), (20030210, 2507), (20030217, 2490), (20030224, 2528), (20030303, 2549), (20030310, 2549), (20030317, 2571), (20030324, 2571), (20030331, 2614), (20030407, 2587), (20030414, 2587), (20030421, 2608), (20030428, 2719), (20030505, 2652), (20030512, 2671), (20030519, 2728), (20030526, 1860), (20030602, 2728), (20030609, 2753), (20030616, 2753), (20030623, 2731), (20030630, 2731), (20030707, 2730), (20030714, 2755), (20030721, 2759), (20030728, 2777), (20030804, 2732), (20030811, 2734), (20030818, 2755), (20030825, 2801), (20030901, 2801), (20030908, 2798), (20030915, 2847), (20030922, 2862), (20030929, 2930), (20031006, 2961), (20031013, 2966), (20031020, 3035), (20031027, 3020), (20031103, 3038), (20031110, 3052), (20031117, 3065), (20031124, 3092), (20031201, 3120), (20031208, 3190), (20031215, 3211), (20031222, 3211), (20031229, 3214), (20040101, 3214), (20040105, 3206), (20040112, 3206), (20040119, 3206), (20040126, 3206), (20040202, 3257), (20040209, 3265), (20040216, 3282), (20040223, 3282), (20040301, 3279), (20040308, 3286), (20040315, 3286), (20040322, 3286), (20040329, 3286), (20040405, 3277), (20040412, 3286), (20040419, 1489), (20040426, 3379), (20040503, 2613), (20040510, 1187), (20040517, 2361), (20040524, 2955), (20040531, 2535), (20040607, 3433), (20040614, 3456), (20040621, 3492), (20040628, 3492), (20040705, 3498), (20040712, 3516), (20040719, 3587), (20040726, 3592), (20040802, 3592), (20040809, 3645), (20040816, 3647), (20040823, 3661), (20040830, 3705), (20040906, 3705), (20040913, 3785), (20040920, 3831), (20040927, 3913), (20041004, 3957), (20041011, 3986), (20041018, 3987), (20041025, 3968), (20041101, 4011), (20041108, 4071), (20041115, 4124), (20041122, 4145), (20041129, 4147), (20041206, 4160), (20041213, 4160), (20041220, 4160), (20041227, 4160), (20050101, 4160), (20050103, 4160), (20050110, 4160), (20050117, 4160), (20050124, 4160), (20050131, 4198), (20050207, 4198), (20050214, 4211), (20050221, 4286), (20050228, 4286), (20050307, 4313), (20050314, 4313), (20050321, 4333), (20050328, 4333), (20050404, 4362), (20050411, 4371), (20050418, 4379), (20050425, 4379), (20050502, 4379), (20050509, 4470), (20050516, 4489), (20050523, 4522), (20050530, 4522), (20050606, 4682), (20050613, 4705), (20050620, 4727), (20050627, 4727), (20050704, 4792), (20050711, 4816), (20050718, 4847), (20050725, 4859), (20050801, 4926), (20050808, 4982), (20050815, 5020), (20050822, 5090), (20050829, 5100), (20050905, 5100), (20050912, 5187), (20050919, 5173), (20050926, 5175), (20051003, 5215), (20051010, 5249), (20051017, 5237), (20051024, 5257), (20051031, 5331), (20051107, 5362), (20051114, 5357), (20051121, 5391), (20051128, 5401), (20051205, 5452), (20051212, 5452), (20051219, 5452), (20051226, 5452), (20060101, 5452), (20060102, 5452), (20060109, 5452), (20060116, 5452), (20060123, 5452), (20060130, 5441), (20060206, 5425), (20060213, 5441), (20060220, 5478), (20060227, 5528), (20060306, 5548), (20060313, 5548), (20060320, 5559), (20060327, 5559), (20060403, 5626), (20060410, 5626), (20060417, 5644), (20060424, 5658), (20060501, 5656), (20060508, 5654), (20060515, 5683), (20060522, 5721), (20060529, 5798), (20060605, 5798), (20060612, 5862), (20060619, 5897), (20060626, 5944), (20060703, 5944), (20060710, 5983), (20060717, 6026), (20060724, 6065), (20060731, 6133), (20060807, 6151), (20060814, 6226), (20060821, 6289), (20060828, 6284), (20060904, 6284), (20060911, 6304), (20060918, 6347), (20060925, 6376), (20061002, 6436), (20061009, 6520), (20061016, 6629), (20061023, 6730), (20061030, 6808), (20061106, 6816), (20061113, 6807), (20061120, 6893), (20061127, 6896), (20061204, 6931), (20061211, 6953), (20061218, 6953), (20061225, 6953), (20070101, 6953), (20070108, 6926), (20070115, 6926), (20070122, 6926), (20070129, 6925), (20070205, 6925), (20070212, 6930), (20070219, 6942), (20070226, 6988), (20070305, 7017), (20070312, 7017), (20070319, 7058), (20070326, 7058), (20070402, 7139), (20070409, 7175), (20070416, 7197), (20070423, 7197), (20070430, 7197), (20070507, 7233), (20070514, 7317), (20070521, 7341), (20070528, 7365), (20070604, 7365), (20070611, 7448), (20070618, 7448), (20070625, 7473), (20070702, 7473), (20070709, 7495), (20070716, 7478), (20070723, 7470), (20070730, 7528), (20070806, 7522), (20070813, 7527), (20070820, 7503), (20070827, 7504), (20070903, 7504), (20070910, 7602), (20070917, 7643), (20070924, 7686), (20071001, 7697), (20071008, 7707), (20071015, 7687), (20071022, 7638), (20071029, 7711), (20071105, 7677), (20071112, 7664), (20071119, 7666), (20071126, 7674), (20071203, 7650), (20071210, 7659), (20071217, 7659), (20071224, 7682), (20071231, 7682), (20080101, 7682), (20080107, 7682), (20080114, 7711), (20080121, 7711), (20080128, 7691), (20080204, 7716), (20080211, 7743), (20080218, 7742), (20080225, 7731), (20080303, 7761), (20080310, 7790), (20080317, 7790), (20080324, 7832), (20080331, 7832), (20080407, 7873), (20080414, 7889), (20080421, 7917), (20080428, 7917), (20080505, 7929), (20080512, 8002), (20080519, 8022), (20080526, 8090), (20080602, 8090), (20080609, 8030), (20080616, 7970), (20080623, 7966), (20080630, 7966), (20080707, 8089), (20080714, 8113), (20080721, 8235), (20080728, 8280), (20080804, 8325), (20080811, 8372), (20080818, 8387), (20080825, 8417), (20080901, 8417), (20080908, 8527), (20080915, 8639), (20080922, 8690), (20080929, 8731), (20081006, 8762), (20081013, 8794), (20081020, 8836), (20081027, 8898), (20081103, 8956), (20081110, 8996), (20081117, 9003), (20081124, 9019), (20081201, 9050), (20081208, 9076), (20081215, 9077), (20081222, 9070), (20081229, 9070), (20090101, 9070), (20090105, 9064), (20090112, 9064), (20090119, 9064), (20090126, 9064), (20090202, 9087), (20090209, 9087), (20090216, 9059), (20090223, 9063), (20090302, 9063), (20090309, 9053), (20090316, 9053), (20090323, 9057), (20090330, 9057), (20090406, 9066), (20090413, 9121), (20090420, 9110), (20090427, 9111), (20090504, 9094), (20090511, 9143), (20090518, 9140), (20090525, 9153), (20090601, 9153), (20090608, 9203), (20090615, 9239), (20090622, 9255), (20090629, 9255), (20090706, 9310), (20090713, 9376), (20090720, 9474), (20090727, 9589), (20090803, 9611), (20090810, 9598), (20090817, 9642), (20090824, 9682), (20090831, 9682), (20090907, 9682), (20090914, 9808), (20090921, 9856), (20090928, 9918), (20091005, 9929), (20091012, 9925), (20091019, 10003), (20091026, 10025), (20091102, 10061), (20091109, 10116), (20091116, 10137), (20091123, 10204), (20091130, 10238), (20091207, 10221), (20091214, 10272), (20091221, 10272), (20091228, 10318), (20100101, 10318), (20100104, 10318), (20100111, 10320), (20100118, 10329), (20100125, 10329), (20100201, 10373), (20100208, 10372), (20100215, 10389), (20100222, 10404), (20100301, 10430), (20100308, 10442), (20100315, 10442), (20100322, 10412), (20100329, 10412), (20100405, 10481), (20100412, 10515), (20100419, 10543), (20100426, 10580), (20100503, 10590), (20100510, 10576), (20100517, 10593), (20100524, 10634), (20100531, 10634), (20100607, 10613), (20100614, 10630), (20100621, 10634), (20100628, 10634), (20100705, 10685), (20100712, 10726), (20100719, 10756), (20100726, 10817), (20100802, 10835), (20100809, 10937), (20100816, 10999), (20100823, 11026), (20100830, 11125), (20100906, 11125), (20100913, 11256), (20100920, 11290), (20100927, 11339), (20101004, 11460), (20101011, 11566), (20101018, 11594), (20101025, 11617), (20101101, 11687), (20101108, 11735), (20101115, 11814), (20101122, 11845), (20101129, 11877), (20101206, 11888), (20101213, 11907), (20101220, 11913), (20101227, 11904), (20110101, 11904), (20110103, 12060), (20110110, 12067), (20110117, 12094), (20110124, 12094), (20110131, 12143), (20110207, 12181), (20110214, 12204), (20110221, 12201), (20110228, 12254), (20110307, 12267), (20110314, 12267), (20110321, 12303), (20110328, 12303), (20110404, 12343), (20110411, 12398), (20110418, 12434), (20110425, 12422), (20110502, 12438), (20110509, 12482), (20110516, 12467), (20110523, 12522), (20110530, 12522), (20110606, 12659), (20110613, 12682), (20110620, 12686), (20110627, 12686), (20110704, 12867), (20110711, 12895), (20110718, 12927), (20110725, 13006), (20110801, 12999), (20110808, 13081), (20110815, 13129), (20110822, 13140), (20110829, 13174), (20110905, 13174), (20110912, 13299), (20110919, 13342), (20110926, 13382), (20111003, 13372), (20111010, 13382), (20111017, 13411), (20111024, 13443), (20111031, 13465), (20111107, 13443), (20111114, 13482), (20111121, 13518), (20111128, 13517), (20111205, 13542), (20111212, 13536), (20111219, 13565), (20111226, 13603), (20120101, 13603), (20120102, 13610), (20120109, 13628), (20120116, 13618), (20120123, 13618), (20120130, 13667), (20120206, 13666), (20120213, 13674), (20120220, 13719), (20120227, 13788), (20120305, 13791), (20120312, 13791), (20120319, 13818), (20120326, 13818), (20120402, 13881), (20120409, 13902), (20120416, 13938), (20120423, 13964), (20120430, 13983), (20120507, 14016), (20120514, 14015), (20120521, 14034), (20120528, 14087), (20120604, 14087), (20120611, 14072), (20120618, 14138), (20120625, 14172), (20120702, 14172), (20120709, 14180), (20120716, 14223), (20120723, 14250), (20120730, 14264), (20120806, 14286), (20120813, 14331), (20120820, 14361), (20120827, 14389), (20120903, 14389), (20120910, 14389), (20120917, 14402), (20120924, 14438), (20121001, 14472), (20121008, 14480), (20121015, 14513), (20121022, 14525), (20121029, 14547), (20121105, 14585), (20121112, 14621), (20121119, 14624), (20121126, 14612), (20121203, 14610), (20121210, 14639), (20121217, 14633), (20121224, 14649), (20121231, 13949), (20130101, 14648), (20130107, 13966), (20130114, 14667), (20130121, 14667), (20130128, 14667), (20130204, 14652), (20130211, 14651), (20130218, 14649), (20130225, 14554), (20130304, 14695), (20130311, 14727), (20130318, 13048), (20130401, 6790), (20130408, 14591), (20130415, 14449), (20130422, 14451), (20130429, 14462), (20130506, 14487), (20130513, 14516), (20130520, 14531), (20130527, 14545), (20130603, 14545), (20130610, 14553), (20130617, 14569), (20130624, 14650), (20130708, 14651), (20130715, 14689), (20130722, 14751), (20130729, 14766), (20130805, 14679), (20130812, 14599), (20130819, 14740), (20130826, 14714), (20130902, 14796), (20130909, 14820), (20130916, 14866), (20130923, 14878), (20130930, 14885), (20131007, 15028), (20131014, 15072), (20131021, 15025), (20131028, 15071), (20131104, 15098), (20131111, 15101), (20131118, 15151), (20131125, 15337), (20131202, 15334), (20131209, 15512), (20131216, 15540), (20131223, 15701), (20131230, 15708), (20140106, 15703), (20140113, 15637), (20140120, 8585), (20140127, 15646), (20140203, 15632), (20140210, 15637), (20140217, 8565), (20140224, 15659), (20150302, 15557), (20150406, 15578), (20150413, 15545), (20150420, 15568), (20150427, 15475), (20150511, 15710), (20150518, 15623), (20150525, 15741), (20150608, 15741), (20150622, 15810), (20150803, 15761), (20150810, 15776), (20150824, 15908), (20150831, 16184), (20150914, 15832), (20150921, 15800), (20151005, 16178), (20151012, 16191), (20151019, 16138), (20151102, 16293), (20160111, 4812), (20160118, 16518), (20160201, 16629), (20160208, 16586), (20160215, 16529), (20160222, 16454), (20160229, 16515), (20160307, 16517), (20160411, 16446), (20160418, 16454), (20160425, 16489), (20160502, 16388), (20160509, 16374), (20160523, 16351), (20160606, 16361), (20160620, 16314), (20160627, 16293), (20160815, 16325), (20160919, 16316), (20160926, 16305), (20161010, 16233), (20161031, 16349), (20161107, 16364), (20161114, 16249), (20161121, 16345), (20161128, 16294), (20161205, 16336), (20161212, 16387), (20170102, 16372), (20170109, 16406), (20170116, 16379), (20170213, 16305), (20170220, 16207), (20170306, 16111), (20170320, 16230), (20170417, 16270), (20170424, 16226), (20170501, 16303), (20170508, 16124), (20170515, 16204), (20170522, 16290), (20170529, 16649), (20170612, 16157), (20170619, 16189), (20170626, 16184), (20170703, 16597), (20170717, 15983), (20170724, 16138), (20170731, 16145), (20170807, 16147), (20170814, 16268), (20170821, 16279), (20170828, 16301), (20170911, 16161)]","[(0, 19870119), (0, 19870126), (0, 19870202), (0, 19870209), (0, 19870302), (0, 19870330), (0, 19870406), (0, 19870413), (0, 19870420), (0, 19870427), (0, 19870504), (0, 19870511), (0, 19870518), (0, 19870525), (0, 19870601), (0, 19870608), (0, 19870615), (0, 19870622), (0, 19870629), (0, 19870706), (0, 19870713), (0, 19870720), (0, 19870727), (0, 19870803), (0, 19870810), (0, 19870817), (0, 19870824), (0, 19870831), (0, 19870907), (0, 19870914), (0, 19870921), (0, 19870928), (0, 19871005), (0, 19871012), (0, 19871019), (0, 19871026), (0, 19871102), (0, 19871109), (0, 19871116), (0, 19871123), (0, 19871130), (0, 19871207), (0, 19871214), (0, 19871221), (0, 19871228), (0, 19880101), (0, 19880104), (0, 19880111), (0, 19880118), (0, 19880125), (0, 19880201), (0, 19880208), (0, 19880215), (0, 19880222), (0, 19880229), (0, 19880307), (0, 19880314), (0, 19880321), (0, 19880328), (0, 19880404), (0, 19880411), (0, 19880418), (0, 19880425), (0, 19880502), (0, 19880509), (0, 19880516), (0, 19880523), (0, 19880530), (0, 19880606), (0, 19880613), (0, 19880620), (0, 19880627), (0, 19880704), (0, 19880711), (0, 19880718), (0, 19880725), (0, 19880801), (0, 19880808), (0, 19880815), (0, 19880822), (0, 19880829), (0, 19880905), (0, 19880912), (0, 19880919), (0, 19880926), (0, 19881003), (0, 19881010), (0, 19881017), (0, 19881024), (0, 19881031), (0, 19881107), (0, 19881114), (29, 19881121), (29, 19881128), (29, 19881205), (29, 19881212), (29, 19881219), (29, 19881226), (28, 19890101), (29, 19890102), (29, 19890109), (29, 19890116), (29, 19890123), (29, 19890130), (29, 19890206), (0, 19890213), (0, 19890220), (0, 19890227), (0, 19890306), (29, 19890313), (29, 19890320), (0, 19890327), (0, 19890403), (29, 19890410), (29, 19890417), (29, 19890424), (29, 19890501), (29, 19890508), (29, 19890515), (29, 19890522), (29, 19890529), (29, 19890605), (29, 19890612), (29, 19890619), (29, 19890626), (29, 19890703), (29, 19890710), (29, 19890717), (29, 19890724), (29, 19890731), (29, 19890807), (29, 19890814), (29, 19890821), (29, 19890828), (29, 19890904), (29, 19890911), (29, 19890918), (29, 19890925), (29, 19891002), (29, 19891009), (29, 19891016), (29, 19891023), (29, 19891030), (29, 19891106), (29, 19891113), (29, 19891120), (29, 19891127), (29, 19891204), (29, 19891211), (29, 19891218), (29, 19891225), (28, 19900101), (29, 19900108), (29, 19900115), (29, 19900122), (29, 19900129), (29, 19900205), (29, 19900212), (29, 19900219), (29, 19900226), (29, 19900305), (29, 19900312), (29, 19900319), (29, 19900326), (29, 19900402), (29, 19900409), (29, 19900416), (29, 19900423), (29, 19900430), (29, 19900507), (29, 19900514), (29, 19900521), (29, 19900528), (29, 19900604), (29, 19900611), (30, 19900618), (30, 19900625), (30, 19900702), (30, 19900709), (30, 19900716), (30, 19900723), (30, 19900730), (30, 19900806), (30, 19900813), (30, 19900820), (30, 19900827), (30, 19900903), (30, 19900910), (30, 19900917), (30, 19900924), (30, 19901001), (30, 19901008), (30, 19901015), (30, 19901022), (30, 19901029), (30, 19901105), (30, 19901112), (30, 19901119), (30, 19901126), (30, 19901203), (30, 19901210), (30, 19901217), (30, 19901224), (30, 19901231), (29, 19910101), (30, 19910107), (30, 19910114), (30, 19910121), (30, 19910128), (30, 19910204), (30, 19910211), (30, 19910218), (30, 19910225), (30, 19910304), (29, 19910311), (29, 19910318), (29, 19910325), (29, 19910401), (29, 19910408), (29, 19910415), (29, 19910422), (29, 19910429), (29, 19910506), (29, 19910513), (29, 19910520), (29, 19910527), (29, 19910603), (29, 19910610), (29, 19910617), (29, 19910624), (29, 19910701), (30, 19910708), (29, 19910715), (29, 19910722), (29, 19910729), (29, 19910805), (29, 19910812), (29, 19910819), (30, 19910826), (30, 19910902), (30, 19910909), (30, 19910916), (30, 19910923), (30, 19910930), (31, 19911007), (31, 19911014), (31, 19911021), (31, 19911028), (44, 19911104), (44, 19911111), (44, 19911118), (44, 19911125), (31, 19911202), (44, 19911209), (45, 19911216), (45, 19911223), (45, 19911230), (44, 19920101), (45, 19920106), (45, 19920113), (45, 19920120), (45, 19920127), (45, 19920203), (29, 19920210), (45, 19920217), (45, 19920224), (45, 19920302), (45, 19920309), (45, 19920316), (45, 19920323), (45, 19920330), (45, 19920406), (45, 19920413), (45, 19920420), (45, 19920427), (45, 19920504), (45, 19920511), (45, 19920518), (45, 19920525), (45, 19920601), (45, 19920608), (45, 19920615), (45, 19920622), (45, 19920629), (45, 19920706), (46, 19920713), (46, 19920720), (45, 19920727), (73, 19920803), (73, 19920810), (73, 19920817), (119, 19920824), (90, 19920831), (90, 19920907), (90, 19920914), (90, 19920921), (90, 19920928), (62, 19921005), (62, 19921012), (62, 19921019), (62, 19921026), (62, 19921102), (62, 19921109), (62, 19921116), (62, 19921123), (62, 19921130), (62, 19921207), (62, 19921214), (62, 19921221), (45, 19921228), (44, 19930101), (45, 19930104), (45, 19930111), (45, 19930118), (45, 19930125), (45, 19930201), (32, 19930208), (45, 19930215), (45, 19930222), (45, 19930301), (45, 19930308), (45, 19930315), (45, 19930322), (45, 19930329), (45, 19930405), (62, 19930412), (62, 19930419), (62, 19930426), (62, 19930503), (62, 19930510), (44, 19930517), (44, 19930524), (44, 19930531), (44, 19930607), (44, 19930614), (44, 19930621), (44, 19930628), (62, 19930705), (62, 19930712), (62, 19930719), (62, 19930726), (43, 19930802), (43, 19930809), (43, 19930816), (43, 19930823), (43, 19930830), (43, 19930906), (43, 19930913), (76, 19930920), (75, 19930927), (58, 19931004), (58, 19931011), (58, 19931018), (58, 19931025), (58, 19931101), (58, 19931108), (75, 19931115), (75, 19931122), (75, 19931129), (75, 19931206), (75, 19931213), (75, 19931220), (75, 19931227), (73, 19940101), (75, 19940103), (75, 19940110), (75, 19940117), (75, 19940124), (62, 19940131), (63, 19940207), (63, 19940214), (63, 19940221), (62, 19940228), (62, 19940307), (62, 19940314), (62, 19940321), (61, 19940328), (62, 19940404), (61, 19940411), (44, 19940418), (57, 19940425), (57, 19940502), (57, 19940509), (57, 19940516), (57, 19940523), (57, 19940530), (65, 19940606), (65, 19940613), (65, 19940620), (65, 19940627), (67, 19940704), (67, 19940711), (60, 19940718), (60, 19940725), (60, 19940801), (60, 19940808), (60, 19940815), (60, 19940822), (60, 19940829), (60, 19940905), (68, 19940912), (68, 19940919), (69, 19940926), (69, 19941003), (69, 19941010), (69, 19941017), (59, 19941024), (59, 19941031), (69, 19941107), (69, 19941114), (69, 19941121), (69, 19941128), (69, 19941205), (69, 19941212), (69, 19941219), (69, 19941226), (69, 19950101), (69, 19950102), (69, 19950109), (69, 19950116), (69, 19950123), (69, 19950130), (69, 19950206), (69, 19950213), (69, 19950220), (69, 19950227), (69, 19950306), (69, 19950313), (69, 19950320), (69, 19950327), (69, 19950403), (69, 19950410), (69, 19950417), (69, 19950424), (69, 19950501), (69, 19950508), (69, 19950515), (69, 19950522), (69, 19950529), (69, 19950605), (96, 19950612), (96, 19950619), (96, 19950626), (96, 19950703), (97, 19950710), (118, 19950717), (118, 19950724), (118, 19950731), (118, 19950807), (118, 19950814), (131, 19950821), (131, 19950828), (131, 19950904), (131, 19950911), (131, 19950918), (131, 19950925), (131, 19951002), (131, 19951009), (131, 19951016), (131, 19951023), (131, 19951030), (131, 19951106), (138, 19951113), (138, 19951120), (138, 19951127), (138, 19951204), (138, 19951211), (138, 19951218), (138, 19951225), (138, 19960101), (125, 19960108), (125, 19960115), (125, 19960122), (125, 19960129), (125, 19960205), (125, 19960212), (125, 19960219), (147, 19960226), (147, 19960304), (147, 19960311), (147, 19960318), (147, 19960325), (147, 19960401), (147, 19960408), (147, 19960415), (147, 19960422), (147, 19960429), (147, 19960506), (147, 19960513), (147, 19960520), (147, 19960527), (147, 19960603), (147, 19960610), (147, 19960617), (147, 19960624), (147, 19960701), (171, 19960708), (171, 19960715), (171, 19960722), (171, 19960729), (171, 19960805), (171, 19960812), (171, 19960819), (171, 19960826), (171, 19960902), (194, 19960909), (172, 19960916), (172, 19960923), (172, 19960930), (172, 19961007), (175, 19961014), (175, 19961021), (191, 19961028), (191, 19961104), (213, 19961111), (213, 19961118), (213, 19961125), (213, 19961202), (213, 19961209), (213, 19961216), (185, 19961223), (185, 19961230), (185, 19970101), (185, 19970106), (185, 19970113), (185, 19970120), (209, 19970127), (209, 19970203), (209, 19970210), (209, 19970217), (223, 19970224), (223, 19970303), (223, 19970310), (223, 19970317), (223, 19970324), (223, 19970331), (223, 19970407), (225, 19970414), (225, 19970421), (225, 19970428), (225, 19970505), (225, 19970512), (225, 19970519), (225, 19970526), (225, 19970602), (225, 19970609), (225, 19970616), (225, 19970623), (225, 19970630), (164, 19970707), (257, 19970714), (257, 19970721), (257, 19970728), (273, 19970804), (273, 19970811), (273, 19970818), (273, 19970825), (273, 19970901), (273, 19970908), (273, 19970915), (273, 19970922), (273, 19970929), (273, 19971006), (299, 19971013), (314, 19971020), (314, 19971027), (337, 19971103), (337, 19971110), (363, 19971117), (363, 19971124), (363, 19971201), (394, 19971208), (394, 19971215), (394, 19971222), (394, 19971229), (394, 19980101), (394, 19980105), (394, 19980112), (394, 19980119), (394, 19980126), (394, 19980202), (394, 19980209), (394, 19980216), (394, 19980223), (394, 19980302), (394, 19980309), (394, 19980316), (394, 19980323), (426, 19980330), (426, 19980406), (459, 19980413), (459, 19980420), (459, 19980427), (459, 19980504), (459, 19980511), (459, 19980518), (459, 19980525), (459, 19980601), (543, 19980608), (569, 19980615), (590, 19980622), (590, 19980629), (633, 19980706), (633, 19980713), (633, 19980720), (634, 19980727), (634, 19980803), (634, 19980810), (631, 19980817), (631, 19980824), (660, 19980831), (660, 19980907), (663, 19980914), (663, 19980921), (683, 19980928), (688, 19981005), (688, 19981012), (696, 19981019), (693, 19981026), (693, 19981102), (692, 19981109), (692, 19981116), (692, 19981123), (709, 19981130), (703, 19981207), (703, 19981214), (703, 19981221), (703, 19981228), (703, 19990101), (722, 19990104), (722, 19990111), (722, 19990118), (722, 19990125), (728, 19990201), (723, 19990208), (723, 19990215), (723, 19990222), (723, 19990301), (723, 19990308), (728, 19990315), (728, 19990322), (728, 19990329), (728, 19990405), (728, 19990412), (728, 19990419), (752, 19990426), (761, 19990503), (761, 19990510), (777, 19990517), (777, 19990524), (777, 19990531), (804, 19990607), (804, 19990614), (804, 19990621), (804, 19990628), (804, 19990705), (829, 19990712), (829, 19990719), (829, 19990726), (829, 19990802), (870, 19990809), (873, 19990816), (853, 19990823), (861, 19990830), (861, 19990906), (879, 19990913), (879, 19990920), (899, 19990927), (927, 19991004), (941, 19991011), (964, 19991018), (941, 19991025), (941, 19991101), (941, 19991108), (941, 19991115), (941, 19991122), (966, 19991129), (966, 19991206), (989, 19991213), (989, 19991220), (989, 19991227), (989, 20000101), (989, 20000103), (989, 20000110), (989, 20000117), (989, 20000124), (1013, 20000131), (1038, 20000207), (1038, 20000214), (1038, 20000221), (1038, 20000228), (1065, 20000306), (1065, 20000313), (1065, 20000320), (1065, 20000327), (1065, 20000403), (1093, 20000410), (1093, 20000417), (1093, 20000424), (1122, 20000501), (1122, 20000508), (1106, 20000515), (1106, 20000522), (1106, 20000529), (1106, 20000605), (1160, 20000612), (1160, 20000619), (1188, 20000626), (1188, 20000703), (1204, 20000710), (1205, 20000717), (1212, 20000724), (1276, 20000731), (1276, 20000807), (1224, 20000814), (1224, 20000821), (1224, 20000828), (1224, 20000904), (1241, 20000911), (1265, 20000918), (1231, 20000925), (1223, 20001002), (1232, 20001009), (1253, 20001016), (1245, 20001023), (1247, 20001030), (1173, 20001106), (964, 20001113), (961, 20001120), (961, 20001127), (961, 20001204), (964, 20001211), (964, 20001218), (964, 20001225), (964, 20010101), (964, 20010108), (964, 20010115), (964, 20010122), (977, 20010129), (977, 20010205), (1004, 20010212), (1027, 20010219), (1027, 20010226), (1027, 20010305), (1027, 20010312), (1101, 20010319), (1101, 20010326), (914, 20010402), (930, 20010409), (952, 20010416), (961, 20010423), (988, 20010430), (1011, 20010507), (1011, 20010514), (1029, 20010521), (1067, 20010528), (1067, 20010604), (1094, 20010611), (1094, 20010618), (1073, 20010625), (1073, 20010702), (1113, 20010709), (1135, 20010716), (1149, 20010723), (1149, 20010730), (1175, 20010806), (1175, 20010813), (1175, 20010820), (1201, 20010827), (1201, 20010903), (1228, 20010910), (1231, 20010917), (1263, 20010924), (1287, 20011001), (1267, 20011008), (1288, 20011015), (1291, 20011022), (1312, 20011029), (1312, 20011105), (1412, 20011112), (1412, 20011119), (1437, 20011126), (1437, 20011203), (1437, 20011210), (1430, 20011217), (1430, 20011224), (1430, 20011231), (1430, 20020101), (1430, 20020107), (1430, 20020114), (1430, 20020121), (1430, 20020128), (1422, 20020204), (1422, 20020211), (1422, 20020218), (1424, 20020225), (1424, 20020304), (1424, 20020311), (1448, 20020318), (1448, 20020325), (1573, 20020401), (1574, 20020408), (1574, 20020415), (1574, 20020422), (1577, 20020429), (1730, 20020506), (1577, 20020513), (1577, 20020520), (1577, 20020527), (1577, 20020603), (1783, 20020610), (1803, 20020617), (1783, 20020624), (1783, 20020701), (1834, 20020708), (1835, 20020715), (1828, 20020722), (1853, 20020729), (1853, 20020805), (1925, 20020812), (1915, 20020819), (2111, 20020826), (2111, 20020902), (2451, 20020909), (2457, 20020916), (2462, 20020923), (2496, 20020930), (2526, 20021007), (2520, 20021014), (2505, 20021021), (2505, 20021028), (2498, 20021104), (2497, 20021111), (2497, 20021118), (2497, 20021125), (2497, 20021202), (2497, 20021209), (2497, 20021216), (2497, 20021223), (2497, 20021230), (2497, 20030101), (2497, 20030106), (2497, 20030113), (2497, 20030120), (2497, 20030127), (2517, 20030203), (2507, 20030210), (2490, 20030217), (2528, 20030224), (2549, 20030303), (2549, 20030310), (2571, 20030317), (2571, 20030324), (2614, 20030331), (2587, 20030407), (2587, 20030414), (2608, 20030421), (2719, 20030428), (2652, 20030505), (2671, 20030512), (2728, 20030519), (1860, 20030526), (2728, 20030602), (2753, 20030609), (2753, 20030616), (2731, 20030623), (2731, 20030630), (2730, 20030707), (2755, 20030714), (2759, 20030721), (2777, 20030728), (2732, 20030804), (2734, 20030811), (2755, 20030818), (2801, 20030825), (2801, 20030901), (2798, 20030908), (2847, 20030915), (2862, 20030922), (2930, 20030929), (2961, 20031006), (2966, 20031013), (3035, 20031020), (3020, 20031027), (3038, 20031103), (3052, 20031110), (3065, 20031117), (3092, 20031124), (3120, 20031201), (3190, 20031208), (3211, 20031215), (3211, 20031222), (3214, 20031229), (3214, 20040101), (3206, 20040105), (3206, 20040112), (3206, 20040119), (3206, 20040126), (3257, 20040202), (3265, 20040209), (3282, 20040216), (3282, 20040223), (3279, 20040301), (3286, 20040308), (3286, 20040315), (3286, 20040322), (3286, 20040329), (3277, 20040405), (3286, 20040412), (1489, 20040419), (3379, 20040426), (2613, 20040503), (1187, 20040510), (2361, 20040517), (2955, 20040524), (2535, 20040531), (3433, 20040607), (3456, 20040614), (3492, 20040621), (3492, 20040628), (3498, 20040705), (3516, 20040712), (3587, 20040719), (3592, 20040726), (3592, 20040802), (3645, 20040809), (3647, 20040816), (3661, 20040823), (3705, 20040830), (3705, 20040906), (3785, 20040913), (3831, 20040920), (3913, 20040927), (3957, 20041004), (3986, 20041011), (3987, 20041018), (3968, 20041025), (4011, 20041101), (4071, 20041108), (4124, 20041115), (4145, 20041122), (4147, 20041129), (4160, 20041206), (4160, 20041213), (4160, 20041220), (4160, 20041227), (4160, 20050101), (4160, 20050103), (4160, 20050110), (4160, 20050117), (4160, 20050124), (4198, 20050131), (4198, 20050207), (4211, 20050214), (4286, 20050221), (4286, 20050228), (4313, 20050307), (4313, 20050314), (4333, 20050321), (4333, 20050328), (4362, 20050404), (4371, 20050411), (4379, 20050418), (4379, 20050425), (4379, 20050502), (4470, 20050509), (4489, 20050516), (4522, 20050523), (4522, 20050530), (4682, 20050606), (4705, 20050613), (4727, 20050620), (4727, 20050627), (4792, 20050704), (4816, 20050711), (4847, 20050718), (4859, 20050725), (4926, 20050801), (4982, 20050808), (5020, 20050815), (5090, 20050822), (5100, 20050829), (5100, 20050905), (5187, 20050912), (5173, 20050919), (5175, 20050926), (5215, 20051003), (5249, 20051010), (5237, 20051017), (5257, 20051024), (5331, 20051031), (5362, 20051107), (5357, 20051114), (5391, 20051121), (5401, 20051128), (5452, 20051205), (5452, 20051212), (5452, 20051219), (5452, 20051226), (5452, 20060101), (5452, 20060102), (5452, 20060109), (5452, 20060116), (5452, 20060123), (5441, 20060130), (5425, 20060206), (5441, 20060213), (5478, 20060220), (5528, 20060227), (5548, 20060306), (5548, 20060313), (5559, 20060320), (5559, 20060327), (5626, 20060403), (5626, 20060410), (5644, 20060417), (5658, 20060424), (5656, 20060501), (5654, 20060508), (5683, 20060515), (5721, 20060522), (5798, 20060529), (5798, 20060605), (5862, 20060612), (5897, 20060619), (5944, 20060626), (5944, 20060703), (5983, 20060710), (6026, 20060717), (6065, 20060724), (6133, 20060731), (6151, 20060807), (6226, 20060814), (6289, 20060821), (6284, 20060828), (6284, 20060904), (6304, 20060911), (6347, 20060918), (6376, 20060925), (6436, 20061002), (6520, 20061009), (6629, 20061016), (6730, 20061023), (6808, 20061030), (6816, 20061106), (6807, 20061113), (6893, 20061120), (6896, 20061127), (6931, 20061204), (6953, 20061211), (6953, 20061218), (6953, 20061225), (6953, 20070101), (6926, 20070108), (6926, 20070115), (6926, 20070122), (6925, 20070129), (6925, 20070205), (6930, 20070212), (6942, 20070219), (6988, 20070226), (7017, 20070305), (7017, 20070312), (7058, 20070319), (7058, 20070326), (7139, 20070402), (7175, 20070409), (7197, 20070416), (7197, 20070423), (7197, 20070430), (7233, 20070507), (7317, 20070514), (7341, 20070521), (7365, 20070528), (7365, 20070604), (7448, 20070611), (7448, 20070618), (7473, 20070625), (7473, 20070702), (7495, 20070709), (7478, 20070716), (7470, 20070723), (7528, 20070730), (7522, 20070806), (7527, 20070813), (7503, 20070820), (7504, 20070827), (7504, 20070903), (7602, 20070910), (7643, 20070917), (7686, 20070924), (7697, 20071001), (7707, 20071008), (7687, 20071015), (7638, 20071022), (7711, 20071029), (7677, 20071105), (7664, 20071112), (7666, 20071119), (7674, 20071126), (7650, 20071203), (7659, 20071210), (7659, 20071217), (7682, 20071224), (7682, 20071231), (7682, 20080101), (7682, 20080107), (7711, 20080114), (7711, 20080121), (7691, 20080128), (7716, 20080204), (7743, 20080211), (7742, 20080218), (7731, 20080225), (7761, 20080303), (7790, 20080310), (7790, 20080317), (7832, 20080324), (7832, 20080331), (7873, 20080407), (7889, 20080414), (7917, 20080421), (7917, 20080428), (7929, 20080505), (8002, 20080512), (8022, 20080519), (8090, 20080526), (8090, 20080602), (8030, 20080609), (7970, 20080616), (7966, 20080623), (7966, 20080630), (8089, 20080707), (8113, 20080714), (8235, 20080721), (8280, 20080728), (8325, 20080804), (8372, 20080811), (8387, 20080818), (8417, 20080825), (8417, 20080901), (8527, 20080908), (8639, 20080915), (8690, 20080922), (8731, 20080929), (8762, 20081006), (8794, 20081013), (8836, 20081020), (8898, 20081027), (8956, 20081103), (8996, 20081110), (9003, 20081117), (9019, 20081124), (9050, 20081201), (9076, 20081208), (9077, 20081215), (9070, 20081222), (9070, 20081229), (9070, 20090101), (9064, 20090105), (9064, 20090112), (9064, 20090119), (9064, 20090126), (9087, 20090202), (9087, 20090209), (9059, 20090216), (9063, 20090223), (9063, 20090302), (9053, 20090309), (9053, 20090316), (9057, 20090323), (9057, 20090330), (9066, 20090406), (9121, 20090413), (9110, 20090420), (9111, 20090427), (9094, 20090504), (9143, 20090511), (9140, 20090518), (9153, 20090525), (9153, 20090601), (9203, 20090608), (9239, 20090615), (9255, 20090622), (9255, 20090629), (9310, 20090706), (9376, 20090713), (9474, 20090720), (9589, 20090727), (9611, 20090803), (9598, 20090810), (9642, 20090817), (9682, 20090824), (9682, 20090831), (9682, 20090907), (9808, 20090914), (9856, 20090921), (9918, 20090928), (9929, 20091005), (9925, 20091012), (10003, 20091019), (10025, 20091026), (10061, 20091102), (10116, 20091109), (10137, 20091116), (10204, 20091123), (10238, 20091130), (10221, 20091207), (10272, 20091214), (10272, 20091221), (10318, 20091228), (10318, 20100101), (10318, 20100104), (10320, 20100111), (10329, 20100118), (10329, 20100125), (10373, 20100201), (10372, 20100208), (10389, 20100215), (10404, 20100222), (10430, 20100301), (10442, 20100308), (10442, 20100315), (10412, 20100322), (10412, 20100329), (10481, 20100405), (10515, 20100412), (10543, 20100419), (10580, 20100426), (10590, 20100503), (10576, 20100510), (10593, 20100517), (10634, 20100524), (10634, 20100531), (10613, 20100607), (10630, 20100614), (10634, 20100621), (10634, 20100628), (10685, 20100705), (10726, 20100712), (10756, 20100719), (10817, 20100726), (10835, 20100802), (10937, 20100809), (10999, 20100816), (11026, 20100823), (11125, 20100830), (11125, 20100906), (11256, 20100913), (11290, 20100920), (11339, 20100927), (11460, 20101004), (11566, 20101011), (11594, 20101018), (11617, 20101025), (11687, 20101101), (11735, 20101108), (11814, 20101115), (11845, 20101122), (11877, 20101129), (11888, 20101206), (11907, 20101213), (11913, 20101220), (11904, 20101227), (11904, 20110101), (12060, 20110103), (12067, 20110110), (12094, 20110117), (12094, 20110124), (12143, 20110131), (12181, 20110207), (12204, 20110214), (12201, 20110221), (12254, 20110228), (12267, 20110307), (12267, 20110314), (12303, 20110321), (12303, 20110328), (12343, 20110404), (12398, 20110411), (12434, 20110418), (12422, 20110425), (12438, 20110502), (12482, 20110509), (12467, 20110516), (12522, 20110523), (12522, 20110530), (12659, 20110606), (12682, 20110613), (12686, 20110620), (12686, 20110627), (12867, 20110704), (12895, 20110711), (12927, 20110718), (13006, 20110725), (12999, 20110801), (13081, 20110808), (13129, 20110815), (13140, 20110822), (13174, 20110829), (13174, 20110905), (13299, 20110912), (13342, 20110919), (13382, 20110926), (13372, 20111003), (13382, 20111010), (13411, 20111017), (13443, 20111024), (13465, 20111031), (13443, 20111107), (13482, 20111114), (13518, 20111121), (13517, 20111128), (13542, 20111205), (13536, 20111212), (13565, 20111219), (13603, 20111226), (13603, 20120101), (13610, 20120102), (13628, 20120109), (13618, 20120116), (13618, 20120123), (13667, 20120130), (13666, 20120206), (13674, 20120213), (13719, 20120220), (13788, 20120227), (13791, 20120305), (13791, 20120312), (13818, 20120319), (13818, 20120326), (13881, 20120402), (13902, 20120409), (13938, 20120416), (13964, 20120423), (13983, 20120430), (14016, 20120507), (14015, 20120514), (14034, 20120521), (14087, 20120528), (14087, 20120604), (14072, 20120611), (14138, 20120618), (14172, 20120625), (14172, 20120702), (14180, 20120709), (14223, 20120716), (14250, 20120723), (14264, 20120730), (14286, 20120806), (14331, 20120813), (14361, 20120820), (14389, 20120827), (14389, 20120903), (14389, 20120910), (14402, 20120917), (14438, 20120924), (14472, 20121001), (14480, 20121008), (14513, 20121015), (14525, 20121022), (14547, 20121029), (14585, 20121105), (14621, 20121112), (14624, 20121119), (14612, 20121126), (14610, 20121203), (14639, 20121210), (14633, 20121217), (14649, 20121224), (13949, 20121231), (14648, 20130101), (13966, 20130107), (14667, 20130114), (14667, 20130121), (14667, 20130128), (14652, 20130204), (14651, 20130211), (14649, 20130218), (14554, 20130225), (14695, 20130304), (14727, 20130311), (13048, 20130318), (6790, 20130401), (14591, 20130408), (14449, 20130415), (14451, 20130422), (14462, 20130429), (14487, 20130506), (14516, 20130513), (14531, 20130520), (14545, 20130527), (14545, 20130603), (14553, 20130610), (14569, 20130617), (14650, 20130624), (14651, 20130708), (14689, 20130715), (14751, 20130722), (14766, 20130729), (14679, 20130805), (14599, 20130812), (14740, 20130819), (14714, 20130826), (14796, 20130902), (14820, 20130909), (14866, 20130916), (14878, 20130923), (14885, 20130930), (15028, 20131007), (15072, 20131014), (15025, 20131021), (15071, 20131028), (15098, 20131104), (15101, 20131111), (15151, 20131118), (15337, 20131125), (15334, 20131202), (15512, 20131209), (15540, 20131216), (15701, 20131223), (15708, 20131230), (15703, 20140106), (15637, 20140113), (8585, 20140120), (15646, 20140127), (15632, 20140203), (15637, 20140210), (8565, 20140217), (15659, 20140224), (15557, 20150302), (15578, 20150406), (15545, 20150413), (15568, 20150420), (15475, 20150427), (15710, 20150511), (15623, 20150518), (15741, 20150525), (15741, 20150608), (15810, 20150622), (15761, 20150803), (15776, 20150810), (15908, 20150824), (16184, 20150831), (15832, 20150914), (15800, 20150921), (16178, 20151005), (16191, 20151012), (16138, 20151019), (16293, 20151102), (4812, 20160111), (16518, 20160118), (16629, 20160201), (16586, 20160208), (16529, 20160215), (16454, 20160222), (16515, 20160229), (16517, 20160307), (16446, 20160411), (16454, 20160418), (16489, 20160425), (16388, 20160502), (16374, 20160509), (16351, 20160523), (16361, 20160606), (16314, 20160620), (16293, 20160627), (16325, 20160815), (16316, 20160919), (16305, 20160926), (16233, 20161010), (16349, 20161031), (16364, 20161107), (16249, 20161114), (16345, 20161121), (16294, 20161128), (16336, 20161205), (16387, 20161212), (16372, 20170102), (16406, 20170109), (16379, 20170116), (16305, 20170213), (16207, 20170220), (16111, 20170306), (16230, 20170320), (16270, 20170417), (16226, 20170424), (16303, 20170501), (16124, 20170508), (16204, 20170515), (16290, 20170522), (16649, 20170529), (16157, 20170612), (16189, 20170619), (16184, 20170626), (16597, 20170703), (15983, 20170717), (16138, 20170724), (16145, 20170731), (16147, 20170807), (16268, 20170814), (16279, 20170821), (16301, 20170828), (16161, 20170911)]",,1.0,
Find the id and name of the museum that has the most staff members?,"[museum.Museum_ID, museum.Name, museum.Num_of_Staff]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",EASY,"SELECT museum.Museum_ID, museum.Name FROM museum ORDER BY museum.Num_of_Staff DESC LIMIT 1;","SELECT museum_id ,  name FROM museum ORDER BY num_of_staff DESC LIMIT 1",museum_visit,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""museum.Museum_ID"" and ""museum.Name"" of the museum with the most staff members. 2. Condition Structure: No specific filtering condition is required since we are looking for the museum with the highest number of staff members. 3. Join Structure: No JOIN is required as all the necessary information is available in the ""museum"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""museum.Num_of_Staff"" to rank museums by the number of staff members. Apply LIMIT 1 to select the museum with the highest number of staff members.","[(1, 'Plaza Museum')]","[(1, 'Plaza Museum')]",,1.0,
Show different hometown of teachers and the number of teachers from each hometown.,"[teacher.Hometown, teacher.Teacher_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,"SELECT teacher.Hometown, COUNT(teacher.Teacher_ID) AS teacher_count FROM teacher GROUP BY teacher.Hometown;","SELECT Hometown ,  COUNT(*) FROM teacher GROUP BY Hometown",course_teach,"1. Sequential Structure: Begin with the SELECT clause to specify the hometown and the count of teachers from each hometown. 2. Aggregation Structure: Use COUNT to calculate the number of teachers from each hometown. 3. Grouping Structure: Use GROUP BY on ""teacher.Hometown"" to group the results by each hometown. 4. Join Structure: No JOIN is required since all necessary data is within the ""teacher"" table. 5. Condition Structure: No specific filtering condition is required as we want all hometowns and their respective teacher counts.","[('Blackrod Urban District', 1), ('Bolton County Borough', 1), ('Farnworth Municipal Borough', 1), ('Horwich Urban District', 1), ('Kearsley Urban District', 1), ('Little Lever Urban District', 1), ('Turton Urban District', 1)]","[('Blackrod Urban District', 1), ('Bolton County Borough', 1), ('Farnworth Municipal Borough', 1), ('Horwich Urban District', 1), ('Kearsley Urban District', 1), ('Little Lever Urban District', 1), ('Turton Urban District', 1)]",,1.0,
List the names of all winners who played in both 2013 and 2016.,"[players.player_id, players.first_name, players.last_name, matches.winner_id, matches.tourney_date, matches.winner_id = players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NESTED,"SELECT DISTINCT players.first_name, players.last_name FROM players JOIN matches ON players.player_id = matches.winner_id WHERE players.player_id IN ( SELECT winner_id FROM matches WHERE strftime('%Y', tourney_date) = '2013' ) AND players.player_id IN ( SELECT winner_id FROM matches WHERE strftime('%Y', tourney_date) = '2016' );",SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016,wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the first and last names of winners. Use the FROM clause to specify the players and matches tables. Apply a WHERE clause to filter for winners who played in both 2013 and 2016. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the winner_id appears in matches for both 2013 and 2016. This can be achieved by checking the tourney_date for the respective years. 3. Join Structure: Use an INNER JOIN between the players and matches tables based on the winner_id to connect player details with their match records. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",[],"[('Angelique Kerber',), ('Petra Kvitova',), ('Sara Errani',), ('Serena Williams',), ('Victoria Azarenka',)]",,0.0,
What are the names of the people who teach math courses?,"[teacher.Name,course.Course,course_arrange.Course_ID = course.Course_ID,course_arrange.Teacher_ID = teacher.Teacher_ID,math]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NON-NESTED,SELECT teacher.Name FROM course JOIN course_arrange ON course.Course_ID = course_arrange.Course_ID JOIN teacher ON course_arrange.Teacher_ID = teacher.Teacher_ID WHERE course.Course = 'math';,"SELECT T3.Name FROM course_arrange AS T1 JOIN course AS T2 ON T1.Course_ID  =  T2.Course_ID JOIN teacher AS T3 ON T1.Teacher_ID  =  T3.Teacher_ID WHERE T2.Course  =  ""Math""",course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Name"" of the people who teach math courses. 2. Condition Structure: Use a WHERE clause to filter for courses where the ""course.Course"" is 'math.' 3. Join Structure: Use JOINs to connect the ""course"" table with ""course_arrange"" on ""course.Course_ID"" and then connect ""course_arrange"" with ""teacher"" on ""course_arrange.Teacher_ID = teacher.Teacher_ID"" to link courses with their respective teachers. 4. Aggregation Structure: No aggregation is needed as we are retrieving individual teacher names.",[],"[('Kearsley Brown',), ('Vicente Carretero',)]",,0.0,
what are all the addresses including line 1 and line 2?,"[Addresses.line_1, Addresses.line_2]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT Addresses.line_1, Addresses.line_2 FROM Addresses;","SELECT line_1 ,  line_2 FROM addresses",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""line_1"" and ""line_2"" from the ""Addresses"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for all addresses. 3. Join Structure: No JOIN is required since all necessary data is within the ""Addresses"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields.","[('2294 Grant Square Apt. 235', 'Apt. 370'), ('3999 Aufderhar Ways Suite 593', 'Apt. 388'), ('67942 Carlotta Ferry Apt. 686', 'Apt. 583'), ('0144 Lamar Plaza Apt. 346', 'Suite 703'), ('858 Peggie Bypass Suite 212', 'Apt. 335'), ('16998 Mraz Lodge', 'Apt. 689'), ('193 Marlin Brook', 'Apt. 406'), ('202 Hessel Views Apt. 468', 'Apt. 305'), ('0643 Muller Vista', 'Suite 383'), ('7081 Eda Center', 'Suite 830'), ('9283 Schulist Falls Apt. 037', 'Suite 239'), ('979 Haag Shores Suite 656', 'Apt. 468'), ('492 Wilkinson Route', 'Suite 865'), ('186 Evan Motorway Apt. 409', 'Suite 079'), ('74046 Metz Walk Apt. 113', 'Suite 674')]","[('2294 Grant Square Apt. 235', 'Apt. 370'), ('3999 Aufderhar Ways Suite 593', 'Apt. 388'), ('67942 Carlotta Ferry Apt. 686', 'Apt. 583'), ('0144 Lamar Plaza Apt. 346', 'Suite 703'), ('858 Peggie Bypass Suite 212', 'Apt. 335'), ('16998 Mraz Lodge', 'Apt. 689'), ('193 Marlin Brook', 'Apt. 406'), ('202 Hessel Views Apt. 468', 'Apt. 305'), ('0643 Muller Vista', 'Suite 383'), ('7081 Eda Center', 'Suite 830'), ('9283 Schulist Falls Apt. 037', 'Suite 239'), ('979 Haag Shores Suite 656', 'Apt. 468'), ('492 Wilkinson Route', 'Suite 865'), ('186 Evan Motorway Apt. 409', 'Suite 079'), ('74046 Metz Walk Apt. 113', 'Suite 674')]",,1.0,
Find the number of matches happened in each year.,[matches.year],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT matches.year, COUNT(*) AS match_count FROM matches GROUP BY matches.year;","SELECT count(*) ,  YEAR FROM matches GROUP BY YEAR",wta_1,"1. Sequential Structure: Start with the SELECT clause to specify the year and the count of matches for each year. 2. Aggregation Structure: Use COUNT to calculate the number of matches for each year. 3. Grouping Structure: Use GROUP BY on ""matches.year"" to aggregate the results by year. 4. Join Structure: No JOIN is required since all necessary data is within the ""matches"" table.","[(2013, 12), (2016, 158), (2017, 108)]","[(12, 2013), (158, 2016), (108, 2017)]",,1.0,
How many courses in total are listed?,[Courses.course_id],"Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT COUNT(Courses.course_id) AS total_courses FROM Courses;,SELECT count(*) FROM Courses,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to count the total number of courses listed. 2. Condition Structure: No specific filtering condition is required as we want the total count of all courses. 3. Join Structure: No JOIN is necessary since all required data is available in the ""Courses"" table. 4. Aggregation Structure: Use COUNT on ""Courses.course_id"" to calculate the total number of courses.","[(15,)]","[(15,)]",,1.0,
What are the ids and names of the battles that led to more than 10 people killed in total.,"[battle.id, battle.name, death.killed, ship.lost_in_battle = battle.id, death.caused_by_ship_id = ship.id]","Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",NESTED,"SELECT battle.id, battle.name FROM battle JOIN ship ON ship.lost_in_battle = battle.id JOIN death ON death.caused_by_ship_id = ship.id GROUP BY battle.id, battle.name HAVING SUM(death.killed) > 10;","SELECT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle JOIN death AS T3 ON T2.id  =  T3.caused_by_ship_id GROUP BY T1.id HAVING sum(T3.killed)  >  10",battle_death,"1. Sequential Structure: Start with the SELECT clause to retrieve the ids and names of battles. Use the FROM clause to specify the battle table. Join it with the ship table to link battles with ships and then with the death table to link ships with casualties. Use GROUP BY to group records by battle id and name, and apply a HAVING clause to filter battles where the total number of people killed exceeds 10. 2. Condition Structure: Use the HAVING clause with SUM(death.killed) to filter battles where the total number of people killed is greater than 10. 3. Join Structure: Use INNER JOINs between the battle, ship, and death tables. The ship table is joined with the battle table using the lost_in_battle and id fields, and the death table is joined with the ship table using the caused_by_ship_id and id fields. 4. Aggregation Structure: Use SUM(death.killed) to calculate the total number of people killed for each battle.","[(5, 'Battle of Messinopolis'), (6, 'Battle of Boruy'), (8, 'Siege of Constantinople')]","[(5, 'Battle of Messinopolis'), (6, 'Battle of Boruy'), (8, 'Siege of Constantinople')]",,1.0,
How is the math course described?,"[Courses.course_description, Courses.course_name]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Courses.course_description FROM Courses WHERE Courses.course_name = 'Math';,SELECT course_description FROM Courses WHERE course_name  =  'math',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""course_description"" of the math course. 2. Condition Structure: Use a WHERE clause to filter for the course where ""Courses.course_name"" is 'Math'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Courses"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",[],"[('q',)]",,0.0,
How many visitors below age 30 are there?,"[visitor.ID, visitor.Age, visit.visitor_ID = visitor.ID]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",EASY,SELECT COUNT(visitor.ID) FROM visitor WHERE visitor.Age < 30;,SELECT count(*) FROM visitor WHERE age  <  30,museum_visit,"1. Sequential Structure: Start with the SELECT clause to count the number of visitors below age 30. 2. Condition Structure: Use a WHERE clause to filter visitors whose age is less than 30. 3. Join Structure: No JOIN is required since the relevant information is available in the ""visitor"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of visitors meeting the age condition.","[(3,)]","[(3,)]",,1.0,
"What are the id, name and membership level of visitors who have spent the largest amount of money in total in all museum tickets?","[visitor.ID, visitor.Name, visitor.Level_of_membership, visit.Total_spent, visit.visitor_ID = visitor.ID]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",NON-NESTED,"SELECT visitor.ID, visitor.Name, visitor.Level_of_membership FROM visit JOIN visitor ON visit.visitor_ID = visitor.ID GROUP BY visitor.ID ORDER BY SUM(visit.Total_spent) DESC LIMIT 1;","SELECT t2.visitor_id ,  t1.name ,  t1.Level_of_membership FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id GROUP BY t2.visitor_id ORDER BY sum(t2.Total_spent) DESC LIMIT 1",museum_visit,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""visitor.ID,"" ""visitor.Name,"" and ""visitor.Level_of_membership."" Use an aggregate function (SUM) on ""visit.Total_spent"" to calculate the total amount spent by each visitor. Use ORDER BY in descending order to rank visitors by their total spending and LIMIT 1 to get the visitor with the largest total spending. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all visitors. 3. Join Structure: Use an INNER JOIN between the ""visit"" and ""visitor"" tables on ""visit.visitor_ID = visitor.ID"" to associate each visitor with their spending records. 4. Aggregation Structure: Use SUM on ""visit.Total_spent"" to calculate the total spending for each visitor, then GROUP BY ""visitor.ID"" to group the results by each visitor.","[(3, 'Arjen Robben', 1)]","[('3', 'Arjen Robben', 1)]",,1.0,
What are the names of the teachers and how many courses do they teach?,"[teacher.Name, course_arrange.Teacher_ID, course_arrange.Course_ID = course.Course_ID, course_arrange.Teacher_ID = teacher.Teacher_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NON-NESTED,"SELECT teacher.Name, COUNT(course_arrange.Course_ID) AS Course_Count FROM teacher JOIN course_arrange ON course_arrange.Teacher_ID = teacher.Teacher_ID GROUP BY teacher.Name;","SELECT T2.Name ,  COUNT(*) FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name",course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the teacher's name and the count of courses they teach. Use COUNT on ""course_arrange.Course_ID"" to count the number of courses taught by each teacher. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""teacher"" and ""course_arrange"" tables based on ""course_arrange.Teacher_ID = teacher.Teacher_ID"" to associate each teacher with their courses. 4. Aggregation Structure: Use COUNT to aggregate the number of courses taught by each teacher and GROUP BY ""teacher.Name"" to group the results by teacher.","[('Anne Walker', 2), ('Gustaaf Deloor', 1), ('Kearsley Brown', 1), ('Lucy Wong', 1), ('Vicente Carretero', 1)]","[('Anne Walker', 2), ('Gustaaf Deloor', 1), ('Kearsley Brown', 1), ('Lucy Wong', 1), ('Vicente Carretero', 1)]",,1.0,
"What are the first names of all players, and their average rankings?","[players.first_name, rankings.ranking, rankings.player_id = players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT players.first_name, AVG(rankings.ranking) AS average_ranking FROM players JOIN rankings ON players.player_id = rankings.player_id GROUP BY players.first_name;","SELECT avg(ranking) ,  T1.first_name FROM players AS T1 JOIN rankings AS T2 ON T1.player_id  =  T2.player_id GROUP BY T1.first_name",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""players.first_name"" and the average of ""rankings.ranking."" Use an aggregate function (AVG) to calculate the average ranking. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""players"" and ""rankings"" tables on the ""player_id"" field to associate each player with their rankings. 4. Aggregation Structure: Use AVG to calculate the average ranking for each player and GROUP BY ""players.first_name"" to group the results by player first name.","[('Aastha', 1199.8235294117646), ('Abbi', 1110.0434782608695), ('Abbie', 808.4545454545455), ('Abigail', 387.66706161137444), ('Abiodun', 1039.6744186046512), ('Abir', 1228.75), ('Adeliya', 790.1538461538462), ('Adnya', 1122.4423076923076), ('Adriana', 619.6814159292036), ('Adrienn', 1213.1666666666667), ('Adrijana', 627.12), ('Adva', 1255.3333333333333), ('Afroditi', 1155.0392156862745), ('Agata', 960.6770186335403), ('Agata Jadwiga', 1082.3548387096773), ('Agne', 1231.5), ('Agnes', 391.3003629764065), ('Agnese', 694.0659898477157), ('Agni', 940.2125603864735), ('Agnieszka', 122.19587628865979), ('Agustina', 684.8497652582159), ('Agustina Elena', 1154.25), ('Ah', 1156.340425531915), ('Ahlam', 1248.72), ('Ahsha', 728.5), ('Ai', 890.8728448275862), ('Ai Wen', 912.1523178807947), ('Aida', 1110.3333333333333), ('Aiko', 284.8724727838258), ('Ailen', 1034.5833333333333), ('Aimee', 1200.2), ('Aina', 1164.95), ('Ainhoa', 943.7397959183673), ('Aishwarya', 1024.625), ('Ajla', 302.84831460674155), ('Akari', 704.9618138424821), ('Akgul', 215.25185185185185), ('Aki', 710.9617224880383), ('Akiho', 1145.8235294117646), ('Akiko', 493.98205383848455), ('Akilah', 772.8571428571429), ('Akvile', 1038.35), ('Alana', 1119.1639344262296), ('Alba', 843.7260273972603), ('Alberta', 343.22432701894314), ('Albina', 775.2734375), ('Aldana', 1185.7142857142858), ('Alejandra', 1067.019801980198), ('Aleksandra', 450.22998544395927), ('Aleksandrina', 578.07962529274), ('Alena', 820.4563492063492), ('Alessandra', 1123.4864864864865), ('Alessia', 1057.628205128205), ('Alessondra', 1145.1641791044776), ('Alexa', 383.9921465968586), ('Alexandra', 569.2647632558965), ('Alexandria', 945.625), ('Alexia', 718.5202702702703), ('Alexis', 604.15), ('Aliaksandra', 441.9846743295019), ('Alice', 710.3822682786414), ('Alice Andrada', 951.9764150943396), ('Alicia', 1105.1298701298701), ('Alicja', 855.813627254509), ('Alina', 925.0028776978418), ('Aliona', 611.35), ('Alisa', 453.01556420233464), ('Alison', 403.48784576697403), ('Alix', 822.3459915611814), ('Alize', 252.11485774499474), ('Alla', 217.85922330097088), ('Allie', 557.9232456140351), ('Almudena', 1157.8), ('Alona', 871.6926829268293), ('Alory Regina Elorriaga', 1181.6078431372548), ('Alyona', 496.9431818181818), ('Amanda', 650.6240276577355), ('Amandine', 747.4375), ('Amelie', 1011.3666666666667), ('Amina', 803.9764705882353), ('Aminat', 613.195652173913), ('Amira', 1075.8260869565217), ('Amra', 415.9078341013825), ('Amrita', 1209.4), ('Amy', 763.888198757764), ('An Sophie', 460.8932038834951), ('Ana', 396.2893280632411), ('Ana Bianca', 842.8446601941747), ('Ana Clara', 524.9192825112108), ('Ana Gabriela', 1084.7916666666667), ('Ana Luisa', 1243.4285714285713), ('Ana Paula', 1031.228855721393), ('Ana Sofia', 496.7156398104265), ('Ana Victoria', 961.2631578947369), ('Anabel', 144.3264367816092), ('Anaeve', 922.2255639097745), ('Anais', 482.26169844020797), ('Anamika', 859.3059701492538), ('Anastasia', 430.0872542522642), ('Anastasia Evgenyevna', 956.5754716981132), ('Anastasiia', 1245.75), ('Anastasija', 221.66153846153847), ('Anastasiya', 671.2584369449378), ('Anca', 1127.7368421052631), ('Anda', 1150.0), ('Andie K', 970.3620689655172), ('Andjela', 1063.4736842105262), ('Andra Maria', 1275.8235294117646), ('Andrea', 414.4332292750607), ('Andrea Renee', 878.3939393939394), ('Andreea', 956.0333333333333), ('Andreea Amalia', 801.84375), ('Andreea Roxana', 726.2657657657658), ('Andreja', 424.64521739130436), ('Andressa Cristina', 1184.0416666666667), ('Andrina', 1045.6666666666667), ('Aneta', 1152.0857142857142), ('Anett', 367.2274678111588), ('Anette', 969.8181818181819), ('Ange Oby', 1226.3333333333333), ('Angela', 1128.7272727272727), ('Angelica', 686.2234432234433), ('Angeliki', 1089.1603773584907), ('Angelina', 750.3207810320781), ('Angelique', 308.56833824975416), ('Anhelina', 432.6949152542373), ('Anhzelika', 850.9791666666666), ('Ani', 720.1431870669746), ('Anita', 947.472972972973), ('Anja', 725.3893333333333), ('Anke', 1228.388888888889), ('Ankita', 618.4714285714285), ('Ann', 907.4), ('Anna', 551.5557158312297), ('Anna Arina', 760.639175257732), ('Anna Giulia', 428.5496828752643), ('Anna Karolina', 345.51020408163265), ('Anna Katalina', 916.7115384615385), ('Anna Lena', 201.87700534759358), ('Anna Maria', 1070.3967391304348), ('Annalisa', 583.9347826086956), ('Anne', 248.74237737516572), ('Anne Liz', 762.7606382978723), ('Anne Marie', 1237.6363636363637), ('Anne Sophie', 1252.0), ('Annie', 1042.037037037037), ('Annika', 265.79487179487177), ('Anouk', 969.5882352941177), ('Antonela', 1051.7096774193549), ('Antonia', 589.1298076923077), ('Antonina', 1049.4655172413793), ('Anushka', 1037.0833333333333), ('Ao', 617.3333333333334), ('Apichaya', 1016.5714285714286), ('Arabela', 658.5074074074074), ('Arantxa', 279.23336006415394), ('Aranza', 490.4144736842105), ('Aravane', 200.97080291970804), ('Ariadna', 951.4146341463414), ('Arina', 560.6778190830236), ('Arina Gabriela', 1224.0), ('Arlinda', 1074.3333333333333), ('Arthi', 1281.8461538461538), ('Aryna', 349.54794520547944), ('Aselya', 1181.27868852459), ('Asha', 1151.95), ('Ashleigh', 331.3681818181818), ('Ashley', 638.88), ('Ashling', 823.0909090909091), ('Ashmitha', 1018.6637931034483), ('Ashvarya', 803.3904761904762), ('Asia', 453.43392070484583), ('Asiya', 790.46875), ('Assia', 1172.5531914893618), ('Astra', 829.5625), ('Astrid Wanja', 1086.45), ('Audrey', 591.2544731610338), ('Avgusta', 1208.4285714285713), ('Axana', 1064.0), ('Ayaka', 552.4653465346535), ('Ayan', 901.8717948717949), ('Ayano', 597.6981132075472), ('Ayla', 397.83561643835617), ('Aymet', 915.5932203389831), ('Ayu Fani', 479.5530612244898), ('Ayumi', 412.74466019417474), ('Azra', 556.2303370786517), ('Barbara', 763.8900651465798), ('Barbora', 252.6093155893536), ('Basak', 656.2932551319648), ('Beatrice', 785.0707482993197), ('Beatriz', 457.4050279329609), ('Beatriz Magdalena', 1253.4), ('Beatriz Maria', 971.2865853658536), ('Beauty', 1382.1538461538462), ('Belen', 1167.3368421052633), ('Belinda', 681.7736842105263), ('Benedetta', 705.4688346883469), ('Berfu', 625.013698630137), ('Bermet', 717.7932330827068), ('Bernarda', 541.273631840796), ('Bernice', 834.1005025125628), ('Berta', 1005.75), ('Bethanie', 146.59709379128137), ('Betina', 1229.5714285714287), ('Bhuvana', 878.0138888888889), ('Bianca', 653.2805383022775), ('Bianka', 696.952380952381), ('Bibiane', 550.1941544885177), ('Blair', 912.71875), ('Blanca', 904.6538461538462), ('Blessing', 1221.8333333333333), ('Boba', 1254.6341463414635), ('Bojana', 392.7313829787234), ('Borislava', 834.2066115702479), ('Boyan', 992.4222222222222), ('Brandy', 970.9846153846154), ('Breaunna', 872.0930232558139), ('Brenda', 211.01377118644066), ('Brianna', 854.3170731707318), ('Brienne', 917.0), ('Brindtha', 1126.3333333333333), ('Britt', 647.5205479452055), ('Brittany', 990.5210084033613), ('Brooke', 804.6277056277056), ('Brynn', 952.5619834710744), ('Bunyawi', 555.3384615384615), ('Busra', 1140.981981981982), ('Cagla', 311.87854251012146), ('Caitlin', 709.4247787610619), ('Camelia Elena', 803.7139479905437), ('Cameron', 1192.1818181818182), ('Camila', 539.7944621938232), ('Camila Vital', 1192.3783783783783), ('Camilla', 801.6850649350649), ('Camille', 1112.9450549450548), ('Cara', 236.07412398921832), ('Carina', 416.3666666666667), ('Carla', 411.70779777206513), ('Carlota', 1236.7777777777778), ('Carlotta', 1127.9338842975208), ('Carly', 318.69978858350953), ('Carmen', 890.6351351351351), ('Carmen Raluca', 842.1553398058253), ('Carol', 564.1434426229508), ('Carolin', 645.2279792746114), ('Carolina', 718.725321888412), ('Carolina Meligeni Rodrigues', 799.0650406504066), ('Caroline', 342.40130505709624), ('Caroline B', 1161.5675675675675), ('Carolyn', 1197.578947368421), ('Carson', 1020.6), ('Casey', 378.0163727959698), ('Catalina', 293.76942355889724), ('Catherine', 941.4724409448819), ('Catherine Cartan', 134.21917808219177), ('Caty', 744.0), ('Cecilia', 755.4649681528663), ('Cecilie Lundgaard', 1141.842105263158), ('Celine', 708.618398637138), ('Cemre', 1123.3855421686746), ('Chalena', 650.1367521367522), ('Chanel', 343.2835365853659), ('Chanelle', 215.6615811373093), ('Chang', 575.4626436781609), ('Chanikarn', 1281.8461538461538), ('Chantal', 609.90625), ('Chantelle', 1128.030303030303), ('Chaoyi', 1232.8), ('Charlene', 766.4794520547945), ('Charlotte', 927.7647058823529), ('Chayenne', 593.9759036144578), ('Chelsea', 1132.0), ('Chelsey', 719.3061224489796), ('Chen', 524.7444668008048), ('Chengyiyi', 789.2857142857143), ('Chi Chi', 464.1367781155015), ('Chi Fan', 1039.3902439024391), ('Chia Hsien', 950.8813559322034), ('Chia Jung', 359.3764705882353), ('Chiaki', 437.73858921161826), ('Chiara', 977.9640591966173), ('Chieh Yu', 533.9586374695864), ('Chihiro', 848.9908952959029), ('Chin Wei', 385.2651515151515), ('Chinami', 615.2230215827338), ('Ching Wen', 583.530303030303), ('Chiraz', 749.3582089552239), ('Chisa', 874.8181818181819), ('Chloe', 675.2445414847161), ('Chompoothip', 1112.1458333333333), ('Christie', 1112.875), ('Christina', 454.9920529801324), ('Christine', 841.4051724137931), ('Chun Mei', 692.390625), ('Chun Yan', 986.3944099378882), ('Cindy', 659.3055555555555), ('Claire', 443.45754716981133), ('Clara', 1190.7307692307693), ('Claudia', 826.2619047619048), ('Claudia Antonia', 967.2978723404256), ('Claudia Gianina', 996.2574257425742), ('Claudine', 383.6413199426112), ('Clelia', 823.6306306306307), ('Clemence', 875.9772727272727), ('Clementina Eugenia', 964.1224489795918), ('Clothilde', 620.4120171673819), ('Coco', 270.5896860986547), ('Colomba', 1165.093023255814), ('Conny', 390.0), ('Constance', 570.2723004694835), ('Constanza', 835.1132075471698), ('Constanze', 1245.3333333333333), ('Corina', 832.7818181818182), ('Corinna', 356.8219696969697), ('Cornelia', 757.2253521126761), ('Cory Ann', 406.5511363636364), ('Costanza', 1049.0), ('Cristiana', 554.5376344086021), ('Cristina', 643.616049382716), ('Cristina Andreea', 439.5747863247863), ('Cristina Madalina', 720.6428571428571), ('Csilla', 949.7944444444445), ('Cynthia', 998.7722772277227), ('Da Hye', 1010.3333333333334), ('Dabin', 920.1276595744681), ('Dagmara', 1159.1818181818182), ('Daiana', 720.7490039840637), ('Dajana', 1181.4736842105262), ('Dalia', 801.6933333333334), ('Dalila', 525.9552572706936), ('Dalma', 279.16438356164383), ('Damilola', 1493.0), ('Damini', 1242.0), ('Damira', 1198.3333333333333), ('Dan Ni', 994.4769230769231), ('Dana', 805.7028985507246), ('Daneika', 977.4539007092199), ('Danica', 380.609375), ('Daniela', 348.6364892881825), ('Daniella', 643.9216101694915), ('Danielle', 744.7453250222618), ('Danielle Rose', 434.68), ('Danijela', 1107.0919540229886), ('Danka', 302.83268482490274), ('Daphne', 1226.5454545454545), ('Daria', 629.6443987667009), ('Darija', 464.95631067961165), ('Dariya', 1132.1744186046512), ('Darya', 531.1829405162739), ('Dasha', 722.6986301369863), ('Dayana', 576.4307692307692), ('Dea', 550.9545454545455), ('Deborah', 764.6785714285714), ('Deeon', 1115.0851063829787), ('Dejana', 758.5342960288808), ('Demi', 983.4174757281553), ('Denisa', 419.1633466135458), ('Denise', 949.1239316239316), ('Denise Antonela', 1160.3125), ('Deniz', 551.5304659498208), ('Deria', 1123.6486486486488), ('Desirae', 863.7826086956521), ('Desiree', 1032.2666666666667), ('Despina', 665.686684073107), ('Despoina', 746.0962962962963), ('Destanee', 483.77464788732397), ('Dewi', 1154.2857142857142), ('Dhruthi', 615.1506849315068), ('Di', 736.1650485436893), ('Dia', 383.7832512315271), ('Diana', 654.3773657782928), ('Diana Maria', 1205.7692307692307), ('Dianne', 809.697247706422), ('Dijana', 669.2982456140351), ('Dilara', 1248.2), ('Dina', 1094.4583333333333), ('Dinah', 268.05945945945945), ('Doga Selen', 1234.6176470588234), ('Domenica', 803.8666666666667), ('Dominika', 171.71134020618555), ('Dominique', 1042.7843137254902), ('Donika', 1131.6333333333334), ('Donna', 223.50900900900902), ('Dorien', 1196.56), ('Doroteja', 520.9397993311037), ('Draginja', 913.7272727272727), ('Dunja', 929.0599369085173), ('Ebony', 1073.1752577319587), ('Eden', 1029.6888888888889), ('Edina', 211.67325428194994), ('Eduarda', 656.2851711026616), ('Eetee', 842.7045454545455), ('Ege', 1214.857142857143), ('Ekaterina', 471.8367290748899), ('Ekaterine', 553.9434782608696), ('Elaine', 1221.7931034482758), ('Eleanor', 1066.5343511450383), ('Elena', 324.3720930232558), ('Elena Gabriela', 392.44444444444446), ('Elena Teodora', 686.6470588235294), ('Eleni', 249.5244140625), ('Eleonora', 950.0277777777778), ('Eleonore', 1087.372340425532), ('Eliessa', 876.1730769230769), ('Elina', 421.6573033707865), ('Elisabeth', 888.2213114754098), ('Elise', 334.7118644067797), ('Elitsa', 418.39748953974896), ('Elixane', 579.5214723926381), ('Eliza', 978.2708333333334), ('Elizabeta', 1154.2714285714285), ('Elizabeth', 736.9747747747748), ('Elizabeth Anita Alexandria', 1006.2982456140351), ('Elizaveta', 489.5307517084282), ('Elizaveta Anna', 981.9814814814815), ('Elke', 1011.9433962264151), ('Ella', 1168.7967479674796), ('Ellen', 750.9460093896714), ('Ellie', 508.340206185567), ('Elodie', 1211.2333333333333), ('Elyne', 652.1984732824427), ('Ema', 819.3400503778338), ('Emelyn', 672.730407523511), ('Emi', 770.8472222222222), ('Emilia', 1232.0), ('Emiliana', 1022.9174311926605), ('Emilie', 705.4716981132076), ('Emilija', 1209.625), ('Emiliya', 1092.2771084337348), ('Emily', 585.093851132686), ('Emily J', 1041.948717948718), ('Emina', 682.0972222222222), ('Emma', 641.046992481203), ('Emma Christine', 1193.3529411764705), ('Emmanuelle', 943.7716535433071), ('En Pei', 1229.7333333333333), ('Ena', 980.3333333333334), ('Eri', 321.23595505617976), ('Erica', 788.0384615384615), ('Erika', 544.5041866028708), ('Erin', 942.7969696969697), ('Erina', 733.1351351351351), ('Esen', 1218.5652173913043), ('Estela', 966.0540540540541), ('Estelle', 617.4935251798561), ('Ester', 950.9090909090909), ('Estrella', 347.34943639291464), ('Etsuko', 781.3218390804598), ('Eudice Wong', 911.7241379310345), ('Eugenia', 1157.5), ('Eugenie', 477.62886597938143), ('Eugeniya', 620.6746411483253), ('Eva', 500.29483037156706), ('Eva Marie', 1083.8333333333333), ('Eveliina', 1023.8690476190476), ('Evelyn', 471.5439093484419), ('Evgenia', 414.66339869281046), ('Evgeniya', 442.0344827586207), ('Fang Ying', 612.0185185185185), ('Fangzhou', 406.9281767955801), ('Fanny', 569.1904761904761), ('Farah', 1106.3076923076924), ('Fatima', 673.7509157509157), ('Fatimah', 1070.9463414634147), ('Fatma', 648.2984054669704), ('Fatyha', 1015.5), ('Federica', 722.7286493034525), ('Federica Joe', 1204.7272727272727), ('Fernanda', 647.922077922078), ('Ferny', 1187.0384615384614), ('Fiona', 853.3908045977012), ('Flavia', 376.47888446215137), ('Florencia', 451.5810397553517), ('Frances', 999.2), ('Francesca', 570.534951862704), ('Francisca', 903.1666666666666), ('Francoise', 437.05298013245033), ('Franziska', 949.6575342465753), ('Frederikke', 1244.3333333333333), ('Freya', 544.1627906976744), ('Gabriela', 696.7697332607512), ('Gabriela Nicole', 994.0612244897959), ('Gabriella', 792.5), ('Gabrielle Faith', 985.7211538461538), ('Gaelle', 1052.8314606741574), ('Gaia', 759.5352697095435), ('Gail', 526.2644836272041), ('Galina', 305.19563522992985), ('Ganna', 606.7211740041929), ('Garbine', 229.3774193548387), ('Gebriela', 1152.142857142857), ('Genevieve', 772.2857142857143), ('Georgia', 533.5940594059406), ('Georgia Andreea', 763.1014492753624), ('Georgiana', 1153.9166666666667), ('Georgina', 396.225), ('Ghislaine', 1150.6607142857142), ('Giada', 813.1351351351351), ('Gioia', 567.8518518518518), ('Giorgia', 960.4941860465116), ('Giorgie', 1226.5), ('Giovanna', 1197.0), ('Giulia', 693.6215943491422), ('Giuliana', 584.359375), ('Gloria', 794.7118644067797), ('Gozal', 716.3150684931506), ('Grace', 454.06233062330625), ('Gracia', 783.8288043478261), ('Greetje', 547.277108433735), ('Greta', 296.8219584569733), ('Guadalupe', 797.383606557377), ('Guillermina', 1027.0), ('Guiomar', 957.9512195121952), ('Gulben', 1168.3396226415093), ('Gulchekhra', 1196.0), ('Gulnaz', 1236.6153846153845), ('Guzal', 995.4074074074074), ('Gyulnara', 1087.6216216216217), ('Habiba', 1051.623188405797), ('Hae Sung', 844.3856812933026), ('Haine', 1179.4153846153847), ('Hana', 1110.5376344086021), ('Hanna', 957.2), ('Hanyu', 543.968253968254), ('Hao Chen', 680.1050228310502), ('Hao Ching', 1153.936507936508), ('Harmony', 574.8723404255319), ('Harriet', 694.341935483871), ('Haruka', 774.6837606837607), ('Haruna', 512.1515151515151), ('Hayley', 914.5321100917431), ('Hazal', 1214.7692307692307), ('Heather', 167.50632911392404), ('Heidi', 417.44323483670297), ('Helen', 1019.4107142857143), ('Helene', 696.4752475247525), ('Hikari', 1095.1176470588234), ('Hilda', 673.6635071090047), ('Himari', 1219.0), ('Hiroko', 534.890243902439), ('Hirono', 860.8104265402843), ('Ho Ching', 925.9865771812081), ('Hollie', 1185.75), ('Hongrui', 914.8607594936709), ('Hortencia', 1251.1333333333334), ('Hsin Yuan', 1107.7142857142858), ('Hua Chen', 726.1737089201878), ('Huijie', 1118.904761904762), ('Hulya', 888.0055096418732), ('Hye Min', 1020.28125), ('Hyojung', 1069.3208955223881), ('Hyun Hui', 729.0671936758894), ('I Hsuan', 1038.6911764705883), ('Iana', 1085.581818181818), ('Ida', 962.5), ('Idia', 1232.2), ('Iga', 705.5625), ('Ilay', 1135.5), ('Ilka', 868.2191780821918), ('Ilona', 452.625), ('Ilze', 847.0941176470589), ('Imane Maelle', 845.375), ('Ina', 1165.5573770491803), ('Inci', 1069.0925925925926), ('India', 954.046875), ('Indire', 627.7027027027027), ('Indy', 485.9559748427673), ('Ineke', 919.6147540983607), ('Ines', 687.0229885057471), ('Inger', 1039.0), ('Ingrid', 766.2549019607843), ('Ingrid Alexandra', 869.3571428571429), ('Ingrid Esperanza', 748.6622691292876), ('Intissar', 1192.5454545454545), ('Ioana', 980.2232142857143), ('Ioana Diana', 482.43243243243245), ('Ioana Loredana', 646.0441176470588), ('Ionela Andreea', 799.0552486187845), ('Ipek', 655.7828348504552), ('Irena', 288.74423480083857), ('Irene', 579.2153846153847), ('Irina', 436.84339509862525), ('Irina Camelia', 285.84388185654007), ('Irina Maria', 578.1381578947369), ('Iris', 866.1075949367089), ('Iryna', 489.5294964028777), ('Isabel', 724.9178743961353), ('Isabela', 1114.99375), ('Isabella', 566.7873931623932), ('Isabelle', 781.6993464052288), ('Iulia Maria', 1170.9411764705883), ('Iva', 732.7386018237082), ('Ivana', 439.81414868105514), ('Ivania', 871.109375), ('Ivanka', 1079.05), ('Iveta', 117.95684523809524), ('Ivette', 1136.8535031847134), ('Ivone', 872.0), ('Ivonne', 591.3809523809524), ('Jacqueline', 624.6089494163424), ('Jada', 909.2), ('Jade', 739.04802259887), ('Jaeda', 760.4920634920635), ('Jaimee', 562.8450704225352), ('Jaimy Gayle', 1243.875), ('Jainy', 1037.5274725274726), ('Jamie', 402.36756756756756), ('Jamilya', 1247.3333333333333), ('Jan', 592.5990783410139), ('Jana', 406.6258503401361), ('Janette', 240.5306603773585), ('Janina', 699.7864583333334), ('Janja', 1262.5416666666667), ('Janneke', 861.5102040816327), ('Jaqueline Adina', 748.7238095238096), ('Jara', 1121.767857142857), ('Jarmila', 149.46360759493672), ('Jasmin', 633.027027027027), ('Jasmina', 642.1811989100818), ('Jasmine', 437.86915887850466), ('Jasmine Amber', 1117.64), ('Jawairiah', 1070.5648854961833), ('Jazmin', 1035.46), ('Jazzamay', 983.1290322580645), ('Jeannine', 767.7730496453901), ('Jelena', 348.19338235294117), ('Jennifer', 556.7936681222708), ('Jenny', 902.1470588235294), ('Jesika', 501.5860215053763), ('Jessica', 655.7464059804486), ('Jessika', 818.2043795620438), ('Jessy', 967.6708860759494), ('Ji Hee', 823.9789029535865), ('Ji Young', 833.5061082024433), ('Jia', 1169.6923076923076), ('Jia Jing', 682.961038961039), ('Jia Qi', 529.7777777777778), ('Jiahui', 794.4931506849315), ('Jiakang', 1230.6), ('Jiatian', 1232.032258064516), ('Jiaxi', 578.5), ('Jiaxue', 1161.0), ('Jie', 114.05571428571429), ('Jil Belen', 501.0619469026549), ('Jil Nora', 1116.4190476190477), ('Jill', 121.9579326923077), ('Jillian', 721.14), ('Jin', 1267.0), ('Jin A', 492.8915187376726), ('Jin Ju', 1035.6470588235295), ('Jing Jing', 369.1620469083156), ('Joana', 863.3225806451613), ('Joanna', 931.025641025641), ('Joanne', 1227.8), ('Jodie Anna', 925.4230769230769), ('Johana', 1111.8333333333333), ('Johanna', 310.3405299313052), ('Jordana', 1022.6198347107438), ('Josepha', 924.9325842696629), ('Josephine', 684.4892086330935), ('Josie', 993.2105263157895), ('Jovana', 601.9846625766871), ('Ju Eun', 812.6), ('Judith', 1224.0), ('Jule', 1243.904761904762), ('Julia', 576.9173467252564), ('Julia Mansano', 1024.6666666666667), ('Juliana', 1110.0816326530612), ('Juliana Rocha', 1175.7666666666667), ('Julie', 512.3787128712871), ('Julieta Lara', 707.1467889908257), ('Julita', 1019.9411764705883), ('Julyette Maria Josephine', 732.1666666666666), ('June', 1189.0), ('Junri', 262.30884808013354), ('Justina', 1212.9166666666667), ('Justine', 521.5358361774744), ('Justyna', 585.8517745302714), ('Kady', 1055.020202020202), ('Kai Chen', 272.08855291576674), ('Kai Lin', 522.6561403508772), ('Kaia', 127.06775067750678), ('Kaitlin', 901.3333333333334), ('Kaitlyn', 756.2549019607843), ('Kaja', 633.5454545454545), ('Kajsa', 661.9589041095891), ('Kamila', 568.2547169811321), ('Kamilla', 1162.8301886792453), ('Kamonwan', 765.1395348837209), ('Kana', 924.2782608695652), ('Kanae', 635.346516007533), ('Kanako', 1105.3125), ('Kanami', 799.9940828402367), ('Kanika', 962.8536585365854), ('Kaori', 871.0790513833992), ('Karen', 674.9672514619883), ('Kariann', 1068.9166666666667), ('Karin', 472.338003502627), ('Karina', 883.6090909090909), ('Karina Ildor', 696.9606060606061), ('Karina Kristina', 1062.795918367347), ('Karine', 868.8904109589041), ('Karis', 1001.0679611650486), ('Karla', 807.616), ('Karman', 652.917808219178), ('Karola Patricia', 928.3333333333334), ('Karolayne', 1077.8095238095239), ('Karolina', 586.9412296564195), ('Karoline', 873.6229508196722), ('Karyn', 903.5769230769231), ('Kassandra', 927.0350877192982), ('Katalin', 331.93949394939494), ('Katarina', 401.0998263888889), ('Katarzyna', 459.29286608260327), ('Kate', 1117.7142857142858), ('Katerina', 491.8507295173962), ('Kateryna', 294.33209990749305), ('Katharina', 680.677700348432), ('Katharine', 882.1071428571429), ('Katherine', 836.6804511278195), ('Katherine Gabriela', 910.396694214876), ('Kathinka', 415.7), ('Kathrin', 291.4792817679558), ('Katie', 620.9404580152672), ('Katrine Isabel', 1111.08), ('Katy', 492.6608695652174), ('Katya', 1050.7), ('Katyarina', 1010.1818181818181), ('Kayla', 583.1686746987951), ('Kaylah', 1163.3478260869565), ('Kazusa', 772.2402912621359), ('Kei', 1003.1212121212121), ('Kelia', 1114.9433962264152), ('Kelly', 804.873831775701), ('Kelly S', 312.7584269662921), ('Kelsey', 1012.325), ('Kennedy', 807.7222222222222), ('Keren', 643.422641509434), ('Keri', 1018.6534653465346), ('Kerstin', 1020.4271844660194), ('Khristina', 978.0229885057471), ('Ki Ryang', 1164.090909090909), ('Kiki', 287.71625344352617), ('Kim', 687.3120567375887), ('Kim Alice', 762.4081632653061), ('Kimberley', 846.9154228855722), ('Kimberly', 618.6923076923077), ('Kimika', 1097.219512195122), ('Kimiko', 95.03465982028241), ('Kinnie', 606.1467576791808), ('Kirsten', 308.64912280701753), ('Kirsten Andrea', 1035.0384615384614), ('Klaartje', 576.9), ('Klara', 235.31431431431432), ('Klaudia', 780.7905027932961), ('Komola', 826.0238095238095), ('Korina', 567.0507399577167), ('Kotomi', 844.7460317460317), ('Krista', 522.984693877551), ('Kristie', 445.18918918918916), ('Kristina', 343.25546975546973), ('Kristina N', 1060.5633802816901), ('Kristy', 837.7730496453901), ('Kristyna', 443.8467908902692), ('Ksenia', 482.36648501362396), ('Kseniia', 990.6), ('Ksenija', 975.6271186440678), ('Kumiko', 488.76107382550333), ('Kurumi', 165.96132596685084), ('Kveta', 159.62397820163488), ('Kwan Yau', 1070.0377358490566), ('Kyle', 887.502487562189), ('Kylie', 798.3181818181819), ('Kyoka', 348.54794520547944), ('Kyra', 443.76148409893995), ('Kyung Mi', 533.433770014556), ('Laetitia', 677.4458598726114), ('Laili', 996.8148148148148), ('Lamis', 1062.3666666666666), ('Lara', 643.6939163498099), ('Larikah', 1054.9019607843138), ('Laura', 504.4145867098865), ('Laura D', 910.5714285714286), ('Laura Ioana', 516.1982942430703), ('Laura Sofia', 1198.1538461538462), ('Lauren', 484.9442231075697), ('Lauryn', 1107.0882352941176), ('Lavinia', 612.736), ('Laylo', 1226.076923076923), ('Layne', 1184.0), ('Lea', 858.4107142857143), ('Leah', 1179.6216216216217), ('Lee', 908.156862745098), ('Lena', 594.9436936936937), ('Lena Marie', 657.8934169278997), ('Lenka', 451.33577981651376), ('Leolia', 773.5666666666667), ('Leonie', 825.972972972973), ('Lesedi Sheya', 887.4545454545455), ('Lesia', 205.17590361445784), ('Lesley', 514.7174515235457), ('Leslie', 1180.5454545454545), ('Leticia', 481.3229166666667), ('Leticia Garcia', 1072.4), ('Leylah Annie', 1030.5), ('Li', 988.7425149700599), ('Liana Gabriela', 387.87113402061857), ('Libby', 899.9150326797386), ('Libi', 1035.327868852459), ('Lidia', 1147.8529411764705), ('Lidziya', 797.2128378378378), ('Liezel', 284.8326771653543), ('Liga', 567.9464544138929), ('Lilla', 722.5087719298245), ('Lin', 497.42124542124543), ('Lina', 574.9808362369338), ('Linda', 929.4398496240601), ('Lindsay', 275.6055900621118), ('Lindsey', 986.82), ('Ling', 418.81925343811395), ('Liniques', 1184.7222222222222), ('Linnea', 959.6981132075472), ('Lisa', 356.0105210420842), ('Lisa Maria', 758.06), ('Lisa Marie', 996.0408163265306), ('Lisanne', 673.6507936507936), ('Liubov', 887.2875), ('Livia', 1179.875), ('Liz Tatiane', 870.9007633587786), ('Lizaveta', 1120.5652173913043), ('Lizette', 666.1496062992126), ('Lorenza', 1231.2727272727273), ('Lorraine M', 972.75), ('Lou', 680.1724137931035), ('Loudmilla', 1220.0), ('Louisa', 380.5308641975309), ('Louise', 1070.1025641025642), ('Lourdes', 188.06095041322314), ('Lu', 907.3557312252965), ('Luca', 859.8644067796611), ('Lucia', 845.740638002774), ('Luciana', 885.7495107632094), ('Lucie', 322.62611607142856), ('Lucrezia', 845.986301369863), ('Lucy', 756.3141592920354), ('Ludmila', 846.2727272727273), ('Ludmilla', 787.5416666666666), ('Luisa', 981.7517730496454), ('Luisa Marie', 820.59375), ('Luksika', 284.22813688212926), ('Lulu', 1098.2888888888888), ('Luna', 1139.0), ('Lusine', 974.2702702702703), ('Lutfiye', 1190.0629921259842), ('Lyann', 982.6666666666666), ('Lynn', 952.4411764705883), ('Lyudmyla', 382.82479784366575), ('Macall', 607.3360995850622), ('Macarena', 692.1515151515151), ('Madalina', 324.63613231552165), ('Maddison', 748.0), ('Madeleine', 1028.0365853658536), ('Madeline', 1217.469387755102), ('Madina', 1203.5), ('Madison', 290.64452214452217), ('Madrie', 958.0955414012739), ('Maegan', 787.0), ('Mafalda', 1139.7), ('Maftuna', 1173.75), ('Magali', 734.0), ('Magalie', 1036.1214953271028), ('Magda', 300.3974358974359), ('Magdalena', 443.6296006264683), ('Magy', 1092.7621951219512), ('Mahak', 875.0), ('Mahitha', 1007.15), ('Mai', 687.25), ('Maia', 745.433962264151), ('Maia A', 1206.6666666666667), ('Maiko', 438.4245810055866), ('Maileen', 1152.888888888889), ('Mailen', 410.8463541666667), ('Maja', 896.7413793103449), ('Makiho', 784.8009049773756), ('Makoto', 516.6615384615385), ('Malene', 999.15625), ('Malika', 1004.7428571428571), ('Malin', 825.039603960396), ('Mallaurie', 1031.5342465753424), ('Mallory', 143.48235294117646), ('Malou', 947.3333333333334), ('Mami', 1153.590909090909), ('Man Ying Maggie', 1202.2692307692307), ('Mana', 689.891129032258), ('Mananchaya', 1230.6), ('Manca', 838.1780821917808), ('Mandy', 361.0), ('Manisha', 897.0974358974358), ('Manon', 622.7673469387755), ('Manya', 1181.3548387096773), ('Mara', 908.3962264150944), ('Marcela', 774.64), ('Marcela Guimaraes', 1143.7957746478874), ('Marcelina', 1247.3636363636363), ('Marcella', 657.0171919770773), ('Margalita', 325.5912596401028), ('Margarida', 987.6739130434783), ('Margarita', 611.4060995184591), ('Margaux', 1051.1224489795918), ('Margot', 753.8346456692914), ('Mari', 526.3698630136986), ('Maria', 426.6002565198803), ('Maria Agustina', 1190.0833333333333), ('Maria Andrea', 1072.9591836734694), ('Maria Camila', 1188.5277777777778), ('Maria Constanza De Las Mercedes', 861.5050505050505), ('Maria Del Rosario', 1119.4897959183672), ('Maria Elena', 194.2392065344224), ('Maria Fernanda', 443.0228531855956), ('Maria Jesus', 1170.1830985915492), ('Maria Joao', 486.6092544987147), ('Maria Jose', 306.1794310722101), ('Maria Lourdes', 918.0769230769231), ('Maria Paulina', 1047.98224852071), ('Maria Teresa', 359.81081081081084), ('Mariam', 662.1182795698925), ('Mariana', 556.0428051001821), ('Marianna', 730.3831168831168), ('Marianne', 993.175925925926), ('Mariaryeni', 1085.4242424242425), ('Marie', 695.574074074074), ('Marie Eve', 300.56296296296296), ('Mariia', 1148.9166666666667), ('Marija', 544.2636655948553), ('Marijana', 1215.0), ('Marina', 532.6881807180315), ('Marine', 774.5654761904761), ('Marion', 279.78655282817505), ('Mariona', 1163.0), ('Marisa', 1067.3413173652696), ('Mariya', 281.871335504886), ('Marketa', 353.44444444444446), ('Marlies', 946.8934426229508), ('Marrit', 783.1711711711712), ('Marta', 419.32988047808766), ('Marta Huqi', 851.1224489795918), ('Martha', 1056.0588235294117), ('Martina', 751.8679119412942), ('Mary', 869.1666666666666), ('Mary Ann', 1188.7096774193549), ('Maryna', 323.86176470588236), ('Masa', 355.7223168654174), ('Mathilde', 437.11396648044695), ('Matilda', 799.1875), ('Maud', 1013.4761904761905), ('Maureen', 1070.21875), ('Maurien', 1121.0869565217392), ('Maxine', 973.8717948717949), ('May', 1084.0294117647059), ('Maya', 732.4260679079956), ('Mayar', 891.6309523809524), ('Mayo', 407.029702970297), ('Mayya', 619.9064748201439), ('Megan', 736.4809523809524), ('Megumi', 1025.0), ('Mei Xu', 1031.6), ('Meiling', 812.85), ('Meiqi', 1029.1666666666667), ('Melanie', 372.32502965599053), ('Melany Solange', 1039.8333333333333), ('Melina', 1017.2560553633218), ('Melinda', 169.13578500707214), ('Melis', 634.7950310559006), ('Melisa', 993.1351351351351), ('Melissa', 1154.093023255814), ('Melissa Ishuan', 1104.357142857143), ('Meng Ning', 1035.95), ('Mercedes', 1213.2142857142858), ('Merel', 900.75), ('Meritxell', 1182.9107142857142), ('Mervana', 337.5292682926829), ('Mi', 554.3953934740883), ('Mi Jeong', 1071.3076923076924), ('Mi Rae', 992.7225433526012), ('Mi Zhuoma', 999.375), ('Mia Nicole', 987.504761904762), ('Micaela', 1332.0737704918033), ('Michaela', 676.90589198036), ('Michaella', 185.3469387755102), ('Michela', 1228.9285714285713), ('Michele Alexandra', 946.8846153846154), ('Michelle', 280.79959100204496), ('Michika', 718.047619047619), ('Mihaela', 376.7356115107914), ('Mihaela Lorena', 1223.4), ('Miharu', 523.2788844621514), ('Mihika', 1064.142857142857), ('Mihoki', 1110.4411764705883), ('Miki', 586.2250489236791), ('Mila', 1201.16), ('Milagros', 1234.2857142857142), ('Milana', 626.441935483871), ('Milena', 1114.4074074074074), ('Milica', 1221.904761904762), ('Min', 866.0693069306931), ('Min Hwa', 819.8425531914894), ('Minami', 1238.0625), ('Mira', 788.2622950819672), ('Mirabelle', 721.1643835616438), ('Miranda', 1169.4864864864865), ('Miriam', 912.120218579235), ('Miriam Bianca', 628.075), ('Miriana', 950.6263736263736), ('Mirjam', 843.6428571428571), ('Mirjana', 186.76587795765877), ('Misa', 617.0379241516966), ('Misaki', 208.95263157894738), ('Mitsumi', 1121.04), ('Miyabi', 447.93283582089555), ('Miyu', 594.9036697247707), ('Mizuno', 593.1506849315068), ('Molly', 1029.0), ('Momoko', 772.6981132075472), ('Mona', 273.57517899761336), ('Monica', 210.0846394984326), ('Monika', 980.575), ('Monique', 462.4270462633452), ('Montserrat', 541.952380952381), ('Morgane', 880.6527777777778), ('Moulika', 1243.4), ('Mouna', 1258.5), ('Moyuka', 1198.25), ('Muazzez', 1227.0), ('Muge', 1186.9444444444443), ('Myrtille', 485.40168539325845), ('Na', 82.13112391930835), ('Na Lae', 608.7791798107255), ('Na Ri', 573.5197368421053), ('Nadezda', 868.6521739130435), ('Nadia', 407.5463976945245), ('Nadiya', 637.4607407407408), ('Nadja', 631.8181818181819), ('Nagi', 828.0675675675676), ('Naiktha', 767.4963503649635), ('Naima', 930.7027027027027), ('Nam Yeon', 878.6666666666666), ('Nan Nan', 890.4455445544554), ('Nanuli', 542.7168141592921), ('Nao', 313.45625), ('Naoko', 1180.3828125), ('Naomi', 483.97225572979494), ('Napatsakorn', 929.4388489208633), ('Nastassia', 1138.9166666666667), ('Nastassja', 554.5290322580645), ('Nastja', 593.1772853185596), ('Natalia', 720.132932166302), ('Natalie', 577.9677419354839), ('Natalija', 634.3620689655172), ('Nataliya', 1247.909090909091), ('Natasa', 666.2853403141361), ('Natasha', 883.0777142857143), ('Natela', 566.4943396226415), ('Natella', 962.0188679245283), ('Nathalia', 543.031185031185), ('Nathaly', 617.4615384615385), ('Natia', 929.6928104575163), ('Natsumi', 547.7037037037037), ('Nattawadee', 1177.622641509434), ('Naz', 1087.3823529411766), ('Nazari', 825.7291666666666), ('Neda', 745.421052631579), ('Nelise', 1164.107142857143), ('Nermeen', 1069.15), ('Nevena', 1031.0), ('Nicha', 515.3191489361702), ('Nicky', 843.9007633587786), ('Nicola', 753.2253164556962), ('Nicole', 499.4127634660422), ('Nicoleta Catalina', 485.46875), ('Nicolette', 778.1648648648649), ('Nidhi', 762.1578947368421), ('Nigina', 376.7617554858934), ('Nika', 913.4380165289256), ('Nikita', 1174.0), ('Nikki', 1017.3134328358209), ('Nikol', 1054.0813953488373), ('Nikola', 723.484076433121), ('Nina', 528.8673050615595), ('Nina Isabella', 1124.1666666666667), ('Nives', 841.0514705882352), ('Noel', 965.5343511450382), ('Noelia', 1049.834745762712), ('Noelle', 883.7787610619469), ('Nonna', 1167.2758620689656), ('Noppawan', 374.93926247288505), ('Nora', 921.6216216216217), ('Nour', 1096.1140350877192), ('Nozomi', 936.3392857142857), ('Nudnida', 436.66881028938906), ('Nungnadda', 537.577922077922), ('Nuria', 395.6680227827502), ('Oana', 1027.1382978723404), ('Oana Georgeta', 686.3047619047619), ('Oceane', 728.7630208333334), ('Ofri', 839.4923664122138), ('Oksana', 533.9652351738241), ('Ola', 660.8924731182796), ('Olawaseun', 1397.5), ('Olaya', 1112.75), ('Oleksandra', 903.4289156626506), ('Olena', 1179.1555555555556), ('Olesya', 501.44444444444446), ('Olga', 432.6511627906977), ('Olivia', 446.7231833910035), ('Oliwia', 1006.5128205128206), ('Ons', 435.1470588235294), ('Ornella', 978.7321428571429), ('Oyku', 866.0454545454545), ('Paige Mary', 1156.28125), ('Pamela', 989.1904761904761), ('Panna', 683.1081081081081), ('Paola', 132.12638580931264), ('Parris', 1099.625), ('Patcharin', 863.5507246376811), ('Patricia', 572.8059701492538), ('Patricia Maria', 403.935), ('Patrycja', 657.3816155988858), ('Patty', 385.8135593220339), ('Paula', 558.0162601626016), ('Paula Andrea', 1175.909090909091), ('Paula Catalina', 868.7624113475177), ('Paula Cristina', 508.4679802955665), ('Paulina', 1035.7780678851175), ('Pauline', 298.1861898890259), ('Pavla', 915.5892857142857), ('Peangtarn', 514.586319218241), ('Peggy', 755.5813953488372), ('Pei Chi', 673.9809523809524), ('Pei Hsuan', 1106.5), ('Pei Ju', 1061.3076923076924), ('Pemra', 465.24962852897477), ('Pernilla', 619.4154929577464), ('Petia', 710.3972602739726), ('Petra', 365.50280484204313), ('Phenomena', 1211.0), ('Phillis', 826.6486486486486), ('Pia', 737.862676056338), ('Piia', 668.2581196581197), ('Pilar', 740.5879828326181), ('Pippa', 1041.0740740740741), ('Plobrung', 937.7945205479452), ('Polina', 630.7953529937444), ('Polona', 478.30369515011546), ('Poojashree', 729.1047904191616), ('Pranjala', 795.4736842105264), ('Prarthana G', 653.5070422535211), ('Prerna', 740.5361842105264), ('Priscila', 1137.19), ('Priscilla', 675.4124293785311), ('Qiang', 383.4714587737844), ('Qianhui', 826.1388888888889), ('Qianqian', 943.421052631579), ('Qiu Yu', 705.8493150684932), ('Quinn', 883.2352941176471), ('Quirine', 633.9770491803279), ('Rachael', 859.2706766917294), ('Rachel', 1147.8526315789475), ('Radina', 955.7833333333333), ('Rafaela', 1121.2432432432433), ('Ralina', 1176.5), ('Raluca', 304.4619771863118), ('Raluca Elena', 672.2258064516129), ('Raluca Georgiana', 539.6164383561644), ('Ramu', 1010.4545454545455), ('Ramya', 1121.8846153846155), ('Ran', 598.2655172413793), ('Rana', 1117.6666666666667), ('Raquel', 700.7644444444444), ('Rashmi', 1089.2100840336134), ('Ratnika', 1021.6504854368932), ('Raveena', 487.6268656716418), ('Rebeca', 1145.4333333333334), ('Rebecca', 568.3374316939891), ('Rebeka', 676.1090909090909), ('Regina', 289.60283687943263), ('Reina', 1019.0), ('Reka Luca', 323.1388101983003), ('Remi', 494.6111111111111), ('Renata', 274.85317919075146), ('Ria', 669.448275862069), ('Rianna', 638.6666666666666), ('Richel', 246.19871794871796), ('Rika', 290.0614657210402), ('Riko', 495.22641509433964), ('Rio', 1125.0363636363636), ('Risa', 489.65909090909093), ('Rishika', 775.7269624573379), ('Rita', 1051.7349397590363), ('Riya', 651.4246575342465), ('Roberta', 150.96681415929203), ('Robin', 431.19607843137254), ('Robyn', 1054.606896551724), ('Rocio', 795.6201232032854), ('Romana', 402.49931972789113), ('Romana Caroline', 669.8542372881356), ('Romina', 283.63246554364474), ('Romy', 758.1714285714286), ('Rona', 1125.5471698113208), ('Ronit', 427.0), ('Ronke', 1072.857142857143), ('Roosh', 1168.2857142857142), ('Rosa', 965.0), ('Rosalia', 1059.73), ('Rosalie', 1066.5887096774193), ('Rosie', 984.1714285714286), ('Roxane', 479.51738241308794), ('Rui', 1209.625), ('Rushmi', 573.8729603729604), ('Rutuja', 808.5096774193548), ('Ryann', 1069.0379746835442), ('Saana', 1117.88), ('Sabastiani', 982.7397260273973), ('Sabina', 682.2005532503458), ('Sabina Elena', 1184.6666666666667), ('Sabine', 203.5871080139373), ('Sabrina', 905.6324786324786), ('Sacha', 340.2890442890443), ('Sachia', 400.8093385214008), ('Sachie', 368.26881720430106), ('Sadafmoh', 665.8219178082192), ('Sai Samhitha', 998.5238095238095), ('Saisai', 297.39032258064515), ('Sakiko', 832.9585365853659), ('Sally', 529.583908045977), ('Salma', 1204.6666666666667), ('Samantha', 406.21702404158543), ('Samira', 932.8940397350993), ('Sanae', 1105.171875), ('Sanaz', 703.1372549019608), ('Sandra', 563.964505613908), ('Sandy', 1028.9565217391305), ('Sang Hee', 857.9508196721312), ('Sania', 177.22695035460993), ('Sara', 509.80945757997216), ('Sarah', 546.5551763367463), ('Sarah Beth', 875.9277108433735), ('Sarah Rebecca', 743.6062176165804), ('Sarahi', 1139.2340425531916), ('Sarai Delfina', 1191.6470588235295), ('Saray', 840.0776699029126), ('Sari', 1081.1666666666667), ('Sarlota', 1209.7777777777778), ('Sarvinoz', 1235.1960784313726), ('Sasa', 1033.027027027027), ('Saska', 747.3695652173913), ('Satsuki', 888.7272727272727), ('Savannah', 1142.9285714285713), ('Schena', 1188.2941176470588), ('Se Hyun', 1210.2571428571428), ('Se Jin', 1122.4545454545455), ('Sean', 1240.92), ('Seda', 1003.5367647058823), ('Seira', 1115.72), ('Selin', 1168.6571428571428), ('Seo Kyung', 858.9173789173789), ('Seone', 889.8028169014085), ('Serena', 14.654294803817603), ('Sesil', 162.3505747126437), ('Seung Yeon', 784.0465949820789), ('Severine', 218.4701086956522), ('Shahar', 166.41358024691357), ('Shakhlo', 924.8818897637796), ('Shakhnoza', 1236.7627118644068), ('Shangqing', 1228.3235294117646), ('Shanshan', 694.2), ('Shao Yuan', 967.9034090909091), ('Sharmada', 851.5633802816901), ('Sharon', 296.5792682926829), ('Sharon Sanchana', 1097.0), ('Shelby', 372.89398280802294), ('Shelly', 1171.0), ('Sheng Nan', 451.8657487091222), ('Sherazad', 649.5154639175257), ('Sherry', 1024.0116279069769), ('Shiho', 500.688679245283), ('Shilin', 632.2824427480916), ('Shiori', 1070.6666666666667), ('Shir', 1154.4166666666667), ('Shiran', 1187.9245283018868), ('Shivika', 935.2322946175638), ('Shou Na', 1120.388888888889), ('Shreya', 1148.0), ('Shu Ying', 1042.6802325581396), ('Shuai', 167.90740740740742), ('Shuko', 421.44179894179894), ('Shuo', 864.1538461538462), ('Shuyue', 966.0588235294117), ('Shweta', 897.6951219512196), ('Si Qi', 1047.7575757575758), ('Silvia', 565.8211508553654), ('Simona', 542.2382851445662), ('Simone', 1070.3417721518988), ('Simran Kaur', 974.8), ('Sina', 728.7443609022556), ('Sinead', 975.3484848484849), ('Sing Le', 1141.842105263158), ('Siqi', 980.9076923076923), ('Sirui', 949.7916666666666), ('Siyu', 1241.1379310344828), ('Sloane', 259.63589743589745), ('Smriti', 1184.8260869565217), ('Sneha', 1225.388888888889), ('Snehadevi S', 632.3150684931506), ('So Jung', 514.1732026143791), ('So Ra', 572.2654545454545), ('Sofia', 526.3535641547861), ('Sofico', 1084.107142857143), ('Sofie', 724.5), ('Sofiya', 541.1570881226054), ('Sofya', 640.8727272727273), ('Sohyun', 1004.6666666666666), ('Sonia', 1029.0980392156862), ('Sonja', 885.0976744186047), ('Sophia', 1221.3333333333333), ('Sophie', 600.6881091617934), ('Sorana', 213.75043630017453), ('Sowjanya', 813.1357142857142), ('Spurti', 1149.3125), ('Sri Vaishnavi', 792.1927710843373), ('Stamatia', 841.8387096774194), ('Stanislava', 312.54158964879855), ('Stefana', 993.4255319148937), ('Stefani', 1167.3333333333333), ('Stefania', 759.2894995093228), ('Stefanie', 387.73412112259973), ('Steffi', 939.746835443038), ('Stephanie', 439.87772357723577), ('Stephanie Mariel', 1035.5548387096774), ('Storm', 573.6708333333333), ('Su Jeong', 426.3886462882096), ('Su Wei', 217.2493188010899), ('Suellen', 911.7619047619048), ('Sultan', 944.2432432432432), ('Sun Jung', 812.4581005586592), ('Sunae', 1229.8), ('Sunam', 611.0757575757576), ('Sung Hee', 635.7449168207024), ('Susan', 1015.6792452830189), ('Susanne', 417.8053097345133), ('Suzan', 982.7222222222222), ('Suzuho', 980.6666666666666), ('Suzy', 698.7567567567568), ('Svenja', 844.203007518797), ('Svetlana', 267.03227571115974), ('Sviatlana', 691.9934640522875), ('Sybille', 1002.6792452830189), ('Sylvia', 869.1702127659574), ('Sylwia', 787.7645348837209), ('Syna', 791.1240506329113), ('Szabina', 772.3186813186813), ('Tadeja', 343.0985324947589), ('Taisiya', 969.6588235294117), ('Talya', 1230.2), ('Tamachan', 949.8059701492538), ('Tamar', 1118.4166666666667), ('Tamara', 614.0434782608696), ('Tamari', 1146.3934426229507), ('Tamarine', 121.82273948075202), ('Tamaryn', 386.7025316455696), ('Tamira', 135.88910505836577), ('Tammi', 601.906914893617), ('Tanaporn', 1113.2325581395348), ('Tanya', 1023.089430894309), ('Tara', 475.2979683972912), ('Tatia', 1075.0), ('Tatiana', 681.9417582417583), ('Tatjana', 247.7449768160742), ('Tatsiana', 912.1077844311377), ('Tayisiya', 747.3172413793103), ('Taylor', 387.5662100456621), ('Tea', 1068.7457627118645), ('Teliana', 461.06702898550725), ('Tena', 614.9346733668342), ('Teodora', 489.27513227513225), ('Tereza', 557.241418764302), ('Terri', 963.5), ('Tess', 696.2878787878788), ('Tessah', 390.2361111111111), ('Tetiana', 437.4119658119658), ('Tetyana', 398.83478260869566), ('Thai Sa Grana', 802.7222222222222), ('Theo', 650.1206896551724), ('Theresa', 1159.5632183908046), ('Tijana', 1017.7777777777778), ('Timea', 182.02426160337552), ('Tina', 425.82394366197184), ('Tinatin', 810.6666666666666), ('Ting Fei', 739.7727272727273), ('Ting Jr', 789.6113989637306), ('Tingting', 1015.2352941176471), ('Tjasa', 743.1953125), ('Tomoko', 838.8065217391304), ('Tori', 841.7167381974249), ('Tornado Alicia', 878.1666666666666), ('Trang', 1029.3196721311476), ('Treta', 1009.8666666666667), ('Tsvetana', 131.02074074074073), ('Tyra', 992.4870588235294), ('Ulrikke', 506.39344262295083), ('Ulyana', 844.0692307692308), ('Urszula', 229.35687022900763), ('Ushna', 1132.4109589041095), ('Usue Maitane', 411.5068493150685), ('Valentina', 921.3333333333334), ('Valentine', 751.2668918918919), ('Valentini', 479.8914728682171), ('Valentyna', 368.14331210191085), ('Valeria', 661.8474576271186), ('Valerie', 806.2648401826484), ('Valeriya', 799.8668224299065), ('Vanda', 696.4126984126984), ('Vanesa', 579.437984496124), ('Vanessa', 398.3106546854942), ('Vania', 185.75), ('Vaniya', 1130.6037735849056), ('Vanja', 1089.7111111111112), ('Varatchaya', 450.4642082429501), ('Varunya', 894.3846153846154), ('Varvara', 382.6888217522659), ('Vasilisa', 613.5330490405117), ('Vaszilisza', 859.8103448275862), ('Vendula', 729.0117647058823), ('Venus', 32.984862819299906), ('Vera', 195.66923570969814), ('Verena', 958.1327800829876), ('Veronica', 726.1852387843704), ('Veronica M', 951.0075757575758), ('Veronika', 734.6018957345972), ('Vesna', 240.0448979591837), ('Vicky', 1252.9130434782608), ('Victoire', 1138.8490566037735), ('Victoria', 444.9760935910478), ('Victoria Ariadna', 1236.0), ('Viktoria', 566.9148936170212), ('Viktoriia', 1236.5333333333333), ('Viktorija', 507.4), ('Viktoriya', 736.2288557213931), ('Viktoryia', 966.4671052631579), ('Vilma Y', 1243.0), ('Vincenza', 1214.1142857142856), ('Vinciane', 1150.0), ('Violetta', 1170.840579710145), ('Virginie', 355.88102893890675), ('Vishesh', 1208.952380952381), ('Vita', 1201.25), ('Vitalia', 296.2025641025641), ('Vivian', 670.9108527131783), ('Vivien', 607.2810218978102), ('Vivienne', 659.2103004291846), ('Vlada', 595.3291666666667), ('Vladica', 943.5432098765432), ('Vladimira', 823.8770833333333), ('Vladislava', 1006.1769911504425), ('Vladyslava', 856.0782608695653), ('Vojislava', 555.6572164948453), ('Voni', 999.0215053763441), ('Wan Ting', 701.4009009009009), ('Wan Yi', 1081.142857142857), ('Warona', 1249.3333333333333), ('Wen Hsin', 440.35214446952597), ('Wen Ling', 1117.55), ('Wendy Qi Wen', 1011.469696969697), ('Weronika Jasmina', 1152.7837837837837), ('Whitney', 886.1407407407407), ('Wiktoria', 1083.1454545454546), ('Wing Yau Venise', 585.2589641434263), ('Wushuang', 937.7878787878788), ('Xenia', 661.2222222222222), ('Xi Yao', 714.8653846153846), ('Xiao', 814.4171122994652), ('Xiaodi', 467.24657534246575), ('Xiaorong', 848.4418604651163), ('Xiaoxi', 737.7547169811321), ('Ximena', 712.2780373831775), ('Xin', 694.4808743169399), ('Xin Yu', 1022.3333333333334), ('Xinyu', 480.646017699115), ('Xinyun', 309.35767790262173), ('Xiyu', 954.6), ('Xu Liu', 488.7671232876712), ('Ya', 1225.75), ('Ya Hsuan', 586.865), ('Yafan', 325.6162790697674), ('Yan', 768.560975609756), ('Yana', 740.0214504596527), ('Yang', 1177.8823529411766), ('Yanina', 381.2581602373887), ('Yanni', 1059.2702702702702), ('Yarden', 1166.875), ('Yaroslava', 211.41240310077518), ('Yasmin', 702.1784386617101), ('Yasmina', 1227.7777777777778), ('Yasmine', 983.0410958904109), ('Yasmyn', 1261.8181818181818), ('Yawna', 1110.4594594594594), ('Yayuk', 114.78806907378336), ('Ye Ra', 431.3144424131627), ('Ye Xin', 1048.081081081081), ('Yekaterina', 1155.8191489361702), ('Yelena', 897.4873949579832), ('Yeong Won', 973.8617021276596), ('Yevgeniya', 724.8712871287129), ('Yi', 791.0756207674943), ('Yi Fan', 381.5512572533849), ('Yi Jing', 656.8787276341948), ('Yi Miao', 418.2566137566138), ('Yidi', 1185.030303030303), ('Yihong', 1209.625), ('Yijia', 1063.9411764705883), ('Ying', 661.3972602739726), ('Ying Ying', 403.8775981524249), ('Yixuan', 801.6712328767123), ('Ylena', 892.3561643835617), ('Ylona Georgiana', 642.9487179487179), ('Yoko', 1128.901098901099), ('Yolande', 1068.4619883040937), ('Yoo Ri', 1263.7666666666667), ('Yoon Young', 844.9310344827586), ('Yoshimi', 1096.9130434782608), ('Yosr', 1222.24), ('You Na', 1170.3461538461538), ('Ysaline', 458.86633663366337), ('Yu Jin', 1098.357142857143), ('Yu Tong', 1239.6666666666667), ('Yuan', 1054.0), ('Yuanyi', 891.2340425531914), ('Yue', 983.359649122807), ('Yue Yue', 444.96190476190475), ('Yuenu', 961.876923076923), ('Yujia', 1034.1304347826087), ('Yuka', 748.8250591016548), ('Yukako', 1071.5833333333333), ('Yuki', 876.7428571428571), ('Yuki Kristina', 698.8285714285714), ('Yukina', 857.1692307692308), ('Yukun', 824.3936170212766), ('Yulia', 485.35135135135135), ('Yuliana', 725.5322195704057), ('Yuliya', 384.87776983559684), ('Yumi', 799.1332586786115), ('Yung Jan', 166.6586270871985), ('Yuqi', 1047.3529411764705), ('Yurika', 322.17758620689654), ('Yuriko', 1041.5367231638418), ('Yurina', 746.4803493449782), ('Yuuki', 608.1309090909091), ('Yuval', 1230.2), ('Yuxuan', 545.449074074074), ('Yvonne', 318.2867132867133), ('Zaineb', 1227.344827586207), ('Zalina', 867.5288461538462), ('Zarah', 709.625), ('Zarina', 222.81428571428572), ('Zeel', 791.2352941176471), ('Zeynep  Sena', 1229.5714285714287), ('Zhanlan', 627.7777777777778), ('Zhaoxuan', 629.0081967213115), ('Zhibek', 1058.0), ('Zhima', 1144.45), ('Zhou', 1237.9), ('Zhuoma', 989.75), ('Zi', 391.4656290531777), ('Zinovia', 1221.5), ('Ziyue', 878.4606741573034), ('Zoe', 765.3777777777777), ('Zoe Gwen', 935.081081081081), ('Zsofia', 916.559633027523), ('Zuzana', 451.92875448487956), ('Zuzanna', 794.5416666666666)]","[(1199.8235294117646, 'Aastha'), (1110.0434782608695, 'Abbi'), (808.4545454545455, 'Abbie'), (387.66706161137444, 'Abigail'), (1039.6744186046512, 'Abiodun'), (1228.75, 'Abir'), (790.1538461538462, 'Adeliya'), (1122.4423076923076, 'Adnya'), (619.6814159292036, 'Adriana'), (1213.1666666666667, 'Adrienn'), (627.12, 'Adrijana'), (1255.3333333333333, 'Adva'), (1155.0392156862745, 'Afroditi'), (960.6770186335403, 'Agata'), (1082.3548387096773, 'Agata Jadwiga'), (1231.5, 'Agne'), (391.3003629764065, 'Agnes'), (694.0659898477157, 'Agnese'), (940.2125603864735, 'Agni'), (122.19587628865979, 'Agnieszka'), (684.8497652582159, 'Agustina'), (1154.25, 'Agustina Elena'), (1156.340425531915, 'Ah'), (1248.72, 'Ahlam'), (728.5, 'Ahsha'), (890.8728448275862, 'Ai'), (912.1523178807947, 'Ai Wen'), (1110.3333333333333, 'Aida'), (284.8724727838258, 'Aiko'), (1034.5833333333333, 'Ailen'), (1200.2, 'Aimee'), (1164.95, 'Aina'), (943.7397959183673, 'Ainhoa'), (1024.625, 'Aishwarya'), (302.84831460674155, 'Ajla'), (704.9618138424821, 'Akari'), (215.25185185185185, 'Akgul'), (710.9617224880383, 'Aki'), (1145.8235294117646, 'Akiho'), (493.98205383848455, 'Akiko'), (772.8571428571429, 'Akilah'), (1038.35, 'Akvile'), (1119.1639344262296, 'Alana'), (843.7260273972603, 'Alba'), (343.22432701894314, 'Alberta'), (775.2734375, 'Albina'), (1185.7142857142858, 'Aldana'), (1067.019801980198, 'Alejandra'), (450.22998544395927, 'Aleksandra'), (578.07962529274, 'Aleksandrina'), (820.4563492063492, 'Alena'), (1123.4864864864865, 'Alessandra'), (1057.628205128205, 'Alessia'), (1145.1641791044776, 'Alessondra'), (383.9921465968586, 'Alexa'), (569.2647632558965, 'Alexandra'), (945.625, 'Alexandria'), (718.5202702702703, 'Alexia'), (604.15, 'Alexis'), (441.9846743295019, 'Aliaksandra'), (710.3822682786414, 'Alice'), (951.9764150943396, 'Alice Andrada'), (1105.1298701298701, 'Alicia'), (855.813627254509, 'Alicja'), (925.0028776978418, 'Alina'), (611.35, 'Aliona'), (453.01556420233464, 'Alisa'), (403.48784576697403, 'Alison'), (822.3459915611814, 'Alix'), (252.11485774499474, 'Alize'), (217.85922330097088, 'Alla'), (557.9232456140351, 'Allie'), (1157.8, 'Almudena'), (871.6926829268293, 'Alona'), (1181.6078431372548, 'Alory Regina Elorriaga'), (496.9431818181818, 'Alyona'), (650.6240276577355, 'Amanda'), (747.4375, 'Amandine'), (1011.3666666666667, 'Amelie'), (803.9764705882353, 'Amina'), (613.195652173913, 'Aminat'), (1075.8260869565217, 'Amira'), (415.9078341013825, 'Amra'), (1209.4, 'Amrita'), (763.888198757764, 'Amy'), (460.8932038834951, 'An Sophie'), (396.2893280632411, 'Ana'), (842.8446601941747, 'Ana Bianca'), (524.9192825112108, 'Ana Clara'), (1084.7916666666667, 'Ana Gabriela'), (1243.4285714285713, 'Ana Luisa'), (1031.228855721393, 'Ana Paula'), (496.7156398104265, 'Ana Sofia'), (961.2631578947369, 'Ana Victoria'), (144.3264367816092, 'Anabel'), (922.2255639097745, 'Anaeve'), (482.26169844020797, 'Anais'), (859.3059701492538, 'Anamika'), (430.0872542522642, 'Anastasia'), (956.5754716981132, 'Anastasia Evgenyevna'), (1245.75, 'Anastasiia'), (221.66153846153847, 'Anastasija'), (671.2584369449378, 'Anastasiya'), (1127.7368421052631, 'Anca'), (1150.0, 'Anda'), (970.3620689655172, 'Andie K'), (1063.4736842105262, 'Andjela'), (1275.8235294117646, 'Andra Maria'), (414.4332292750607, 'Andrea'), (878.3939393939394, 'Andrea Renee'), (956.0333333333333, 'Andreea'), (801.84375, 'Andreea Amalia'), (726.2657657657658, 'Andreea Roxana'), (424.64521739130436, 'Andreja'), (1184.0416666666667, 'Andressa Cristina'), (1045.6666666666667, 'Andrina'), (1152.0857142857142, 'Aneta'), (367.2274678111588, 'Anett'), (969.8181818181819, 'Anette'), (1226.3333333333333, 'Ange Oby'), (1128.7272727272727, 'Angela'), (686.2234432234433, 'Angelica'), (1089.1603773584907, 'Angeliki'), (750.3207810320781, 'Angelina'), (308.56833824975416, 'Angelique'), (432.6949152542373, 'Anhelina'), (850.9791666666666, 'Anhzelika'), (720.1431870669746, 'Ani'), (947.472972972973, 'Anita'), (725.3893333333333, 'Anja'), (1228.388888888889, 'Anke'), (618.4714285714285, 'Ankita'), (907.4, 'Ann'), (551.5557158312297, 'Anna'), (760.639175257732, 'Anna Arina'), (428.5496828752643, 'Anna Giulia'), (345.51020408163265, 'Anna Karolina'), (916.7115384615385, 'Anna Katalina'), (201.87700534759358, 'Anna Lena'), (1070.3967391304348, 'Anna Maria'), (583.9347826086956, 'Annalisa'), (248.74237737516572, 'Anne'), (762.7606382978723, 'Anne Liz'), (1237.6363636363637, 'Anne Marie'), (1252.0, 'Anne Sophie'), (1042.037037037037, 'Annie'), (265.79487179487177, 'Annika'), (969.5882352941177, 'Anouk'), (1051.7096774193549, 'Antonela'), (589.1298076923077, 'Antonia'), (1049.4655172413793, 'Antonina'), (1037.0833333333333, 'Anushka'), (617.3333333333334, 'Ao'), (1016.5714285714286, 'Apichaya'), (658.5074074074074, 'Arabela'), (279.23336006415394, 'Arantxa'), (490.4144736842105, 'Aranza'), (200.97080291970804, 'Aravane'), (951.4146341463414, 'Ariadna'), (560.6778190830236, 'Arina'), (1224.0, 'Arina Gabriela'), (1074.3333333333333, 'Arlinda'), (1281.8461538461538, 'Arthi'), (349.54794520547944, 'Aryna'), (1181.27868852459, 'Aselya'), (1151.95, 'Asha'), (331.3681818181818, 'Ashleigh'), (638.88, 'Ashley'), (823.0909090909091, 'Ashling'), (1018.6637931034483, 'Ashmitha'), (803.3904761904762, 'Ashvarya'), (453.43392070484583, 'Asia'), (790.46875, 'Asiya'), (1172.5531914893618, 'Assia'), (829.5625, 'Astra'), (1086.45, 'Astrid Wanja'), (591.2544731610338, 'Audrey'), (1208.4285714285713, 'Avgusta'), (1064.0, 'Axana'), (552.4653465346535, 'Ayaka'), (901.8717948717949, 'Ayan'), (597.6981132075472, 'Ayano'), (397.83561643835617, 'Ayla'), (915.5932203389831, 'Aymet'), (479.5530612244898, 'Ayu Fani'), (412.74466019417474, 'Ayumi'), (556.2303370786517, 'Azra'), (763.8900651465798, 'Barbara'), (252.6093155893536, 'Barbora'), (656.2932551319648, 'Basak'), (785.0707482993197, 'Beatrice'), (457.4050279329609, 'Beatriz'), (1253.4, 'Beatriz Magdalena'), (971.2865853658536, 'Beatriz Maria'), (1382.1538461538462, 'Beauty'), (1167.3368421052633, 'Belen'), (681.7736842105263, 'Belinda'), (705.4688346883469, 'Benedetta'), (625.013698630137, 'Berfu'), (717.7932330827068, 'Bermet'), (541.273631840796, 'Bernarda'), (834.1005025125628, 'Bernice'), (1005.75, 'Berta'), (146.59709379128137, 'Bethanie'), (1229.5714285714287, 'Betina'), (878.0138888888889, 'Bhuvana'), (653.2805383022775, 'Bianca'), (696.952380952381, 'Bianka'), (550.1941544885177, 'Bibiane'), (912.71875, 'Blair'), (904.6538461538462, 'Blanca'), (1221.8333333333333, 'Blessing'), (1254.6341463414635, 'Boba'), (392.7313829787234, 'Bojana'), (834.2066115702479, 'Borislava'), (992.4222222222222, 'Boyan'), (970.9846153846154, 'Brandy'), (872.0930232558139, 'Breaunna'), (211.01377118644066, 'Brenda'), (854.3170731707318, 'Brianna'), (917.0, 'Brienne'), (1126.3333333333333, 'Brindtha'), (647.5205479452055, 'Britt'), (990.5210084033613, 'Brittany'), (804.6277056277056, 'Brooke'), (952.5619834710744, 'Brynn'), (555.3384615384615, 'Bunyawi'), (1140.981981981982, 'Busra'), (311.87854251012146, 'Cagla'), (709.4247787610619, 'Caitlin'), (803.7139479905437, 'Camelia Elena'), (1192.1818181818182, 'Cameron'), (539.7944621938232, 'Camila'), (1192.3783783783783, 'Camila Vital'), (801.6850649350649, 'Camilla'), (1112.9450549450548, 'Camille'), (236.07412398921832, 'Cara'), (416.3666666666667, 'Carina'), (411.70779777206513, 'Carla'), (1236.7777777777778, 'Carlota'), (1127.9338842975208, 'Carlotta'), (318.69978858350953, 'Carly'), (890.6351351351351, 'Carmen'), (842.1553398058253, 'Carmen Raluca'), (564.1434426229508, 'Carol'), (645.2279792746114, 'Carolin'), (718.725321888412, 'Carolina'), (799.0650406504066, 'Carolina Meligeni Rodrigues'), (342.40130505709624, 'Caroline'), (1161.5675675675675, 'Caroline B'), (1197.578947368421, 'Carolyn'), (1020.6, 'Carson'), (378.0163727959698, 'Casey'), (293.76942355889724, 'Catalina'), (941.4724409448819, 'Catherine'), (134.21917808219177, 'Catherine Cartan'), (744.0, 'Caty'), (755.4649681528663, 'Cecilia'), (1141.842105263158, 'Cecilie Lundgaard'), (708.618398637138, 'Celine'), (1123.3855421686746, 'Cemre'), (650.1367521367522, 'Chalena'), (343.2835365853659, 'Chanel'), (215.6615811373093, 'Chanelle'), (575.4626436781609, 'Chang'), (1281.8461538461538, 'Chanikarn'), (609.90625, 'Chantal'), (1128.030303030303, 'Chantelle'), (1232.8, 'Chaoyi'), (766.4794520547945, 'Charlene'), (927.7647058823529, 'Charlotte'), (593.9759036144578, 'Chayenne'), (1132.0, 'Chelsea'), (719.3061224489796, 'Chelsey'), (524.7444668008048, 'Chen'), (789.2857142857143, 'Chengyiyi'), (464.1367781155015, 'Chi Chi'), (1039.3902439024391, 'Chi Fan'), (950.8813559322034, 'Chia Hsien'), (359.3764705882353, 'Chia Jung'), (437.73858921161826, 'Chiaki'), (977.9640591966173, 'Chiara'), (533.9586374695864, 'Chieh Yu'), (848.9908952959029, 'Chihiro'), (385.2651515151515, 'Chin Wei'), (615.2230215827338, 'Chinami'), (583.530303030303, 'Ching Wen'), (749.3582089552239, 'Chiraz'), (874.8181818181819, 'Chisa'), (675.2445414847161, 'Chloe'), (1112.1458333333333, 'Chompoothip'), (1112.875, 'Christie'), (454.9920529801324, 'Christina'), (841.4051724137931, 'Christine'), (692.390625, 'Chun Mei'), (986.3944099378882, 'Chun Yan'), (659.3055555555555, 'Cindy'), (443.45754716981133, 'Claire'), (1190.7307692307693, 'Clara'), (826.2619047619048, 'Claudia'), (967.2978723404256, 'Claudia Antonia'), (996.2574257425742, 'Claudia Gianina'), (383.6413199426112, 'Claudine'), (823.6306306306307, 'Clelia'), (875.9772727272727, 'Clemence'), (964.1224489795918, 'Clementina Eugenia'), (620.4120171673819, 'Clothilde'), (270.5896860986547, 'Coco'), (1165.093023255814, 'Colomba'), (390.0, 'Conny'), (570.2723004694835, 'Constance'), (835.1132075471698, 'Constanza'), (1245.3333333333333, 'Constanze'), (832.7818181818182, 'Corina'), (356.8219696969697, 'Corinna'), (757.2253521126761, 'Cornelia'), (406.5511363636364, 'Cory Ann'), (1049.0, 'Costanza'), (554.5376344086021, 'Cristiana'), (643.616049382716, 'Cristina'), (439.5747863247863, 'Cristina Andreea'), (720.6428571428571, 'Cristina Madalina'), (949.7944444444445, 'Csilla'), (998.7722772277227, 'Cynthia'), (1010.3333333333334, 'Da Hye'), (920.1276595744681, 'Dabin'), (1159.1818181818182, 'Dagmara'), (720.7490039840637, 'Daiana'), (1181.4736842105262, 'Dajana'), (801.6933333333334, 'Dalia'), (525.9552572706936, 'Dalila'), (279.16438356164383, 'Dalma'), (1493.0, 'Damilola'), (1242.0, 'Damini'), (1198.3333333333333, 'Damira'), (994.4769230769231, 'Dan Ni'), (805.7028985507246, 'Dana'), (977.4539007092199, 'Daneika'), (380.609375, 'Danica'), (348.6364892881825, 'Daniela'), (643.9216101694915, 'Daniella'), (744.7453250222618, 'Danielle'), (434.68, 'Danielle Rose'), (1107.0919540229886, 'Danijela'), (302.83268482490274, 'Danka'), (1226.5454545454545, 'Daphne'), (629.6443987667009, 'Daria'), (464.95631067961165, 'Darija'), (1132.1744186046512, 'Dariya'), (531.1829405162739, 'Darya'), (722.6986301369863, 'Dasha'), (576.4307692307692, 'Dayana'), (550.9545454545455, 'Dea'), (764.6785714285714, 'Deborah'), (1115.0851063829787, 'Deeon'), (758.5342960288808, 'Dejana'), (983.4174757281553, 'Demi'), (419.1633466135458, 'Denisa'), (949.1239316239316, 'Denise'), (1160.3125, 'Denise Antonela'), (551.5304659498208, 'Deniz'), (1123.6486486486488, 'Deria'), (863.7826086956521, 'Desirae'), (1032.2666666666667, 'Desiree'), (665.686684073107, 'Despina'), (746.0962962962963, 'Despoina'), (483.77464788732397, 'Destanee'), (1154.2857142857142, 'Dewi'), (615.1506849315068, 'Dhruthi'), (736.1650485436893, 'Di'), (383.7832512315271, 'Dia'), (654.3773657782928, 'Diana'), (1205.7692307692307, 'Diana Maria'), (809.697247706422, 'Dianne'), (669.2982456140351, 'Dijana'), (1248.2, 'Dilara'), (1094.4583333333333, 'Dina'), (268.05945945945945, 'Dinah'), (1234.6176470588234, 'Doga Selen'), (803.8666666666667, 'Domenica'), (171.71134020618555, 'Dominika'), (1042.7843137254902, 'Dominique'), (1131.6333333333334, 'Donika'), (223.50900900900902, 'Donna'), (1196.56, 'Dorien'), (520.9397993311037, 'Doroteja'), (913.7272727272727, 'Draginja'), (929.0599369085173, 'Dunja'), (1073.1752577319587, 'Ebony'), (1029.6888888888889, 'Eden'), (211.67325428194994, 'Edina'), (656.2851711026616, 'Eduarda'), (842.7045454545455, 'Eetee'), (1214.857142857143, 'Ege'), (471.8367290748899, 'Ekaterina'), (553.9434782608696, 'Ekaterine'), (1221.7931034482758, 'Elaine'), (1066.5343511450383, 'Eleanor'), (324.3720930232558, 'Elena'), (392.44444444444446, 'Elena Gabriela'), (686.6470588235294, 'Elena Teodora'), (249.5244140625, 'Eleni'), (950.0277777777778, 'Eleonora'), (1087.372340425532, 'Eleonore'), (876.1730769230769, 'Eliessa'), (421.6573033707865, 'Elina'), (888.2213114754098, 'Elisabeth'), (334.7118644067797, 'Elise'), (418.39748953974896, 'Elitsa'), (579.5214723926381, 'Elixane'), (978.2708333333334, 'Eliza'), (1154.2714285714285, 'Elizabeta'), (736.9747747747748, 'Elizabeth'), (1006.2982456140351, 'Elizabeth Anita Alexandria'), (489.5307517084282, 'Elizaveta'), (981.9814814814815, 'Elizaveta Anna'), (1011.9433962264151, 'Elke'), (1168.7967479674796, 'Ella'), (750.9460093896714, 'Ellen'), (508.340206185567, 'Ellie'), (1211.2333333333333, 'Elodie'), (652.1984732824427, 'Elyne'), (819.3400503778338, 'Ema'), (672.730407523511, 'Emelyn'), (770.8472222222222, 'Emi'), (1232.0, 'Emilia'), (1022.9174311926605, 'Emiliana'), (705.4716981132076, 'Emilie'), (1209.625, 'Emilija'), (1092.2771084337348, 'Emiliya'), (585.093851132686, 'Emily'), (1041.948717948718, 'Emily J'), (682.0972222222222, 'Emina'), (641.046992481203, 'Emma'), (1193.3529411764705, 'Emma Christine'), (943.7716535433071, 'Emmanuelle'), (1229.7333333333333, 'En Pei'), (980.3333333333334, 'Ena'), (321.23595505617976, 'Eri'), (788.0384615384615, 'Erica'), (544.5041866028708, 'Erika'), (942.7969696969697, 'Erin'), (733.1351351351351, 'Erina'), (1218.5652173913043, 'Esen'), (966.0540540540541, 'Estela'), (617.4935251798561, 'Estelle'), (950.9090909090909, 'Ester'), (347.34943639291464, 'Estrella'), (781.3218390804598, 'Etsuko'), (911.7241379310345, 'Eudice Wong'), (1157.5, 'Eugenia'), (477.62886597938143, 'Eugenie'), (620.6746411483253, 'Eugeniya'), (500.29483037156706, 'Eva'), (1083.8333333333333, 'Eva Marie'), (1023.8690476190476, 'Eveliina'), (471.5439093484419, 'Evelyn'), (414.66339869281046, 'Evgenia'), (442.0344827586207, 'Evgeniya'), (612.0185185185185, 'Fang Ying'), (406.9281767955801, 'Fangzhou'), (569.1904761904761, 'Fanny'), (1106.3076923076924, 'Farah'), (673.7509157509157, 'Fatima'), (1070.9463414634147, 'Fatimah'), (648.2984054669704, 'Fatma'), (1015.5, 'Fatyha'), (722.7286493034525, 'Federica'), (1204.7272727272727, 'Federica Joe'), (647.922077922078, 'Fernanda'), (1187.0384615384614, 'Ferny'), (853.3908045977012, 'Fiona'), (376.47888446215137, 'Flavia'), (451.5810397553517, 'Florencia'), (999.2, 'Frances'), (570.534951862704, 'Francesca'), (903.1666666666666, 'Francisca'), (437.05298013245033, 'Francoise'), (949.6575342465753, 'Franziska'), (1244.3333333333333, 'Frederikke'), (544.1627906976744, 'Freya'), (696.7697332607512, 'Gabriela'), (994.0612244897959, 'Gabriela Nicole'), (792.5, 'Gabriella'), (985.7211538461538, 'Gabrielle Faith'), (1052.8314606741574, 'Gaelle'), (759.5352697095435, 'Gaia'), (526.2644836272041, 'Gail'), (305.19563522992985, 'Galina'), (606.7211740041929, 'Ganna'), (229.3774193548387, 'Garbine'), (1152.142857142857, 'Gebriela'), (772.2857142857143, 'Genevieve'), (533.5940594059406, 'Georgia'), (763.1014492753624, 'Georgia Andreea'), (1153.9166666666667, 'Georgiana'), (396.225, 'Georgina'), (1150.6607142857142, 'Ghislaine'), (813.1351351351351, 'Giada'), (567.8518518518518, 'Gioia'), (960.4941860465116, 'Giorgia'), (1226.5, 'Giorgie'), (1197.0, 'Giovanna'), (693.6215943491422, 'Giulia'), (584.359375, 'Giuliana'), (794.7118644067797, 'Gloria'), (716.3150684931506, 'Gozal'), (454.06233062330625, 'Grace'), (783.8288043478261, 'Gracia'), (547.277108433735, 'Greetje'), (296.8219584569733, 'Greta'), (797.383606557377, 'Guadalupe'), (1027.0, 'Guillermina'), (957.9512195121952, 'Guiomar'), (1168.3396226415093, 'Gulben'), (1196.0, 'Gulchekhra'), (1236.6153846153845, 'Gulnaz'), (995.4074074074074, 'Guzal'), (1087.6216216216217, 'Gyulnara'), (1051.623188405797, 'Habiba'), (844.3856812933026, 'Hae Sung'), (1179.4153846153847, 'Haine'), (1110.5376344086021, 'Hana'), (957.2, 'Hanna'), (543.968253968254, 'Hanyu'), (680.1050228310502, 'Hao Chen'), (1153.936507936508, 'Hao Ching'), (574.8723404255319, 'Harmony'), (694.341935483871, 'Harriet'), (774.6837606837607, 'Haruka'), (512.1515151515151, 'Haruna'), (914.5321100917431, 'Hayley'), (1214.7692307692307, 'Hazal'), (167.50632911392404, 'Heather'), (417.44323483670297, 'Heidi'), (1019.4107142857143, 'Helen'), (696.4752475247525, 'Helene'), (1095.1176470588234, 'Hikari'), (673.6635071090047, 'Hilda'), (1219.0, 'Himari'), (534.890243902439, 'Hiroko'), (860.8104265402843, 'Hirono'), (925.9865771812081, 'Ho Ching'), (1185.75, 'Hollie'), (914.8607594936709, 'Hongrui'), (1251.1333333333334, 'Hortencia'), (1107.7142857142858, 'Hsin Yuan'), (726.1737089201878, 'Hua Chen'), (1118.904761904762, 'Huijie'), (888.0055096418732, 'Hulya'), (1020.28125, 'Hye Min'), (1069.3208955223881, 'Hyojung'), (729.0671936758894, 'Hyun Hui'), (1038.6911764705883, 'I Hsuan'), (1085.581818181818, 'Iana'), (962.5, 'Ida'), (1232.2, 'Idia'), (705.5625, 'Iga'), (1135.5, 'Ilay'), (868.2191780821918, 'Ilka'), (452.625, 'Ilona'), (847.0941176470589, 'Ilze'), (845.375, 'Imane Maelle'), (1165.5573770491803, 'Ina'), (1069.0925925925926, 'Inci'), (954.046875, 'India'), (627.7027027027027, 'Indire'), (485.9559748427673, 'Indy'), (919.6147540983607, 'Ineke'), (687.0229885057471, 'Ines'), (1039.0, 'Inger'), (766.2549019607843, 'Ingrid'), (869.3571428571429, 'Ingrid Alexandra'), (748.6622691292876, 'Ingrid Esperanza'), (1192.5454545454545, 'Intissar'), (980.2232142857143, 'Ioana'), (482.43243243243245, 'Ioana Diana'), (646.0441176470588, 'Ioana Loredana'), (799.0552486187845, 'Ionela Andreea'), (655.7828348504552, 'Ipek'), (288.74423480083857, 'Irena'), (579.2153846153847, 'Irene'), (436.84339509862525, 'Irina'), (285.84388185654007, 'Irina Camelia'), (578.1381578947369, 'Irina Maria'), (866.1075949367089, 'Iris'), (489.5294964028777, 'Iryna'), (724.9178743961353, 'Isabel'), (1114.99375, 'Isabela'), (566.7873931623932, 'Isabella'), (781.6993464052288, 'Isabelle'), (1170.9411764705883, 'Iulia Maria'), (732.7386018237082, 'Iva'), (439.81414868105514, 'Ivana'), (871.109375, 'Ivania'), (1079.05, 'Ivanka'), (117.95684523809524, 'Iveta'), (1136.8535031847134, 'Ivette'), (872.0, 'Ivone'), (591.3809523809524, 'Ivonne'), (624.6089494163424, 'Jacqueline'), (909.2, 'Jada'), (739.04802259887, 'Jade'), (760.4920634920635, 'Jaeda'), (562.8450704225352, 'Jaimee'), (1243.875, 'Jaimy Gayle'), (1037.5274725274726, 'Jainy'), (402.36756756756756, 'Jamie'), (1247.3333333333333, 'Jamilya'), (592.5990783410139, 'Jan'), (406.6258503401361, 'Jana'), (240.5306603773585, 'Janette'), (699.7864583333334, 'Janina'), (1262.5416666666667, 'Janja'), (861.5102040816327, 'Janneke'), (748.7238095238096, 'Jaqueline Adina'), (1121.767857142857, 'Jara'), (149.46360759493672, 'Jarmila'), (633.027027027027, 'Jasmin'), (642.1811989100818, 'Jasmina'), (437.86915887850466, 'Jasmine'), (1117.64, 'Jasmine Amber'), (1070.5648854961833, 'Jawairiah'), (1035.46, 'Jazmin'), (983.1290322580645, 'Jazzamay'), (767.7730496453901, 'Jeannine'), (348.19338235294117, 'Jelena'), (556.7936681222708, 'Jennifer'), (902.1470588235294, 'Jenny'), (501.5860215053763, 'Jesika'), (655.7464059804486, 'Jessica'), (818.2043795620438, 'Jessika'), (967.6708860759494, 'Jessy'), (823.9789029535865, 'Ji Hee'), (833.5061082024433, 'Ji Young'), (1169.6923076923076, 'Jia'), (682.961038961039, 'Jia Jing'), (529.7777777777778, 'Jia Qi'), (794.4931506849315, 'Jiahui'), (1230.6, 'Jiakang'), (1232.032258064516, 'Jiatian'), (578.5, 'Jiaxi'), (1161.0, 'Jiaxue'), (114.05571428571429, 'Jie'), (501.0619469026549, 'Jil Belen'), (1116.4190476190477, 'Jil Nora'), (121.9579326923077, 'Jill'), (721.14, 'Jillian'), (1267.0, 'Jin'), (492.8915187376726, 'Jin A'), (1035.6470588235295, 'Jin Ju'), (369.1620469083156, 'Jing Jing'), (863.3225806451613, 'Joana'), (931.025641025641, 'Joanna'), (1227.8, 'Joanne'), (925.4230769230769, 'Jodie Anna'), (1111.8333333333333, 'Johana'), (310.3405299313052, 'Johanna'), (1022.6198347107438, 'Jordana'), (924.9325842696629, 'Josepha'), (684.4892086330935, 'Josephine'), (993.2105263157895, 'Josie'), (601.9846625766871, 'Jovana'), (812.6, 'Ju Eun'), (1224.0, 'Judith'), (1243.904761904762, 'Jule'), (576.9173467252564, 'Julia'), (1024.6666666666667, 'Julia Mansano'), (1110.0816326530612, 'Juliana'), (1175.7666666666667, 'Juliana Rocha'), (512.3787128712871, 'Julie'), (707.1467889908257, 'Julieta Lara'), (1019.9411764705883, 'Julita'), (732.1666666666666, 'Julyette Maria Josephine'), (1189.0, 'June'), (262.30884808013354, 'Junri'), (1212.9166666666667, 'Justina'), (521.5358361774744, 'Justine'), (585.8517745302714, 'Justyna'), (1055.020202020202, 'Kady'), (272.08855291576674, 'Kai Chen'), (522.6561403508772, 'Kai Lin'), (127.06775067750678, 'Kaia'), (901.3333333333334, 'Kaitlin'), (756.2549019607843, 'Kaitlyn'), (633.5454545454545, 'Kaja'), (661.9589041095891, 'Kajsa'), (568.2547169811321, 'Kamila'), (1162.8301886792453, 'Kamilla'), (765.1395348837209, 'Kamonwan'), (924.2782608695652, 'Kana'), (635.346516007533, 'Kanae'), (1105.3125, 'Kanako'), (799.9940828402367, 'Kanami'), (962.8536585365854, 'Kanika'), (871.0790513833992, 'Kaori'), (674.9672514619883, 'Karen'), (1068.9166666666667, 'Kariann'), (472.338003502627, 'Karin'), (883.6090909090909, 'Karina'), (696.9606060606061, 'Karina Ildor'), (1062.795918367347, 'Karina Kristina'), (868.8904109589041, 'Karine'), (1001.0679611650486, 'Karis'), (807.616, 'Karla'), (652.917808219178, 'Karman'), (928.3333333333334, 'Karola Patricia'), (1077.8095238095239, 'Karolayne'), (586.9412296564195, 'Karolina'), (873.6229508196722, 'Karoline'), (903.5769230769231, 'Karyn'), (927.0350877192982, 'Kassandra'), (331.93949394939494, 'Katalin'), (401.0998263888889, 'Katarina'), (459.29286608260327, 'Katarzyna'), (1117.7142857142858, 'Kate'), (491.8507295173962, 'Katerina'), (294.33209990749305, 'Kateryna'), (680.677700348432, 'Katharina'), (882.1071428571429, 'Katharine'), (836.6804511278195, 'Katherine'), (910.396694214876, 'Katherine Gabriela'), (415.7, 'Kathinka'), (291.4792817679558, 'Kathrin'), (620.9404580152672, 'Katie'), (1111.08, 'Katrine Isabel'), (492.6608695652174, 'Katy'), (1050.7, 'Katya'), (1010.1818181818181, 'Katyarina'), (583.1686746987951, 'Kayla'), (1163.3478260869565, 'Kaylah'), (772.2402912621359, 'Kazusa'), (1003.1212121212121, 'Kei'), (1114.9433962264152, 'Kelia'), (804.873831775701, 'Kelly'), (312.7584269662921, 'Kelly S'), (1012.325, 'Kelsey'), (807.7222222222222, 'Kennedy'), (643.422641509434, 'Keren'), (1018.6534653465346, 'Keri'), (1020.4271844660194, 'Kerstin'), (978.0229885057471, 'Khristina'), (1164.090909090909, 'Ki Ryang'), (287.71625344352617, 'Kiki'), (687.3120567375887, 'Kim'), (762.4081632653061, 'Kim Alice'), (846.9154228855722, 'Kimberley'), (618.6923076923077, 'Kimberly'), (1097.219512195122, 'Kimika'), (95.03465982028241, 'Kimiko'), (606.1467576791808, 'Kinnie'), (308.64912280701753, 'Kirsten'), (1035.0384615384614, 'Kirsten Andrea'), (576.9, 'Klaartje'), (235.31431431431432, 'Klara'), (780.7905027932961, 'Klaudia'), (826.0238095238095, 'Komola'), (567.0507399577167, 'Korina'), (844.7460317460317, 'Kotomi'), (522.984693877551, 'Krista'), (445.18918918918916, 'Kristie'), (343.25546975546973, 'Kristina'), (1060.5633802816901, 'Kristina N'), (837.7730496453901, 'Kristy'), (443.8467908902692, 'Kristyna'), (482.36648501362396, 'Ksenia'), (990.6, 'Kseniia'), (975.6271186440678, 'Ksenija'), (488.76107382550333, 'Kumiko'), (165.96132596685084, 'Kurumi'), (159.62397820163488, 'Kveta'), (1070.0377358490566, 'Kwan Yau'), (887.502487562189, 'Kyle'), (798.3181818181819, 'Kylie'), (348.54794520547944, 'Kyoka'), (443.76148409893995, 'Kyra'), (533.433770014556, 'Kyung Mi'), (677.4458598726114, 'Laetitia'), (996.8148148148148, 'Laili'), (1062.3666666666666, 'Lamis'), (643.6939163498099, 'Lara'), (1054.9019607843138, 'Larikah'), (504.4145867098865, 'Laura'), (910.5714285714286, 'Laura D'), (516.1982942430703, 'Laura Ioana'), (1198.1538461538462, 'Laura Sofia'), (484.9442231075697, 'Lauren'), (1107.0882352941176, 'Lauryn'), (612.736, 'Lavinia'), (1226.076923076923, 'Laylo'), (1184.0, 'Layne'), (858.4107142857143, 'Lea'), (1179.6216216216217, 'Leah'), (908.156862745098, 'Lee'), (594.9436936936937, 'Lena'), (657.8934169278997, 'Lena Marie'), (451.33577981651376, 'Lenka'), (773.5666666666667, 'Leolia'), (825.972972972973, 'Leonie'), (887.4545454545455, 'Lesedi Sheya'), (205.17590361445784, 'Lesia'), (514.7174515235457, 'Lesley'), (1180.5454545454545, 'Leslie'), (481.3229166666667, 'Leticia'), (1072.4, 'Leticia Garcia'), (1030.5, 'Leylah Annie'), (988.7425149700599, 'Li'), (387.87113402061857, 'Liana Gabriela'), (899.9150326797386, 'Libby'), (1035.327868852459, 'Libi'), (1147.8529411764705, 'Lidia'), (797.2128378378378, 'Lidziya'), (284.8326771653543, 'Liezel'), (567.9464544138929, 'Liga'), (722.5087719298245, 'Lilla'), (497.42124542124543, 'Lin'), (574.9808362369338, 'Lina'), (929.4398496240601, 'Linda'), (275.6055900621118, 'Lindsay'), (986.82, 'Lindsey'), (418.81925343811395, 'Ling'), (1184.7222222222222, 'Liniques'), (959.6981132075472, 'Linnea'), (356.0105210420842, 'Lisa'), (758.06, 'Lisa Maria'), (996.0408163265306, 'Lisa Marie'), (673.6507936507936, 'Lisanne'), (887.2875, 'Liubov'), (1179.875, 'Livia'), (870.9007633587786, 'Liz Tatiane'), (1120.5652173913043, 'Lizaveta'), (666.1496062992126, 'Lizette'), (1231.2727272727273, 'Lorenza'), (972.75, 'Lorraine M'), (680.1724137931035, 'Lou'), (1220.0, 'Loudmilla'), (380.5308641975309, 'Louisa'), (1070.1025641025642, 'Louise'), (188.06095041322314, 'Lourdes'), (907.3557312252965, 'Lu'), (859.8644067796611, 'Luca'), (845.740638002774, 'Lucia'), (885.7495107632094, 'Luciana'), (322.62611607142856, 'Lucie'), (845.986301369863, 'Lucrezia'), (756.3141592920354, 'Lucy'), (846.2727272727273, 'Ludmila'), (787.5416666666666, 'Ludmilla'), (981.7517730496454, 'Luisa'), (820.59375, 'Luisa Marie'), (284.22813688212926, 'Luksika'), (1098.2888888888888, 'Lulu'), (1139.0, 'Luna'), (974.2702702702703, 'Lusine'), (1190.0629921259842, 'Lutfiye'), (982.6666666666666, 'Lyann'), (952.4411764705883, 'Lynn'), (382.82479784366575, 'Lyudmyla'), (607.3360995850622, 'Macall'), (692.1515151515151, 'Macarena'), (324.63613231552165, 'Madalina'), (748.0, 'Maddison'), (1028.0365853658536, 'Madeleine'), (1217.469387755102, 'Madeline'), (1203.5, 'Madina'), (290.64452214452217, 'Madison'), (958.0955414012739, 'Madrie'), (787.0, 'Maegan'), (1139.7, 'Mafalda'), (1173.75, 'Maftuna'), (734.0, 'Magali'), (1036.1214953271028, 'Magalie'), (300.3974358974359, 'Magda'), (443.6296006264683, 'Magdalena'), (1092.7621951219512, 'Magy'), (875.0, 'Mahak'), (1007.15, 'Mahitha'), (687.25, 'Mai'), (745.433962264151, 'Maia'), (1206.6666666666667, 'Maia A'), (438.4245810055866, 'Maiko'), (1152.888888888889, 'Maileen'), (410.8463541666667, 'Mailen'), (896.7413793103449, 'Maja'), (784.8009049773756, 'Makiho'), (516.6615384615385, 'Makoto'), (999.15625, 'Malene'), (1004.7428571428571, 'Malika'), (825.039603960396, 'Malin'), (1031.5342465753424, 'Mallaurie'), (143.48235294117646, 'Mallory'), (947.3333333333334, 'Malou'), (1153.590909090909, 'Mami'), (1202.2692307692307, 'Man Ying Maggie'), (689.891129032258, 'Mana'), (1230.6, 'Mananchaya'), (838.1780821917808, 'Manca'), (361.0, 'Mandy'), (897.0974358974358, 'Manisha'), (622.7673469387755, 'Manon'), (1181.3548387096773, 'Manya'), (908.3962264150944, 'Mara'), (774.64, 'Marcela'), (1143.7957746478874, 'Marcela Guimaraes'), (1247.3636363636363, 'Marcelina'), (657.0171919770773, 'Marcella'), (325.5912596401028, 'Margalita'), (987.6739130434783, 'Margarida'), (611.4060995184591, 'Margarita'), (1051.1224489795918, 'Margaux'), (753.8346456692914, 'Margot'), (526.3698630136986, 'Mari'), (426.6002565198803, 'Maria'), (1190.0833333333333, 'Maria Agustina'), (1072.9591836734694, 'Maria Andrea'), (1188.5277777777778, 'Maria Camila'), (861.5050505050505, 'Maria Constanza De Las Mercedes'), (1119.4897959183672, 'Maria Del Rosario'), (194.2392065344224, 'Maria Elena'), (443.0228531855956, 'Maria Fernanda'), (1170.1830985915492, 'Maria Jesus'), (486.6092544987147, 'Maria Joao'), (306.1794310722101, 'Maria Jose'), (918.0769230769231, 'Maria Lourdes'), (1047.98224852071, 'Maria Paulina'), (359.81081081081084, 'Maria Teresa'), (662.1182795698925, 'Mariam'), (556.0428051001821, 'Mariana'), (730.3831168831168, 'Marianna'), (993.175925925926, 'Marianne'), (1085.4242424242425, 'Mariaryeni'), (695.574074074074, 'Marie'), (300.56296296296296, 'Marie Eve'), (1148.9166666666667, 'Mariia'), (544.2636655948553, 'Marija'), (1215.0, 'Marijana'), (532.6881807180315, 'Marina'), (774.5654761904761, 'Marine'), (279.78655282817505, 'Marion'), (1163.0, 'Mariona'), (1067.3413173652696, 'Marisa'), (281.871335504886, 'Mariya'), (353.44444444444446, 'Marketa'), (946.8934426229508, 'Marlies'), (783.1711711711712, 'Marrit'), (419.32988047808766, 'Marta'), (851.1224489795918, 'Marta Huqi'), (1056.0588235294117, 'Martha'), (751.8679119412942, 'Martina'), (869.1666666666666, 'Mary'), (1188.7096774193549, 'Mary Ann'), (323.86176470588236, 'Maryna'), (355.7223168654174, 'Masa'), (437.11396648044695, 'Mathilde'), (799.1875, 'Matilda'), (1013.4761904761905, 'Maud'), (1070.21875, 'Maureen'), (1121.0869565217392, 'Maurien'), (973.8717948717949, 'Maxine'), (1084.0294117647059, 'May'), (732.4260679079956, 'Maya'), (891.6309523809524, 'Mayar'), (407.029702970297, 'Mayo'), (619.9064748201439, 'Mayya'), (736.4809523809524, 'Megan'), (1025.0, 'Megumi'), (1031.6, 'Mei Xu'), (812.85, 'Meiling'), (1029.1666666666667, 'Meiqi'), (372.32502965599053, 'Melanie'), (1039.8333333333333, 'Melany Solange'), (1017.2560553633218, 'Melina'), (169.13578500707214, 'Melinda'), (634.7950310559006, 'Melis'), (993.1351351351351, 'Melisa'), (1154.093023255814, 'Melissa'), (1104.357142857143, 'Melissa Ishuan'), (1035.95, 'Meng Ning'), (1213.2142857142858, 'Mercedes'), (900.75, 'Merel'), (1182.9107142857142, 'Meritxell'), (337.5292682926829, 'Mervana'), (554.3953934740883, 'Mi'), (1071.3076923076924, 'Mi Jeong'), (992.7225433526012, 'Mi Rae'), (999.375, 'Mi Zhuoma'), (987.504761904762, 'Mia Nicole'), (1332.0737704918033, 'Micaela'), (676.90589198036, 'Michaela'), (185.3469387755102, 'Michaella'), (1228.9285714285713, 'Michela'), (946.8846153846154, 'Michele Alexandra'), (280.79959100204496, 'Michelle'), (718.047619047619, 'Michika'), (376.7356115107914, 'Mihaela'), (1223.4, 'Mihaela Lorena'), (523.2788844621514, 'Miharu'), (1064.142857142857, 'Mihika'), (1110.4411764705883, 'Mihoki'), (586.2250489236791, 'Miki'), (1201.16, 'Mila'), (1234.2857142857142, 'Milagros'), (626.441935483871, 'Milana'), (1114.4074074074074, 'Milena'), (1221.904761904762, 'Milica'), (866.0693069306931, 'Min'), (819.8425531914894, 'Min Hwa'), (1238.0625, 'Minami'), (788.2622950819672, 'Mira'), (721.1643835616438, 'Mirabelle'), (1169.4864864864865, 'Miranda'), (912.120218579235, 'Miriam'), (628.075, 'Miriam Bianca'), (950.6263736263736, 'Miriana'), (843.6428571428571, 'Mirjam'), (186.76587795765877, 'Mirjana'), (617.0379241516966, 'Misa'), (208.95263157894738, 'Misaki'), (1121.04, 'Mitsumi'), (447.93283582089555, 'Miyabi'), (594.9036697247707, 'Miyu'), (593.1506849315068, 'Mizuno'), (1029.0, 'Molly'), (772.6981132075472, 'Momoko'), (273.57517899761336, 'Mona'), (210.0846394984326, 'Monica'), (980.575, 'Monika'), (462.4270462633452, 'Monique'), (541.952380952381, 'Montserrat'), (880.6527777777778, 'Morgane'), (1243.4, 'Moulika'), (1258.5, 'Mouna'), (1198.25, 'Moyuka'), (1227.0, 'Muazzez'), (1186.9444444444443, 'Muge'), (485.40168539325845, 'Myrtille'), (82.13112391930835, 'Na'), (608.7791798107255, 'Na Lae'), (573.5197368421053, 'Na Ri'), (868.6521739130435, 'Nadezda'), (407.5463976945245, 'Nadia'), (637.4607407407408, 'Nadiya'), (631.8181818181819, 'Nadja'), (828.0675675675676, 'Nagi'), (767.4963503649635, 'Naiktha'), (930.7027027027027, 'Naima'), (878.6666666666666, 'Nam Yeon'), (890.4455445544554, 'Nan Nan'), (542.7168141592921, 'Nanuli'), (313.45625, 'Nao'), (1180.3828125, 'Naoko'), (483.97225572979494, 'Naomi'), (929.4388489208633, 'Napatsakorn'), (1138.9166666666667, 'Nastassia'), (554.5290322580645, 'Nastassja'), (593.1772853185596, 'Nastja'), (720.132932166302, 'Natalia'), (577.9677419354839, 'Natalie'), (634.3620689655172, 'Natalija'), (1247.909090909091, 'Nataliya'), (666.2853403141361, 'Natasa'), (883.0777142857143, 'Natasha'), (566.4943396226415, 'Natela'), (962.0188679245283, 'Natella'), (543.031185031185, 'Nathalia'), (617.4615384615385, 'Nathaly'), (929.6928104575163, 'Natia'), (547.7037037037037, 'Natsumi'), (1177.622641509434, 'Nattawadee'), (1087.3823529411766, 'Naz'), (825.7291666666666, 'Nazari'), (745.421052631579, 'Neda'), (1164.107142857143, 'Nelise'), (1069.15, 'Nermeen'), (1031.0, 'Nevena'), (515.3191489361702, 'Nicha'), (843.9007633587786, 'Nicky'), (753.2253164556962, 'Nicola'), (499.4127634660422, 'Nicole'), (485.46875, 'Nicoleta Catalina'), (778.1648648648649, 'Nicolette'), (762.1578947368421, 'Nidhi'), (376.7617554858934, 'Nigina'), (913.4380165289256, 'Nika'), (1174.0, 'Nikita'), (1017.3134328358209, 'Nikki'), (1054.0813953488373, 'Nikol'), (723.484076433121, 'Nikola'), (528.8673050615595, 'Nina'), (1124.1666666666667, 'Nina Isabella'), (841.0514705882352, 'Nives'), (965.5343511450382, 'Noel'), (1049.834745762712, 'Noelia'), (883.7787610619469, 'Noelle'), (1167.2758620689656, 'Nonna'), (374.93926247288505, 'Noppawan'), (921.6216216216217, 'Nora'), (1096.1140350877192, 'Nour'), (936.3392857142857, 'Nozomi'), (436.66881028938906, 'Nudnida'), (537.577922077922, 'Nungnadda'), (395.6680227827502, 'Nuria'), (1027.1382978723404, 'Oana'), (686.3047619047619, 'Oana Georgeta'), (728.7630208333334, 'Oceane'), (839.4923664122138, 'Ofri'), (533.9652351738241, 'Oksana'), (660.8924731182796, 'Ola'), (1397.5, 'Olawaseun'), (1112.75, 'Olaya'), (903.4289156626506, 'Oleksandra'), (1179.1555555555556, 'Olena'), (501.44444444444446, 'Olesya'), (432.6511627906977, 'Olga'), (446.7231833910035, 'Olivia'), (1006.5128205128206, 'Oliwia'), (435.1470588235294, 'Ons'), (978.7321428571429, 'Ornella'), (866.0454545454545, 'Oyku'), (1156.28125, 'Paige Mary'), (989.1904761904761, 'Pamela'), (683.1081081081081, 'Panna'), (132.12638580931264, 'Paola'), (1099.625, 'Parris'), (863.5507246376811, 'Patcharin'), (572.8059701492538, 'Patricia'), (403.935, 'Patricia Maria'), (657.3816155988858, 'Patrycja'), (385.8135593220339, 'Patty'), (558.0162601626016, 'Paula'), (1175.909090909091, 'Paula Andrea'), (868.7624113475177, 'Paula Catalina'), (508.4679802955665, 'Paula Cristina'), (1035.7780678851175, 'Paulina'), (298.1861898890259, 'Pauline'), (915.5892857142857, 'Pavla'), (514.586319218241, 'Peangtarn'), (755.5813953488372, 'Peggy'), (673.9809523809524, 'Pei Chi'), (1106.5, 'Pei Hsuan'), (1061.3076923076924, 'Pei Ju'), (465.24962852897477, 'Pemra'), (619.4154929577464, 'Pernilla'), (710.3972602739726, 'Petia'), (365.50280484204313, 'Petra'), (1211.0, 'Phenomena'), (826.6486486486486, 'Phillis'), (737.862676056338, 'Pia'), (668.2581196581197, 'Piia'), (740.5879828326181, 'Pilar'), (1041.0740740740741, 'Pippa'), (937.7945205479452, 'Plobrung'), (630.7953529937444, 'Polina'), (478.30369515011546, 'Polona'), (729.1047904191616, 'Poojashree'), (795.4736842105264, 'Pranjala'), (653.5070422535211, 'Prarthana G'), (740.5361842105264, 'Prerna'), (1137.19, 'Priscila'), (675.4124293785311, 'Priscilla'), (383.4714587737844, 'Qiang'), (826.1388888888889, 'Qianhui'), (943.421052631579, 'Qianqian'), (705.8493150684932, 'Qiu Yu'), (883.2352941176471, 'Quinn'), (633.9770491803279, 'Quirine'), (859.2706766917294, 'Rachael'), (1147.8526315789475, 'Rachel'), (955.7833333333333, 'Radina'), (1121.2432432432433, 'Rafaela'), (1176.5, 'Ralina'), (304.4619771863118, 'Raluca'), (672.2258064516129, 'Raluca Elena'), (539.6164383561644, 'Raluca Georgiana'), (1010.4545454545455, 'Ramu'), (1121.8846153846155, 'Ramya'), (598.2655172413793, 'Ran'), (1117.6666666666667, 'Rana'), (700.7644444444444, 'Raquel'), (1089.2100840336134, 'Rashmi'), (1021.6504854368932, 'Ratnika'), (487.6268656716418, 'Raveena'), (1145.4333333333334, 'Rebeca'), (568.3374316939891, 'Rebecca'), (676.1090909090909, 'Rebeka'), (289.60283687943263, 'Regina'), (1019.0, 'Reina'), (323.1388101983003, 'Reka Luca'), (494.6111111111111, 'Remi'), (274.85317919075146, 'Renata'), (669.448275862069, 'Ria'), (638.6666666666666, 'Rianna'), (246.19871794871796, 'Richel'), (290.0614657210402, 'Rika'), (495.22641509433964, 'Riko'), (1125.0363636363636, 'Rio'), (489.65909090909093, 'Risa'), (775.7269624573379, 'Rishika'), (1051.7349397590363, 'Rita'), (651.4246575342465, 'Riya'), (150.96681415929203, 'Roberta'), (431.19607843137254, 'Robin'), (1054.606896551724, 'Robyn'), (795.6201232032854, 'Rocio'), (402.49931972789113, 'Romana'), (669.8542372881356, 'Romana Caroline'), (283.63246554364474, 'Romina'), (758.1714285714286, 'Romy'), (1125.5471698113208, 'Rona'), (427.0, 'Ronit'), (1072.857142857143, 'Ronke'), (1168.2857142857142, 'Roosh'), (965.0, 'Rosa'), (1059.73, 'Rosalia'), (1066.5887096774193, 'Rosalie'), (984.1714285714286, 'Rosie'), (479.51738241308794, 'Roxane'), (1209.625, 'Rui'), (573.8729603729604, 'Rushmi'), (808.5096774193548, 'Rutuja'), (1069.0379746835442, 'Ryann'), (1117.88, 'Saana'), (982.7397260273973, 'Sabastiani'), (682.2005532503458, 'Sabina'), (1184.6666666666667, 'Sabina Elena'), (203.5871080139373, 'Sabine'), (905.6324786324786, 'Sabrina'), (340.2890442890443, 'Sacha'), (400.8093385214008, 'Sachia'), (368.26881720430106, 'Sachie'), (665.8219178082192, 'Sadafmoh'), (998.5238095238095, 'Sai Samhitha'), (297.39032258064515, 'Saisai'), (832.9585365853659, 'Sakiko'), (529.583908045977, 'Sally'), (1204.6666666666667, 'Salma'), (406.21702404158543, 'Samantha'), (932.8940397350993, 'Samira'), (1105.171875, 'Sanae'), (703.1372549019608, 'Sanaz'), (563.964505613908, 'Sandra'), (1028.9565217391305, 'Sandy'), (857.9508196721312, 'Sang Hee'), (177.22695035460993, 'Sania'), (509.80945757997216, 'Sara'), (546.5551763367463, 'Sarah'), (875.9277108433735, 'Sarah Beth'), (743.6062176165804, 'Sarah Rebecca'), (1139.2340425531916, 'Sarahi'), (1191.6470588235295, 'Sarai Delfina'), (840.0776699029126, 'Saray'), (1081.1666666666667, 'Sari'), (1209.7777777777778, 'Sarlota'), (1235.1960784313726, 'Sarvinoz'), (1033.027027027027, 'Sasa'), (747.3695652173913, 'Saska'), (888.7272727272727, 'Satsuki'), (1142.9285714285713, 'Savannah'), (1188.2941176470588, 'Schena'), (1210.2571428571428, 'Se Hyun'), (1122.4545454545455, 'Se Jin'), (1240.92, 'Sean'), (1003.5367647058823, 'Seda'), (1115.72, 'Seira'), (1168.6571428571428, 'Selin'), (858.9173789173789, 'Seo Kyung'), (889.8028169014085, 'Seone'), (14.654294803817603, 'Serena'), (162.3505747126437, 'Sesil'), (784.0465949820789, 'Seung Yeon'), (218.4701086956522, 'Severine'), (166.41358024691357, 'Shahar'), (924.8818897637796, 'Shakhlo'), (1236.7627118644068, 'Shakhnoza'), (1228.3235294117646, 'Shangqing'), (694.2, 'Shanshan'), (967.9034090909091, 'Shao Yuan'), (851.5633802816901, 'Sharmada'), (296.5792682926829, 'Sharon'), (1097.0, 'Sharon Sanchana'), (372.89398280802294, 'Shelby'), (1171.0, 'Shelly'), (451.8657487091222, 'Sheng Nan'), (649.5154639175257, 'Sherazad'), (1024.0116279069769, 'Sherry'), (500.688679245283, 'Shiho'), (632.2824427480916, 'Shilin'), (1070.6666666666667, 'Shiori'), (1154.4166666666667, 'Shir'), (1187.9245283018868, 'Shiran'), (935.2322946175638, 'Shivika'), (1120.388888888889, 'Shou Na'), (1148.0, 'Shreya'), (1042.6802325581396, 'Shu Ying'), (167.90740740740742, 'Shuai'), (421.44179894179894, 'Shuko'), (864.1538461538462, 'Shuo'), (966.0588235294117, 'Shuyue'), (897.6951219512196, 'Shweta'), (1047.7575757575758, 'Si Qi'), (565.8211508553654, 'Silvia'), (542.2382851445662, 'Simona'), (1070.3417721518988, 'Simone'), (974.8, 'Simran Kaur'), (728.7443609022556, 'Sina'), (975.3484848484849, 'Sinead'), (1141.842105263158, 'Sing Le'), (980.9076923076923, 'Siqi'), (949.7916666666666, 'Sirui'), (1241.1379310344828, 'Siyu'), (259.63589743589745, 'Sloane'), (1184.8260869565217, 'Smriti'), (1225.388888888889, 'Sneha'), (632.3150684931506, 'Snehadevi S'), (514.1732026143791, 'So Jung'), (572.2654545454545, 'So Ra'), (526.3535641547861, 'Sofia'), (1084.107142857143, 'Sofico'), (724.5, 'Sofie'), (541.1570881226054, 'Sofiya'), (640.8727272727273, 'Sofya'), (1004.6666666666666, 'Sohyun'), (1029.0980392156862, 'Sonia'), (885.0976744186047, 'Sonja'), (1221.3333333333333, 'Sophia'), (600.6881091617934, 'Sophie'), (213.75043630017453, 'Sorana'), (813.1357142857142, 'Sowjanya'), (1149.3125, 'Spurti'), (792.1927710843373, 'Sri Vaishnavi'), (841.8387096774194, 'Stamatia'), (312.54158964879855, 'Stanislava'), (993.4255319148937, 'Stefana'), (1167.3333333333333, 'Stefani'), (759.2894995093228, 'Stefania'), (387.73412112259973, 'Stefanie'), (939.746835443038, 'Steffi'), (439.87772357723577, 'Stephanie'), (1035.5548387096774, 'Stephanie Mariel'), (573.6708333333333, 'Storm'), (426.3886462882096, 'Su Jeong'), (217.2493188010899, 'Su Wei'), (911.7619047619048, 'Suellen'), (944.2432432432432, 'Sultan'), (812.4581005586592, 'Sun Jung'), (1229.8, 'Sunae'), (611.0757575757576, 'Sunam'), (635.7449168207024, 'Sung Hee'), (1015.6792452830189, 'Susan'), (417.8053097345133, 'Susanne'), (982.7222222222222, 'Suzan'), (980.6666666666666, 'Suzuho'), (698.7567567567568, 'Suzy'), (844.203007518797, 'Svenja'), (267.03227571115974, 'Svetlana'), (691.9934640522875, 'Sviatlana'), (1002.6792452830189, 'Sybille'), (869.1702127659574, 'Sylvia'), (787.7645348837209, 'Sylwia'), (791.1240506329113, 'Syna'), (772.3186813186813, 'Szabina'), (343.0985324947589, 'Tadeja'), (969.6588235294117, 'Taisiya'), (1230.2, 'Talya'), (949.8059701492538, 'Tamachan'), (1118.4166666666667, 'Tamar'), (614.0434782608696, 'Tamara'), (1146.3934426229507, 'Tamari'), (121.82273948075202, 'Tamarine'), (386.7025316455696, 'Tamaryn'), (135.88910505836577, 'Tamira'), (601.906914893617, 'Tammi'), (1113.2325581395348, 'Tanaporn'), (1023.089430894309, 'Tanya'), (475.2979683972912, 'Tara'), (1075.0, 'Tatia'), (681.9417582417583, 'Tatiana'), (247.7449768160742, 'Tatjana'), (912.1077844311377, 'Tatsiana'), (747.3172413793103, 'Tayisiya'), (387.5662100456621, 'Taylor'), (1068.7457627118645, 'Tea'), (461.06702898550725, 'Teliana'), (614.9346733668342, 'Tena'), (489.27513227513225, 'Teodora'), (557.241418764302, 'Tereza'), (963.5, 'Terri'), (696.2878787878788, 'Tess'), (390.2361111111111, 'Tessah'), (437.4119658119658, 'Tetiana'), (398.83478260869566, 'Tetyana'), (802.7222222222222, 'Thai Sa Grana'), (650.1206896551724, 'Theo'), (1159.5632183908046, 'Theresa'), (1017.7777777777778, 'Tijana'), (182.02426160337552, 'Timea'), (425.82394366197184, 'Tina'), (810.6666666666666, 'Tinatin'), (739.7727272727273, 'Ting Fei'), (789.6113989637306, 'Ting Jr'), (1015.2352941176471, 'Tingting'), (743.1953125, 'Tjasa'), (838.8065217391304, 'Tomoko'), (841.7167381974249, 'Tori'), (878.1666666666666, 'Tornado Alicia'), (1029.3196721311476, 'Trang'), (1009.8666666666667, 'Treta'), (131.02074074074073, 'Tsvetana'), (992.4870588235294, 'Tyra'), (506.39344262295083, 'Ulrikke'), (844.0692307692308, 'Ulyana'), (229.35687022900763, 'Urszula'), (1132.4109589041095, 'Ushna'), (411.5068493150685, 'Usue Maitane'), (921.3333333333334, 'Valentina'), (751.2668918918919, 'Valentine'), (479.8914728682171, 'Valentini'), (368.14331210191085, 'Valentyna'), (661.8474576271186, 'Valeria'), (806.2648401826484, 'Valerie'), (799.8668224299065, 'Valeriya'), (696.4126984126984, 'Vanda'), (579.437984496124, 'Vanesa'), (398.3106546854942, 'Vanessa'), (185.75, 'Vania'), (1130.6037735849056, 'Vaniya'), (1089.7111111111112, 'Vanja'), (450.4642082429501, 'Varatchaya'), (894.3846153846154, 'Varunya'), (382.6888217522659, 'Varvara'), (613.5330490405117, 'Vasilisa'), (859.8103448275862, 'Vaszilisza'), (729.0117647058823, 'Vendula'), (32.984862819299906, 'Venus'), (195.66923570969814, 'Vera'), (958.1327800829876, 'Verena'), (726.1852387843704, 'Veronica'), (951.0075757575758, 'Veronica M'), (734.6018957345972, 'Veronika'), (240.0448979591837, 'Vesna'), (1252.9130434782608, 'Vicky'), (1138.8490566037735, 'Victoire'), (444.9760935910478, 'Victoria'), (1236.0, 'Victoria Ariadna'), (566.9148936170212, 'Viktoria'), (1236.5333333333333, 'Viktoriia'), (507.4, 'Viktorija'), (736.2288557213931, 'Viktoriya'), (966.4671052631579, 'Viktoryia'), (1243.0, 'Vilma Y'), (1214.1142857142856, 'Vincenza'), (1150.0, 'Vinciane'), (1170.840579710145, 'Violetta'), (355.88102893890675, 'Virginie'), (1208.952380952381, 'Vishesh'), (1201.25, 'Vita'), (296.2025641025641, 'Vitalia'), (670.9108527131783, 'Vivian'), (607.2810218978102, 'Vivien'), (659.2103004291846, 'Vivienne'), (595.3291666666667, 'Vlada'), (943.5432098765432, 'Vladica'), (823.8770833333333, 'Vladimira'), (1006.1769911504425, 'Vladislava'), (856.0782608695653, 'Vladyslava'), (555.6572164948453, 'Vojislava'), (999.0215053763441, 'Voni'), (701.4009009009009, 'Wan Ting'), (1081.142857142857, 'Wan Yi'), (1249.3333333333333, 'Warona'), (440.35214446952597, 'Wen Hsin'), (1117.55, 'Wen Ling'), (1011.469696969697, 'Wendy Qi Wen'), (1152.7837837837837, 'Weronika Jasmina'), (886.1407407407407, 'Whitney'), (1083.1454545454546, 'Wiktoria'), (585.2589641434263, 'Wing Yau Venise'), (937.7878787878788, 'Wushuang'), (661.2222222222222, 'Xenia'), (714.8653846153846, 'Xi Yao'), (814.4171122994652, 'Xiao'), (467.24657534246575, 'Xiaodi'), (848.4418604651163, 'Xiaorong'), (737.7547169811321, 'Xiaoxi'), (712.2780373831775, 'Ximena'), (694.4808743169399, 'Xin'), (1022.3333333333334, 'Xin Yu'), (480.646017699115, 'Xinyu'), (309.35767790262173, 'Xinyun'), (954.6, 'Xiyu'), (488.7671232876712, 'Xu Liu'), (1225.75, 'Ya'), (586.865, 'Ya Hsuan'), (325.6162790697674, 'Yafan'), (768.560975609756, 'Yan'), (740.0214504596527, 'Yana'), (1177.8823529411766, 'Yang'), (381.2581602373887, 'Yanina'), (1059.2702702702702, 'Yanni'), (1166.875, 'Yarden'), (211.41240310077518, 'Yaroslava'), (702.1784386617101, 'Yasmin'), (1227.7777777777778, 'Yasmina'), (983.0410958904109, 'Yasmine'), (1261.8181818181818, 'Yasmyn'), (1110.4594594594594, 'Yawna'), (114.78806907378336, 'Yayuk'), (431.3144424131627, 'Ye Ra'), (1048.081081081081, 'Ye Xin'), (1155.8191489361702, 'Yekaterina'), (897.4873949579832, 'Yelena'), (973.8617021276596, 'Yeong Won'), (724.8712871287129, 'Yevgeniya'), (791.0756207674943, 'Yi'), (381.5512572533849, 'Yi Fan'), (656.8787276341948, 'Yi Jing'), (418.2566137566138, 'Yi Miao'), (1185.030303030303, 'Yidi'), (1209.625, 'Yihong'), (1063.9411764705883, 'Yijia'), (661.3972602739726, 'Ying'), (403.8775981524249, 'Ying Ying'), (801.6712328767123, 'Yixuan'), (892.3561643835617, 'Ylena'), (642.9487179487179, 'Ylona Georgiana'), (1128.901098901099, 'Yoko'), (1068.4619883040937, 'Yolande'), (1263.7666666666667, 'Yoo Ri'), (844.9310344827586, 'Yoon Young'), (1096.9130434782608, 'Yoshimi'), (1222.24, 'Yosr'), (1170.3461538461538, 'You Na'), (458.86633663366337, 'Ysaline'), (1098.357142857143, 'Yu Jin'), (1239.6666666666667, 'Yu Tong'), (1054.0, 'Yuan'), (891.2340425531914, 'Yuanyi'), (983.359649122807, 'Yue'), (444.96190476190475, 'Yue Yue'), (961.876923076923, 'Yuenu'), (1034.1304347826087, 'Yujia'), (748.8250591016548, 'Yuka'), (1071.5833333333333, 'Yukako'), (876.7428571428571, 'Yuki'), (698.8285714285714, 'Yuki Kristina'), (857.1692307692308, 'Yukina'), (824.3936170212766, 'Yukun'), (485.35135135135135, 'Yulia'), (725.5322195704057, 'Yuliana'), (384.87776983559684, 'Yuliya'), (799.1332586786115, 'Yumi'), (166.6586270871985, 'Yung Jan'), (1047.3529411764705, 'Yuqi'), (322.17758620689654, 'Yurika'), (1041.5367231638418, 'Yuriko'), (746.4803493449782, 'Yurina'), (608.1309090909091, 'Yuuki'), (1230.2, 'Yuval'), (545.449074074074, 'Yuxuan'), (318.2867132867133, 'Yvonne'), (1227.344827586207, 'Zaineb'), (867.5288461538462, 'Zalina'), (709.625, 'Zarah'), (222.81428571428572, 'Zarina'), (791.2352941176471, 'Zeel'), (1229.5714285714287, 'Zeynep  Sena'), (627.7777777777778, 'Zhanlan'), (629.0081967213115, 'Zhaoxuan'), (1058.0, 'Zhibek'), (1144.45, 'Zhima'), (1237.9, 'Zhou'), (989.75, 'Zhuoma'), (391.4656290531777, 'Zi'), (1221.5, 'Zinovia'), (878.4606741573034, 'Ziyue'), (765.3777777777777, 'Zoe'), (935.081081081081, 'Zoe Gwen'), (916.559633027523, 'Zsofia'), (451.92875448487956, 'Zuzana'), (794.5416666666666, 'Zuzanna')]",,1.0,
find the number of players for each country.,"[players.country_code, players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT players.country_code, COUNT(players.player_id) AS player_count FROM players GROUP BY players.country_code;","SELECT count(*) ,  country_code FROM players GROUP BY country_code",wta_1,"1. Sequential Structure: Start with the SELECT clause to specify the country code and the count of players for each country. 2. Aggregation Structure: Use COUNT to calculate the number of players for each country. 3. Grouping Structure: Use GROUP BY on ""players.country_code"" to group the results by country. 4. Join Structure: No JOIN is required since all necessary data is within the ""players"" table.","[('AHO', 6), ('ALB', 2), ('ALG', 63), ('AND', 1), ('ANG', 1), ('ANT', 8), ('ARG', 456), ('ARM', 27), ('AUS', 742), ('AUT', 236), ('AZE', 10), ('BAH', 22), ('BAR', 20), ('BDI', 5), ('BEL', 247), ('BEN', 2), ('BER', 20), ('BIH', 75), ('BLR', 144), ('BOL', 97), ('BOT', 17), ('BRA', 456), ('BRN', 5), ('BRU', 4), ('BUL', 181), ('CAN', 331), ('CGO', 2), ('CHI', 114), ('CHN', 391), ('CMR', 8), ('COL', 240), ('CRC', 24), ('CRO', 240), ('CUB', 39), ('CYP', 22), ('CZE', 456), ('DEN', 79), ('DOM', 38), ('ECA', 3), ('ECU', 90), ('EGY', 112), ('ESA', 33), ('ESP', 853), ('EST', 48), ('ETH', 8), ('FIJ', 5), ('FIN', 103), ('FRA', 736), ('FRG', 22), ('GBR', 660), ('GEO', 91), ('GER', 833), ('GHA', 4), ('GRE', 163), ('GRN', 1), ('GUA', 29), ('GUD', 8), ('HAI', 5), ('HKG', 56), ('HON', 8), ('HUN', 169), ('INA', 181), ('IND', 478), ('IRI', 15), ('IRL', 68), ('IRQ', 7), ('ISL', 18), ('ISR', 232), ('ITA', 866), ('JAM', 19), ('JOR', 6), ('JPN', 823), ('KAZ', 99), ('KEN', 23), ('KGZ', 23), ('KOR', 274), ('KUW', 3), ('LAT', 56), ('LES', 3), ('LIB', 11), ('LIE', 15), ('LTU', 31), ('LUX', 37), ('MAD', 21), ('MAR', 97), ('MAS', 35), ('MDA', 45), ('MEX', 416), ('MGL', 1), ('MKD', 23), ('MLT', 17), ('MNE', 25), ('MON', 2), ('MRI', 15), ('MRN', 4), ('NAM', 13), ('NCA', 3), ('NED', 342), ('NGR', 80), ('NOR', 68), ('NZL', 104), ('OMA', 3), ('PAK', 18), ('PAN', 22), ('PAR', 56), ('PER', 76), ('PHI', 70), ('PNG', 1), ('POC', 12), ('POL', 266), ('POR', 142), ('PUR', 43), ('QAT', 1), ('REU', 17), ('RHO', 3), ('ROU', 422), ('RSA', 283), ('RUS', 810), ('SAM', 3), ('SCG', 16), ('SEN', 7), ('SIN', 44), ('SLO', 145), ('SMR', 4), ('SRB', 224), ('SRI', 32), ('SUI', 243), ('SVK', 247), ('SWE', 324), ('SYR', 21), ('TCH', 21), ('THA', 171), ('TJK', 6), ('TKM', 12), ('TOG', 2), ('TPE', 146), ('TRI', 29), ('TTO', 1), ('TUN', 57), ('TUR', 203), ('UAE', 1), ('UKR', 311), ('UNK', 11), ('URS', 22), ('URU', 56), ('USA', 2217), ('UZB', 123), ('VEN', 150), ('VIE', 19), ('YUG', 48), ('ZAM', 1), ('ZIM', 26), ('rc=', 4)]","[(6, 'AHO'), (2, 'ALB'), (63, 'ALG'), (1, 'AND'), (1, 'ANG'), (8, 'ANT'), (456, 'ARG'), (27, 'ARM'), (742, 'AUS'), (236, 'AUT'), (10, 'AZE'), (22, 'BAH'), (20, 'BAR'), (5, 'BDI'), (247, 'BEL'), (2, 'BEN'), (20, 'BER'), (75, 'BIH'), (144, 'BLR'), (97, 'BOL'), (17, 'BOT'), (456, 'BRA'), (5, 'BRN'), (4, 'BRU'), (181, 'BUL'), (331, 'CAN'), (2, 'CGO'), (114, 'CHI'), (391, 'CHN'), (8, 'CMR'), (240, 'COL'), (24, 'CRC'), (240, 'CRO'), (39, 'CUB'), (22, 'CYP'), (456, 'CZE'), (79, 'DEN'), (38, 'DOM'), (3, 'ECA'), (90, 'ECU'), (112, 'EGY'), (33, 'ESA'), (853, 'ESP'), (48, 'EST'), (8, 'ETH'), (5, 'FIJ'), (103, 'FIN'), (736, 'FRA'), (22, 'FRG'), (660, 'GBR'), (91, 'GEO'), (833, 'GER'), (4, 'GHA'), (163, 'GRE'), (1, 'GRN'), (29, 'GUA'), (8, 'GUD'), (5, 'HAI'), (56, 'HKG'), (8, 'HON'), (169, 'HUN'), (181, 'INA'), (478, 'IND'), (15, 'IRI'), (68, 'IRL'), (7, 'IRQ'), (18, 'ISL'), (232, 'ISR'), (866, 'ITA'), (19, 'JAM'), (6, 'JOR'), (823, 'JPN'), (99, 'KAZ'), (23, 'KEN'), (23, 'KGZ'), (274, 'KOR'), (3, 'KUW'), (56, 'LAT'), (3, 'LES'), (11, 'LIB'), (15, 'LIE'), (31, 'LTU'), (37, 'LUX'), (21, 'MAD'), (97, 'MAR'), (35, 'MAS'), (45, 'MDA'), (416, 'MEX'), (1, 'MGL'), (23, 'MKD'), (17, 'MLT'), (25, 'MNE'), (2, 'MON'), (15, 'MRI'), (4, 'MRN'), (13, 'NAM'), (3, 'NCA'), (342, 'NED'), (80, 'NGR'), (68, 'NOR'), (104, 'NZL'), (3, 'OMA'), (18, 'PAK'), (22, 'PAN'), (56, 'PAR'), (76, 'PER'), (70, 'PHI'), (1, 'PNG'), (12, 'POC'), (266, 'POL'), (142, 'POR'), (43, 'PUR'), (1, 'QAT'), (17, 'REU'), (3, 'RHO'), (422, 'ROU'), (283, 'RSA'), (810, 'RUS'), (3, 'SAM'), (16, 'SCG'), (7, 'SEN'), (44, 'SIN'), (145, 'SLO'), (4, 'SMR'), (224, 'SRB'), (32, 'SRI'), (243, 'SUI'), (247, 'SVK'), (324, 'SWE'), (21, 'SYR'), (21, 'TCH'), (171, 'THA'), (6, 'TJK'), (12, 'TKM'), (2, 'TOG'), (146, 'TPE'), (29, 'TRI'), (1, 'TTO'), (57, 'TUN'), (203, 'TUR'), (1, 'UAE'), (311, 'UKR'), (11, 'UNK'), (22, 'URS'), (56, 'URU'), (2217, 'USA'), (123, 'UZB'), (150, 'VEN'), (19, 'VIE'), (48, 'YUG'), (1, 'ZAM'), (26, 'ZIM'), (4, 'rc=')]",,1.0,
How many different results are there for the battles?,[battle.result],"Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",EASY,SELECT COUNT(DISTINCT battle.result) FROM battle;,SELECT count(DISTINCT RESULT) FROM battle,battle_death,"1. Sequential Structure: Start with the SELECT clause to count the distinct results of battles. 2. Condition Structure: No specific filtering condition is required as we are interested in all battle results. 3. Join Structure: No JOIN is necessary since all the required data is within the ""battle"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique battle results.","[(3,)]","[(3,)]",,1.0,
List the names of teachers who have not been arranged to teach courses.,"[teacher.Name, teacher.Teacher_ID, course_arrange.Teacher_ID = teacher.Teacher_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NESTED,SELECT teacher.Name FROM teacher WHERE teacher.Teacher_ID NOT IN (SELECT course_arrange.Teacher_ID FROM course_arrange);,SELECT Name FROM teacher WHERE Teacher_id NOT IN (SELECT Teacher_id FROM course_arrange),course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of teachers. Use the FROM clause to specify the teacher table. Apply a WHERE clause to filter for teachers who have not been arranged to teach any courses by ensuring their Teacher_ID is not present in the course_arrange table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude teachers whose Teacher_ID appears in the course_arrange table, meaning they have been assigned to teach courses. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Teacher_ID entries in the course_arrange table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Joseph Huts',), ('John Deloor',)]","[('Joseph Huts',), ('John Deloor',)]",,1.0,
List the first name and birth date of all players from the country with code USA.,"[players.first_name, players.birth_date, players.country_code, USA]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT players.first_name, players.birth_date FROM players WHERE players.country_code = 'USA';","SELECT first_name ,  birth_date FROM players WHERE country_code  =  'USA'",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""players.first_name"" and ""players.birth_date"" fields. 2. Condition Structure: Use a WHERE clause to filter players whose ""players.country_code"" is 'USA'. 3. Join Structure: No JOIN is required since all necessary information is in the ""players"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving specific fields based on a condition.","[('Jolene', 19680831), ('Lisa', 19730810), ('Meilen', 19780117), ('Serena', 19810926), ('Chanda', 19760218), ('Amy', 19720919), ('Tara', 19770526), ('Meghann', 19790413), ('Erika', 19721014), ('Lilia', 19780407), ('Jane', 19740621), ('Jennifer', 19760329), ('Alexandra', 19801215), ('Linda', 19710211), ('Brie', 19800121), ('Corina', 19780126), ('Marissa', 19800623), ('Lindsay', 19760608), ('Kathleen', 19461027), ('Geri', ''), ('Rosie', 19480916), ('Joan', ''), ('Mary Ann', 19461125), ('Billie Jean', 19431122), ('Patti', 19491221), ('Sharon', 19520224), ('Mona', 19481128), ('Ann', 19510504), ('Chris', 19541221), ('Janet', 19530806), ('Jill', 19540519), ('Julie', 19451208), ('Ann', 19550822), ('Joy', 19540519), ('Pam', 19510417), ('Peggy', 19490202), ('Martina', 19561018), ('Laura', 19490504), ('Sally', 19550325), ('Cecilia', 19470524), ('Rene', 19570512), ('Beth', 19570613), ('Patricia', 19511125), ('Kim', 19561011), ('Betsy', 19561023), ('Barbara', 19570402), ('Dianne', 19580811), ('Felicia', 19570720), ('Lindsay', 19550124), ('Lele', 19560910), ('Diane', 19550615), ('Rosalyn', 19601102), ('Marcie', 19530910), ('Pam', 19620704), ('Barbara', 19570501), ('Candy', 19550324), ('Bonnie', 19630911), ('Barbara', 19611022), ('Anne', 19590701), ('Paula', 19570110), ('Nancy', 19550522), ('Andrea', 19650604), ('Anne', 19610928), ('Leslie', 19570312), ('Kathy', 19591203), ('Mary Lou', 19610806), ('Sherry', 19590606), ('Lea', 19590120), ('Kim', 19571222), ('Tracy', 19621212), ('Kate', 19521025), ('Wendy', 19600929), ('Andrea', 19640118), ('Zina', 19631116), ('Susan', 19640628), ('Camille', 19660602), ('Alycia', 19610218), ('Jane', 19531206), ('Vicki', 19620925), ('Heather', 19610611), ('Robin', 19631210), ('Gigi', 19640222), ('Kathy', 19670324), ('Anna Maria', 19601022), ('Beth', 19640528), ('Lori', 19631218), ('Laura', 19630317), ('Kim', 19570928), ('Shelley', 19630619), ('Barbara', 19640703), ('Michaela', 19660227), ('Shawn', 19671221), ('Elise', 19620305), ('Sandy', 19581013), ('Linda', 19691224), ('Lisa', 19620714), ('Terry', 19551128), ('Ann', 19591031), ('Lisa', 19651016), ('Molly', 19650312), ('Hu', 19630416), ('Dee Ann', 19620611), ('Jamie', 19620121), ('Beverly', 19650909), ('Louise', 19620107), ('Cammy', 19681011), ('Susan', 19590415), ('Caryn', 19610314), ('Tina', 19521124), ('Terry', 19661218), ('Marianne', 19671017), ('Gretchen', 19640207), ('Kathrin', 19621128), ('Pamela', 19630703), ('Lindsay', 19620731), ('Jennifer', 19670702), ('Jennifer', 19620426), ('Carol', 19621009), ('Jill', 19640904), ('Elizabeth', 19680826), ('Pam', 19631220), ('Melissa', 19680411), ('Cynthia', 19640326), ('Amy', 19690902), ('Sherri', 19640202), ('Stephanie', 19650206), ('Patty', 19650331), ('Penny', 19640411), ('Wendy', 19640420), ('Katrina', 19680805), ('Leigh Anne', 19641214), ('Donna', 19710705), ('Jennifer', 19690226), ('Andrea', 19710930), ('Anna', 19660117), ('Kimberly', 19730327), ('Laxmi', 19721109), ('Kathy', 19650825), ('Halle', 19690805), ('Ronni', 19660510), ('Ann', 19701013), ('Mary Joe', 19710819), ('Jeri', 19701211), ('Carrie', 19720428), ('Shaun', 19681213), ('Audra', 19711117), ('Stacey', 19701113), ('Tami', 19681113), ('Stacey', 19680319), ('Ginger', 19680914), ('Monica', 19731202), ('Patty', 19680118), ('Nicole', 19690826), ('Jessica', 19700913), ('Kimberly', 19711020), ('Stephanie', 19691105), ('Debbie', 19700825), ('Susan', 19701205), ('Caroline', 19660825), ('Elly', 19690825), ('Meredith', 19710428), ('Sandra', 19740910), ('Anne', 19770119), ('Lindsay', 19770628), ('Venus', 19800617), ('Samantha', 19790117), ('Karin', 19771210), ('Jill', 19740704), ('Bunny', 19570905), ('Rayni', 19560524), ('Jennifer', 19810210), ('Holly', 19790210), ('Nancy', 19420823), ('Dorothy', 19250703), ('Kristy', 19500815), ('Valerie', 19490629), ('Linda', 19501021), ('Peaches', 19490416), ('Tory Ann', 19420808), ('Pamela', 19500312), ('Denise', 19500731), ('Wendy', 19470331), ('Becky', ''), ('Nancy', 19520731), ('Barbara', 19540304), ('Kristien', 19520725), ('Janet', 19530628), ('Daryl', 19540507), ('Ching Ling', 19481008), ('Robin', 19580513), ('Patricia', 19410811), ('Laurie', 19551104), ('Donna', 19541109), ('Linda', 19521114), ('Julie', 19480113), ('Jeanne', 19571005), ('Laurie', 19550614), ('Kathy', 19560618), ('Janice', 19520710), ('Kathy', 19561123), ('Jane', 19530810), ('Marita', 19560219), ('Susie', 19570916), ('Mary', 19500721), ('Mary', 19540907), ('Mary', 19570312), ('Carrie', 19550822), ('Ruta', 19551118), ('Mareen', 19600815), ('Robin', 19560413), ('Caroline', 19601104), ('Emilse', 19571219), ('Kay', 19570925), ('Zenda', 19591212), ('Betty Ann', 19500226), ('Jeanne', 19591207), ('Linda', 19610605), ('Julie', 19620205), ('Stacy', 19590405), ('Dana', 19591126), ('Roberta', 19581103), ('Joyce', 19580503), ('Andrea', 19550406), ('Trey', 19591127), ('Jenny', 19650419), ('Leigh Anne', 19640108), ('Joanne', 19541030), ('Michelle', 19670627), ('Nancy', 19580418), ('Felicia', 19611231), ('Jean', 19581025), ('Barbi', 19640914), ('Amy', 19650405), ('Jill', 19600623), ('Ginny', 19661115), ('Grace', 19680416), ('Melissa', 19690624), ('Debbie', 19670809), ('Eileen', 19661201), ('Maeve', 19641116), ('Kathleen', 19610905), ('Niurka', 19690419), ('Cecilia', 19630628), ('Kristin', 19590827), ('Kate', 19630111), ('Liezel', 19760821), ('Mashona', 19760531), ('Stephanie', 19460308), ('Marilyn', 19480308), ('Mimi', ''), ('Alice', 19421122), ('Pixie', ''), ('Betty', 19250415), ('Nadine', 19441026), ('Victoria', ''), ('Stephanie', 19500703), ('Carole', 19430624), ('Gail', 19510421), ('Patricia', 19400101), ('Eliza', 19530102), ('Patricia', 19450828), ('Sandy', 19560501), ('Tam', 19520127), ('Wendy', 19520430), ('Kathy', 19461218), ('Lisa', ''), ('Judy', 19490816), ('Roberta', 19560702), ('Mary', 19450925), ('Aleida', 19550616), ('Erin', 19550720), ('Stephanie', 19560325), ('Karen', 19421211), ('Sheila', 19580222), ('Susie', 19620329), ('Micki', 19601129), ('Heather', 19610712), ('Jane', 19620121), ('Diane', 19611105), ('Shawna', ''), ('Tammy', 19651012), ('Tracy', 19791006), ('Allison', 19801114), ('Ansley', 19820105), ('Dawn', 19760529), ('Kristen', 19840628), ('Vija', ''), ('Farel', ''), ('Connie', 19510521), ('Marjorie', 19510503), ('Peggy', ''), ('Tish', ''), ('Jade', ''), ('Carole', ''), ('Emilie', ''), ('Diane', ''), ('Mary', ''), ('Ann', ''), ('Tina', ''), ('Maricaye', ''), ('Roylee', 19490526), ('Nancy', 19330421), ('Louise', 19470321), ('Mimi', 19390818), ('Raymonde', ''), ('Carol', ''), ('Joyce', 19420223), ('Pat', 19340819), ('Jane', 19510220), ('Darlene', 19360106), ('Pam', 19501025), ('Carol', ''), ('Emilie', ''), ('Margaret', 19500413), ('Pam', ''), ('Susan', 19531113), ('Shari', ''), ('Sue', 19540603), ('Jeanne', 19350721), ('Kathy', 19521219), ('Gertrude', 19230908), ('Judy', 19430402), ('Brenda', 19540211), ('Patricia', 19580516), ('Marcy', ''), ('Sally', ''), ('Lynne', 19580328), ('Margaret', 19530105), ('Renee', 19340819), ('Carol', 19501022), ('Chris', 19561026), ('Kelly', 19620418), ('Lisa', 19590305), ('Lucy', ''), ('Jody', 19560704), ('Phyllis', 19570326), ('Linda', 19631106), ('Karen', 19640323), ('Eleni', 19671023), ('Lisa', 19680718), ('Sandra', 19690903), ('Shannan', 19700519), ('Julie', 19760424), ('Nicole', 19760203), ('Angela', 19720404), ('Keri', 19740501), ('Jacqueline', 19801126), ('Laura', 19810512), ('Jean', 19740607), ('Melissa', 19820606), ('Amber', 19840706), ('Sarah', 19811106), ('Ashley', 19850502), ('Bethanie', 19850323), ('Allison', 19860410), ('Bea', 19801128), ('Alexandra', 19850902), ('Carly', 19861126), ('Theresa', 19850310), ('Gabriela', 19800607), ('Shenay', 19840706), ('Angela', 19840927), ('Kelly', 19830318), ('Teryn', 19781212), ('Abigail', 19810712), ('Jessica', 19871110), ('Jamea', 19860907), ('Mary', 19881218), ('Tiffany', 19800314), ('Alexa', 19890910), ('Vania', 19890303), ('Ahsha', 19850321), ('Lauren', 19891001), ('Varvara', 19860521), ('Madison', 19900403), ('Audra', 19860421), ('Ashley', 19890620), ('Julie', 19790104), ('Melanie', 19910923), ('Kristie', 19920615), ('Gail', 19910605), ('Asia', 19910404), ('Coco', 19911206), ('Christina', 19920511), ('Mallory', 19900718), ('Lauren', 19910110), ('Hilary', 19881117), ('Sloane', 19930320), ('Alison', 19900703), ('Jamie', 19900108), ('Chelsey', 19900829), ('Beatrice', 19920406), ('Shelby', 19921013), ('Irina', 19900504), ('Lauren', 19931009), ('Madison', 19950217), ('Nicole', 19740801), ('Michelle', 19731228), ('Akiko', 19720214), ('Joy', 19621006), ('Caryn', 19711005), ('Luanne', 19721228), ('Julie', 19720510), ('Rachel Ann', 19721119), ('Judy', 19620511), ('Noelle', 19701218), ('Alysia', 19710131), ('Laura', 19670517), ('Amanda', 19780620), ('Julie', 19721007), ('Ann', 19670822), ('Melissa', 19720621), ('Jan', 19531223), ('Mary', 19620121), ('Sylvia', 19640127), ('Gail', 19470116), ('Diedre', 19711011), ('Caroline', 19651129), ('Kerry', 19501002), ('Kathy', 19670904), ('Stella', 19690309), ('Karen', 19680705), ('Cynthia', 19580614), ('Marlie', 19501120), ('Rona', 19690708), ('Kylie', 19610519), ('Helena', 19610201), ('Cheryl', 19640503), ('Jennifer', 19690715), ('Elizabeth', 19660406), ('Anne', 19660205), ('Alix', 19721022), ('Erica', 19690716), ('Stephanie', 19700424), ('Jill', 19671011), ('Jane', 19630123), ('Kathy', ''), ('Jean', 19700510), ('Ann', 19651028), ('Kirsten', 19690327), ('Wendy', 19600327), ('Nicole', 19610906), ('Vicki', 19570325), ('Mary Ann', 19560424), ('Christine', 19680118), ('Jennifer', 19600326), ('Julie', 19570621), ('Penny', 19550826), ('Cathy', 19580310), ('June', 19630619), ('Pam', 19750701), ('Stephanie', 19791023), ('Jane', ''), ('Gretchen', 19650626), ('Jane', 19660324), ('Holyn', 19731012), ('Kristi', 19690910), ('Linley', 19620501), ('Shelby', 19500626), ('Andrea', 19700128), ('Kathy', 19591224), ('Danielle', 19700322), ('Carol', 19610705), ('Jean', 19550606), ('Lori', 19650330), ('Edie', ''), ('Robin', ''), ('Kerri', 19681001), ('Lisa', 19700324), ('Mary', 19660508), ('Carol', 19591113), ('Katie', 19750429), ('Michele', 19660606), ('Shannon', 19670527), ('Gina', 19490515), ('Clare', ''), ('Cathleen', 19570316), ('Janice', 19510522), ('Betsy', 19540503), ('Lucia', 19601022), ('Wendy', 19680715), ('Allyson', 19631007), ('Debbie', 19620722), ('Marsha', ''), ('Linda', 19690503), ('Page', 19740622), ('Heather', 19711011), ('Gigi', 19701007), ('Marilda', 19650222), ('Christine', 19720714), ('Cynthia Ann', 19521114), ('Jenny', 19710226), ('Shelley', 19650421), ('Jackie', 19640104), ('Stephanie', ''), ('Michelle', 19610116), ('Genevieve', 19630819), ('Glynis', ''), ('Ann', 19520526), ('Allegra', ''), ('Cricket', 19610507), ('Bunny', 19460729), ('Holly Ann', 19701218), ('Amy', 19721112), ('Kathy', 19631005), ('Monique', 19841006), ('Erica', 19721128), ('Susan', 19651125), ('Rita', 19601018), ('Nina', 19610207), ('Donna', 19591005), ('Cissie', 19600108), ('Nancy', 19640804), ('Erika', 19631007), ('Cristina', 19770210), ('Terri', 19680118), ('Patty', 19730928), ('Katrina', 19681104), ('Katrina', 19800530), ('Anne', 19810420), ('Cory Ann', 19850122), ('Nicole', 19861103), ('Diana', 19790704), ('Tanner', 19840803), ('Shadisha', 19850712), ('Leslie', 19870525), ('Neha', 19860206), ('Megan', 19850719), ('Elizabeth', 19880603), ('Jewel', 19810910), ('Lindsey', 19851118), ('Raquel', 19821208), ('Brittany', 19910919), ('Kirsten', 19880814), ('Chieh Yu', 19920114), ('Alexis', 19830331), ('Amanda', 19861204), ('Catherine', 19940409), ('Tetiana', 19840904), ('Julia', 19910909), ('Alexandra', 19880214), ('Zoe Gwen', 19930921), ('Julia', 19890323), ('Jessica', 19940224), ('Grace', 19940506), ('Chi Chi', 19920705), ('Nicole', 19930303), ('Mallory', 19910128), ('Jennifer', 19860922), ('Samantha', 19950218), ('Victoria', 19951130), ('Maria', 19891126), ('Anne', 19850828), ('Megan', 19850311), ('Lena', 19881115), ('Katie', 19830503), ('Courtney B', 19920325), ('Kimberly', 19890509), ('Jacqueline', 19910830), ('Ester', 19930704), ('Eleanor', 19880626), ('Yasmin', 19880504), ('Anne Liz', 19960526), ('Alessondra', 19900906), ('Ryann', 19960723), ('Lucie', 19720406), ('Kelly S', 19730905), ('Kristina', 19790811), ('Wendy', 19750131), ('Julie', 19751016), ('Aurandrea', 19791121), ('Brandis', 19800213), ('Megan', 19781224), ('Alyssa', 19821119), ('Jennifer', 19780807), ('Jennifer', 19840217), ('Candice', 19820331), ('Michelle', 19780119), ('Kristy', 19790517), ('Andrea', 19881006), ('Lauren', 19800829), ('Iris', 19850613), ('Jennifer', 19810718), ('Ali', 19870923), ('Nicole', 19851124), ('Kaysie', 19800411), ('Krystina', 19880510), ('Riza', 19860210), ('Sarah', 19810627), ('Megan', 19830326), ('Story', 19830502), ('Christina', 19801127), ('Stacia', 19850921), ('Kaitlyn', 19920113), ('Chloe', 19900201), ('Amanda', 19870902), ('Kelcy', 19890411), ('June', 19950619), ('Krista', 19940914), ('Adria', 19791221), ('Susie', 19721210), ('Kori', 19731101), ('Elizabeth', 19770823), ('Agnes', 19800801), ('Courtenay', 19770227), ('Dee Dee', 19790211), ('Aurora', 19741107), ('Keirsten', 19730917), ('Ingrid', 19730602), ('Stephanie', 19761207), ('Sara', 19770113), ('Lori', 19810731), ('Milangela', 19811209), ('Brooke', 19790101), ('Lauren', 19820521), ('Amanda', 19780119), ('Kelley', 19850922), ('Meredith', 19720604), ('Jackie', 19840111), ('Megan', 19780427), ('Amanda', 19811126), ('Cammy', 19701225), ('Ditta', 19751226), ('Jennifer', 19731228), ('Krissy', 19791211), ('Annica', 19780902), ('Tory', 19850618), ('Whitney', 19860123), ('Sarah', 19801121), ('Jessyca', 19800826), ('Beau', 19800626), ('Katrina', 19880707), ('Stephanie', 19790129), ('Jennifer', 19881123), ('Jessica', 19871124), ('Sarah', 19880209), ('Kim Anh', 19831004), ('Ellah', 19881122), ('Lauren', 19820914), ('Link', 19861125), ('Aleke', 19820427), ('Kendra', 19831118), ('Arpi', 19830612), ('Erin', 19900328), ('Tiffany', 19820909), ('Robin', 19830621), ('Kristi', 19851222), ('Jennifer Lee', 19870227), ('Veronica Ruo Qi', 19891110), ('Danielle', 19910328), ('Shilpa', 19840412), ('Elizabeth', 19880526), ('Megan', 19870701), ('Melissa', 19880408), ('Lauren', 19890522), ('Alana', 19851031), ('Riley', 19901114), ('Kristen', 19880323), ('Mami', 19790715), ('Kit', 19810726), ('Stacey', 19910718), ('Elizabeth', 19810315), ('Nina', 19890707), ('Nadja', 19900607), ('Erica', 19901127), ('Jenna', 19851126), ('Tiya', 19860611), ('Natalie', 19850322), ('Courtney', 19820929), ('Kristy', 19900108), ('Susanna', 19831103), ('Alexa', 19901117), ('Aeriel', 19900928), ('Maureen', 19820528), ('Allie', 19910420), ('Sanaz', 19880621), ('Lauren', 19760912), ('Alexis', 19840927), ('Libby', 19940124), ('Lauren', 19930723), ('Michaela', 19880722), ('Tori', 19871124), ('Gabrielle', 19930227), ('Danielle Rose', 19931213), ('Tarakaa', 19860811), ('Danielle', 19910528), ('Ellen', 19931008), ('Brooke', 19920408), ('Mccall', 19900315), ('Macall', 19860205), ('Megan', 19880705), ('Nicole', 19930729), ('Alexandra', 19911130), ('Elizabeth', 19860524), ('Jade', 19921028), ('Brie', 19890507), ('Jan', 19950301), ('Simone', 19891230), ('Elizabeth', 19860731), ('Gabrielle Faith', 19961223), ('Sachia', 19950511), ('Taylor', 19960416), ('Lindsey', 19900104), ('Alexandra', 19950630), ('Alexandra', 19910213), ('Robin', 19930412), ('Brianna', 19940219), ('Olivia', 19960122), ('Whitney', 19860811), ('Emily J', 19910615), ('Caroline B', 19941031), ('Chalena', 19950818), ('Elizabeth Anita Alexandria', 19960806), ('Breanna Alexa Bachini', 19930521), ('Mary', 19950817), ('Betsy', 19600427), ('Eve', 19621028), ('Janet', 19670405), ('Jaime', 19611001), ('Angel', 19610830), ('Donna', 19550626), ('Valerie', 19540813), ('Lucinda', 19520717), ('J', ''), ('J', ''), ('D', ''), ('K', ''), ('B', ''), ('J', ''), ('R', ''), ('N', ''), ('E', ''), ('F', ''), ('Caroline', 19560622), ('D', ''), ('Wendy', ''), ('Nancy', 19530830), ('Susan', 19570107), ('Gretchen', 19560201), ('Anne', ''), ('Holly', 19690811), ('Margaret', 19601012), ('Clare', 19671008), ('Kathy', 19641104), ('Rita', 19660512), ('Marlene', 19810731), ('Linda', 19570701), ('Beverly', 19530124), ('Ann', 19551013), ('Robin', 19540923), ('A', ''), ('Maria', ''), ('Karen', ''), ('Karen', ''), ('Jenny', ''), ('Lisa', ''), ('Kathy', ''), ('Maria', 19600424), ('Judith', ''), ('Becky', ''), ('Connie', ''), ('Lori', ''), ('Joni', 19651125), ('Lisa', ''), ('Suzanne', ''), ('Shandra', 19680519), ('Merrilee', ''), ('Jennifer', 19660615), ('Chris', ''), ('Trisha', 19690203), ('Stephanie', 19690818), ('Sonya', 19670825), ('Susan', 19710412), ('Tanya', 19690302), ('Tonya', 19690821), ('Kara', 19730105), ('Melissa', 19740402), ('Victoria', 19761230), ('Trina', 19821230), ('Kristine', 19720623), ('Martha', 19691215), ('Candice', 19800207), ('Cindy', 19790422), ('Elizabeth', 19740824), ('Valerie', 19731228), ('Tracey', 19710129), ('Diana', 19680410), ('Alice', 19770830), ('Allison', 19660804), ('Vickie', 19710827), ('Stacey', 19750105), ('Marissa', 19780613), ('Susanna', 19720303), ('Rebecca', 19721119), ('Ashley', 19720408), ('Varalee', 19760502), ('Stephanie', 19770408), ('Elizabeth', 19631112), ('Bridget', 19740207), ('Leslie', 19720209), ('Traci', 19780805), ('Alison', 19741125), ('Amy', 19681007), ('Vanessa', 19760513), ('Laura', 19720426), ('Anna', 19761021), ('Betsy', 19751127), ('Kristen', 19781002), ('Mugette', 19810424), ('Tu', 19780208), ('Irene', 19790612), ('Jennifer', 19720416), ('Diana', 19751029), ('Jody', 19711122), ('Samantha', 19890509), ('Tristen Z', 19940501), ('Rachel', 19920719), ('Ashley', 19871106), ('Alexandra', 19920223), ('Natalie', 19910801), ('Lindsay', 19880226), ('Amelia', 19920802), ('Caroline', 19930313), ('Camila', 19950929), ('Josie', 19951105), ('Skylar Alexandra', 19940424), ('Brooke', 19960212), ('Alexandra', 19910413), ('Daniella', 19971105), ('Hayley', 19950517), ('Jody', 19780930), ('Ella', 19760917), ('Emily Ann', 19820328), ('Jacquelyn', 19801117), ('Lesley', 19781011), ('Kristen', 19770518), ('Cara', 19720421), ('Zuzanna', 19800403), ('Katie', 19800911), ('Marilyn', 19740114), ('Lena', 19830510), ('Brandi', 19770612), ('Andrea', 19780204), ('Sara', 19801022), ('Hillary', 19820417), ('Mariel', 19800220), ('Whitney', 19800508), ('Darian', 19790615), ('Alexandra', 19820310), ('Prim', 19810115), ('Janet', 19800628), ('Rachel', 19690211), ('Lindsay', 19821207), ('Kirsty', 19780517), ('Raluca Daniela', 19830717), ('Mindy', 19720322), ('Erin', 19830419), ('Mary Carlisle', 19780716), ('Erin', 19800116), ('Keiko', 19800429), ('Maiko', 19820623), ('Paige', 19740714), ('Janet', 19790529), ('Briana', 19781221), ('Stacey', 19721219), ('Kristin', 19720204), ('Julia', 19810518), ('Rochelle', 19800430), ('Selin', 19780706), ('Jennifer', 19730117), ('Luana', 19821205), ('Whitney', 19850811), ('Paloma', 19720823), ('Tumeka', 19761226), ('Maria', 19830319), ('Hyacinth', 19610809), ('Eva', 19840706), ('Kara', 19790920), ('Katie', 19841110), ('Melissa', 19840613), ('Emmy', 19870722), ('Alexandria', 19860310), ('Shari', 19641103), ('Michelle', 19791212), ('Alexandra', 19841228), ('Nicole', 19860203), ('Monica', 19851212), ('Caitlin', 19850517), ('Lia', 19800922), ('Michelle', 19870304), ('Sybil', 19770106), ('Jodi', 19810822), ('Liberty', 19870409), ('Mimi', 19841030), ('Melissa', 19861211), ('Jessi', 19870221), ('Courtney', 19880501), ('Chrissie', 19870902), ('Yvette', 19880612), ('Audra', 19830331), ('Leila', 19860206), ('Tamara', 19790924), ('Rebekah', 19791012), ('Sabita', 19840927), ('Shannon', 19870109), ('Courtney', 19851011), ('Polina', 19860408), ('Anamika', 19890413), ('Jie', 19871101), ('Georgette', 19840709), ('Christy', 19871212), ('Suzanne', 19880117), ('Courtney', 19900327), ('Cammie', 19871122), ('Nelly', 19901113), ('Veronica', 19870514), ('Keilly', 19900505), ('Kate', 19831111), ('Reka', 19890708), ('Bianca', 19890514), ('Thien Trang', 19910918), ('Pamela', 19910101), ('Morgan', 19920220), ('Julianna', 19850107), ('Subbadharmi', 19890708), ('Stephanie', 19930216), ('Kelsey', 19910408), ('Alexandra', 19870719), ('Amanda', 19880314), ('Chelsea', 19891211), ('Anna', 19840821), ('Jill M', 19910313), ('Kady', 19860317), ('Phoebe', 19880520), ('Emily', 19921201), ('Christian', 19840913), ('Keri', 19891225), ('Sabrina', 19860112), ('Nataly', 19900913), ('Maria', 19920619), ('Noel', 19930203), ('April', 19920508), ('Ellie', 19930808), ('Stephanie', 19901027), ('Nicole', 19911031), ('Anna', 19940308), ('Veronika', 19900920), ('Annie', 19930330), ('Kyle', 19940405), ('Chanelle', 19940119), ('Yawna', 19860801), ('Hilary', 19910513), ('Ivana', 19861108), ('Gira', 19860829), ('Claire', 19891129), ('Erin', 19880609), ('Caitlin', 19880219), ('Alexandra', 19850703), ('Jennifer', 19950412), ('Kimberly', 19961015), ('Natalie', 19891102), ('Elizaveta Anna', 19930831), ('Veronica M', 19911207), ('Karina', 19950706), ('Sylvia', 19860904), ('Sherry', 19950208), ('Katrine Isabel', 19960315), ('Denise', 19950417), ('Courtney', 19940325), ('Christina', 19960529), ('Noelle', 19881205), ('Lauren', 19950517), ('Breaunna', 19941222), ('Nicole', 19941230), ('Meredith', 19970521), ('Nadia', 19950114), ('Jackie', 19710922), ('Antoinette', 19850107), ('Kathleen', 19740511), ('Kylene', 19790725), ('Dana', 19730725), ('Audra', 19720605), ('Tracee', 19731009), ('Amie', 19800517), ('Jennifer', 19811128), ('Lashawnn', 19740602), ('Jacqueline', 19820209), ('Jennifer', 19770119), ('Kristy', 19741230), ('Susan', 19741201), ('Bridget', 19761018), ('Amy', 19690628), ('Sandra', 19750116), ('Khristen', 19750803), ('Stefanie', 19810322), ('Barrie', 19730724), ('Kate', 19820415), ('Amy', 19731107), ('Anne', 19780520), ('Lauren', 19740830), ('Dewonder', 19590127), ('Kendra', 19790828), ('Jamie', 19801106), ('Jennifer', 19750823), ('Audrey', 19850430), ('Marjorie', 19750503), ('Katie', 19770527), ('Aimee', 19820110), ('Megan', 19810519), ('April', 19781129), ('Maren', 19791106), ('Sarah', 19780514), ('Marie Ange', 19780114), ('Dina', 19680406), ('Margaret', 19760707), ('Mary Beth', 19760329), ('Patricia', 19841020), ('Ashley', 19821229), ('Kathryn', 19790225), ('Leslie', 19810718), ('Becky', 19640801), ('Julie', 19811223), ('Danielle', 19781110), ('Terri', 19650402), ('Amy', 19681215), ('Douglas', 19840522), ('Sara', 19850621), ('Karla', 19770318), ('Kristin', 19841130), ('Kristin', 19810705), ('Bonnie', 19850503), ('Natalie', 19830401), ('Jennifer', 19830702), ('Claire', 19700527), ('Lauren', 19780316), ('Alison', 19791129), ('Laura', 19710624), ('Katia', 19810816), ('Kara', 19771202), ('Violette', 19790927), ('Lisa', 19740221), ('Evonne', 19740923), ('Mandy', 19790312), ('Jessica', 19800415), ('Emily', 19811119), ('Callie', 19770711), ('Maggie', 19750529), ('Elina', 19820521), ('Terry Ann', 19740428), ('Kimberly', 19790725), ('Bettina', 19820718), ('Lindsay', 19800519), ('Johanna', 19750518), ('Amy', 19790124), ('Meiling', 19791112), ('Jennifer', 19781020), ('Vania', 19810428), ('Megan', 19831014), ('Lindsey', 19800201), ('Megan', 19820411), ('Angela', 19840329), ('Megan', 19840920), ('Nicolette', 19831108), ('Anita', 19860219), ('Alessandra', 19870112), ('Aradhana', 19820709), ('Tiffany', 19831228), ('Macey', 19830224), ('Kelcy', 19861225), ('Caylan', 19820701), ('Stephanie', 19820923), ('Jan', 19580317), ('Kate', 19830530), ('Karen', 19671205), ('Sarah Jane', 19820802), ('Catrina', 19840913), ('Bethany', 19821129), ('Lindsay', 19820811), ('Kathleen', 19820917), ('Amy', 19810415), ('Emilia', 19820204), ('Colleen', 19790212), ('Ashlee', 19850522), ('Saras', 19830726), ('Brittany', 19850420), ('Laila', 19810805), ('Natalie', 19851103), ('Celena', 19790130), ('Marine', 19780929), ('Cara', 19730424), ('Loni', 19810928), ('Christyn', 19850210), ('Cassy', 19850802), ('Manisha', 19770513), ('Jennifer', 19811121), ('Michelle', 19801002), ('Brook', 19851231), ('Samantha', 19840807), ('Stephanie', 19870411), ('Courtney', 19820502), ('Melissa', 19840112), ('Kristin', 19790227), ('Adriana', 19780902), ('Christine', 19831216), ('Julie', 19840521), ('Cristina', 19860826), ('Nadia', 19850209), ('Amanda', 19821020), ('Camelia', 19860406), ('Emily', 19850201), ('Danielle', 19840717), ('Rochelle', 19800627), ('Brianna', 19851215), ('Zena', 19880717), ('Adina', 19870619), ('Lauren', 19880204), ('Lauren', 19870928), ('Meg', 19870811), ('Ristine', 19850116), ('Jennifer', 19841115), ('Lindsey', 19860101), ('Lindsay', 19880524), ('Gloriann', 19840228), ('Patricia', 19740119), ('Kelly', 19820223), ('Amanda', 19870813), ('Elizabeth', 19860128), ('Whitney', 19851225), ('Laura', 19850506), ('Masha', 19840211), ('Karina', 19880811), ('Erin', 19850113), ('Randi', 19870211), ('Kewa', 19860701), ('Hala', 19850809), ('Dasha', 19870606), ('Suzanna', 19861013), ('Colleen', 19880209), ('Blair', 19830904), ('Simone', 19881010), ('Jessica', 19870304), ('Austin', 19860601), ('Preethi', 19850629), ('Christala', 19890709), ('Krista', 19900423), ('Marie', 19830721), ('Ashley', 19861113), ('Latrell', 19891212), ('Sheryl', 19850920), ('Amanda', 19850319), ('Blakeley', 19841114), ('Ashley', 19870917), ('Whitney', 19890109), ('Marlene', 19880329), ('Melissa', 19860801), ('Alex', 19870117), ('Jessica', 19811223), ('Megan', 19890204), ('Jacqueline', 19830608), ('Melody', 19830708), ('Sarah', 19910314), ('Marie', 19910614), ('Daron', 19851128), ('Amy', 19790324), ('Dina', 19871014), ('Mia', 19910312), ('Valerie', 19851231), ('Amanda', 19880523), ('Connor', 19870922), ('Elizabeth', 19920114), ('Brittany', 19870208), ('Kristen A', 19880325), ('Julie', 19880331), ('Sarah', 19880129), ('Emily', 19890724), ('Christine', 19871225), ('Amanda', 19850511), ('Nicole', 19880620), ('Laurianne', 19881018), ('Pamela', 19901124), ('Miya', 19871114), ('Rachel', 19830708), ('Joanna', 19891009), ('Lynn', 19791216), ('Claire', 19871108), ('Paola', 19920827), ('Lauren', 19890512), ('Erin Carol', 19930506), ('Cameron', 19881224), ('Julie', 19870627), ('Stefanie', 19890130), ('Hannah', 19910812), ('Katherine', 19860305), ('Olivia', 19880423), ('Christina', 19880426), ('Christina', 19881212), ('Cierra', 19910927), ('Milena', 19850506), ('Christin J', 19870731), ('Stephanie', 19900327), ('Kaysara', 19910623), ('Nina', 19900115), ('Deirdre', 19901205), ('Kristin', 19841024), ('Jacqueline', 19900913), ('Stephany', 19900609), ('Erica', 19900702), ('Julia', 19910916), ('Grace', 19891211), ('C C', 19911009), ('Sarah', 19910422), ('Marianne', 19850906), ('Monica', 19920622), ('Kate', 19920109), ('Amanda Marie', 19860106), ('Alexa', 19900824), ('Denise', 19890731), ('Molly', 19890525), ('Nelo', 19920705), ('Farwa', 19891101), ('Millie', 19641005), ('Brooke Lindsey', 19940622), ('Lilly F', 19911101), ('Brynn', 19910801), ('Karina', 19831112), ('Tracy', 19740827), ('Desiree', 19931110), ('Rachael', 19910427), ('Alrissa', 19920724), ('Amanda', 19870317), ('Olivia', 19910711), ('Caryssa L', 19920413), ('Monica', 19930108), ('Joelle', 19910606), ('Malika', 19910709), ('Theresa', 19930607), ('Mary Anne', 19920215), ('Morocco', 19921107), ('Mara', 19920222), ('Alejandra Maria', 19950228), ('Catherine', 19880430), ('Kate', 19901106), ('Abigail', 19900209), ('Sabrina', 19930224), ('Heatherm', 19890925), ('Stephanie', 19940511), ('Leighann', 19931204), ('Lauren', 19880816), ('Kayla', 19920921), ('Kir', 19891031), ('Skylar', 19930914), ('Julia', 19931207), ('Meghan', 19930621), ('Nida', 19911029), ('Lauren', 19880905), ('Kelly K', 19910531), ('Alyssa Grace', 19950215), ('Mary', 19911122), ('Madeleine', 19920319), ('Rachel', 19840302), ('Alex', 19911229), ('Kyra', 19960510), ('Suzy', 19940830), ('Remeice', 19891112), ('Kate', 19940201), ('Courtney', 19891015), ('Molly', 19930810), ('Stephanie', 19940131), ('Alexandra M', 19870719), ('Aleksandra', 19960409), ('Erin', 19880709), ('Jessica', 19930428), ('Spencer', 19950125), ('Anik', 19910405), ('Simone', 19920717), ('Emma', 19930623), ('Melissa', 19921004), ('Tina', 19950427), ('Julia', 19940613), ('Rachael', 19931209), ('Shelby', 19930114), ('Epiphany B', 19921217), ('Kaitlin', 19921215), ('Mariana', 19950927), ('Hannah', 19951103), ('Casey', 19910613), ('Deborah', 19940514), ('Jessica', 19931117), ('Kelsey', 19940821), ('Samantha', 19930126), ('Blair', 19940814), ('Martha V', 19900628), ('Amanda', 19930322), ('Sarah', 19920729), ('Emily', 19931112), ('Jamie', 19950308), ('Kelly', 19770505), ('Quinn', 19941110), ('Sophia', 19930330), ('Sierra A', 19900816), ('Mckenzie', 19940107), ('Stacey', 19900117), ('Courtney', 19910226), ('Rosalia', 19900208), ('Sydney', 19950207), ('Mia', 19950406), ('Erin Kane', 19960512), ('Laura', 19841119), ('Eva', 19921222), ('Elizabeth', 19940706), ('Sarah', 19930713), ('Elyse', 19870910), ('Sabrina', 19920912), ('Julia', 19890114), ('Gabriella', 19951208), ('Tanya', 19930914), ('Nyla', 19960730), ('Louisa', 19960516), ('Zina', 19980402), ('Tornado Alicia', 19980512), ('Madison', 19970919), ('Rima', 19951116), ('Kourtney J', 19940907), ('Natasha', 19940823), ('Erin', 19901230), ('Rachel May', 19941113), ('Jillian', 19941210), ('Caroline', 19960315), ('Dominique', 19870203), ('Trelsie', 19890707), ('Angela', 19950604), ('Nicole', 19980429), ('Kim', 19951027), ('Emina', 19930330), ('Lynda', 19921123), ('Joanna Mary', 19930201), ('Caroline', 19960103), ('Julia', 19940403), ('Callie', 19910904), ('Maxine', 19910710), ('Katie', 19921211), ('Emma Christine', 19980201), ('Johnnise', 19960510), ('Katerina', 19970717), ('Jessica', 19970105), ('Marjorie', 19880420), ('Maci', 19931007), ('Kaitlyn', 19971204), ('Jacqueline', 19941203), ('Charity', 19870711), ('Parris', 19980708), ('Jamie', 19930819), ('Miriam Ruth', 19940724), ('Elizabeth', 19910118), ('Amanda', 19860130), ('Lindsay', 19780708), ('Erica', 19860327), ('Dina', 19711211), ('Robyn', 19850111), ('Anita', 19810402), ('Casey', 19840501), ('Emily', 19850224), ('Jamie', 19880415), ('Brittany', 19880627), ('Elizabeth', 19550921), ('Carolyn', 19900415), ('Cassandra', 19891211), ('Prissy', 19910807), ('Kristin', 19830420), ('Diamond', 19901226), ('Celia', 19860527), ('Tiffany', 19891126), ('Jennifer', 19890531), ('Komal', 19930108), ('Roxanne', 19890826), ('Mandy', 19810914), ('Amanda', 19800324), ('Alissa', 19671209), ('Kay', 19570927), ('Jane', 19661222), ('Tracie', 19610116), ('Elizabeth', 19630811), ('Cinda', 19710410), ('Tracy', 19611021), ('Dena', 19650928), ('Hemel', 19660108), ('Karen', 19630803), ('Reka', 19670612), ('Vincenza', 19660820), ('Lisa', 19640803), ('Lynn', 19661018), ('Jill', 19731226), ('Julie', 19710609), ('Kilmeny', 19660218), ('Kay', 19690131), ('Debbie', 19651129), ('Anne Marie', 19660720), ('Leslie', 19660908), ('Lisa', 19630604), ('Lisa', 19611106), ('Tory', 19660712), ('Kylie', 19700509), ('Anya', 19690220), ('Jennifer', 19670106), ('Diana', 19721007), ('Betsy', 19671127), ('Katrina', 19671129), ('Karen', 19701102), ('Susan', 19710206), ('Sherri', 19730118), ('Tonya', 19691110), ('Julie', 19680817), ('Susan', 19710206), ('Jamie', 19691029), ('Alita', 19630112), ('Tara', 19681223), ('Erika', 19720516), ('Kellie', 19670601), ('Happy', 19680605), ('Angie', 19710323), ('Bonnie', 19770412), ('Farley', 19741212), ('Tunecia', 19701023), ('Roseann', 19710227), ('Allison', 19710927), ('Hillery', 19610619), ('La Shawnn', 19740206), ('Sylvia', 19610419), ('Kathy', 19741105), ('Zuzanna', 19790726), ('Cassi', 19850902), ('Lejla', 19870206), ('Danielle', 19820120), ('Geneva', 19871225), ('Katie', 19891023), ('Katie', 19881216), ('Brittany', 19940406), ('Allie', 19950630), ('Sofia', 19981114), ('Mia', 19970723), ('Ty Ana', 19970313), ('Karina Kristina', 19981021), ('Jessica', 19890916), ('Trisha', 19981027), ('Ashley', 19881017), ('Tina', 19920831), ('Tatijana', 19971116), ('Taylor L', 19950117), ('Alexa', 19980707), ('Emerald', 19970905), ('Marie', 19970611), ('Alexandra', 19950224), ('Aleah', 19910923), ('Sarah', 19941219), ('Usue Maitane', 19981028), ('Ellie', 19970710), ('Maia A', 19960921), ('Raquel', 19980128), ('Peggy', 19951110), ('Rebecca', 19971004), ('Camila', 19961125), ('Karyn', 19940912), ('Ayla', 19960715), ('Rasheeda', 19950630), ('Amy', 19941028), ('Ariana', 19960126), ('Luisa', 19951005), ('Mary', 19910802), ('Kristi', 19900427), ('Ronit', 19931203), ('Julia Christine', 19921027), ('Kristina N', 19910125), ('Macie', 19941023), ('Jessica', 19950102), ('Rhiann', 19940622), ('Frances', 19940222), ('Kelly', 19960221), ('Hanna', 19980225), ('Natalie', 19960508), ('Dasha', 19961011), ('Elizabeth', 19910218), ('Brianna', 19951012), ('Kristin', 19951122), ('Kristina', 19951204), ('Maddie', 19971117), ('Raveena', 19980723), ('Daniella', 19971027), ('Laura', 19970305), ('Idia', 19930922), ('Chloe Michele', 19970905), ('Morgan', 19941219), ('Nikki', 19960418), ('Sianna', 19900804), ('Nicole', 19990508), ('Mercedes', 19970525), ('Lourdes', 19990531), ('Adi', 19951213), ('Anna', 19971103), ('Alexandra', 19980719), ('Katarina', 19960704), ('Michaela', 19990726), ('Ena', 19980212), ('Catherine Cartan', 19990408), ('Hadley', 19960311), ('Madison', 19960402), ('Jaeda', 19990728), ('Jeannez', 19960707), ('Erica', 19980316), ('Jessie', 19980419), ('Andie K', 19970107), ('Alexandria', 19960511), ('Gabriella', 19960709), ('Kelly', 19990509), ('Terri', 19960723), ('Angel', 19850125), ('Maria', 19970506), ('Alexis', 19980809), ('Rianna', 19960903), ('Megen', 19960709), ('Caroline', 19980905), ('Sophie', 19970528), ('Nicole', 19960504), ('Jacqueline', 19970531), ('Jessica', 19970709), ('Adriana', 19890308), ('Kylie', 19970606), ('Yuki Kristina', 19950819), ('Lexi', 19950525), ('Caroline', 19970726), ('Ingrid', 19980616), ('Alexandra', 19970301), ('Nada', 20000308), ('Alexis', 19950606), ('Felicity', 19970313), ('Tory', 19930105), ('Aimee', 19940907), ('Alli', 19961203), ('Claudia', 19961206), ('Brooke', 19951010), ('Marina', 19981123), ('Zoe Adeline', 19941217), ('Jessica', 19970605), ('Ashley', 19920829), ('Valerie', 19971122), ('Ashley', 19990208), ('Brittany', 19920303), ('Olivia', 19940623), ('Taylor', 19950731), ('Alexis', 19950724), ('Sara', 19971217), ('Lindsay', 19930107), ('Liza', 19950317), ('Jayci', 20000517), ('Marina', 19920314), ('Sydney', 19990430), ('Alyza', 19951122), ('Sophia', 19920113), ('Riley', 19990615), ('Delaney', 19981028), ('Jane', 19961112), ('Valerie Ann', 19980801), ('Carolyn', 19970524), ('Maegan', 19950416), ('Tamara', 19971129), ('Mary', 19981025), ('Victoria', 19990401), ('Kennedy', 19970521), ('Amy', 19970120), ('Makenna', 19980226), ('Stephanie', 19980415), ('Nicole Taylor', 19990426), ('Claire', 20000525), ('Jada', 19990129), ('Sara', 19970723), ('Hannah', 19960923), ('Sophia', 19971005), ('Akiko', 19930913), ('Karina', 19970808), ('Haley', 19910403), ('Paige', 19970222), ('Kayla', 19990928), ('Carson', 20000909), ('Amanda', 19940813), ('Maria', 19990721), ('Kylie', 19990321), ('Luciana', 19981001), ('Zoe', 20010308), ('Sachi', 19981129), ('Audrey', 19951029), ('Anna', 19970319), ('Abigail', 20010122), ('Cameron', 19990920), ('Katelyn', 19921211), ('Katharine', 19961019), ('Elyse', 19981014), ('Mimi', 19930430), ('Bess', 19971029), ('Ines Karmen', 19970615), ('Taylor', 19990615), ('Kristen', 19970407), ('Sabrina', 19971003), ('Desirae', 19940111), ('Sarah', 19960418), ('Rachel', 19961108), ('Victoria', 19990807), ('Nini', 19950909), ('Francesca', 19970722), ('Makenzie', 19990610), ('Chiara', 19980826), ('Melissa', 19930602), ('Morgan', 19990416), ('Jerricka', 19950116), ('Eva', 19961102), ('Miranda', 19990307), ('Teresia', 19990529), ('Julia', 19971217), ('Malkia', 20000808), ('Lorraine M', 19930615), ('Carol', 19960218), ('Jocelyn', 19900526), ('Roosh', 19920321), ('Alexa', 19980703), ('Alyvia', 20000503), ('Katie', 19990929), ('Meible', 19990519), ('Elizabeth', 20010712), ('Emma', 20010518), ('Arianna', 19950206), ('Kiah', 19950117), ('Alyssa', 20000210), ('Stephanie', 19880402), ('Sofia', 19990722), ('Sarah', 19930814), ('Melan', 19970406), ('Alexandra', 19990105), ('Dilara', 19990911), ('Hurricane Tyra', 20010302), ('Taylor', 19980222), ('Nami', 19980827), ('Marcella', 20001012), ('Sophia', 20010630), ('Delisha', ''), ('Haley', ''), ('Jenna', ''), ('Nikita', 19931021), ('Hoda', ''), ('Meredith', 19990310), ('Morgan', 19950317), ('Kirsten', 19940508), ('Maya', 19940527), ('Kat', 19930215), ('Alexandra', 19930215), ('Meghan', 19971028), ('Salma', 20000828), ('Madeline', 19990307), ('Lindsay', 19981217), ('Alexa', 20010908), ('Mary Catherine', 19971104), ('Cheyenne', 19960326), ('Neri', 19990902), ('Jesse', 20011004), ('Ann', 20000626), ('Natalia', 19930929), ('Whitney', 20020417), ('Christina', 19970725), ('Sofia', 19980703), ('Nicole', 20000805), ('Kenadi', 19970313), ('Paiton', 19980808), ('Shannon', 19950915), ('Elysia', 20000324), ('Ashley', 19991026), ('Alexis', 19970314), ('Caty', 20011120), ('Isabella', 20010706), ('Elizabeth', 20010519), ('Anna', 20020306), ('Dakota', 20020508), ('Janice', 19990105), ('Amanda', 20010831), ('Jada', 19980319), ('Hind', 19990228), ('Mikaela', 19890801), ('Micheline', 19970428), ('Kendal', 19940106), ('Anna', 19991008), ('Mia', 19981021), ('Chloe', 20010830), ('Abigail', 20010310), ('Ryan', 19990510), ('Maia', ''), ('Jana', 19941110), ('Shale', 20011015), ('Helen Abigail', 19980520), ('Kariann', 19990116), ('Kennedy', 19980903), ('Caroline', 19980929), ('Allison', 19981031), ('Melissa', 19970624), ('Ellyse', 19961109), ('Charleen', 19410918), ('Doris', 19250620), ('Patricia', 19370601), ('Pauline', 19190806), ('Helen', 19290507), ('Mary', ''), ('Althea', 19270825), ('Carrie', 19571026), ('Cathy', 19510822), ('Karen', 19570408), ('', ''), ('Barbara', ''), ('Susan', 19611219), ('Jan', 19630609), ('Diane', 19650626), ('Carol', 19620605), ('Leanne', ''), ('Shelley', 19631120), ('Maureen', ''), ('Lorrie', 19601015), ('Tiffany', 19600417), ('Sarah', 19741010), ('Meg', ''), ('Wendy', ''), ('Lynn', 19660819), ('Heidi', 19640507), ('Jacqueline', 19620329), ('Sheri', 19690629), ('Diane', 19710121), ('Angela', 19641211), ('Nancy', ''), ('Liz', 19640423), ('Jamie', 19630530), ('', ''), ('Laura', 19681210), ('Jill', ''), ('Courtney', 19560622), ('Tiffany', 19810121), ('Kristen', 19810501), ('Wendy', 19681001), ('Sheila', ''), ('Heidi', 19601007), ('Julie', 19610523), ('Deborah', 19701129), ('Jennifer', ''), ('Cindy', 19591207), ('Lynn', ''), ('I', ''), ('Lisa', 19600808), ('Jill', 19540907), ('Aschara', ''), ('Heidi', 19720713), ('Julie', 19710609), ('', ''), ('G', ''), ('Stephanie', 19661010), ('Lucy', 19540402), ('Cathy', ''), ('', ''), ('Emmy', ''), ('', ''), ('Claudette', ''), ('Lisa', ''), ('Lynn', 19631114), ('Lindsay', ''), ('Lisa', 19630218), ('Virginia', ''), ('Lloyd', 19451208), ('Suzanne', 19750612), ('Caren', 19611110), ('Allegra', 19720113), ('Molly', 19630215), ('Lori', 19600112), ('Lindsay', 19780417), ('Adrienne', 19680903), ('Quynh', 19710627), ('Kari', 19810120), ('Lisa', 19590212), ('Christa', 19790115), ('Kelly', 19770505), ('Massoumeh', 19770803), ('Louise', 19500119), ('Jayne', 19741006), ('Christine', ''), ('Kim', 19780329), ('Lani', 19600808), ('Julie', 19690425), ('Ruth Ann', 19700506), ('Lauren', 19830423), ('Tasha', 19760223), ('Kealy', 19801030), ('Courtney', 19721230), ('Julie Ann', 19750618), ('Nicole', 19741001), ('Ashlee', 19801005), ('Kelly', 19751106), ('Alexandra', 19790210), ('Mary', 19730912), ('Lisa', 19660204), ('Monty', 19650506), ('Julie Anne', 19800911), ('Lorrie', 19651203), ('Kendra', 19760621), ('Chris', 19610706), ('Christine', 19850303), ('Rankin', 19840126), ('Julia', 19850721), ('Sabaea', 19811125), ('Nicole', 19750602), ('Joyce', 19800628), ('Sarah', 19820410), ('Jean Marie', 19651109), ('Stacey', 19720110), ('Varita', 19820702), ('Shera', 19780910), ('Trisha', 19710617), ('Suzanne', 19680921), ('Lisa', 19801119), ('Martha', 19551005), ('Kandiss', 19770221), ('Brooke', 19780413), ('Cristina', 19750825), ('Jasmine', 19810102), ('Kathleen', 19830125), ('Melissa', 19770524), ('Michelle', 19731114), ('April', 19831011), ('Olivia', 19810310), ('Melissa', 19650221), ('Cami', 19720314), ('Marissa', 19780318), ('Kristin', 19720204), ('Christi', 19610509), ('Cindy', ''), ('Ashley', 19830506), ('Leigh', 19831014), ('Natalia', 19831110), ('Nikhila', 19850208), ('Rachel', 19820916), ('Alison', 19850118), ('Cameron', 19830328), ('Gretchen', 19820304), ('Cackie', 19661107), ('Stephanie', 19650104), ('Miriam', 19850925), ('Nicole', 19880219), ('Lilivette', 19800225), ('Jonni', 19791203), ('Amanda', 19850102), ('Weyli', 19800722), ('Helene', 19841215), ('Amanda', 19841101), ('Nicole', 19870615), ('Stefani', 19841215), ('Laura', 19860217), ('Tifanie', 19880920), ('Mary', 19651124), ('Katherine', 19730414), ('Monica', 19800204), ('Nicole', 19850105), ('Shanna', 19750428), ('Jane', 19890926), ('Estelle', 19890503), ('Maria', 19820204), ('Jessica', 19860812), ('Renata', 19650224), ('Laura', 19830408), ('Lindsey', 19840313), ('Christy', 19850925), ('Timberly', 19831209), ('Brooke', 19850423), ('Kelli Elizabeth', 19940409), ('Melanie', ''), ('Whitney P', 19930625), ('Sydni', 19880612), ('Jasmine Nicole', 19930826), ('Alexandra', 19920812), ('Amber', 19870605), ('Kelsey', 19920610), ('Alex', 19920225), ('Ashley M', 19940304), ('Lauren', 19940828), ('Stacia', 19930914), ('Alexandria', 19900111), ('Rozel Asuncion', 19950616), ('Bolan', 19890908), ('Annie', 19920829), ('Eva', 19941007), ('Whitney', 19900909), ('Hanna', 19911107), ('Mandy', 19910501), ('Gia', 19900614), ('Brooke', 19951105), ('Lisa', 19680519), ('Alexandra M', 19930120), ('Sonya Sheeran', 19940816), ('Shinann', 19900608), ('Nicolette', 19950824), ('Rebecca', 19921125), ('Ashley', 19960430), ('Savannah', 19950115), ('Margaret', 19570423), ('Carlee', 19950724), ('Sarah', 19850718), ('Caroline', 19840926), ('Alexia', 19940421), ('Micaela', 19890311), ('Tina', 19810116), ('Manon Cristina', 19941224), ('Hailey M', 19930127), ('Tiffany', 19911216), ('Devan', 19940528), ('Courtenay', 19770227), ('Christine', 19931110), ('Emily', 19900517), ('Leyla', 19930423), ('Alexis', 19880722), ('Di Andrea', 19950730), ('Jandayia', 19960303), ('Margarita', 19950317), ('Olivia', 19941211), ('Caitlin', 19910905), ('Kara', 19910629), ('Paloma', 19890313), ('Susie', 19491114), ('Emily', 19861118), ('Abbie', 19951121), ('Alanna', 19950107), ('Siobhan', 19871110), ('Kayla Symone', 19960110), ('Margie', 19901106), ('Jamie', 19820521), ('Adria', 19791221), ('Lynn', 19941106), ('Nadege', 19960527), ('Lauren', 19941203), ('Tiffany', 19881204), ('Sarah', 19880907), ('Victoria', 19941214), ('Natalia', 19950325), ('Alexandra', 19931013), ('Montana', 19970219), ('Samantha Rose', 19940410), ('Angela', 19980331), ('Samantha', 19950527), ('Elizabeth', 19890419), ('Sarah', 19941121), ('Gabriela', 19950418), ('Tina', 19911222), ('Mia', 19920116), ('Stephanie', 19920831), ('Kennan', 19960317), ('Madison', 19930602), ('Whitney', 19910815), ('Sarah', 19960925), ('Brooke', 19980614), ('Jessie Lynn', 19951228), ('Brittany', 19941212), ('Kylie', 19870826), ('Erin', 19861102), ('Lindsay', 19821118), ('Jessica', 19801107), ('Yuliya', 19860609), ('Kathryn', 19831129), ('Lyndsey', 19820509), ('Tiana', 19841014), ('Keri', 19870310), ('Sarah', 19871201), ('Alyssa', 19841006), ('Rachel', 19870205), ('Angelina', 19521229), ('Amy', 19540720), ('Bernadette', 19821015), ('Tarrin', 19820423), ('Christine', 19670817), ('Christian', 19870108), ('Emily', 19820728), ('Kelly', 19700330), ('Courtney', 19900729), ('Taylor', 19900818), ('Carissa', 19900507), ('Heather', 19810210), ('Georgiana', 19880624), ('Michelle', 19910127), ('Brintney', 19871008), ('Chisako', 19870720), ('Kristen', 19890819), ('Jessica', 19910223), ('Susie', 19700212), ('Ashley', 19830410), ('Megan', 19890818), ('Larraine', 19910713), ('Courtney', 19920503), ('Tiffany', 19860519), ('Olga', 19880819), ('Shauna', 19900424), ('Canna', 19860515), ('Jennifer', 19890525), ('Keri', ''), ('Lauren', 19890922), ('Whitney', 19880108), ('Caitlyn', 19891220), ('Stephanie', 19890627), ('Jacqueline', 19910905), ('Natalia Maria', 19880414), ('Katie', 19921222), ('Stephanie', 19880527), ('Kirsten', 19810703), ('Taylor', 19881121), ('Rebecca', 19880627), ('Maggie', 19881230), ('Arianna', 19910421), ('Katrina', 19860415), ('Jennifer', 19851029), ('Amber', 19920313), ('Kali A', 19880211), ('Merritt', 19890702), ('Whitney', 19860409), ('Jovana', 19900831), ('Daisy', 19841010), ('Danice', 19801001), ('Dana', 19870713), ('Kellie', 19871004), ('Magdalena', 19880701), ('Alison', 19900425), ('Myke', 19610608), ('Isadora', 19920421), ('Kelly', 19900622), ('Kristina', 19890516), ('Lindsey', 19930106), ('Emily Theresa', 19901123), ('Lauren', 19900423), ('Jenna', 19931127), ('Elizabeth', 19831216), ('Kelly', 19891215), ('Chelsea', 19880701), ('Sabrina', 19930104), ('Jamila', 19920114), ('Tracy', 19860926), ('Whitney', 19870831), ('Margaret', 19910927), ('Alexandra', 19920422), ('Mikayla', 19880525), ('Hailee', 19880530), ('Maureen', 19900314), ('Catherine R', 19910609), ('Erin', 19900530), ('Maryam', 19930203), ('Shabnam', 19910726), ('Caitlyn', 19931013), ('Chelsea', 19850919), ('Ashley', 19820703), ('Christina', 19890331), ('Chanel', 19930618), ('Amanda', 19890125), ('Alexandra', 19891129), ('Monica', 19901123), ('Lauren', 19890811), ('Jacquelyn', 19870304), ('Jacquelynn', 19890111), ('Courtney M', 19880916), ('Courtney', 19820114), ('Kristen', 19820114), ('Cameron', 19881217), ('Caroline', 19900110), ('Susanne', 19750213), ('Sarah', 19920801), ('Niltooli', 19900411), ('Victoria', 19891231), ('Hiromi', 19900510), ('Rachel', 19900209), ('Sena', 19970605), ('Christi', 19960204), ('Tatum', 19970428), ('Madeline', 19940911), ('Julia', 19890628), ('Kelly', 19941021), ('Jasmine Janelle', 19920519), ('Maria', 19950924), ('Monet', 19960106), ('Cordelia Currey', 19930607), ('Millie', 19911004), ('Madison', 19941227), ('Zaina', 19970519), ('Katelyn', 19870608), ('Amanda', 19961028), ('Anna Kate', 19941011), ('Tamijean', 19980616), ('Victoria', 19961202), ('Christiana', 19951116), ('Angie', 19750716), ('Kerry', 19680528), ('Anna', 19960128), ('Sabrina', 19920113), ('Brienne', 19971125), ('Sarah', 19960513), ('Stephanie J', 19960305), ('Alexus', 19970206), ('Alexandra', 19990630), ('Chloe', 19900921), ('Megan', 19960122), ('Erin', 19941226), ('Sydney', 19950909), ('Katherine', ''), ('Lauren', 19990905), ('Teresa', 19941010), ('Alix', 19950718), ('Alaina', 19980809), ('Cassie', 19950201), ('Morgan', 19940208), ('Kenna', 19930918), ('Kelli', 19931202), ('Lauren', 19940618), ('Katrina', 19920314), ('Taylor', 19921208), ('Sara Catherine', 19970130), ('Tamara', 19850418), ('Mckenna Alexandra', 19970303), ('Caroline', 19990809), ('Hada', 19980710), ('Lauren', 19970108), ('Jacara', 19980704), ('Ndindi Inziani', 19971224), ('Susanne', 19980505), ('Bianca', 19960804), ('Caitlin', 19960406), ('Iesha', 19911109), ('Chelsie Marie', 19920321), ('Aurora', 19921204), ('Alexandra', 19950811), ('Karolina', 19990305), ('Skylar', 19950616), ('Jillian', 20010513), ('Gabrielle', 19960114), ('Gabriella', 19971216), ('Allison', 19980324), ('Madeline', 19970403), ('Darya', 19981019), ('Seriana', 19980227), ('Erin', 19960312), ('Katherine', 20001206), ('Vivian', 20000111), ('Stephanie M', 19931110), ('Sabrina', 19971216), ('Kate', 19971013), ('Emma', 20000212), ('Lauren', 20010728), ('Kayla', 19930220), ('Khume', 19961023), ('Christiana', 19970614), ('Candace Olivia', 19800101), ('Alycia', 20001231), ('Mikayla', 19990722), ('Tiffany', 19971009), ('Sanyukta', 20010928), ('Karly', 19850115), ('Emma', 19940624), ('Arielle', 20000910), ('Marjorie', 19980202), ('Anastasiya', 19990324), ('Natasha', ''), ('Addison', ''), ('Mbalia', 19980107), ('Safiya', ''), ('Taylor', 20010406), ('Natasha', 19920609), ('Katherine', 20010213), ('Madison', 19961215), ('Omolola', 19840818), ('Reagan', 19980505), ('Katelyn', 19960909), ('Sophie', 20021031), ('Gabrielle', 19920202), ('Taylor', 19981203), ('Andrea', 19940728), ('Annie', 19870905), ('Olivia', 19990308), ('Imani', 20011220), ('Lauren', 20020523), ('Taylor', 20000807), ('Nicole', 20000304), ('Jane', 19881118), ('Chelsea', 20000819), ('Peyton', 19990915), ('Ellie', 20000523), ('Jane', 19931227), ('Anna', 20010815), ('Rosalyn', 19930622), ('Madison', 19990419), ('Sophia', 20010718), ('Jasmine', 19990813), ('Theresa', 19701102), ('Spirit', 19941027), ('Najah', 20010909), ('Sharmada', 19990810), ('Nicole', 20000812), ('Nina', 20020117), ('Alexa', 20020906), ('Naomi', 20020516), ('Sabina', 20010406), ('Katie', 20011231), ('Nikki', 20011019), ('Mccartney', 19990708), ('Tricia', 19920706), ('Peyton', 20011008), ('Anika', 20010807), ('Dalayna', 20001216), ('Kolie', 20000317), ('Cassie', 19960225), ('Anna', 20020102), ('Monica', 19950419), ('Taysia', 20000708), ('Kathleen', 19940728), ('Amanda', 19990718), ('Jimena', 20000707), ('Cassidy', 19950510), ('Brittany', 19950405)]","[('Jolene', 19680831), ('Lisa', 19730810), ('Meilen', 19780117), ('Serena', 19810926), ('Chanda', 19760218), ('Amy', 19720919), ('Tara', 19770526), ('Meghann', 19790413), ('Erika', 19721014), ('Lilia', 19780407), ('Jane', 19740621), ('Jennifer', 19760329), ('Alexandra', 19801215), ('Linda', 19710211), ('Brie', 19800121), ('Corina', 19780126), ('Marissa', 19800623), ('Lindsay', 19760608), ('Kathleen', 19461027), ('Geri', ''), ('Rosie', 19480916), ('Joan', ''), ('Mary Ann', 19461125), ('Billie Jean', 19431122), ('Patti', 19491221), ('Sharon', 19520224), ('Mona', 19481128), ('Ann', 19510504), ('Chris', 19541221), ('Janet', 19530806), ('Jill', 19540519), ('Julie', 19451208), ('Ann', 19550822), ('Joy', 19540519), ('Pam', 19510417), ('Peggy', 19490202), ('Martina', 19561018), ('Laura', 19490504), ('Sally', 19550325), ('Cecilia', 19470524), ('Rene', 19570512), ('Beth', 19570613), ('Patricia', 19511125), ('Kim', 19561011), ('Betsy', 19561023), ('Barbara', 19570402), ('Dianne', 19580811), ('Felicia', 19570720), ('Lindsay', 19550124), ('Lele', 19560910), ('Diane', 19550615), ('Rosalyn', 19601102), ('Marcie', 19530910), ('Pam', 19620704), ('Barbara', 19570501), ('Candy', 19550324), ('Bonnie', 19630911), ('Barbara', 19611022), ('Anne', 19590701), ('Paula', 19570110), ('Nancy', 19550522), ('Andrea', 19650604), ('Anne', 19610928), ('Leslie', 19570312), ('Kathy', 19591203), ('Mary Lou', 19610806), ('Sherry', 19590606), ('Lea', 19590120), ('Kim', 19571222), ('Tracy', 19621212), ('Kate', 19521025), ('Wendy', 19600929), ('Andrea', 19640118), ('Zina', 19631116), ('Susan', 19640628), ('Camille', 19660602), ('Alycia', 19610218), ('Jane', 19531206), ('Vicki', 19620925), ('Heather', 19610611), ('Robin', 19631210), ('Gigi', 19640222), ('Kathy', 19670324), ('Anna Maria', 19601022), ('Beth', 19640528), ('Lori', 19631218), ('Laura', 19630317), ('Kim', 19570928), ('Shelley', 19630619), ('Barbara', 19640703), ('Michaela', 19660227), ('Shawn', 19671221), ('Elise', 19620305), ('Sandy', 19581013), ('Linda', 19691224), ('Lisa', 19620714), ('Terry', 19551128), ('Ann', 19591031), ('Lisa', 19651016), ('Molly', 19650312), ('Hu', 19630416), ('Dee Ann', 19620611), ('Jamie', 19620121), ('Beverly', 19650909), ('Louise', 19620107), ('Cammy', 19681011), ('Susan', 19590415), ('Caryn', 19610314), ('Tina', 19521124), ('Terry', 19661218), ('Marianne', 19671017), ('Gretchen', 19640207), ('Kathrin', 19621128), ('Pamela', 19630703), ('Lindsay', 19620731), ('Jennifer', 19670702), ('Jennifer', 19620426), ('Carol', 19621009), ('Jill', 19640904), ('Elizabeth', 19680826), ('Pam', 19631220), ('Melissa', 19680411), ('Cynthia', 19640326), ('Amy', 19690902), ('Sherri', 19640202), ('Stephanie', 19650206), ('Patty', 19650331), ('Penny', 19640411), ('Wendy', 19640420), ('Katrina', 19680805), ('Leigh Anne', 19641214), ('Donna', 19710705), ('Jennifer', 19690226), ('Andrea', 19710930), ('Anna', 19660117), ('Kimberly', 19730327), ('Laxmi', 19721109), ('Kathy', 19650825), ('Halle', 19690805), ('Ronni', 19660510), ('Ann', 19701013), ('Mary Joe', 19710819), ('Jeri', 19701211), ('Carrie', 19720428), ('Shaun', 19681213), ('Audra', 19711117), ('Stacey', 19701113), ('Tami', 19681113), ('Stacey', 19680319), ('Ginger', 19680914), ('Monica', 19731202), ('Patty', 19680118), ('Nicole', 19690826), ('Jessica', 19700913), ('Kimberly', 19711020), ('Stephanie', 19691105), ('Debbie', 19700825), ('Susan', 19701205), ('Caroline', 19660825), ('Elly', 19690825), ('Meredith', 19710428), ('Sandra', 19740910), ('Anne', 19770119), ('Lindsay', 19770628), ('Venus', 19800617), ('Samantha', 19790117), ('Karin', 19771210), ('Jill', 19740704), ('Bunny', 19570905), ('Rayni', 19560524), ('Jennifer', 19810210), ('Holly', 19790210), ('Nancy', 19420823), ('Dorothy', 19250703), ('Kristy', 19500815), ('Valerie', 19490629), ('Linda', 19501021), ('Peaches', 19490416), ('Tory Ann', 19420808), ('Pamela', 19500312), ('Denise', 19500731), ('Wendy', 19470331), ('Becky', ''), ('Nancy', 19520731), ('Barbara', 19540304), ('Kristien', 19520725), ('Janet', 19530628), ('Daryl', 19540507), ('Ching Ling', 19481008), ('Robin', 19580513), ('Patricia', 19410811), ('Laurie', 19551104), ('Donna', 19541109), ('Linda', 19521114), ('Julie', 19480113), ('Jeanne', 19571005), ('Laurie', 19550614), ('Kathy', 19560618), ('Janice', 19520710), ('Kathy', 19561123), ('Jane', 19530810), ('Marita', 19560219), ('Susie', 19570916), ('Mary', 19500721), ('Mary', 19540907), ('Mary', 19570312), ('Carrie', 19550822), ('Ruta', 19551118), ('Mareen', 19600815), ('Robin', 19560413), ('Caroline', 19601104), ('Emilse', 19571219), ('Kay', 19570925), ('Zenda', 19591212), ('Betty Ann', 19500226), ('Jeanne', 19591207), ('Linda', 19610605), ('Julie', 19620205), ('Stacy', 19590405), ('Dana', 19591126), ('Roberta', 19581103), ('Joyce', 19580503), ('Andrea', 19550406), ('Trey', 19591127), ('Jenny', 19650419), ('Leigh Anne', 19640108), ('Joanne', 19541030), ('Michelle', 19670627), ('Nancy', 19580418), ('Felicia', 19611231), ('Jean', 19581025), ('Barbi', 19640914), ('Amy', 19650405), ('Jill', 19600623), ('Ginny', 19661115), ('Grace', 19680416), ('Melissa', 19690624), ('Debbie', 19670809), ('Eileen', 19661201), ('Maeve', 19641116), ('Kathleen', 19610905), ('Niurka', 19690419), ('Cecilia', 19630628), ('Kristin', 19590827), ('Kate', 19630111), ('Liezel', 19760821), ('Mashona', 19760531), ('Stephanie', 19460308), ('Marilyn', 19480308), ('Mimi', ''), ('Alice', 19421122), ('Pixie', ''), ('Betty', 19250415), ('Nadine', 19441026), ('Victoria', ''), ('Stephanie', 19500703), ('Carole', 19430624), ('Gail', 19510421), ('Patricia', 19400101), ('Eliza', 19530102), ('Patricia', 19450828), ('Sandy', 19560501), ('Tam', 19520127), ('Wendy', 19520430), ('Kathy', 19461218), ('Lisa', ''), ('Judy', 19490816), ('Roberta', 19560702), ('Mary', 19450925), ('Aleida', 19550616), ('Erin', 19550720), ('Stephanie', 19560325), ('Karen', 19421211), ('Sheila', 19580222), ('Susie', 19620329), ('Micki', 19601129), ('Heather', 19610712), ('Jane', 19620121), ('Diane', 19611105), ('Shawna', ''), ('Tammy', 19651012), ('Tracy', 19791006), ('Allison', 19801114), ('Ansley', 19820105), ('Dawn', 19760529), ('Kristen', 19840628), ('Vija', ''), ('Farel', ''), ('Connie', 19510521), ('Marjorie', 19510503), ('Peggy', ''), ('Tish', ''), ('Jade', ''), ('Carole', ''), ('Emilie', ''), ('Diane', ''), ('Mary', ''), ('Ann', ''), ('Tina', ''), ('Maricaye', ''), ('Roylee', 19490526), ('Nancy', 19330421), ('Louise', 19470321), ('Mimi', 19390818), ('Raymonde', ''), ('Carol', ''), ('Joyce', 19420223), ('Pat', 19340819), ('Jane', 19510220), ('Darlene', 19360106), ('Pam', 19501025), ('Carol', ''), ('Emilie', ''), ('Margaret', 19500413), ('Pam', ''), ('Susan', 19531113), ('Shari', ''), ('Sue', 19540603), ('Jeanne', 19350721), ('Kathy', 19521219), ('Gertrude', 19230908), ('Judy', 19430402), ('Brenda', 19540211), ('Patricia', 19580516), ('Marcy', ''), ('Sally', ''), ('Lynne', 19580328), ('Margaret', 19530105), ('Renee', 19340819), ('Carol', 19501022), ('Chris', 19561026), ('Kelly', 19620418), ('Lisa', 19590305), ('Lucy', ''), ('Jody', 19560704), ('Phyllis', 19570326), ('Linda', 19631106), ('Karen', 19640323), ('Eleni', 19671023), ('Lisa', 19680718), ('Sandra', 19690903), ('Shannan', 19700519), ('Julie', 19760424), ('Nicole', 19760203), ('Angela', 19720404), ('Keri', 19740501), ('Jacqueline', 19801126), ('Laura', 19810512), ('Jean', 19740607), ('Melissa', 19820606), ('Amber', 19840706), ('Sarah', 19811106), ('Ashley', 19850502), ('Bethanie', 19850323), ('Allison', 19860410), ('Bea', 19801128), ('Alexandra', 19850902), ('Carly', 19861126), ('Theresa', 19850310), ('Gabriela', 19800607), ('Shenay', 19840706), ('Angela', 19840927), ('Kelly', 19830318), ('Teryn', 19781212), ('Abigail', 19810712), ('Jessica', 19871110), ('Jamea', 19860907), ('Mary', 19881218), ('Tiffany', 19800314), ('Alexa', 19890910), ('Vania', 19890303), ('Ahsha', 19850321), ('Lauren', 19891001), ('Varvara', 19860521), ('Madison', 19900403), ('Audra', 19860421), ('Ashley', 19890620), ('Julie', 19790104), ('Melanie', 19910923), ('Kristie', 19920615), ('Gail', 19910605), ('Asia', 19910404), ('Coco', 19911206), ('Christina', 19920511), ('Mallory', 19900718), ('Lauren', 19910110), ('Hilary', 19881117), ('Sloane', 19930320), ('Alison', 19900703), ('Jamie', 19900108), ('Chelsey', 19900829), ('Beatrice', 19920406), ('Shelby', 19921013), ('Irina', 19900504), ('Lauren', 19931009), ('Madison', 19950217), ('Nicole', 19740801), ('Michelle', 19731228), ('Akiko', 19720214), ('Joy', 19621006), ('Caryn', 19711005), ('Luanne', 19721228), ('Julie', 19720510), ('Rachel Ann', 19721119), ('Judy', 19620511), ('Noelle', 19701218), ('Alysia', 19710131), ('Laura', 19670517), ('Amanda', 19780620), ('Julie', 19721007), ('Ann', 19670822), ('Melissa', 19720621), ('Jan', 19531223), ('Mary', 19620121), ('Sylvia', 19640127), ('Gail', 19470116), ('Diedre', 19711011), ('Caroline', 19651129), ('Kerry', 19501002), ('Kathy', 19670904), ('Stella', 19690309), ('Karen', 19680705), ('Cynthia', 19580614), ('Marlie', 19501120), ('Rona', 19690708), ('Kylie', 19610519), ('Helena', 19610201), ('Cheryl', 19640503), ('Jennifer', 19690715), ('Elizabeth', 19660406), ('Anne', 19660205), ('Alix', 19721022), ('Erica', 19690716), ('Stephanie', 19700424), ('Jill', 19671011), ('Jane', 19630123), ('Kathy', ''), ('Jean', 19700510), ('Ann', 19651028), ('Kirsten', 19690327), ('Wendy', 19600327), ('Nicole', 19610906), ('Vicki', 19570325), ('Mary Ann', 19560424), ('Christine', 19680118), ('Jennifer', 19600326), ('Julie', 19570621), ('Penny', 19550826), ('Cathy', 19580310), ('June', 19630619), ('Pam', 19750701), ('Stephanie', 19791023), ('Jane', ''), ('Gretchen', 19650626), ('Jane', 19660324), ('Holyn', 19731012), ('Kristi', 19690910), ('Linley', 19620501), ('Shelby', 19500626), ('Andrea', 19700128), ('Kathy', 19591224), ('Danielle', 19700322), ('Carol', 19610705), ('Jean', 19550606), ('Lori', 19650330), ('Edie', ''), ('Robin', ''), ('Kerri', 19681001), ('Lisa', 19700324), ('Mary', 19660508), ('Carol', 19591113), ('Katie', 19750429), ('Michele', 19660606), ('Shannon', 19670527), ('Gina', 19490515), ('Clare', ''), ('Cathleen', 19570316), ('Janice', 19510522), ('Betsy', 19540503), ('Lucia', 19601022), ('Wendy', 19680715), ('Allyson', 19631007), ('Debbie', 19620722), ('Marsha', ''), ('Linda', 19690503), ('Page', 19740622), ('Heather', 19711011), ('Gigi', 19701007), ('Marilda', 19650222), ('Christine', 19720714), ('Cynthia Ann', 19521114), ('Jenny', 19710226), ('Shelley', 19650421), ('Jackie', 19640104), ('Stephanie', ''), ('Michelle', 19610116), ('Genevieve', 19630819), ('Glynis', ''), ('Ann', 19520526), ('Allegra', ''), ('Cricket', 19610507), ('Bunny', 19460729), ('Holly Ann', 19701218), ('Amy', 19721112), ('Kathy', 19631005), ('Monique', 19841006), ('Erica', 19721128), ('Susan', 19651125), ('Rita', 19601018), ('Nina', 19610207), ('Donna', 19591005), ('Cissie', 19600108), ('Nancy', 19640804), ('Erika', 19631007), ('Cristina', 19770210), ('Terri', 19680118), ('Patty', 19730928), ('Katrina', 19681104), ('Katrina', 19800530), ('Anne', 19810420), ('Cory Ann', 19850122), ('Nicole', 19861103), ('Diana', 19790704), ('Tanner', 19840803), ('Shadisha', 19850712), ('Leslie', 19870525), ('Neha', 19860206), ('Megan', 19850719), ('Elizabeth', 19880603), ('Jewel', 19810910), ('Lindsey', 19851118), ('Raquel', 19821208), ('Brittany', 19910919), ('Kirsten', 19880814), ('Chieh Yu', 19920114), ('Alexis', 19830331), ('Amanda', 19861204), ('Catherine', 19940409), ('Tetiana', 19840904), ('Julia', 19910909), ('Alexandra', 19880214), ('Zoe Gwen', 19930921), ('Julia', 19890323), ('Jessica', 19940224), ('Grace', 19940506), ('Chi Chi', 19920705), ('Nicole', 19930303), ('Mallory', 19910128), ('Jennifer', 19860922), ('Samantha', 19950218), ('Victoria', 19951130), ('Maria', 19891126), ('Anne', 19850828), ('Megan', 19850311), ('Lena', 19881115), ('Katie', 19830503), ('Courtney B', 19920325), ('Kimberly', 19890509), ('Jacqueline', 19910830), ('Ester', 19930704), ('Eleanor', 19880626), ('Yasmin', 19880504), ('Anne Liz', 19960526), ('Alessondra', 19900906), ('Ryann', 19960723), ('Lucie', 19720406), ('Kelly S', 19730905), ('Kristina', 19790811), ('Wendy', 19750131), ('Julie', 19751016), ('Aurandrea', 19791121), ('Brandis', 19800213), ('Megan', 19781224), ('Alyssa', 19821119), ('Jennifer', 19780807), ('Jennifer', 19840217), ('Candice', 19820331), ('Michelle', 19780119), ('Kristy', 19790517), ('Andrea', 19881006), ('Lauren', 19800829), ('Iris', 19850613), ('Jennifer', 19810718), ('Ali', 19870923), ('Nicole', 19851124), ('Kaysie', 19800411), ('Krystina', 19880510), ('Riza', 19860210), ('Sarah', 19810627), ('Megan', 19830326), ('Story', 19830502), ('Christina', 19801127), ('Stacia', 19850921), ('Kaitlyn', 19920113), ('Chloe', 19900201), ('Amanda', 19870902), ('Kelcy', 19890411), ('June', 19950619), ('Krista', 19940914), ('Adria', 19791221), ('Susie', 19721210), ('Kori', 19731101), ('Elizabeth', 19770823), ('Agnes', 19800801), ('Courtenay', 19770227), ('Dee Dee', 19790211), ('Aurora', 19741107), ('Keirsten', 19730917), ('Ingrid', 19730602), ('Stephanie', 19761207), ('Sara', 19770113), ('Lori', 19810731), ('Milangela', 19811209), ('Brooke', 19790101), ('Lauren', 19820521), ('Amanda', 19780119), ('Kelley', 19850922), ('Meredith', 19720604), ('Jackie', 19840111), ('Megan', 19780427), ('Amanda', 19811126), ('Cammy', 19701225), ('Ditta', 19751226), ('Jennifer', 19731228), ('Krissy', 19791211), ('Annica', 19780902), ('Tory', 19850618), ('Whitney', 19860123), ('Sarah', 19801121), ('Jessyca', 19800826), ('Beau', 19800626), ('Katrina', 19880707), ('Stephanie', 19790129), ('Jennifer', 19881123), ('Jessica', 19871124), ('Sarah', 19880209), ('Kim Anh', 19831004), ('Ellah', 19881122), ('Lauren', 19820914), ('Link', 19861125), ('Aleke', 19820427), ('Kendra', 19831118), ('Arpi', 19830612), ('Erin', 19900328), ('Tiffany', 19820909), ('Robin', 19830621), ('Kristi', 19851222), ('Jennifer Lee', 19870227), ('Veronica Ruo Qi', 19891110), ('Danielle', 19910328), ('Shilpa', 19840412), ('Elizabeth', 19880526), ('Megan', 19870701), ('Melissa', 19880408), ('Lauren', 19890522), ('Alana', 19851031), ('Riley', 19901114), ('Kristen', 19880323), ('Mami', 19790715), ('Kit', 19810726), ('Stacey', 19910718), ('Elizabeth', 19810315), ('Nina', 19890707), ('Nadja', 19900607), ('Erica', 19901127), ('Jenna', 19851126), ('Tiya', 19860611), ('Natalie', 19850322), ('Courtney', 19820929), ('Kristy', 19900108), ('Susanna', 19831103), ('Alexa', 19901117), ('Aeriel', 19900928), ('Maureen', 19820528), ('Allie', 19910420), ('Sanaz', 19880621), ('Lauren', 19760912), ('Alexis', 19840927), ('Libby', 19940124), ('Lauren', 19930723), ('Michaela', 19880722), ('Tori', 19871124), ('Gabrielle', 19930227), ('Danielle Rose', 19931213), ('Tarakaa', 19860811), ('Danielle', 19910528), ('Ellen', 19931008), ('Brooke', 19920408), ('Mccall', 19900315), ('Macall', 19860205), ('Megan', 19880705), ('Nicole', 19930729), ('Alexandra', 19911130), ('Elizabeth', 19860524), ('Jade', 19921028), ('Brie', 19890507), ('Jan', 19950301), ('Simone', 19891230), ('Elizabeth', 19860731), ('Gabrielle Faith', 19961223), ('Sachia', 19950511), ('Taylor', 19960416), ('Lindsey', 19900104), ('Alexandra', 19950630), ('Alexandra', 19910213), ('Robin', 19930412), ('Brianna', 19940219), ('Olivia', 19960122), ('Whitney', 19860811), ('Emily J', 19910615), ('Caroline B', 19941031), ('Chalena', 19950818), ('Elizabeth Anita Alexandria', 19960806), ('Breanna Alexa Bachini', 19930521), ('Mary', 19950817), ('Betsy', 19600427), ('Eve', 19621028), ('Janet', 19670405), ('Jaime', 19611001), ('Angel', 19610830), ('Donna', 19550626), ('Valerie', 19540813), ('Lucinda', 19520717), ('J', ''), ('J', ''), ('D', ''), ('K', ''), ('B', ''), ('J', ''), ('R', ''), ('N', ''), ('E', ''), ('F', ''), ('Caroline', 19560622), ('D', ''), ('Wendy', ''), ('Nancy', 19530830), ('Susan', 19570107), ('Gretchen', 19560201), ('Anne', ''), ('Holly', 19690811), ('Margaret', 19601012), ('Clare', 19671008), ('Kathy', 19641104), ('Rita', 19660512), ('Marlene', 19810731), ('Linda', 19570701), ('Beverly', 19530124), ('Ann', 19551013), ('Robin', 19540923), ('A', ''), ('Maria', ''), ('Karen', ''), ('Karen', ''), ('Jenny', ''), ('Lisa', ''), ('Kathy', ''), ('Maria', 19600424), ('Judith', ''), ('Becky', ''), ('Connie', ''), ('Lori', ''), ('Joni', 19651125), ('Lisa', ''), ('Suzanne', ''), ('Shandra', 19680519), ('Merrilee', ''), ('Jennifer', 19660615), ('Chris', ''), ('Trisha', 19690203), ('Stephanie', 19690818), ('Sonya', 19670825), ('Susan', 19710412), ('Tanya', 19690302), ('Tonya', 19690821), ('Kara', 19730105), ('Melissa', 19740402), ('Victoria', 19761230), ('Trina', 19821230), ('Kristine', 19720623), ('Martha', 19691215), ('Candice', 19800207), ('Cindy', 19790422), ('Elizabeth', 19740824), ('Valerie', 19731228), ('Tracey', 19710129), ('Diana', 19680410), ('Alice', 19770830), ('Allison', 19660804), ('Vickie', 19710827), ('Stacey', 19750105), ('Marissa', 19780613), ('Susanna', 19720303), ('Rebecca', 19721119), ('Ashley', 19720408), ('Varalee', 19760502), ('Stephanie', 19770408), ('Elizabeth', 19631112), ('Bridget', 19740207), ('Leslie', 19720209), ('Traci', 19780805), ('Alison', 19741125), ('Amy', 19681007), ('Vanessa', 19760513), ('Laura', 19720426), ('Anna', 19761021), ('Betsy', 19751127), ('Kristen', 19781002), ('Mugette', 19810424), ('Tu', 19780208), ('Irene', 19790612), ('Jennifer', 19720416), ('Diana', 19751029), ('Jody', 19711122), ('Samantha', 19890509), ('Tristen Z', 19940501), ('Rachel', 19920719), ('Ashley', 19871106), ('Alexandra', 19920223), ('Natalie', 19910801), ('Lindsay', 19880226), ('Amelia', 19920802), ('Caroline', 19930313), ('Camila', 19950929), ('Josie', 19951105), ('Skylar Alexandra', 19940424), ('Brooke', 19960212), ('Alexandra', 19910413), ('Daniella', 19971105), ('Hayley', 19950517), ('Jody', 19780930), ('Ella', 19760917), ('Emily Ann', 19820328), ('Jacquelyn', 19801117), ('Lesley', 19781011), ('Kristen', 19770518), ('Cara', 19720421), ('Zuzanna', 19800403), ('Katie', 19800911), ('Marilyn', 19740114), ('Lena', 19830510), ('Brandi', 19770612), ('Andrea', 19780204), ('Sara', 19801022), ('Hillary', 19820417), ('Mariel', 19800220), ('Whitney', 19800508), ('Darian', 19790615), ('Alexandra', 19820310), ('Prim', 19810115), ('Janet', 19800628), ('Rachel', 19690211), ('Lindsay', 19821207), ('Kirsty', 19780517), ('Raluca Daniela', 19830717), ('Mindy', 19720322), ('Erin', 19830419), ('Mary Carlisle', 19780716), ('Erin', 19800116), ('Keiko', 19800429), ('Maiko', 19820623), ('Paige', 19740714), ('Janet', 19790529), ('Briana', 19781221), ('Stacey', 19721219), ('Kristin', 19720204), ('Julia', 19810518), ('Rochelle', 19800430), ('Selin', 19780706), ('Jennifer', 19730117), ('Luana', 19821205), ('Whitney', 19850811), ('Paloma', 19720823), ('Tumeka', 19761226), ('Maria', 19830319), ('Hyacinth', 19610809), ('Eva', 19840706), ('Kara', 19790920), ('Katie', 19841110), ('Melissa', 19840613), ('Emmy', 19870722), ('Alexandria', 19860310), ('Shari', 19641103), ('Michelle', 19791212), ('Alexandra', 19841228), ('Nicole', 19860203), ('Monica', 19851212), ('Caitlin', 19850517), ('Lia', 19800922), ('Michelle', 19870304), ('Sybil', 19770106), ('Jodi', 19810822), ('Liberty', 19870409), ('Mimi', 19841030), ('Melissa', 19861211), ('Jessi', 19870221), ('Courtney', 19880501), ('Chrissie', 19870902), ('Yvette', 19880612), ('Audra', 19830331), ('Leila', 19860206), ('Tamara', 19790924), ('Rebekah', 19791012), ('Sabita', 19840927), ('Shannon', 19870109), ('Courtney', 19851011), ('Polina', 19860408), ('Anamika', 19890413), ('Jie', 19871101), ('Georgette', 19840709), ('Christy', 19871212), ('Suzanne', 19880117), ('Courtney', 19900327), ('Cammie', 19871122), ('Nelly', 19901113), ('Veronica', 19870514), ('Keilly', 19900505), ('Kate', 19831111), ('Reka', 19890708), ('Bianca', 19890514), ('Thien Trang', 19910918), ('Pamela', 19910101), ('Morgan', 19920220), ('Julianna', 19850107), ('Subbadharmi', 19890708), ('Stephanie', 19930216), ('Kelsey', 19910408), ('Alexandra', 19870719), ('Amanda', 19880314), ('Chelsea', 19891211), ('Anna', 19840821), ('Jill M', 19910313), ('Kady', 19860317), ('Phoebe', 19880520), ('Emily', 19921201), ('Christian', 19840913), ('Keri', 19891225), ('Sabrina', 19860112), ('Nataly', 19900913), ('Maria', 19920619), ('Noel', 19930203), ('April', 19920508), ('Ellie', 19930808), ('Stephanie', 19901027), ('Nicole', 19911031), ('Anna', 19940308), ('Veronika', 19900920), ('Annie', 19930330), ('Kyle', 19940405), ('Chanelle', 19940119), ('Yawna', 19860801), ('Hilary', 19910513), ('Ivana', 19861108), ('Gira', 19860829), ('Claire', 19891129), ('Erin', 19880609), ('Caitlin', 19880219), ('Alexandra', 19850703), ('Jennifer', 19950412), ('Kimberly', 19961015), ('Natalie', 19891102), ('Elizaveta Anna', 19930831), ('Veronica M', 19911207), ('Karina', 19950706), ('Sylvia', 19860904), ('Sherry', 19950208), ('Katrine Isabel', 19960315), ('Denise', 19950417), ('Courtney', 19940325), ('Christina', 19960529), ('Noelle', 19881205), ('Lauren', 19950517), ('Breaunna', 19941222), ('Nicole', 19941230), ('Meredith', 19970521), ('Nadia', 19950114), ('Jackie', 19710922), ('Antoinette', 19850107), ('Kathleen', 19740511), ('Kylene', 19790725), ('Dana', 19730725), ('Audra', 19720605), ('Tracee', 19731009), ('Amie', 19800517), ('Jennifer', 19811128), ('Lashawnn', 19740602), ('Jacqueline', 19820209), ('Jennifer', 19770119), ('Kristy', 19741230), ('Susan', 19741201), ('Bridget', 19761018), ('Amy', 19690628), ('Sandra', 19750116), ('Khristen', 19750803), ('Stefanie', 19810322), ('Barrie', 19730724), ('Kate', 19820415), ('Amy', 19731107), ('Anne', 19780520), ('Lauren', 19740830), ('Dewonder', 19590127), ('Kendra', 19790828), ('Jamie', 19801106), ('Jennifer', 19750823), ('Audrey', 19850430), ('Marjorie', 19750503), ('Katie', 19770527), ('Aimee', 19820110), ('Megan', 19810519), ('April', 19781129), ('Maren', 19791106), ('Sarah', 19780514), ('Marie Ange', 19780114), ('Dina', 19680406), ('Margaret', 19760707), ('Mary Beth', 19760329), ('Patricia', 19841020), ('Ashley', 19821229), ('Kathryn', 19790225), ('Leslie', 19810718), ('Becky', 19640801), ('Julie', 19811223), ('Danielle', 19781110), ('Terri', 19650402), ('Amy', 19681215), ('Douglas', 19840522), ('Sara', 19850621), ('Karla', 19770318), ('Kristin', 19841130), ('Kristin', 19810705), ('Bonnie', 19850503), ('Natalie', 19830401), ('Jennifer', 19830702), ('Claire', 19700527), ('Lauren', 19780316), ('Alison', 19791129), ('Laura', 19710624), ('Katia', 19810816), ('Kara', 19771202), ('Violette', 19790927), ('Lisa', 19740221), ('Evonne', 19740923), ('Mandy', 19790312), ('Jessica', 19800415), ('Emily', 19811119), ('Callie', 19770711), ('Maggie', 19750529), ('Elina', 19820521), ('Terry Ann', 19740428), ('Kimberly', 19790725), ('Bettina', 19820718), ('Lindsay', 19800519), ('Johanna', 19750518), ('Amy', 19790124), ('Meiling', 19791112), ('Jennifer', 19781020), ('Vania', 19810428), ('Megan', 19831014), ('Lindsey', 19800201), ('Megan', 19820411), ('Angela', 19840329), ('Megan', 19840920), ('Nicolette', 19831108), ('Anita', 19860219), ('Alessandra', 19870112), ('Aradhana', 19820709), ('Tiffany', 19831228), ('Macey', 19830224), ('Kelcy', 19861225), ('Caylan', 19820701), ('Stephanie', 19820923), ('Jan', 19580317), ('Kate', 19830530), ('Karen', 19671205), ('Sarah Jane', 19820802), ('Catrina', 19840913), ('Bethany', 19821129), ('Lindsay', 19820811), ('Kathleen', 19820917), ('Amy', 19810415), ('Emilia', 19820204), ('Colleen', 19790212), ('Ashlee', 19850522), ('Saras', 19830726), ('Brittany', 19850420), ('Laila', 19810805), ('Natalie', 19851103), ('Celena', 19790130), ('Marine', 19780929), ('Cara', 19730424), ('Loni', 19810928), ('Christyn', 19850210), ('Cassy', 19850802), ('Manisha', 19770513), ('Jennifer', 19811121), ('Michelle', 19801002), ('Brook', 19851231), ('Samantha', 19840807), ('Stephanie', 19870411), ('Courtney', 19820502), ('Melissa', 19840112), ('Kristin', 19790227), ('Adriana', 19780902), ('Christine', 19831216), ('Julie', 19840521), ('Cristina', 19860826), ('Nadia', 19850209), ('Amanda', 19821020), ('Camelia', 19860406), ('Emily', 19850201), ('Danielle', 19840717), ('Rochelle', 19800627), ('Brianna', 19851215), ('Zena', 19880717), ('Adina', 19870619), ('Lauren', 19880204), ('Lauren', 19870928), ('Meg', 19870811), ('Ristine', 19850116), ('Jennifer', 19841115), ('Lindsey', 19860101), ('Lindsay', 19880524), ('Gloriann', 19840228), ('Patricia', 19740119), ('Kelly', 19820223), ('Amanda', 19870813), ('Elizabeth', 19860128), ('Whitney', 19851225), ('Laura', 19850506), ('Masha', 19840211), ('Karina', 19880811), ('Erin', 19850113), ('Randi', 19870211), ('Kewa', 19860701), ('Hala', 19850809), ('Dasha', 19870606), ('Suzanna', 19861013), ('Colleen', 19880209), ('Blair', 19830904), ('Simone', 19881010), ('Jessica', 19870304), ('Austin', 19860601), ('Preethi', 19850629), ('Christala', 19890709), ('Krista', 19900423), ('Marie', 19830721), ('Ashley', 19861113), ('Latrell', 19891212), ('Sheryl', 19850920), ('Amanda', 19850319), ('Blakeley', 19841114), ('Ashley', 19870917), ('Whitney', 19890109), ('Marlene', 19880329), ('Melissa', 19860801), ('Alex', 19870117), ('Jessica', 19811223), ('Megan', 19890204), ('Jacqueline', 19830608), ('Melody', 19830708), ('Sarah', 19910314), ('Marie', 19910614), ('Daron', 19851128), ('Amy', 19790324), ('Dina', 19871014), ('Mia', 19910312), ('Valerie', 19851231), ('Amanda', 19880523), ('Connor', 19870922), ('Elizabeth', 19920114), ('Brittany', 19870208), ('Kristen A', 19880325), ('Julie', 19880331), ('Sarah', 19880129), ('Emily', 19890724), ('Christine', 19871225), ('Amanda', 19850511), ('Nicole', 19880620), ('Laurianne', 19881018), ('Pamela', 19901124), ('Miya', 19871114), ('Rachel', 19830708), ('Joanna', 19891009), ('Lynn', 19791216), ('Claire', 19871108), ('Paola', 19920827), ('Lauren', 19890512), ('Erin Carol', 19930506), ('Cameron', 19881224), ('Julie', 19870627), ('Stefanie', 19890130), ('Hannah', 19910812), ('Katherine', 19860305), ('Olivia', 19880423), ('Christina', 19880426), ('Christina', 19881212), ('Cierra', 19910927), ('Milena', 19850506), ('Christin J', 19870731), ('Stephanie', 19900327), ('Kaysara', 19910623), ('Nina', 19900115), ('Deirdre', 19901205), ('Kristin', 19841024), ('Jacqueline', 19900913), ('Stephany', 19900609), ('Erica', 19900702), ('Julia', 19910916), ('Grace', 19891211), ('C C', 19911009), ('Sarah', 19910422), ('Marianne', 19850906), ('Monica', 19920622), ('Kate', 19920109), ('Amanda Marie', 19860106), ('Alexa', 19900824), ('Denise', 19890731), ('Molly', 19890525), ('Nelo', 19920705), ('Farwa', 19891101), ('Millie', 19641005), ('Brooke Lindsey', 19940622), ('Lilly F', 19911101), ('Brynn', 19910801), ('Karina', 19831112), ('Tracy', 19740827), ('Desiree', 19931110), ('Rachael', 19910427), ('Alrissa', 19920724), ('Amanda', 19870317), ('Olivia', 19910711), ('Caryssa L', 19920413), ('Monica', 19930108), ('Joelle', 19910606), ('Malika', 19910709), ('Theresa', 19930607), ('Mary Anne', 19920215), ('Morocco', 19921107), ('Mara', 19920222), ('Alejandra Maria', 19950228), ('Catherine', 19880430), ('Kate', 19901106), ('Abigail', 19900209), ('Sabrina', 19930224), ('Heatherm', 19890925), ('Stephanie', 19940511), ('Leighann', 19931204), ('Lauren', 19880816), ('Kayla', 19920921), ('Kir', 19891031), ('Skylar', 19930914), ('Julia', 19931207), ('Meghan', 19930621), ('Nida', 19911029), ('Lauren', 19880905), ('Kelly K', 19910531), ('Alyssa Grace', 19950215), ('Mary', 19911122), ('Madeleine', 19920319), ('Rachel', 19840302), ('Alex', 19911229), ('Kyra', 19960510), ('Suzy', 19940830), ('Remeice', 19891112), ('Kate', 19940201), ('Courtney', 19891015), ('Molly', 19930810), ('Stephanie', 19940131), ('Alexandra M', 19870719), ('Aleksandra', 19960409), ('Erin', 19880709), ('Jessica', 19930428), ('Spencer', 19950125), ('Anik', 19910405), ('Simone', 19920717), ('Emma', 19930623), ('Melissa', 19921004), ('Tina', 19950427), ('Julia', 19940613), ('Rachael', 19931209), ('Shelby', 19930114), ('Epiphany B', 19921217), ('Kaitlin', 19921215), ('Mariana', 19950927), ('Hannah', 19951103), ('Casey', 19910613), ('Deborah', 19940514), ('Jessica', 19931117), ('Kelsey', 19940821), ('Samantha', 19930126), ('Blair', 19940814), ('Martha V', 19900628), ('Amanda', 19930322), ('Sarah', 19920729), ('Emily', 19931112), ('Jamie', 19950308), ('Kelly', 19770505), ('Quinn', 19941110), ('Sophia', 19930330), ('Sierra A', 19900816), ('Mckenzie', 19940107), ('Stacey', 19900117), ('Courtney', 19910226), ('Rosalia', 19900208), ('Sydney', 19950207), ('Mia', 19950406), ('Erin Kane', 19960512), ('Laura', 19841119), ('Eva', 19921222), ('Elizabeth', 19940706), ('Sarah', 19930713), ('Elyse', 19870910), ('Sabrina', 19920912), ('Julia', 19890114), ('Gabriella', 19951208), ('Tanya', 19930914), ('Nyla', 19960730), ('Louisa', 19960516), ('Zina', 19980402), ('Tornado Alicia', 19980512), ('Madison', 19970919), ('Rima', 19951116), ('Kourtney J', 19940907), ('Natasha', 19940823), ('Erin', 19901230), ('Rachel May', 19941113), ('Jillian', 19941210), ('Caroline', 19960315), ('Dominique', 19870203), ('Trelsie', 19890707), ('Angela', 19950604), ('Nicole', 19980429), ('Kim', 19951027), ('Emina', 19930330), ('Lynda', 19921123), ('Joanna Mary', 19930201), ('Caroline', 19960103), ('Julia', 19940403), ('Callie', 19910904), ('Maxine', 19910710), ('Katie', 19921211), ('Emma Christine', 19980201), ('Johnnise', 19960510), ('Katerina', 19970717), ('Jessica', 19970105), ('Marjorie', 19880420), ('Maci', 19931007), ('Kaitlyn', 19971204), ('Jacqueline', 19941203), ('Charity', 19870711), ('Parris', 19980708), ('Jamie', 19930819), ('Miriam Ruth', 19940724), ('Elizabeth', 19910118), ('Amanda', 19860130), ('Lindsay', 19780708), ('Erica', 19860327), ('Dina', 19711211), ('Robyn', 19850111), ('Anita', 19810402), ('Casey', 19840501), ('Emily', 19850224), ('Jamie', 19880415), ('Brittany', 19880627), ('Elizabeth', 19550921), ('Carolyn', 19900415), ('Cassandra', 19891211), ('Prissy', 19910807), ('Kristin', 19830420), ('Diamond', 19901226), ('Celia', 19860527), ('Tiffany', 19891126), ('Jennifer', 19890531), ('Komal', 19930108), ('Roxanne', 19890826), ('Mandy', 19810914), ('Amanda', 19800324), ('Alissa', 19671209), ('Kay', 19570927), ('Jane', 19661222), ('Tracie', 19610116), ('Elizabeth', 19630811), ('Cinda', 19710410), ('Tracy', 19611021), ('Dena', 19650928), ('Hemel', 19660108), ('Karen', 19630803), ('Reka', 19670612), ('Vincenza', 19660820), ('Lisa', 19640803), ('Lynn', 19661018), ('Jill', 19731226), ('Julie', 19710609), ('Kilmeny', 19660218), ('Kay', 19690131), ('Debbie', 19651129), ('Anne Marie', 19660720), ('Leslie', 19660908), ('Lisa', 19630604), ('Lisa', 19611106), ('Tory', 19660712), ('Kylie', 19700509), ('Anya', 19690220), ('Jennifer', 19670106), ('Diana', 19721007), ('Betsy', 19671127), ('Katrina', 19671129), ('Karen', 19701102), ('Susan', 19710206), ('Sherri', 19730118), ('Tonya', 19691110), ('Julie', 19680817), ('Susan', 19710206), ('Jamie', 19691029), ('Alita', 19630112), ('Tara', 19681223), ('Erika', 19720516), ('Kellie', 19670601), ('Happy', 19680605), ('Angie', 19710323), ('Bonnie', 19770412), ('Farley', 19741212), ('Tunecia', 19701023), ('Roseann', 19710227), ('Allison', 19710927), ('Hillery', 19610619), ('La Shawnn', 19740206), ('Sylvia', 19610419), ('Kathy', 19741105), ('Zuzanna', 19790726), ('Cassi', 19850902), ('Lejla', 19870206), ('Danielle', 19820120), ('Geneva', 19871225), ('Katie', 19891023), ('Katie', 19881216), ('Brittany', 19940406), ('Allie', 19950630), ('Sofia', 19981114), ('Mia', 19970723), ('Ty Ana', 19970313), ('Karina Kristina', 19981021), ('Jessica', 19890916), ('Trisha', 19981027), ('Ashley', 19881017), ('Tina', 19920831), ('Tatijana', 19971116), ('Taylor L', 19950117), ('Alexa', 19980707), ('Emerald', 19970905), ('Marie', 19970611), ('Alexandra', 19950224), ('Aleah', 19910923), ('Sarah', 19941219), ('Usue Maitane', 19981028), ('Ellie', 19970710), ('Maia A', 19960921), ('Raquel', 19980128), ('Peggy', 19951110), ('Rebecca', 19971004), ('Camila', 19961125), ('Karyn', 19940912), ('Ayla', 19960715), ('Rasheeda', 19950630), ('Amy', 19941028), ('Ariana', 19960126), ('Luisa', 19951005), ('Mary', 19910802), ('Kristi', 19900427), ('Ronit', 19931203), ('Julia Christine', 19921027), ('Kristina N', 19910125), ('Macie', 19941023), ('Jessica', 19950102), ('Rhiann', 19940622), ('Frances', 19940222), ('Kelly', 19960221), ('Hanna', 19980225), ('Natalie', 19960508), ('Dasha', 19961011), ('Elizabeth', 19910218), ('Brianna', 19951012), ('Kristin', 19951122), ('Kristina', 19951204), ('Maddie', 19971117), ('Raveena', 19980723), ('Daniella', 19971027), ('Laura', 19970305), ('Idia', 19930922), ('Chloe Michele', 19970905), ('Morgan', 19941219), ('Nikki', 19960418), ('Sianna', 19900804), ('Nicole', 19990508), ('Mercedes', 19970525), ('Lourdes', 19990531), ('Adi', 19951213), ('Anna', 19971103), ('Alexandra', 19980719), ('Katarina', 19960704), ('Michaela', 19990726), ('Ena', 19980212), ('Catherine Cartan', 19990408), ('Hadley', 19960311), ('Madison', 19960402), ('Jaeda', 19990728), ('Jeannez', 19960707), ('Erica', 19980316), ('Jessie', 19980419), ('Andie K', 19970107), ('Alexandria', 19960511), ('Gabriella', 19960709), ('Kelly', 19990509), ('Terri', 19960723), ('Angel', 19850125), ('Maria', 19970506), ('Alexis', 19980809), ('Rianna', 19960903), ('Megen', 19960709), ('Caroline', 19980905), ('Sophie', 19970528), ('Nicole', 19960504), ('Jacqueline', 19970531), ('Jessica', 19970709), ('Adriana', 19890308), ('Kylie', 19970606), ('Yuki Kristina', 19950819), ('Lexi', 19950525), ('Caroline', 19970726), ('Ingrid', 19980616), ('Alexandra', 19970301), ('Nada', 20000308), ('Alexis', 19950606), ('Felicity', 19970313), ('Tory', 19930105), ('Aimee', 19940907), ('Alli', 19961203), ('Claudia', 19961206), ('Brooke', 19951010), ('Marina', 19981123), ('Zoe Adeline', 19941217), ('Jessica', 19970605), ('Ashley', 19920829), ('Valerie', 19971122), ('Ashley', 19990208), ('Brittany', 19920303), ('Olivia', 19940623), ('Taylor', 19950731), ('Alexis', 19950724), ('Sara', 19971217), ('Lindsay', 19930107), ('Liza', 19950317), ('Jayci', 20000517), ('Marina', 19920314), ('Sydney', 19990430), ('Alyza', 19951122), ('Sophia', 19920113), ('Riley', 19990615), ('Delaney', 19981028), ('Jane', 19961112), ('Valerie Ann', 19980801), ('Carolyn', 19970524), ('Maegan', 19950416), ('Tamara', 19971129), ('Mary', 19981025), ('Victoria', 19990401), ('Kennedy', 19970521), ('Amy', 19970120), ('Makenna', 19980226), ('Stephanie', 19980415), ('Nicole Taylor', 19990426), ('Claire', 20000525), ('Jada', 19990129), ('Sara', 19970723), ('Hannah', 19960923), ('Sophia', 19971005), ('Akiko', 19930913), ('Karina', 19970808), ('Haley', 19910403), ('Paige', 19970222), ('Kayla', 19990928), ('Carson', 20000909), ('Amanda', 19940813), ('Maria', 19990721), ('Kylie', 19990321), ('Luciana', 19981001), ('Zoe', 20010308), ('Sachi', 19981129), ('Audrey', 19951029), ('Anna', 19970319), ('Abigail', 20010122), ('Cameron', 19990920), ('Katelyn', 19921211), ('Katharine', 19961019), ('Elyse', 19981014), ('Mimi', 19930430), ('Bess', 19971029), ('Ines Karmen', 19970615), ('Taylor', 19990615), ('Kristen', 19970407), ('Sabrina', 19971003), ('Desirae', 19940111), ('Sarah', 19960418), ('Rachel', 19961108), ('Victoria', 19990807), ('Nini', 19950909), ('Francesca', 19970722), ('Makenzie', 19990610), ('Chiara', 19980826), ('Melissa', 19930602), ('Morgan', 19990416), ('Jerricka', 19950116), ('Eva', 19961102), ('Miranda', 19990307), ('Teresia', 19990529), ('Julia', 19971217), ('Malkia', 20000808), ('Lorraine M', 19930615), ('Carol', 19960218), ('Jocelyn', 19900526), ('Roosh', 19920321), ('Alexa', 19980703), ('Alyvia', 20000503), ('Katie', 19990929), ('Meible', 19990519), ('Elizabeth', 20010712), ('Emma', 20010518), ('Arianna', 19950206), ('Kiah', 19950117), ('Alyssa', 20000210), ('Stephanie', 19880402), ('Sofia', 19990722), ('Sarah', 19930814), ('Melan', 19970406), ('Alexandra', 19990105), ('Dilara', 19990911), ('Hurricane Tyra', 20010302), ('Taylor', 19980222), ('Nami', 19980827), ('Marcella', 20001012), ('Sophia', 20010630), ('Delisha', ''), ('Haley', ''), ('Jenna', ''), ('Nikita', 19931021), ('Hoda', ''), ('Meredith', 19990310), ('Morgan', 19950317), ('Kirsten', 19940508), ('Maya', 19940527), ('Kat', 19930215), ('Alexandra', 19930215), ('Meghan', 19971028), ('Salma', 20000828), ('Madeline', 19990307), ('Lindsay', 19981217), ('Alexa', 20010908), ('Mary Catherine', 19971104), ('Cheyenne', 19960326), ('Neri', 19990902), ('Jesse', 20011004), ('Ann', 20000626), ('Natalia', 19930929), ('Whitney', 20020417), ('Christina', 19970725), ('Sofia', 19980703), ('Nicole', 20000805), ('Kenadi', 19970313), ('Paiton', 19980808), ('Shannon', 19950915), ('Elysia', 20000324), ('Ashley', 19991026), ('Alexis', 19970314), ('Caty', 20011120), ('Isabella', 20010706), ('Elizabeth', 20010519), ('Anna', 20020306), ('Dakota', 20020508), ('Janice', 19990105), ('Amanda', 20010831), ('Jada', 19980319), ('Hind', 19990228), ('Mikaela', 19890801), ('Micheline', 19970428), ('Kendal', 19940106), ('Anna', 19991008), ('Mia', 19981021), ('Chloe', 20010830), ('Abigail', 20010310), ('Ryan', 19990510), ('Maia', ''), ('Jana', 19941110), ('Shale', 20011015), ('Helen Abigail', 19980520), ('Kariann', 19990116), ('Kennedy', 19980903), ('Caroline', 19980929), ('Allison', 19981031), ('Melissa', 19970624), ('Ellyse', 19961109), ('Charleen', 19410918), ('Doris', 19250620), ('Patricia', 19370601), ('Pauline', 19190806), ('Helen', 19290507), ('Mary', ''), ('Althea', 19270825), ('Carrie', 19571026), ('Cathy', 19510822), ('Karen', 19570408), ('', ''), ('Barbara', ''), ('Susan', 19611219), ('Jan', 19630609), ('Diane', 19650626), ('Carol', 19620605), ('Leanne', ''), ('Shelley', 19631120), ('Maureen', ''), ('Lorrie', 19601015), ('Tiffany', 19600417), ('Sarah', 19741010), ('Meg', ''), ('Wendy', ''), ('Lynn', 19660819), ('Heidi', 19640507), ('Jacqueline', 19620329), ('Sheri', 19690629), ('Diane', 19710121), ('Angela', 19641211), ('Nancy', ''), ('Liz', 19640423), ('Jamie', 19630530), ('', ''), ('Laura', 19681210), ('Jill', ''), ('Courtney', 19560622), ('Tiffany', 19810121), ('Kristen', 19810501), ('Wendy', 19681001), ('Sheila', ''), ('Heidi', 19601007), ('Julie', 19610523), ('Deborah', 19701129), ('Jennifer', ''), ('Cindy', 19591207), ('Lynn', ''), ('I', ''), ('Lisa', 19600808), ('Jill', 19540907), ('Aschara', ''), ('Heidi', 19720713), ('Julie', 19710609), ('', ''), ('G', ''), ('Stephanie', 19661010), ('Lucy', 19540402), ('Cathy', ''), ('', ''), ('Emmy', ''), ('', ''), ('Claudette', ''), ('Lisa', ''), ('Lynn', 19631114), ('Lindsay', ''), ('Lisa', 19630218), ('Virginia', ''), ('Lloyd', 19451208), ('Suzanne', 19750612), ('Caren', 19611110), ('Allegra', 19720113), ('Molly', 19630215), ('Lori', 19600112), ('Lindsay', 19780417), ('Adrienne', 19680903), ('Quynh', 19710627), ('Kari', 19810120), ('Lisa', 19590212), ('Christa', 19790115), ('Kelly', 19770505), ('Massoumeh', 19770803), ('Louise', 19500119), ('Jayne', 19741006), ('Christine', ''), ('Kim', 19780329), ('Lani', 19600808), ('Julie', 19690425), ('Ruth Ann', 19700506), ('Lauren', 19830423), ('Tasha', 19760223), ('Kealy', 19801030), ('Courtney', 19721230), ('Julie Ann', 19750618), ('Nicole', 19741001), ('Ashlee', 19801005), ('Kelly', 19751106), ('Alexandra', 19790210), ('Mary', 19730912), ('Lisa', 19660204), ('Monty', 19650506), ('Julie Anne', 19800911), ('Lorrie', 19651203), ('Kendra', 19760621), ('Chris', 19610706), ('Christine', 19850303), ('Rankin', 19840126), ('Julia', 19850721), ('Sabaea', 19811125), ('Nicole', 19750602), ('Joyce', 19800628), ('Sarah', 19820410), ('Jean Marie', 19651109), ('Stacey', 19720110), ('Varita', 19820702), ('Shera', 19780910), ('Trisha', 19710617), ('Suzanne', 19680921), ('Lisa', 19801119), ('Martha', 19551005), ('Kandiss', 19770221), ('Brooke', 19780413), ('Cristina', 19750825), ('Jasmine', 19810102), ('Kathleen', 19830125), ('Melissa', 19770524), ('Michelle', 19731114), ('April', 19831011), ('Olivia', 19810310), ('Melissa', 19650221), ('Cami', 19720314), ('Marissa', 19780318), ('Kristin', 19720204), ('Christi', 19610509), ('Cindy', ''), ('Ashley', 19830506), ('Leigh', 19831014), ('Natalia', 19831110), ('Nikhila', 19850208), ('Rachel', 19820916), ('Alison', 19850118), ('Cameron', 19830328), ('Gretchen', 19820304), ('Cackie', 19661107), ('Stephanie', 19650104), ('Miriam', 19850925), ('Nicole', 19880219), ('Lilivette', 19800225), ('Jonni', 19791203), ('Amanda', 19850102), ('Weyli', 19800722), ('Helene', 19841215), ('Amanda', 19841101), ('Nicole', 19870615), ('Stefani', 19841215), ('Laura', 19860217), ('Tifanie', 19880920), ('Mary', 19651124), ('Katherine', 19730414), ('Monica', 19800204), ('Nicole', 19850105), ('Shanna', 19750428), ('Jane', 19890926), ('Estelle', 19890503), ('Maria', 19820204), ('Jessica', 19860812), ('Renata', 19650224), ('Laura', 19830408), ('Lindsey', 19840313), ('Christy', 19850925), ('Timberly', 19831209), ('Brooke', 19850423), ('Kelli Elizabeth', 19940409), ('Melanie', ''), ('Whitney P', 19930625), ('Sydni', 19880612), ('Jasmine Nicole', 19930826), ('Alexandra', 19920812), ('Amber', 19870605), ('Kelsey', 19920610), ('Alex', 19920225), ('Ashley M', 19940304), ('Lauren', 19940828), ('Stacia', 19930914), ('Alexandria', 19900111), ('Rozel Asuncion', 19950616), ('Bolan', 19890908), ('Annie', 19920829), ('Eva', 19941007), ('Whitney', 19900909), ('Hanna', 19911107), ('Mandy', 19910501), ('Gia', 19900614), ('Brooke', 19951105), ('Lisa', 19680519), ('Alexandra M', 19930120), ('Sonya Sheeran', 19940816), ('Shinann', 19900608), ('Nicolette', 19950824), ('Rebecca', 19921125), ('Ashley', 19960430), ('Savannah', 19950115), ('Margaret', 19570423), ('Carlee', 19950724), ('Sarah', 19850718), ('Caroline', 19840926), ('Alexia', 19940421), ('Micaela', 19890311), ('Tina', 19810116), ('Manon Cristina', 19941224), ('Hailey M', 19930127), ('Tiffany', 19911216), ('Devan', 19940528), ('Courtenay', 19770227), ('Christine', 19931110), ('Emily', 19900517), ('Leyla', 19930423), ('Alexis', 19880722), ('Di Andrea', 19950730), ('Jandayia', 19960303), ('Margarita', 19950317), ('Olivia', 19941211), ('Caitlin', 19910905), ('Kara', 19910629), ('Paloma', 19890313), ('Susie', 19491114), ('Emily', 19861118), ('Abbie', 19951121), ('Alanna', 19950107), ('Siobhan', 19871110), ('Kayla Symone', 19960110), ('Margie', 19901106), ('Jamie', 19820521), ('Adria', 19791221), ('Lynn', 19941106), ('Nadege', 19960527), ('Lauren', 19941203), ('Tiffany', 19881204), ('Sarah', 19880907), ('Victoria', 19941214), ('Natalia', 19950325), ('Alexandra', 19931013), ('Montana', 19970219), ('Samantha Rose', 19940410), ('Angela', 19980331), ('Samantha', 19950527), ('Elizabeth', 19890419), ('Sarah', 19941121), ('Gabriela', 19950418), ('Tina', 19911222), ('Mia', 19920116), ('Stephanie', 19920831), ('Kennan', 19960317), ('Madison', 19930602), ('Whitney', 19910815), ('Sarah', 19960925), ('Brooke', 19980614), ('Jessie Lynn', 19951228), ('Brittany', 19941212), ('Kylie', 19870826), ('Erin', 19861102), ('Lindsay', 19821118), ('Jessica', 19801107), ('Yuliya', 19860609), ('Kathryn', 19831129), ('Lyndsey', 19820509), ('Tiana', 19841014), ('Keri', 19870310), ('Sarah', 19871201), ('Alyssa', 19841006), ('Rachel', 19870205), ('Angelina', 19521229), ('Amy', 19540720), ('Bernadette', 19821015), ('Tarrin', 19820423), ('Christine', 19670817), ('Christian', 19870108), ('Emily', 19820728), ('Kelly', 19700330), ('Courtney', 19900729), ('Taylor', 19900818), ('Carissa', 19900507), ('Heather', 19810210), ('Georgiana', 19880624), ('Michelle', 19910127), ('Brintney', 19871008), ('Chisako', 19870720), ('Kristen', 19890819), ('Jessica', 19910223), ('Susie', 19700212), ('Ashley', 19830410), ('Megan', 19890818), ('Larraine', 19910713), ('Courtney', 19920503), ('Tiffany', 19860519), ('Olga', 19880819), ('Shauna', 19900424), ('Canna', 19860515), ('Jennifer', 19890525), ('Keri', ''), ('Lauren', 19890922), ('Whitney', 19880108), ('Caitlyn', 19891220), ('Stephanie', 19890627), ('Jacqueline', 19910905), ('Natalia Maria', 19880414), ('Katie', 19921222), ('Stephanie', 19880527), ('Kirsten', 19810703), ('Taylor', 19881121), ('Rebecca', 19880627), ('Maggie', 19881230), ('Arianna', 19910421), ('Katrina', 19860415), ('Jennifer', 19851029), ('Amber', 19920313), ('Kali A', 19880211), ('Merritt', 19890702), ('Whitney', 19860409), ('Jovana', 19900831), ('Daisy', 19841010), ('Danice', 19801001), ('Dana', 19870713), ('Kellie', 19871004), ('Magdalena', 19880701), ('Alison', 19900425), ('Myke', 19610608), ('Isadora', 19920421), ('Kelly', 19900622), ('Kristina', 19890516), ('Lindsey', 19930106), ('Emily Theresa', 19901123), ('Lauren', 19900423), ('Jenna', 19931127), ('Elizabeth', 19831216), ('Kelly', 19891215), ('Chelsea', 19880701), ('Sabrina', 19930104), ('Jamila', 19920114), ('Tracy', 19860926), ('Whitney', 19870831), ('Margaret', 19910927), ('Alexandra', 19920422), ('Mikayla', 19880525), ('Hailee', 19880530), ('Maureen', 19900314), ('Catherine R', 19910609), ('Erin', 19900530), ('Maryam', 19930203), ('Shabnam', 19910726), ('Caitlyn', 19931013), ('Chelsea', 19850919), ('Ashley', 19820703), ('Christina', 19890331), ('Chanel', 19930618), ('Amanda', 19890125), ('Alexandra', 19891129), ('Monica', 19901123), ('Lauren', 19890811), ('Jacquelyn', 19870304), ('Jacquelynn', 19890111), ('Courtney M', 19880916), ('Courtney', 19820114), ('Kristen', 19820114), ('Cameron', 19881217), ('Caroline', 19900110), ('Susanne', 19750213), ('Sarah', 19920801), ('Niltooli', 19900411), ('Victoria', 19891231), ('Hiromi', 19900510), ('Rachel', 19900209), ('Sena', 19970605), ('Christi', 19960204), ('Tatum', 19970428), ('Madeline', 19940911), ('Julia', 19890628), ('Kelly', 19941021), ('Jasmine Janelle', 19920519), ('Maria', 19950924), ('Monet', 19960106), ('Cordelia Currey', 19930607), ('Millie', 19911004), ('Madison', 19941227), ('Zaina', 19970519), ('Katelyn', 19870608), ('Amanda', 19961028), ('Anna Kate', 19941011), ('Tamijean', 19980616), ('Victoria', 19961202), ('Christiana', 19951116), ('Angie', 19750716), ('Kerry', 19680528), ('Anna', 19960128), ('Sabrina', 19920113), ('Brienne', 19971125), ('Sarah', 19960513), ('Stephanie J', 19960305), ('Alexus', 19970206), ('Alexandra', 19990630), ('Chloe', 19900921), ('Megan', 19960122), ('Erin', 19941226), ('Sydney', 19950909), ('Katherine', ''), ('Lauren', 19990905), ('Teresa', 19941010), ('Alix', 19950718), ('Alaina', 19980809), ('Cassie', 19950201), ('Morgan', 19940208), ('Kenna', 19930918), ('Kelli', 19931202), ('Lauren', 19940618), ('Katrina', 19920314), ('Taylor', 19921208), ('Sara Catherine', 19970130), ('Tamara', 19850418), ('Mckenna Alexandra', 19970303), ('Caroline', 19990809), ('Hada', 19980710), ('Lauren', 19970108), ('Jacara', 19980704), ('Ndindi Inziani', 19971224), ('Susanne', 19980505), ('Bianca', 19960804), ('Caitlin', 19960406), ('Iesha', 19911109), ('Chelsie Marie', 19920321), ('Aurora', 19921204), ('Alexandra', 19950811), ('Karolina', 19990305), ('Skylar', 19950616), ('Jillian', 20010513), ('Gabrielle', 19960114), ('Gabriella', 19971216), ('Allison', 19980324), ('Madeline', 19970403), ('Darya', 19981019), ('Seriana', 19980227), ('Erin', 19960312), ('Katherine', 20001206), ('Vivian', 20000111), ('Stephanie M', 19931110), ('Sabrina', 19971216), ('Kate', 19971013), ('Emma', 20000212), ('Lauren', 20010728), ('Kayla', 19930220), ('Khume', 19961023), ('Christiana', 19970614), ('Candace Olivia', 19800101), ('Alycia', 20001231), ('Mikayla', 19990722), ('Tiffany', 19971009), ('Sanyukta', 20010928), ('Karly', 19850115), ('Emma', 19940624), ('Arielle', 20000910), ('Marjorie', 19980202), ('Anastasiya', 19990324), ('Natasha', ''), ('Addison', ''), ('Mbalia', 19980107), ('Safiya', ''), ('Taylor', 20010406), ('Natasha', 19920609), ('Katherine', 20010213), ('Madison', 19961215), ('Omolola', 19840818), ('Reagan', 19980505), ('Katelyn', 19960909), ('Sophie', 20021031), ('Gabrielle', 19920202), ('Taylor', 19981203), ('Andrea', 19940728), ('Annie', 19870905), ('Olivia', 19990308), ('Imani', 20011220), ('Lauren', 20020523), ('Taylor', 20000807), ('Nicole', 20000304), ('Jane', 19881118), ('Chelsea', 20000819), ('Peyton', 19990915), ('Ellie', 20000523), ('Jane', 19931227), ('Anna', 20010815), ('Rosalyn', 19930622), ('Madison', 19990419), ('Sophia', 20010718), ('Jasmine', 19990813), ('Theresa', 19701102), ('Spirit', 19941027), ('Najah', 20010909), ('Sharmada', 19990810), ('Nicole', 20000812), ('Nina', 20020117), ('Alexa', 20020906), ('Naomi', 20020516), ('Sabina', 20010406), ('Katie', 20011231), ('Nikki', 20011019), ('Mccartney', 19990708), ('Tricia', 19920706), ('Peyton', 20011008), ('Anika', 20010807), ('Dalayna', 20001216), ('Kolie', 20000317), ('Cassie', 19960225), ('Anna', 20020102), ('Monica', 19950419), ('Taysia', 20000708), ('Kathleen', 19940728), ('Amanda', 19990718), ('Jimena', 20000707), ('Cassidy', 19950510), ('Brittany', 19950405)]",,1.0,
How many matches were played in 2013 or 2016?,"[matches.year,2013,2016]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT COUNT(*) AS match_count FROM matches WHERE matches.year IN (2013, 2016);",SELECT count(*) FROM matches WHERE YEAR  =  2013 OR YEAR  =  2016,wta_1,"1. Sequential Structure: Start with the SELECT clause to count the total number of matches played. 2. Condition Structure: Use a WHERE clause to filter matches played in the years 2013 or 2016. 3. Join Structure: No JOIN is required since all necessary information is in the ""matches"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of matches that meet the specified year condition.","[(170,)]","[(170,)]",,1.0,
What is the name of the visitor who visited both a museum opened before 2009 and a museum opened after 2011?,"[visitor.Name,visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID,museum.Open_Year,2009,2011]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",NESTED,SELECT DISTINCT visitor.Name FROM visitor JOIN visit ON visit.visitor_ID = visitor.ID JOIN museum ON visit.Museum_ID = museum.Museum_ID WHERE visitor.ID IN ( SELECT visitor_ID FROM visit JOIN museum ON visit.Museum_ID = museum.Museum_ID WHERE museum.Open_Year < 2009 ) AND visitor.ID IN ( SELECT visitor_ID FROM visit JOIN museum ON visit.Museum_ID = museum.Museum_ID WHERE museum.Open_Year > 2011 );,SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  <  2009 INTERSECT SELECT t1.name FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id JOIN museum AS t3 ON t3.Museum_ID  =  t2.Museum_ID WHERE t3.open_year  >  2011,museum_visit,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the visitor. Use the FROM clause to specify the visitor, visit, and museum tables. Apply a WHERE clause to filter for visitors who visited museums opened before 2009 and museums opened after 2011. 2. Condition Structure: Use the WHERE clause with two conditions: one to filter for museums opened before 2009 and another for museums opened after 2011. Use a subquery to ensure the visitor visited both types of museums. 3. Join Structure: Use INNER JOINs between the visitor, visit, and museum tables based on the foreign key relationships (visit.visitor_ID = visitor.ID and visit.Museum_ID = museum.Museum_ID) to connect visitor names with museum details. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('Fernando Gago',)]","[('Fernando Gago',)]",,1.0,
Find the number of left handed winners who participated in the WTA Championships.,"[players.hand, players.player_id, matches.winner_id, matches.tourney_name, players.player_id = matches.winner_id, left, WTA Championships]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,SELECT COUNT(*) FROM players JOIN matches ON players.player_id = matches.winner_id WHERE players.hand = 'left' AND matches.tourney_name = 'WTA Championships';,SELECT count(DISTINCT winner_name) FROM matches WHERE tourney_name  =  'WTA Championships' AND winner_hand  =  'L',wta_1,"1. Sequential Structure: Start with the SELECT clause to count the number of left-handed winners. Use COUNT to aggregate the results. 2. Condition Structure: Use a WHERE clause to filter for players with ""hand"" as 'left' and matches where the ""tourney_name"" is 'WTA Championships.' 3. Join Structure: Use an INNER JOIN between the ""players"" and ""matches"" tables on ""players.player_id = matches.winner_id"" to link winners with their player details. 4. Aggregation Structure: Use COUNT to calculate the total number of left-handed winners who participated in the specified tournament.","[(0,)]","[(2,)]",,0.0,
What are the distinct battle names which are between bulgarian commander 'Kaloyan' and latin commander 'Baldwin I'?,"[battle.name, battle.bulgarian_commander, battle.latin_commander]","Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",EASY,SELECT DISTINCT battle.name FROM battle WHERE battle.bulgarian_commander = 'Kaloyan' AND battle.latin_commander = 'Baldwin I';,SELECT name FROM battle WHERE bulgarian_commander  =  'Kaloyan' AND latin_commander  =  'Baldwin I',battle_death,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct battle names. 2. Condition Structure: Use a WHERE clause to filter battles where the ""battle.bulgarian_commander"" is 'Kaloyan' and the ""battle.latin_commander"" is 'Baldwin I'. 3. Join Structure: No JOIN is required since all necessary information is in the ""battle"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving distinct battle names based on specific conditions.","[('Battle of Adrianople',)]","[('Battle of Adrianople',)]",,1.0,
Find the name and rank of the 3 youngest winners across all matches.,"[players.first_name, players.last_name, matches.winner_id, matches.winner_age, rankings.ranking, rankings.player_id = players.player_id, matches.winner_id = players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT players.first_name || ' ' || players.last_name AS name, rankings.ranking FROM matches JOIN players ON matches.winner_id = players.player_id JOIN rankings ON players.player_id = rankings.player_id ORDER BY matches.winner_age ASC LIMIT 3;","SELECT DISTINCT winner_name ,  winner_rank FROM matches ORDER BY winner_age LIMIT 3",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the winner's name (constructed from ""players.first_name"" and ""players.last_name"") and their rank (""rankings.ranking""). Use ORDER BY to sort the winners by their age in ascending order, as we are looking for the youngest winners. Use LIMIT 3 to restrict the results to the top 3 youngest winners. 2. Condition Structure: No specific filtering condition is required beyond sorting by age. 3. Join Structure: Use JOINs to connect the ""matches"" table with the ""players"" table on ""matches.winner_id = players.player_id"" to get the winner's details. Then, join the ""rankings"" table with the ""players"" table on ""rankings.player_id = players.player_id"" to get the winner's rank. 4. Aggregation Structure: No aggregation is needed, as we are only retrieving specific fields for the youngest winners.","[('Madison Keys', 7), ('Madison Keys', 8), ('Madison Keys', 8)]","[('Madison Keys', 17), ('Madison Keys', 24), ('Madison Keys', 16)]",,0.0,
Find the name of the winner who has the highest rank points and participated in the Australian Open tourney.,"[players.first_name, players.last_name, matches.winner_id, matches.winner_rank_points, matches.tourney_name, matches.winner_id = players.player_id, Australian Open]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT players.first_name, players.last_name FROM matches JOIN players ON matches.winner_id = players.player_id WHERE matches.tourney_name = 'Australian Open' ORDER BY matches.winner_rank_points DESC LIMIT 1;",SELECT winner_name FROM matches WHERE tourney_name  =  'Australian Open' ORDER BY winner_rank_points DESC LIMIT 1,wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the winner's first and last name. Use an ORDER BY clause to sort the results by ""matches.winner_rank_points"" in descending order to find the highest rank points. Use LIMIT 1 to get only the top result. 2. Condition Structure: Use a WHERE clause to filter for matches where the ""matches.tourney_name"" is ""Australian Open."" 3. Join Structure: Use a JOIN between the ""matches"" and ""players"" tables on ""matches.winner_id = players.player_id"" to link the winner's details with their player information. 4. Aggregation Structure: No aggregation is needed as we are only interested in the winner with the highest rank points for the specified tournament.","[('Serena', 'Williams')]","[('Serena Williams',)]",,1.0,
List the number of all matches who played in years of 2013 or 2016.,"[matches.year, matches.match_num]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT COUNT(matches.match_num) AS total_matches FROM matches WHERE matches.year IN (2013, 2016);",SELECT count(*) FROM matches WHERE YEAR  =  2013 OR YEAR  =  2016,wta_1,"1. Sequential Structure: Start with the SELECT clause to count the number of matches played in the specified years (2013 or 2016). 2. Condition Structure: Use a WHERE clause to filter matches that occurred in the years 2013 or 2016. 3. Join Structure: No JOIN is required since all necessary information is available in the ""matches"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of matches played in the specified years.","[(170,)]","[(170,)]",,1.0,
Find the name and age of the visitor who bought the most tickets at once.,"[visitor.Name, visitor.Age, visit.Num_of_Ticket, visit.visitor_ID = visitor.ID]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",NON-NESTED,"SELECT visitor.Name, visitor.Age FROM visit JOIN visitor ON visit.visitor_ID = visitor.ID WHERE visit.Num_of_Ticket = (SELECT MAX(visit.Num_of_Ticket) FROM visit);","SELECT t1.name ,  t1.age FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id ORDER BY t2.num_of_ticket DESC LIMIT 1",museum_visit,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""visitor.Name"" and ""visitor.Age."" 2. Condition Structure: Use a WHERE clause to filter for the visitor who bought the most tickets at once. This requires identifying the maximum value of ""visit.Num_of_Ticket."" 3. Join Structure: Use a JOIN between the ""visit"" and ""visitor"" tables based on ""visit.visitor_ID = visitor.ID"" to associate ticket purchases with visitor details. 4. Aggregation Structure: Use a subquery to find the maximum value of ""visit.Num_of_Ticket"" and compare it in the WHERE clause to filter the visitor who matches this condition.","[('Arjen Robben', 27)]","[('Arjen Robben', 27)]",,1.0,
How many players are there?,[players.player_id],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT COUNT(players.player_id) AS total_players FROM players;,SELECT count(*) FROM players,wta_1,"1. Sequential Structure: Start with the SELECT clause to count the number of players. 2. Condition Structure: No specific filtering condition is required as we want the total count of players. 3. Join Structure: No JOIN is necessary since the required information is available in the ""players"" table. 4. Aggregation Structure: Use COUNT on ""players.player_id"" to calculate the total number of players.","[(20662,)]","[(20662,)]",,1.0,
What are the opening year and staff number of the museum named Plaza Museum?,"[museum.Open_Year, museum.Num_of_Staff, museum.Name]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",EASY,"SELECT museum.Open_Year, museum.Num_of_Staff FROM museum WHERE museum.Name = 'Plaza Museum';","SELECT Num_of_Staff ,  Open_Year FROM museum WHERE name  =  'Plaza Museum'",museum_visit,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""museum.Open_Year"" and ""museum.Num_of_Staff"". 2. Condition Structure: Use a WHERE clause to filter for the museum with the name ""Plaza Museum"". 3. Join Structure: No JOIN is required since all necessary information is in the ""museum"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.","[('2000', 62)]","[(62, '2000')]",,1.0,
What are the different ids and names of the battles that lost any 'Brig' type shipes?,"[battle.id, battle.name, ship.lost_in_battle, ship.ship_type, ship.lost_in_battle = battle.id, 'Brig']","Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",NESTED,"SELECT DISTINCT battle.id, battle.name FROM battle JOIN ship ON ship.lost_in_battle = battle.id WHERE ship.ship_type = 'Brig';","SELECT DISTINCT T1.id ,  T1.name FROM battle AS T1 JOIN ship AS T2 ON T1.id  =  T2.lost_in_battle WHERE T2.ship_type  =  'Brig'",battle_death,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ids and names of battles. Use the FROM clause to specify the battle table. Join it with the ship table to connect battles with the ships lost in them. Apply a WHERE clause to filter for ships of type 'Brig'. 2. Condition Structure: Use the WHERE clause to filter for ships with the type 'Brig' that were lost in battles. 3. Join Structure: Use an INNER JOIN between the battle and ship tables based on the relationship ship.lost_in_battle = battle.id to connect battles with the ships lost in them. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[(8, 'Siege of Constantinople'), (7, 'Battle of Philippopolis'), (6, 'Battle of Boruy'), (5, 'Battle of Messinopolis'), (4, 'Battle of Rodosto')]","[(8, 'Siege of Constantinople'), (7, 'Battle of Philippopolis'), (6, 'Battle of Boruy'), (5, 'Battle of Messinopolis'), (4, 'Battle of Rodosto')]",,1.0,
What are the names of players who won in both 2013 and 2016?,"[players.player_id, players.first_name, players.last_name, matches.winner_id, matches.year, matches.winner_id = players.player_id]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NESTED,"SELECT players.first_name, players.last_name FROM players JOIN matches ON players.player_id = matches.winner_id WHERE matches.year IN (2013, 2016) GROUP BY players.player_id, players.first_name, players.last_name HAVING COUNT(DISTINCT matches.year) = 2;",SELECT winner_name FROM matches WHERE YEAR  =  2013 INTERSECT SELECT winner_name FROM matches WHERE YEAR  =  2016,wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the first and last names of players. Use the FROM clause to specify the players table and JOIN it with the matches table to link players with their match records. Apply a WHERE clause to filter for matches won in both 2013 and 2016. 2. Condition Structure: Use the WHERE clause to filter for matches where the year is either 2013 or 2016. Use a GROUP BY clause to group by player_id, and apply a HAVING clause to ensure that only players who won in both years are included. 3. Join Structure: Use an INNER JOIN between the players and matches tables based on the winner_id and player_id to connect players with their winning matches. 4. Aggregation Structure: Use COUNT(DISTINCT year) in the HAVING clause to ensure that the player won in both 2013 and 2016.","[('Serena', 'Williams'), ('Victoria', 'Azarenka'), ('Angelique', 'Kerber'), ('Sara', 'Errani'), ('Petra', 'Kvitova')]","[('Angelique Kerber',), ('Petra Kvitova',), ('Sara Errani',), ('Serena Williams',), ('Victoria Azarenka',)]",,1.0,
Show names of teachers and the number of courses they teach.,"[teacher.Name, course_arrange.Teacher_ID, course_arrange.Course_ID = course.Course_ID, course_arrange.Teacher_ID = teacher.Teacher_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NON-NESTED,"SELECT teacher.Name, COUNT(course_arrange.Course_ID) AS Number_of_Courses FROM teacher JOIN course_arrange ON course_arrange.Teacher_ID = teacher.Teacher_ID GROUP BY teacher.Name;","SELECT T2.Name ,  COUNT(*) FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name",course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the teacher's name and the count of courses they teach. Use COUNT on ""course_arrange.Course_ID"" to count the number of courses for each teacher. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""teacher"" and ""course_arrange"" tables based on ""course_arrange.Teacher_ID = teacher.Teacher_ID"" to associate each teacher with their courses. 4. Aggregation Structure: Use COUNT to aggregate the number of courses taught by each teacher, and GROUP BY ""teacher.Name"" to group the results by teacher.","[('Anne Walker', 2), ('Gustaaf Deloor', 1), ('Kearsley Brown', 1), ('Lucy Wong', 1), ('Vicente Carretero', 1)]","[('Anne Walker', 2), ('Gustaaf Deloor', 1), ('Kearsley Brown', 1), ('Lucy Wong', 1), ('Vicente Carretero', 1)]",,1.0,
Find the codes of countries that have more than 50 players.,"[players.country_code, players.player_id, 50]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT players.country_code FROM players GROUP BY players.country_code HAVING COUNT(players.player_id) > 50;,SELECT country_code FROM players GROUP BY country_code HAVING count(*)  >  50,wta_1,"1. Sequential Structure: Start with the SELECT clause to specify the required field, which is the ""players.country_code"". 2. Aggregation Structure: Use COUNT to calculate the number of players for each country. 3. Grouping Structure: Use GROUP BY on ""players.country_code"" to group the results by country code. 4. Condition Structure: Apply the HAVING clause to filter for countries that have more than 50 players. 5. Join Structure: No JOIN is required since all necessary data is within the ""players"" table.","[('ALG',), ('ARG',), ('AUS',), ('AUT',), ('BEL',), ('BIH',), ('BLR',), ('BOL',), ('BRA',), ('BUL',), ('CAN',), ('CHI',), ('CHN',), ('COL',), ('CRO',), ('CZE',), ('DEN',), ('ECU',), ('EGY',), ('ESP',), ('FIN',), ('FRA',), ('GBR',), ('GEO',), ('GER',), ('GRE',), ('HKG',), ('HUN',), ('INA',), ('IND',), ('IRL',), ('ISR',), ('ITA',), ('JPN',), ('KAZ',), ('KOR',), ('LAT',), ('MAR',), ('MEX',), ('NED',), ('NGR',), ('NOR',), ('NZL',), ('PAR',), ('PER',), ('PHI',), ('POL',), ('POR',), ('ROU',), ('RSA',), ('RUS',), ('SLO',), ('SRB',), ('SUI',), ('SVK',), ('SWE',), ('THA',), ('TPE',), ('TUN',), ('TUR',), ('UKR',), ('URU',), ('USA',), ('UZB',), ('VEN',)]","[('ALG',), ('ARG',), ('AUS',), ('AUT',), ('BEL',), ('BIH',), ('BLR',), ('BOL',), ('BRA',), ('BUL',), ('CAN',), ('CHI',), ('CHN',), ('COL',), ('CRO',), ('CZE',), ('DEN',), ('ECU',), ('EGY',), ('ESP',), ('FIN',), ('FRA',), ('GBR',), ('GEO',), ('GER',), ('GRE',), ('HKG',), ('HUN',), ('INA',), ('IND',), ('IRL',), ('ISR',), ('ITA',), ('JPN',), ('KAZ',), ('KOR',), ('LAT',), ('MAR',), ('MEX',), ('NED',), ('NGR',), ('NOR',), ('NZL',), ('PAR',), ('PER',), ('PHI',), ('POL',), ('POR',), ('ROU',), ('RSA',), ('RUS',), ('SLO',), ('SRB',), ('SUI',), ('SVK',), ('SWE',), ('THA',), ('TPE',), ('TUN',), ('TUR',), ('UKR',), ('URU',), ('USA',), ('UZB',), ('VEN',)]",,1.0,
Show the hometowns shared by at least two teachers.,"[teacher.Hometown, teacher.Teacher_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NESTED,SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*) >= 2;,SELECT Hometown FROM teacher GROUP BY Hometown HAVING COUNT(*)  >=  2,course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the hometowns. Use the FROM clause to specify the teacher table. Apply GROUP BY on the hometown column to group teachers by their hometowns. Use the HAVING clause to filter for hometowns that are shared by at least two teachers. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for groups where the count of teachers is at least 2. 3. Join Structure: Not required, as all data is from the teacher table. 4. Aggregation Structure: Use COUNT(*) to count the number of teachers for each hometown and filter based on this count.",[],[],,1.0,
Find the year that has the most number of matches.,[matches.year],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT matches.year FROM matches GROUP BY matches.year ORDER BY COUNT(*) DESC LIMIT 1;,SELECT YEAR FROM matches GROUP BY YEAR ORDER BY count(*) DESC LIMIT 1,wta_1,"1. Sequential Structure: Begin with the SELECT clause to retrieve the ""year"" from the ""matches"" table, as the question asks for the year with the most matches. 2. Condition Structure: No specific filtering condition is required since we are analyzing all matches. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""matches"" table. 4. Aggregation Structure: Use COUNT to calculate the number of matches for each year. Use ORDER BY in descending order on the count and LIMIT 1 to retrieve the year with the most matches.","[(2016,)]","[(2016,)]",,1.0,
Find the total number of matches.,[matches.match_num],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT COUNT(matches.match_num) AS total_matches FROM matches;,SELECT count(*) FROM matches,wta_1,"1. Sequential Structure: Start with the SELECT clause to count the total number of matches. 2. Condition Structure: No specific filtering condition is required as we want the total count of matches. 3. Join Structure: No JOIN is necessary since all required data is within the ""matches"" table. 4. Aggregation Structure: Use COUNT on ""matches.match_num"" to calculate the total number of matches.","[(278,)]","[(278,)]",,1.0,
How many ships ended up being 'Captured'?,[ship.disposition_of_ship],"Table battle, columns = [*,id,name,date,bulgarian_commander,latin_commander,result]
Table death, columns = [*,caused_by_ship_id,id,note,killed,injured]
Table ship, columns = [*,lost_in_battle,id,name,tonnage,ship_type,location,disposition_of_ship]
","Foreign_keys = [ship.lost_in_battle = battle.id,death.caused_by_ship_id = ship.id]
",EASY,SELECT COUNT(*) FROM ship WHERE ship.disposition_of_ship = 'Captured';,SELECT count(*) FROM ship WHERE disposition_of_ship  =  'Captured',battle_death,"1. Sequential Structure: Start with the SELECT clause to count the number of ships with the disposition ""Captured"". 2. Condition Structure: Use a WHERE clause to filter for ships where ""ship.disposition_of_ship"" is equal to 'Captured'. 3. Join Structure: No JOIN is required since all necessary information is in the ""ship"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of ships that meet the specified condition.","[(4,)]","[(4,)]",,1.0,
How many distinct countries do players come from?,[players.country_code],"Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT COUNT(DISTINCT players.country_code) FROM players;,SELECT count(DISTINCT country_code) FROM players,wta_1,"1. Sequential Structure: Start with the SELECT clause to count the distinct countries from the ""players.country_code"" column. 2. Condition Structure: No specific filtering condition is required as we want to count all distinct countries. 3. Join Structure: No JOIN is necessary since the required information is available within the ""players"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""players.country_code"" to count the unique countries.","[(153,)]","[(153,)]",,1.0,
What are the first names and country codes for players who won both the WTA Championships and the Australian Open?,"[players.first_name, players.country_code, matches.winner_id = players.player_id, matches.tourney_name, matches.winner_name]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NESTED,"SELECT DISTINCT players.first_name, players.country_code FROM players JOIN matches ON players.player_id = matches.winner_id WHERE matches.tourney_name = 'WTA Championships' AND players.player_id IN ( SELECT winner_id FROM matches WHERE tourney_name = 'Australian Open' );","SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'WTA Championships' INTERSECT SELECT T1.country_code ,  T1.first_name FROM players AS T1 JOIN matches AS T2 ON T1.player_id  =  T2.winner_id WHERE T2.tourney_name  =  'Australian Open'",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the first names and country codes of players. Use the FROM clause to specify the players table and JOIN it with the matches table to link players with their match records. Apply a WHERE clause to filter for players who won both the ""WTA Championships"" and the ""Australian Open"". 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the player has won matches in both tournaments. This can be achieved by filtering for players whose winner_id appears in matches for both ""WTA Championships"" and ""Australian Open"". 3. Join Structure: Use an INNER JOIN between the players and matches tables based on the winner_id and player_id to connect player details with their match records. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('Serena', 'USA'), ('Angelique', 'GER')]","[('GER', 'Angelique'), ('USA', 'Serena')]",,1.0,
What are the names of the teachers who teach at least two courses?,"[teacher.Name, course_arrange.Teacher_ID, course_arrange.Course_ID, course_arrange.Teacher_ID = teacher.Teacher_ID]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",NON-NESTED,SELECT DISTINCT teacher.Name FROM course_arrange JOIN teacher ON course_arrange.Teacher_ID = teacher.Teacher_ID GROUP BY course_arrange.Teacher_ID HAVING COUNT(course_arrange.Course_ID) >= 2;,SELECT T2.Name FROM course_arrange AS T1 JOIN teacher AS T2 ON T1.Teacher_ID  =  T2.Teacher_ID GROUP BY T2.Name HAVING COUNT(*)  >=  2,course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of teachers. Use GROUP BY on ""course_arrange.Teacher_ID"" to group the data by each teacher. Apply a HAVING clause to filter teachers who teach at least two courses. 2. Condition Structure: Use the HAVING clause to filter groups where the count of ""course_arrange.Course_ID"" is greater than or equal to 2. 3. Join Structure: Use an INNER JOIN between ""course_arrange"" and ""teacher"" tables on ""course_arrange.Teacher_ID = teacher.Teacher_ID"" to associate each course with its respective teacher. 4. Aggregation Structure: Use COUNT on ""course_arrange.Course_ID"" to count the number of courses taught by each teacher.","[('Anne Walker',)]","[('Anne Walker',)]",,1.0,
What is the zip code for Port Chelsea?,"[Addresses.zip_postcode, Addresses.city, Addresses.city = 'Port Chelsea']","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Addresses.zip_postcode FROM Addresses WHERE Addresses.city = 'Port Chelsea';,SELECT zip_postcode FROM Addresses WHERE city  =  'Port Chelsea',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Addresses.zip_postcode"" for the city ""Port Chelsea"". 2. Condition Structure: Use a WHERE clause to filter for rows where ""Addresses.city"" is equal to 'Port Chelsea'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Addresses"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('148',)]","[('148',)]",,1.0,
Where is the youngest teacher from?,"[teacher.Hometown, teacher.Age]","Table course, columns = [*,Course_ID,Staring_Date,Course]
Table course_arrange, columns = [*,Course_ID,Teacher_ID,Grade]
Table teacher, columns = [*,Teacher_ID,Name,Age,Hometown]
","Foreign_keys = [course_arrange.Teacher_ID = teacher.Teacher_ID,course_arrange.Course_ID = course.Course_ID]
",EASY,SELECT teacher.Hometown FROM teacher ORDER BY teacher.Age ASC LIMIT 1;,SELECT Hometown FROM teacher ORDER BY Age ASC LIMIT 1,course_teach,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""teacher.Hometown"" of the youngest teacher. 2. Condition Structure: Use ORDER BY on ""teacher.Age"" in ascending order to find the youngest teacher. Apply LIMIT 1 to select only the youngest teacher. 3. Join Structure: No JOIN is required since all necessary information is in the ""teacher"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('Farnworth Municipal Borough',)]","[('Farnworth Municipal Borough',)]",,1.0,
What is the total ticket expense of the visitors whose membership level is 1?,"[visitor.Level_of_membership,visit.Total_spent,visit.visitor_ID = visitor.ID]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",NON-NESTED,SELECT SUM(visit.Total_spent) FROM visit JOIN visitor ON visit.visitor_ID = visitor.ID WHERE visitor.Level_of_membership = 1;,SELECT sum(t2.Total_spent) FROM visitor AS t1 JOIN visit AS t2 ON t1.id  =  t2.visitor_id WHERE t1.Level_of_membership  =  1,museum_visit,"1. Sequential Structure: Start with the SELECT clause to calculate the total ticket expense, which is the sum of ""visit.Total_spent."" 2. Condition Structure: Use a WHERE clause to filter for visitors whose ""visitor.Level_of_membership"" is 1. 3. Join Structure: Use an INNER JOIN between the ""visit"" and ""visitor"" tables on ""visit.visitor_ID = visitor.ID"" to associate ticket expenses with visitor membership levels. 4. Aggregation Structure: Use the SUM function to calculate the total ticket expense for the filtered visitors.","[(570.84,)]","[(570.84,)]",,1.0,
How many total tours were there for each ranking date?,"[rankings.ranking_date, rankings.tours]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,"SELECT rankings.ranking_date, SUM(rankings.tours) AS total_tours FROM rankings GROUP BY rankings.ranking_date;","SELECT sum(tours) ,  ranking_date FROM rankings GROUP BY ranking_date",wta_1,"1. Sequential Structure: Begin with the SELECT clause to specify the ranking date and the total number of tours for each ranking date. 2. Aggregation Structure: Use SUM to calculate the total number of tours for each ranking date. 3. Grouping Structure: Use GROUP BY on ""rankings.ranking_date"" to aggregate the results by each ranking date. 4. Join Structure: No JOIN is required since all necessary data is within the ""rankings"" table.","[(19870119, 0), (19870126, 0), (19870202, 0), (19870209, 0), (19870302, 0), (19870330, 0), (19870406, 0), (19870413, 0), (19870420, 0), (19870427, 0), (19870504, 0), (19870511, 0), (19870518, 0), (19870525, 0), (19870601, 0), (19870608, 0), (19870615, 0), (19870622, 0), (19870629, 0), (19870706, 0), (19870713, 0), (19870720, 0), (19870727, 0), (19870803, 0), (19870810, 0), (19870817, 0), (19870824, 0), (19870831, 0), (19870907, 0), (19870914, 0), (19870921, 0), (19870928, 0), (19871005, 0), (19871012, 0), (19871019, 0), (19871026, 0), (19871102, 0), (19871109, 0), (19871116, 0), (19871123, 0), (19871130, 0), (19871207, 0), (19871214, 0), (19871221, 0), (19871228, 0), (19880101, 0), (19880104, 0), (19880111, 0), (19880118, 0), (19880125, 0), (19880201, 0), (19880208, 0), (19880215, 0), (19880222, 0), (19880229, 0), (19880307, 0), (19880314, 0), (19880321, 0), (19880328, 0), (19880404, 0), (19880411, 0), (19880418, 0), (19880425, 0), (19880502, 0), (19880509, 0), (19880516, 0), (19880523, 0), (19880530, 0), (19880606, 0), (19880613, 0), (19880620, 0), (19880627, 0), (19880704, 0), (19880711, 0), (19880718, 0), (19880725, 0), (19880801, 0), (19880808, 0), (19880815, 0), (19880822, 0), (19880829, 0), (19880905, 0), (19880912, 0), (19880919, 0), (19880926, 0), (19881003, 0), (19881010, 0), (19881017, 0), (19881024, 0), (19881031, 0), (19881107, 0), (19881114, 0), (19881121, 29), (19881128, 29), (19881205, 29), (19881212, 29), (19881219, 29), (19881226, 29), (19890101, 28), (19890102, 29), (19890109, 29), (19890116, 29), (19890123, 29), (19890130, 29), (19890206, 29), (19890213, 0), (19890220, 0), (19890227, 0), (19890306, 0), (19890313, 29), (19890320, 29), (19890327, 0), (19890403, 0), (19890410, 29), (19890417, 29), (19890424, 29), (19890501, 29), (19890508, 29), (19890515, 29), (19890522, 29), (19890529, 29), (19890605, 29), (19890612, 29), (19890619, 29), (19890626, 29), (19890703, 29), (19890710, 29), (19890717, 29), (19890724, 29), (19890731, 29), (19890807, 29), (19890814, 29), (19890821, 29), (19890828, 29), (19890904, 29), (19890911, 29), (19890918, 29), (19890925, 29), (19891002, 29), (19891009, 29), (19891016, 29), (19891023, 29), (19891030, 29), (19891106, 29), (19891113, 29), (19891120, 29), (19891127, 29), (19891204, 29), (19891211, 29), (19891218, 29), (19891225, 29), (19900101, 28), (19900108, 29), (19900115, 29), (19900122, 29), (19900129, 29), (19900205, 29), (19900212, 29), (19900219, 29), (19900226, 29), (19900305, 29), (19900312, 29), (19900319, 29), (19900326, 29), (19900402, 29), (19900409, 29), (19900416, 29), (19900423, 29), (19900430, 29), (19900507, 29), (19900514, 29), (19900521, 29), (19900528, 29), (19900604, 29), (19900611, 29), (19900618, 30), (19900625, 30), (19900702, 30), (19900709, 30), (19900716, 30), (19900723, 30), (19900730, 30), (19900806, 30), (19900813, 30), (19900820, 30), (19900827, 30), (19900903, 30), (19900910, 30), (19900917, 30), (19900924, 30), (19901001, 30), (19901008, 30), (19901015, 30), (19901022, 30), (19901029, 30), (19901105, 30), (19901112, 30), (19901119, 30), (19901126, 30), (19901203, 30), (19901210, 30), (19901217, 30), (19901224, 30), (19901231, 30), (19910101, 29), (19910107, 30), (19910114, 30), (19910121, 30), (19910128, 30), (19910204, 30), (19910211, 30), (19910218, 30), (19910225, 30), (19910304, 30), (19910311, 29), (19910318, 29), (19910325, 29), (19910401, 29), (19910408, 29), (19910415, 29), (19910422, 29), (19910429, 29), (19910506, 29), (19910513, 29), (19910520, 29), (19910527, 29), (19910603, 29), (19910610, 29), (19910617, 29), (19910624, 29), (19910701, 29), (19910708, 30), (19910715, 29), (19910722, 29), (19910729, 29), (19910805, 29), (19910812, 29), (19910819, 29), (19910826, 30), (19910902, 30), (19910909, 30), (19910916, 30), (19910923, 30), (19910930, 30), (19911007, 31), (19911014, 31), (19911021, 31), (19911028, 31), (19911104, 44), (19911111, 44), (19911118, 44), (19911125, 44), (19911202, 31), (19911209, 44), (19911216, 45), (19911223, 45), (19911230, 45), (19920101, 44), (19920106, 45), (19920113, 45), (19920120, 45), (19920127, 45), (19920203, 45), (19920210, 29), (19920217, 45), (19920224, 45), (19920302, 45), (19920309, 45), (19920316, 45), (19920323, 45), (19920330, 45), (19920406, 45), (19920413, 45), (19920420, 45), (19920427, 45), (19920504, 45), (19920511, 45), (19920518, 45), (19920525, 45), (19920601, 45), (19920608, 45), (19920615, 45), (19920622, 45), (19920629, 45), (19920706, 45), (19920713, 46), (19920720, 46), (19920727, 45), (19920803, 73), (19920810, 73), (19920817, 73), (19920824, 119), (19920831, 90), (19920907, 90), (19920914, 90), (19920921, 90), (19920928, 90), (19921005, 62), (19921012, 62), (19921019, 62), (19921026, 62), (19921102, 62), (19921109, 62), (19921116, 62), (19921123, 62), (19921130, 62), (19921207, 62), (19921214, 62), (19921221, 62), (19921228, 45), (19930101, 44), (19930104, 45), (19930111, 45), (19930118, 45), (19930125, 45), (19930201, 45), (19930208, 32), (19930215, 45), (19930222, 45), (19930301, 45), (19930308, 45), (19930315, 45), (19930322, 45), (19930329, 45), (19930405, 45), (19930412, 62), (19930419, 62), (19930426, 62), (19930503, 62), (19930510, 62), (19930517, 44), (19930524, 44), (19930531, 44), (19930607, 44), (19930614, 44), (19930621, 44), (19930628, 44), (19930705, 62), (19930712, 62), (19930719, 62), (19930726, 62), (19930802, 43), (19930809, 43), (19930816, 43), (19930823, 43), (19930830, 43), (19930906, 43), (19930913, 43), (19930920, 76), (19930927, 75), (19931004, 58), (19931011, 58), (19931018, 58), (19931025, 58), (19931101, 58), (19931108, 58), (19931115, 75), (19931122, 75), (19931129, 75), (19931206, 75), (19931213, 75), (19931220, 75), (19931227, 75), (19940101, 73), (19940103, 75), (19940110, 75), (19940117, 75), (19940124, 75), (19940131, 62), (19940207, 63), (19940214, 63), (19940221, 63), (19940228, 62), (19940307, 62), (19940314, 62), (19940321, 62), (19940328, 61), (19940404, 62), (19940411, 61), (19940418, 44), (19940425, 57), (19940502, 57), (19940509, 57), (19940516, 57), (19940523, 57), (19940530, 57), (19940606, 65), (19940613, 65), (19940620, 65), (19940627, 65), (19940704, 67), (19940711, 67), (19940718, 60), (19940725, 60), (19940801, 60), (19940808, 60), (19940815, 60), (19940822, 60), (19940829, 60), (19940905, 60), (19940912, 68), (19940919, 68), (19940926, 69), (19941003, 69), (19941010, 69), (19941017, 69), (19941024, 59), (19941031, 59), (19941107, 69), (19941114, 69), (19941121, 69), (19941128, 69), (19941205, 69), (19941212, 69), (19941219, 69), (19941226, 69), (19950101, 69), (19950102, 69), (19950109, 69), (19950116, 69), (19950123, 69), (19950130, 69), (19950206, 69), (19950213, 69), (19950220, 69), (19950227, 69), (19950306, 69), (19950313, 69), (19950320, 69), (19950327, 69), (19950403, 69), (19950410, 69), (19950417, 69), (19950424, 69), (19950501, 69), (19950508, 69), (19950515, 69), (19950522, 69), (19950529, 69), (19950605, 69), (19950612, 96), (19950619, 96), (19950626, 96), (19950703, 96), (19950710, 97), (19950717, 118), (19950724, 118), (19950731, 118), (19950807, 118), (19950814, 118), (19950821, 131), (19950828, 131), (19950904, 131), (19950911, 131), (19950918, 131), (19950925, 131), (19951002, 131), (19951009, 131), (19951016, 131), (19951023, 131), (19951030, 131), (19951106, 131), (19951113, 138), (19951120, 138), (19951127, 138), (19951204, 138), (19951211, 138), (19951218, 138), (19951225, 138), (19960101, 138), (19960108, 125), (19960115, 125), (19960122, 125), (19960129, 125), (19960205, 125), (19960212, 125), (19960219, 125), (19960226, 147), (19960304, 147), (19960311, 147), (19960318, 147), (19960325, 147), (19960401, 147), (19960408, 147), (19960415, 147), (19960422, 147), (19960429, 147), (19960506, 147), (19960513, 147), (19960520, 147), (19960527, 147), (19960603, 147), (19960610, 147), (19960617, 147), (19960624, 147), (19960701, 147), (19960708, 171), (19960715, 171), (19960722, 171), (19960729, 171), (19960805, 171), (19960812, 171), (19960819, 171), (19960826, 171), (19960902, 171), (19960909, 194), (19960916, 172), (19960923, 172), (19960930, 172), (19961007, 172), (19961014, 175), (19961021, 175), (19961028, 191), (19961104, 191), (19961111, 213), (19961118, 213), (19961125, 213), (19961202, 213), (19961209, 213), (19961216, 213), (19961223, 185), (19961230, 185), (19970101, 185), (19970106, 185), (19970113, 185), (19970120, 185), (19970127, 209), (19970203, 209), (19970210, 209), (19970217, 209), (19970224, 223), (19970303, 223), (19970310, 223), (19970317, 223), (19970324, 223), (19970331, 223), (19970407, 223), (19970414, 225), (19970421, 225), (19970428, 225), (19970505, 225), (19970512, 225), (19970519, 225), (19970526, 225), (19970602, 225), (19970609, 225), (19970616, 225), (19970623, 225), (19970630, 225), (19970707, 164), (19970714, 257), (19970721, 257), (19970728, 257), (19970804, 273), (19970811, 273), (19970818, 273), (19970825, 273), (19970901, 273), (19970908, 273), (19970915, 273), (19970922, 273), (19970929, 273), (19971006, 273), (19971013, 299), (19971020, 314), (19971027, 314), (19971103, 337), (19971110, 337), (19971117, 363), (19971124, 363), (19971201, 363), (19971208, 394), (19971215, 394), (19971222, 394), (19971229, 394), (19980101, 394), (19980105, 394), (19980112, 394), (19980119, 394), (19980126, 394), (19980202, 394), (19980209, 394), (19980216, 394), (19980223, 394), (19980302, 394), (19980309, 394), (19980316, 394), (19980323, 394), (19980330, 426), (19980406, 426), (19980413, 459), (19980420, 459), (19980427, 459), (19980504, 459), (19980511, 459), (19980518, 459), (19980525, 459), (19980601, 459), (19980608, 543), (19980615, 569), (19980622, 590), (19980629, 590), (19980706, 633), (19980713, 633), (19980720, 633), (19980727, 634), (19980803, 634), (19980810, 634), (19980817, 631), (19980824, 631), (19980831, 660), (19980907, 660), (19980914, 663), (19980921, 663), (19980928, 683), (19981005, 688), (19981012, 688), (19981019, 696), (19981026, 693), (19981102, 693), (19981109, 692), (19981116, 692), (19981123, 692), (19981130, 709), (19981207, 703), (19981214, 703), (19981221, 703), (19981228, 703), (19990101, 703), (19990104, 722), (19990111, 722), (19990118, 722), (19990125, 722), (19990201, 728), (19990208, 723), (19990215, 723), (19990222, 723), (19990301, 723), (19990308, 723), (19990315, 728), (19990322, 728), (19990329, 728), (19990405, 728), (19990412, 728), (19990419, 728), (19990426, 752), (19990503, 761), (19990510, 761), (19990517, 777), (19990524, 777), (19990531, 777), (19990607, 804), (19990614, 804), (19990621, 804), (19990628, 804), (19990705, 804), (19990712, 829), (19990719, 829), (19990726, 829), (19990802, 829), (19990809, 870), (19990816, 873), (19990823, 853), (19990830, 861), (19990906, 861), (19990913, 879), (19990920, 879), (19990927, 899), (19991004, 927), (19991011, 941), (19991018, 964), (19991025, 941), (19991101, 941), (19991108, 941), (19991115, 941), (19991122, 941), (19991129, 966), (19991206, 966), (19991213, 989), (19991220, 989), (19991227, 989), (20000101, 989), (20000103, 989), (20000110, 989), (20000117, 989), (20000124, 989), (20000131, 1013), (20000207, 1038), (20000214, 1038), (20000221, 1038), (20000228, 1038), (20000306, 1065), (20000313, 1065), (20000320, 1065), (20000327, 1065), (20000403, 1065), (20000410, 1093), (20000417, 1093), (20000424, 1093), (20000501, 1122), (20000508, 1122), (20000515, 1106), (20000522, 1106), (20000529, 1106), (20000605, 1106), (20000612, 1160), (20000619, 1160), (20000626, 1188), (20000703, 1188), (20000710, 1204), (20000717, 1205), (20000724, 1212), (20000731, 1276), (20000807, 1276), (20000814, 1224), (20000821, 1224), (20000828, 1224), (20000904, 1224), (20000911, 1241), (20000918, 1265), (20000925, 1231), (20001002, 1223), (20001009, 1232), (20001016, 1253), (20001023, 1245), (20001030, 1247), (20001106, 1173), (20001113, 964), (20001120, 961), (20001127, 961), (20001204, 961), (20001211, 964), (20001218, 964), (20001225, 964), (20010101, 964), (20010108, 964), (20010115, 964), (20010122, 964), (20010129, 977), (20010205, 977), (20010212, 1004), (20010219, 1027), (20010226, 1027), (20010305, 1027), (20010312, 1027), (20010319, 1101), (20010326, 1101), (20010402, 914), (20010409, 930), (20010416, 952), (20010423, 961), (20010430, 988), (20010507, 1011), (20010514, 1011), (20010521, 1029), (20010528, 1067), (20010604, 1067), (20010611, 1094), (20010618, 1094), (20010625, 1073), (20010702, 1073), (20010709, 1113), (20010716, 1135), (20010723, 1149), (20010730, 1149), (20010806, 1175), (20010813, 1175), (20010820, 1175), (20010827, 1201), (20010903, 1201), (20010910, 1228), (20010917, 1231), (20010924, 1263), (20011001, 1287), (20011008, 1267), (20011015, 1288), (20011022, 1291), (20011029, 1312), (20011105, 1312), (20011112, 1412), (20011119, 1412), (20011126, 1437), (20011203, 1437), (20011210, 1437), (20011217, 1430), (20011224, 1430), (20011231, 1430), (20020101, 1430), (20020107, 1430), (20020114, 1430), (20020121, 1430), (20020128, 1430), (20020204, 1422), (20020211, 1422), (20020218, 1422), (20020225, 1424), (20020304, 1424), (20020311, 1424), (20020318, 1448), (20020325, 1448), (20020401, 1573), (20020408, 1574), (20020415, 1574), (20020422, 1574), (20020429, 1577), (20020506, 1730), (20020513, 1577), (20020520, 1577), (20020527, 1577), (20020603, 1577), (20020610, 1783), (20020617, 1803), (20020624, 1783), (20020701, 1783), (20020708, 1834), (20020715, 1835), (20020722, 1828), (20020729, 1853), (20020805, 1853), (20020812, 1925), (20020819, 1915), (20020826, 2111), (20020902, 2111), (20020909, 2451), (20020916, 2457), (20020923, 2462), (20020930, 2496), (20021007, 2526), (20021014, 2520), (20021021, 2505), (20021028, 2505), (20021104, 2498), (20021111, 2497), (20021118, 2497), (20021125, 2497), (20021202, 2497), (20021209, 2497), (20021216, 2497), (20021223, 2497), (20021230, 2497), (20030101, 2497), (20030106, 2497), (20030113, 2497), (20030120, 2497), (20030127, 2497), (20030203, 2517), (20030210, 2507), (20030217, 2490), (20030224, 2528), (20030303, 2549), (20030310, 2549), (20030317, 2571), (20030324, 2571), (20030331, 2614), (20030407, 2587), (20030414, 2587), (20030421, 2608), (20030428, 2719), (20030505, 2652), (20030512, 2671), (20030519, 2728), (20030526, 1860), (20030602, 2728), (20030609, 2753), (20030616, 2753), (20030623, 2731), (20030630, 2731), (20030707, 2730), (20030714, 2755), (20030721, 2759), (20030728, 2777), (20030804, 2732), (20030811, 2734), (20030818, 2755), (20030825, 2801), (20030901, 2801), (20030908, 2798), (20030915, 2847), (20030922, 2862), (20030929, 2930), (20031006, 2961), (20031013, 2966), (20031020, 3035), (20031027, 3020), (20031103, 3038), (20031110, 3052), (20031117, 3065), (20031124, 3092), (20031201, 3120), (20031208, 3190), (20031215, 3211), (20031222, 3211), (20031229, 3214), (20040101, 3214), (20040105, 3206), (20040112, 3206), (20040119, 3206), (20040126, 3206), (20040202, 3257), (20040209, 3265), (20040216, 3282), (20040223, 3282), (20040301, 3279), (20040308, 3286), (20040315, 3286), (20040322, 3286), (20040329, 3286), (20040405, 3277), (20040412, 3286), (20040419, 1489), (20040426, 3379), (20040503, 2613), (20040510, 1187), (20040517, 2361), (20040524, 2955), (20040531, 2535), (20040607, 3433), (20040614, 3456), (20040621, 3492), (20040628, 3492), (20040705, 3498), (20040712, 3516), (20040719, 3587), (20040726, 3592), (20040802, 3592), (20040809, 3645), (20040816, 3647), (20040823, 3661), (20040830, 3705), (20040906, 3705), (20040913, 3785), (20040920, 3831), (20040927, 3913), (20041004, 3957), (20041011, 3986), (20041018, 3987), (20041025, 3968), (20041101, 4011), (20041108, 4071), (20041115, 4124), (20041122, 4145), (20041129, 4147), (20041206, 4160), (20041213, 4160), (20041220, 4160), (20041227, 4160), (20050101, 4160), (20050103, 4160), (20050110, 4160), (20050117, 4160), (20050124, 4160), (20050131, 4198), (20050207, 4198), (20050214, 4211), (20050221, 4286), (20050228, 4286), (20050307, 4313), (20050314, 4313), (20050321, 4333), (20050328, 4333), (20050404, 4362), (20050411, 4371), (20050418, 4379), (20050425, 4379), (20050502, 4379), (20050509, 4470), (20050516, 4489), (20050523, 4522), (20050530, 4522), (20050606, 4682), (20050613, 4705), (20050620, 4727), (20050627, 4727), (20050704, 4792), (20050711, 4816), (20050718, 4847), (20050725, 4859), (20050801, 4926), (20050808, 4982), (20050815, 5020), (20050822, 5090), (20050829, 5100), (20050905, 5100), (20050912, 5187), (20050919, 5173), (20050926, 5175), (20051003, 5215), (20051010, 5249), (20051017, 5237), (20051024, 5257), (20051031, 5331), (20051107, 5362), (20051114, 5357), (20051121, 5391), (20051128, 5401), (20051205, 5452), (20051212, 5452), (20051219, 5452), (20051226, 5452), (20060101, 5452), (20060102, 5452), (20060109, 5452), (20060116, 5452), (20060123, 5452), (20060130, 5441), (20060206, 5425), (20060213, 5441), (20060220, 5478), (20060227, 5528), (20060306, 5548), (20060313, 5548), (20060320, 5559), (20060327, 5559), (20060403, 5626), (20060410, 5626), (20060417, 5644), (20060424, 5658), (20060501, 5656), (20060508, 5654), (20060515, 5683), (20060522, 5721), (20060529, 5798), (20060605, 5798), (20060612, 5862), (20060619, 5897), (20060626, 5944), (20060703, 5944), (20060710, 5983), (20060717, 6026), (20060724, 6065), (20060731, 6133), (20060807, 6151), (20060814, 6226), (20060821, 6289), (20060828, 6284), (20060904, 6284), (20060911, 6304), (20060918, 6347), (20060925, 6376), (20061002, 6436), (20061009, 6520), (20061016, 6629), (20061023, 6730), (20061030, 6808), (20061106, 6816), (20061113, 6807), (20061120, 6893), (20061127, 6896), (20061204, 6931), (20061211, 6953), (20061218, 6953), (20061225, 6953), (20070101, 6953), (20070108, 6926), (20070115, 6926), (20070122, 6926), (20070129, 6925), (20070205, 6925), (20070212, 6930), (20070219, 6942), (20070226, 6988), (20070305, 7017), (20070312, 7017), (20070319, 7058), (20070326, 7058), (20070402, 7139), (20070409, 7175), (20070416, 7197), (20070423, 7197), (20070430, 7197), (20070507, 7233), (20070514, 7317), (20070521, 7341), (20070528, 7365), (20070604, 7365), (20070611, 7448), (20070618, 7448), (20070625, 7473), (20070702, 7473), (20070709, 7495), (20070716, 7478), (20070723, 7470), (20070730, 7528), (20070806, 7522), (20070813, 7527), (20070820, 7503), (20070827, 7504), (20070903, 7504), (20070910, 7602), (20070917, 7643), (20070924, 7686), (20071001, 7697), (20071008, 7707), (20071015, 7687), (20071022, 7638), (20071029, 7711), (20071105, 7677), (20071112, 7664), (20071119, 7666), (20071126, 7674), (20071203, 7650), (20071210, 7659), (20071217, 7659), (20071224, 7682), (20071231, 7682), (20080101, 7682), (20080107, 7682), (20080114, 7711), (20080121, 7711), (20080128, 7691), (20080204, 7716), (20080211, 7743), (20080218, 7742), (20080225, 7731), (20080303, 7761), (20080310, 7790), (20080317, 7790), (20080324, 7832), (20080331, 7832), (20080407, 7873), (20080414, 7889), (20080421, 7917), (20080428, 7917), (20080505, 7929), (20080512, 8002), (20080519, 8022), (20080526, 8090), (20080602, 8090), (20080609, 8030), (20080616, 7970), (20080623, 7966), (20080630, 7966), (20080707, 8089), (20080714, 8113), (20080721, 8235), (20080728, 8280), (20080804, 8325), (20080811, 8372), (20080818, 8387), (20080825, 8417), (20080901, 8417), (20080908, 8527), (20080915, 8639), (20080922, 8690), (20080929, 8731), (20081006, 8762), (20081013, 8794), (20081020, 8836), (20081027, 8898), (20081103, 8956), (20081110, 8996), (20081117, 9003), (20081124, 9019), (20081201, 9050), (20081208, 9076), (20081215, 9077), (20081222, 9070), (20081229, 9070), (20090101, 9070), (20090105, 9064), (20090112, 9064), (20090119, 9064), (20090126, 9064), (20090202, 9087), (20090209, 9087), (20090216, 9059), (20090223, 9063), (20090302, 9063), (20090309, 9053), (20090316, 9053), (20090323, 9057), (20090330, 9057), (20090406, 9066), (20090413, 9121), (20090420, 9110), (20090427, 9111), (20090504, 9094), (20090511, 9143), (20090518, 9140), (20090525, 9153), (20090601, 9153), (20090608, 9203), (20090615, 9239), (20090622, 9255), (20090629, 9255), (20090706, 9310), (20090713, 9376), (20090720, 9474), (20090727, 9589), (20090803, 9611), (20090810, 9598), (20090817, 9642), (20090824, 9682), (20090831, 9682), (20090907, 9682), (20090914, 9808), (20090921, 9856), (20090928, 9918), (20091005, 9929), (20091012, 9925), (20091019, 10003), (20091026, 10025), (20091102, 10061), (20091109, 10116), (20091116, 10137), (20091123, 10204), (20091130, 10238), (20091207, 10221), (20091214, 10272), (20091221, 10272), (20091228, 10318), (20100101, 10318), (20100104, 10318), (20100111, 10320), (20100118, 10329), (20100125, 10329), (20100201, 10373), (20100208, 10372), (20100215, 10389), (20100222, 10404), (20100301, 10430), (20100308, 10442), (20100315, 10442), (20100322, 10412), (20100329, 10412), (20100405, 10481), (20100412, 10515), (20100419, 10543), (20100426, 10580), (20100503, 10590), (20100510, 10576), (20100517, 10593), (20100524, 10634), (20100531, 10634), (20100607, 10613), (20100614, 10630), (20100621, 10634), (20100628, 10634), (20100705, 10685), (20100712, 10726), (20100719, 10756), (20100726, 10817), (20100802, 10835), (20100809, 10937), (20100816, 10999), (20100823, 11026), (20100830, 11125), (20100906, 11125), (20100913, 11256), (20100920, 11290), (20100927, 11339), (20101004, 11460), (20101011, 11566), (20101018, 11594), (20101025, 11617), (20101101, 11687), (20101108, 11735), (20101115, 11814), (20101122, 11845), (20101129, 11877), (20101206, 11888), (20101213, 11907), (20101220, 11913), (20101227, 11904), (20110101, 11904), (20110103, 12060), (20110110, 12067), (20110117, 12094), (20110124, 12094), (20110131, 12143), (20110207, 12181), (20110214, 12204), (20110221, 12201), (20110228, 12254), (20110307, 12267), (20110314, 12267), (20110321, 12303), (20110328, 12303), (20110404, 12343), (20110411, 12398), (20110418, 12434), (20110425, 12422), (20110502, 12438), (20110509, 12482), (20110516, 12467), (20110523, 12522), (20110530, 12522), (20110606, 12659), (20110613, 12682), (20110620, 12686), (20110627, 12686), (20110704, 12867), (20110711, 12895), (20110718, 12927), (20110725, 13006), (20110801, 12999), (20110808, 13081), (20110815, 13129), (20110822, 13140), (20110829, 13174), (20110905, 13174), (20110912, 13299), (20110919, 13342), (20110926, 13382), (20111003, 13372), (20111010, 13382), (20111017, 13411), (20111024, 13443), (20111031, 13465), (20111107, 13443), (20111114, 13482), (20111121, 13518), (20111128, 13517), (20111205, 13542), (20111212, 13536), (20111219, 13565), (20111226, 13603), (20120101, 13603), (20120102, 13610), (20120109, 13628), (20120116, 13618), (20120123, 13618), (20120130, 13667), (20120206, 13666), (20120213, 13674), (20120220, 13719), (20120227, 13788), (20120305, 13791), (20120312, 13791), (20120319, 13818), (20120326, 13818), (20120402, 13881), (20120409, 13902), (20120416, 13938), (20120423, 13964), (20120430, 13983), (20120507, 14016), (20120514, 14015), (20120521, 14034), (20120528, 14087), (20120604, 14087), (20120611, 14072), (20120618, 14138), (20120625, 14172), (20120702, 14172), (20120709, 14180), (20120716, 14223), (20120723, 14250), (20120730, 14264), (20120806, 14286), (20120813, 14331), (20120820, 14361), (20120827, 14389), (20120903, 14389), (20120910, 14389), (20120917, 14402), (20120924, 14438), (20121001, 14472), (20121008, 14480), (20121015, 14513), (20121022, 14525), (20121029, 14547), (20121105, 14585), (20121112, 14621), (20121119, 14624), (20121126, 14612), (20121203, 14610), (20121210, 14639), (20121217, 14633), (20121224, 14649), (20121231, 13949), (20130101, 14648), (20130107, 13966), (20130114, 14667), (20130121, 14667), (20130128, 14667), (20130204, 14652), (20130211, 14651), (20130218, 14649), (20130225, 14554), (20130304, 14695), (20130311, 14727), (20130318, 13048), (20130401, 6790), (20130408, 14591), (20130415, 14449), (20130422, 14451), (20130429, 14462), (20130506, 14487), (20130513, 14516), (20130520, 14531), (20130527, 14545), (20130603, 14545), (20130610, 14553), (20130617, 14569), (20130624, 14650), (20130708, 14651), (20130715, 14689), (20130722, 14751), (20130729, 14766), (20130805, 14679), (20130812, 14599), (20130819, 14740), (20130826, 14714), (20130902, 14796), (20130909, 14820), (20130916, 14866), (20130923, 14878), (20130930, 14885), (20131007, 15028), (20131014, 15072), (20131021, 15025), (20131028, 15071), (20131104, 15098), (20131111, 15101), (20131118, 15151), (20131125, 15337), (20131202, 15334), (20131209, 15512), (20131216, 15540), (20131223, 15701), (20131230, 15708), (20140106, 15703), (20140113, 15637), (20140120, 8585), (20140127, 15646), (20140203, 15632), (20140210, 15637), (20140217, 8565), (20140224, 15659), (20150302, 15557), (20150406, 15578), (20150413, 15545), (20150420, 15568), (20150427, 15475), (20150511, 15710), (20150518, 15623), (20150525, 15741), (20150608, 15741), (20150622, 15810), (20150803, 15761), (20150810, 15776), (20150824, 15908), (20150831, 16184), (20150914, 15832), (20150921, 15800), (20151005, 16178), (20151012, 16191), (20151019, 16138), (20151102, 16293), (20160111, 4812), (20160118, 16518), (20160201, 16629), (20160208, 16586), (20160215, 16529), (20160222, 16454), (20160229, 16515), (20160307, 16517), (20160411, 16446), (20160418, 16454), (20160425, 16489), (20160502, 16388), (20160509, 16374), (20160523, 16351), (20160606, 16361), (20160620, 16314), (20160627, 16293), (20160815, 16325), (20160919, 16316), (20160926, 16305), (20161010, 16233), (20161031, 16349), (20161107, 16364), (20161114, 16249), (20161121, 16345), (20161128, 16294), (20161205, 16336), (20161212, 16387), (20170102, 16372), (20170109, 16406), (20170116, 16379), (20170213, 16305), (20170220, 16207), (20170306, 16111), (20170320, 16230), (20170417, 16270), (20170424, 16226), (20170501, 16303), (20170508, 16124), (20170515, 16204), (20170522, 16290), (20170529, 16649), (20170612, 16157), (20170619, 16189), (20170626, 16184), (20170703, 16597), (20170717, 15983), (20170724, 16138), (20170731, 16145), (20170807, 16147), (20170814, 16268), (20170821, 16279), (20170828, 16301), (20170911, 16161)]","[(0, 19870119), (0, 19870126), (0, 19870202), (0, 19870209), (0, 19870302), (0, 19870330), (0, 19870406), (0, 19870413), (0, 19870420), (0, 19870427), (0, 19870504), (0, 19870511), (0, 19870518), (0, 19870525), (0, 19870601), (0, 19870608), (0, 19870615), (0, 19870622), (0, 19870629), (0, 19870706), (0, 19870713), (0, 19870720), (0, 19870727), (0, 19870803), (0, 19870810), (0, 19870817), (0, 19870824), (0, 19870831), (0, 19870907), (0, 19870914), (0, 19870921), (0, 19870928), (0, 19871005), (0, 19871012), (0, 19871019), (0, 19871026), (0, 19871102), (0, 19871109), (0, 19871116), (0, 19871123), (0, 19871130), (0, 19871207), (0, 19871214), (0, 19871221), (0, 19871228), (0, 19880101), (0, 19880104), (0, 19880111), (0, 19880118), (0, 19880125), (0, 19880201), (0, 19880208), (0, 19880215), (0, 19880222), (0, 19880229), (0, 19880307), (0, 19880314), (0, 19880321), (0, 19880328), (0, 19880404), (0, 19880411), (0, 19880418), (0, 19880425), (0, 19880502), (0, 19880509), (0, 19880516), (0, 19880523), (0, 19880530), (0, 19880606), (0, 19880613), (0, 19880620), (0, 19880627), (0, 19880704), (0, 19880711), (0, 19880718), (0, 19880725), (0, 19880801), (0, 19880808), (0, 19880815), (0, 19880822), (0, 19880829), (0, 19880905), (0, 19880912), (0, 19880919), (0, 19880926), (0, 19881003), (0, 19881010), (0, 19881017), (0, 19881024), (0, 19881031), (0, 19881107), (0, 19881114), (29, 19881121), (29, 19881128), (29, 19881205), (29, 19881212), (29, 19881219), (29, 19881226), (28, 19890101), (29, 19890102), (29, 19890109), (29, 19890116), (29, 19890123), (29, 19890130), (29, 19890206), (0, 19890213), (0, 19890220), (0, 19890227), (0, 19890306), (29, 19890313), (29, 19890320), (0, 19890327), (0, 19890403), (29, 19890410), (29, 19890417), (29, 19890424), (29, 19890501), (29, 19890508), (29, 19890515), (29, 19890522), (29, 19890529), (29, 19890605), (29, 19890612), (29, 19890619), (29, 19890626), (29, 19890703), (29, 19890710), (29, 19890717), (29, 19890724), (29, 19890731), (29, 19890807), (29, 19890814), (29, 19890821), (29, 19890828), (29, 19890904), (29, 19890911), (29, 19890918), (29, 19890925), (29, 19891002), (29, 19891009), (29, 19891016), (29, 19891023), (29, 19891030), (29, 19891106), (29, 19891113), (29, 19891120), (29, 19891127), (29, 19891204), (29, 19891211), (29, 19891218), (29, 19891225), (28, 19900101), (29, 19900108), (29, 19900115), (29, 19900122), (29, 19900129), (29, 19900205), (29, 19900212), (29, 19900219), (29, 19900226), (29, 19900305), (29, 19900312), (29, 19900319), (29, 19900326), (29, 19900402), (29, 19900409), (29, 19900416), (29, 19900423), (29, 19900430), (29, 19900507), (29, 19900514), (29, 19900521), (29, 19900528), (29, 19900604), (29, 19900611), (30, 19900618), (30, 19900625), (30, 19900702), (30, 19900709), (30, 19900716), (30, 19900723), (30, 19900730), (30, 19900806), (30, 19900813), (30, 19900820), (30, 19900827), (30, 19900903), (30, 19900910), (30, 19900917), (30, 19900924), (30, 19901001), (30, 19901008), (30, 19901015), (30, 19901022), (30, 19901029), (30, 19901105), (30, 19901112), (30, 19901119), (30, 19901126), (30, 19901203), (30, 19901210), (30, 19901217), (30, 19901224), (30, 19901231), (29, 19910101), (30, 19910107), (30, 19910114), (30, 19910121), (30, 19910128), (30, 19910204), (30, 19910211), (30, 19910218), (30, 19910225), (30, 19910304), (29, 19910311), (29, 19910318), (29, 19910325), (29, 19910401), (29, 19910408), (29, 19910415), (29, 19910422), (29, 19910429), (29, 19910506), (29, 19910513), (29, 19910520), (29, 19910527), (29, 19910603), (29, 19910610), (29, 19910617), (29, 19910624), (29, 19910701), (30, 19910708), (29, 19910715), (29, 19910722), (29, 19910729), (29, 19910805), (29, 19910812), (29, 19910819), (30, 19910826), (30, 19910902), (30, 19910909), (30, 19910916), (30, 19910923), (30, 19910930), (31, 19911007), (31, 19911014), (31, 19911021), (31, 19911028), (44, 19911104), (44, 19911111), (44, 19911118), (44, 19911125), (31, 19911202), (44, 19911209), (45, 19911216), (45, 19911223), (45, 19911230), (44, 19920101), (45, 19920106), (45, 19920113), (45, 19920120), (45, 19920127), (45, 19920203), (29, 19920210), (45, 19920217), (45, 19920224), (45, 19920302), (45, 19920309), (45, 19920316), (45, 19920323), (45, 19920330), (45, 19920406), (45, 19920413), (45, 19920420), (45, 19920427), (45, 19920504), (45, 19920511), (45, 19920518), (45, 19920525), (45, 19920601), (45, 19920608), (45, 19920615), (45, 19920622), (45, 19920629), (45, 19920706), (46, 19920713), (46, 19920720), (45, 19920727), (73, 19920803), (73, 19920810), (73, 19920817), (119, 19920824), (90, 19920831), (90, 19920907), (90, 19920914), (90, 19920921), (90, 19920928), (62, 19921005), (62, 19921012), (62, 19921019), (62, 19921026), (62, 19921102), (62, 19921109), (62, 19921116), (62, 19921123), (62, 19921130), (62, 19921207), (62, 19921214), (62, 19921221), (45, 19921228), (44, 19930101), (45, 19930104), (45, 19930111), (45, 19930118), (45, 19930125), (45, 19930201), (32, 19930208), (45, 19930215), (45, 19930222), (45, 19930301), (45, 19930308), (45, 19930315), (45, 19930322), (45, 19930329), (45, 19930405), (62, 19930412), (62, 19930419), (62, 19930426), (62, 19930503), (62, 19930510), (44, 19930517), (44, 19930524), (44, 19930531), (44, 19930607), (44, 19930614), (44, 19930621), (44, 19930628), (62, 19930705), (62, 19930712), (62, 19930719), (62, 19930726), (43, 19930802), (43, 19930809), (43, 19930816), (43, 19930823), (43, 19930830), (43, 19930906), (43, 19930913), (76, 19930920), (75, 19930927), (58, 19931004), (58, 19931011), (58, 19931018), (58, 19931025), (58, 19931101), (58, 19931108), (75, 19931115), (75, 19931122), (75, 19931129), (75, 19931206), (75, 19931213), (75, 19931220), (75, 19931227), (73, 19940101), (75, 19940103), (75, 19940110), (75, 19940117), (75, 19940124), (62, 19940131), (63, 19940207), (63, 19940214), (63, 19940221), (62, 19940228), (62, 19940307), (62, 19940314), (62, 19940321), (61, 19940328), (62, 19940404), (61, 19940411), (44, 19940418), (57, 19940425), (57, 19940502), (57, 19940509), (57, 19940516), (57, 19940523), (57, 19940530), (65, 19940606), (65, 19940613), (65, 19940620), (65, 19940627), (67, 19940704), (67, 19940711), (60, 19940718), (60, 19940725), (60, 19940801), (60, 19940808), (60, 19940815), (60, 19940822), (60, 19940829), (60, 19940905), (68, 19940912), (68, 19940919), (69, 19940926), (69, 19941003), (69, 19941010), (69, 19941017), (59, 19941024), (59, 19941031), (69, 19941107), (69, 19941114), (69, 19941121), (69, 19941128), (69, 19941205), (69, 19941212), (69, 19941219), (69, 19941226), (69, 19950101), (69, 19950102), (69, 19950109), (69, 19950116), (69, 19950123), (69, 19950130), (69, 19950206), (69, 19950213), (69, 19950220), (69, 19950227), (69, 19950306), (69, 19950313), (69, 19950320), (69, 19950327), (69, 19950403), (69, 19950410), (69, 19950417), (69, 19950424), (69, 19950501), (69, 19950508), (69, 19950515), (69, 19950522), (69, 19950529), (69, 19950605), (96, 19950612), (96, 19950619), (96, 19950626), (96, 19950703), (97, 19950710), (118, 19950717), (118, 19950724), (118, 19950731), (118, 19950807), (118, 19950814), (131, 19950821), (131, 19950828), (131, 19950904), (131, 19950911), (131, 19950918), (131, 19950925), (131, 19951002), (131, 19951009), (131, 19951016), (131, 19951023), (131, 19951030), (131, 19951106), (138, 19951113), (138, 19951120), (138, 19951127), (138, 19951204), (138, 19951211), (138, 19951218), (138, 19951225), (138, 19960101), (125, 19960108), (125, 19960115), (125, 19960122), (125, 19960129), (125, 19960205), (125, 19960212), (125, 19960219), (147, 19960226), (147, 19960304), (147, 19960311), (147, 19960318), (147, 19960325), (147, 19960401), (147, 19960408), (147, 19960415), (147, 19960422), (147, 19960429), (147, 19960506), (147, 19960513), (147, 19960520), (147, 19960527), (147, 19960603), (147, 19960610), (147, 19960617), (147, 19960624), (147, 19960701), (171, 19960708), (171, 19960715), (171, 19960722), (171, 19960729), (171, 19960805), (171, 19960812), (171, 19960819), (171, 19960826), (171, 19960902), (194, 19960909), (172, 19960916), (172, 19960923), (172, 19960930), (172, 19961007), (175, 19961014), (175, 19961021), (191, 19961028), (191, 19961104), (213, 19961111), (213, 19961118), (213, 19961125), (213, 19961202), (213, 19961209), (213, 19961216), (185, 19961223), (185, 19961230), (185, 19970101), (185, 19970106), (185, 19970113), (185, 19970120), (209, 19970127), (209, 19970203), (209, 19970210), (209, 19970217), (223, 19970224), (223, 19970303), (223, 19970310), (223, 19970317), (223, 19970324), (223, 19970331), (223, 19970407), (225, 19970414), (225, 19970421), (225, 19970428), (225, 19970505), (225, 19970512), (225, 19970519), (225, 19970526), (225, 19970602), (225, 19970609), (225, 19970616), (225, 19970623), (225, 19970630), (164, 19970707), (257, 19970714), (257, 19970721), (257, 19970728), (273, 19970804), (273, 19970811), (273, 19970818), (273, 19970825), (273, 19970901), (273, 19970908), (273, 19970915), (273, 19970922), (273, 19970929), (273, 19971006), (299, 19971013), (314, 19971020), (314, 19971027), (337, 19971103), (337, 19971110), (363, 19971117), (363, 19971124), (363, 19971201), (394, 19971208), (394, 19971215), (394, 19971222), (394, 19971229), (394, 19980101), (394, 19980105), (394, 19980112), (394, 19980119), (394, 19980126), (394, 19980202), (394, 19980209), (394, 19980216), (394, 19980223), (394, 19980302), (394, 19980309), (394, 19980316), (394, 19980323), (426, 19980330), (426, 19980406), (459, 19980413), (459, 19980420), (459, 19980427), (459, 19980504), (459, 19980511), (459, 19980518), (459, 19980525), (459, 19980601), (543, 19980608), (569, 19980615), (590, 19980622), (590, 19980629), (633, 19980706), (633, 19980713), (633, 19980720), (634, 19980727), (634, 19980803), (634, 19980810), (631, 19980817), (631, 19980824), (660, 19980831), (660, 19980907), (663, 19980914), (663, 19980921), (683, 19980928), (688, 19981005), (688, 19981012), (696, 19981019), (693, 19981026), (693, 19981102), (692, 19981109), (692, 19981116), (692, 19981123), (709, 19981130), (703, 19981207), (703, 19981214), (703, 19981221), (703, 19981228), (703, 19990101), (722, 19990104), (722, 19990111), (722, 19990118), (722, 19990125), (728, 19990201), (723, 19990208), (723, 19990215), (723, 19990222), (723, 19990301), (723, 19990308), (728, 19990315), (728, 19990322), (728, 19990329), (728, 19990405), (728, 19990412), (728, 19990419), (752, 19990426), (761, 19990503), (761, 19990510), (777, 19990517), (777, 19990524), (777, 19990531), (804, 19990607), (804, 19990614), (804, 19990621), (804, 19990628), (804, 19990705), (829, 19990712), (829, 19990719), (829, 19990726), (829, 19990802), (870, 19990809), (873, 19990816), (853, 19990823), (861, 19990830), (861, 19990906), (879, 19990913), (879, 19990920), (899, 19990927), (927, 19991004), (941, 19991011), (964, 19991018), (941, 19991025), (941, 19991101), (941, 19991108), (941, 19991115), (941, 19991122), (966, 19991129), (966, 19991206), (989, 19991213), (989, 19991220), (989, 19991227), (989, 20000101), (989, 20000103), (989, 20000110), (989, 20000117), (989, 20000124), (1013, 20000131), (1038, 20000207), (1038, 20000214), (1038, 20000221), (1038, 20000228), (1065, 20000306), (1065, 20000313), (1065, 20000320), (1065, 20000327), (1065, 20000403), (1093, 20000410), (1093, 20000417), (1093, 20000424), (1122, 20000501), (1122, 20000508), (1106, 20000515), (1106, 20000522), (1106, 20000529), (1106, 20000605), (1160, 20000612), (1160, 20000619), (1188, 20000626), (1188, 20000703), (1204, 20000710), (1205, 20000717), (1212, 20000724), (1276, 20000731), (1276, 20000807), (1224, 20000814), (1224, 20000821), (1224, 20000828), (1224, 20000904), (1241, 20000911), (1265, 20000918), (1231, 20000925), (1223, 20001002), (1232, 20001009), (1253, 20001016), (1245, 20001023), (1247, 20001030), (1173, 20001106), (964, 20001113), (961, 20001120), (961, 20001127), (961, 20001204), (964, 20001211), (964, 20001218), (964, 20001225), (964, 20010101), (964, 20010108), (964, 20010115), (964, 20010122), (977, 20010129), (977, 20010205), (1004, 20010212), (1027, 20010219), (1027, 20010226), (1027, 20010305), (1027, 20010312), (1101, 20010319), (1101, 20010326), (914, 20010402), (930, 20010409), (952, 20010416), (961, 20010423), (988, 20010430), (1011, 20010507), (1011, 20010514), (1029, 20010521), (1067, 20010528), (1067, 20010604), (1094, 20010611), (1094, 20010618), (1073, 20010625), (1073, 20010702), (1113, 20010709), (1135, 20010716), (1149, 20010723), (1149, 20010730), (1175, 20010806), (1175, 20010813), (1175, 20010820), (1201, 20010827), (1201, 20010903), (1228, 20010910), (1231, 20010917), (1263, 20010924), (1287, 20011001), (1267, 20011008), (1288, 20011015), (1291, 20011022), (1312, 20011029), (1312, 20011105), (1412, 20011112), (1412, 20011119), (1437, 20011126), (1437, 20011203), (1437, 20011210), (1430, 20011217), (1430, 20011224), (1430, 20011231), (1430, 20020101), (1430, 20020107), (1430, 20020114), (1430, 20020121), (1430, 20020128), (1422, 20020204), (1422, 20020211), (1422, 20020218), (1424, 20020225), (1424, 20020304), (1424, 20020311), (1448, 20020318), (1448, 20020325), (1573, 20020401), (1574, 20020408), (1574, 20020415), (1574, 20020422), (1577, 20020429), (1730, 20020506), (1577, 20020513), (1577, 20020520), (1577, 20020527), (1577, 20020603), (1783, 20020610), (1803, 20020617), (1783, 20020624), (1783, 20020701), (1834, 20020708), (1835, 20020715), (1828, 20020722), (1853, 20020729), (1853, 20020805), (1925, 20020812), (1915, 20020819), (2111, 20020826), (2111, 20020902), (2451, 20020909), (2457, 20020916), (2462, 20020923), (2496, 20020930), (2526, 20021007), (2520, 20021014), (2505, 20021021), (2505, 20021028), (2498, 20021104), (2497, 20021111), (2497, 20021118), (2497, 20021125), (2497, 20021202), (2497, 20021209), (2497, 20021216), (2497, 20021223), (2497, 20021230), (2497, 20030101), (2497, 20030106), (2497, 20030113), (2497, 20030120), (2497, 20030127), (2517, 20030203), (2507, 20030210), (2490, 20030217), (2528, 20030224), (2549, 20030303), (2549, 20030310), (2571, 20030317), (2571, 20030324), (2614, 20030331), (2587, 20030407), (2587, 20030414), (2608, 20030421), (2719, 20030428), (2652, 20030505), (2671, 20030512), (2728, 20030519), (1860, 20030526), (2728, 20030602), (2753, 20030609), (2753, 20030616), (2731, 20030623), (2731, 20030630), (2730, 20030707), (2755, 20030714), (2759, 20030721), (2777, 20030728), (2732, 20030804), (2734, 20030811), (2755, 20030818), (2801, 20030825), (2801, 20030901), (2798, 20030908), (2847, 20030915), (2862, 20030922), (2930, 20030929), (2961, 20031006), (2966, 20031013), (3035, 20031020), (3020, 20031027), (3038, 20031103), (3052, 20031110), (3065, 20031117), (3092, 20031124), (3120, 20031201), (3190, 20031208), (3211, 20031215), (3211, 20031222), (3214, 20031229), (3214, 20040101), (3206, 20040105), (3206, 20040112), (3206, 20040119), (3206, 20040126), (3257, 20040202), (3265, 20040209), (3282, 20040216), (3282, 20040223), (3279, 20040301), (3286, 20040308), (3286, 20040315), (3286, 20040322), (3286, 20040329), (3277, 20040405), (3286, 20040412), (1489, 20040419), (3379, 20040426), (2613, 20040503), (1187, 20040510), (2361, 20040517), (2955, 20040524), (2535, 20040531), (3433, 20040607), (3456, 20040614), (3492, 20040621), (3492, 20040628), (3498, 20040705), (3516, 20040712), (3587, 20040719), (3592, 20040726), (3592, 20040802), (3645, 20040809), (3647, 20040816), (3661, 20040823), (3705, 20040830), (3705, 20040906), (3785, 20040913), (3831, 20040920), (3913, 20040927), (3957, 20041004), (3986, 20041011), (3987, 20041018), (3968, 20041025), (4011, 20041101), (4071, 20041108), (4124, 20041115), (4145, 20041122), (4147, 20041129), (4160, 20041206), (4160, 20041213), (4160, 20041220), (4160, 20041227), (4160, 20050101), (4160, 20050103), (4160, 20050110), (4160, 20050117), (4160, 20050124), (4198, 20050131), (4198, 20050207), (4211, 20050214), (4286, 20050221), (4286, 20050228), (4313, 20050307), (4313, 20050314), (4333, 20050321), (4333, 20050328), (4362, 20050404), (4371, 20050411), (4379, 20050418), (4379, 20050425), (4379, 20050502), (4470, 20050509), (4489, 20050516), (4522, 20050523), (4522, 20050530), (4682, 20050606), (4705, 20050613), (4727, 20050620), (4727, 20050627), (4792, 20050704), (4816, 20050711), (4847, 20050718), (4859, 20050725), (4926, 20050801), (4982, 20050808), (5020, 20050815), (5090, 20050822), (5100, 20050829), (5100, 20050905), (5187, 20050912), (5173, 20050919), (5175, 20050926), (5215, 20051003), (5249, 20051010), (5237, 20051017), (5257, 20051024), (5331, 20051031), (5362, 20051107), (5357, 20051114), (5391, 20051121), (5401, 20051128), (5452, 20051205), (5452, 20051212), (5452, 20051219), (5452, 20051226), (5452, 20060101), (5452, 20060102), (5452, 20060109), (5452, 20060116), (5452, 20060123), (5441, 20060130), (5425, 20060206), (5441, 20060213), (5478, 20060220), (5528, 20060227), (5548, 20060306), (5548, 20060313), (5559, 20060320), (5559, 20060327), (5626, 20060403), (5626, 20060410), (5644, 20060417), (5658, 20060424), (5656, 20060501), (5654, 20060508), (5683, 20060515), (5721, 20060522), (5798, 20060529), (5798, 20060605), (5862, 20060612), (5897, 20060619), (5944, 20060626), (5944, 20060703), (5983, 20060710), (6026, 20060717), (6065, 20060724), (6133, 20060731), (6151, 20060807), (6226, 20060814), (6289, 20060821), (6284, 20060828), (6284, 20060904), (6304, 20060911), (6347, 20060918), (6376, 20060925), (6436, 20061002), (6520, 20061009), (6629, 20061016), (6730, 20061023), (6808, 20061030), (6816, 20061106), (6807, 20061113), (6893, 20061120), (6896, 20061127), (6931, 20061204), (6953, 20061211), (6953, 20061218), (6953, 20061225), (6953, 20070101), (6926, 20070108), (6926, 20070115), (6926, 20070122), (6925, 20070129), (6925, 20070205), (6930, 20070212), (6942, 20070219), (6988, 20070226), (7017, 20070305), (7017, 20070312), (7058, 20070319), (7058, 20070326), (7139, 20070402), (7175, 20070409), (7197, 20070416), (7197, 20070423), (7197, 20070430), (7233, 20070507), (7317, 20070514), (7341, 20070521), (7365, 20070528), (7365, 20070604), (7448, 20070611), (7448, 20070618), (7473, 20070625), (7473, 20070702), (7495, 20070709), (7478, 20070716), (7470, 20070723), (7528, 20070730), (7522, 20070806), (7527, 20070813), (7503, 20070820), (7504, 20070827), (7504, 20070903), (7602, 20070910), (7643, 20070917), (7686, 20070924), (7697, 20071001), (7707, 20071008), (7687, 20071015), (7638, 20071022), (7711, 20071029), (7677, 20071105), (7664, 20071112), (7666, 20071119), (7674, 20071126), (7650, 20071203), (7659, 20071210), (7659, 20071217), (7682, 20071224), (7682, 20071231), (7682, 20080101), (7682, 20080107), (7711, 20080114), (7711, 20080121), (7691, 20080128), (7716, 20080204), (7743, 20080211), (7742, 20080218), (7731, 20080225), (7761, 20080303), (7790, 20080310), (7790, 20080317), (7832, 20080324), (7832, 20080331), (7873, 20080407), (7889, 20080414), (7917, 20080421), (7917, 20080428), (7929, 20080505), (8002, 20080512), (8022, 20080519), (8090, 20080526), (8090, 20080602), (8030, 20080609), (7970, 20080616), (7966, 20080623), (7966, 20080630), (8089, 20080707), (8113, 20080714), (8235, 20080721), (8280, 20080728), (8325, 20080804), (8372, 20080811), (8387, 20080818), (8417, 20080825), (8417, 20080901), (8527, 20080908), (8639, 20080915), (8690, 20080922), (8731, 20080929), (8762, 20081006), (8794, 20081013), (8836, 20081020), (8898, 20081027), (8956, 20081103), (8996, 20081110), (9003, 20081117), (9019, 20081124), (9050, 20081201), (9076, 20081208), (9077, 20081215), (9070, 20081222), (9070, 20081229), (9070, 20090101), (9064, 20090105), (9064, 20090112), (9064, 20090119), (9064, 20090126), (9087, 20090202), (9087, 20090209), (9059, 20090216), (9063, 20090223), (9063, 20090302), (9053, 20090309), (9053, 20090316), (9057, 20090323), (9057, 20090330), (9066, 20090406), (9121, 20090413), (9110, 20090420), (9111, 20090427), (9094, 20090504), (9143, 20090511), (9140, 20090518), (9153, 20090525), (9153, 20090601), (9203, 20090608), (9239, 20090615), (9255, 20090622), (9255, 20090629), (9310, 20090706), (9376, 20090713), (9474, 20090720), (9589, 20090727), (9611, 20090803), (9598, 20090810), (9642, 20090817), (9682, 20090824), (9682, 20090831), (9682, 20090907), (9808, 20090914), (9856, 20090921), (9918, 20090928), (9929, 20091005), (9925, 20091012), (10003, 20091019), (10025, 20091026), (10061, 20091102), (10116, 20091109), (10137, 20091116), (10204, 20091123), (10238, 20091130), (10221, 20091207), (10272, 20091214), (10272, 20091221), (10318, 20091228), (10318, 20100101), (10318, 20100104), (10320, 20100111), (10329, 20100118), (10329, 20100125), (10373, 20100201), (10372, 20100208), (10389, 20100215), (10404, 20100222), (10430, 20100301), (10442, 20100308), (10442, 20100315), (10412, 20100322), (10412, 20100329), (10481, 20100405), (10515, 20100412), (10543, 20100419), (10580, 20100426), (10590, 20100503), (10576, 20100510), (10593, 20100517), (10634, 20100524), (10634, 20100531), (10613, 20100607), (10630, 20100614), (10634, 20100621), (10634, 20100628), (10685, 20100705), (10726, 20100712), (10756, 20100719), (10817, 20100726), (10835, 20100802), (10937, 20100809), (10999, 20100816), (11026, 20100823), (11125, 20100830), (11125, 20100906), (11256, 20100913), (11290, 20100920), (11339, 20100927), (11460, 20101004), (11566, 20101011), (11594, 20101018), (11617, 20101025), (11687, 20101101), (11735, 20101108), (11814, 20101115), (11845, 20101122), (11877, 20101129), (11888, 20101206), (11907, 20101213), (11913, 20101220), (11904, 20101227), (11904, 20110101), (12060, 20110103), (12067, 20110110), (12094, 20110117), (12094, 20110124), (12143, 20110131), (12181, 20110207), (12204, 20110214), (12201, 20110221), (12254, 20110228), (12267, 20110307), (12267, 20110314), (12303, 20110321), (12303, 20110328), (12343, 20110404), (12398, 20110411), (12434, 20110418), (12422, 20110425), (12438, 20110502), (12482, 20110509), (12467, 20110516), (12522, 20110523), (12522, 20110530), (12659, 20110606), (12682, 20110613), (12686, 20110620), (12686, 20110627), (12867, 20110704), (12895, 20110711), (12927, 20110718), (13006, 20110725), (12999, 20110801), (13081, 20110808), (13129, 20110815), (13140, 20110822), (13174, 20110829), (13174, 20110905), (13299, 20110912), (13342, 20110919), (13382, 20110926), (13372, 20111003), (13382, 20111010), (13411, 20111017), (13443, 20111024), (13465, 20111031), (13443, 20111107), (13482, 20111114), (13518, 20111121), (13517, 20111128), (13542, 20111205), (13536, 20111212), (13565, 20111219), (13603, 20111226), (13603, 20120101), (13610, 20120102), (13628, 20120109), (13618, 20120116), (13618, 20120123), (13667, 20120130), (13666, 20120206), (13674, 20120213), (13719, 20120220), (13788, 20120227), (13791, 20120305), (13791, 20120312), (13818, 20120319), (13818, 20120326), (13881, 20120402), (13902, 20120409), (13938, 20120416), (13964, 20120423), (13983, 20120430), (14016, 20120507), (14015, 20120514), (14034, 20120521), (14087, 20120528), (14087, 20120604), (14072, 20120611), (14138, 20120618), (14172, 20120625), (14172, 20120702), (14180, 20120709), (14223, 20120716), (14250, 20120723), (14264, 20120730), (14286, 20120806), (14331, 20120813), (14361, 20120820), (14389, 20120827), (14389, 20120903), (14389, 20120910), (14402, 20120917), (14438, 20120924), (14472, 20121001), (14480, 20121008), (14513, 20121015), (14525, 20121022), (14547, 20121029), (14585, 20121105), (14621, 20121112), (14624, 20121119), (14612, 20121126), (14610, 20121203), (14639, 20121210), (14633, 20121217), (14649, 20121224), (13949, 20121231), (14648, 20130101), (13966, 20130107), (14667, 20130114), (14667, 20130121), (14667, 20130128), (14652, 20130204), (14651, 20130211), (14649, 20130218), (14554, 20130225), (14695, 20130304), (14727, 20130311), (13048, 20130318), (6790, 20130401), (14591, 20130408), (14449, 20130415), (14451, 20130422), (14462, 20130429), (14487, 20130506), (14516, 20130513), (14531, 20130520), (14545, 20130527), (14545, 20130603), (14553, 20130610), (14569, 20130617), (14650, 20130624), (14651, 20130708), (14689, 20130715), (14751, 20130722), (14766, 20130729), (14679, 20130805), (14599, 20130812), (14740, 20130819), (14714, 20130826), (14796, 20130902), (14820, 20130909), (14866, 20130916), (14878, 20130923), (14885, 20130930), (15028, 20131007), (15072, 20131014), (15025, 20131021), (15071, 20131028), (15098, 20131104), (15101, 20131111), (15151, 20131118), (15337, 20131125), (15334, 20131202), (15512, 20131209), (15540, 20131216), (15701, 20131223), (15708, 20131230), (15703, 20140106), (15637, 20140113), (8585, 20140120), (15646, 20140127), (15632, 20140203), (15637, 20140210), (8565, 20140217), (15659, 20140224), (15557, 20150302), (15578, 20150406), (15545, 20150413), (15568, 20150420), (15475, 20150427), (15710, 20150511), (15623, 20150518), (15741, 20150525), (15741, 20150608), (15810, 20150622), (15761, 20150803), (15776, 20150810), (15908, 20150824), (16184, 20150831), (15832, 20150914), (15800, 20150921), (16178, 20151005), (16191, 20151012), (16138, 20151019), (16293, 20151102), (4812, 20160111), (16518, 20160118), (16629, 20160201), (16586, 20160208), (16529, 20160215), (16454, 20160222), (16515, 20160229), (16517, 20160307), (16446, 20160411), (16454, 20160418), (16489, 20160425), (16388, 20160502), (16374, 20160509), (16351, 20160523), (16361, 20160606), (16314, 20160620), (16293, 20160627), (16325, 20160815), (16316, 20160919), (16305, 20160926), (16233, 20161010), (16349, 20161031), (16364, 20161107), (16249, 20161114), (16345, 20161121), (16294, 20161128), (16336, 20161205), (16387, 20161212), (16372, 20170102), (16406, 20170109), (16379, 20170116), (16305, 20170213), (16207, 20170220), (16111, 20170306), (16230, 20170320), (16270, 20170417), (16226, 20170424), (16303, 20170501), (16124, 20170508), (16204, 20170515), (16290, 20170522), (16649, 20170529), (16157, 20170612), (16189, 20170619), (16184, 20170626), (16597, 20170703), (15983, 20170717), (16138, 20170724), (16145, 20170731), (16147, 20170807), (16268, 20170814), (16279, 20170821), (16301, 20170828), (16161, 20170911)]",,1.0,
"What is the name of the winner who has won the most matches, and how many rank points does this player have?","[matches.winner_id, matches.winner_name, players.player_id = matches.winner_id, rankings.player_id = players.player_id, rankings.ranking_points]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",NON-NESTED,"SELECT players.first_name || ' ' || players.last_name AS winner_name, rankings.ranking_points FROM matches JOIN players ON matches.winner_id = players.player_id JOIN rankings ON players.player_id = rankings.player_id GROUP BY players.player_id, rankings.ranking_points ORDER BY COUNT(matches.winner_id) DESC LIMIT 1;","SELECT winner_name ,  winner_rank_points FROM matches GROUP BY winner_name ORDER BY count(*) DESC LIMIT 1",wta_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the winner and their total rank points. Use COUNT to count the number of matches won by each player. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the player with the most wins. 3. Join Structure: Use JOINs to connect the ""matches"" table with the ""players"" table on ""matches.winner_id = players.player_id"" to get the winner's name, and then join the ""rankings"" table on ""rankings.player_id = players.player_id"" to get the rank points. 4. Aggregation Structure: Use COUNT to count the number of matches won by each player, GROUP BY to group results by player, and ORDER BY in descending order of the count to find the player with the most wins. Use LIMIT 1 to select the top player.","[('Karolina Pliskova', 4)]","[('Angelique Kerber', 3715)]",,0.0,
What are the id and name of the museum visited most times?,"[museum.Museum_ID, museum.Name, visit.Museum_ID, visit.Num_of_Ticket]","Table museum, columns = [*,Museum_ID,Name,Num_of_Staff,Open_Year]
Table visit, columns = [*,Museum_ID,visitor_ID,Num_of_Ticket,Total_spent]
Table visitor, columns = [*,ID,Name,Level_of_membership,Age]
","Foreign_keys = [visit.visitor_ID = visitor.ID,visit.Museum_ID = museum.Museum_ID]
",NON-NESTED,"SELECT museum.Museum_ID, museum.Name FROM museum JOIN visit ON museum.Museum_ID = visit.Museum_ID GROUP BY museum.Museum_ID, museum.Name ORDER BY SUM(visit.Num_of_Ticket) DESC LIMIT 1;","SELECT t2.Museum_ID ,  t1.name FROM museum AS t1 JOIN visit AS t2 ON t1.Museum_ID  =  t2.Museum_ID GROUP BY t2.Museum_ID ORDER BY count(*) DESC LIMIT 1",museum_visit,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""museum.Museum_ID"" and ""museum.Name."" Use an aggregate function (SUM) on ""visit.Num_of_Ticket"" to calculate the total number of tickets for each museum. 2. Condition Structure: No specific filtering condition is required, as we are interested in all museums. 3. Join Structure: Use an INNER JOIN between the ""museum"" and ""visit"" tables on ""museum.Museum_ID = visit.Museum_ID"" to link each museum with its visit records. 4. Aggregation Structure: Use GROUP BY on ""museum.Museum_ID"" and ""museum.Name"" to group the results by museum. Use ORDER BY in descending order on the total number of tickets (SUM of ""visit.Num_of_Ticket"") to rank museums by the number of visits. Use LIMIT 1 to select the museum with the highest number of visits.","[(2, 'Capital Plaza Museum')]","[(2, 'Capital Plaza Museum')]",,1.0,
What is the average rank for winners in all matches?,"[matches.winner_id, matches.winner_rank]","Table matches, columns = [*,best_of,draw_size,loser_age,loser_entry,loser_hand,loser_ht,loser_id,loser_ioc,loser_name,loser_rank,loser_rank_points,loser_seed,match_num,minutes,round,score,surface,tourney_date,tourney_id,tourney_level,tourney_name,winner_age,winner_entry,winner_hand,winner_ht,winner_id,winner_ioc,winner_name,winner_rank,winner_rank_points,winner_seed,year]
Table players, columns = [*,player_id,first_name,last_name,hand,birth_date,country_code]
Table rankings, columns = [*,ranking_date,ranking,player_id,ranking_points,tours]
","Foreign_keys = [matches.winner_id = players.player_id,matches.loser_id = players.player_id,rankings.player_id = players.player_id]
",EASY,SELECT AVG(matches.winner_rank) AS average_winner_rank FROM matches;,SELECT avg(winner_rank) FROM matches,wta_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average rank of winners. 2. Aggregation Structure: Use the AVG function to calculate the average of ""matches.winner_rank"". 3. Condition Structure: No specific filtering condition is required since the query asks for the average rank of all winners in all matches. 4. Join Structure: No JOIN is required as the necessary data is available within the ""matches"" table.","[(13.715827338129497,)]","[(13.715827338129497,)]",,1.0,
What are the different addresses that have students living there?,"[Addresses.address_id, Students.current_address_id, Students.permanent_address_id, Students.current_address_id = Addresses.address_id, Students.permanent_address_id = Addresses.address_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT DISTINCT A.* FROM Addresses AS A JOIN Students AS S1 ON S1.current_address_id = A.address_id JOIN Students AS S2 ON S2.permanent_address_id = A.address_id;,SELECT count(DISTINCT current_address_id) FROM Students,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct address details from the ""Addresses"" table. Since we are interested in different addresses where students live, we will include all relevant address fields. 2. Condition Structure: No specific filtering condition is required, as we are interested in all addresses associated with students. 3. Join Structure: Use JOINs to connect the ""Students"" table with the ""Addresses"" table twice: once for ""current_address_id"" and once for ""permanent_address_id."" This ensures we capture both current and permanent addresses of students. 4. Aggregation Structure: Use DISTINCT to ensure that only unique addresses are returned.","[(9, '0643 Muller Vista', 'Suite 383', None, 'Port Elvisfurt', '777', 'NorthCarolina', 'Gabon', None), (14, '186 Evan Motorway Apt. 409', 'Suite 079', None, 'Lake Careyberg', '895', 'Kentucky', 'New Caledonia', None), (15, '74046 Metz Walk Apt. 113', 'Suite 674', None, 'Port Oceane', '669', 'Wyoming', 'Norfolk Island', None)]","[(9,)]",,1.0,
What are the titles of the cartoons sorted alphabetically?,[Cartoon.Title],"Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT Cartoon.Title FROM Cartoon ORDER BY Cartoon.Title ASC;,SELECT Title FROM Cartoon ORDER BY title,tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Cartoon.Title"" field, as the question asks for the titles of cartoons. 2. Condition Structure: No specific filtering condition is required since we want all cartoon titles. 3. Join Structure: No JOIN is necessary because the required data is available within the ""Cartoon"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the titles. 5. Ordering Structure: Use ORDER BY to sort the cartoon titles alphabetically.","[('Dawn of the Dead Man!',), ('Day of the Dark Knight!',), ('Deep Cover for Batman!',), ('Enter the Outsiders!',), ('Evil Under the Sea!',), ('Fall of the Blue Beetle!',), ('Invasion of the Secret Santas!',), ('Journey to the Center of the Bat!',), ('Return of the Fearsome Fangs!',), ('Terror on Dinosaur Island!',), ('The Eyes of Despero!',), ('The Rise of the Blue Beetle!',)]","[('Dawn of the Dead Man!',), ('Day of the Dark Knight!',), ('Deep Cover for Batman!',), ('Enter the Outsiders!',), ('Evil Under the Sea!',), ('Fall of the Blue Beetle!',), ('Invasion of the Secret Santas!',), ('Journey to the Center of the Bat!',), ('Return of the Fearsome Fangs!',), ('Terror on Dinosaur Island!',), ('The Eyes of Despero!',), ('The Rise of the Blue Beetle!',)]",,1.0,
"What is the first, middle, and last name of the first student to register?","[Students.first_name, Students.middle_name, Students.last_name, Students.date_first_registered]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT Students.first_name, Students.middle_name, Students.last_name FROM Students ORDER BY Students.date_first_registered ASC LIMIT 1;","SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""first_name,"" ""middle_name,"" and ""last_name"" of the student. 2. Condition Structure: No specific filtering condition is required since we are looking for the first student to register. 3. Join Structure: No JOIN is required as all necessary information is available in the ""Students"" table. 4. Aggregation Structure: Use ORDER BY on ""Students.date_first_registered"" in ascending order to sort students by their registration date. Use LIMIT 1 to select the first student.","[('Timmothy', 'Anna', 'Ward')]","[('Timmothy', 'Anna', 'Ward')]",,1.0,
What are the names and descriptions of all the sections?,"[Sections.section_name, Sections.section_description]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT Sections.section_name, Sections.section_description FROM Sections;","SELECT section_name ,  section_description FROM Sections",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""section_name"" and ""section_description"" fields from the ""Sections"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for all sections. 3. Join Structure: No JOIN is necessary since all the required information is available in the ""Sections"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the names and descriptions of all sections.","[('a', 'non'), ('b', 'voluptatem'), ('c', 'qui'), ('d', 'voluptas'), ('e', 'ex'), ('f', 'doloremque'), ('g', 'provident'), ('h', 'et'), ('j', 'quis'), ('k', 'nesciunt'), ('l', 'ad'), ('o', 'et'), ('p', 'facilis'), ('u', 'reprehenderit'), ('y', 'qui')]","[('a', 'non'), ('b', 'voluptatem'), ('c', 'qui'), ('d', 'voluptas'), ('e', 'ex'), ('f', 'doloremque'), ('g', 'provident'), ('h', 'et'), ('j', 'quis'), ('k', 'nesciunt'), ('l', 'ad'), ('o', 'et'), ('p', 'facilis'), ('u', 'reprehenderit'), ('y', 'qui')]",,1.0,
List the number of different series names and contents in the TV Channel table.,"[TV_Channel.series_name, TV_Channel.Content]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT COUNT(DISTINCT TV_Channel.series_name) AS distinct_series_names, COUNT(DISTINCT TV_Channel.Content) AS distinct_contents FROM TV_Channel;","SELECT count(DISTINCT series_name) ,  count(DISTINCT content) FROM TV_Channel;",tvshow,"1. Sequential Structure: Start with the SELECT clause to count the distinct series names and contents in the ""TV_Channel"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for the count of distinct series names and contents. 3. Join Structure: No JOIN is required since all necessary data is within the ""TV_Channel"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to calculate the number of unique series names and contents.","[(15, 1)]","[(15, 1)]",,1.0,
What are the countries that have cartoons on TV that were written by Todd Casey?,"[Cartoon.Title,Cartoon.Written_by,Cartoon.Channel,TV_Channel.Country,Cartoon.Channel = TV_Channel.id,Todd Casey]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,SELECT DISTINCT TV_Channel.Country FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE Cartoon.Written_by = 'Todd Casey';,SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey',tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct countries where cartoons written by ""Todd Casey"" are aired. 2. Condition Structure: Use a WHERE clause to filter for cartoons written by ""Todd Casey."" 3. Join Structure: Use an INNER JOIN between the ""Cartoon"" table and the ""TV_Channel"" table based on the foreign key ""Cartoon.Channel = TV_Channel.id"" to link cartoons with their respective TV channels. 4. Aggregation Structure: Use DISTINCT to ensure that each country is listed only once in the result.","[('United Kingdom',), ('Italy',)]","[('United Kingdom',), ('Italy',)]",,1.0,
"What is the content of TV Channel with serial name ""Sky Radio""?","[TV_Channel.Content,TV_Channel.series_name,Sky Radio]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT TV_Channel.Content FROM TV_Channel WHERE TV_Channel.series_name = 'Sky Radio';,"SELECT Content FROM TV_Channel WHERE series_name = ""Sky Radio"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""TV_Channel.Content"" field, as the question asks for the content of the TV channel. 2. Condition Structure: Use a WHERE clause to filter for the TV channel where ""TV_Channel.series_name"" is ""Sky Radio"". 3. Join Structure: No JOIN is required since all necessary information is in the ""TV_Channel"" table. 4. Aggregation Structure: No aggregation is needed, as we are retrieving a single field based on a specific condition.","[('music',)]","[('music',)]",,1.0,
"List the title of all  Cartoons showed on TV Channel with series name ""Sky Radio"".","[Cartoon.Title,TV_Channel.series_name,Cartoon.Channel = TV_Channel.id,Sky Radio]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,SELECT Cartoon.Title FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE TV_Channel.series_name = 'Sky Radio';,"SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = ""Sky Radio"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Cartoon.Title."" 2. Condition Structure: Use a WHERE clause to filter for records where the ""TV_Channel.series_name"" is ""Sky Radio."" 3. Join Structure: Use a JOIN between the ""Cartoon"" and ""TV_Channel"" tables based on the foreign key relationship ""Cartoon.Channel = TV_Channel.id"" to link cartoons with their respective TV channels. 4. Aggregation Structure: No aggregation is needed as the query only retrieves titles of cartoons.","[('The Rise of the Blue Beetle!',), ('Return of the Fearsome Fangs!',)]","[('The Rise of the Blue Beetle!',), ('Return of the Fearsome Fangs!',)]",,1.0,
"What is the name of the series that has the episode ""A Love of a Lifetime""?","[TV_series.series_name,TV_series.Episode,""A Love of a Lifetime""]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT TV_series.series_name FROM TV_series WHERE TV_series.Episode = 'A Love of a Lifetime';,"SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = ""A Love of a Lifetime"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""series_name"" of the series that has the episode titled ""A Love of a Lifetime"". 2. Condition Structure: Use a WHERE clause to filter for the episode with the title ""A Love of a Lifetime"". 3. Join Structure: No JOIN is required since all necessary information is in the ""TV_series"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",[],"[('Sky Radio',)]",no such column: TV_series.series_name,0.0,
What are all the course names of the courses which ever have students enrolled in?,"[Courses.course_name, Student_Enrolment_Courses.course_id, Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT DISTINCT Courses.course_name FROM Courses JOIN Student_Enrolment_Courses ON Courses.course_id = Student_Enrolment_Courses.course_id WHERE Student_Enrolment_Courses.student_enrolment_id IS NOT NULL;,SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Courses.course_name"" since we are interested in all unique course names. 2. Condition Structure: No specific filtering condition is required, as we are looking for all courses that have any student enrolled. 3. Join Structure: Use a JOIN between the ""Courses"" table and the ""Student_Enrolment_Courses"" table on ""Courses.course_id"" and ""Student_Enrolment_Courses.course_id"" to link courses with their enrollments. Additionally, ensure that ""Student_Enrolment_Courses.student_enrolment_id"" is not NULL to confirm that students are enrolled. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique course names are returned.","[('la',), ('pl',), ('ai',), ('math',), ('ml',), ('os',), ('en',), ('nlp',), ('rs',), ('db',)]","[('la',), ('pl',), ('ai',), ('math',), ('ml',), ('os',), ('en',), ('nlp',), ('rs',), ('db',)]",,1.0,
Find the series name and country of the tv channel that is playing some cartoons directed by Ben Jones and Michael Chang?,"[TV_Channel.series_name, TV_Channel.Country, Cartoon.Title, Cartoon.Directed_by, Cartoon.Channel = TV_Channel.id, Ben Jones, Michael Chang]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,"SELECT TV_Channel.series_name, TV_Channel.Country FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE Cartoon.Directed_by = 'Ben Jones' OR Cartoon.Directed_by = 'Michael Chang';","SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve ""TV_Channel.series_name"" and ""TV_Channel.Country."" 2. Condition Structure: Use a WHERE clause to filter for cartoons directed by ""Ben Jones"" or ""Michael Chang."" 3. Join Structure: Use a JOIN between the ""Cartoon"" table and the ""TV_Channel"" table based on the foreign key ""Cartoon.Channel = TV_Channel.id"" to link cartoons with their respective TV channels. 4. Aggregation Structure: No aggregation is needed as the query is focused on filtering and retrieving specific data.","[('Sky Radio', 'Italy'), ('Music Box Italia', 'Italy'), ('MTV Hits', 'Italy'), ('MTV Rocks', 'United Kingdom'), ('MTV Dance', 'United Kingdom'), ('MTV Dance', 'United Kingdom'), ('Classica', 'Italy'), ('MTV Dance', 'United Kingdom')]","[('MTV Dance', 'United Kingdom')]",,1.0,
What is the name of the course with the most students enrolled?,"[Courses.course_name, Student_Enrolment_Courses.course_id, Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT Courses.course_name FROM Courses JOIN Student_Enrolment_Courses ON Courses.course_id = Student_Enrolment_Courses.course_id GROUP BY Student_Enrolment_Courses.course_id ORDER BY COUNT(Student_Enrolment_Courses.student_enrolment_id) DESC LIMIT 1;,SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Courses.course_name"" since we need the name of the course. Use COUNT to count the number of students enrolled in each course. Use GROUP BY to group the results by ""Student_Enrolment_Courses.course_id"" and ORDER BY in descending order of the count to find the course with the most students. Use LIMIT 1 to get the top result. 2. Condition Structure: No specific filtering condition is required as we are considering all courses. 3. Join Structure: Use a JOIN between ""Courses"" and ""Student_Enrolment_Courses"" on ""Courses.course_id = Student_Enrolment_Courses.course_id"" to link courses with their enrollments. 4. Aggregation Structure: Use COUNT to calculate the number of students enrolled in each course, and ORDER BY COUNT in descending order to find the course with the highest enrollment.","[('pl',)]","[('rs',)]",,0.0,
How many degrees does the engineering department offer?,"[Degree_Programs.degree_program_id,Departments.department_name,Degree_Programs.department_id = Departments.department_id,engineering]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT COUNT(Degree_Programs.degree_program_id) FROM Degree_Programs JOIN Departments ON Degree_Programs.department_id = Departments.department_id WHERE Departments.department_name = 'engineering';,SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to count the number of degree programs offered by the engineering department. Use COUNT on ""Degree_Programs.degree_program_id."" 2. Condition Structure: Use a WHERE clause to filter for the department with the name ""engineering."" 3. Join Structure: Use an INNER JOIN to connect the ""Degree_Programs"" table with the ""Departments"" table based on the foreign key relationship ""Degree_Programs.department_id = Departments.department_id."" 4. Aggregation Structure: Use COUNT to aggregate the number of degree programs offered by the engineering department.","[(0,)]","[(0,)]",,1.0,
find the pixel aspect ratio and nation of the tv channels that do not use English.,"[TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country, TV_Channel.Language]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NESTED,"SELECT Pixel_aspect_ratio_PAR, Country FROM TV_Channel WHERE Language != 'English';","SELECT Pixel_aspect_ratio_PAR ,  country FROM tv_channel WHERE LANGUAGE != 'English'",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the pixel aspect ratio and country of TV channels. Use the FROM clause to specify the TV_Channel table. Apply a WHERE clause to filter out channels that do not use English as their language. 2. Condition Structure: Use the WHERE clause to filter for records where the Language column is not equal to 'English'. 3. Join Structure: Not required, as all the necessary data is available in the TV_Channel table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('4:3', 'Italy'), ('4:3', 'Italy'), ('4:3 / 16:9', 'Italy'), ('16:9', 'Italy'), ('4:3', 'Italy'), ('16:9', 'Italy'), ('4:3', 'Italy'), ('16:9', 'Italy'), ('4:3 / 16:9', 'Italy'), ('4:3 / 16:9', 'Italy'), ('4:3', 'Italy'), ('4:3', 'Italy')]","[('4:3', 'Italy'), ('4:3', 'Italy'), ('4:3 / 16:9', 'Italy'), ('16:9', 'Italy'), ('4:3', 'Italy'), ('16:9', 'Italy'), ('4:3', 'Italy'), ('16:9', 'Italy'), ('4:3 / 16:9', 'Italy'), ('4:3 / 16:9', 'Italy'), ('4:3', 'Italy'), ('4:3', 'Italy')]",,1.0,
"Show the date of the transcript which shows the least number of results, also list the id.","[Transcripts.transcript_date, Transcripts.transcript_id, Transcript_Contents.transcript_id = Transcripts.transcript_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NESTED,"SELECT Transcripts.transcript_id, Transcripts.transcript_date FROM Transcripts JOIN Transcript_Contents ON Transcript_Contents.transcript_id = Transcripts.transcript_id GROUP BY Transcripts.transcript_id, Transcripts.transcript_date ORDER BY COUNT(Transcript_Contents.student_course_id) ASC LIMIT 1;","SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id ORDER BY count(*) ASC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the transcript date and transcript ID. Use the FROM clause to specify the Transcripts table. Join it with the Transcript_Contents table to count the number of results associated with each transcript. Use GROUP BY to group by transcript ID and transcript date. Apply an ORDER BY clause to sort by the count of results in ascending order and use LIMIT 1 to get the transcript with the least number of results. 2. Condition Structure: No specific filtering condition is required, as we are interested in all transcripts and their associated results. 3. Join Structure: Use an INNER JOIN between the Transcripts and Transcript_Contents tables based on the transcript_id to link transcripts with their results. 4. Aggregation Structure: Use COUNT(*) to count the number of results for each transcript and sort them to find the one with the least results.","[(2, '1975-10-28 15:16:51')]","[('1975-10-28 15:16:51', 2)]",,1.0,
"What is the TV Channel of TV series with Episode ""A Love of a Lifetime""? List the TV Channel's series name.","[TV_Channel.series_name, TV_series.Episode, TV_series.Channel = TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,SELECT TV_Channel.series_name FROM TV_series JOIN TV_Channel ON TV_series.Channel = TV_Channel.id WHERE TV_series.Episode = 'A Love of a Lifetime';,"SELECT T1.series_name FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T2.Episode = ""A Love of a Lifetime"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""TV_Channel.series_name"" for the TV series with the specified episode title. 2. Condition Structure: Use a WHERE clause to filter for the TV series where ""TV_series.Episode"" is ""A Love of a Lifetime."" 3. Join Structure: Use an INNER JOIN to connect the ""TV_series"" table with the ""TV_Channel"" table based on the foreign key relationship ""TV_series.Channel = TV_Channel.id."" 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific information for a single episode.","[('Sky Radio',)]","[('Sky Radio',)]",,1.0,
What is the date and id of the transcript with at least 2 courses listed?,"[Transcripts.transcript_id,Transcripts.transcript_date,Transcript_Contents.transcript_id,Transcript_Contents.student_course_id,Student_Enrolment_Courses.student_course_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Transcripts.transcript_id, Transcripts.transcript_date FROM Transcripts JOIN Transcript_Contents ON Transcripts.transcript_id = Transcript_Contents.transcript_id GROUP BY Transcripts.transcript_id, Transcripts.transcript_date HAVING COUNT(Transcript_Contents.student_course_id) >= 2;","SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Transcripts.transcript_id"" and ""Transcripts.transcript_date."" 2. Condition Structure: Use a HAVING clause to filter for transcripts that have at least 2 courses listed. This requires counting the number of ""Transcript_Contents.student_course_id"" entries for each transcript. 3. Join Structure: Use a JOIN between ""Transcripts"" and ""Transcript_Contents"" on ""Transcripts.transcript_id"" to link each transcript with its contents. 4. Aggregation Structure: Use COUNT on ""Transcript_Contents.student_course_id"" to count the number of courses listed for each transcript, and filter with HAVING to select transcripts with at least 2 courses.","[(5, '2013-06-30 13:01:40'), (6, '2010-12-13 10:55:15'), (8, '1975-05-06 12:04:47'), (15, '1998-11-22 12:18:29')]","[('2013-06-30 13:01:40', 5), ('2010-12-13 10:55:15', 6), ('1975-05-06 12:04:47', 8), ('1998-11-22 12:18:29', 15)]",,1.0,
"Who is the first student to register? List the first name, middle name and last name.","[Students.first_name, Students.middle_name, Students.last_name, Students.date_first_registered]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT Students.first_name, Students.middle_name, Students.last_name FROM Students ORDER BY Students.date_first_registered ASC LIMIT 1;","SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_first_registered ASC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""first_name,"" ""middle_name,"" and ""last_name"" of the student who registered first. 2. Condition Structure: No specific filtering condition is required, as we are looking for the earliest registration date. 3. Join Structure: No JOIN is necessary since all relevant information is available in the ""Students"" table. 4. Aggregation Structure: Use ORDER BY on ""Students.date_first_registered"" in ascending order to sort by the earliest registration date. Apply LIMIT 1 to select the first student.","[('Timmothy', 'Anna', 'Ward')]","[('Timmothy', 'Anna', 'Ward')]",,1.0,
How many cartoons did each director create?,"[Cartoon.id, Cartoon.Directed_by]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT Cartoon.Directed_by, COUNT(Cartoon.id) AS cartoon_count FROM Cartoon GROUP BY Cartoon.Directed_by;","SELECT count(*) ,  Directed_by FROM cartoon GROUP BY Directed_by",tvshow,"1. Sequential Structure: Start with the SELECT clause to specify the director's name and the count of cartoons they created. 2. Aggregation Structure: Use COUNT to calculate the number of cartoons created by each director. 3. Grouping Structure: Use GROUP BY on ""Cartoon.Directed_by"" to aggregate the results by each director. 4. Join Structure: No JOIN is required since all necessary data is within the ""Cartoon"" table. 5. Condition Structure: No specific filtering condition is required as the query asks for the count of cartoons for each director.","[('Ben Jones', 4), ('Brandon Vietti', 4), ('Michael Chang', 4)]","[(4, 'Ben Jones'), (4, 'Brandon Vietti'), (4, 'Michael Chang')]",,1.0,
What is the description for the section named h?,"[Sections.section_description, Sections.section_name, Sections.section_name = 'h']","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Sections.section_description FROM Sections WHERE Sections.section_name = 'h';,SELECT section_description FROM Sections WHERE section_name  =  'h',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Sections.section_description"" for the section named 'h'. 2. Condition Structure: Use a WHERE clause to filter for the section where ""Sections.section_name"" equals 'h'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Sections"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('et',)]","[('et',)]",,1.0,
What is the content of the series Sky Radio?,"[TV_Channel.Content, TV_Channel.series_name, TV_series.Channel = TV_Channel.id, TV_Channel.series_name = 'Sky Radio']","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,SELECT TV_Channel.Content FROM TV_Channel WHERE TV_Channel.series_name = 'Sky Radio';,"SELECT Content FROM TV_Channel WHERE series_name = ""Sky Radio"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""TV_Channel.Content"" field, as the question asks for the content of the series. 2. Condition Structure: Use a WHERE clause to filter for the specific series name, ""Sky Radio."" 3. Join Structure: No JOIN is required since the ""series_name"" and ""Content"" fields are both in the ""TV_Channel"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single value based on the condition.","[('music',)]","[('music',)]",,1.0,
which countries' tv channels are not playing any cartoon written by Todd Casey?,"[TV_Channel.Country, Cartoon.Written_by, Cartoon.Channel = TV_Channel.id, Todd Casey]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NESTED,SELECT DISTINCT TV_Channel.Country FROM TV_Channel WHERE TV_Channel.id NOT IN ( SELECT Cartoon.Channel FROM Cartoon WHERE Cartoon.Written_by = 'Todd Casey' );,SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey',tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct countries of TV channels. Use the FROM clause to specify the TV_Channel table. Apply a WHERE clause to filter for countries whose channels are not playing any cartoon written by Todd Casey. 2. Condition Structure: Use a WHERE clause with a subquery to exclude countries where the channel ID matches any channel playing a cartoon written by Todd Casey. The subquery identifies such channels by filtering the Cartoon table for entries where Written_by is 'Todd Casey'. 3. Join Structure: Use the relationship between Cartoon.Channel and TV_Channel.id to connect cartoons with their respective TV channels. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('Italy',), ('United Kingdom',), ('Poland',)]","[('Poland',)]",,1.0,
"What is the series name of the TV Channel that shows the cartoon ""The Rise of the Blue Beetle""?","[Cartoon.Title, TV_Channel.series_name, Cartoon.Channel = TV_Channel.id, ""The Rise of the Blue Beetle""]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,SELECT TV_Channel.series_name FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE Cartoon.Title = 'The Rise of the Blue Beetle';,"SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = ""The Rise of the Blue Beetle!"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""TV_Channel.series_name."" 2. Condition Structure: Use a WHERE clause to filter for the cartoon with the title ""The Rise of the Blue Beetle."" 3. Join Structure: Use a JOIN between the ""Cartoon"" and ""TV_Channel"" tables based on the foreign key relationship ""Cartoon.Channel = TV_Channel.id"" to link the cartoon with its corresponding TV channel. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single value.",[],"[('Sky Radio',)]",,0.0,
"On average, when were the transcripts printed?",[Transcripts.transcript_date],"Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT AVG(Transcripts.transcript_date) AS average_transcript_date FROM Transcripts;,SELECT avg(transcript_date) FROM Transcripts,student_transcripts_tracking,"1. Sequential Structure: Begin with the SELECT clause to calculate the average date when transcripts were printed. 2. Aggregation Structure: Use the AVG function on the ""Transcripts.transcript_date"" field to compute the average date. 3. Condition Structure: No specific filtering condition is required as we are calculating the average for all transcripts. 4. Join Structure: No JOIN is required since all necessary data is within the ""Transcripts"" table.","[(1989.9333333333334,)]","[(1989.9333333333334,)]",,1.0,
What is the date and id of the transcript with the least number of results?,"[Transcripts.transcript_id, Transcripts.transcript_date, Transcript_Contents.transcript_id = Transcripts.transcript_id, Transcript_Contents.student_course_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Transcripts.transcript_id, Transcripts.transcript_date FROM Transcripts JOIN Transcript_Contents ON Transcript_Contents.transcript_id = Transcripts.transcript_id GROUP BY Transcripts.transcript_id, Transcripts.transcript_date ORDER BY COUNT(Transcript_Contents.student_course_id) ASC LIMIT 1;","SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id ORDER BY count(*) ASC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Transcripts.transcript_id"" and ""Transcripts.transcript_date."" Use COUNT to determine the number of results associated with each transcript. 2. Condition Structure: No specific filtering condition is needed, but we need to identify the transcript with the least number of results. This will be done using ORDER BY and LIMIT 1. 3. Join Structure: Use a JOIN between ""Transcripts"" and ""Transcript_Contents"" on ""Transcript_Contents.transcript_id = Transcripts.transcript_id"" to link each transcript with its results. 4. Aggregation Structure: Use COUNT on ""Transcript_Contents.student_course_id"" to count the number of results for each transcript. Use ORDER BY in ascending order to rank transcripts by the number of results, and LIMIT 1 to select the transcript with the least number of results.","[(2, '1975-10-28 15:16:51')]","[('1975-10-28 15:16:51', 2)]",,1.0,
"List the title of all cartoon directed by ""Ben Jones"" or ""Brandon Vietti"".","[Cartoon.Title, Cartoon.Directed_by, Cartoon.Channel = TV_Channel.id, Ben Jones, Brandon Vietti]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT Cartoon.Title FROM Cartoon WHERE Cartoon.Directed_by = 'Ben Jones' OR Cartoon.Directed_by = 'Brandon Vietti';,"SELECT Title FROM Cartoon WHERE Directed_by = ""Ben Jones"" OR Directed_by = ""Brandon Vietti"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Cartoon.Title"" of cartoons directed by ""Ben Jones"" or ""Brandon Vietti"". 2. Condition Structure: Use a WHERE clause to filter for rows where ""Cartoon.Directed_by"" is either ""Ben Jones"" or ""Brandon Vietti"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Cartoon"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving titles based on a specific condition.","[('The Rise of the Blue Beetle!',), ('Terror on Dinosaur Island!',), ('Day of the Dark Knight!',), ('Invasion of the Secret Santas!',), ('Dawn of the Dead Man!',), ('Fall of the Blue Beetle!',), ('The Eyes of Despero!',), ('Return of the Fearsome Fangs!',)]","[('The Rise of the Blue Beetle!',), ('Terror on Dinosaur Island!',), ('Day of the Dark Knight!',), ('Invasion of the Secret Santas!',), ('Dawn of the Dead Man!',), ('Fall of the Blue Beetle!',), ('The Eyes of Despero!',), ('Return of the Fearsome Fangs!',)]",,1.0,
Describe the section h.,"[Sections.section_name, Sections.section_description, Sections.section_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT Sections.section_name, Sections.section_description FROM Sections WHERE Sections.section_name = 'h';",SELECT section_description FROM Sections WHERE section_name  =  'h',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the section name and section description for the section with the name 'h'. 2. Condition Structure: Use a WHERE clause to filter the section by its name, specifically where ""Sections.section_name"" equals 'h'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Sections"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific details about a single section.","[('h', 'et')]","[('et',)]",,1.0,
"What is the air date of TV series with Episode ""A Love of a Lifetime""?","[TV_series.Air_Date,TV_series.Episode]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT TV_series.Air_Date FROM TV_series WHERE TV_series.Episode = 'A Love of a Lifetime';,"SELECT Air_Date FROM TV_series WHERE Episode = ""A Love of a Lifetime"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Air_Date"" of the TV series with the specified episode title. 2. Condition Structure: Use a WHERE clause to filter for the episode titled ""A Love of a Lifetime."" 3. Join Structure: No JOIN is required since all necessary information is in the ""TV_series"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('September 24, 2007',)]","[('September 24, 2007',)]",,1.0,
"What is the TV Channel that shows the cartoon ""The Rise of the Blue Beetle!""? List the TV Channel's series name.","[Cartoon.Title, TV_Channel.series_name, Cartoon.Channel = TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,SELECT TV_Channel.series_name FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE Cartoon.Title = 'The Rise of the Blue Beetle!';,"SELECT T1.series_name FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T2.Title = ""The Rise of the Blue Beetle!"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""TV_Channel.series_name."" 2. Condition Structure: Use a WHERE clause to filter for the cartoon with the title ""The Rise of the Blue Beetle!"". 3. Join Structure: Use a JOIN between the ""Cartoon"" and ""TV_Channel"" tables based on the foreign key ""Cartoon.Channel = TV_Channel.id"" to link the cartoon with its corresponding TV channel. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific information about the TV channel.","[('Sky Radio',)]","[('Sky Radio',)]",,1.0,
"What is the episode for the TV series named ""Sky Radio""?","[TV_series.Episode,TV_Channel.series_name,TV_series.Channel = TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,SELECT TV_series.Episode FROM TV_series JOIN TV_Channel ON TV_series.Channel = TV_Channel.id WHERE TV_Channel.series_name = 'Sky Radio';,"SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = ""Sky Radio"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""TV_series.Episode"" field, as the question asks for the episode of a specific TV series. 2. Condition Structure: Use a WHERE clause to filter for the TV series with the name ""Sky Radio."" This requires filtering on ""TV_Channel.series_name."" 3. Join Structure: Use an INNER JOIN between the ""TV_series"" table and the ""TV_Channel"" table based on the foreign key relationship ""TV_series.Channel = TV_Channel.id"" to link the series with its channel information. 4. Aggregation Structure: No aggregation is needed, as the query is retrieving specific information about a single TV series.","[('A Love of a Lifetime',), ('Keepers',)]","[('A Love of a Lifetime',), ('Keepers',)]",,1.0,
"Who is enrolled in a Bachelor degree program? List the first name, middle name, last name.","[Degree_Programs.degree_summary_name, Students.first_name, Students.middle_name, Students.last_name, Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id, Student_Enrolment.student_id = Students.student_id, Bachelor]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Students.first_name, Students.middle_name, Students.last_name FROM Degree_Programs JOIN Student_Enrolment ON Degree_Programs.degree_program_id = Student_Enrolment.degree_program_id JOIN Students ON Student_Enrolment.student_id = Students.student_id WHERE Degree_Programs.degree_summary_name = 'Bachelor';","SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""first_name,"" ""middle_name,"" and ""last_name"" of students. 2. Condition Structure: Use a WHERE clause to filter for students enrolled in a degree program where the ""degree_summary_name"" is ""Bachelor."" 3. Join Structure: Use JOINs to connect the ""Degree_Programs"" table with the ""Student_Enrolment"" table on ""degree_program_id"" and the ""Student_Enrolment"" table with the ""Students"" table on ""student_id."" 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific student details.","[('Reva', 'Golda', 'Osinski'), ('Frida', 'Aisha', 'Huel'), ('Reva', 'Golda', 'Osinski'), ('Jarvis', 'Aaliyah', 'Carroll'), ('Frida', 'Aisha', 'Huel'), ('Jarvis', 'Aaliyah', 'Carroll'), ('Milton', 'Vaughn', 'Christiansen'), ('Stanford', 'Mona', 'Rogahn')]","[('Reva', 'Golda', 'Osinski'), ('Frida', 'Aisha', 'Huel'), ('Jarvis', 'Aaliyah', 'Carroll'), ('Milton', 'Vaughn', 'Christiansen'), ('Stanford', 'Mona', 'Rogahn')]",,1.0,
How many transcripts are listed?,[Transcripts.transcript_id],"Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT COUNT(Transcripts.transcript_id) AS total_transcripts FROM Transcripts;,SELECT count(*) FROM Transcripts,student_transcripts_tracking,"1. Sequential Structure: Begin with the SELECT clause to count the number of transcripts, as the question asks for the total count. 2. Condition Structure: No specific filtering condition is required since we want the total number of transcripts. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Transcripts"" table. 4. Aggregation Structure: Use COUNT on ""Transcripts.transcript_id"" to calculate the total number of transcripts.","[(15,)]","[(15,)]",,1.0,
What is the maximum number of times that a course shows up in different transcripts and what is that course's enrollment id?,"[Transcript_Contents.student_course_id,Student_Enrolment_Courses.student_course_id,Student_Enrolment_Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Student_Enrolment_Courses.course_id, COUNT(Transcript_Contents.transcript_id) AS transcript_count FROM Transcript_Contents JOIN Student_Enrolment_Courses ON Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id GROUP BY Student_Enrolment_Courses.course_id ORDER BY transcript_count DESC LIMIT 1;","SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the maximum count of a course appearing in different transcripts and the corresponding ""Student_Enrolment_Courses.course_id."" Use COUNT to count the occurrences of each course in the ""Transcript_Contents"" table. 2. Condition Structure: No specific filtering condition is required, as we are analyzing all courses across all transcripts. 3. Join Structure: Use a JOIN between ""Transcript_Contents"" and ""Student_Enrolment_Courses"" on ""student_course_id"" to link each transcript entry to its corresponding course. 4. Aggregation Structure: Use COUNT to count the occurrences of each course in the ""Transcript_Contents"" table. Use GROUP BY on ""Student_Enrolment_Courses.course_id"" to group the counts by course. Use ORDER BY in descending order to rank the courses by their count, and LIMIT 1 to get the course with the maximum count.","[(6, 4)]","[(4, 0)]",,0.0,
What are the languages used by the least number of TV Channels and how many channels use it?,"[TV_Channel.Language, TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NESTED,"SELECT Language, COUNT(*) AS channel_count FROM TV_Channel GROUP BY Language HAVING COUNT(*) = (SELECT MIN(channel_count) FROM (SELECT COUNT(*) AS channel_count FROM TV_Channel GROUP BY Language) AS subquery);","SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE ORDER BY count(*) ASC LIMIT 1;",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the language and the count of TV channels using that language. Use the FROM clause to specify the TV_Channel table. Apply GROUP BY on the Language column to group channels by their language. Use the HAVING clause to filter for the language(s) used by the least number of channels. 2. Condition Structure: Use the HAVING clause with the COUNT function to filter for the minimum count of channels per language. 3. Join Structure: Not required, as all the necessary data is in the TV_Channel table. 4. Aggregation Structure: Use COUNT to calculate the number of channels per language and MIN to identify the least number of channels used for a language.","[('English', 3)]","[('English', 3)]",,1.0,
List all the student details in reversed lexicographical order.,"[Students.first_name, Students.middle_name, Students.last_name, Students.student_id, Students.current_address_id, Students.permanent_address_id, Students.cell_mobile_number, Students.email_address, Students.ssn, Students.date_first_registered, Students.date_left, Students.other_student_details]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT * FROM Students ORDER BY Students.last_name DESC, Students.middle_name DESC, Students.first_name DESC;",SELECT other_student_details FROM Students ORDER BY other_student_details DESC,student_transcripts_tracking,"1. Sequential Structure: Begin with the SELECT clause to retrieve all columns from the ""Students"" table, as the question asks for all student details. 2. Condition Structure: No specific filtering condition is required since the query is to list all student details. 3. Join Structure: No JOIN is necessary because all required data is within the ""Students"" table. 4. Ordering Structure: Use ORDER BY in descending order on the ""Students.last_name"", ""Students.middle_name"", and ""Students.first_name"" to achieve reversed lexicographical order. 5. Aggregation Structure: No aggregation is needed as the query is simply retrieving and ordering data.","[(13, 9, 8, 'Deon', 'Brooklyn', 'Weimann', '(213)445-0399x85208', 'jhuel@example.com', '68095', '1986-02-24 21:12:23', '2014-05-30 23:32:02', 'assumenda'), (1, 10, 15, 'Timmothy', 'Anna', 'Ward', '(096)889-8954x524', 'erwin.zboncak@example.com', '965', '1971-02-05 07:28:23', '1971-05-17 19:28:49', 'quia'), (11, 14, 4, 'Gregg', 'Mossie', 'Schuppe', '(462)246-7921', 'nbruen@example.org', '494', '1989-05-24 23:31:29', '1975-10-09 00:49:27', 'omnis'), (6, 6, 3, 'Stanford', 'Mona', 'Rogahn', '436.613.7683', 'skassulke@example.net', '248', '1997-03-20 16:47:25', '2016-04-09 12:27:04', 'qui'), (14, 12, 11, 'Jordy', 'Osborne', 'Rempel', '(605)919-3594x3661', 'gracie29@example.com', '34458427', '2004-12-24 12:36:46', '1999-08-24 00:07:10', 'et'), (9, 2, 15, 'Reva', 'Golda', 'Osinski', '(507)365-8405', ""qo'kon@example.com"", '39', '2017-01-04 08:10:25', '1990-09-01 05:03:27', 'nesciunt'), (10, 15, 14, 'Helga', 'Cleve', 'Mohr', '677.401.9382', 'nya.lesch@example.net', '43', '2009-09-25 00:14:25', '2017-07-09 21:38:43', 'rerum'), (12, 14, 9, 'Orrin', 'Neal', 'Kemmer', '(982)153-1469x1733', 'beth42@example.org', '6274274', '2005-12-15 08:42:10', '2006-08-04 17:26:49', 'non'), (15, 2, 9, 'Jett', 'Alberta', 'Jaskolski', '877.549.9067x8723', 'mya88@example.org', '156', '1982-06-19 13:15:18', '1982-06-11 00:25:39', 'omnis'), (7, 15, 3, 'Frida', 'Aisha', 'Huel', '1-879-796-8987x164', 'baumbach.lucious@example.org', '668', '2018-03-13 09:56:22', '1997-11-16 08:54:33', 'dolorum'), (3, 9, 5, 'Warren', 'Violet', 'Gleichner', '07661787471', 'johns.unique@example.net', '3', '2007-08-29 23:25:41', '2007-03-31 09:53:19', 'facilis'), (5, 9, 9, 'Milton', 'Vaughn', 'Christiansen', '171-642-5684', 'lhartmann@example.org', '', '1973-05-19 19:12:46', '2007-11-28 12:50:21', 'laborum'), (4, 7, 11, 'Jarvis', 'Aaliyah', 'Carroll', '09700166582', 'jillian26@example.net', '141072406', '2014-03-28 05:48:23', '2007-08-02 04:12:58', 'atque'), (2, 12, 5, 'Hobart', 'Lorenz', 'Balistreri', '1-009-710-5151', 'swift.kolby@example.com', '304246', '1976-10-26 02:33:06', '2013-10-05 17:41:28', 'autem'), (8, 1, 5, 'Delaney', 'Judd', 'Ankunding', '03174364122', 'dell43@example.net', '402', '1982-02-14 08:46:35', '2004-12-08 05:29:11', 'voluptatem')]","[('voluptatem',), ('rerum',), ('quia',), ('qui',), ('omnis',), ('omnis',), ('non',), ('nesciunt',), ('laborum',), ('facilis',), ('et',), ('dolorum',), ('autem',), ('atque',), ('assumenda',)]",,1.0,
What is the number of cartoones written by Joseph Kuhr?,"[Cartoon.Title, Cartoon.Written_by, Joseph Kuhr]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT COUNT(Cartoon.Title) FROM Cartoon WHERE Cartoon.Written_by = 'Joseph Kuhr';,"SELECT count(*) FROM Cartoon WHERE Written_by = ""Joseph Kuhr"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to count the number of cartoons written by Joseph Kuhr. 2. Condition Structure: Use a WHERE clause to filter rows where ""Cartoon.Written_by"" is equal to 'Joseph Kuhr'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Cartoon"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cartoons written by Joseph Kuhr.","[(2,)]","[(2,)]",,1.0,
What is the series name and country of all TV channels that are playing cartoons directed by Ben Jones and cartoons directed by Michael Chang?,"[TV_Channel.series_name, TV_Channel.Country, Cartoon.Directed_by, Cartoon.Channel, TV_Channel.id = Cartoon.Channel, Ben Jones, Michael Chang]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NESTED,"SELECT TV_Channel.series_name, TV_Channel.Country FROM TV_Channel JOIN Cartoon ON TV_Channel.id = Cartoon.Channel WHERE Cartoon.Directed_by IN ('Ben Jones', 'Michael Chang');","SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Michael Chang' INTERSECT SELECT T1.series_name ,  T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.directed_by  =  'Ben Jones'",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the series name and country of TV channels. Use the FROM clause to specify the TV_Channel and Cartoon tables. Apply a WHERE clause to filter for cartoons directed by either Ben Jones or Michael Chang. 2. Condition Structure: Use the WHERE clause to filter for records where the ""Directed_by"" column in the Cartoon table matches either 'Ben Jones' or 'Michael Chang'. 3. Join Structure: Use an INNER JOIN between the TV_Channel and Cartoon tables based on the ""Channel"" column in the Cartoon table and the ""id"" column in the TV_Channel table to connect TV channels with their respective cartoons. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('Sky Radio', 'Italy'), ('Music Box Italia', 'Italy'), ('MTV Hits', 'Italy'), ('MTV Rocks', 'United Kingdom'), ('MTV Dance', 'United Kingdom'), ('MTV Dance', 'United Kingdom'), ('Classica', 'Italy'), ('MTV Dance', 'United Kingdom')]","[('MTV Dance', 'United Kingdom')]",,1.0,
"What is the first, middle, and last name of the earliest school graduate?","[Students.first_name, Students.middle_name, Students.last_name, Students.date_left]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT Students.first_name, Students.middle_name, Students.last_name FROM Students ORDER BY Students.date_left ASC LIMIT 1;","SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""first_name,"" ""middle_name,"" and ""last_name"" of the earliest school graduate. 2. Condition Structure: No specific filtering condition is required since we are looking for the earliest graduate based on the ""date_left"" field. 3. Join Structure: No JOIN is required as all necessary information is available in the ""Students"" table. 4. Aggregation Structure: Use ORDER BY on ""date_left"" in ascending order to find the earliest graduate and apply LIMIT 1 to retrieve only the first record.","[('Timmothy', 'Anna', 'Ward')]","[('Timmothy', 'Anna', 'Ward')]",,1.0,
What are the first names of the students who live in Haiti permanently or have the cell phone number 09700166582 ?,"[Students.first_name,Students.permanent_address_id = Addresses.address_id,Addresses.country,Haiti,Students.cell_mobile_number,09700166582]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT Students.first_name FROM Students JOIN Addresses ON Students.permanent_address_id = Addresses.address_id WHERE Addresses.country = 'Haiti' OR Students.cell_mobile_number = '09700166582';,select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.first_name."" 2. Condition Structure: Use a WHERE clause to filter students who either have a permanent address in Haiti or have the cell phone number ""09700166582."" 3. Join Structure: Use a JOIN between the ""Students"" table and the ""Addresses"" table on ""Students.permanent_address_id = Addresses.address_id"" to access the country information for the permanent address. 4. Aggregation Structure: No aggregation is needed as we are retrieving individual student first names based on the specified conditions.","[('Hobart',), ('Warren',), ('Jarvis',), ('Delaney',)]","[('Jarvis',)]",,1.0,
How many TV Channel using language English?,"[TV_Channel.Language, TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT COUNT(*) FROM TV_Channel WHERE TV_Channel.Language = 'English';,"SELECT count(*) FROM TV_Channel WHERE LANGUAGE = ""English"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to count the number of TV channels using the English language. 2. Condition Structure: Use a WHERE clause to filter for TV channels where the ""TV_Channel.Language"" is 'English'. 3. Join Structure: No JOIN is required since all necessary information is in the ""TV_Channel"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of TV channels that meet the specified condition.","[(3,)]","[(3,)]",,1.0,
How many transcripts are released?,[Transcripts.transcript_id],"Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT COUNT(Transcripts.transcript_id) AS total_transcripts FROM Transcripts;,SELECT count(*) FROM Transcripts,student_transcripts_tracking,"1. Sequential Structure: Begin with the SELECT clause to count the number of transcripts released, which corresponds to the ""transcript_id"" in the ""Transcripts"" table. 2. Condition Structure: No specific filtering condition is required since the query asks for the total count of transcripts. 3. Join Structure: No JOIN is necessary as all the required data is available in the ""Transcripts"" table. 4. Aggregation Structure: Use the COUNT function to calculate the total number of transcripts.","[(15,)]","[(15,)]",,1.0,
What are the names and ids of every course with less than 2 sections?,"[Courses.course_id, Courses.course_name, Sections.course_id = Courses.course_id, Sections.section_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NESTED,"SELECT Courses.course_id, Courses.course_name FROM Courses JOIN Sections ON Courses.course_id = Sections.course_id GROUP BY Courses.course_id, Courses.course_name HAVING COUNT(Sections.section_id) < 2;","SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the course names and IDs. Use the FROM clause to specify the Courses table and JOIN it with the Sections table to relate courses with their sections. Use GROUP BY to group records by course_id and course_name, and apply a HAVING clause to filter courses with fewer than 2 sections. 2. Condition Structure: Use the HAVING clause with COUNT(section_id) to filter for courses that have less than 2 sections. 3. Join Structure: Use an INNER JOIN between the Courses and Sections tables based on course_id to connect courses with their sections. 4. Aggregation Structure: Use COUNT(section_id) within the HAVING clause to count the number of sections for each course and filter out courses with 2 or more sections.","[(2, 'math'), (4, 'en'), (6, 'la'), (7, 'cal'), (9, 'dl'), (10, 'ml'), (12, 'db')]","[('ds', 1), ('math', 2), ('en', 4), ('fr', 5), ('la', 6), ('cal', 7), ('nlp', 8), ('dl', 9), ('ml', 10), ('db', 12), ('pl', 14)]",,0.0,
"What is the weekly rank for the episode ""A Love of a Lifetime""?","[TV_series.Weekly_Rank,TV_series.Episode]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT TV_series.Weekly_Rank FROM TV_series WHERE TV_series.Episode = 'A Love of a Lifetime';,"SELECT Weekly_Rank FROM TV_series WHERE Episode = ""A Love of a Lifetime"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""TV_series.Weekly_Rank"" for the specified episode. 2. Condition Structure: Use a WHERE clause to filter for the episode titled ""A Love of a Lifetime."" 3. Join Structure: No JOIN is required since all necessary information is in the ""TV_series"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[(43.0,)]","[(43.0,)]",,1.0,
Which semesters do not have any student enrolled? List the semester name.,"[Semesters.semester_name,Semesters.semester_id,Student_Enrolment.semester_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NESTED,SELECT semester_name FROM Semesters WHERE semester_id NOT IN (SELECT semester_id FROM Student_Enrolment);,SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment ),student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the semester names. Use the FROM clause to specify the Semesters table. Apply a WHERE clause to filter semesters that do not have any student enrolled by ensuring that the semester_id is not present in the Student_Enrolment table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude semesters whose semester_id appears in the Student_Enrolment table, meaning they have students enrolled. 3. Join Structure: Not required, as we only need to filter based on the absence of matching semester_id entries in the Student_Enrolment table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('fall 2010',), ('spring 2013',), ('spring 2014',), ('spring 2016',), ('spring 2017',), ('winter 2018',)]","[('fall 2010',), ('spring 2013',), ('spring 2014',), ('spring 2016',), ('spring 2017',), ('winter 2018',)]",,1.0,
Whose permanent address is different from his or her current address? List his or her first name.,"[Students.first_name, Students.permanent_address_id, Students.current_address_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Students.first_name FROM Students WHERE Students.permanent_address_id != Students.current_address_id;,SELECT first_name FROM Students WHERE current_address_id != permanent_address_id,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.first_name"" of students whose permanent address is different from their current address. 2. Condition Structure: Use a WHERE clause to filter students where ""Students.permanent_address_id"" is not equal to ""Students.current_address_id"". 3. Join Structure: No JOIN is required since all necessary information is available in the ""Students"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the first names of students based on a specific condition.","[('Timmothy',), ('Hobart',), ('Warren',), ('Jarvis',), ('Stanford',), ('Frida',), ('Delaney',), ('Reva',), ('Helga',), ('Gregg',), ('Orrin',), ('Deon',), ('Jordy',), ('Jett',)]","[('Timmothy',), ('Hobart',), ('Warren',), ('Jarvis',), ('Stanford',), ('Frida',), ('Delaney',), ('Reva',), ('Helga',), ('Gregg',), ('Orrin',), ('Deon',), ('Jordy',), ('Jett',)]",,1.0,
What are the names and id of courses having at most 2 sections?,"[Courses.course_id, Courses.course_name, Sections.course_id = Courses.course_id, Sections.section_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Courses.course_id, Courses.course_name FROM Courses JOIN Sections ON Sections.course_id = Courses.course_id GROUP BY Courses.course_id, Courses.course_name HAVING COUNT(Sections.section_id) <= 2;","SELECT T1.course_name ,  T1.course_id FROM Courses AS T1 JOIN Sections AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_id HAVING count(*)  <=  2",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Courses.course_id"" and ""Courses.course_name."" 2. Condition Structure: Use a HAVING clause to filter courses that have at most 2 sections. This requires counting the number of sections for each course. 3. Join Structure: Use a JOIN between the ""Courses"" and ""Sections"" tables based on ""Sections.course_id = Courses.course_id"" to associate each course with its sections. 4. Aggregation Structure: Use COUNT on ""Sections.section_id"" to count the number of sections for each course, then filter with HAVING to select courses with at most 2 sections.","[(1, 'ds'), (2, 'math'), (4, 'en'), (5, 'fr'), (6, 'la'), (7, 'cal'), (8, 'nlp'), (9, 'dl'), (10, 'ml'), (12, 'db'), (14, 'pl')]","[('ds', 1), ('math', 2), ('en', 4), ('fr', 5), ('la', 6), ('cal', 7), ('nlp', 8), ('dl', 9), ('ml', 10), ('db', 12), ('pl', 14)]",,1.0,
What's the name of the course with most number of enrollments?,"[Courses.course_name, Student_Enrolment_Courses.course_id, Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT Courses.course_name FROM Courses JOIN Student_Enrolment_Courses ON Courses.course_id = Student_Enrolment_Courses.course_id GROUP BY Courses.course_id ORDER BY COUNT(Student_Enrolment_Courses.student_enrolment_id) DESC LIMIT 1;,SELECT  T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id GROUP BY T1.course_name ORDER BY count(*) DESC LIMIT 1,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Courses.course_name"" since we need the name of the course. Use COUNT to count the number of enrollments for each course. Use ORDER BY in descending order to rank courses by the number of enrollments and LIMIT 1 to get the course with the most enrollments. 2. Condition Structure: No specific filtering condition is required as we are considering all courses. 3. Join Structure: Use a JOIN between ""Courses"" and ""Student_Enrolment_Courses"" on ""Courses.course_id = Student_Enrolment_Courses.course_id"" to link courses with their enrollments. 4. Aggregation Structure: Use COUNT on ""Student_Enrolment_Courses.student_enrolment_id"" to count the number of enrollments for each course, then group by ""Courses.course_id"" to aggregate the data by course.","[('pl',)]","[('rs',)]",,0.0,
What is the department description for the one whose name has the word computer?,"[Departments.department_description, Departments.department_name]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Departments.department_description FROM Departments WHERE Departments.department_name LIKE '%computer%';,SELECT department_description FROM Departments WHERE department_name LIKE '%computer%',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Departments.department_description"" for the department whose name contains the word ""computer"". 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for department names that contain the word ""computer"". 3. Join Structure: No JOIN is required since all relevant information is in the ""Departments"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('error',)]","[('error',)]",,1.0,
List top 3 highest Rating  TV series. List the TV series's Episode and Rating.,"[TV_series.Episode, TV_series.Rating]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT TV_series.Episode, TV_series.Rating FROM TV_series ORDER BY TV_series.Rating DESC LIMIT 3;","SELECT Episode ,  Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;",tvshow,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the ""TV_series.Episode"" and ""TV_series.Rating"". 2. Condition Structure: No specific filtering condition is required as we are looking for the top 3 highest-rated TV series. 3. Ordering Structure: Use ORDER BY in descending order on ""TV_series.Rating"" to rank the TV series by their ratings. 4. Limiting Structure: Use LIMIT 3 to retrieve only the top 3 highest-rated TV series. 5. Join Structure: No JOIN is required since all necessary data is within the ""TV_series"" table. 6. Aggregation Structure: No aggregation is needed as we are directly retrieving the top 3 records based on the rating.","[('A Love of a Lifetime', '5.8'), ('Friendly Skies', '5.3'), ('Game Three', '4.4')]","[('A Love of a Lifetime', '5.8'), ('Friendly Skies', '5.3'), ('Game Three', '4.4')]",,1.0,
How many TV Channels use the English language?,"[TV_Channel.Country, TV_Channel.Language]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT COUNT(*) FROM TV_Channel WHERE TV_Channel.Language = 'English';,"SELECT count(*) FROM TV_Channel WHERE LANGUAGE = ""English"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to count the number of TV channels that use the English language. 2. Condition Structure: Use a WHERE clause to filter TV channels where the ""TV_Channel.Language"" is 'English'. 3. Join Structure: No JOIN is required since all necessary information is in the ""TV_Channel"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of TV channels that meet the specified condition.","[(3,)]","[(3,)]",,1.0,
What are the package options and the name of the series for the TV Channel that supports high definition TV?,"[TV_Channel.Package_Option, TV_Channel.series_name, TV_Channel.Hight_definition_TV, TV_series.Channel = TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,"SELECT TV_Channel.Package_Option, TV_Channel.series_name FROM TV_Channel WHERE TV_Channel.Hight_definition_TV = 1;","SELECT package_option ,  series_name FROM TV_Channel WHERE hight_definition_TV  =  ""yes""",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve ""TV_Channel.Package_Option"" and ""TV_Channel.series_name."" 2. Condition Structure: Use a WHERE clause to filter for TV Channels that support high definition TV, i.e., where ""TV_Channel.Hight_definition_TV"" is true. 3. Join Structure: No JOIN is required since the required information is available within the ""TV_Channel"" table. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without any summarization.",[],"[('Sky Famiglia + Sky HD', 'MTV Live HD')]",,0.0,
What are the names of all courses that have some students enrolled?,"[Courses.course_name, Student_Enrolment_Courses.course_id, Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT DISTINCT Courses.course_name FROM Courses JOIN Student_Enrolment_Courses ON Courses.course_id = Student_Enrolment_Courses.course_id WHERE Student_Enrolment_Courses.student_enrolment_id IS NOT NULL;,SELECT DISTINCT T1.course_name FROM Courses AS T1 JOIN Student_Enrolment_Courses AS T2 ON T1.course_id  =  T2.course_id,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""Courses.course_name"" since we are interested in the names of courses with enrolled students. 2. Condition Structure: No specific filtering condition is required, as we are looking for all courses with any student enrollment. 3. Join Structure: Use a JOIN between ""Courses"" and ""Student_Enrolment_Courses"" on ""Courses.course_id = Student_Enrolment_Courses.course_id"" to link courses with their enrollments. Additionally, ensure that ""Student_Enrolment_Courses.student_enrolment_id"" is not null to confirm that students are enrolled. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique course names are returned.","[('la',), ('pl',), ('ai',), ('math',), ('ml',), ('os',), ('en',), ('nlp',), ('rs',), ('db',)]","[('la',), ('pl',), ('ai',), ('math',), ('ml',), ('os',), ('en',), ('nlp',), ('rs',), ('db',)]",,1.0,
"What is the Package Option of TV Channel with serial name ""Sky Radio""?","[TV_Channel.Package_Option,TV_Channel.series_name]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT TV_Channel.Package_Option FROM TV_Channel WHERE TV_Channel.series_name = 'Sky Radio';,"SELECT Package_Option FROM TV_Channel WHERE series_name = ""Sky Radio"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Package_Option"" of the TV Channel. 2. Condition Structure: Use a WHERE clause to filter for the TV Channel where the ""series_name"" is ""Sky Radio"". 3. Join Structure: No JOIN is required since all necessary information is in the ""TV_Channel"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('Sky Famiglia',)]","[('Sky Famiglia',)]",,1.0,
How many different degrees are offered?,[Degree_Programs.degree_summary_name],"Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT COUNT(DISTINCT Degree_Programs.degree_summary_name) AS number_of_degrees FROM Degree_Programs;,SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to count the distinct degree names, as the question asks for the number of different degrees offered. 2. Condition Structure: No specific filtering condition is required since we are counting all distinct degrees. 3. Join Structure: No JOIN is necessary because all the required data is available in the ""Degree_Programs"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Degree_Programs.degree_summary_name"" to count the unique degree names.","[(3,)]","[(3,)]",,1.0,
What is the degree summary name that has the most number of students enrolled?,"[Degree_Programs.degree_summary_name,Student_Enrolment.degree_program_id,Student_Enrolment.student_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT Degree_Programs.degree_summary_name FROM Degree_Programs JOIN Student_Enrolment ON Degree_Programs.degree_program_id = Student_Enrolment.degree_program_id GROUP BY Degree_Programs.degree_summary_name ORDER BY COUNT(Student_Enrolment.student_id) DESC LIMIT 1;,SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""degree_summary_name"" from the ""Degree_Programs"" table. Use COUNT to count the number of students enrolled in each degree program. 2. Condition Structure: No specific filtering condition is required, as we are interested in finding the degree program with the most students enrolled. 3. Join Structure: Use an INNER JOIN between ""Degree_Programs"" and ""Student_Enrolment"" on ""degree_program_id"" to link each degree program with its student enrollments. 4. Aggregation Structure: Use COUNT to count the number of students for each degree program, GROUP BY ""degree_summary_name"" to group results by degree program, and ORDER BY the count in descending order to rank the programs by the number of students. Use LIMIT 1 to select the program with the most students.","[('Bachelor',)]","[('Bachelor',)]",,1.0,
"Which student has enrolled for the most times in any program? List the id, first name, middle name, last name, the number of enrollments and student id.","[Students.student_id,Students.first_name,Students.middle_name,Students.last_name,Student_Enrolment.student_id,COUNT(Student_Enrolment.student_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Students.student_id, Students.first_name, Students.middle_name, Students.last_name, COUNT(Student_Enrolment.student_id) AS number_of_enrollments FROM Students JOIN Student_Enrolment ON Students.student_id = Student_Enrolment.student_id GROUP BY Students.student_id ORDER BY number_of_enrollments DESC LIMIT 1;","SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Students.student_id,"" ""Students.first_name,"" ""Students.middle_name,"" ""Students.last_name,"" and the count of enrollments. Use COUNT to calculate the number of enrollments for each student. 2. Condition Structure: No specific filtering condition is required as we are interested in all students. 3. Join Structure: Use an INNER JOIN between the ""Students"" table and the ""Student_Enrolment"" table on ""Students.student_id = Student_Enrolment.student_id"" to link students with their enrollment records. 4. Aggregation Structure: Use GROUP BY on ""Students.student_id"" to group the results by each student. Use ORDER BY in descending order on the count of enrollments to rank students by the number of enrollments. Use LIMIT 1 to get the student with the most enrollments.","[(7, 'Frida', 'Aisha', 'Huel', 3)]","[(7, 'Frida', 'Aisha', 'Huel', 3, 7)]",,1.0,
find id of the tv channels that from the countries where have more than two tv channels.,"[TV_Channel.id, TV_Channel.Country, TV_series.Channel = TV_Channel.id, Cartoon.Channel = TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NESTED,SELECT id FROM TV_Channel GROUP BY Country HAVING COUNT(*) > 2;,SELECT id FROM tv_channel GROUP BY country HAVING count(*)  >  2,tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of TV channels. Use the FROM clause to specify the TV_Channel table. Apply a GROUP BY clause to group records by country and a HAVING clause to filter countries with more than two TV channels. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter for countries that have more than two TV channels. 3. Join Structure: Not required, as all necessary data is in the TV_Channel table. 4. Aggregation Structure: Use COUNT(*) to count the number of TV channels per country and filter based on this count.","[('700',)]","[('700',)]",,1.0,
What is the average transcript date?,[Transcripts.transcript_date],"Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT AVG(transcript_date) AS average_transcript_date FROM Transcripts;,SELECT avg(transcript_date) FROM Transcripts,student_transcripts_tracking,"1. Sequential Structure: Begin with the SELECT clause to calculate the average of the ""transcript_date"" field. 2. Aggregation Structure: Use the AVG function to compute the average transcript date. 3. Condition Structure: No specific filtering condition is required as the query asks for the average of all transcript dates. 4. Join Structure: No JOIN is required since all necessary data is within the ""Transcripts"" table.","[(1989.9333333333334,)]","[(1989.9333333333334,)]",,1.0,
What is the pixel aspect ratio and country of origin for all TV channels that do not use English?,"[TV_Channel.Pixel_aspect_ratio_PAR, TV_Channel.Country, TV_Channel.Language]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NESTED,"SELECT Pixel_aspect_ratio_PAR, Country FROM TV_Channel WHERE Language != 'English';","SELECT Pixel_aspect_ratio_PAR ,  country FROM tv_channel WHERE LANGUAGE != 'English'",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the pixel aspect ratio and country of origin. Use the FROM clause to specify the TV_Channel table. Apply a WHERE clause to filter for TV channels that do not use English as their language. 2. Condition Structure: Use the WHERE clause to filter records where the language is not 'English'. 3. Join Structure: Not required, as all the necessary data is available in the TV_Channel table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.","[('4:3', 'Italy'), ('4:3', 'Italy'), ('4:3 / 16:9', 'Italy'), ('16:9', 'Italy'), ('4:3', 'Italy'), ('16:9', 'Italy'), ('4:3', 'Italy'), ('16:9', 'Italy'), ('4:3 / 16:9', 'Italy'), ('4:3 / 16:9', 'Italy'), ('4:3', 'Italy'), ('4:3', 'Italy')]","[('4:3', 'Italy'), ('4:3', 'Italy'), ('4:3 / 16:9', 'Italy'), ('16:9', 'Italy'), ('4:3', 'Italy'), ('16:9', 'Italy'), ('4:3', 'Italy'), ('16:9', 'Italy'), ('4:3 / 16:9', 'Italy'), ('4:3 / 16:9', 'Italy'), ('4:3', 'Italy'), ('4:3', 'Italy')]",,1.0,
When was the last transcript released?,[Transcripts.transcript_date],"Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT MAX(Transcripts.transcript_date) AS last_transcript_date FROM Transcripts;,SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""transcript_date"" of the last transcript released. 2. Condition Structure: No specific filtering condition is required since we are looking for the most recent transcript date. 3. Join Structure: No JOIN is necessary as the required information is available in the ""Transcripts"" table. 4. Aggregation Structure: Use the MAX function to find the latest transcript date.","[('2013-06-30 13:01:40',)]","[('2013-06-30 13:01:40',)]",,1.0,
"For each language, list the number of TV Channels that use it.","[TV_Channel.Language, TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT TV_Channel.Language, COUNT(TV_Channel.id) AS channel_count FROM TV_Channel GROUP BY TV_Channel.Language;","SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE",tvshow,"1. Sequential Structure: Start with the SELECT clause to specify the language and the count of TV channels using that language. 2. Aggregation Structure: Use COUNT to calculate the number of TV channels for each language. 3. Grouping Structure: Use GROUP BY on ""TV_Channel.Language"" to group the results by language. 4. Join Structure: No JOIN is required since all necessary data is within the ""TV_Channel"" table. 5. Condition Structure: No specific filtering condition is required as we want the count for all languages.","[('English', 3), ('Italian', 12)]","[('English', 3), ('Italian', 12)]",,1.0,
What are 3 most highly rated episodes in the TV series table and what were those ratings?,"[TV_series.Episode, TV_series.Rating]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT TV_series.Episode, TV_series.Rating FROM TV_series ORDER BY TV_series.Rating DESC LIMIT 3;","SELECT Episode ,  Rating FROM TV_series ORDER BY Rating DESC LIMIT 3;",tvshow,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the episode name and its rating. 2. Condition Structure: No specific filtering condition is required as we want the top 3 episodes based on their ratings. 3. Join Structure: No JOIN is required since all necessary data is within the ""TV_series"" table. 4. Aggregation Structure: Use ORDER BY in descending order on the ""TV_series.Rating"" to rank episodes by their ratings. Use LIMIT 3 to retrieve only the top 3 episodes.","[('A Love of a Lifetime', '5.8'), ('Friendly Skies', '5.3'), ('Game Three', '4.4')]","[('A Love of a Lifetime', '5.8'), ('Friendly Skies', '5.3'), ('Game Three', '4.4')]",,1.0,
What other details can you tell me about students in reverse alphabetical order?,"[Students.first_name, Students.middle_name, Students.last_name, Students.other_student_details]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT Students.first_name, Students.middle_name, Students.last_name, Students.other_student_details FROM Students ORDER BY Students.last_name DESC;",SELECT other_student_details FROM Students ORDER BY other_student_details DESC,student_transcripts_tracking,"1. Sequential Structure: Begin with the SELECT clause to retrieve the fields ""Students.first_name,"" ""Students.middle_name,"" ""Students.last_name,"" and ""Students.other_student_details."" 2. Condition Structure: No specific filtering condition is required as the query asks for details about all students. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Students"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves and orders the data. 5. Ordering Structure: Use ORDER BY on ""Students.last_name"" in descending order to sort the results in reverse alphabetical order.","[('Deon', 'Brooklyn', 'Weimann', 'assumenda'), ('Timmothy', 'Anna', 'Ward', 'quia'), ('Gregg', 'Mossie', 'Schuppe', 'omnis'), ('Stanford', 'Mona', 'Rogahn', 'qui'), ('Jordy', 'Osborne', 'Rempel', 'et'), ('Reva', 'Golda', 'Osinski', 'nesciunt'), ('Helga', 'Cleve', 'Mohr', 'rerum'), ('Orrin', 'Neal', 'Kemmer', 'non'), ('Jett', 'Alberta', 'Jaskolski', 'omnis'), ('Frida', 'Aisha', 'Huel', 'dolorum'), ('Warren', 'Violet', 'Gleichner', 'facilis'), ('Milton', 'Vaughn', 'Christiansen', 'laborum'), ('Jarvis', 'Aaliyah', 'Carroll', 'atque'), ('Hobart', 'Lorenz', 'Balistreri', 'autem'), ('Delaney', 'Judd', 'Ankunding', 'voluptatem')]","[('voluptatem',), ('rerum',), ('quia',), ('qui',), ('omnis',), ('omnis',), ('non',), ('nesciunt',), ('laborum',), ('facilis',), ('et',), ('dolorum',), ('autem',), ('atque',), ('assumenda',)]",,1.0,
"Who is the earliest graduate of the school? List the first name, middle name and last name.","[Students.first_name, Students.middle_name, Students.last_name, Students.date_left]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT Students.first_name, Students.middle_name, Students.last_name FROM Students ORDER BY Students.date_left ASC LIMIT 1;","SELECT first_name ,  middle_name ,  last_name FROM Students ORDER BY date_left ASC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""first_name,"" ""middle_name,"" and ""last_name"" of the earliest graduate. Use the ""date_left"" column to determine the earliest graduate. 2. Condition Structure: No specific filtering condition is required since we are looking for the earliest graduate based on the ""date_left"" column. 3. Join Structure: No JOIN is required as all necessary information is available in the ""Students"" table. 4. Aggregation Structure: Use ORDER BY on ""date_left"" in ascending order to find the earliest graduate. Apply LIMIT 1 to select only the first record.","[('Timmothy', 'Anna', 'Ward')]","[('Timmothy', 'Anna', 'Ward')]",,1.0,
How many different series and contents are listed in the TV Channel table?,"[TV_Channel.series_name, TV_Channel.Content]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT COUNT(DISTINCT TV_Channel.series_name) AS distinct_series_count, COUNT(DISTINCT TV_Channel.Content) AS distinct_content_count FROM TV_Channel;","SELECT count(DISTINCT series_name) ,  count(DISTINCT content) FROM TV_Channel;",tvshow,"1. Sequential Structure: Start with the SELECT clause to count the distinct series names and contents in the ""TV_Channel"" table. 2. Condition Structure: No specific filtering condition is required as we want to count all distinct series names and contents. 3. Join Structure: No JOIN is necessary since all required data is within the ""TV_Channel"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique series names and contents.","[(15, 1)]","[(15, 1)]",,1.0,
What is the first name of the student whose permanent address is different from his or her current one?,"[Students.first_name, Students.permanent_address_id, Students.current_address_id, Students.permanent_address_id != Students.current_address_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Students.first_name FROM Students WHERE Students.permanent_address_id != Students.current_address_id;,SELECT first_name FROM Students WHERE current_address_id != permanent_address_id,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.first_name"" of students whose permanent address is different from their current address. 2. Condition Structure: Use a WHERE clause to filter students where ""Students.permanent_address_id"" is not equal to ""Students.current_address_id"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Students"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the first names of students based on a specific condition.","[('Timmothy',), ('Hobart',), ('Warren',), ('Jarvis',), ('Stanford',), ('Frida',), ('Delaney',), ('Reva',), ('Helga',), ('Gregg',), ('Orrin',), ('Deon',), ('Jordy',), ('Jett',)]","[('Timmothy',), ('Hobart',), ('Warren',), ('Jarvis',), ('Stanford',), ('Frida',), ('Delaney',), ('Reva',), ('Helga',), ('Gregg',), ('Orrin',), ('Deon',), ('Jordy',), ('Jett',)]",,1.0,
"What are the first, middle, and last names for everybody enrolled in a Bachelors program?","[Students.first_name, Students.middle_name, Students.last_name, Student_Enrolment.student_id = Students.student_id, Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name, Bachelors]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Students.first_name, Students.middle_name, Students.last_name FROM Students JOIN Student_Enrolment ON Student_Enrolment.student_id = Students.student_id JOIN Degree_Programs ON Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id WHERE Degree_Programs.degree_summary_name = 'Bachelors';","SELECT DISTINCT T1.first_name ,  T1.middle_name ,  T1.last_name FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id JOIN Degree_Programs AS T3 ON T2.degree_program_id  =  T3.degree_program_id WHERE T3.degree_summary_name  =  'Bachelor'",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Students.first_name,"" ""Students.middle_name,"" and ""Students.last_name."" 2. Condition Structure: Use a WHERE clause to filter for students enrolled in a degree program where ""Degree_Programs.degree_summary_name"" is ""Bachelors."" 3. Join Structure: Use JOINs to connect ""Students"" with ""Student_Enrolment"" on ""Student_Enrolment.student_id = Students.student_id"" and ""Student_Enrolment"" with ""Degree_Programs"" on ""Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id."" 4. Aggregation Structure: No aggregation is needed as the query only retrieves individual student names.",[],"[('Reva', 'Golda', 'Osinski'), ('Frida', 'Aisha', 'Huel'), ('Jarvis', 'Aaliyah', 'Carroll'), ('Milton', 'Vaughn', 'Christiansen'), ('Stanford', 'Mona', 'Rogahn')]",,0.0,
List the language used least number of TV Channel. List language and number of TV Channel.,"[TV_Channel.Language, TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NESTED,"SELECT Language, COUNT(id) AS num_channels FROM TV_Channel GROUP BY Language ORDER BY num_channels ASC LIMIT 1;","SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE ORDER BY count(*) ASC LIMIT 1;",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the language and the count of TV channels for each language. Use the FROM clause to specify the TV_Channel table. Apply GROUP BY on the language column to group the data by language. Use ORDER BY to sort the results by the count of TV channels in ascending order and LIMIT to get the language with the least number of TV channels. 2. Condition Structure: No specific WHERE clause is needed as we are analyzing all languages. 3. Join Structure: Not required, as all the necessary data is in the TV_Channel table. 4. Aggregation Structure: Use COUNT to calculate the number of TV channels for each language.","[('English', 3)]","[('English', 3)]",,1.0,
What are the names and descriptions for all the sections?,"[Sections.section_name, Sections.section_description]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT Sections.section_name, Sections.section_description FROM Sections;","SELECT section_name ,  section_description FROM Sections",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""section_name"" and ""section_description"" fields from the ""Sections"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for all sections. 3. Join Structure: No JOIN is necessary since all the required data is available within the ""Sections"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the names and descriptions of all sections.","[('a', 'non'), ('b', 'voluptatem'), ('c', 'qui'), ('d', 'voluptas'), ('e', 'ex'), ('f', 'doloremque'), ('g', 'provident'), ('h', 'et'), ('j', 'quis'), ('k', 'nesciunt'), ('l', 'ad'), ('o', 'et'), ('p', 'facilis'), ('u', 'reprehenderit'), ('y', 'qui')]","[('a', 'non'), ('b', 'voluptatem'), ('c', 'qui'), ('d', 'voluptas'), ('e', 'ex'), ('f', 'doloremque'), ('g', 'provident'), ('h', 'et'), ('j', 'quis'), ('k', 'nesciunt'), ('l', 'ad'), ('o', 'et'), ('p', 'facilis'), ('u', 'reprehenderit'), ('y', 'qui')]",,1.0,
What are the ids of all tv channels that have more than 2 TV channels?,"[TV_Channel.id, TV_series.Channel, TV_series.Channel = TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,SELECT TV_Channel.id FROM TV_Channel JOIN TV_series ON TV_series.Channel = TV_Channel.id GROUP BY TV_Channel.id HAVING COUNT(TV_series.Channel) > 2;,SELECT id FROM tv_channel GROUP BY country HAVING count(*)  >  2,tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""TV_Channel.id"" field. Since the question asks for channels with more than 2 TV series, we will use a GROUP BY clause on ""TV_Channel.id"" and a HAVING clause to filter groups with more than 2 TV series. 2. Condition Structure: Use a HAVING clause to filter for channels that have more than 2 TV series. 3. Join Structure: Use an INNER JOIN between ""TV_Channel"" and ""TV_series"" on the ""TV_series.Channel"" and ""TV_Channel.id"" fields to link TV series with their respective channels. 4. Aggregation Structure: Use COUNT on ""TV_series.Channel"" to count the number of TV series associated with each channel, and filter using HAVING to include only those with more than 2 TV series.",[],"[('700',)]",,0.0,
What is the mobile phone number of the student named Timmothy Ward ?,"[Students.cell_mobile_number, Students.first_name, Students.last_name]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Students.cell_mobile_number FROM Students WHERE Students.first_name = 'Timmothy' AND Students.last_name = 'Ward';,select cell_mobile_number from students where first_name  =  'timmothy' and last_name  =  'ward',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.cell_mobile_number"" of the student named ""Timmothy Ward"". 2. Condition Structure: Use a WHERE clause to filter for students whose ""Students.first_name"" is 'Timmothy' and ""Students.last_name"" is 'Ward'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Students"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on specific conditions.","[('(096)889-8954x524',)]",[],,1.0,
How many departments offer any degree?,"[Departments.department_id,Departments.department_name,Degree_Programs.department_id = Departments.department_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT COUNT(DISTINCT Departments.department_id) FROM Departments JOIN Degree_Programs ON Degree_Programs.department_id = Departments.department_id;,SELECT count(DISTINCT department_id) FROM Degree_Programs,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to count the number of unique departments offering degrees. Use COUNT with DISTINCT on ""Departments.department_id"" to ensure each department is counted only once. 2. Condition Structure: No specific filtering condition is required since we are interested in all departments offering any degree. 3. Join Structure: Use an INNER JOIN between the ""Departments"" and ""Degree_Programs"" tables on ""Departments.department_id"" and ""Degree_Programs.department_id"" to link departments with their degree programs. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique departments offering degrees.","[(10,)]","[(10,)]",,1.0,
Find the production code and channel of the most recently aired cartoon .,"[Cartoon.Production_code, Cartoon.Original_air_date, Cartoon.Channel, Cartoon.Channel = TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,"SELECT Cartoon.Production_code, Cartoon.Channel FROM Cartoon ORDER BY Cartoon.Original_air_date DESC LIMIT 1;","select production_code ,  channel from cartoon order by original_air_date desc limit 1",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Cartoon.Production_code"" and ""Cartoon.Channel."" To find the most recently aired cartoon, use ORDER BY on ""Cartoon.Original_air_date"" in descending order and LIMIT 1 to get the latest record. 2. Condition Structure: No specific filtering condition is required since we are only interested in the most recent cartoon. 3. Join Structure: No JOIN is necessary because all the required information is available in the ""Cartoon"" table. 4. Aggregation Structure: No aggregation is needed as we are only retrieving the most recent record.","[(102.0, '701')]","[(102.0, '701')]",,1.0,
"For each semester, what is the name and id of the one with the most students registered?","[Semesters.semester_id, Semesters.semester_name, Student_Enrolment.semester_id = Semesters.semester_id, Student_Enrolment.student_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NESTED,"SELECT Semesters.semester_id, Semesters.semester_name FROM Semesters JOIN Student_Enrolment ON Semesters.semester_id = Student_Enrolment.semester_id GROUP BY Semesters.semester_id, Semesters.semester_name ORDER BY COUNT(Student_Enrolment.student_id) DESC LIMIT 1;","SELECT T1.semester_name ,  T1.semester_id FROM Semesters AS T1 JOIN Student_Enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T1.semester_id ORDER BY count(*) DESC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the semester name and ID. Use the FROM clause to specify the Semesters table and JOIN it with the Student_Enrolment table to link semesters with student registrations. Use GROUP BY to group records by semester ID and name, and COUNT to calculate the number of students registered in each semester. Use ORDER BY to sort the results by the count of students in descending order and LIMIT 1 to get the semester with the most students registered. 2. Condition Structure: No specific filtering condition is required, as we are interested in all semesters and their student counts. 3. Join Structure: Use an INNER JOIN between the Semesters and Student_Enrolment tables based on semester_id to connect semesters with their student registrations. 4. Aggregation Structure: Use COUNT to calculate the number of students registered in each semester and use it to determine the semester with the highest count.","[(2, 'summer 2010')]","[('summer 2010', 2)]",,1.0,
List the title of all cartoons in alphabetical order.,[Cartoon.Title],"Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT Cartoon.Title FROM Cartoon ORDER BY Cartoon.Title ASC;,SELECT Title FROM Cartoon ORDER BY title,tvshow,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""Cartoon.Title"". 2. Condition Structure: No specific filtering condition is required as we want all cartoon titles. 3. Join Structure: No JOIN is required since all necessary information is in the ""Cartoon"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the cartoon titles in alphabetical order.","[('Dawn of the Dead Man!',), ('Day of the Dark Knight!',), ('Deep Cover for Batman!',), ('Enter the Outsiders!',), ('Evil Under the Sea!',), ('Fall of the Blue Beetle!',), ('Invasion of the Secret Santas!',), ('Journey to the Center of the Bat!',), ('Return of the Fearsome Fangs!',), ('Terror on Dinosaur Island!',), ('The Eyes of Despero!',), ('The Rise of the Blue Beetle!',)]","[('Dawn of the Dead Man!',), ('Day of the Dark Knight!',), ('Deep Cover for Batman!',), ('Enter the Outsiders!',), ('Evil Under the Sea!',), ('Fall of the Blue Beetle!',), ('Invasion of the Secret Santas!',), ('Journey to the Center of the Bat!',), ('Return of the Fearsome Fangs!',), ('Terror on Dinosaur Island!',), ('The Eyes of Despero!',), ('The Rise of the Blue Beetle!',)]",,1.0,
What are the last name of the students who live in North Carolina but have not registered in any degree programs?,"[Students.last_name,Addresses.state_province_county,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,North Carolina]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NESTED,SELECT DISTINCT Students.last_name FROM Students JOIN Addresses ON Students.permanent_address_id = Addresses.address_id OR Students.current_address_id = Addresses.address_id WHERE Addresses.state_province_county = 'North Carolina' AND NOT EXISTS ( SELECT 1 FROM Student_Enrolment WHERE Student_Enrolment.student_id = Students.student_id );,SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the last names of students. Use the FROM clause to specify the Students table and JOIN it with the Addresses table to filter students based on their state of residence. Use a WHERE clause to filter for students living in North Carolina. Additionally, use a NOT EXISTS clause to exclude students who are registered in any degree programs. 2. Condition Structure: Use the WHERE clause to filter for students whose permanent or current address is in North Carolina. Use a NOT EXISTS clause to ensure that the student_id does not appear in the Student_Enrolment table, indicating they are not registered in any degree programs. 3. Join Structure: Use INNER JOINs between the Students table and the Addresses table on the permanent_address_id and current_address_id to connect students with their address details. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",[],"[('Gleichner',), ('Weimann',)]",,0.0,
which countries' tv channels are playing some cartoon written by Todd Casey?,"[TV_Channel.Country, Cartoon.Title, Cartoon.Written_by, Cartoon.Channel = TV_Channel.id, Todd Casey]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,SELECT DISTINCT TV_Channel.Country FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE Cartoon.Written_by = 'Todd Casey';,SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey',tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""TV_Channel.Country"" since the question asks for the countries of TV channels. 2. Condition Structure: Use a WHERE clause to filter for cartoons written by ""Todd Casey."" 3. Join Structure: Use a JOIN between the ""Cartoon"" table and the ""TV_Channel"" table based on the foreign key ""Cartoon.Channel = TV_Channel.id"" to link cartoons with their respective TV channels. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique countries are returned.","[('United Kingdom',), ('Italy',)]","[('United Kingdom',), ('Italy',)]",,1.0,
"What is Weekly Rank of TV series with Episode ""A Love of a Lifetime""?","[TV_series.Weekly_Rank, TV_series.Episode]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT TV_series.Weekly_Rank FROM TV_series WHERE TV_series.Episode = 'A Love of a Lifetime';,"SELECT Weekly_Rank FROM TV_series WHERE Episode = ""A Love of a Lifetime"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Weekly_Rank"" of the TV series. 2. Condition Structure: Use a WHERE clause to filter for the TV series with the episode title ""A Love of a Lifetime"". 3. Join Structure: No JOIN is required since all necessary information is in the ""TV_series"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[(43.0,)]","[(43.0,)]",,1.0,
Which country has the most of TV Channels? List the country and number of TV Channels it has.,"[TV_Channel.Country, TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT TV_Channel.Country, COUNT(*) AS channel_count FROM TV_Channel GROUP BY TV_Channel.Country ORDER BY COUNT(*) DESC LIMIT 1;","SELECT Country ,  count(*) FROM TV_Channel GROUP BY Country ORDER BY count(*) DESC LIMIT 1;",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the country and the count of TV channels for each country. 2. Aggregation Structure: Use COUNT to calculate the number of TV channels for each country. 3. Grouping Structure: Use GROUP BY on ""TV_Channel.Country"" to aggregate the results by country. 4. Ordering Structure: Use ORDER BY in descending order on the count of TV channels to rank countries by the number of TV channels they have. 5. Limiting Structure: Use LIMIT 1 to retrieve the country with the most TV channels. 6. Join Structure: No JOIN is required since all necessary data is within the ""TV_Channel"" table.","[('Italy', 12)]","[('Italy', 12)]",,1.0,
List each language and the number of TV Channels using it.,"[TV_Channel.Language, TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT TV_Channel.Language, COUNT(TV_Channel.id) AS channel_count FROM TV_Channel GROUP BY TV_Channel.Language;","SELECT LANGUAGE ,  count(*) FROM TV_Channel GROUP BY LANGUAGE",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the language and the count of TV channels using that language. 2. Aggregation Structure: Use COUNT to calculate the number of TV channels for each language. 3. Grouping Structure: Use GROUP BY on ""TV_Channel.Language"" to group the results by each language. 4. Join Structure: No JOIN is required since all necessary data is within the ""TV_Channel"" table. 5. Condition Structure: No specific filtering condition is required as we want the count for all languages.","[('English', 3), ('Italian', 12)]","[('English', 3), ('Italian', 12)]",,1.0,
How many times at most can a course enrollment result show in different transcripts? Also show the course enrollment id.,"[Transcript_Contents.student_course_id,Transcript_Contents.transcript_id,Student_Enrolment_Courses.student_course_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT student_course_id, COUNT(transcript_id) AS transcript_count FROM Transcript_Contents GROUP BY student_course_id ORDER BY transcript_count DESC LIMIT 1;","SELECT count(*) ,  student_course_id FROM Transcript_Contents GROUP BY student_course_id ORDER BY count(*) DESC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""student_course_id"" and the maximum count of how many times it appears in different transcripts. Use COUNT to count occurrences of ""student_course_id"" in the ""Transcript_Contents"" table. 2. Condition Structure: No specific filtering condition is required, as we are interested in the maximum count across all records. 3. Join Structure: No JOIN is needed since all the required data is in the ""Transcript_Contents"" table. 4. Aggregation Structure: Use COUNT to count occurrences of ""student_course_id"" and GROUP BY ""student_course_id"" to group the results by each course enrollment ID. Use ORDER BY in descending order on the count and LIMIT 1 to get the maximum count.","[(0, 4)]","[(4, 0)]",,1.0,
"List all cartoon directed by ""Ben Jones"".","[Cartoon.Title, Cartoon.Directed_by, Cartoon.Directed_by = ""Ben Jones""]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT Cartoon.Title FROM Cartoon WHERE Cartoon.Directed_by = 'Ben Jones';,"SELECT Title FROM Cartoon WHERE Directed_by = ""Ben Jones"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Cartoon.Title"" of cartoons directed by ""Ben Jones"". 2. Condition Structure: Use a WHERE clause to filter records where ""Cartoon.Directed_by"" is equal to ""Ben Jones"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Cartoon"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving titles based on a specific condition.","[('The Rise of the Blue Beetle!',), ('Day of the Dark Knight!',), ('Dawn of the Dead Man!',), ('The Eyes of Despero!',)]","[('The Rise of the Blue Beetle!',), ('Day of the Dark Knight!',), ('Dawn of the Dead Man!',), ('The Eyes of Despero!',)]",,1.0,
When is the first transcript released? List the date and details.,"[Transcripts.transcript_date,Transcripts.other_details]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT Transcripts.transcript_date, Transcripts.other_details FROM Transcripts ORDER BY Transcripts.transcript_date ASC LIMIT 1;","SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""transcript_date"" and ""other_details"" from the ""Transcripts"" table. 2. Condition Structure: No specific filtering condition is required since we are looking for the earliest transcript date. 3. Join Structure: No JOIN is necessary as all the required information is available in the ""Transcripts"" table. 4. Aggregation Structure: Use ORDER BY on ""transcript_date"" in ascending order to find the earliest date. Apply LIMIT 1 to retrieve only the first transcript.","[('1975-05-06 12:04:47', None)]","[('1975-05-06 12:04:47', None)]",,1.0,
"How many cartoons were written by ""Joseph Kuhr""?","[Cartoon.id, Cartoon.Written_by, ""Joseph Kuhr""]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT COUNT(Cartoon.id) FROM Cartoon WHERE Cartoon.Written_by = 'Joseph Kuhr';,"SELECT count(*) FROM Cartoon WHERE Written_by = ""Joseph Kuhr"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to count the number of cartoons written by ""Joseph Kuhr"". 2. Condition Structure: Use a WHERE clause to filter rows where ""Cartoon.Written_by"" is equal to ""Joseph Kuhr"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Cartoon"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of cartoons that meet the specified condition.","[(2,)]","[(2,)]",,1.0,
How many degrees does the engineering department have?,"[Departments.department_name,Departments.department_id,Degree_Programs.department_id = Departments.department_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT COUNT(Degree_Programs.degree_program_id) FROM Departments JOIN Degree_Programs ON Departments.department_id = Degree_Programs.department_id WHERE Departments.department_name = 'Engineering';,SELECT count(*) FROM Departments AS T1 JOIN Degree_Programs AS T2 ON T1.department_id  =  T2.department_id WHERE T1.department_name  =  'engineer',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to count the number of degrees in the engineering department. Use COUNT on ""degree_program_id"" from the ""Degree_Programs"" table. 2. Condition Structure: Use a WHERE clause to filter for the ""engineering"" department by matching ""Departments.department_name"" to 'Engineering'. 3. Join Structure: Use an INNER JOIN between the ""Departments"" and ""Degree_Programs"" tables on ""Departments.department_id = Degree_Programs.department_id"" to associate degrees with their respective departments. 4. Aggregation Structure: Use COUNT to calculate the total number of degrees for the engineering department.","[(0,)]","[(0,)]",,1.0,
What are all of the episodes ordered by ratings?,"[TV_series.Episode, TV_series.Rating]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT TV_series.Episode, TV_series.Rating FROM TV_series ORDER BY TV_series.Rating DESC;",SELECT Episode FROM TV_series ORDER BY rating,tvshow,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the episode names and their ratings. 2. Condition Structure: No specific filtering condition is required as the query asks for all episodes. 3. Join Structure: No JOIN is required since all necessary information is available in the ""TV_series"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by ""TV_series.Rating"" in descending order to list episodes by their ratings.","[('A Love of a Lifetime', '5.8'), ('Friendly Skies', '5.3'), ('Game Three', '4.4'), ('The Year of the Rabbit', '4.3'), ('Winterland', '4.0'), ('The Legend of Dylan McCleen', '3.8'), ('Keepers', '3.7'), ('Emily', '3.7'), ('Blowback', '3.7'), ('Home By Another Way', '3.5'), ('Double Down', '3.4'), ('The Hanged Man', '3.0')]","[('The Hanged Man',), ('Double Down',), ('Home By Another Way',), ('Keepers',), ('Emily',), ('Blowback',), ('The Legend of Dylan McCleen',), ('Winterland',), ('The Year of the Rabbit',), ('Game Three',), ('Friendly Skies',), ('A Love of a Lifetime',)]",,1.0,
What is minimum and maximum share of TV series?,[TV_series.Share],"Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT MIN(TV_series.Share) AS min_share, MAX(TV_series.Share) AS max_share FROM TV_series;","SELECT max(SHARE) , min(SHARE) FROM TV_series;",tvshow,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the minimum and maximum share of TV series. 2. Aggregation Structure: Use MIN and MAX functions to calculate the minimum and maximum share values. 3. Grouping Structure: No GROUP BY is required since we are calculating the aggregate values for the entire ""TV_series"" table. 4. Join Structure: No JOIN is necessary as all the required data is within the ""TV_series"" table.","[(5.0, 9.0)]","[(9.0, 5.0)]",,1.0,
"List the Episode of all  TV series showed on TV Channel with series name ""Sky Radio"".","[TV_series.Episode, TV_Channel.series_name, TV_series.Channel = TV_Channel.id, Sky Radio]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,SELECT TV_series.Episode FROM TV_series JOIN TV_Channel ON TV_series.Channel = TV_Channel.id WHERE TV_Channel.series_name = 'Sky Radio';,"SELECT T2.Episode FROM TV_Channel AS T1 JOIN TV_series AS T2 ON T1.id = T2.Channel WHERE T1.series_name = ""Sky Radio"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""TV_series.Episode"" field. 2. Condition Structure: Use a WHERE clause to filter for TV series that are shown on a TV channel with the series name ""Sky Radio."" 3. Join Structure: Use an INNER JOIN between the ""TV_series"" table and the ""TV_Channel"" table based on the foreign key relationship ""TV_series.Channel = TV_Channel.id"" to link TV series with their respective channels. 4. Aggregation Structure: No aggregation is needed as the query only requires listing episodes.","[('A Love of a Lifetime',), ('Keepers',)]","[('A Love of a Lifetime',), ('Keepers',)]",,1.0,
What are the titles of all cartoons directed by Ben Jones or Brandon Vietti?,"[Cartoon.Title, Cartoon.Directed_by]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT Cartoon.Title FROM Cartoon WHERE Cartoon.Directed_by = 'Ben Jones' OR Cartoon.Directed_by = 'Brandon Vietti';,"SELECT Title FROM Cartoon WHERE Directed_by = ""Ben Jones"" OR Directed_by = ""Brandon Vietti"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the titles of cartoons. 2. Condition Structure: Use a WHERE clause to filter cartoons directed by either ""Ben Jones"" or ""Brandon Vietti"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Cartoon"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving titles based on a specific condition.","[('The Rise of the Blue Beetle!',), ('Terror on Dinosaur Island!',), ('Day of the Dark Knight!',), ('Invasion of the Secret Santas!',), ('Dawn of the Dead Man!',), ('Fall of the Blue Beetle!',), ('The Eyes of Despero!',), ('Return of the Fearsome Fangs!',)]","[('The Rise of the Blue Beetle!',), ('Terror on Dinosaur Island!',), ('Day of the Dark Knight!',), ('Invasion of the Secret Santas!',), ('Dawn of the Dead Man!',), ('Fall of the Blue Beetle!',), ('The Eyes of Despero!',), ('Return of the Fearsome Fangs!',)]",,1.0,
"What is the title of all the cartools that are on the TV Channel with the series name ""Sky Radio""?","[Cartoon.Title,TV_Channel.series_name,Cartoon.Channel = TV_Channel.id,TV_Channel.series_name = ""Sky Radio""]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,"SELECT Cartoon.Title FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE TV_Channel.series_name = ""Sky Radio"";","SELECT T2.Title FROM TV_Channel AS T1 JOIN Cartoon AS T2 ON T1.id = T2.Channel WHERE T1.series_name = ""Sky Radio"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Cartoon.Title"" field, as the question asks for the titles of cartoons. 2. Condition Structure: Use a WHERE clause to filter for TV Channels where ""TV_Channel.series_name"" is ""Sky Radio."" 3. Join Structure: Use an INNER JOIN to connect the ""Cartoon"" table with the ""TV_Channel"" table based on the foreign key relationship ""Cartoon.Channel = TV_Channel.id."" 4. Aggregation Structure: No aggregation is needed since the query only retrieves specific cartoon titles.","[('The Rise of the Blue Beetle!',), ('Return of the Fearsome Fangs!',)]","[('The Rise of the Blue Beetle!',), ('Return of the Fearsome Fangs!',)]",,1.0,
Find the number of cartoons directed by each of the listed directors.,"[Cartoon.id, Cartoon.Directed_by]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT Cartoon.Directed_by, COUNT(Cartoon.id) AS number_of_cartoons FROM Cartoon GROUP BY Cartoon.Directed_by;","SELECT count(*) ,  Directed_by FROM cartoon GROUP BY Directed_by",tvshow,"1. Sequential Structure: Start with the SELECT clause to specify the director's name and the count of cartoons directed by each director. 2. Aggregation Structure: Use COUNT to calculate the number of cartoons directed by each director. 3. Grouping Structure: Use GROUP BY on ""Cartoon.Directed_by"" to group the results by each director. 4. Condition Structure: No specific filtering condition is required as the query asks for the count of cartoons for all directors. 5. Join Structure: No JOIN is required since all necessary data is within the ""Cartoon"" table.","[('Ben Jones', 4), ('Brandon Vietti', 4), ('Michael Chang', 4)]","[(4, 'Ben Jones'), (4, 'Brandon Vietti'), (4, 'Michael Chang')]",,1.0,
"What is the earliest date of a transcript release, and what details can you tell me?","[Transcripts.transcript_date,Transcripts.other_details]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,"SELECT MIN(Transcripts.transcript_date) AS earliest_date, Transcripts.other_details FROM Transcripts;","SELECT transcript_date ,  other_details FROM Transcripts ORDER BY transcript_date ASC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the earliest transcript release date (""Transcripts.transcript_date"") and its associated details (""Transcripts.other_details""). 2. Aggregation Structure: Use the MIN function to find the earliest transcript release date. 3. Condition Structure: No specific filtering condition is required since we are looking for the earliest date across all records. 4. Join Structure: No JOIN is required as all necessary data is within the ""Transcripts"" table.","[('1975-05-06 12:04:47', None)]","[('1975-05-06 12:04:47', None)]",,1.0,
Find the last name of the students who currently live in the state of North Carolina but have not registered in any degree program.,"[Students.last_name, Students.current_address_id = Addresses.address_id, Addresses.state_province_county, Degree_Programs.degree_program_id = Student_Enrolment.degree_program_id, Student_Enrolment.student_id = Students.student_id, North Carolina]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NESTED,SELECT Students.last_name FROM Students JOIN Addresses ON Students.current_address_id = Addresses.address_id WHERE Addresses.state_province_county = 'North Carolina' AND Students.student_id NOT IN (SELECT Student_Enrolment.student_id FROM Student_Enrolment);,SELECT T1.last_name FROM Students AS T1 JOIN Addresses AS T2 ON T1.current_address_id  =  T2.address_id WHERE T2.state_province_county  =  'NorthCarolina' EXCEPT SELECT DISTINCT T3.last_name FROM Students AS T3 JOIN Student_Enrolment AS T4 ON T3.student_id  =  T4.student_id,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the last names of students. Use the FROM clause to specify the Students table and JOIN it with the Addresses table to access the current address details. Use a WHERE clause to filter students who live in the state of North Carolina. Additionally, use a subquery to exclude students who are registered in any degree program. 2. Condition Structure: Use the WHERE clause to filter students whose current address is in North Carolina. Use a NOT IN subquery to exclude students who have an entry in the Student_Enrolment table, indicating they are registered in a degree program. 3. Join Structure: Use an INNER JOIN between the Students and Addresses tables based on the current_address_id to access the state information. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",[],"[('Gleichner',), ('Weimann',)]",,0.0,
"What is the id, line 1, and line 2 of the address with the most students?","[Addresses.address_id, Addresses.line_1, Addresses.line_2, Students.current_address_id = Addresses.address_id, Students.permanent_address_id = Addresses.address_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Addresses.address_id, Addresses.line_1, Addresses.line_2 FROM Addresses JOIN Students ON Students.current_address_id = Addresses.address_id OR Students.permanent_address_id = Addresses.address_id GROUP BY Addresses.address_id, Addresses.line_1, Addresses.line_2 ORDER BY COUNT(Students.student_id) DESC LIMIT 1;","SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Addresses.address_id,"" ""Addresses.line_1,"" and ""Addresses.line_2."" 2. Condition Structure: No specific filtering condition is needed, as we are looking for the address with the most students. 3. Join Structure: Use JOINs to connect the ""Students"" table with the ""Addresses"" table on both ""current_address_id"" and ""permanent_address_id"" to account for all student addresses. 4. Aggregation Structure: Use COUNT to count the number of students associated with each address. Use GROUP BY to group results by ""Addresses.address_id,"" and ORDER BY in descending order of the count to find the address with the most students. Use LIMIT 1 to select the top result.","[(9, '0643 Muller Vista', 'Suite 383')]","[(9, '0643 Muller Vista', 'Suite 383')]",,1.0,
What is the name and id of the department with the most number of degrees ?,"[Departments.department_id,Departments.department_name,Degree_Programs.department_id = Departments.department_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Departments.department_name, Departments.department_id FROM Departments JOIN Degree_Programs ON Departments.department_id = Degree_Programs.department_id GROUP BY Departments.department_id ORDER BY COUNT(Degree_Programs.degree_program_id) DESC LIMIT 1;","select t2.department_name ,  t1.department_id from degree_programs as t1 join departments as t2 on t1.department_id  =  t2.department_id group by t1.department_id order by count(*) desc limit 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""department_name"" and ""department_id"" of the department. Use COUNT to count the number of degrees associated with each department. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the department with the most degrees. 3. Join Structure: Use an INNER JOIN between the ""Departments"" and ""Degree_Programs"" tables on ""Departments.department_id = Degree_Programs.department_id"" to associate each department with its degree programs. 4. Aggregation Structure: Use COUNT to count the number of degrees for each department, GROUP BY ""Departments.department_id"" to group the results by department, and ORDER BY the count in descending order. Use LIMIT 1 to select the department with the most degrees.","[('statistics', 8)]","[('statistics', 8)]",,1.0,
What are the names of all cartoons directed by Ben Jones?,"[Cartoon.Title, Cartoon.Directed_by, Cartoon.Channel = TV_Channel.id, Ben Jones]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,SELECT Cartoon.Title FROM Cartoon WHERE Cartoon.Directed_by = 'Ben Jones';,"SELECT Title FROM Cartoon WHERE Directed_by = ""Ben Jones"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Cartoon.Title"" of cartoons directed by ""Ben Jones"". 2. Condition Structure: Use a WHERE clause to filter for records where ""Cartoon.Directed_by"" is equal to ""Ben Jones"". 3. Join Structure: No JOIN is required since all necessary information is available in the ""Cartoon"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the titles of cartoons that meet the specified condition.","[('The Rise of the Blue Beetle!',), ('Day of the Dark Knight!',), ('Dawn of the Dead Man!',), ('The Eyes of Despero!',)]","[('The Rise of the Blue Beetle!',), ('Day of the Dark Knight!',), ('Dawn of the Dead Man!',), ('The Eyes of Despero!',)]",,1.0,
What is the program id and the summary of the degree that has the most students enrolled?,"[Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id, Student_Enrolment.student_id, Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name FROM Degree_Programs JOIN Student_Enrolment ON Degree_Programs.degree_program_id = Student_Enrolment.degree_program_id GROUP BY Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name ORDER BY COUNT(Student_Enrolment.student_id) DESC LIMIT 1;","SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Degree_Programs.degree_program_id"" and ""Degree_Programs.degree_summary_name."" Use COUNT to count the number of students enrolled in each degree program. 2. Condition Structure: No specific filtering condition is required, as we are interested in finding the degree program with the most students enrolled. 3. Join Structure: Use an INNER JOIN between ""Degree_Programs"" and ""Student_Enrolment"" on ""Degree_Programs.degree_program_id = Student_Enrolment.degree_program_id"" to associate degree programs with their student enrollments. 4. Aggregation Structure: Use COUNT to count the number of students enrolled in each degree program. Use GROUP BY to group results by ""Degree_Programs.degree_program_id"" and ""Degree_Programs.degree_summary_name."" Use ORDER BY in descending order of the count and LIMIT 1 to select the degree program with the most students enrolled.","[(9, 'Bachelor')]","[(9, 'Bachelor')]",,1.0,
"What are the first, middle, and last names, along with the ids, of all students who enrolled in 2 degree programs in one semester?","[Students.first_name, Students.middle_name, Students.last_name, Students.student_id, Student_Enrolment.student_id, Student_Enrolment.degree_program_id, Student_Enrolment.semester_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Students.first_name, Students.middle_name, Students.last_name, Students.student_id FROM Students JOIN Student_Enrolment ON Students.student_id = Student_Enrolment.student_id GROUP BY Student_Enrolment.student_id, Student_Enrolment.semester_id HAVING COUNT(DISTINCT Student_Enrolment.degree_program_id) = 2;","SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Students.first_name,"" ""Students.middle_name,"" ""Students.last_name,"" and ""Students.student_id."" 2. Condition Structure: Use a HAVING clause to filter for students who enrolled in exactly 2 degree programs in one semester. This requires grouping by ""Student_Enrolment.student_id"" and ""Student_Enrolment.semester_id"" and counting the distinct ""Student_Enrolment.degree_program_id."" 3. Join Structure: Use a JOIN between the ""Students"" table and the ""Student_Enrolment"" table on ""Students.student_id = Student_Enrolment.student_id"" to link students with their enrollment records. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Student_Enrolment.degree_program_id"" to count the number of degree programs a student enrolled in per semester, and filter using HAVING to select those with exactly 2 enrollments.","[('Frida', 'Aisha', 'Huel', 7)]","[('Jarvis', 'Aaliyah', 'Carroll', 4), ('Reva', 'Golda', 'Osinski', 9), ('Jordy', 'Osborne', 'Rempel', 14)]",,0.0,
What is the country with the most number of TV Channels and how many does it have?,"[TV_Channel.Country, TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT TV_Channel.Country, COUNT(*) AS channel_count FROM TV_Channel GROUP BY TV_Channel.Country ORDER BY COUNT(*) DESC LIMIT 1;","SELECT Country ,  count(*) FROM TV_Channel GROUP BY Country ORDER BY count(*) DESC LIMIT 1;",tvshow,"1. Sequential Structure: Begin with the SELECT clause to retrieve the ""TV_Channel.Country"" and the count of TV channels in each country. 2. Aggregation Structure: Use COUNT to calculate the number of TV channels for each country. 3. Grouping Structure: Use GROUP BY on ""TV_Channel.Country"" to group the results by country. 4. Ordering Structure: Use ORDER BY in descending order on the count of TV channels to rank countries by the number of channels. 5. Limiting Structure: Use LIMIT 1 to retrieve the country with the most TV channels. 6. Join Structure: No JOIN is required since all necessary data is within the ""TV_Channel"" table.","[('Italy', 12)]","[('Italy', 12)]",,1.0,
List the section_name in reversed lexicographical order.,[Sections.section_name],"Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Sections.section_name FROM Sections ORDER BY Sections.section_name DESC;,SELECT section_name FROM Sections ORDER BY section_name DESC,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""section_name"" from the ""Sections"" table. 2. Condition Structure: No specific filtering condition is required as we want all section names. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""Sections"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the section names. 5. Ordering Structure: Use ORDER BY in descending order to achieve reversed lexicographical order for the ""section_name"".","[('y',), ('u',), ('p',), ('o',), ('l',), ('k',), ('j',), ('h',), ('g',), ('f',), ('e',), ('d',), ('c',), ('b',), ('a',)]","[('y',), ('u',), ('p',), ('o',), ('l',), ('k',), ('j',), ('h',), ('g',), ('f',), ('e',), ('d',), ('c',), ('b',), ('a',)]",,1.0,
What are the ids of the TV channels that do not have any cartoons directed by Ben Jones?,"[TV_Channel.id, Cartoon.Directed_by, Cartoon.Channel = TV_Channel.id, Ben Jones]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NESTED,SELECT id FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones');,SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones',tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of TV channels. Use the FROM clause to specify the TV_Channel table. Apply a WHERE clause to filter out channels that have cartoons directed by Ben Jones. 2. Condition Structure: Use the WHERE clause with a subquery to exclude channels whose IDs appear in the Cartoon table with ""Directed_by"" as 'Ben Jones'. 3. Join Structure: Not required, as the filtering is based on the relationship between the TV_Channel and Cartoon tables through the Channel field. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.","[('701',), ('703',), ('705',), ('706',), ('708',), ('709',), ('713',), ('714',), ('715',), ('717',), ('719',)]","[('701',), ('703',), ('705',), ('706',), ('708',), ('709',), ('713',), ('714',), ('715',), ('717',), ('719',)]",,1.0,
What is the description of the department whose name has the substring the computer?,"[Departments.department_description, Departments.department_name]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Departments.department_description FROM Departments WHERE Departments.department_name LIKE '%the computer%';,SELECT department_description FROM Departments WHERE department_name LIKE '%computer%',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Departments.department_description"" of the department whose name contains the substring ""the computer"". 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for department names that contain the substring ""the computer"". 3. Join Structure: No JOIN is required since all relevant information is in the ""Departments"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.",[],"[('error',)]",,0.0,
Which address holds the most number of students currently? List the address id and all lines.,"[Addresses.address_id, Addresses.line_1, Addresses.line_2, Addresses.line_3, Students.current_address_id, Students.student_id = Student_Enrolment.student_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Addresses.address_id, Addresses.line_1, Addresses.line_2, Addresses.line_3 FROM Addresses JOIN Students ON Students.current_address_id = Addresses.address_id GROUP BY Addresses.address_id, Addresses.line_1, Addresses.line_2, Addresses.line_3 ORDER BY COUNT(Students.student_id) DESC LIMIT 1;","SELECT T1.address_id ,  T1.line_1 ,  T1.line_2 FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.current_address_id GROUP BY T1.address_id ORDER BY count(*) DESC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""address_id,"" ""line_1,"" ""line_2,"" and ""line_3"" fields from the ""Addresses"" table. Use COUNT to count the number of students associated with each address. 2. Condition Structure: No specific filtering condition is required since we are looking for the address with the most students. 3. Join Structure: Use a JOIN between the ""Students"" table and the ""Addresses"" table on ""Students.current_address_id = Addresses.address_id"" to associate students with their current addresses. 4. Aggregation Structure: Use COUNT to count the number of students for each address, GROUP BY ""Addresses.address_id"" to group the results by address, and ORDER BY the count in descending order to find the address with the most students. Use LIMIT 1 to get the top result.","[(9, '0643 Muller Vista', 'Suite 383', None)]","[(9, '0643 Muller Vista', 'Suite 383')]",,1.0,
"What is the first, middle, and last name, along with the id and number of enrollments, for the student who enrolled the most in any program?","[Students.first_name, Students.middle_name, Students.last_name, Students.student_id, Student_Enrolment.student_id, COUNT(Student_Enrolment.student_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Students.first_name, Students.middle_name, Students.last_name, Students.student_id, COUNT(Student_Enrolment.student_id) AS number_of_enrollments FROM Students JOIN Student_Enrolment ON Students.student_id = Student_Enrolment.student_id GROUP BY Students.student_id ORDER BY number_of_enrollments DESC LIMIT 1;","SELECT T1.student_id ,  T1.first_name ,  T1.middle_name ,  T1.last_name ,  count(*) ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Students.first_name,"" ""Students.middle_name,"" ""Students.last_name,"" ""Students.student_id,"" and the count of enrollments. Use COUNT to calculate the number of enrollments for each student. 2. Condition Structure: Use ORDER BY in descending order on the count of enrollments to rank students by the number of enrollments. Use LIMIT 1 to select the student with the highest number of enrollments. 3. Join Structure: Use a JOIN between the ""Students"" table and the ""Student_Enrolment"" table on ""Students.student_id"" to associate each student with their enrollments. 4. Aggregation Structure: Use COUNT on ""Student_Enrolment.student_id"" to count the number of enrollments for each student, then GROUP BY ""Students.student_id"" to group results by each student.","[('Frida', 'Aisha', 'Huel', 7, 3)]","[(7, 'Frida', 'Aisha', 'Huel', 3, 7)]",,1.0,
Find the semester when both Master students and Bachelor students got enrolled in.,"[Degree_Programs.degree_summary_name,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment.semester_id,Semesters.semester_id = Student_Enrolment.semester_id,Semesters.semester_name]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NESTED,"SELECT Semesters.semester_name FROM Semesters JOIN Student_Enrolment ON Semesters.semester_id = Student_Enrolment.semester_id JOIN Degree_Programs ON Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id GROUP BY Semesters.semester_name HAVING COUNT(DISTINCT CASE WHEN Degree_Programs.degree_summary_name IN ('Master', 'Bachelor') THEN Degree_Programs.degree_summary_name END) = 2;",SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the semester name. Use the FROM clause to specify the Semesters table and join it with the Student_Enrolment and Degree_Programs tables to connect semesters with the degree programs of enrolled students. Use GROUP BY to group by semester name and filter semesters where both Master and Bachelor students were enrolled. 2. Condition Structure: Use the HAVING clause to ensure that both ""Master"" and ""Bachelor"" degree programs are present in the same semester. 3. Join Structure: Use INNER JOINs between Semesters, Student_Enrolment, and Degree_Programs tables based on their respective foreign key relationships to connect semesters with degree programs. 4. Aggregation Structure: Use COUNT(DISTINCT degree_summary_name) in the HAVING clause to ensure that both ""Master"" and ""Bachelor"" degree programs are present in the same semester.","[('fall 2018',)]","[(13,)]",,0.0,
How many different degree names are offered?,[Degree_Programs.degree_summary_name],"Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT COUNT(DISTINCT Degree_Programs.degree_summary_name) AS number_of_degrees FROM Degree_Programs;,SELECT count(DISTINCT degree_summary_name) FROM Degree_Programs,student_transcripts_tracking,"1. Sequential Structure: Begin with the SELECT clause to count the distinct degree names, as the question asks for the number of different degree names offered. 2. Condition Structure: No specific filtering condition is required since we are interested in all degree names. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Degree_Programs"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Degree_Programs.degree_summary_name"" to count the unique degree names.","[(3,)]","[(3,)]",,1.0,
What is the last transcript release date?,[Transcripts.transcript_date],"Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT MAX(Transcripts.transcript_date) AS last_transcript_date FROM Transcripts;,SELECT transcript_date FROM Transcripts ORDER BY transcript_date DESC LIMIT 1,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""transcript_date"" field, as the question asks for the last transcript release date. 2. Condition Structure: No specific filtering condition is required since we are looking for the latest date. 3. Join Structure: No JOIN is necessary because all the required data is contained within the ""Transcripts"" table. 4. Aggregation Structure: Use the MAX function to find the latest (maximum) transcript release date.","[('2013-06-30 13:01:40',)]","[('2013-06-30 13:01:40',)]",,1.0,
"Who are enrolled in 2 degree programs in one semester? List the first name, middle name and last name and the id.","[Students.first_name, Students.middle_name, Students.last_name, Students.student_id, Student_Enrolment.student_id, Student_Enrolment.degree_program_id, Student_Enrolment.semester_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Students.first_name, Students.middle_name, Students.last_name, Students.student_id FROM Students JOIN Student_Enrolment ON Students.student_id = Student_Enrolment.student_id GROUP BY Student_Enrolment.student_id, Student_Enrolment.semester_id HAVING COUNT(Student_Enrolment.degree_program_id) = 2;","SELECT T1.first_name ,  T1.middle_name ,  T1.last_name ,  T1.student_id FROM Students AS T1 JOIN Student_Enrolment AS T2 ON T1.student_id  =  T2.student_id GROUP BY T1.student_id HAVING count(*)  =  2",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Students.first_name,"" ""Students.middle_name,"" ""Students.last_name,"" and ""Students.student_id."" 2. Condition Structure: Use a HAVING clause to filter students who are enrolled in exactly 2 degree programs in the same semester. This requires grouping by ""Student_Enrolment.student_id"" and ""Student_Enrolment.semester_id."" 3. Join Structure: Use a JOIN between the ""Students"" table and the ""Student_Enrolment"" table on ""Students.student_id = Student_Enrolment.student_id"" to link students with their enrollment records. 4. Aggregation Structure: Use COUNT on ""Student_Enrolment.degree_program_id"" to count the number of degree programs a student is enrolled in per semester, and filter with HAVING to select those with exactly 2 enrollments.","[('Frida', 'Aisha', 'Huel', 7)]","[('Jarvis', 'Aaliyah', 'Carroll', 4), ('Reva', 'Golda', 'Osinski', 9), ('Jordy', 'Osborne', 'Rempel', 14)]",,0.0,
What is the produdction code and channel of the most recent cartoon ?,"[Cartoon.Production_code, Cartoon.Channel, Cartoon.Original_air_date, TV_Channel.id = Cartoon.Channel]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,"SELECT Cartoon.Production_code, Cartoon.Channel FROM Cartoon ORDER BY Cartoon.Original_air_date DESC LIMIT 1;","select production_code ,  channel from cartoon order by original_air_date desc limit 1",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Cartoon.Production_code"" and ""Cartoon.Channel."" To find the most recent cartoon, use ORDER BY on ""Cartoon.Original_air_date"" in descending order and LIMIT 1 to get the latest record. 2. Condition Structure: No specific filtering condition is required since we are only interested in the most recent cartoon. 3. Join Structure: No JOIN is necessary as all the required information is available in the ""Cartoon"" table. 4. Aggregation Structure: No aggregation is needed since we are only retrieving the production code and channel of the most recent cartoon.","[(102.0, '701')]","[(102.0, '701')]",,1.0,
What is the maximum and minimum share for the TV series?,[TV_series.Share],"Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT MAX(TV_series.Share) AS max_share, MIN(TV_series.Share) AS min_share FROM TV_series;","SELECT max(SHARE) , min(SHARE) FROM TV_series;",tvshow,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum shares for the TV series. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum share values. 3. Grouping Structure: No GROUP BY is required since we are calculating the overall maximum and minimum shares across all TV series. 4. Join Structure: No JOIN is required as all necessary data is within the ""TV_series"" table.","[(9.0, 5.0)]","[(9.0, 5.0)]",,1.0,
What is the name and directors of all the cartoons that are ordered by air date?,"[Cartoon.Title, Cartoon.Directed_by, Cartoon.Original_air_date]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT Cartoon.Title, Cartoon.Directed_by FROM Cartoon ORDER BY Cartoon.Original_air_date;","SELECT title ,  Directed_by FROM Cartoon ORDER BY Original_air_date",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Cartoon.Title"" and ""Cartoon.Directed_by"" fields, as well as the ""Cartoon.Original_air_date"" for ordering purposes. 2. Condition Structure: No specific filtering condition is required since the query asks for all cartoons. 3. Join Structure: No JOIN is required because all the necessary information is available in the ""Cartoon"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves and orders the data. 5. Ordering Structure: Use ORDER BY on ""Cartoon.Original_air_date"" to sort the results by air date.","[('Invasion of the Secret Santas!', 'Brandon Vietti'), ('Evil Under the Sea!', 'Michael Chang'), ('Return of the Fearsome Fangs!', 'Brandon Vietti'), ('Deep Cover for Batman!', 'Michael Chang'), ('The Eyes of Despero!', 'Ben Jones'), ('Dawn of the Dead Man!', 'Ben Jones'), ('Day of the Dark Knight!', 'Ben Jones'), ('Fall of the Blue Beetle!', 'Brandon Vietti'), ('Journey to the Center of the Bat!', 'Michael Chang'), ('Enter the Outsiders!', 'Michael Chang'), ('The Rise of the Blue Beetle!', 'Ben Jones'), ('Terror on Dinosaur Island!', 'Brandon Vietti')]","[('Invasion of the Secret Santas!', 'Brandon Vietti'), ('Evil Under the Sea!', 'Michael Chang'), ('Return of the Fearsome Fangs!', 'Brandon Vietti'), ('Deep Cover for Batman!', 'Michael Chang'), ('The Eyes of Despero!', 'Ben Jones'), ('Dawn of the Dead Man!', 'Ben Jones'), ('Day of the Dark Knight!', 'Ben Jones'), ('Fall of the Blue Beetle!', 'Brandon Vietti'), ('Journey to the Center of the Bat!', 'Michael Chang'), ('Enter the Outsiders!', 'Michael Chang'), ('The Rise of the Blue Beetle!', 'Ben Jones'), ('Terror on Dinosaur Island!', 'Brandon Vietti')]",,1.0,
How many different departments offer degrees?,"[Departments.department_id,Departments.department_name,Degree_Programs.department_id = Departments.department_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT COUNT(DISTINCT Departments.department_id) FROM Degree_Programs JOIN Departments ON Degree_Programs.department_id = Departments.department_id;,SELECT count(DISTINCT department_id) FROM Degree_Programs,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""Departments.department_id"" since we are interested in the number of different departments offering degrees. 2. Condition Structure: No specific filtering condition is required as we are considering all departments that offer degrees. 3. Join Structure: Use an INNER JOIN between the ""Degree_Programs"" table and the ""Departments"" table on ""Degree_Programs.department_id = Departments.department_id"" to link degree programs to their respective departments. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique department IDs that are associated with degree programs.","[(10,)]","[(10,)]",,1.0,
What are the Package Options of the TV Channels whose series names are Sky Radio?,"[TV_Channel.Package_Option, TV_Channel.series_name, TV_Channel.id = TV_series.Channel, TV_series.series_name, Sky Radio]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,SELECT TV_Channel.Package_Option FROM TV_Channel JOIN TV_series ON TV_Channel.id = TV_series.Channel WHERE TV_series.series_name = 'Sky Radio';,"SELECT Package_Option FROM TV_Channel WHERE series_name = ""Sky Radio"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""TV_Channel.Package_Option"" field. 2. Condition Structure: Use a WHERE clause to filter for TV channels where the series name is ""Sky Radio."" 3. Join Structure: Use a JOIN between the ""TV_Channel"" and ""TV_series"" tables based on the foreign key ""TV_Channel.id = TV_series.Channel"" to link TV channels with their series. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields without any summarization.",[],"[('Sky Famiglia',)]",no such column: TV_series.series_name,0.0,
What are the countries that are not playing cartoons written by Todd Casey?,"[Cartoon.Title,Cartoon.Written_by,Cartoon.Channel = TV_Channel.id,TV_Channel.Country,Todd Casey]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NESTED,SELECT DISTINCT TV_Channel.Country FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE TV_Channel.Country NOT IN ( SELECT DISTINCT TV_Channel.Country FROM Cartoon JOIN TV_Channel ON Cartoon.Channel = TV_Channel.id WHERE Cartoon.Written_by = 'Todd Casey' );,SELECT country FROM TV_Channel EXCEPT SELECT T1.country FROM TV_Channel AS T1 JOIN cartoon AS T2 ON T1.id = T2.Channel WHERE T2.written_by  =  'Todd Casey',tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct countries. Use the FROM clause to specify the Cartoon and TV_Channel tables. Apply a WHERE clause to filter out cartoons written by Todd Casey and ensure we exclude those countries. 2. Condition Structure: Use the WHERE clause to filter for cartoons not written by Todd Casey by checking the ""Written_by"" column. Use a NOT IN subquery to exclude countries where cartoons written by Todd Casey are aired. 3. Join Structure: Use an INNER JOIN between the Cartoon and TV_Channel tables based on the Channel foreign key to connect cartoons with their respective countries. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",[],"[('Poland',)]",,0.0,
List the Episode of all TV series sorted by rating.,"[TV_series.Episode, TV_series.Rating]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT TV_series.Episode, TV_series.Rating FROM TV_series ORDER BY TV_series.Rating ASC;",SELECT Episode FROM TV_series ORDER BY rating,tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Episode"" and ""Rating"" fields from the ""TV_series"" table. 2. Condition Structure: No specific filtering condition is required as we want all episodes. 3. Join Structure: No JOIN is required since all necessary information is available in the ""TV_series"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by ""Rating"" in ascending order.","[('The Hanged Man', '3.0'), ('Double Down', '3.4'), ('Home By Another Way', '3.5'), ('Keepers', '3.7'), ('Emily', '3.7'), ('Blowback', '3.7'), ('The Legend of Dylan McCleen', '3.8'), ('Winterland', '4.0'), ('The Year of the Rabbit', '4.3'), ('Game Three', '4.4'), ('Friendly Skies', '5.3'), ('A Love of a Lifetime', '5.8')]","[('The Hanged Man',), ('Double Down',), ('Home By Another Way',), ('Keepers',), ('Emily',), ('Blowback',), ('The Legend of Dylan McCleen',), ('Winterland',), ('The Year of the Rabbit',), ('Game Three',), ('Friendly Skies',), ('A Love of a Lifetime',)]",,1.0,
"When did the episode ""A Love of a Lifetime"" air?","[TV_series.Episode, TV_series.Air_Date, TV_series.Channel = TV_Channel.id]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NON-NESTED,SELECT TV_series.Air_Date FROM TV_series WHERE TV_series.Episode = 'A Love of a Lifetime';,"SELECT Air_Date FROM TV_series WHERE Episode = ""A Love of a Lifetime"";",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Air_Date"" of the episode. 2. Condition Structure: Use a WHERE clause to filter for the specific episode titled ""A Love of a Lifetime."" 3. Join Structure: No JOIN is required since the necessary information is available in the ""TV_series"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single value.","[('September 24, 2007',)]","[('September 24, 2007',)]",,1.0,
What is the id of the semester that had both Masters and Bachelors students enrolled?,"[Degree_Programs.degree_summary_name,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment.semester_id,Semesters.semester_id = Student_Enrolment.semester_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NESTED,"SELECT Student_Enrolment.semester_id FROM Student_Enrolment JOIN Degree_Programs ON Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id JOIN Semesters ON Student_Enrolment.semester_id = Semesters.semester_id WHERE Degree_Programs.degree_summary_name IN ('Masters', 'Bachelors') GROUP BY Student_Enrolment.semester_id HAVING COUNT(DISTINCT Degree_Programs.degree_summary_name) = 2;",SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Master' INTERSECT SELECT DISTINCT T2.semester_id FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id WHERE degree_summary_name  =  'Bachelor',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the semester ID. Use the FROM clause to specify the Student_Enrolment and Degree_Programs tables. Join these tables to link student enrollments with their degree programs. Additionally, join the Semesters table to get the semester details. Use a WHERE clause to filter for semesters that had both Masters and Bachelors students enrolled. 2. Condition Structure: Use a WHERE clause to filter for degree programs with names 'Masters' and 'Bachelors'. Use a GROUP BY clause to group by semester ID and a HAVING clause to ensure that both degree types are present in the same semester. 3. Join Structure: Use INNER JOINs to connect Student_Enrolment with Degree_Programs on degree_program_id and Semesters on semester_id. 4. Aggregation Structure: Use COUNT(DISTINCT degree_summary_name) in the HAVING clause to ensure that both 'Masters' and 'Bachelors' are present in the same semester.",[],"[(13,)]",,0.0,
What is the phone number of the man with the first name Timmothy and the last name Ward?,"[Students.first_name, Students.last_name, Students.cell_mobile_number, Students.first_name = 'Timmothy', Students.last_name = 'Ward']","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Students.cell_mobile_number FROM Students WHERE Students.first_name = 'Timmothy' AND Students.last_name = 'Ward';,SELECT cell_mobile_number FROM Students WHERE first_name  =  'Timmothy' AND last_name  =  'Ward',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.cell_mobile_number"" of the student whose first name is 'Timmothy' and last name is 'Ward'. 2. Condition Structure: Use a WHERE clause to filter for students with ""Students.first_name"" equal to 'Timmothy' and ""Students.last_name"" equal to 'Ward'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Students"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on specific conditions.","[('(096)889-8954x524',)]","[('(096)889-8954x524',)]",,1.0,
How many different addresses do the students currently live?,"[Students.current_address_id, Addresses.address_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT COUNT(DISTINCT Addresses.address_id) FROM Students JOIN Addresses ON Students.current_address_id = Addresses.address_id;,SELECT count(DISTINCT current_address_id) FROM Students,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""address_id"" values from the ""Addresses"" table, as we are interested in the number of unique addresses where students currently live. 2. Condition Structure: Use a WHERE clause to filter the records based on the ""current_address_id"" in the ""Students"" table, ensuring we only consider addresses that are currently associated with students. 3. Join Structure: Use an INNER JOIN between the ""Students"" table and the ""Addresses"" table on ""Students.current_address_id = Addresses.address_id"" to link students with their current addresses. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique ""address_id"" values.","[(9,)]","[(9,)]",,1.0,
Find the kind of program which most number of students are enrolled in?,"[Degree_Programs.degree_summary_name,Student_Enrolment.degree_program_id,Student_Enrolment.student_id = Students.student_id,Degree_Programs.degree_program_id = Student_Enrolment.degree_program_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Degree_Programs.degree_summary_name, COUNT(Student_Enrolment.student_id) AS student_count FROM Degree_Programs JOIN Student_Enrolment ON Degree_Programs.degree_program_id = Student_Enrolment.degree_program_id GROUP BY Degree_Programs.degree_summary_name ORDER BY student_count DESC LIMIT 1;",SELECT T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_summary_name ORDER BY count(*) DESC LIMIT 1,student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""degree_summary_name"" from the ""Degree_Programs"" table. Use COUNT to count the number of students enrolled in each program. Use GROUP BY to group the results by ""degree_summary_name"" and ORDER BY in descending order of the count to find the program with the most students. Use LIMIT 1 to get the top result. 2. Condition Structure: No specific filtering condition is required as we are considering all programs. 3. Join Structure: Use a JOIN between ""Degree_Programs"" and ""Student_Enrolment"" on ""degree_program_id"" to link programs with their enrollments. 4. Aggregation Structure: Use COUNT to calculate the number of students enrolled in each program and ORDER BY to rank the programs by the number of students.","[('Bachelor', 8)]","[('Bachelor',)]",,1.0,
What are the names of the sections in reverse alphabetical order?,[Sections.section_name],"Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",EASY,SELECT Sections.section_name FROM Sections ORDER BY Sections.section_name DESC;,SELECT section_name FROM Sections ORDER BY section_name DESC,student_transcripts_tracking,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""section_name"" from the ""Sections"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for all section names. 3. Join Structure: No JOIN is required since all necessary data is within the ""Sections"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the section names. 5. Ordering Structure: Use ORDER BY in descending order to sort the section names in reverse alphabetical order.","[('y',), ('u',), ('p',), ('o',), ('l',), ('k',), ('j',), ('h',), ('g',), ('f',), ('e',), ('d',), ('c',), ('b',), ('a',)]","[('y',), ('u',), ('p',), ('o',), ('l',), ('k',), ('j',), ('h',), ('g',), ('f',), ('e',), ('d',), ('c',), ('b',), ('a',)]",,1.0,
Find the program which most number of students are enrolled in. List both the id and the summary.,"[Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name, Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id, Student_Enrolment.student_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name FROM Degree_Programs JOIN Student_Enrolment ON Degree_Programs.degree_program_id = Student_Enrolment.degree_program_id GROUP BY Degree_Programs.degree_program_id, Degree_Programs.degree_summary_name ORDER BY COUNT(Student_Enrolment.student_id) DESC LIMIT 1;","SELECT T1.degree_program_id ,  T1.degree_summary_name FROM Degree_Programs AS T1 JOIN Student_Enrolment AS T2 ON T1.degree_program_id  =  T2.degree_program_id GROUP BY T1.degree_program_id ORDER BY count(*) DESC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""degree_program_id"" and ""degree_summary_name"" from the ""Degree_Programs"" table. Use COUNT to calculate the number of students enrolled in each program. 2. Condition Structure: No specific filtering condition is required as we are interested in all programs. 3. Join Structure: Use an INNER JOIN between ""Degree_Programs"" and ""Student_Enrolment"" on ""degree_program_id"" to link each program with its student enrollments. 4. Aggregation Structure: Use COUNT to count the number of students enrolled in each program, GROUP BY ""degree_program_id"" to group the results by program, and ORDER BY the count in descending order to find the program with the most students. Use LIMIT 1 to select the top result.","[(9, 'Bachelor')]","[(9, 'Bachelor')]",,1.0,
list all cartoon titles and their directors ordered by their air date,"[Cartoon.Title, Cartoon.Directed_by, Cartoon.Original_air_date]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT Cartoon.Title, Cartoon.Directed_by FROM Cartoon ORDER BY Cartoon.Original_air_date;","SELECT title ,  Directed_by FROM Cartoon ORDER BY Original_air_date",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Cartoon.Title"" and ""Cartoon.Directed_by"" fields, as well as the ""Cartoon.Original_air_date"" for ordering purposes. 2. Condition Structure: No specific filtering condition is required since the query asks for all cartoon titles and their directors. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Cartoon"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves and orders the data. 5. Ordering Structure: Use ORDER BY on ""Cartoon.Original_air_date"" to sort the results by their air date.","[('Invasion of the Secret Santas!', 'Brandon Vietti'), ('Evil Under the Sea!', 'Michael Chang'), ('Return of the Fearsome Fangs!', 'Brandon Vietti'), ('Deep Cover for Batman!', 'Michael Chang'), ('The Eyes of Despero!', 'Ben Jones'), ('Dawn of the Dead Man!', 'Ben Jones'), ('Day of the Dark Knight!', 'Ben Jones'), ('Fall of the Blue Beetle!', 'Brandon Vietti'), ('Journey to the Center of the Bat!', 'Michael Chang'), ('Enter the Outsiders!', 'Michael Chang'), ('The Rise of the Blue Beetle!', 'Ben Jones'), ('Terror on Dinosaur Island!', 'Brandon Vietti')]","[('Invasion of the Secret Santas!', 'Brandon Vietti'), ('Evil Under the Sea!', 'Michael Chang'), ('Return of the Fearsome Fangs!', 'Brandon Vietti'), ('Deep Cover for Batman!', 'Michael Chang'), ('The Eyes of Despero!', 'Ben Jones'), ('Dawn of the Dead Man!', 'Ben Jones'), ('Day of the Dark Knight!', 'Ben Jones'), ('Fall of the Blue Beetle!', 'Brandon Vietti'), ('Journey to the Center of the Bat!', 'Michael Chang'), ('Enter the Outsiders!', 'Michael Chang'), ('The Rise of the Blue Beetle!', 'Ben Jones'), ('Terror on Dinosaur Island!', 'Brandon Vietti')]",,1.0,
find the id of tv channels that do not play any cartoon directed by Ben Jones.,"[TV_Channel.id, Cartoon.Directed_by, Cartoon.Channel = TV_Channel.id, Ben Jones]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NESTED,SELECT id FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones');,SELECT id FROM TV_Channel EXCEPT SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones',tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of TV channels. Use the FROM clause to specify the TV_Channel table. Apply a WHERE clause to filter out channels that play cartoons directed by Ben Jones. 2. Condition Structure: Use a WHERE clause with a subquery to exclude channels whose IDs appear in the Cartoon table for cartoons directed by Ben Jones. 3. Join Structure: Not required, as the filtering is based on the relationship between the TV_Channel and Cartoon tables through the Channel field. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.","[('701',), ('703',), ('705',), ('706',), ('708',), ('709',), ('713',), ('714',), ('715',), ('717',), ('719',)]","[('701',), ('703',), ('705',), ('706',), ('708',), ('709',), ('713',), ('714',), ('715',), ('717',), ('719',)]",,1.0,
Find the first name of the students who permanently live in the country Haiti or have the cell phone number 09700166582 .,"[Students.first_name,Students.permanent_address_id = Addresses.address_id,Addresses.country,Students.cell_mobile_number,Haiti,09700166582]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,SELECT Students.first_name FROM Students JOIN Addresses ON Students.permanent_address_id = Addresses.address_id WHERE Addresses.country = 'Haiti' OR Students.cell_mobile_number = '09700166582';,select t1.first_name from students as t1 join addresses as t2 on t1.permanent_address_id  =  t2.address_id where t2.country  =  'haiti' or t1.cell_mobile_number  =  '09700166582',student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Students.first_name."" 2. Condition Structure: Use a WHERE clause to filter students who either permanently live in the country ""Haiti"" or have the cell phone number ""09700166582."" This requires checking the ""Addresses.country"" for ""Haiti"" and ""Students.cell_mobile_number"" for the specific number. 3. Join Structure: Use a JOIN between the ""Students"" table and the ""Addresses"" table on ""Students.permanent_address_id = Addresses.address_id"" to access the country information for each student's permanent address. 4. Aggregation Structure: No aggregation is needed as we are retrieving individual student names based on the specified conditions.","[('Hobart',), ('Warren',), ('Jarvis',), ('Delaney',)]","[('Jarvis',)]",,1.0,
What is the name of the semester with no students enrolled?,"[Semesters.semester_name,Student_Enrolment.semester_id,Semesters.semester_id = Student_Enrolment.semester_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NESTED,SELECT semester_name FROM Semesters WHERE semester_id NOT IN (SELECT semester_id FROM Student_Enrolment);,SELECT semester_name FROM Semesters WHERE semester_id NOT IN( SELECT semester_id FROM Student_Enrolment ),student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve the semester name. Use the FROM clause to specify the Semesters table. Apply a WHERE clause to filter semesters that have no students enrolled by ensuring their semester_id is not present in the Student_Enrolment table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude semesters whose semester_id appears in the Student_Enrolment table, meaning they have students enrolled. 3. Join Structure: Not required, as we only need to filter based on the absence of matching semester_id entries in the Student_Enrolment table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('fall 2010',), ('spring 2013',), ('spring 2014',), ('spring 2016',), ('spring 2017',), ('winter 2018',)]","[('fall 2010',), ('spring 2013',), ('spring 2014',), ('spring 2016',), ('spring 2017',), ('winter 2018',)]",,1.0,
Find the package choice and series name of the TV channel that has high definition TV.,"[TV_Channel.Package_Option, TV_Channel.series_name, TV_Channel.Hight_definition_TV]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",EASY,"SELECT TV_Channel.Package_Option, TV_Channel.series_name FROM TV_Channel WHERE TV_Channel.Hight_definition_TV = 1;","SELECT package_option ,  series_name FROM TV_Channel WHERE hight_definition_TV  =  ""yes""",tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""TV_Channel.Package_Option"" and ""TV_Channel.series_name"" fields, as the question asks for these details. 2. Condition Structure: Use a WHERE clause to filter for TV channels that have high definition TV, i.e., where ""TV_Channel.Hight_definition_TV"" is true or equivalent. 3. Join Structure: No JOIN is required since all the necessary information is available in the ""TV_Channel"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving specific fields based on a condition.",[],"[('Sky Famiglia + Sky HD', 'MTV Live HD')]",,0.0,
What is the semester which most student registered in? Show both the name and the id.,"[Semesters.semester_id, Semesters.semester_name, Student_Enrolment.semester_id = Semesters.semester_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Semesters.semester_id, Semesters.semester_name FROM Semesters JOIN Student_Enrolment ON Student_Enrolment.semester_id = Semesters.semester_id GROUP BY Semesters.semester_id, Semesters.semester_name ORDER BY COUNT(Student_Enrolment.student_id) DESC LIMIT 1;","SELECT T1.semester_name ,  T1.semester_id FROM Semesters AS T1 JOIN Student_Enrolment AS T2 ON T1.semester_id  =  T2.semester_id GROUP BY T1.semester_id ORDER BY count(*) DESC LIMIT 1",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Semesters.semester_id"" and ""Semesters.semester_name."" Use COUNT to count the number of students registered in each semester. 2. Condition Structure: No specific filtering condition is required, as we are interested in all semesters. 3. Join Structure: Use a JOIN between ""Semesters"" and ""Student_Enrolment"" on ""Student_Enrolment.semester_id = Semesters.semester_id"" to associate each student enrollment with its respective semester. 4. Aggregation Structure: Use COUNT to count the number of students registered in each semester, GROUP BY ""Semesters.semester_id"" and ""Semesters.semester_name"" to group results by semester, and ORDER BY the count in descending order to find the semester with the most registrations. Use LIMIT 1 to return only the semester with the highest count.","[(2, 'summer 2010')]","[('summer 2010', 2)]",,1.0,
Show the date and id of the transcript with at least 2 course results.,"[Transcripts.transcript_date, Transcripts.transcript_id, Transcript_Contents.transcript_id = Transcripts.transcript_id, Transcript_Contents.student_course_id]","Table Addresses, columns = [*,address_id,line_1,line_2,line_3,city,zip_postcode,state_province_county,country,other_address_details]
Table Courses, columns = [*,course_id,course_name,course_description,other_details]
Table Degree_Programs, columns = [*,degree_program_id,department_id,degree_summary_name,degree_summary_description,other_details]
Table Departments, columns = [*,department_id,department_name,department_description,other_details]
Table Sections, columns = [*,section_id,course_id,section_name,section_description,other_details]
Table Semesters, columns = [*,semester_id,semester_name,semester_description,other_details]
Table Student_Enrolment, columns = [*,student_enrolment_id,degree_program_id,semester_id,student_id,other_details]
Table Student_Enrolment_Courses, columns = [*,student_course_id,course_id,student_enrolment_id]
Table Students, columns = [*,student_id,current_address_id,permanent_address_id,first_name,middle_name,last_name,cell_mobile_number,email_address,ssn,date_first_registered,date_left,other_student_details]
Table Transcript_Contents, columns = [*,student_course_id,transcript_id]
Table Transcripts, columns = [*,transcript_id,transcript_date,other_details]
","Foreign_keys = [Degree_Programs.department_id = Departments.department_id,Sections.course_id = Courses.course_id,Students.permanent_address_id = Addresses.address_id,Students.current_address_id = Addresses.address_id,Student_Enrolment.student_id = Students.student_id,Student_Enrolment.semester_id = Semesters.semester_id,Student_Enrolment.degree_program_id = Degree_Programs.degree_program_id,Student_Enrolment_Courses.student_enrolment_id = Student_Enrolment.student_enrolment_id,Student_Enrolment_Courses.course_id = Courses.course_id,Transcript_Contents.transcript_id = Transcripts.transcript_id,Transcript_Contents.student_course_id = Student_Enrolment_Courses.student_course_id]
",NON-NESTED,"SELECT Transcripts.transcript_date, Transcripts.transcript_id FROM Transcripts JOIN Transcript_Contents ON Transcript_Contents.transcript_id = Transcripts.transcript_id GROUP BY Transcripts.transcript_id, Transcripts.transcript_date HAVING COUNT(Transcript_Contents.student_course_id) >= 2;","SELECT T2.transcript_date ,  T1.transcript_id FROM Transcript_Contents AS T1 JOIN Transcripts AS T2 ON T1.transcript_id  =  T2.transcript_id GROUP BY T1.transcript_id HAVING count(*)  >=  2",student_transcripts_tracking,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Transcripts.transcript_date"" and ""Transcripts.transcript_id."" 2. Condition Structure: Use a HAVING clause to filter for transcripts that have at least 2 course results. This requires counting the number of ""Transcript_Contents.student_course_id"" entries for each transcript. 3. Join Structure: Use a JOIN between ""Transcripts"" and ""Transcript_Contents"" on ""Transcript_Contents.transcript_id"" to associate each transcript with its course results. 4. Aggregation Structure: Use COUNT on ""Transcript_Contents.student_course_id"" to count the number of course results for each transcript, and filter with HAVING to include only those with at least 2 results.","[('2013-06-30 13:01:40', 5), ('2010-12-13 10:55:15', 6), ('1975-05-06 12:04:47', 8), ('1998-11-22 12:18:29', 15)]","[('2013-06-30 13:01:40', 5), ('2010-12-13 10:55:15', 6), ('1975-05-06 12:04:47', 8), ('1998-11-22 12:18:29', 15)]",,1.0,
What is name of the country that speaks the largest number of languages?,"[country.Name, countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT country.Name FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode GROUP BY country.Code ORDER BY COUNT(countrylanguage.Language) DESC LIMIT 1;,SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name ORDER BY COUNT(*) DESC LIMIT 1,world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the country. Use COUNT to determine the number of languages spoken in each country. 2. Condition Structure: No specific filtering condition is required, as we are interested in all countries. 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables on ""country.Code = countrylanguage.CountryCode"" to associate each country with its languages. 4. Aggregation Structure: Use COUNT on ""countrylanguage.Language"" to count the number of languages spoken in each country. Use GROUP BY to group the results by country. Use ORDER BY in descending order to rank countries by the number of languages spoken, and LIMIT 1 to select the country with the largest number of languages.","[('Canada',)]","[('United States',)]",,0.0,
How many countries have governments that are republics?,"[country.Name, country.GovernmentForm]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT COUNT(*) FROM country WHERE country.GovernmentForm LIKE '%Republic%';,"SELECT count(*) FROM country WHERE GovernmentForm  =  ""Republic""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the number of countries. Use COUNT to calculate the total number of countries with a specific government form. 2. Condition Structure: Use a WHERE clause to filter for countries where the ""GovernmentForm"" is 'Republic'. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use COUNT to count the number of countries that meet the specified condition.","[(143,)]","[(122,)]",,0.0,
What is the continent name which Anguilla belongs to?,"[country.Continent,city.Name,city.CountryCode = country.Code,Anguilla]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT country.Continent FROM city JOIN country ON city.CountryCode = country.Code WHERE city.Name = 'Anguilla';,"SELECT Continent FROM country WHERE Name  =  ""Anguilla""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Continent"" field, as the question asks for the continent name. 2. Condition Structure: Use a WHERE clause to filter for the city name ""Anguilla."" 3. Join Structure: Use an INNER JOIN between the ""city"" and ""country"" tables on the ""city.CountryCode = country.Code"" foreign key to link the city with its corresponding country. 4. Aggregation Structure: No aggregation is needed since we are retrieving a single value.",[],"[('North America',)]",,0.0,
Which regions speak Dutch or English?,"[country.Region, countrylanguage.Language, countrylanguage.CountryCode = country.Code, Dutch, English]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT DISTINCT country.Region FROM countrylanguage JOIN country ON countrylanguage.CountryCode = country.Code WHERE countrylanguage.Language = 'Dutch' OR countrylanguage.Language = 'English';,"SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"" OR T2.Language  =  ""Dutch""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""country.Region"" values. These regions are associated with countries where the specified languages (Dutch or English) are spoken. 2. Condition Structure: Use a WHERE clause to filter for records where ""countrylanguage.Language"" is either 'Dutch' or 'English.' 3. Join Structure: Use an INNER JOIN between the ""countrylanguage"" and ""country"" tables on ""countrylanguage.CountryCode = country.Code"" to associate languages with their respective countries and regions. 4. Aggregation Structure: Use DISTINCT to ensure that each region is listed only once in the result.","[('Caribbean',), ('Polynesia',), ('Australia and New Zealand',), ('Western Europe',), ('Middle East',), ('Central America',), ('North America',), ('Southeast Asia',), ('Nordic Countries',), ('South America',), ('British Islands',), ('Southern Europe',), ('Micronesia',), ('Eastern Asia',), ('Southern Africa',), ('Southern and Central Asia',), ('Western Africa',), ('Eastern Africa',), ('Micronesia/Caribbean',), ('Melanesia',)]","[('Caribbean',), ('Polynesia',), ('Australia and New Zealand',), ('Western Europe',), ('Middle East',), ('Central America',), ('North America',), ('Southeast Asia',), ('Nordic Countries',), ('South America',), ('British Islands',), ('Southern Europe',), ('Micronesia',), ('Eastern Asia',), ('Southern Africa',), ('Southern and Central Asia',), ('Western Africa',), ('Eastern Africa',), ('Micronesia/Caribbean',), ('Melanesia',)]",,1.0,
"For the countries founded before 1930, what is the total number of distinct official languages?","[country.IndepYear, country.Code, countrylanguage.CountryCode, countrylanguage.IsOfficial, countrylanguage.Language, country.Code = countrylanguage.CountryCode]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT COUNT(DISTINCT countrylanguage.Language) FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.IndepYear < 1930 AND countrylanguage.IsOfficial = 'T';,"SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  ""T""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the distinct official languages. Use COUNT with DISTINCT on ""countrylanguage.Language"" to get the total number of unique official languages. 2. Condition Structure: Use a WHERE clause to filter for countries founded before 1930 (i.e., ""country.IndepYear < 1930"") and where the language is official (""countrylanguage.IsOfficial = 'T'""). 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables based on the relationship ""country.Code = countrylanguage.CountryCode"" to link countries with their languages. 4. Aggregation Structure: Use COUNT with DISTINCT to ensure only unique official languages are counted.","[(40,)]","[(40,)]",,1.0,
What region does Angola belong to and what is its population?,"[country.Region, country.Population, country.Name, country.Code, city.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,"SELECT country.Region, country.Population FROM country WHERE country.Name = 'Angola';","SELECT Population ,  Region FROM country WHERE Name  =  ""Angola""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Region"" and ""country.Population"" for Angola. 2. Condition Structure: Use a WHERE clause to filter for the country with the name ""Angola"". 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields for a single country.","[('Central Africa', 12878000)]","[(12878000, 'Central Africa')]",,1.0,
What is average life expectancy in the countries where English is not the official language?,"[country.LifeExpectancy, country.Code = countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.IsOfficial, English]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT AVG(country.LifeExpectancy) AS avg_life_expectancy FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.Language = 'English' AND countrylanguage.IsOfficial = 'No';,"SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"" AND T2.IsOfficial  =  ""T"")",world_1,1. Sequential Structure: Start with the SELECT clause to calculate the average life expectancy. Use the FROM clause to specify the country table and JOIN it with the countrylanguage table to connect countries with their languages. Apply a WHERE clause to filter for countries where English is not the official language. 2. Condition Structure: Use the WHERE clause to filter for records where the language is 'English' and IsOfficial is 'No'. 3. Join Structure: Use an INNER JOIN between the country and countrylanguage tables based on the CountryCode and Code fields to link countries with their language data. 4. Aggregation Structure: Use the AVG function to calculate the average life expectancy for the filtered countries.,"[(None,)]","[(65.4827027027027,)]",,0.0,
Give the names of nations that speak both English and French.,"[country.Name, countrylanguage.Language, countrylanguage.CountryCode = country.Code, English, French]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT country.Name FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Code IN ( SELECT CountryCode FROM countrylanguage WHERE Language = 'English' ) AND country.Code IN ( SELECT CountryCode FROM countrylanguage WHERE Language = 'French' );,"SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""French""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of nations. Use the FROM clause to specify the country table and JOIN it with the countrylanguage table to link countries with their languages. Apply a WHERE clause to filter for countries that speak both English and French. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the country has entries for both English and French in the countrylanguage table. 3. Join Structure: Use an INNER JOIN between the country and countrylanguage tables based on the CountryCode and Code fields to connect countries with their languages. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Monaco',), ('Monaco',), ('Monaco',), ('Monaco',), ('Seychelles',), ('Seychelles',), ('Seychelles',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('Virgin Islands, U.S.',), ('Virgin Islands, U.S.',), ('Virgin Islands, U.S.',), ('Vanuatu',), ('Vanuatu',), ('Vanuatu',)]","[('Canada',), ('Monaco',), ('Seychelles',), ('United States',), ('Vanuatu',), ('Virgin Islands, U.S.',)]",,1.0,
Return the birth date of the poker player with the lowest earnings.,"[poker_player.Earnings, poker_player.People_ID, people.Birth_Date, poker_player.People_ID = people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,SELECT people.Birth_Date FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID ORDER BY poker_player.Earnings ASC LIMIT 1;,SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""people.Birth_Date"" of the poker player. Use ORDER BY on ""poker_player.Earnings"" in ascending order to rank players by their earnings. Use LIMIT 1 to get the player with the lowest earnings. 2. Condition Structure: No specific filtering condition is required since we are only interested in the player with the lowest earnings. 3. Join Structure: Use an INNER JOIN between the ""poker_player"" and ""people"" tables on the ""People_ID"" column to link poker players with their personal details. 4. Aggregation Structure: No aggregation is needed as we are only retrieving a single record.","[('August 8, 1986',)]","[('August 8, 1986',)]",,1.0,
What are the distinct states and create time of all votes?,"[VOTES.state, VOTES.created]","Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",EASY,"SELECT DISTINCT VOTES.state, VOTES.created FROM VOTES;","SELECT DISTINCT state ,  created FROM votes",voter_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct states and the creation time of all votes. 2. Condition Structure: No specific filtering condition is required as the query asks for all votes. 3. Join Structure: No JOIN is necessary since the required information is available within the ""VOTES"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving distinct combinations of states and creation times.","[('NY', '2018-03-09 19:03:21'), ('NY', '2018-03-09 19:03:36'), ('CA', '2018-03-09 19:03:39'), ('NJ\n', '2018-03-09 19:03:40')]","[('NY', '2018-03-09 19:03:21'), ('NY', '2018-03-09 19:03:36'), ('CA', '2018-03-09 19:03:39'), ('NJ\n', '2018-03-09 19:03:40')]",,1.0,
Give the mean GNP and total population of nations which are considered US territory.,"[country.GNP, country.Population, country.Name, country.Code, city.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,"SELECT AVG(country.GNP) AS mean_gnp, SUM(country.Population) AS total_population FROM country WHERE country.Name LIKE '%United States%';","SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  ""US Territory""",world_1,"1. Sequential Structure: Start with the SELECT clause to calculate the mean GNP and total population. Use the AVG function for the mean GNP and SUM function for the total population. 2. Condition Structure: Use a WHERE clause to filter for nations that are considered US territory. This would involve checking the ""country.Name"" for relevant entries (e.g., ""United States"" or related territories). 3. Join Structure: No JOIN is required since all the necessary data is in the ""country"" table. 4. Aggregation Structure: Use AVG for the mean GNP and SUM for the total population to aggregate the data.","[(4255350.0, 278357000)]","[(510.3333333333333, 329000)]",,0.0,
What languages are only used by a single country with a republic government?,"[countrylanguage.Language, countrylanguage.CountryCode, country.Code, country.GovernmentForm, city.CountryCode = country.Code, countrylanguage.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT countrylanguage.Language FROM countrylanguage JOIN country ON countrylanguage.CountryCode = country.Code WHERE country.GovernmentForm LIKE '%republic%' GROUP BY countrylanguage.Language HAVING COUNT(countrylanguage.CountryCode) = 1;,"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  ""Republic"" GROUP BY T2.Language HAVING COUNT(*)  =  1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct languages from the countrylanguage table. Use the FROM clause to specify the countrylanguage and country tables. Apply a WHERE clause to filter for countries with a ""republic"" government form. Use GROUP BY to group by language and HAVING to filter languages used by only one country. 2. Condition Structure: Use the WHERE clause to filter for countries with a ""republic"" government form. Use the HAVING clause to ensure that the language is used by only one country. 3. Join Structure: Use an INNER JOIN between the countrylanguage and country tables based on the CountryCode and Code fields to connect languages with their respective countries. 4. Aggregation Structure: Use COUNT(*) in the HAVING clause to count the number of countries using each language and filter for languages used by only one country.","[('Abhyasi',), ('Acholi',), ('Adja',), ('Aizo',), ('Ambo',), ('Amhara',), ('Ami',), ('Ane',), ('Arabic-French',), ('Arabic-French-English',), ('Araucan',), ('Asami',), ('Assyrian',), ('Atayal',), ('Avarian',), ('Bajad',), ('Bakhtyari',), ('Balante',), ('Bali',), ('Bambara',), ('Bamileke-bamum',), ('Banda',), ('Banja',), ('Bari',), ('Bariba',), ('Bashkir',), ('Bassa',), ('Batakki',), ('Beja',), ('Bemba',), ('Berberi',), ('Bhojpuri',), ('Bicol',), ('Bilin',), ('Bislama',), ('Boa',), ('Brahui',), ('Bubi',), ('Bugi',), ('Bullom-sherbro',), ('Bura',), ('Burmese',), ('Buryat',), ('Busansi',), ('Cakchiquel',), ('Caprivi',), ('Cebuano',), ('Chaga and Pare',), ('Chakma',), ('Chechen',), ('Chewa',), ('Chichewa',), ('Chilluk',), ('Chin',), ('Chuabo',), ('Chuvash',), ('Comorian',), ('Comorian-Arabic',), ('Comorian-French',), ('Comorian-Swahili',), ('Comorian-madagassi',), ('Cuna',), ('Czech and Moravian',), ('Dagara',), ('Dariganga',), ('Dhivehi',), ('Dinka',), ('Dong',), ('Dorbet',), ('Duala',), ('Dyula',), ('Edo',), ('Embera',), ('Fijian',), ('Fon',), ('Friuli',), ('Fur',), ('Ga-adangme',), ('Gagauzi',), ('Ganda',), ('Garifuna',), ('Garo',), ('Gbaya',), ('Georgiana',), ('Gilaki',), ('Gio',), ('Gisu',), ('Goajiro',), ('Gogo',), ('Gorane',), ('Grebo',), ('Guaymí',), ('Gujarati',), ('Gur',), ('Gurage',), ('Gusii',), ('Ha',), ('Hadareb',), ('Hadjarai',), ('Haiti Creole',), ('Hakka',), ('Hassaniya',), ('Haya',), ('Hebrew',), ('Hehet',), ('Herero',), ('Hiligaynon',), ('Hindko',), ('Hui',), ('Ibibio',), ('Ibo',), ('Icelandic',), ('Ijo',), ('Ilocano',), ('Irish',), ('Javanese',), ('Kabyé',), ('Kachin',), ('Kalenjin',), ('Kamba',), ('Kanem-bornu',), ('Kannada',), ('Karakalpak',), ('Karen',), ('Kavango',), ('Kayah',), ('Kekchí',), ('Khasi',), ('Khmer',), ('Khoekhoe',), ('Kiga',), ('Kikuyu',), ('Kirgiz',), ('Kirundi',), ('Kissi',), ('Kono-vai',), ('Kosrean',), ('Kotokoli',), ('Kuranko',), ('Lango',), ('Lao',), ('Lao-Soung',), ('Latvian',), ('Lezgian',), ('Limba',), ('Lotuko',), ('Lozi',), ('Luba',), ('Luchazi',), ('Lugbara',), ('Luguru',), ('Luhya',), ('Luimbe-nganguela',), ('Luo',), ('Luri',), ('Luvale',), ('Madura',), ('Maguindanao',), ('Maka',), ('Makonde',), ('Makua',), ('Malagasy',), ('Malajalam',), ('Maltese',), ('Mam',), ('Man',), ('Mandara',), ('Mandarin Chinese',), ('Mandjia',), ('Mandyako',), ('Mano',), ('Mantšu',), ('Maranao',), ('Marendje',), ('Mari',), ('Marma',), ('Marshallese',), ('Masai',), ('Masana',), ('Mayo-kebbi',), ('Mazandarani',), ('Mboshi',), ('Mbum',), ('Mbundu',), ('Mende',), ('Meru',), ('Min',), ('Minangkabau',), ('Mixed Languages',), ('Mixtec',), ('Moba',), ('Mon',), ('Mon-khmer',), ('Mongo',), ('Moravian',), ('Mordva',), ('Mortlock',), ('Mpongwe',), ('Muong',), ('Nahua',), ('Nama',), ('Naudemba',), ('Nauru',), ('Ngala and Bangi',), ('Ngbaka',), ('Ngoni',), ('Nkole',), ('Northsotho',), ('Nsenga',), ('Nubian Languages',), ('Nuer',), ('Nung',), ('Nyakusa',), ('Nyamwesi',), ('Nyaneka-nkhumbi',), ('Nyika',), ('Náhuatl',), ('Orija',), ('Oromo',), ('Osseetti',), ('Otomí',), ('Ouaddai',), ('Ovambo',), ('Ovimbundu',), ('Paiwan',), ('Palau',), ('Pampango',), ('Pangasinan',), ('Pashto',), ('Philippene Languages',), ('Pilipino',), ('Pohnpei',), ('Punu',), ('Punu-sira-nzebi',), ('Puyi',), ('Quiché',), ('Rakhine',), ('Rapa nui',), ('Ronga',), ('Rundi',), ('Saame',), ('Saho',), ('Sango',), ('Santhali',), ('Saraiki',), ('Sardinian',), ('Sena',), ('Senufo and Minianka',), ('Serer',), ('Seselwa',), ('Shambala',), ('Shan',), ('Sidamo',), ('Silesiana',), ('Sinaberberi',), ('Sindhi',), ('Singali',), ('Soga',), ('Somba',), ('Songhai',), ('Songhai-zerma',), ('Soqutri',), ('Southern Slavic Languages',), ('Southsotho',), ('Sranantonga',), ('Sumo',), ('Sunda',), ('Susu',), ('Swazi',), ('Swedish',), ('Tagalog',), ('Tandjile',), ('Telugu',), ('Temne',), ('Teso',), ('Tho',), ('Tibetan',), ('Tigre',), ('Tikar',), ('Tiv',), ('Tongan',), ('Tripuri',), ('Trukese',), ('Tswa',), ('Tujia',), ('Tukulor',), ('Turkana',), ('Udmur',), ('Uighur',), ('Ukrainian and Russian',), ('Venda',), ('Walaita',), ('Waray-waray',), ('Warrau',), ('Watyi',), ('Wolea',), ('Xhosa',), ('Yao',), ('Yap',), ('Yi',), ('Yucatec',), ('Zapotec',), ('Zenaga',), ('Zhuang',), ('Zulu',), ('[South]Mande',)]","[('Abhyasi',), ('Acholi',), ('Adja',), ('Aizo',), ('Ambo',), ('Amhara',), ('Ami',), ('Ane',), ('Arabic-French',), ('Arabic-French-English',), ('Araucan',), ('Assyrian',), ('Atayal',), ('Bajad',), ('Balante',), ('Bali',), ('Balochi',), ('Bambara',), ('Bamileke-bamum',), ('Banda',), ('Banja',), ('Bariba',), ('Bassa',), ('Batakki',), ('Bemba',), ('Bengali',), ('Berberi',), ('Bhojpuri',), ('Bicol',), ('Bilin',), ('Bislama',), ('Boa',), ('Brahui',), ('Bubi',), ('Bugi',), ('Bullom-sherbro',), ('Burmese',), ('Buryat',), ('Busansi',), ('Cakchiquel',), ('Caprivi',), ('Cebuano',), ('Chaga and Pare',), ('Chakma',), ('Chewa',), ('Chichewa',), ('Chin',), ('Chuabo',), ('Comorian',), ('Comorian-Arabic',), ('Comorian-French',), ('Comorian-Swahili',), ('Comorian-madagassi',), ('Cuna',), ('Czech',), ('Czech and Moravian',), ('Dagara',), ('Dariganga',), ('Dhivehi',), ('Dorbet',), ('Duala',), ('Dyula',), ('Embera',), ('Fijian',), ('Fon',), ('Friuli',), ('Ga-adangme',), ('Gagauzi',), ('Ganda',), ('Garifuna',), ('Garo',), ('Gbaya',), ('Georgiana',), ('Gio',), ('Gisu',), ('Gogo',), ('Gorane',), ('Grebo',), ('Guaymí',), ('Gur',), ('Gurage',), ('Gusii',), ('Ha',), ('Hadareb',), ('Hadjarai',), ('Haiti Creole',), ('Hakka',), ('Hassaniya',), ('Hausa',), ('Haya',), ('Hebrew',), ('Hehet',), ('Herero',), ('Hiligaynon',), ('Hindko',), ('Icelandic',), ('Ilocano',), ('Irish',), ('Javanese',), ('Kabyé',), ('Kachin',), ('Kalenjin',), ('Kamba',), ('Kanem-bornu',), ('Kanuri',), ('Karakalpak',), ('Karen',), ('Kavango',), ('Kayah',), ('Kekchí',), ('Khasi',), ('Khoekhoe',), ('Kiga',), ('Kikuyu',), ('Kirgiz',), ('Kirundi',), ('Kissi',), ('Kono-vai',), ('Korean',), ('Kotokoli',), ('Kuranko',), ('Lango',), ('Lao',), ('Lao-Soung',), ('Latvian',), ('Limba',), ('Lozi',), ('Luba',), ('Luchazi',), ('Lugbara',), ('Luguru',), ('Luhya',), ('Luimbe-nganguela',), ('Luo',), ('Luvale',), ('Madura',), ('Maguindanao',), ('Maka',), ('Makonde',), ('Makua',), ('Maltese',), ('Mam',), ('Mandara',), ('Mandarin Chinese',), ('Mandjia',), ('Mandyako',), ('Mano',), ('Maranao',), ('Marathi',), ('Marendje',), ('Marma',), ('Marshallese',), ('Masai',), ('Masana',), ('Mayo-kebbi',), ('Mboshi',), ('Mbum',), ('Mbundu',), ('Mende',), ('Meru',), ('Min',), ('Minangkabau',), ('Mixed Languages',), ('Moba',), ('Mon',), ('Mon-khmer',), ('Mongo',), ('Mongolian',), ('Moravian',), ('Mpongwe',), ('Nahua',), ('Nama',), ('Naudemba',), ('Nauru',), ('Ngala and Bangi',), ('Ngbaka',), ('Ngoni',), ('Nkole',), ('Northsotho',), ('Nsenga',), ('Nyakusa',), ('Nyamwesi',), ('Nyaneka-nkhumbi',), ('Nyika',), ('Oromo',), ('Osseetti',), ('Ouaddai',), ('Ovambo',), ('Ovimbundu',), ('Paiwan',), ('Palau',), ('Pampango',), ('Pangasinan',), ('Pashto',), ('Persian',), ('Philippene Languages',), ('Pilipino',), ('Punjabi',), ('Punu',), ('Punu-sira-nzebi',), ('Quiché',), ('Rakhine',), ('Rapa nui',), ('Ronga',), ('Rundi',), ('Saame',), ('Saho',), ('Sango',), ('Santhali',), ('Saraiki',), ('Sardinian',), ('Sena',), ('Senufo and Minianka',), ('Serer',), ('Seselwa',), ('Shambala',), ('Shan',), ('Sidamo',), ('Silesiana',), ('Sinaberberi',), ('Sindhi',), ('Singali',), ('Soga',), ('Somba',), ('Songhai',), ('Songhai-zerma',), ('Soqutri',), ('Southsotho',), ('Sranantonga',), ('Sumo',), ('Sunda',), ('Susu',), ('Swazi',), ('Swedish',), ('Tandjile',), ('Temne',), ('Teso',), ('Thai',), ('Tigre',), ('Tikar',), ('Tongan',), ('Tripuri',), ('Tswa',), ('Tukulor',), ('Turkana',), ('Turkmenian',), ('Ukrainian and Russian',), ('Urdu',), ('Venda',), ('Walaita',), ('Waray-waray',), ('Watyi',), ('Xhosa',), ('Yao',), ('Zande',), ('Zenaga',), ('Zulu',), ('[South]Mande',)]",,1.0,
"Show names of people whose nationality is not ""Russia"".","[people.Name, people.Nationality]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT people.Name FROM people WHERE people.Nationality != 'Russia';,"SELECT Name FROM people WHERE Nationality != ""Russia""",poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""people.Name"" of individuals whose nationality is not ""Russia"". 2. Condition Structure: Use a WHERE clause to filter for records where ""people.Nationality"" is not equal to ""Russia"". 3. Join Structure: No JOIN is required since all necessary information is in the ""people"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.","[('Teodor Salparov',)]","[('Teodor Salparov',)]",,1.0,
What are the names of nations where both English and French are official languages?,"[country.Name, country.Code = countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.IsOfficial, English, French]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT country.Name FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.IsOfficial = 'T' AND countrylanguage.Language IN ('English', 'French') GROUP BY country.Name HAVING COUNT(DISTINCT countrylanguage.Language) = 2;","SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"" AND T2.IsOfficial  =  ""T"" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""French"" AND T2.IsOfficial  =  ""T""",world_1,1. Sequential Structure: Start with the SELECT clause to retrieve the names of nations. Use the FROM clause to specify the country table and JOIN it with the countrylanguage table to link countries with their languages. Apply a WHERE clause to filter for countries where both English and French are official languages. 2. Condition Structure: Use the WHERE clause with conditions to check for the presence of both English and French as official languages. This can be achieved by using a subquery or grouping and filtering. 3. Join Structure: Use an INNER JOIN between the country and countrylanguage tables based on the CountryCode and Code fields to connect countries with their languages. 4. Aggregation Structure: Use GROUP BY to group records by country and apply a HAVING clause to ensure that both English and French are official languages for the same country.,"[('Canada',), ('Seychelles',), ('Vanuatu',)]","[('Canada',), ('Seychelles',), ('Vanuatu',)]",,1.0,
How many countries speak both English and Dutch?,"[countrylanguage.CountryCode, countrylanguage.Language, country.Code, countrylanguage.CountryCode = country.Code, English, Dutch]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT COUNT(*) FROM ( SELECT CountryCode FROM countrylanguage WHERE Language = 'English' INTERSECT SELECT CountryCode FROM countrylanguage WHERE Language = 'Dutch' ) AS common_countries;,"SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""Dutch"")",world_1,"1. Sequential Structure: Start with the SELECT clause to count the number of countries. Use the FROM clause to specify the countrylanguage table. Apply a WHERE clause to filter for countries that speak both English and Dutch. 2. Condition Structure: Use a subquery to identify countries that speak English and another subquery to identify countries that speak Dutch. Use an INTERSECT operation to find the countries that appear in both subqueries. 3. Join Structure: Not required, as all necessary data is in the countrylanguage table. 4. Aggregation Structure: Use COUNT to count the number of countries that meet the condition of speaking both English and Dutch.","[(3,)]","[(3,)]",,1.0,
List the area codes in which voters voted both for the contestant 'Tabatha Gehling' and the contestant 'Kelly Clauss'.,"[AREA_CODE_STATE.area_code,CONTESTANTS.contestant_name,VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state,Tabatha Gehling,Kelly Clauss]","Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",NESTED,"SELECT DISTINCT AREA_CODE_STATE.area_code FROM VOTES JOIN CONTESTANTS ON VOTES.contestant_number = CONTESTANTS.contestant_number JOIN AREA_CODE_STATE ON VOTES.state = AREA_CODE_STATE.state WHERE CONTESTANTS.contestant_name IN ('Tabatha Gehling', 'Kelly Clauss') GROUP BY AREA_CODE_STATE.area_code HAVING COUNT(DISTINCT CONTESTANTS.contestant_name) = 2;",SELECT T3.area_code FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number JOIN area_code_state AS T3 ON T2.state  =  T3.state WHERE T1.contestant_name  =  'Tabatha Gehling' INTERSECT SELECT T3.area_code FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number JOIN area_code_state AS T3 ON T2.state  =  T3.state WHERE T1.contestant_name  =  'Kelly Clauss',voter_1,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct area codes. Use the FROM clause to specify the VOTES table and join it with the CONTESTANTS and AREA_CODE_STATE tables to connect votes with contestant names and area codes. Apply a WHERE clause to filter votes for the contestants 'Tabatha Gehling' and 'Kelly Clauss'. Use GROUP BY to group by area codes and apply a HAVING clause to ensure that both contestants were voted for in the same area code. 2. Condition Structure: Use the WHERE clause to filter votes for the contestants 'Tabatha Gehling' and 'Kelly Clauss'. Use the HAVING clause to ensure that both contestants are present in the grouped area codes. 3. Join Structure: Use INNER JOINs between VOTES, CONTESTANTS, and AREA_CODE_STATE tables. Join VOTES with CONTESTANTS on contestant_number to get contestant names, and join VOTES with AREA_CODE_STATE on state to get area codes. 4. Aggregation Structure: Use COUNT(DISTINCT contestant_name) in the HAVING clause to ensure that both contestants were voted for in the same area code.","[(212,), (315,), (347,), (516,), (518,), (585,), (607,), (631,), (646,), (716,), (718,), (845,), (914,), (917,)]","[(212,), (315,), (347,), (516,), (518,), (585,), (607,), (631,), (646,), (716,), (718,), (845,), (914,), (917,)]",,1.0,
Give the total surface area covered by countries in Asia or Europe.,"[country.SurfaceArea, country.Continent]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT SUM(country.SurfaceArea) AS total_surface_area FROM country WHERE country.Continent = 'Asia' OR country.Continent = 'Europe';,"SELECT sum(SurfaceArea) FROM country WHERE Continent  =  ""Asia"" OR Continent  =  ""Europe""",world_1,"1. Sequential Structure: Start with the SELECT clause to calculate the total surface area. Use the SUM function on ""country.SurfaceArea"" to compute the total. 2. Condition Structure: Use a WHERE clause to filter for countries in the continents ""Asia"" or ""Europe"". 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use the SUM function to aggregate the surface area values for the specified continents.","[(54930138.9,)]","[(54930138.9,)]",,1.0,
What is the language that is used by the largest number of Asian nations?,"[countrylanguage.Language, country.Continent, country.Code = countrylanguage.CountryCode, Asia]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT countrylanguage.Language FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Continent = 'Asia' GROUP BY countrylanguage.Language ORDER BY COUNT(country.Code) DESC LIMIT 1;,"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Continent  =  ""Asia"" GROUP BY T2.Language ORDER BY COUNT (*) DESC LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countrylanguage.Language."" Use COUNT to determine the number of Asian nations using each language. 2. Condition Structure: Use a WHERE clause to filter for countries in the ""Asia"" continent. 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables on ""country.Code = countrylanguage.CountryCode"" to associate languages with their respective countries. 4. Aggregation Structure: Use GROUP BY on ""countrylanguage.Language"" to group the results by language. Use COUNT to count the number of Asian nations using each language, and ORDER BY in descending order to rank languages by the number of nations. Use LIMIT 1 to get the language used by the largest number of Asian nations.","[('Arabic',)]","[('Arabic',)]",,1.0,
What is the most common nationality of people?,[people.Nationality],"Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,"SELECT people.Nationality, COUNT(*) AS COUNT FROM people GROUP BY people.Nationality ORDER BY COUNT DESC LIMIT 1;",SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1,poker_player,"1. Sequential Structure: Begin with the SELECT clause to specify the nationality and the count of occurrences for each nationality. 2. Aggregation Structure: Use COUNT to calculate the number of occurrences of each nationality. 3. Grouping Structure: Use GROUP BY on ""people.Nationality"" to group the results by nationality. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank nationalities by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common nationality. 6. Join Structure: No JOIN is required since all necessary data is within the ""people"" table.","[('Russia', 6)]","[('Russia',)]",,1.0,
Give the mean life expectancy of countries in which English is not the official language.,"[country.LifeExpectancy, country.Code = countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.IsOfficial]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT AVG(country.LifeExpectancy) AS mean_life_expectancy FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.Language = 'English' AND countrylanguage.IsOfficial = 'No';,"SELECT avg(LifeExpectancy) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"" AND T2.IsOfficial  =  ""T"")",world_1,1. Sequential Structure: Start with the SELECT clause to calculate the mean life expectancy using the AVG function. Use the FROM clause to specify the country table and JOIN it with the countrylanguage table to link countries with their languages. Apply a WHERE clause to filter for countries where English is not the official language. 2. Condition Structure: Use the WHERE clause to filter for rows where the language is 'English' and IsOfficial is 'No'. 3. Join Structure: Use an INNER JOIN between the country and countrylanguage tables based on the CountryCode and Code fields to connect countries with their language data. 4. Aggregation Structure: Use the AVG function to calculate the mean life expectancy of the filtered countries.,"[(None,)]","[(65.4827027027027,)]",,0.0,
What are the names of people who are not from Russia?,"[people.Name, people.Nationality, poker_player.People_ID = people.People_ID, Russia]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NESTED,SELECT Name FROM people WHERE Nationality != 'Russia';,"SELECT Name FROM people WHERE Nationality != ""Russia""",poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of people. Use the FROM clause to specify the people table. Apply a WHERE clause to filter out individuals whose nationality is 'Russia'. 2. Condition Structure: Use the WHERE clause to exclude records where the nationality is 'Russia'. 3. Join Structure: Not required, as the data needed is only in the people table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Teodor Salparov',)]","[('Teodor Salparov',)]",,1.0,
List the final tables made and the best finishes of poker players.,"[poker_player.Final_Table_Made, poker_player.Best_Finish]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,"SELECT poker_player.Final_Table_Made, poker_player.Best_Finish FROM poker_player;","SELECT Final_Table_Made ,  Best_Finish FROM poker_player",poker_player,"1. Sequential Structure: Start with the SELECT clause to specify the fields ""poker_player.Final_Table_Made"" and ""poker_player.Best_Finish"" as required by the question. 2. Condition Structure: No specific filtering condition is needed since the question asks for all poker players' final tables made and best finishes. 3. Join Structure: No JOIN is required because all the necessary information is available in the ""poker_player"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the specified fields.","[(42.0, 1.0), (10.0, 2.0), (21.0, 1.0), (19.0, 2.0), (26.0, 3.0)]","[(42.0, 1.0), (10.0, 2.0), (21.0, 1.0), (19.0, 2.0), (26.0, 3.0)]",,1.0,
Give average earnings of poker players who are taller than 200.,"[poker_player.Earnings,people.Height,poker_player.People_ID = people.People_ID,200]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,SELECT AVG(poker_player.Earnings) FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID WHERE people.Height > 200;,SELECT avg(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Height  >  200,poker_player,"1. Sequential Structure: Start with the SELECT clause to calculate the average earnings of poker players. Use the AVG function on the ""poker_player.Earnings"" field. 2. Condition Structure: Apply a WHERE clause to filter for poker players whose height is greater than 200. This requires accessing the ""people.Height"" field. 3. Join Structure: Use an INNER JOIN to combine the ""poker_player"" table with the ""people"" table based on the foreign key relationship ""poker_player.People_ID = people.People_ID."" 4. Aggregation Structure: Use the AVG function to compute the average earnings of the filtered poker players.","[(309445.0,)]","[(309445.0,)]",,1.0,
What is last date created of votes from the state 'CA'?,"[VOTES.created, VOTES.state, 'CA']","Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",EASY,SELECT MAX(VOTES.created) AS last_date FROM VOTES WHERE VOTES.state = 'CA';,SELECT max(created) FROM votes WHERE state  =  'CA',voter_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the last date created of votes from the state 'CA'. Use the MAX function to find the latest date in the ""VOTES.created"" column. 2. Condition Structure: Use a WHERE clause to filter votes where ""VOTES.state"" is 'CA'. 3. Join Structure: No JOIN is required since all necessary information is in the ""VOTES"" table. 4. Aggregation Structure: Use the MAX function to determine the latest date in the ""VOTES.created"" column for the specified state.","[('2018-03-09 19:03:39',)]","[('2018-03-09 19:03:39',)]",,1.0,
How many distinct nationalities are there?,[people.Nationality],"Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT COUNT(DISTINCT people.Nationality) FROM people;,SELECT count(DISTINCT Nationality) FROM people,poker_player,"1. Sequential Structure: Start with the SELECT clause to count the distinct nationalities. 2. Condition Structure: No specific filtering condition is required as we want to count all distinct nationalities. 3. Join Structure: No JOIN is necessary since the required information is available in the ""people"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""people.Nationality"" to count the unique nationalities.","[(2,)]","[(2,)]",,1.0,
What are the nationalities that are shared by at least two people?,"[people.Nationality, people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NESTED,SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(People_ID) >= 2;,SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*)  >=  2,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the nationalities. Use the FROM clause to specify the people table. Apply GROUP BY on the Nationality column to group records by nationality. Use the HAVING clause to filter groups where the count of people sharing the same nationality is at least two. 2. Condition Structure: Use the HAVING clause with COUNT(People_ID) to filter for nationalities shared by at least two people. 3. Join Structure: Not required, as all data is available within the people table. 4. Aggregation Structure: Use COUNT(People_ID) to count the number of people for each nationality and filter based on this count.","[('Russia',)]","[('Russia',)]",,1.0,
List the names of people that are not poker players.,"[people.Name, poker_player.People_ID = people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NESTED,SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player);,SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player),poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of people. Use the FROM clause to specify the people table. Apply a WHERE clause to filter out people who are poker players by ensuring their People_ID is not present in the poker_player table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude people whose People_ID appears in the poker_player table. 3. Join Structure: Not required, as we only need to filter based on the absence of matching People_ID entries in the poker_player table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Roman Bragin',), ('Sergey Grankin',)]","[('Roman Bragin',), ('Sergey Grankin',)]",,1.0,
"What are the create dates, states, and phone numbers of the votes that were for the contestant named 'Tabatha Gehling'?","[VOTES.created, VOTES.state, VOTES.phone_number, VOTES.contestant_number = CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, 'Tabatha Gehling']","Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",NON-NESTED,"SELECT VOTES.created, VOTES.state, VOTES.phone_number FROM VOTES JOIN CONTESTANTS ON VOTES.contestant_number = CONTESTANTS.contestant_number WHERE CONTESTANTS.contestant_name = 'Tabatha Gehling';","SELECT T2.created ,  T2.state ,  T2.phone_number FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number WHERE T1.contestant_name  =  'Tabatha Gehling'",voter_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""VOTES.created,"" ""VOTES.state,"" and ""VOTES.phone_number."" 2. Condition Structure: Use a WHERE clause to filter for votes associated with the contestant named ""Tabatha Gehling."" 3. Join Structure: Use an INNER JOIN between the ""VOTES"" table and the ""CONTESTANTS"" table on ""VOTES.contestant_number = CONTESTANTS.contestant_number"" to link votes to the corresponding contestant. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields without any summarization.","[('2018-03-09 19:03:21', 'NY', 7182887233)]","[('2018-03-09 19:03:21', 'NY', 7182887233)]",,1.0,
Which region is the city Kabul located in?,"[city.Name, city.CountryCode, country.Code = city.CountryCode, country.Region]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT country.Region FROM city JOIN country ON city.CountryCode = country.Code WHERE city.Name = 'Kabul';,"SELECT Region FROM country AS T1 JOIN city AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Name  =  ""Kabul""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Region"" where the city name is ""Kabul."" 2. Condition Structure: Use a WHERE clause to filter for the city with the name ""Kabul."" 3. Join Structure: Use an INNER JOIN between the ""city"" and ""country"" tables on the ""city.CountryCode"" and ""country.Code"" to link the city with its corresponding country. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single value.","[('Southern and Central Asia',)]","[('Southern and Central Asia',)]",,1.0,
What is the money rank of the poker player with the highest earnings?,"[poker_player.Money_Rank, poker_player.Earnings]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NESTED,SELECT Money_Rank FROM poker_player WHERE Earnings = (SELECT MAX(Earnings) FROM poker_player);,SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the money rank of the poker player. Use the FROM clause to specify the poker_player table. Apply a WHERE clause to filter for the poker player with the highest earnings. 2. Condition Structure: Use the WHERE clause with a subquery to identify the poker player with the maximum earnings. The subquery calculates the maximum earnings from the poker_player table. 3. Join Structure: Not required, as all data is available within the poker_player table. 4. Aggregation Structure: Use the MAX function in a subquery to find the highest earnings, which is then used in the filtering condition.","[(58.0,)]","[(58.0,)]",,1.0,
How many different forms of governments are there in Africa?,"[country.GovernmentForm, country.Continent, country.Continent = 'Africa']","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT COUNT(DISTINCT country.GovernmentForm) FROM country WHERE country.Continent = 'Africa';,"SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  ""Africa""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the distinct forms of government in Africa. 2. Condition Structure: Use a WHERE clause to filter for countries where the continent is 'Africa'. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""country.GovernmentForm"" to count the unique forms of government.","[(10,)]","[(10,)]",,1.0,
How many people live in Gelderland district?,"[city.Population, city.District]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT SUM(city.Population) AS total_population FROM city WHERE city.District = 'Gelderland';,"SELECT sum(Population) FROM city WHERE District  =  ""Gelderland""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the total population of people living in the Gelderland district. 2. Condition Structure: Use a WHERE clause to filter for rows where ""city.District"" is equal to 'Gelderland'. 3. Join Structure: No JOIN is required since all necessary information is in the ""city"" table. 4. Aggregation Structure: Use SUM to calculate the total population for the specified district.","[(545548,)]","[(545548,)]",,1.0,
How many type of governments are in Africa?,"[country.GovernmentForm, country.Continent, country.Continent = 'Africa']","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT COUNT(DISTINCT country.GovernmentForm) FROM country WHERE country.Continent = 'Africa';,"SELECT count(DISTINCT GovernmentForm) FROM country WHERE Continent  =  ""Africa""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the distinct types of government forms in Africa. 2. Condition Structure: Use a WHERE clause to filter for countries where the continent is 'Africa'. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""country.GovernmentForm"" to count the unique government forms in Africa.","[(10,)]","[(10,)]",,1.0,
Give the names of poker players who have earnings above 300000.,"[poker_player.Earnings,people.Name,poker_player.People_ID = people.People_ID,300000]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,SELECT people.Name FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID WHERE poker_player.Earnings > 300000;,SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T2.Earnings  >  300000,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""people.Name"" of poker players. 2. Condition Structure: Use a WHERE clause to filter for poker players whose ""poker_player.Earnings"" is greater than 300000. 3. Join Structure: Use an INNER JOIN between the ""poker_player"" and ""people"" tables based on the foreign key relationship ""poker_player.People_ID = people.People_ID"" to link poker players with their names. 4. Aggregation Structure: No aggregation is needed as the query only requires filtering and retrieving names.","[('Aleksey Ostapenko',), ('Maksim Botin',)]","[('Aleksey Ostapenko',), ('Maksim Botin',)]",,1.0,
What are the names of poker players whose earnings is higher than 300000?,"[poker_player.Earnings,people.Name,poker_player.People_ID = people.People_ID,300000]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,SELECT people.Name FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID WHERE poker_player.Earnings > 300000;,SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T2.Earnings  >  300000,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""people.Name"" of poker players. 2. Condition Structure: Use a WHERE clause to filter for poker players whose ""poker_player.Earnings"" is greater than 300000. 3. Join Structure: Use an INNER JOIN between the ""poker_player"" and ""people"" tables based on the foreign key relationship ""poker_player.People_ID = people.People_ID"" to link poker players with their names. 4. Aggregation Structure: No aggregation is needed as the query only involves filtering and retrieving names.","[('Aleksey Ostapenko',), ('Maksim Botin',)]","[('Aleksey Ostapenko',), ('Maksim Botin',)]",,1.0,
What is the number of nations that use English and Dutch?,"[countrylanguage.Language, countrylanguage.CountryCode, country.Code, countrylanguage.CountryCode = country.Code, English, Dutch]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT COUNT(DISTINCT CountryCode) AS number_of_nations FROM countrylanguage WHERE Language IN ('English', 'Dutch');","SELECT COUNT(*) FROM (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""Dutch"")",world_1,"1. Sequential Structure: Start with the SELECT clause to count the number of nations. Use the FROM clause to specify the countrylanguage table. Apply a WHERE clause to filter for rows where the language is either 'English' or 'Dutch'. Use DISTINCT to ensure that each nation is counted only once. 2. Condition Structure: Use the WHERE clause to filter for rows where the language is 'English' or 'Dutch'. 3. Join Structure: Not required, as all necessary data is available in the countrylanguage table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique nations that use either 'English' or 'Dutch'.","[(62,)]","[(3,)]",,0.0,
Which language is the most popular in Aruba?,"[country.Name, countrylanguage.Language, countrylanguage.Percentage, city.CountryCode = country.Code, countrylanguage.CountryCode = country.Code, Aruba]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT countrylanguage.Language FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Name = 'Aruba' ORDER BY countrylanguage.Percentage DESC LIMIT 1;,"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  ""Aruba"" ORDER BY Percentage DESC LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countrylanguage.Language"" as we are interested in the most popular language. Use MAX on ""countrylanguage.Percentage"" to identify the most popular language in Aruba. 2. Condition Structure: Use a WHERE clause to filter for records where the ""country.Name"" is 'Aruba.' 3. Join Structure: Use a JOIN between the ""country"" and ""countrylanguage"" tables based on ""country.Code"" and ""countrylanguage.CountryCode"" to associate each country with its languages. 4. Aggregation Structure: Use MAX to find the language with the highest percentage for Aruba.","[('Papiamento',)]","[('Papiamento',)]",,1.0,
Give the name of the country in Asia with the lowest life expectancy.,"[country.Name, country.Continent, country.LifeExpectancy, country.Continent = 'Asia']","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT Name FROM country WHERE Continent = 'Asia' ORDER BY LifeExpectancy ASC LIMIT 1;,"SELECT Name FROM country WHERE Continent  =  ""Asia"" ORDER BY LifeExpectancy LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the country. Use the FROM clause to specify the country table. Apply a WHERE clause to filter for countries in the continent 'Asia'. Use ORDER BY to sort the countries by life expectancy in ascending order and LIMIT 1 to get the country with the lowest life expectancy. 2. Condition Structure: Use the WHERE clause to filter for countries where the continent is 'Asia'. 3. Join Structure: Not required, as all the necessary data is in the country table. 4. Aggregation Structure: Not required, as we are only retrieving the country with the lowest life expectancy without any aggregation.","[('Afghanistan',)]","[('Afghanistan',)]",,1.0,
What is the total population of Gelderland district?,"[city.Population, city.District]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT SUM(city.Population) AS total_population FROM city WHERE city.District = 'Gelderland';,"SELECT sum(Population) FROM city WHERE District  =  ""Gelderland""",world_1,"1. Sequential Structure: Start with the SELECT clause to calculate the total population of the Gelderland district. 2. Condition Structure: Use a WHERE clause to filter for rows where ""city.District"" is equal to 'Gelderland'. 3. Join Structure: No JOIN is required since all necessary information is in the ""city"" table. 4. Aggregation Structure: Use the SUM function to calculate the total population of the Gelderland district.","[(545548,)]","[(545548,)]",,1.0,
What is the official language spoken in the country whose head of state is Beatrix?,"[country.HeadOfState, country.Code = countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.IsOfficial]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT countrylanguage.Language FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.HeadOfState = 'Beatrix' AND countrylanguage.IsOfficial = 'T';,"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.HeadOfState  =  ""Beatrix"" AND T2.IsOfficial  =  ""T""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countrylanguage.Language"" field, as the question asks for the official language. 2. Condition Structure: Use a WHERE clause to filter for the country where ""country.HeadOfState"" is 'Beatrix' and ""countrylanguage.IsOfficial"" is 'T' (indicating the language is official). 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables on ""country.Code = countrylanguage.CountryCode"" to link countries with their languages. 4. Aggregation Structure: No aggregation is needed since we are retrieving a specific language.","[('Dutch',), ('Dutch',), ('Papiamento',), ('Dutch',)]","[('Dutch',), ('Dutch',), ('Papiamento',), ('Dutch',)]",,1.0,
Which countries have either English or Dutch as an official language?,"[country.Name, countrylanguage.Language, countrylanguage.IsOfficial, countrylanguage.CountryCode = country.Code, English, Dutch, True]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT country.Name FROM country JOIN countrylanguage ON countrylanguage.CountryCode = country.Code WHERE (countrylanguage.Language = 'English' OR countrylanguage.Language = 'Dutch') AND countrylanguage.IsOfficial = 'True';,"SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"" AND IsOfficial  =  ""T"" UNION SELECT * FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""Dutch"" AND IsOfficial  =  ""T""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries (""country.Name""). 2. Condition Structure: Use a WHERE clause to filter for records where ""countrylanguage.Language"" is either 'English' or 'Dutch' and ""countrylanguage.IsOfficial"" is True. 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables based on the relationship ""countrylanguage.CountryCode = country.Code"" to link each country with its languages. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of countries that meet the specified conditions.",[],"[('ABW', 'Aruba', 'North America', 'Caribbean', 193.0, None, 103000, 78.4, 828.0, 793.0, 'Aruba', 'Nonmetropolitan Territory of The Netherlands', 'Beatrix', 129, 'AW', 'ABW', 'Dutch', 'T', 5.3), ('AIA', 'Anguilla', 'North America', 'Caribbean', 96.0, None, 8000, 76.1, 63.2, None, 'Anguilla', 'Dependent Territory of the UK', 'Elisabeth II', 62, 'AI', 'AIA', 'English', 'T', 0.0), ('ANT', 'Netherlands Antilles', 'North America', 'Caribbean', 800.0, None, 217000, 74.7, 1941.0, None, 'Nederlandse Antillen', 'Nonmetropolitan Territory of The Netherlands', 'Beatrix', 33, 'AN', 'ANT', 'Dutch', 'T', 0.0), ('ASM', 'American Samoa', 'Oceania', 'Polynesia', 199.0, None, 68000, 75.1, 334.0, None, 'Amerika Samoa', 'US Territory', 'George W. Bush', 54, 'AS', 'ASM', 'English', 'T', 3.1), ('ATG', 'Antigua and Barbuda', 'North America', 'Caribbean', 442.0, 1981, 68000, 70.5, 612.0, 584.0, 'Antigua and Barbuda', 'Constitutional Monarchy', 'Elisabeth II', 63, 'AG', 'ATG', 'English', 'T', 0.0), ('AUS', 'Australia', 'Oceania', 'Australia and New Zealand', 7741220.0, 1901, 18886000, 79.8, 351182.0, 392911.0, 'Australia', 'Constitutional Monarchy, Federation', 'Elisabeth II', 135, 'AU', 'AUS', 'English', 'T', 81.2), ('BEL', 'Belgium', 'Europe', 'Western Europe', 30518.0, 1830, 10239000, 77.8, 249704.0, 243948.0, 'België/Belgique', 'Constitutional Monarchy, Federation', 'Albert II', 179, 'BE', 'BEL', 'Dutch', 'T', 59.2), ('BLZ', 'Belize', 'North America', 'Central America', 22696.0, 1981, 241000, 70.9, 630.0, 616.0, 'Belize', 'Constitutional Monarchy', 'Elisabeth II', 185, 'BZ', 'BLZ', 'English', 'T', 50.8), ('BMU', 'Bermuda', 'North America', 'North America', 53.0, None, 65000, 76.9, 2328.0, 2190.0, 'Bermuda', 'Dependent Territory of the UK', 'Elisabeth II', 191, 'BM', 'BMU', 'English', 'T', 100.0), ('BRB', 'Barbados', 'North America', 'Caribbean', 430.0, 1966, 270000, 73.0, 2223.0, 2186.0, 'Barbados', 'Constitutional Monarchy', 'Elisabeth II', 174, 'BB', 'BRB', 'English', 'T', 0.0), ('CAN', 'Canada', 'North America', 'North America', 9970610.0, 1867, 31147000, 79.4, 598862.0, 625626.0, 'Canada', 'Constitutional Monarchy, Federation', 'Elisabeth II', 1822, 'CA', 'CAN', 'English', 'T', 60.4), ('CCK', 'Cocos (Keeling) Islands', 'Oceania', 'Australia and New Zealand', 14.0, None, 600, None, 0.0, None, 'Cocos (Keeling) Islands', 'Territory of Australia', 'Elisabeth II', 2317, 'CC', 'CCK', 'English', 'T', 0.0), ('CXR', 'Christmas Island', 'Oceania', 'Australia and New Zealand', 135.0, None, 2500, None, 0.0, None, 'Christmas Island', 'Territory of Australia', 'Elisabeth II', 1791, 'CX', 'CXR', 'English', 'T', 0.0), ('CYM', 'Cayman Islands', 'North America', 'Caribbean', 264.0, None, 38000, 78.9, 1263.0, 1186.0, 'Cayman Islands', 'Dependent Territory of the UK', 'Elisabeth II', 553, 'KY', 'CYM', 'English', 'T', 0.0), ('FLK', 'Falkland Islands', 'South America', 'South America', 12173.0, None, 2000, None, 0.0, None, 'Falkland Islands', 'Dependent Territory of the UK', 'Elisabeth II', 763, 'FK', 'FLK', 'English', 'T', 0.0), ('GBR', 'United Kingdom', 'Europe', 'British Islands', 242900.0, 1066, 59623400, 77.7, 1378330.0, 1296830.0, 'United Kingdom', 'Constitutional Monarchy', 'Elisabeth II', 456, 'GB', 'GBR', 'English', 'T', 97.3), ('GIB', 'Gibraltar', 'Europe', 'Southern Europe', 6.0, None, 25000, 79.0, 258.0, None, 'Gibraltar', 'Dependent Territory of the UK', 'Elisabeth II', 915, 'GI', 'GIB', 'English', 'T', 88.9), ('GUM', 'Guam', 'Oceania', 'Micronesia', 549.0, None, 168000, 77.8, 1197.0, 1136.0, 'Guam', 'US Territory', 'George W. Bush', 921, 'GU', 'GUM', 'English', 'T', 37.5), ('HKG', 'Hong Kong', 'Asia', 'Eastern Asia', 1075.0, None, 6782000, 79.5, 166448.0, 173610.0, 'Xianggang/Hong Kong', 'Special Administrative Region of China', 'Jiang Zemin', 937, 'HK', 'HKG', 'English', 'T', 2.2), ('IRL', 'Ireland', 'Europe', 'British Islands', 70273.0, 1921, 3775100, 76.8, 75921.0, 73132.0, 'Ireland/Éire', 'Republic', 'Mary McAleese', 1447, 'IE', 'IRL', 'English', 'T', 98.4), ('KNA', 'Saint Kitts and Nevis', 'North America', 'Caribbean', 261.0, 1983, 38000, 70.7, 299.0, None, 'Saint Kitts and Nevis', 'Constitutional Monarchy', 'Elisabeth II', 3064, 'KN', 'KNA', 'English', 'T', 0.0), ('LCA', 'Saint Lucia', 'North America', 'Caribbean', 622.0, 1979, 154000, 72.3, 571.0, None, 'Saint Lucia', 'Constitutional Monarchy', 'Elisabeth II', 3065, 'LC', 'LCA', 'English', 'T', 20.0), ('LSO', 'Lesotho', 'Africa', 'Southern Africa', 30355.0, 1966, 2153000, 50.8, 1061.0, 1161.0, 'Lesotho', 'Constitutional Monarchy', 'Letsie III', 2437, 'LS', 'LSO', 'English', 'T', 0.0), ('MHL', 'Marshall Islands', 'Oceania', 'Micronesia', 181.0, 1990, 64000, 65.5, 97.0, None, 'Marshall Islands/Majol', 'Republic', 'Kessai Note', 2507, 'MH', 'MHL', 'English', 'T', 0.0), ('MLT', 'Malta', 'Europe', 'Southern Europe', 316.0, 1964, 380200, 77.9, 3512.0, 3338.0, 'Malta', 'Republic', 'Guido de Marco', 2484, 'MT', 'MLT', 'English', 'T', 2.1), ('MNP', 'Northern Mariana Islands', 'Oceania', 'Micronesia', 464.0, None, 78000, 75.5, 0.0, None, 'Northern Mariana Islands', 'Commonwealth of the US', 'George W. Bush', 2913, 'MP', 'MNP', 'English', 'T', 4.8), ('MSR', 'Montserrat', 'North America', 'Caribbean', 102.0, None, 11000, 78.0, 109.0, None, 'Montserrat', 'Dependent Territory of the UK', 'Elisabeth II', 2697, 'MS', 'MSR', 'English', 'T', 0.0), ('NFK', 'Norfolk Island', 'Oceania', 'Australia and New Zealand', 36.0, None, 2000, None, 0.0, None, 'Norfolk Island', 'Territory of Australia', 'Elisabeth II', 2806, 'NF', 'NFK', 'English', 'T', 0.0), ('NIU', 'Niue', 'Oceania', 'Polynesia', 260.0, None, 2000, None, 0.0, None, 'Niue', 'Nonmetropolitan Territory of New Zealand', 'Elisabeth II', 2805, 'NU', 'NIU', 'English', 'T', 0.0), ('NLD', 'Netherlands', 'Europe', 'Western Europe', 41526.0, 1581, 15864000, 78.3, 371362.0, 360478.0, 'Nederland', 'Constitutional Monarchy', 'Beatrix', 5, 'NL', 'NLD', 'Dutch', 'T', 95.6), ('NRU', 'Nauru', 'Oceania', 'Micronesia', 21.0, 1968, 12000, 60.8, 197.0, None, 'Naoero/Nauru', 'Republic', 'Bernard Dowiyogo', 2728, 'NR', 'NRU', 'English', 'T', 7.5), ('NZL', 'New Zealand', 'Oceania', 'Australia and New Zealand', 270534.0, 1907, 3862000, 77.8, 54669.0, 64960.0, 'New Zealand/Aotearoa', 'Constitutional Monarchy', 'Elisabeth II', 3499, 'NZ', 'NZL', 'English', 'T', 87.0), ('PLW', 'Palau', 'Oceania', 'Micronesia', 459.0, 1994, 19000, 68.6, 105.0, None, 'Belau/Palau', 'Republic', 'Kuniwo Nakamura', 2881, 'PW', 'PLW', 'English', 'T', 3.2), ('SHN', 'Saint Helena', 'Africa', 'Western Africa', 314.0, None, 6000, 76.8, 0.0, None, 'Saint Helena', 'Dependent Territory of the UK', 'Elisabeth II', 3063, 'SH', 'SHN', 'English', 'T', 0.0), ('SYC', 'Seychelles', 'Africa', 'Eastern Africa', 455.0, 1976, 77000, 70.4, 536.0, 539.0, 'Sesel/Seychelles', 'Republic', 'France-Albert René', 3206, 'SC', 'SYC', 'English', 'T', 3.8), ('TCA', 'Turks and Caicos Islands', 'North America', 'Caribbean', 430.0, None, 17000, 73.3, 96.0, None, 'The Turks and Caicos Islands', 'Dependent Territory of the UK', 'Elisabeth II', 3423, 'TC', 'TCA', 'English', 'T', 0.0), ('TKL', 'Tokelau', 'Oceania', 'Polynesia', 12.0, None, 2000, None, 0.0, None, 'Tokelau', 'Nonmetropolitan Territory of New Zealand', 'Elisabeth II', 3333, 'TK', 'TKL', 'English', 'T', 0.0), ('TON', 'Tonga', 'Oceania', 'Polynesia', 650.0, 1970, 99000, 67.9, 146.0, 170.0, 'Tonga', 'Monarchy', ""Taufa'ahau Tupou IV"", 3334, 'TO', 'TON', 'English', 'T', 0.0), ('TUV', 'Tuvalu', 'Oceania', 'Polynesia', 26.0, 1978, 12000, 66.3, 6.0, None, 'Tuvalu', 'Constitutional Monarchy', 'Elisabeth II', 3424, 'TV', 'TUV', 'English', 'T', 0.0), ('UMI', 'United States Minor Outlying Islands', 'Oceania', 'Micronesia/Caribbean', 16.0, None, 0, None, 0.0, None, 'United States Minor Outlying Islands', 'Dependent Territory of the US', 'George W. Bush', None, 'UM', 'UMI', 'English', 'T', 0.0), ('USA', 'United States', 'North America', 'North America', 9363520.0, 1776, 278357000, 77.1, 8510700.0, 8110900.0, 'United States', 'Federal Republic', 'George W. Bush', 3813, 'US', 'USA', 'English', 'T', 86.2), ('VCT', 'Saint Vincent and the Grenadines', 'North America', 'Caribbean', 388.0, 1979, 114000, 72.3, 285.0, None, 'Saint Vincent and the Grenadines', 'Constitutional Monarchy', 'Elisabeth II', 3066, 'VC', 'VCT', 'English', 'T', 0.0), ('VGB', 'Virgin Islands, British', 'North America', 'Caribbean', 151.0, None, 21000, 75.4, 612.0, 573.0, 'British Virgin Islands', 'Dependent Territory of the UK', 'Elisabeth II', 537, 'VG', 'VGB', 'English', 'T', 0.0), ('VIR', 'Virgin Islands, U.S.', 'North America', 'Caribbean', 347.0, None, 93000, 78.1, 0.0, None, 'Virgin Islands of the United States', 'US Territory', 'George W. Bush', 4067, 'VI', 'VIR', 'English', 'T', 81.7), ('VUT', 'Vanuatu', 'Oceania', 'Melanesia', 12189.0, 1980, 190000, 60.6, 261.0, 246.0, 'Vanuatu', 'Republic', 'John Bani', 3537, 'VU', 'VUT', 'English', 'T', 28.3), ('WSM', 'Samoa', 'Oceania', 'Polynesia', 2831.0, 1962, 180000, 69.2, 141.0, 157.0, 'Samoa', 'Parlementary Monarchy', 'Malietoa Tanumafili II', 3169, 'WS', 'WSM', 'English', 'T', 0.6), ('ZAF', 'South Africa', 'Africa', 'Southern Africa', 1221037.0, 1910, 40377000, 51.1, 116729.0, 129092.0, 'South Africa', 'Republic', 'Thabo Mbeki', 716, 'ZA', 'ZAF', 'English', 'T', 8.5), ('ZWE', 'Zimbabwe', 'Africa', 'Eastern Africa', 390757.0, 1980, 11669000, 37.8, 5951.0, 8670.0, 'Zimbabwe', 'Republic', 'Robert G. Mugabe', 4068, 'ZW', 'ZWE', 'English', 'T', 2.2)]",,0.0,
Give the name of the nation that uses the greatest amount of languages.,"[country.Name, country.Code = countrylanguage.CountryCode, countrylanguage.Language]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT country.Name FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode GROUP BY country.Name ORDER BY COUNT(countrylanguage.Language) DESC LIMIT 1;,SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name ORDER BY COUNT(*) DESC LIMIT 1,world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the country (""country.Name""). Use COUNT to count the number of languages spoken in each country. Use ORDER BY in descending order to rank countries by the number of languages, and LIMIT 1 to get the country with the greatest number of languages. 2. Condition Structure: No specific filtering condition is required, as we are considering all countries and their languages. 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables on ""country.Code = countrylanguage.CountryCode"" to associate each country with its languages. 4. Aggregation Structure: Use COUNT on ""countrylanguage.Language"" to count the number of languages for each country, and GROUP BY ""country.Name"" to group the results by country.","[('United States',)]","[('United States',)]",,1.0,
"Of all the contestants who got voted, what is the contestant number and name of the contestant who got least votes?","[CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, VOTES.contestant_number, VOTES.vote_id, VOTES.contestant_number = CONTESTANTS.contestant_number]","Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",NON-NESTED,"SELECT CONTESTANTS.contestant_number, CONTESTANTS.contestant_name FROM VOTES JOIN CONTESTANTS ON VOTES.contestant_number = CONTESTANTS.contestant_number GROUP BY CONTESTANTS.contestant_number, CONTESTANTS.contestant_name ORDER BY COUNT(VOTES.vote_id) ASC LIMIT 1;","SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number ORDER BY count(*) ASC LIMIT 1",voter_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""CONTESTANTS.contestant_number"" and ""CONTESTANTS.contestant_name"" of the contestant with the least votes. Use COUNT on ""VOTES.vote_id"" to count the number of votes for each contestant. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all contestants who received votes. 3. Join Structure: Use an INNER JOIN between the ""VOTES"" and ""CONTESTANTS"" tables on ""VOTES.contestant_number = CONTESTANTS.contestant_number"" to associate votes with their respective contestants. 4. Aggregation Structure: Use GROUP BY on ""CONTESTANTS.contestant_number"" and ""CONTESTANTS.contestant_name"" to group votes by contestant. Use ORDER BY in ascending order on the vote count and LIMIT 1 to select the contestant with the least votes.","[(2, 'Tabatha Gehling')]","[(2, 'Tabatha Gehling')]",,1.0,
List the names and birth dates of people in ascending alphabetical order of name.,"[people.Name, people.Birth_Date]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,"SELECT people.Name, people.Birth_Date FROM people ORDER BY people.Name ASC;","SELECT Name ,  Birth_Date FROM people ORDER BY Name ASC",poker_player,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""people.Name"" and ""people.Birth_Date"". 2. Condition Structure: No specific filtering condition is required as we want all names and birth dates. 3. Join Structure: No JOIN is required since all necessary information is available in the ""people"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in ascending alphabetical order based on ""people.Name"".","[('Aleksey Ostapenko', 'May 26, 1986'), ('Maksim Botin', 'July 14, 1983'), ('Roman Bragin', 'April 17, 1987'), ('Semen Poltavskiy', 'February 8, 1981'), ('Sergey Grankin', 'January 22, 1987'), ('Teodor Salparov', 'August 16, 1982'), ('Yevgeni Sivozhelez', 'August 8, 1986')]","[('Aleksey Ostapenko', 'May 26, 1986'), ('Maksim Botin', 'July 14, 1983'), ('Roman Bragin', 'April 17, 1987'), ('Semen Poltavskiy', 'February 8, 1981'), ('Sergey Grankin', 'January 22, 1987'), ('Teodor Salparov', 'August 16, 1982'), ('Yevgeni Sivozhelez', 'August 8, 1986')]",,1.0,
"List the vote ids, phone numbers and states of all votes.","[VOTES.vote_id, VOTES.phone_number, VOTES.state]","Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",EASY,"SELECT VOTES.vote_id, VOTES.phone_number, VOTES.state FROM VOTES;","SELECT vote_id ,  phone_number ,  state FROM votes",voter_1,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""VOTES.vote_id"", ""VOTES.phone_number"", and ""VOTES.state"". 2. Condition Structure: No specific filtering condition is required as the query asks for all votes. 3. Join Structure: No JOIN is necessary since all the required data is available within the ""VOTES"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the specified fields for all votes.","[(1, 7182887233, 'NY'), (2, 7148407040, 'NY'), (3, 6209222712, 'CA'), (5, 5112677315, 'NJ\n')]","[(1, 7182887233, 'NY'), (2, 7148407040, 'NY'), (3, 6209222712, 'CA'), (5, 5112677315, 'NJ\n')]",,1.0,
"How many people live in Asia, and what is the largest GNP among them?","[country.Population, country.GNP, country.Continent, country.Continent = 'Asia']","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,"SELECT SUM(country.Population) AS total_population, MAX(country.GNP) AS largest_gnp FROM country WHERE country.Continent = 'Asia';","SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  ""Asia""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the total population and the largest GNP for countries in Asia. 2. Condition Structure: Use a WHERE clause to filter for countries where ""country.Continent"" is 'Asia'. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use SUM to calculate the total population and MAX to find the largest GNP among the countries in Asia.","[(3705025700, 3787042.0)]","[(3705025700, 3787042.0)]",,1.0,
Return the names of all the poker players.,"[people.Name, poker_player.People_ID = people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,SELECT people.Name FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID;,SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""people.Name"" field, as we are interested in the names of poker players. 2. Condition Structure: No specific filtering condition is required since we need the names of all poker players. 3. Join Structure: Use an INNER JOIN between the ""poker_player"" table and the ""people"" table on the ""People_ID"" field to link poker players with their corresponding names. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names.","[('Aleksey Ostapenko',), ('Teodor Salparov',), ('Yevgeni Sivozhelez',), ('Maksim Botin',), ('Semen Poltavskiy',)]","[('Aleksey Ostapenko',), ('Teodor Salparov',), ('Yevgeni Sivozhelez',), ('Maksim Botin',), ('Semen Poltavskiy',)]",,1.0,
Give the names of the nations that were founded after 1950.,"[country.Name, country.IndepYear]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT country.Name FROM country WHERE country.IndepYear > 1950;,SELECT Name FROM country WHERE IndepYear  >  1950,world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Name"" of nations founded after 1950. 2. Condition Structure: Use a WHERE clause to filter for countries where ""country.IndepYear"" is greater than 1950. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of nations based on a specific condition.","[('Angola',), ('United Arab Emirates',), ('Armenia',), ('Antigua and Barbuda',), ('Azerbaijan',), ('Burundi',), ('Benin',), ('Burkina Faso',), ('Bangladesh',), ('Bahrain',), ('Bahamas',), ('Bosnia and Herzegovina',), ('Belarus',), ('Belize',), ('Barbados',), ('Brunei',), ('Botswana',), ('Central African Republic',), ('Côte d’Ivoire',), ('Cameroon',), ('Congo, The Democratic Republic of the',), ('Congo',), ('Comoros',), ('Cape Verde',), ('Cyprus',), ('Czech Republic',), ('Germany',), ('Djibouti',), ('Dominica',), ('Algeria',), ('Eritrea',), ('Estonia',), ('Fiji Islands',), ('Micronesia, Federated States of',), ('Gabon',), ('Georgia',), ('Ghana',), ('Guinea',), ('Gambia',), ('Guinea-Bissau',), ('Equatorial Guinea',), ('Grenada',), ('Guyana',), ('Croatia',), ('Jamaica',), ('Kazakstan',), ('Kenya',), ('Kyrgyzstan',), ('Cambodia',), ('Kiribati',), ('Saint Kitts and Nevis',), ('Kuwait',), ('Laos',), ('Libyan Arab Jamahiriya',), ('Saint Lucia',), ('Lesotho',), ('Lithuania',), ('Latvia',), ('Morocco',), ('Moldova',), ('Madagascar',), ('Maldives',), ('Marshall Islands',), ('Macedonia',), ('Mali',), ('Malta',), ('Mozambique',), ('Mauritania',), ('Mauritius',), ('Malawi',), ('Malaysia',), ('Namibia',), ('Niger',), ('Nigeria',), ('Nauru',), ('Oman',), ('Palau',), ('Papua New Guinea',), ('Qatar',), ('Russian Federation',), ('Rwanda',), ('Sudan',), ('Senegal',), ('Singapore',), ('Solomon Islands',), ('Sierra Leone',), ('Somalia',), ('Sao Tome and Principe',), ('Suriname',), ('Slovakia',), ('Slovenia',), ('Swaziland',), ('Seychelles',), ('Chad',), ('Togo',), ('Tajikistan',), ('Turkmenistan',), ('Tonga',), ('Trinidad and Tobago',), ('Tunisia',), ('Tuvalu',), ('Tanzania',), ('Uganda',), ('Ukraine',), ('Uzbekistan',), ('Saint Vincent and the Grenadines',), ('Vanuatu',), ('Samoa',), ('Zambia',), ('Zimbabwe',)]","[('Angola',), ('United Arab Emirates',), ('Armenia',), ('Antigua and Barbuda',), ('Azerbaijan',), ('Burundi',), ('Benin',), ('Burkina Faso',), ('Bangladesh',), ('Bahrain',), ('Bahamas',), ('Bosnia and Herzegovina',), ('Belarus',), ('Belize',), ('Barbados',), ('Brunei',), ('Botswana',), ('Central African Republic',), ('Côte d’Ivoire',), ('Cameroon',), ('Congo, The Democratic Republic of the',), ('Congo',), ('Comoros',), ('Cape Verde',), ('Cyprus',), ('Czech Republic',), ('Germany',), ('Djibouti',), ('Dominica',), ('Algeria',), ('Eritrea',), ('Estonia',), ('Fiji Islands',), ('Micronesia, Federated States of',), ('Gabon',), ('Georgia',), ('Ghana',), ('Guinea',), ('Gambia',), ('Guinea-Bissau',), ('Equatorial Guinea',), ('Grenada',), ('Guyana',), ('Croatia',), ('Jamaica',), ('Kazakstan',), ('Kenya',), ('Kyrgyzstan',), ('Cambodia',), ('Kiribati',), ('Saint Kitts and Nevis',), ('Kuwait',), ('Laos',), ('Libyan Arab Jamahiriya',), ('Saint Lucia',), ('Lesotho',), ('Lithuania',), ('Latvia',), ('Morocco',), ('Moldova',), ('Madagascar',), ('Maldives',), ('Marshall Islands',), ('Macedonia',), ('Mali',), ('Malta',), ('Mozambique',), ('Mauritania',), ('Mauritius',), ('Malawi',), ('Malaysia',), ('Namibia',), ('Niger',), ('Nigeria',), ('Nauru',), ('Oman',), ('Palau',), ('Papua New Guinea',), ('Qatar',), ('Russian Federation',), ('Rwanda',), ('Sudan',), ('Senegal',), ('Singapore',), ('Solomon Islands',), ('Sierra Leone',), ('Somalia',), ('Sao Tome and Principe',), ('Suriname',), ('Slovakia',), ('Slovenia',), ('Swaziland',), ('Seychelles',), ('Chad',), ('Togo',), ('Tajikistan',), ('Turkmenistan',), ('Tonga',), ('Trinidad and Tobago',), ('Tunisia',), ('Tuvalu',), ('Tanzania',), ('Uganda',), ('Ukraine',), ('Uzbekistan',), ('Saint Vincent and the Grenadines',), ('Vanuatu',), ('Samoa',), ('Zambia',), ('Zimbabwe',)]",,1.0,
Which continent is Anguilla in?,"[country.Name, country.Continent]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT country.Continent FROM country WHERE country.Name = 'Anguilla';,"SELECT Continent FROM country WHERE Name  =  ""Anguilla""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Continent"" for the country named ""Anguilla"". 2. Condition Structure: Use a WHERE clause to filter for the country where ""country.Name"" is ""Anguilla"". 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('North America',)]","[('North America',)]",,1.0,
How long is the people’s average life expectancy in Central Africa?,"[country.LifeExpectancy, country.Region, Central Africa]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT AVG(country.LifeExpectancy) AS avg_life_expectancy FROM country WHERE country.Region = 'Central Africa';,"SELECT avg(LifeExpectancy) FROM country WHERE Region  =  ""Central Africa""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the average life expectancy of people in the specified region, ""Central Africa."" 2. Condition Structure: Use a WHERE clause to filter for countries in the ""Central Africa"" region. 3. Join Structure: No JOIN is required since all necessary information is available in the ""country"" table. 4. Aggregation Structure: Use the AVG function to calculate the average life expectancy for the filtered region.","[(50.31111111111111,)]","[(50.31111111111111,)]",,1.0,
Give me Brazil’s population and life expectancies.,"[country.Name, country.Population, country.LifeExpectancy]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,"SELECT country.Population, country.LifeExpectancy FROM country WHERE country.Name = 'Brazil';","SELECT Population ,  LifeExpectancy FROM country WHERE Name  =  ""Brazil""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the population and life expectancy of Brazil. 2. Condition Structure: Use a WHERE clause to filter for the country with the name ""Brazil"". 3. Join Structure: No JOIN is required since all the necessary information is available in the ""country"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields for a single country.","[(170115000, 62.9)]","[(170115000, 62.9)]",,1.0,
How many continents speak Chinese?,"[country.Continent, country.Code = countrylanguage.CountryCode, countrylanguage.Language, Chinese]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT COUNT(DISTINCT country.Continent) FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.Language = 'Chinese';,"SELECT COUNT( DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""Chinese""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the distinct continents where Chinese is spoken. Use COUNT with DISTINCT on ""country.Continent."" 2. Condition Structure: Use a WHERE clause to filter for records where ""countrylanguage.Language"" is 'Chinese.' 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables on ""country.Code = countrylanguage.CountryCode"" to associate countries with their languages. 4. Aggregation Structure: Use COUNT with DISTINCT to ensure that only unique continents are counted.","[(4,)]","[(4,)]",,1.0,
Return the names of the contestants whose names contain the substring 'Al' .,[CONTESTANTS.contestant_name],"Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",EASY,SELECT CONTESTANTS.contestant_name FROM CONTESTANTS WHERE CONTESTANTS.contestant_name LIKE '%Al%';,"select contestant_name from contestants where contestant_name like ""%al%""",voter_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""CONTESTANTS.contestant_name"" of contestants whose names contain the substring 'Al'. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for contestant names that contain the substring 'Al'. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""CONTESTANTS"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[('Jessie Alloway',), ('Alana Bregman',), ('Allie Rogalski',), ('Kurt Walser',)]","[('Jessie Alloway',), ('Alana Bregman',), ('Allie Rogalski',), ('Kurt Walser',)]",,1.0,
What are the names of people who do not play poker?,"[people.Name, poker_player.People_ID = people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NESTED,SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player);,SELECT Name FROM people WHERE People_ID NOT IN (SELECT People_ID FROM poker_player),poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of people. Use the FROM clause to specify the people table. Apply a WHERE clause to filter for people who do not play poker by ensuring their People_ID is not present in the poker_player table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude people whose People_ID appears in the poker_player table, meaning they play poker. 3. Join Structure: Not required, as we only need to filter based on the absence of matching People_ID entries in the poker_player table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Roman Bragin',), ('Sergey Grankin',)]","[('Roman Bragin',), ('Sergey Grankin',)]",,1.0,
"What are the earnings of poker players, ordered descending by value?",[poker_player.Earnings],"Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT poker_player.Earnings FROM poker_player ORDER BY poker_player.Earnings DESC;,SELECT Earnings FROM poker_player ORDER BY Earnings DESC,poker_player,"1. Sequential Structure: Start with the SELECT clause to specify the field ""poker_player.Earnings"" as the query is focused on retrieving earnings. 2. Condition Structure: No specific filtering condition is required since the query asks for all poker players' earnings. 3. Join Structure: No JOIN is necessary because the required data is available within the ""poker_player"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves and orders the earnings. 5. Ordering Structure: Use ORDER BY in descending order on ""poker_player.Earnings"" to sort the results by value.","[(596462.0,), (476090.0,), (189233.0,), (142800.0,), (104871.0,)]","[(596462.0,), (476090.0,), (189233.0,), (142800.0,), (104871.0,)]",,1.0,
Give the nationality that is most common across all people.,[people.Nationality],"Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,"SELECT people.Nationality, COUNT(*) AS COUNT FROM people GROUP BY people.Nationality ORDER BY COUNT DESC LIMIT 1;",SELECT Nationality FROM people GROUP BY Nationality ORDER BY COUNT(*) DESC LIMIT 1,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""people.Nationality"" and the count of occurrences for each nationality. 2. Aggregation Structure: Use COUNT to calculate the number of occurrences of each nationality. 3. Grouping Structure: Use GROUP BY on ""people.Nationality"" to group the results by nationality. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank nationalities by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the nationality that is most common. 6. Join Structure: No JOIN is required since all necessary data is within the ""people"" table.","[('Russia', 6)]","[('Russia',)]",,1.0,
List the names of poker players ordered by the final tables made in ascending order.,"[people.Name, poker_player.Final_Table_Made, poker_player.People_ID = people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,SELECT people.Name FROM people JOIN poker_player ON poker_player.People_ID = people.People_ID ORDER BY poker_player.Final_Table_Made ASC;,SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Final_Table_Made,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""people.Name"" field. Since the question asks for ordering by ""Final_Table_Made,"" include this field in the query for sorting purposes. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""people"" and ""poker_player"" tables on the ""People_ID"" field to link poker players with their names. 4. Aggregation Structure: No aggregation is needed, but apply ORDER BY on ""Final_Table_Made"" in ascending order to sort the results as specified.","[('Teodor Salparov',), ('Maksim Botin',), ('Yevgeni Sivozhelez',), ('Semen Poltavskiy',), ('Aleksey Ostapenko',)]","[('Teodor Salparov',), ('Maksim Botin',), ('Yevgeni Sivozhelez',), ('Semen Poltavskiy',), ('Aleksey Ostapenko',)]",,1.0,
What language is predominantly spoken in Aruba?,"[country.Name, countrylanguage.Language, countrylanguage.Percentage, countrylanguage.CountryCode = country.Code, Aruba]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT countrylanguage.Language FROM countrylanguage JOIN country ON countrylanguage.CountryCode = country.Code WHERE country.Name = 'Aruba' ORDER BY countrylanguage.Percentage DESC LIMIT 1;,"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  ""Aruba"" ORDER BY Percentage DESC LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countrylanguage.Language"" field, as the question asks for the predominant language. Use ORDER BY in descending order on ""countrylanguage.Percentage"" to rank languages by their percentage of speakers. Use LIMIT 1 to select the language with the highest percentage. 2. Condition Structure: Use a WHERE clause to filter for the country ""Aruba"" by matching ""country.Name"" with 'Aruba'. 3. Join Structure: Use an INNER JOIN between the ""countrylanguage"" and ""country"" tables based on the relationship ""countrylanguage.CountryCode = country.Code"" to link languages with their respective countries. 4. Aggregation Structure: No aggregation function is needed, as we are only selecting the language with the highest percentage for a specific country.","[('Papiamento',)]","[('Papiamento',)]",,1.0,
What are the names of the contestants whose names are not 'Jessie Alloway',[CONTESTANTS.contestant_name],"Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",EASY,SELECT CONTESTANTS.contestant_name FROM CONTESTANTS WHERE CONTESTANTS.contestant_name != 'Jessie Alloway';,SELECT contestant_name FROM contestants WHERE contestant_name != 'Jessie Alloway',voter_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""contestant_name"" of the contestants. 2. Condition Structure: Use a WHERE clause to filter out contestants whose name is 'Jessie Alloway'. 3. Join Structure: No JOIN is required since all necessary information is in the ""CONTESTANTS"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving contestant names based on a specific condition.","[('Edwina Burnam',), ('Tabatha Gehling',), ('Kelly Clauss',), ('Alana Bregman',), ('Jessie Eichman',), ('Allie Rogalski',), ('Nita Coster',), ('Kurt Walser',), ('Ericka Dieter',), ('Loraine NygrenTania Mattioli',)]","[('Edwina Burnam',), ('Tabatha Gehling',), ('Kelly Clauss',), ('Alana Bregman',), ('Jessie Eichman',), ('Allie Rogalski',), ('Nita Coster',), ('Kurt Walser',), ('Ericka Dieter',), ('Loraine NygrenTania Mattioli',)]",,1.0,
Which countries have greater area than that of any country in Europe?,"[country.Name, country.SurfaceArea, country.Continent]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT Name FROM country WHERE SurfaceArea > ALL (SELECT SurfaceArea FROM country WHERE Continent = 'Europe');,"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  ""Europe"")",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries. Use the FROM clause to specify the country table. Apply a WHERE clause to filter countries whose surface area is greater than the surface area of any country in Europe. 2. Condition Structure: Use the WHERE clause with a subquery to compare the surface area of countries to the maximum surface area of countries in Europe. The subquery filters countries in Europe and retrieves their surface areas. 3. Join Structure: Not required, as all data is available within the country table. 4. Aggregation Structure: Use a subquery to calculate the maximum surface area of countries in Europe, and compare it with the surface area of other countries.",[],"[('Aruba',), ('Afghanistan',), ('Angola',), ('Anguilla',), ('Albania',), ('Andorra',), ('Netherlands Antilles',), ('United Arab Emirates',), ('Argentina',), ('Armenia',), ('American Samoa',), ('Antarctica',), ('French Southern territories',), ('Antigua and Barbuda',), ('Australia',), ('Austria',), ('Azerbaijan',), ('Burundi',), ('Belgium',), ('Benin',), ('Burkina Faso',), ('Bangladesh',), ('Bulgaria',), ('Bahrain',), ('Bahamas',), ('Bosnia and Herzegovina',), ('Belarus',), ('Belize',), ('Bermuda',), ('Bolivia',), ('Brazil',), ('Barbados',), ('Brunei',), ('Bhutan',), ('Bouvet Island',), ('Botswana',), ('Central African Republic',), ('Canada',), ('Cocos (Keeling) Islands',), ('Switzerland',), ('Chile',), ('China',), ('Côte d’Ivoire',), ('Cameroon',), ('Congo, The Democratic Republic of the',), ('Congo',), ('Cook Islands',), ('Colombia',), ('Comoros',), ('Cape Verde',), ('Costa Rica',), ('Cuba',), ('Christmas Island',), ('Cayman Islands',), ('Cyprus',), ('Czech Republic',), ('Germany',), ('Djibouti',), ('Dominica',), ('Denmark',), ('Dominican Republic',), ('Algeria',), ('Ecuador',), ('Egypt',), ('Eritrea',), ('Western Sahara',), ('Spain',), ('Estonia',), ('Ethiopia',), ('Finland',), ('Fiji Islands',), ('Falkland Islands',), ('France',), ('Faroe Islands',), ('Micronesia, Federated States of',), ('Gabon',), ('United Kingdom',), ('Georgia',), ('Ghana',), ('Gibraltar',), ('Guinea',), ('Guadeloupe',), ('Gambia',), ('Guinea-Bissau',), ('Equatorial Guinea',), ('Greece',), ('Grenada',), ('Greenland',), ('Guatemala',), ('French Guiana',), ('Guam',), ('Guyana',), ('Hong Kong',), ('Heard Island and McDonald Islands',), ('Honduras',), ('Croatia',), ('Haiti',), ('Hungary',), ('Indonesia',), ('India',), ('British Indian Ocean Territory',), ('Ireland',), ('Iran',), ('Iraq',), ('Iceland',), ('Israel',), ('Italy',), ('Jamaica',), ('Jordan',), ('Japan',), ('Kazakstan',), ('Kenya',), ('Kyrgyzstan',), ('Cambodia',), ('Kiribati',), ('Saint Kitts and Nevis',), ('South Korea',), ('Kuwait',), ('Laos',), ('Lebanon',), ('Liberia',), ('Libyan Arab Jamahiriya',), ('Saint Lucia',), ('Liechtenstein',), ('Sri Lanka',), ('Lesotho',), ('Lithuania',), ('Luxembourg',), ('Latvia',), ('Macao',), ('Morocco',), ('Monaco',), ('Moldova',), ('Madagascar',), ('Maldives',), ('Mexico',), ('Marshall Islands',), ('Macedonia',), ('Mali',), ('Malta',), ('Myanmar',), ('Mongolia',), ('Northern Mariana Islands',), ('Mozambique',), ('Mauritania',), ('Montserrat',), ('Martinique',), ('Mauritius',), ('Malawi',), ('Malaysia',), ('Mayotte',), ('Namibia',), ('New Caledonia',), ('Niger',), ('Norfolk Island',), ('Nigeria',), ('Nicaragua',), ('Niue',), ('Netherlands',), ('Norway',), ('Nepal',), ('Nauru',), ('New Zealand',), ('Oman',), ('Pakistan',), ('Panama',), ('Pitcairn',), ('Peru',), ('Philippines',), ('Palau',), ('Papua New Guinea',), ('Poland',), ('Puerto Rico',), ('North Korea',), ('Portugal',), ('Paraguay',), ('Palestine',), ('French Polynesia',), ('Qatar',), ('Réunion',), ('Romania',), ('Russian Federation',), ('Rwanda',), ('Saudi Arabia',), ('Sudan',), ('Senegal',), ('Singapore',), ('South Georgia and the South Sandwich Islands',), ('Saint Helena',), ('Svalbard and Jan Mayen',), ('Solomon Islands',), ('Sierra Leone',), ('El Salvador',), ('San Marino',), ('Somalia',), ('Saint Pierre and Miquelon',), ('Sao Tome and Principe',), ('Suriname',), ('Slovakia',), ('Slovenia',), ('Sweden',), ('Swaziland',), ('Seychelles',), ('Syria',), ('Turks and Caicos Islands',), ('Chad',), ('Togo',), ('Thailand',), ('Tajikistan',), ('Tokelau',), ('Turkmenistan',), ('East Timor',), ('Tonga',), ('Trinidad and Tobago',), ('Tunisia',), ('Turkey',), ('Tuvalu',), ('Taiwan',), ('Tanzania',), ('Uganda',), ('Ukraine',), ('United States Minor Outlying Islands',), ('Uruguay',), ('United States',), ('Uzbekistan',), ('Saint Vincent and the Grenadines',), ('Venezuela',), ('Virgin Islands, British',), ('Virgin Islands, U.S.',), ('Vietnam',), ('Vanuatu',), ('Wallis and Futuna',), ('Samoa',), ('Yemen',), ('Yugoslavia',), ('South Africa',), ('Zambia',), ('Zimbabwe',)]","near ""ALL"": syntax error",0.0,
What is the total population and maximum GNP in Asia?,"[country.Population, country.GNP, country.Continent]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,"SELECT SUM(country.Population) AS total_population, MAX(country.GNP) AS max_gnp FROM country WHERE country.Continent = 'Asia';","SELECT sum(Population) ,  max(GNP) FROM country WHERE Continent  =  ""Asia""",world_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the total population and the maximum GNP. 2. Condition Structure: Use a WHERE clause to filter for countries in the ""Asia"" continent. 3. Join Structure: No JOIN is required since all necessary data is within the ""country"" table. 4. Aggregation Structure: Use SUM to calculate the total population and MAX to find the maximum GNP for countries in Asia.","[(3705025700, 3787042.0)]","[(3705025700, 3787042.0)]",,1.0,
What are the regions that use English or Dutch?,"[country.Region, countrylanguage.Language, countrylanguage.CountryCode = country.Code, English, Dutch]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT DISTINCT country.Region FROM countrylanguage JOIN country ON countrylanguage.CountryCode = country.Code WHERE countrylanguage.Language = 'English' OR countrylanguage.Language = 'Dutch';,"SELECT DISTINCT T1.Region FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"" OR T2.Language  =  ""Dutch""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct ""country.Region"" values. 2. Condition Structure: Use a WHERE clause to filter for records where ""countrylanguage.Language"" is either 'English' or 'Dutch.' 3. Join Structure: Use an INNER JOIN between the ""countrylanguage"" table and the ""country"" table on ""countrylanguage.CountryCode = country.Code"" to associate languages with their respective countries and regions. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique regions are returned.","[('Caribbean',), ('Polynesia',), ('Australia and New Zealand',), ('Western Europe',), ('Middle East',), ('Central America',), ('North America',), ('Southeast Asia',), ('Nordic Countries',), ('South America',), ('British Islands',), ('Southern Europe',), ('Micronesia',), ('Eastern Asia',), ('Southern Africa',), ('Southern and Central Asia',), ('Western Africa',), ('Eastern Africa',), ('Micronesia/Caribbean',), ('Melanesia',)]","[('Caribbean',), ('Polynesia',), ('Australia and New Zealand',), ('Western Europe',), ('Middle East',), ('Central America',), ('North America',), ('Southeast Asia',), ('Nordic Countries',), ('South America',), ('British Islands',), ('Southern Europe',), ('Micronesia',), ('Eastern Asia',), ('Southern Africa',), ('Southern and Central Asia',), ('Western Africa',), ('Eastern Africa',), ('Micronesia/Caribbean',), ('Melanesia',)]",,1.0,
What is the birth date of the poker player with the lowest earnings?,"[poker_player.Earnings, poker_player.People_ID, people.Birth_Date, poker_player.People_ID = people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,SELECT people.Birth_Date FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID ORDER BY poker_player.Earnings ASC LIMIT 1;,SELECT T1.Birth_Date FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings ASC LIMIT 1,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""people.Birth_Date"" of the poker player with the lowest earnings. Use ORDER BY on ""poker_player.Earnings"" in ascending order to rank players by their earnings. Use LIMIT 1 to select the player with the lowest earnings. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the player with the lowest earnings. 3. Join Structure: Use an INNER JOIN between the ""poker_player"" and ""people"" tables on ""poker_player.People_ID = people.People_ID"" to link poker players with their personal details. 4. Aggregation Structure: No aggregation is required, as we are only retrieving the birth date of a single player.","[('August 8, 1986',)]","[('August 8, 1986',)]",,1.0,
What is the number of distinct continents where Chinese is spoken?,"[country.Continent, countrylanguage.Language, countrylanguage.CountryCode = country.Code, Chinese]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT COUNT(DISTINCT country.Continent) FROM countrylanguage JOIN country ON countrylanguage.CountryCode = country.Code WHERE countrylanguage.Language = 'Chinese';,"SELECT COUNT( DISTINCT Continent) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""Chinese""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the number of distinct continents. Use DISTINCT on ""country.Continent"" to ensure unique continents are counted. 2. Condition Structure: Use a WHERE clause to filter for records where the language is ""Chinese."" 3. Join Structure: Use an INNER JOIN between the ""countrylanguage"" and ""country"" tables on ""countrylanguage.CountryCode = country.Code"" to associate languages with their respective countries and continents. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique continents where ""Chinese"" is spoken.","[(4,)]","[(4,)]",,1.0,
Find the city with the largest population that uses English.,"[city.Name, city.Population, countrylanguage.Language, countrylanguage.IsOfficial, city.CountryCode = country.Code, countrylanguage.CountryCode = country.Code, English]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT city.Name FROM city JOIN country ON city.CountryCode = country.Code JOIN countrylanguage ON countrylanguage.CountryCode = country.Code WHERE countrylanguage.Language = 'English' AND countrylanguage.IsOfficial = 'T' ORDER BY city.Population DESC LIMIT 1;,"SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  ""English"" ORDER BY T1.Population DESC LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the city with the largest population. Use the MAX function to identify the city with the largest population. 2. Condition Structure: Use a WHERE clause to filter for cities in countries where the language is English and it is marked as official. 3. Join Structure: Use JOINs to connect the ""city"" table with the ""country"" table on ""city.CountryCode = country.Code"" and the ""countrylanguage"" table on ""countrylanguage.CountryCode = country.Code"" to link cities with their respective countries and languages. 4. Aggregation Structure: Use MAX to find the city with the largest population. Use ORDER BY in descending order of population and LIMIT 1 to ensure only the city with the largest population is returned.","[('New York',)]","[('New York', 8008278)]",,0.0,
How many unique languages are spoken in the world?,[countrylanguage.Language],"Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT COUNT(DISTINCT countrylanguage.Language) AS unique_languages FROM countrylanguage;,SELECT count(DISTINCT LANGUAGE) FROM countrylanguage,world_1,"1. Sequential Structure: Start with the SELECT clause to count the number of unique languages spoken in the world. 2. Condition Structure: No specific filtering condition is required since we want to count all unique languages. 3. Join Structure: No JOIN is necessary as the required information is available in the ""countrylanguage"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""countrylanguage.Language"" to count the unique languages.","[(457,)]","[(457,)]",,1.0,
Give the average life expectancy for countries in Africa which are republics?,"[country.LifeExpectancy, country.Continent, country.GovernmentForm, country.Continent = 'Africa', country.GovernmentForm = 'Republic']","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT AVG(country.LifeExpectancy) AS avg_life_expectancy FROM country WHERE country.Continent = 'Africa' AND country.GovernmentForm = 'Republic';,"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  ""Africa"" AND GovernmentForm  =  ""Republic""",world_1,"1. Sequential Structure: Start with the SELECT clause to calculate the average life expectancy for countries in Africa that are republics. 2. Condition Structure: Use a WHERE clause to filter for countries where the ""Continent"" is 'Africa' and the ""GovernmentForm"" is 'Republic'. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use the AVG function to calculate the average life expectancy for the filtered countries.","[(50.84347826086957,)]","[(50.84347826086957,)]",,1.0,
Which continent has the most diverse languages?,"[country.Continent, country.Code = countrylanguage.CountryCode, countrylanguage.Language]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,"SELECT country.Continent, COUNT(DISTINCT countrylanguage.Language) AS language_count FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode GROUP BY country.Continent ORDER BY language_count DESC LIMIT 1;",SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1,world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Continent"" and count the distinct ""countrylanguage.Language"" for each continent. Use COUNT with DISTINCT to count unique languages. 2. Condition Structure: No specific filtering condition is required, as we need to consider all continents and their languages. 3. Join Structure: Use a JOIN between the ""country"" and ""countrylanguage"" tables based on ""country.Code"" and ""countrylanguage.CountryCode"" to associate each continent with its languages. 4. Aggregation Structure: Use GROUP BY to group the results by ""country.Continent"" and apply ORDER BY in descending order of the count of distinct languages. Use LIMIT 1 to select the continent with the most diverse languages.","[('Africa', 215)]","[('Africa',)]",,1.0,
Return the nationalities for which there are two or more people.,"[people.Nationality, people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT people.Nationality FROM people GROUP BY people.Nationality HAVING COUNT(people.People_ID) >= 2;,SELECT Nationality FROM people GROUP BY Nationality HAVING COUNT(*)  >=  2,poker_player,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""people.Nationality"". 2. Aggregation Structure: Use COUNT to determine the number of people for each nationality. 3. Grouping Structure: Use GROUP BY on ""people.Nationality"" to aggregate the results by each nationality. 4. Condition Structure: Apply the HAVING clause to filter for nationalities that have two or more people, by setting the count to be greater than or equal to 2. 5. Join Structure: No JOIN is required since all necessary data is within the ""people"" table.","[('Russia',)]","[('Russia',)]",,1.0,
How many official languages does Afghanistan have?,"[country.Name, countrylanguage.Language, countrylanguage.IsOfficial, countrylanguage.CountryCode = country.Code, Afghanistan]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT COUNT(countrylanguage.Language) FROM country JOIN countrylanguage ON countrylanguage.CountryCode = country.Code WHERE country.Name = 'Afghanistan' AND countrylanguage.IsOfficial = 'T';,"SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  ""Afghanistan"" AND IsOfficial  =  ""T""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the number of official languages. Use COUNT to aggregate the ""countrylanguage.Language"" field. 2. Condition Structure: Use a WHERE clause to filter for records where the country name is ""Afghanistan"" and the language is marked as official (""IsOfficial"" = 'T'). 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables based on the relationship ""countrylanguage.CountryCode = country.Code"" to link languages to their respective countries. 4. Aggregation Structure: Use COUNT to calculate the total number of official languages for Afghanistan.","[(2,)]","[(2,)]",,1.0,
How many people are there of each nationality?,[people.Nationality],"Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,"SELECT people.Nationality, COUNT(*) AS count_of_people FROM people GROUP BY people.Nationality;","SELECT Nationality ,  COUNT(*) FROM people GROUP BY Nationality",poker_player,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the nationality and the count of people for each nationality. 2. Aggregation Structure: Use COUNT to calculate the number of people for each nationality. 3. Grouping Structure: Use GROUP BY on ""people.Nationality"" to group the results by nationality. 4. Join Structure: No JOIN is required since all necessary data is within the ""people"" table.","[('Bulgaria', 1), ('Russia', 6)]","[('Bulgaria', 1), ('Russia', 6)]",,1.0,
Return the maximum final tables made across all poker players who have earnings below 200000.,"[poker_player.Final_Table_Made, poker_player.Earnings]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT MAX(poker_player.Final_Table_Made) AS max_final_tables FROM poker_player WHERE poker_player.Earnings < 200000;,SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings  <  200000,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the maximum number of final tables made. 2. Condition Structure: Use a WHERE clause to filter poker players whose earnings are below 200000. 3. Join Structure: No JOIN is required since all necessary information is in the ""poker_player"" table. 4. Aggregation Structure: Use the MAX function to calculate the maximum value of ""poker_player.Final_Table_Made"" for the filtered records.","[(26.0,)]","[(26.0,)]",,1.0,
Which languages are spoken by only one country in republic governments?,"[countrylanguage.Language, countrylanguage.CountryCode, country.Code, country.GovernmentForm, city.CountryCode = country.Code, countrylanguage.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT countrylanguage.Language FROM countrylanguage JOIN country ON countrylanguage.CountryCode = country.Code WHERE country.GovernmentForm = 'Republic' GROUP BY countrylanguage.Language HAVING COUNT(DISTINCT countrylanguage.CountryCode) = 1;,"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.GovernmentForm  =  ""Republic"" GROUP BY T2.Language HAVING COUNT(*)  =  1",world_1,1. Sequential Structure: Start with the SELECT clause to retrieve the distinct languages spoken. Use the FROM clause to specify the countrylanguage and country tables. Apply a WHERE clause to filter for countries with a government form of 'Republic'. Use GROUP BY to group by language and HAVING to filter languages spoken by only one country. 2. Condition Structure: Use the WHERE clause to filter for countries with a government form of 'Republic'. Use the HAVING clause to ensure that the count of distinct countries for each language is exactly one. 3. Join Structure: Use an INNER JOIN between the countrylanguage and country tables based on the CountryCode and Code fields to connect languages with their respective countries. 4. Aggregation Structure: Use COUNT in the HAVING clause to count the number of countries associated with each language and filter for languages spoken by only one country.,"[('Abhyasi',), ('Acholi',), ('Adja',), ('Aizo',), ('Ambo',), ('Amhara',), ('Ami',), ('Ane',), ('Arabic-French',), ('Arabic-French-English',), ('Araucan',), ('Assyrian',), ('Atayal',), ('Bajad',), ('Balante',), ('Bali',), ('Balochi',), ('Bambara',), ('Bamileke-bamum',), ('Banda',), ('Banja',), ('Bariba',), ('Bassa',), ('Batakki',), ('Bemba',), ('Bengali',), ('Berberi',), ('Bhojpuri',), ('Bicol',), ('Bilin',), ('Bislama',), ('Boa',), ('Brahui',), ('Bubi',), ('Bugi',), ('Bullom-sherbro',), ('Burmese',), ('Buryat',), ('Busansi',), ('Cakchiquel',), ('Caprivi',), ('Cebuano',), ('Chaga and Pare',), ('Chakma',), ('Chewa',), ('Chichewa',), ('Chin',), ('Chuabo',), ('Comorian',), ('Comorian-Arabic',), ('Comorian-French',), ('Comorian-Swahili',), ('Comorian-madagassi',), ('Cuna',), ('Czech',), ('Czech and Moravian',), ('Dagara',), ('Dariganga',), ('Dhivehi',), ('Dorbet',), ('Duala',), ('Dyula',), ('Embera',), ('Fijian',), ('Fon',), ('Friuli',), ('Ga-adangme',), ('Gagauzi',), ('Ganda',), ('Garifuna',), ('Garo',), ('Gbaya',), ('Georgiana',), ('Gio',), ('Gisu',), ('Gogo',), ('Gorane',), ('Grebo',), ('Guaymí',), ('Gur',), ('Gurage',), ('Gusii',), ('Ha',), ('Hadareb',), ('Hadjarai',), ('Haiti Creole',), ('Hakka',), ('Hassaniya',), ('Hausa',), ('Haya',), ('Hebrew',), ('Hehet',), ('Herero',), ('Hiligaynon',), ('Hindko',), ('Icelandic',), ('Ilocano',), ('Irish',), ('Javanese',), ('Kabyé',), ('Kachin',), ('Kalenjin',), ('Kamba',), ('Kanem-bornu',), ('Kanuri',), ('Karakalpak',), ('Karen',), ('Kavango',), ('Kayah',), ('Kekchí',), ('Khasi',), ('Khoekhoe',), ('Kiga',), ('Kikuyu',), ('Kirgiz',), ('Kirundi',), ('Kissi',), ('Kono-vai',), ('Korean',), ('Kotokoli',), ('Kuranko',), ('Lango',), ('Lao',), ('Lao-Soung',), ('Latvian',), ('Limba',), ('Lozi',), ('Luba',), ('Luchazi',), ('Lugbara',), ('Luguru',), ('Luhya',), ('Luimbe-nganguela',), ('Luo',), ('Luvale',), ('Madura',), ('Maguindanao',), ('Maka',), ('Makonde',), ('Makua',), ('Maltese',), ('Mam',), ('Mandara',), ('Mandarin Chinese',), ('Mandjia',), ('Mandyako',), ('Mano',), ('Maranao',), ('Marathi',), ('Marendje',), ('Marma',), ('Marshallese',), ('Masai',), ('Masana',), ('Mayo-kebbi',), ('Mboshi',), ('Mbum',), ('Mbundu',), ('Mende',), ('Meru',), ('Min',), ('Minangkabau',), ('Mixed Languages',), ('Moba',), ('Mon',), ('Mon-khmer',), ('Mongo',), ('Mongolian',), ('Moravian',), ('Mpongwe',), ('Nahua',), ('Nama',), ('Naudemba',), ('Nauru',), ('Ngala and Bangi',), ('Ngbaka',), ('Ngoni',), ('Nkole',), ('Northsotho',), ('Nsenga',), ('Nyakusa',), ('Nyamwesi',), ('Nyaneka-nkhumbi',), ('Nyika',), ('Oromo',), ('Osseetti',), ('Ouaddai',), ('Ovambo',), ('Ovimbundu',), ('Paiwan',), ('Palau',), ('Pampango',), ('Pangasinan',), ('Pashto',), ('Persian',), ('Philippene Languages',), ('Pilipino',), ('Punjabi',), ('Punu',), ('Punu-sira-nzebi',), ('Quiché',), ('Rakhine',), ('Rapa nui',), ('Ronga',), ('Rundi',), ('Saame',), ('Saho',), ('Sango',), ('Santhali',), ('Saraiki',), ('Sardinian',), ('Sena',), ('Senufo and Minianka',), ('Serer',), ('Seselwa',), ('Shambala',), ('Shan',), ('Sidamo',), ('Silesiana',), ('Sinaberberi',), ('Sindhi',), ('Singali',), ('Soga',), ('Somba',), ('Songhai',), ('Songhai-zerma',), ('Soqutri',), ('Southsotho',), ('Sranantonga',), ('Sumo',), ('Sunda',), ('Susu',), ('Swazi',), ('Swedish',), ('Tandjile',), ('Temne',), ('Teso',), ('Thai',), ('Tigre',), ('Tikar',), ('Tongan',), ('Tripuri',), ('Tswa',), ('Tukulor',), ('Turkana',), ('Turkmenian',), ('Ukrainian and Russian',), ('Urdu',), ('Venda',), ('Walaita',), ('Waray-waray',), ('Watyi',), ('Xhosa',), ('Yao',), ('Zande',), ('Zenaga',), ('Zulu',), ('[South]Mande',)]","[('Abhyasi',), ('Acholi',), ('Adja',), ('Aizo',), ('Ambo',), ('Amhara',), ('Ami',), ('Ane',), ('Arabic-French',), ('Arabic-French-English',), ('Araucan',), ('Assyrian',), ('Atayal',), ('Bajad',), ('Balante',), ('Bali',), ('Balochi',), ('Bambara',), ('Bamileke-bamum',), ('Banda',), ('Banja',), ('Bariba',), ('Bassa',), ('Batakki',), ('Bemba',), ('Bengali',), ('Berberi',), ('Bhojpuri',), ('Bicol',), ('Bilin',), ('Bislama',), ('Boa',), ('Brahui',), ('Bubi',), ('Bugi',), ('Bullom-sherbro',), ('Burmese',), ('Buryat',), ('Busansi',), ('Cakchiquel',), ('Caprivi',), ('Cebuano',), ('Chaga and Pare',), ('Chakma',), ('Chewa',), ('Chichewa',), ('Chin',), ('Chuabo',), ('Comorian',), ('Comorian-Arabic',), ('Comorian-French',), ('Comorian-Swahili',), ('Comorian-madagassi',), ('Cuna',), ('Czech',), ('Czech and Moravian',), ('Dagara',), ('Dariganga',), ('Dhivehi',), ('Dorbet',), ('Duala',), ('Dyula',), ('Embera',), ('Fijian',), ('Fon',), ('Friuli',), ('Ga-adangme',), ('Gagauzi',), ('Ganda',), ('Garifuna',), ('Garo',), ('Gbaya',), ('Georgiana',), ('Gio',), ('Gisu',), ('Gogo',), ('Gorane',), ('Grebo',), ('Guaymí',), ('Gur',), ('Gurage',), ('Gusii',), ('Ha',), ('Hadareb',), ('Hadjarai',), ('Haiti Creole',), ('Hakka',), ('Hassaniya',), ('Hausa',), ('Haya',), ('Hebrew',), ('Hehet',), ('Herero',), ('Hiligaynon',), ('Hindko',), ('Icelandic',), ('Ilocano',), ('Irish',), ('Javanese',), ('Kabyé',), ('Kachin',), ('Kalenjin',), ('Kamba',), ('Kanem-bornu',), ('Kanuri',), ('Karakalpak',), ('Karen',), ('Kavango',), ('Kayah',), ('Kekchí',), ('Khasi',), ('Khoekhoe',), ('Kiga',), ('Kikuyu',), ('Kirgiz',), ('Kirundi',), ('Kissi',), ('Kono-vai',), ('Korean',), ('Kotokoli',), ('Kuranko',), ('Lango',), ('Lao',), ('Lao-Soung',), ('Latvian',), ('Limba',), ('Lozi',), ('Luba',), ('Luchazi',), ('Lugbara',), ('Luguru',), ('Luhya',), ('Luimbe-nganguela',), ('Luo',), ('Luvale',), ('Madura',), ('Maguindanao',), ('Maka',), ('Makonde',), ('Makua',), ('Maltese',), ('Mam',), ('Mandara',), ('Mandarin Chinese',), ('Mandjia',), ('Mandyako',), ('Mano',), ('Maranao',), ('Marathi',), ('Marendje',), ('Marma',), ('Marshallese',), ('Masai',), ('Masana',), ('Mayo-kebbi',), ('Mboshi',), ('Mbum',), ('Mbundu',), ('Mende',), ('Meru',), ('Min',), ('Minangkabau',), ('Mixed Languages',), ('Moba',), ('Mon',), ('Mon-khmer',), ('Mongo',), ('Mongolian',), ('Moravian',), ('Mpongwe',), ('Nahua',), ('Nama',), ('Naudemba',), ('Nauru',), ('Ngala and Bangi',), ('Ngbaka',), ('Ngoni',), ('Nkole',), ('Northsotho',), ('Nsenga',), ('Nyakusa',), ('Nyamwesi',), ('Nyaneka-nkhumbi',), ('Nyika',), ('Oromo',), ('Osseetti',), ('Ouaddai',), ('Ovambo',), ('Ovimbundu',), ('Paiwan',), ('Palau',), ('Pampango',), ('Pangasinan',), ('Pashto',), ('Persian',), ('Philippene Languages',), ('Pilipino',), ('Punjabi',), ('Punu',), ('Punu-sira-nzebi',), ('Quiché',), ('Rakhine',), ('Rapa nui',), ('Ronga',), ('Rundi',), ('Saame',), ('Saho',), ('Sango',), ('Santhali',), ('Saraiki',), ('Sardinian',), ('Sena',), ('Senufo and Minianka',), ('Serer',), ('Seselwa',), ('Shambala',), ('Shan',), ('Sidamo',), ('Silesiana',), ('Sinaberberi',), ('Sindhi',), ('Singali',), ('Soga',), ('Somba',), ('Songhai',), ('Songhai-zerma',), ('Soqutri',), ('Southsotho',), ('Sranantonga',), ('Sumo',), ('Sunda',), ('Susu',), ('Swazi',), ('Swedish',), ('Tandjile',), ('Temne',), ('Teso',), ('Thai',), ('Tigre',), ('Tikar',), ('Tongan',), ('Tripuri',), ('Tswa',), ('Tukulor',), ('Turkana',), ('Turkmenian',), ('Ukrainian and Russian',), ('Urdu',), ('Venda',), ('Walaita',), ('Waray-waray',), ('Watyi',), ('Xhosa',), ('Yao',), ('Zande',), ('Zenaga',), ('Zulu',), ('[South]Mande',)]",,1.0,
What is the maximum number of final tables made among poker players with earnings less than 200000?,"[poker_player.Final_Table_Made, poker_player.Earnings, 200000]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT MAX(poker_player.Final_Table_Made) AS max_final_tables FROM poker_player WHERE poker_player.Earnings < 200000;,SELECT max(Final_Table_Made) FROM poker_player WHERE Earnings  <  200000,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the maximum number of final tables made. 2. Condition Structure: Use a WHERE clause to filter poker players with earnings less than 200000. 3. Join Structure: No JOIN is required since all necessary information is in the ""poker_player"" table. 4. Aggregation Structure: Use the MAX function to calculate the maximum number of final tables made among the filtered poker players.","[(26.0,)]","[(26.0,)]",,1.0,
How many people live in countries that do not speak English?,"[country.Population, country.Code = countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.IsOfficial, English]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT SUM(country.Population) AS total_population FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Code NOT IN ( SELECT countrylanguage.CountryCode FROM countrylanguage WHERE countrylanguage.Language = 'English' AND countrylanguage.IsOfficial = 'Yes' );,"SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"")",world_1,1. Sequential Structure: Start with the SELECT clause to calculate the total population of countries that do not speak English. Use the FROM clause to specify the country and countrylanguage tables. Use a WHERE clause to filter for countries where English is not spoken as an official language. 2. Condition Structure: Use the WHERE clause to filter for rows where the language is 'English' and IsOfficial is 'No'. Use a subquery to identify countries that do not have English as an official language. 3. Join Structure: Use an INNER JOIN between the country and countrylanguage tables based on the CountryCode and Code fields to connect country population data with language data. 4. Aggregation Structure: Use the SUM function to calculate the total population of the filtered countries.,"[(53486187050,)]","[(5451331150,)]",,1.0,
What are the countries that have greater surface area than any country in Europe?,"[country.Name, country.SurfaceArea, country.Continent, city.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT Name FROM country WHERE SurfaceArea > ALL (SELECT SurfaceArea FROM country WHERE Continent = 'Europe');,"SELECT Name FROM country WHERE SurfaceArea  >  (SELECT min(SurfaceArea) FROM country WHERE Continent  =  ""Europe"")",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries. Use the FROM clause to specify the country table. Apply a WHERE clause to filter countries whose surface area is greater than the surface area of any country in Europe. 2. Condition Structure: Use the WHERE clause with a subquery to compare the surface area of countries to the maximum surface area of countries in Europe. The subquery filters countries in Europe based on the ""Continent"" column. 3. Join Structure: Not required, as all the necessary data is in the country table. 4. Aggregation Structure: Use a subquery to find the maximum surface area of countries in Europe and compare it with the surface area of other countries.",[],"[('Aruba',), ('Afghanistan',), ('Angola',), ('Anguilla',), ('Albania',), ('Andorra',), ('Netherlands Antilles',), ('United Arab Emirates',), ('Argentina',), ('Armenia',), ('American Samoa',), ('Antarctica',), ('French Southern territories',), ('Antigua and Barbuda',), ('Australia',), ('Austria',), ('Azerbaijan',), ('Burundi',), ('Belgium',), ('Benin',), ('Burkina Faso',), ('Bangladesh',), ('Bulgaria',), ('Bahrain',), ('Bahamas',), ('Bosnia and Herzegovina',), ('Belarus',), ('Belize',), ('Bermuda',), ('Bolivia',), ('Brazil',), ('Barbados',), ('Brunei',), ('Bhutan',), ('Bouvet Island',), ('Botswana',), ('Central African Republic',), ('Canada',), ('Cocos (Keeling) Islands',), ('Switzerland',), ('Chile',), ('China',), ('Côte d’Ivoire',), ('Cameroon',), ('Congo, The Democratic Republic of the',), ('Congo',), ('Cook Islands',), ('Colombia',), ('Comoros',), ('Cape Verde',), ('Costa Rica',), ('Cuba',), ('Christmas Island',), ('Cayman Islands',), ('Cyprus',), ('Czech Republic',), ('Germany',), ('Djibouti',), ('Dominica',), ('Denmark',), ('Dominican Republic',), ('Algeria',), ('Ecuador',), ('Egypt',), ('Eritrea',), ('Western Sahara',), ('Spain',), ('Estonia',), ('Ethiopia',), ('Finland',), ('Fiji Islands',), ('Falkland Islands',), ('France',), ('Faroe Islands',), ('Micronesia, Federated States of',), ('Gabon',), ('United Kingdom',), ('Georgia',), ('Ghana',), ('Gibraltar',), ('Guinea',), ('Guadeloupe',), ('Gambia',), ('Guinea-Bissau',), ('Equatorial Guinea',), ('Greece',), ('Grenada',), ('Greenland',), ('Guatemala',), ('French Guiana',), ('Guam',), ('Guyana',), ('Hong Kong',), ('Heard Island and McDonald Islands',), ('Honduras',), ('Croatia',), ('Haiti',), ('Hungary',), ('Indonesia',), ('India',), ('British Indian Ocean Territory',), ('Ireland',), ('Iran',), ('Iraq',), ('Iceland',), ('Israel',), ('Italy',), ('Jamaica',), ('Jordan',), ('Japan',), ('Kazakstan',), ('Kenya',), ('Kyrgyzstan',), ('Cambodia',), ('Kiribati',), ('Saint Kitts and Nevis',), ('South Korea',), ('Kuwait',), ('Laos',), ('Lebanon',), ('Liberia',), ('Libyan Arab Jamahiriya',), ('Saint Lucia',), ('Liechtenstein',), ('Sri Lanka',), ('Lesotho',), ('Lithuania',), ('Luxembourg',), ('Latvia',), ('Macao',), ('Morocco',), ('Monaco',), ('Moldova',), ('Madagascar',), ('Maldives',), ('Mexico',), ('Marshall Islands',), ('Macedonia',), ('Mali',), ('Malta',), ('Myanmar',), ('Mongolia',), ('Northern Mariana Islands',), ('Mozambique',), ('Mauritania',), ('Montserrat',), ('Martinique',), ('Mauritius',), ('Malawi',), ('Malaysia',), ('Mayotte',), ('Namibia',), ('New Caledonia',), ('Niger',), ('Norfolk Island',), ('Nigeria',), ('Nicaragua',), ('Niue',), ('Netherlands',), ('Norway',), ('Nepal',), ('Nauru',), ('New Zealand',), ('Oman',), ('Pakistan',), ('Panama',), ('Pitcairn',), ('Peru',), ('Philippines',), ('Palau',), ('Papua New Guinea',), ('Poland',), ('Puerto Rico',), ('North Korea',), ('Portugal',), ('Paraguay',), ('Palestine',), ('French Polynesia',), ('Qatar',), ('Réunion',), ('Romania',), ('Russian Federation',), ('Rwanda',), ('Saudi Arabia',), ('Sudan',), ('Senegal',), ('Singapore',), ('South Georgia and the South Sandwich Islands',), ('Saint Helena',), ('Svalbard and Jan Mayen',), ('Solomon Islands',), ('Sierra Leone',), ('El Salvador',), ('San Marino',), ('Somalia',), ('Saint Pierre and Miquelon',), ('Sao Tome and Principe',), ('Suriname',), ('Slovakia',), ('Slovenia',), ('Sweden',), ('Swaziland',), ('Seychelles',), ('Syria',), ('Turks and Caicos Islands',), ('Chad',), ('Togo',), ('Thailand',), ('Tajikistan',), ('Tokelau',), ('Turkmenistan',), ('East Timor',), ('Tonga',), ('Trinidad and Tobago',), ('Tunisia',), ('Turkey',), ('Tuvalu',), ('Taiwan',), ('Tanzania',), ('Uganda',), ('Ukraine',), ('United States Minor Outlying Islands',), ('Uruguay',), ('United States',), ('Uzbekistan',), ('Saint Vincent and the Grenadines',), ('Venezuela',), ('Virgin Islands, British',), ('Virgin Islands, U.S.',), ('Vietnam',), ('Vanuatu',), ('Wallis and Futuna',), ('Samoa',), ('Yemen',), ('Yugoslavia',), ('South Africa',), ('Zambia',), ('Zimbabwe',)]","near ""ALL"": syntax error",0.0,
What is the most populace city that speaks English?,"[city.Name, city.Population, countrylanguage.Language, countrylanguage.IsOfficial, city.CountryCode = countrylanguage.CountryCode, countrylanguage.CountryCode = country.Code, English]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,"SELECT city.Name, city.Population FROM city JOIN countrylanguage ON city.CountryCode = countrylanguage.CountryCode WHERE countrylanguage.Language = 'English' AND countrylanguage.IsOfficial = 'T' ORDER BY city.Population DESC LIMIT 1;","SELECT T1.Name ,  T1.Population FROM city AS T1 JOIN countrylanguage AS T2 ON T1.CountryCode  =  T2.CountryCode WHERE T2.Language  =  ""English"" ORDER BY T1.Population DESC LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the city (""city.Name"") and its population (""city.Population""). Since we are looking for the most populous city, use ORDER BY on ""city.Population"" in descending order and LIMIT 1 to get the top result. 2. Condition Structure: Use a WHERE clause to filter for cities where the language spoken is ""English"" and it is marked as official (""countrylanguage.IsOfficial = 'T'""). 3. Join Structure: Use JOIN clauses to connect the ""city"" table with the ""countrylanguage"" table on ""city.CountryCode = countrylanguage.CountryCode"" to associate cities with their languages. 4. Aggregation Structure: No aggregation is needed as we are only retrieving the most populous city that meets the conditions.","[('New York', 8008278)]","[('New York', 8008278)]",,1.0,
Which language is the most popular on the Asian continent?,"[countrylanguage.Language, countrylanguage.Percentage, country.Code, country.Continent, countrylanguage.CountryCode = country.Code, Asia]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,"SELECT countrylanguage.Language, SUM(countrylanguage.Percentage) AS total_percentage FROM countrylanguage JOIN country ON countrylanguage.CountryCode = country.Code WHERE country.Continent = 'Asia' GROUP BY countrylanguage.Language ORDER BY total_percentage DESC LIMIT 1;","SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Continent  =  ""Asia"" GROUP BY T2.Language ORDER BY COUNT (*) DESC LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countrylanguage.Language"" and the total percentage of speakers for each language. Use SUM on ""countrylanguage.Percentage"" to calculate the total percentage of speakers for each language. 2. Condition Structure: Use a WHERE clause to filter for countries located on the Asian continent by checking ""country.Continent = 'Asia'."" 3. Join Structure: Use an INNER JOIN between the ""countrylanguage"" and ""country"" tables on ""countrylanguage.CountryCode = country.Code"" to associate languages with their respective countries. 4. Aggregation Structure: Use GROUP BY on ""countrylanguage.Language"" to group the results by language. Use ORDER BY in descending order on the aggregated percentage to rank languages by popularity. Use LIMIT 1 to select the most popular language.","[('Arabic', 975.4)]","[('Arabic',)]",,1.0,
Return the average earnings across all poker players.,[poker_player.Earnings],"Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT AVG(poker_player.Earnings) AS average_earnings FROM poker_player;,SELECT avg(Earnings) FROM poker_player,poker_player,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average earnings. 2. Aggregation Structure: Use the AVG function to calculate the average of the ""poker_player.Earnings"" column. 3. Condition Structure: No specific filtering condition is required as the query asks for the average earnings across all poker players. 4. Join Structure: No JOIN is required since the necessary data is within the ""poker_player"" table.","[(301891.2,)]","[(301891.2,)]",,1.0,
Count the number of different nationalities.,[people.Nationality],"Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT COUNT(DISTINCT people.Nationality) AS num_nationalities FROM people;,SELECT count(DISTINCT Nationality) FROM people,poker_player,"1. Sequential Structure: Start with the SELECT clause to count the distinct nationalities. 2. Condition Structure: No specific filtering condition is required as we want to count all distinct nationalities. 3. Join Structure: No JOIN is required since the information is available in the ""people"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""people.Nationality"" to count the number of different nationalities.","[(2,)]","[(2,)]",,1.0,
What is the total number of unique official languages spoken in the countries that are founded before 1930?,"[country.IndepYear, country.Code = countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.IsOfficial]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT COUNT(DISTINCT countrylanguage.Language) AS total_unique_official_languages FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.IndepYear < 1930 AND countrylanguage.IsOfficial = 'T';,"SELECT count(DISTINCT T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE  IndepYear  <  1930 AND T2.IsOfficial  =  ""T""",world_1,1. Sequential Structure: Start with the SELECT clause to count the total number of unique official languages. Use the FROM clause to specify the countrylanguage table. Apply a WHERE clause to filter for countries founded before 1930 and where the language is official. 2. Condition Structure: Use the WHERE clause to filter for countries with an IndepYear less than 1930 and for languages marked as official (IsOfficial = 'T'). 3. Join Structure: Use an INNER JOIN between the country and countrylanguage tables based on the CountryCode to connect countries with their languages. 4. Aggregation Structure: Use COUNT(DISTINCT) to count the unique official languages spoken in the filtered countries.,"[(40,)]","[(40,)]",,1.0,
What are different nationalities of people and the corresponding number of people from each nation?,"[people.Nationality, people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,"SELECT people.Nationality, COUNT(people.People_ID) AS number_of_people FROM people GROUP BY people.Nationality;","SELECT Nationality ,  COUNT(*) FROM people GROUP BY Nationality",poker_player,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the nationality and the count of people from each nationality. 2. Aggregation Structure: Use COUNT to calculate the number of people for each nationality. 3. Grouping Structure: Use GROUP BY on ""people.Nationality"" to group the results by nationality. 4. Join Structure: No JOIN is required since all necessary data is within the ""people"" table. 5. Condition Structure: No specific filtering condition is required as we want the count for all nationalities.","[('Bulgaria', 1), ('Russia', 6)]","[('Bulgaria', 1), ('Russia', 6)]",,1.0,
What is the total surface area of the countries in the Caribbean region?,"[country.SurfaceArea, country.Region, country.Region = 'Caribbean']","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT SUM(country.SurfaceArea) AS total_surface_area FROM country WHERE country.Region = 'Caribbean';,"SELECT sum(SurfaceArea) FROM country WHERE Region  =  ""Caribbean""",world_1,"1. Sequential Structure: Start with the SELECT clause to calculate the total surface area of countries in the Caribbean region. Use the SUM function on the ""country.SurfaceArea"" field. 2. Condition Structure: Use a WHERE clause to filter for countries where ""country.Region"" is equal to 'Caribbean'. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use the SUM function to calculate the total surface area for the specified region.","[(234423.0,)]","[(234423.0,)]",,1.0,
What are the package options of all tv channels that are not playing any cartoons directed by Ben Jones?,"[TV_Channel.Package_Option,Cartoon.Directed_by,Cartoon.Channel = TV_Channel.id,Ben Jones]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NESTED,SELECT Package_Option FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones');,SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'),tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the package options of TV channels. Use the FROM clause to specify the TV_Channel table. Apply a WHERE clause to filter out channels that are playing cartoons directed by Ben Jones. 2. Condition Structure: Use a WHERE clause with a subquery to exclude channels whose IDs are associated with cartoons directed by Ben Jones. The subquery retrieves the channel IDs from the Cartoon table where the Directed_by column is 'Ben Jones'. 3. Join Structure: Not required, as the filtering is done using a subquery and the main query only involves the TV_Channel table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',), ('no ( FTV )',), ('Sky Famiglia + Sky HD',), ('no ( FTV )',), ('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',)]","[('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',), ('no ( FTV )',), ('Sky Famiglia + Sky HD',), ('no ( FTV )',), ('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',)]",,1.0,
Count the number of poker players.,[poker_player.Poker_Player_ID],"Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT COUNT(poker_player.Poker_Player_ID) AS poker_player_count FROM poker_player;,SELECT count(*) FROM poker_player,poker_player,"1. Sequential Structure: Start with the SELECT clause to count the number of poker players. Use the COUNT function on the ""poker_player.Poker_Player_ID"" column. 2. Condition Structure: No specific filtering condition is required since we want to count all poker players. 3. Join Structure: No JOIN is necessary as the required information is available within the ""poker_player"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of poker players.","[(5,)]","[(5,)]",,1.0,
What are the number of votes from state 'NY' or 'CA'?,"[VOTES.state,VOTES.contestant_number,VOTES.vote_id,VOTES.state = AREA_CODE_STATE.state,AREA_CODE_STATE.state,NY,CA]","Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",NON-NESTED,SELECT COUNT(VOTES.vote_id) FROM VOTES JOIN AREA_CODE_STATE ON VOTES.state = AREA_CODE_STATE.state WHERE VOTES.state = 'NY' OR VOTES.state = 'CA';,SELECT count(*) FROM votes WHERE state  =  'NY' OR state  =  'CA',voter_1,"1. Sequential Structure: Start with the SELECT clause to count the number of votes. Use COUNT on ""VOTES.vote_id"" to calculate the total number of votes. 2. Condition Structure: Use a WHERE clause to filter for votes from the states 'NY' or 'CA'. 3. Join Structure: Use a JOIN between the ""VOTES"" table and the ""AREA_CODE_STATE"" table on the ""state"" column to ensure the state information is correctly linked. 4. Aggregation Structure: Use COUNT to aggregate the total number of votes for the specified states.","[(64,)]","[(3,)]",,0.0,
What is the total surface area of the continents Asia and Europe?,"[country.SurfaceArea, country.Continent]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,"SELECT SUM(country.SurfaceArea) AS total_surface_area FROM country WHERE country.Continent IN ('Asia', 'Europe');","SELECT sum(SurfaceArea) FROM country WHERE Continent  =  ""Asia"" OR Continent  =  ""Europe""",world_1,"1. Sequential Structure: Start with the SELECT clause to calculate the total surface area. Use the SUM function on ""country.SurfaceArea"" to compute the total. 2. Condition Structure: Use a WHERE clause to filter for countries located in the continents ""Asia"" and ""Europe"". 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use the SUM function to aggregate the surface area values for the specified continents.","[(54930138.9,)]","[(54930138.9,)]",,1.0,
Return the money rank of the poker player with the greatest height.,"[poker_player.Money_Rank,people.Height,poker_player.People_ID = people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,SELECT poker_player.Money_Rank FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID ORDER BY people.Height DESC LIMIT 1;,SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""poker_player.Money_Rank"" of the poker player. Use ORDER BY in descending order on ""people.Height"" to rank players by height. Use LIMIT 1 to select the poker player with the greatest height. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the poker player with the greatest height. 3. Join Structure: Use an INNER JOIN between the ""poker_player"" and ""people"" tables based on the foreign key relationship ""poker_player.People_ID = people.People_ID"" to link poker players with their corresponding people data. 4. Aggregation Structure: No aggregation is required since we are only retrieving the money rank of the tallest poker player.","[(68.0,)]","[(68.0,)]",,1.0,
What is the money rank of the tallest poker player?,"[poker_player.Money_Rank,people.Height,people.People_ID = poker_player.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,SELECT poker_player.Money_Rank FROM people JOIN poker_player ON people.People_ID = poker_player.People_ID ORDER BY people.Height DESC LIMIT 1;,SELECT T2.Money_Rank FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T1.Height DESC LIMIT 1,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""poker_player.Money_Rank"" of the tallest poker player. Use ORDER BY in descending order on ""people.Height"" to rank players by height and LIMIT 1 to select the tallest player. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the tallest poker player. 3. Join Structure: Use an INNER JOIN between the ""people"" and ""poker_player"" tables based on the foreign key relationship ""people.People_ID = poker_player.People_ID"" to combine player details with their poker statistics. 4. Aggregation Structure: No aggregation is required since we are only retrieving the money rank of a single player.","[(68.0,)]","[(68.0,)]",,1.0,
What region is Kabul in?,"[city.Name, city.District, city.CountryCode = country.Code, country.Region]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT country.Region FROM city JOIN country ON city.CountryCode = country.Code WHERE city.Name = 'Kabul';,"SELECT Region FROM country AS T1 JOIN city AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Name  =  ""Kabul""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Region"" field, as the question asks for the region of Kabul. 2. Condition Structure: Use a WHERE clause to filter for the city with the name ""Kabul."" 3. Join Structure: Use an INNER JOIN between the ""city"" and ""country"" tables on the ""city.CountryCode"" and ""country.Code"" fields to link the city with its corresponding country. 4. Aggregation Structure: No aggregation is needed since we are retrieving a single value.","[('Southern and Central Asia',)]","[('Southern and Central Asia',)]",,1.0,
What are the contestant numbers and names of the contestants who had at least two votes?,"[CONTESTANTS.contestant_number, CONTESTANTS.contestant_name, VOTES.contestant_number, VOTES.vote_id, VOTES.contestant_number = CONTESTANTS.contestant_number]","Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",NESTED,"SELECT CONTESTANTS.contestant_number, CONTESTANTS.contestant_name FROM CONTESTANTS JOIN VOTES ON CONTESTANTS.contestant_number = VOTES.contestant_number GROUP BY CONTESTANTS.contestant_number, CONTESTANTS.contestant_name HAVING COUNT(VOTES.vote_id) >= 2;","SELECT T1.contestant_number , T1.contestant_name FROM contestants AS T1 JOIN votes AS T2 ON T1.contestant_number  =  T2.contestant_number GROUP BY T1.contestant_number HAVING count(*)  >=  2",voter_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the contestant numbers and names. Use the FROM clause to specify the CONTESTANTS table and JOIN it with the VOTES table to link contestants with their votes. Use GROUP BY to group votes by contestant_number, allowing us to count the votes for each contestant. Apply a HAVING clause to filter contestants with at least two votes. 2. Condition Structure: Use the HAVING clause with COUNT(vote_id) to filter for contestants who have two or more votes. 3. Join Structure: Use an INNER JOIN between the CONTESTANTS and VOTES tables based on contestant_number to connect contestants with their votes. 4. Aggregation Structure: Use COUNT(vote_id) to count the number of votes for each contestant and filter based on this count.","[(3, 'Kelly Clauss')]","[(3, 'Kelly Clauss')]",,1.0,
What are the countries where either English or Dutch is the official language ?,"[country.Name, countrylanguage.Language, countrylanguage.IsOfficial, countrylanguage.CountryCode = country.Code, English, Dutch, official]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT country.Name FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE (countrylanguage.Language = 'English' OR countrylanguage.Language = 'Dutch') AND countrylanguage.IsOfficial = 'T';,"select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  ""english"" and isofficial  =  ""t"" union select t1.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode where t2.language  =  ""dutch"" and isofficial  =  ""t""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries (""country.Name""). 2. Condition Structure: Use a WHERE clause to filter for records where the ""countrylanguage.Language"" is either 'English' or 'Dutch' and ""countrylanguage.IsOfficial"" is 'T' (indicating the language is official). 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables on ""country.Code = countrylanguage.CountryCode"" to associate countries with their languages. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of countries that meet the specified conditions.","[('Aruba',), ('Anguilla',), ('Netherlands Antilles',), ('American Samoa',), ('Antigua and Barbuda',), ('Australia',), ('Belgium',), ('Belize',), ('Bermuda',), ('Barbados',), ('Canada',), ('Cocos (Keeling) Islands',), ('Christmas Island',), ('Cayman Islands',), ('Falkland Islands',), ('United Kingdom',), ('Gibraltar',), ('Guam',), ('Hong Kong',), ('Ireland',), ('Saint Kitts and Nevis',), ('Saint Lucia',), ('Lesotho',), ('Marshall Islands',), ('Malta',), ('Northern Mariana Islands',), ('Montserrat',), ('Norfolk Island',), ('Niue',), ('Netherlands',), ('Nauru',), ('New Zealand',), ('Palau',), ('Saint Helena',), ('Seychelles',), ('Turks and Caicos Islands',), ('Tokelau',), ('Tonga',), ('Tuvalu',), ('United States Minor Outlying Islands',), ('United States',), ('Saint Vincent and the Grenadines',), ('Virgin Islands, British',), ('Virgin Islands, U.S.',), ('Vanuatu',), ('Samoa',), ('South Africa',), ('Zimbabwe',)]",[],,1.0,
What is the total number of languages used in Aruba?,"[country.Name, country.Code, countrylanguage.CountryCode = country.Code, countrylanguage.Language]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT COUNT(countrylanguage.Language) FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Name = 'Aruba';,"SELECT COUNT(T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  ""Aruba""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the total number of languages. Use COUNT on ""countrylanguage.Language"" to calculate the total number of languages. 2. Condition Structure: Use a WHERE clause to filter for the country ""Aruba"" by matching ""country.Name"" with 'Aruba'. 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables based on the relationship ""countrylanguage.CountryCode = country.Code"" to link languages to the country. 4. Aggregation Structure: Use COUNT to aggregate the total number of languages for the specified country.","[(4,)]","[(4,)]",,1.0,
Return the names of poker players sorted by their earnings descending.,"[people.Name, poker_player.Earnings, poker_player.People_ID = people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,"SELECT people.Name, poker_player.Earnings FROM people JOIN poker_player ON poker_player.People_ID = people.People_ID ORDER BY poker_player.Earnings DESC;",SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings DESC,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""people.Name"" and ""poker_player.Earnings"" fields. Since the question asks for sorting by earnings, include an ORDER BY clause to sort the results in descending order of ""poker_player.Earnings."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""people"" and ""poker_player"" tables based on the foreign key relationship ""poker_player.People_ID = people.People_ID"" to link poker players with their names. 4. Aggregation Structure: No aggregation is needed as the query only involves sorting and retrieving data.","[('Maksim Botin', 596462.0), ('Aleksey Ostapenko', 476090.0), ('Teodor Salparov', 189233.0), ('Semen Poltavskiy', 142800.0), ('Yevgeni Sivozhelez', 104871.0)]","[('Maksim Botin',), ('Aleksey Ostapenko',), ('Teodor Salparov',), ('Semen Poltavskiy',), ('Yevgeni Sivozhelez',)]",,1.0,
What is the average GNP and total population in all nations whose government is US territory?,"[country.GNP, country.Population, country.GovernmentForm, US territory]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,"SELECT AVG(country.GNP) AS average_gnp, SUM(country.Population) AS total_population FROM country WHERE country.GovernmentForm = 'US territory';","SELECT avg(GNP) ,  sum(population) FROM country WHERE GovernmentForm  =  ""US Territory""",world_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the average GNP and total population. 2. Condition Structure: Use a WHERE clause to filter for nations whose ""country.GovernmentForm"" is 'US territory'. 3. Join Structure: No JOIN is required since all necessary data is within the ""country"" table. 4. Aggregation Structure: Use AVG to calculate the average GNP and SUM to calculate the total population for the filtered nations.","[(None, None)]","[(510.3333333333333, 329000)]",,0.0,
What are the names of poker players in descending order of earnings?,"[poker_player.Earnings, people.Name, poker_player.People_ID = people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,"SELECT people.Name, poker_player.Earnings FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID ORDER BY poker_player.Earnings DESC;",SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Earnings DESC,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of poker players (""people.Name"") and their earnings (""poker_player.Earnings""). Use ORDER BY in descending order of ""poker_player.Earnings."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""poker_player"" and ""people"" tables based on the foreign key relationship ""poker_player.People_ID = people.People_ID"" to link poker players with their names. 4. Aggregation Structure: No aggregation is needed as the query only requires sorting the data.","[('Maksim Botin', 596462.0), ('Aleksey Ostapenko', 476090.0), ('Teodor Salparov', 189233.0), ('Semen Poltavskiy', 142800.0), ('Yevgeni Sivozhelez', 104871.0)]","[('Maksim Botin',), ('Aleksey Ostapenko',), ('Teodor Salparov',), ('Semen Poltavskiy',), ('Yevgeni Sivozhelez',)]",,1.0,
What is the number of distinct languages used around the world?,[countrylanguage.Language],"Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT COUNT(DISTINCT countrylanguage.Language) AS distinct_languages FROM countrylanguage;,SELECT count(DISTINCT LANGUAGE) FROM countrylanguage,world_1,"1. Sequential Structure: Begin with the SELECT clause to count the distinct languages, as the question asks for the number of unique languages used worldwide. 2. Condition Structure: No specific filtering condition is required since we are interested in all languages. 3. Join Structure: No JOIN is necessary because the required data is available in the ""countrylanguage"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""countrylanguage.Language"" to calculate the number of unique languages.","[(457,)]","[(457,)]",,1.0,
What are the maximum and minimum values of area codes?,[AREA_CODE_STATE.area_code],"Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",EASY,"SELECT MAX(AREA_CODE_STATE.area_code) AS max_area_code, MIN(AREA_CODE_STATE.area_code) AS min_area_code FROM AREA_CODE_STATE;","SELECT max(area_code) ,  min(area_code) FROM area_code_state",voter_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum area codes. 2. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum values of area codes. 3. Condition Structure: No specific filtering condition is required as we are calculating the aggregate values for all area codes. 4. Join Structure: No JOIN is required since all necessary data is within the ""AREA_CODE_STATE"" table.","[(989, 201)]","[(989, 201)]",,1.0,
What is the area code in which the most voters voted?,"[AREA_CODE_STATE.area_code, VOTES.state, VOTES.state = AREA_CODE_STATE.state]","Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",NON-NESTED,SELECT AREA_CODE_STATE.area_code FROM VOTES JOIN AREA_CODE_STATE ON VOTES.state = AREA_CODE_STATE.state GROUP BY AREA_CODE_STATE.area_code ORDER BY COUNT(VOTES.vote_id) DESC LIMIT 1;,SELECT T1.area_code FROM area_code_state AS T1 JOIN votes AS T2 ON T1.state  =  T2.state GROUP BY T1.area_code ORDER BY count(*) DESC LIMIT 1,voter_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""AREA_CODE_STATE.area_code"" with the highest number of votes. Use COUNT to count the number of votes for each area code. 2. Condition Structure: No specific filtering condition is required, as we are interested in all votes. 3. Join Structure: Use an INNER JOIN between the ""VOTES"" table and the ""AREA_CODE_STATE"" table on the ""state"" column to associate votes with their respective area codes. 4. Aggregation Structure: Use COUNT to count the number of votes for each area code, GROUP BY ""AREA_CODE_STATE.area_code"" to group the results by area code, and ORDER BY the count in descending order to find the area code with the most votes. Use LIMIT 1 to select the top result.","[(212,)]","[(212,)]",,1.0,
Return the money rank of the player with the greatest earnings.,"[poker_player.Money_Rank, poker_player.Earnings]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT poker_player.Money_Rank FROM poker_player ORDER BY poker_player.Earnings DESC LIMIT 1;,SELECT Money_Rank FROM poker_player ORDER BY Earnings DESC LIMIT 1,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""poker_player.Money_Rank"" of the player with the greatest earnings. 2. Condition Structure: No specific filtering condition is needed, as we are looking for the player with the maximum earnings. 3. Join Structure: No JOIN is required since all necessary information is in the ""poker_player"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""poker_player.Earnings"" to rank players by their earnings and apply LIMIT 1 to select the player with the greatest earnings.","[(58.0,)]","[(58.0,)]",,1.0,
What is the average earnings of poker players with height higher than 200?,"[poker_player.Earnings,people.Height,poker_player.People_ID = people.People_ID,200]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,SELECT AVG(poker_player.Earnings) FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID WHERE people.Height > 200;,SELECT avg(T2.Earnings) FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID WHERE T1.Height  >  200,poker_player,"1. Sequential Structure: Start with the SELECT clause to calculate the average earnings of poker players. Use the AVG function on the ""poker_player.Earnings"" field. 2. Condition Structure: Use a WHERE clause to filter for poker players whose height is greater than 200. This requires accessing the ""people.Height"" field. 3. Join Structure: Use an INNER JOIN to combine the ""poker_player"" and ""people"" tables based on the foreign key relationship ""poker_player.People_ID = people.People_ID."" 4. Aggregation Structure: Use the AVG function to compute the average earnings of the filtered poker players.","[(309445.0,)]","[(309445.0,)]",,1.0,
What are the final tables made and best finishes for all poker players?,"[poker_player.Final_Table_Made, poker_player.Best_Finish]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,"SELECT poker_player.Final_Table_Made, poker_player.Best_Finish FROM poker_player;","SELECT Final_Table_Made ,  Best_Finish FROM poker_player",poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""poker_player.Final_Table_Made"" and ""poker_player.Best_Finish"" for all poker players. 2. Condition Structure: No specific filtering condition is required as the query asks for all poker players. 3. Join Structure: No JOIN is necessary since the required information is available within the ""poker_player"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all poker players.","[(42.0, 1.0), (10.0, 2.0), (21.0, 1.0), (19.0, 2.0), (26.0, 3.0)]","[(42.0, 1.0), (10.0, 2.0), (21.0, 1.0), (19.0, 2.0), (26.0, 3.0)]",,1.0,
What are the region and population of Angola?,"[country.Region, country.Population, country.Name, country.Name = 'Angola']","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,"SELECT country.Region, country.Population FROM country WHERE country.Name = 'Angola';","SELECT Population ,  Region FROM country WHERE Name  =  ""Angola""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""region"" and ""population"" of Angola. 2. Condition Structure: Use a WHERE clause to filter for the country where ""country.Name"" is equal to 'Angola'. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields for a single country.","[('Central Africa', 12878000)]","[(12878000, 'Central Africa')]",,1.0,
What is the average life expectancy in African countries that are republics?,"[country.LifeExpectancy, country.Continent, country.GovernmentForm, country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT AVG(country.LifeExpectancy) AS avg_life_expectancy FROM country WHERE country.Continent = 'Africa' AND country.GovernmentForm LIKE '%Republic%';,"SELECT avg(LifeExpectancy) FROM country WHERE Continent  =  ""Africa"" AND GovernmentForm  =  ""Republic""",world_1,"1. Sequential Structure: Begin with the SELECT clause to calculate the average life expectancy. The field of interest is ""country.LifeExpectancy"". 2. Condition Structure: Use a WHERE clause to filter for countries that are in the ""Africa"" continent and have a government form of ""Republic"". 3. Join Structure: No JOIN is required since all necessary data is within the ""country"" table. 4. Aggregation Structure: Use the AVG function to calculate the average life expectancy for the filtered countries.","[(51.06122448979592,)]","[(50.84347826086957,)]",,0.0,
"Find the name, population and expected life length of asian country with the largest area?","[country.Name, country.Population, country.LifeExpectancy, country.SurfaceArea, country.Continent, country.Continent = 'Asia']","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC LIMIT 1;","SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  ""Asia"" ORDER BY SurfaceArea DESC LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name, population, and life expectancy of the country. Use the FROM clause to specify the country table. Apply a WHERE clause to filter for countries in the continent 'Asia'. Use the ORDER BY clause to sort by surface area in descending order and LIMIT 1 to get the country with the largest area. 2. Condition Structure: Use the WHERE clause to filter for countries where the continent is 'Asia'. 3. Join Structure: Not required, as all the necessary data is in the country table. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('China', 1277558000, 71.4)]","[('China', 1277558000, 71.4)]",,1.0,
"What are the name, population, and life expectancy of the largest Asian country by land?","[country.Name, country.Population, country.LifeExpectancy, country.Continent, country.SurfaceArea]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT Name, Population, LifeExpectancy FROM country WHERE Continent = 'Asia' ORDER BY SurfaceArea DESC LIMIT 1;","SELECT Name ,  Population ,  LifeExpectancy FROM country WHERE Continent  =  ""Asia"" ORDER BY SurfaceArea DESC LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name, population, and life expectancy of the country. Use the FROM clause to specify the country table. Apply a WHERE clause to filter for countries in the continent 'Asia'. Use ORDER BY to sort by SurfaceArea in descending order and LIMIT to select the largest country by land. 2. Condition Structure: Use the WHERE clause to filter for countries where the continent is 'Asia'. 3. Join Structure: Not required, as all the necessary data is in the country table. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('China', 1277558000, 71.4)]","[('China', 1277558000, 71.4)]",,1.0,
How many languages are spoken in Aruba?,"[country.Name, countrylanguage.Language, countrylanguage.CountryCode = country.Code, Aruba]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT COUNT(DISTINCT countrylanguage.Language) FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Name = 'Aruba';,"SELECT COUNT(T2.Language) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  ""Aruba""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the number of distinct languages spoken in Aruba. Use COUNT with DISTINCT on ""countrylanguage.Language."" 2. Condition Structure: Use a WHERE clause to filter for records where the country name is ""Aruba."" 3. Join Structure: Use a JOIN between the ""country"" and ""countrylanguage"" tables based on ""country.Code"" and ""countrylanguage.CountryCode"" to link each country with its languages. 4. Aggregation Structure: Use COUNT with DISTINCT to ensure that only unique languages are counted.","[(4,)]","[(4,)]",,1.0,
What are the population and life expectancies in Brazil?,"[country.Population, country.LifeExpectancy, country.Name, country.Name = 'Brazil']","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,"SELECT country.Population, country.LifeExpectancy FROM country WHERE country.Name = 'Brazil';","SELECT Population ,  LifeExpectancy FROM country WHERE Name  =  ""Brazil""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the population and life expectancy of the country. 2. Condition Structure: Use a WHERE clause to filter for the country where the name is 'Brazil'. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields for a single country.","[(170115000, 62.9)]","[(170115000, 62.9)]",,1.0,
Give the names of countries with English and French as official languages.,"[country.Name, countrylanguage.Language, countrylanguage.IsOfficial, countrylanguage.CountryCode = country.Code, English, French, True]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT country.Name FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.IsOfficial = 'True' AND countrylanguage.Language IN ('English', 'French') GROUP BY country.Name HAVING COUNT(DISTINCT countrylanguage.Language) = 2;","SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"" AND T2.IsOfficial  =  ""T"" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""French"" AND T2.IsOfficial  =  ""T""",world_1,1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries. Use the FROM clause to specify the country table and JOIN it with the countrylanguage table to connect countries with their languages. Apply a WHERE clause to filter for countries where both English and French are official languages. 2. Condition Structure: Use the WHERE clause to filter for rows where the language is either English or French and IsOfficial is True. Use a GROUP BY clause to group by country name and a HAVING clause to ensure that both English and French are present as official languages for each country. 3. Join Structure: Use an INNER JOIN between the country and countrylanguage tables based on the CountryCode field to link countries with their languages. 4. Aggregation Structure: Use COUNT(DISTINCT Language) in the HAVING clause to ensure that both English and French are counted as official languages for each country.,[],"[('Canada',), ('Seychelles',), ('Vanuatu',)]",,0.0,
How much surface area do the countires in the Carribean cover together?,"[country.SurfaceArea, country.Region]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT SUM(country.SurfaceArea) AS total_surface_area FROM country WHERE country.Region = 'Caribbean';,"SELECT sum(SurfaceArea) FROM country WHERE Region  =  ""Caribbean""",world_1,"1. Sequential Structure: Start with the SELECT clause to calculate the total surface area of countries in the Caribbean region. 2. Condition Structure: Use a WHERE clause to filter for countries where the ""country.Region"" is 'Caribbean'. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use the SUM function to calculate the total surface area of the filtered countries.","[(234423.0,)]","[(234423.0,)]",,1.0,
"What are the names of poker players, ordered ascending by the number of final tables they have made?","[poker_player.Final_Table_Made, poker_player.People_ID = people.People_ID, people.Name]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,"SELECT people.Name, poker_player.Final_Table_Made FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID ORDER BY poker_player.Final_Table_Made ASC;",SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID ORDER BY T2.Final_Table_Made,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of poker players (""people.Name"") and the number of final tables they have made (""poker_player.Final_Table_Made""). Use ORDER BY to sort the results in ascending order based on the number of final tables made. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to connect the ""poker_player"" table with the ""people"" table based on the foreign key relationship ""poker_player.People_ID = people.People_ID."" 4. Aggregation Structure: No aggregation is needed as the query does not involve summarizing or grouping data.","[('Teodor Salparov', 10.0), ('Maksim Botin', 19.0), ('Yevgeni Sivozhelez', 21.0), ('Semen Poltavskiy', 26.0), ('Aleksey Ostapenko', 42.0)]","[('Teodor Salparov',), ('Maksim Botin',), ('Yevgeni Sivozhelez',), ('Semen Poltavskiy',), ('Aleksey Ostapenko',)]",,1.0,
How many countries have a republic as their form of government?,"[country.Name, country.GovernmentForm]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT COUNT(*) FROM country WHERE country.GovernmentForm = 'Republic';,"SELECT count(*) FROM country WHERE GovernmentForm  =  ""Republic""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the number of countries with a specific form of government. 2. Condition Structure: Use a WHERE clause to filter for countries where the ""GovernmentForm"" is 'Republic'. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of countries that meet the specified condition.","[(122,)]","[(122,)]",,1.0,
Which continent speaks the most languages?,"[country.Continent, country.Code = countrylanguage.CountryCode, countrylanguage.Language]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,"SELECT country.Continent, COUNT(DISTINCT countrylanguage.Language) AS language_count FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode GROUP BY country.Continent ORDER BY language_count DESC LIMIT 1;",SELECT T1.Continent FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Continent ORDER BY COUNT(*) DESC LIMIT 1,world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the continent and the count of distinct languages spoken in each continent. Use COUNT with DISTINCT on ""countrylanguage.Language"" to count the unique languages. 2. Condition Structure: No specific filtering condition is required since we are analyzing all continents. 3. Join Structure: Use a JOIN between the ""country"" and ""countrylanguage"" tables based on ""country.Code"" and ""countrylanguage.CountryCode"" to associate each language with its respective continent. 4. Aggregation Structure: Use GROUP BY on ""country.Continent"" to group the results by continent. Use ORDER BY in descending order of the language count to rank continents by the number of languages spoken. Use LIMIT 1 to select the continent with the most languages.","[('Africa', 215)]","[('Africa',)]",,1.0,
find the package option of the tv channel that do not have any cartoon directed by Ben Jones.,"[TV_Channel.Package_Option,Cartoon.Directed_by,Cartoon.Channel = TV_Channel.id,Ben Jones]","Table Cartoon, columns = [*,id,Title,Directed_by,Written_by,Original_air_date,Production_code,Channel]
Table TV_Channel, columns = [*,id,series_name,Country,Language,Content,Pixel_aspect_ratio_PAR,Hight_definition_TV,Pay_per_view_PPV,Package_Option]
Table TV_series, columns = [*,id,Episode,Air_Date,Rating,Share,18_49_Rating_Share,Viewers_m,Weekly_Rank,Channel]
","Foreign_keys = [TV_series.Channel = TV_Channel.id,Cartoon.Channel = TV_Channel.id]
",NESTED,SELECT Package_Option FROM TV_Channel WHERE id NOT IN (SELECT Channel FROM Cartoon WHERE Directed_by = 'Ben Jones');,SELECT package_option FROM TV_Channel WHERE id NOT IN (SELECT channel FROM cartoon WHERE directed_by  =  'Ben Jones'),tvshow,"1. Sequential Structure: Start with the SELECT clause to retrieve the package option of the TV channels. Use the FROM clause to specify the TV_Channel table. Apply a WHERE clause to filter out channels that have cartoons directed by Ben Jones. 2. Condition Structure: Use the WHERE clause with a subquery to exclude channels whose IDs appear in the Cartoon table with the Directed_by field set to 'Ben Jones'. 3. Join Structure: Not required, as the filtering is done using a subquery and the main query only involves the TV_Channel table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',), ('no ( FTV )',), ('Sky Famiglia + Sky HD',), ('no ( FTV )',), ('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',)]","[('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',), ('no ( FTV )',), ('Sky Famiglia + Sky HD',), ('no ( FTV )',), ('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',), ('Sky Famiglia',)]",,1.0,
What is the average expected life expectancy for countries in the region of Central Africa?,"[country.LifeExpectancy, country.Region, Central Africa]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT AVG(country.LifeExpectancy) AS avg_life_expectancy FROM country WHERE country.Region = 'Central Africa';,"SELECT avg(LifeExpectancy) FROM country WHERE Region  =  ""Central Africa""",world_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the average life expectancy. 2. Condition Structure: Use a WHERE clause to filter for countries in the region of ""Central Africa."" 3. Join Structure: No JOIN is required since all necessary data is within the ""country"" table. 4. Aggregation Structure: Use the AVG function to calculate the average life expectancy for the filtered countries.","[(50.31111111111111,)]","[(50.31111111111111,)]",,1.0,
What is the name of country that has the shortest life expectancy in Asia?,"[country.Name, country.LifeExpectancy, country.Continent, country.Continent = 'Asia']","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT Name FROM country WHERE Continent = 'Asia' ORDER BY LifeExpectancy ASC LIMIT 1;,"SELECT Name FROM country WHERE Continent  =  ""Asia"" ORDER BY LifeExpectancy LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the country. Use the FROM clause to specify the country table. Apply a WHERE clause to filter for countries in the continent 'Asia'. Use ORDER BY to sort the life expectancy in ascending order and LIMIT 1 to get the country with the shortest life expectancy. 2. Condition Structure: Use the WHERE clause to filter for countries where the continent is 'Asia'. 3. Join Structure: Not required, as all the necessary data is in the country table. 4. Aggregation Structure: Not required, as we are only sorting and limiting the results without any aggregation.","[('Afghanistan',)]","[('Afghanistan',)]",,1.0,
"What are the names and birth dates of people, ordered by their names in alphabetical order?","[people.Name, people.Birth_Date]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,"SELECT people.Name, people.Birth_Date FROM people ORDER BY people.Name ASC;","SELECT Name ,  Birth_Date FROM people ORDER BY Name ASC",poker_player,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are ""people.Name"" and ""people.Birth_Date"". 2. Condition Structure: No specific filtering condition is required as the query asks for all people. 3. Join Structure: No JOIN is required since all necessary information is available in the ""people"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results alphabetically by ""people.Name"".","[('Aleksey Ostapenko', 'May 26, 1986'), ('Maksim Botin', 'July 14, 1983'), ('Roman Bragin', 'April 17, 1987'), ('Semen Poltavskiy', 'February 8, 1981'), ('Sergey Grankin', 'January 22, 1987'), ('Teodor Salparov', 'August 16, 1982'), ('Yevgeni Sivozhelez', 'August 8, 1986')]","[('Aleksey Ostapenko', 'May 26, 1986'), ('Maksim Botin', 'July 14, 1983'), ('Roman Bragin', 'April 17, 1987'), ('Semen Poltavskiy', 'February 8, 1981'), ('Sergey Grankin', 'January 22, 1987'), ('Teodor Salparov', 'August 16, 1982'), ('Yevgeni Sivozhelez', 'August 8, 1986')]",,1.0,
What are the names of all the countries that became independent after 1950?,"[country.Name, country.IndepYear, country.IndepYear > 1950]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT country.Name FROM country WHERE country.IndepYear > 1950;,SELECT Name FROM country WHERE IndepYear  >  1950,world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Name"" of countries that became independent after 1950. 2. Condition Structure: Use a WHERE clause to filter for countries where ""country.IndepYear"" is greater than 1950. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of countries that meet the specified condition.","[('Angola',), ('United Arab Emirates',), ('Armenia',), ('Antigua and Barbuda',), ('Azerbaijan',), ('Burundi',), ('Benin',), ('Burkina Faso',), ('Bangladesh',), ('Bahrain',), ('Bahamas',), ('Bosnia and Herzegovina',), ('Belarus',), ('Belize',), ('Barbados',), ('Brunei',), ('Botswana',), ('Central African Republic',), ('Côte d’Ivoire',), ('Cameroon',), ('Congo, The Democratic Republic of the',), ('Congo',), ('Comoros',), ('Cape Verde',), ('Cyprus',), ('Czech Republic',), ('Germany',), ('Djibouti',), ('Dominica',), ('Algeria',), ('Eritrea',), ('Estonia',), ('Fiji Islands',), ('Micronesia, Federated States of',), ('Gabon',), ('Georgia',), ('Ghana',), ('Guinea',), ('Gambia',), ('Guinea-Bissau',), ('Equatorial Guinea',), ('Grenada',), ('Guyana',), ('Croatia',), ('Jamaica',), ('Kazakstan',), ('Kenya',), ('Kyrgyzstan',), ('Cambodia',), ('Kiribati',), ('Saint Kitts and Nevis',), ('Kuwait',), ('Laos',), ('Libyan Arab Jamahiriya',), ('Saint Lucia',), ('Lesotho',), ('Lithuania',), ('Latvia',), ('Morocco',), ('Moldova',), ('Madagascar',), ('Maldives',), ('Marshall Islands',), ('Macedonia',), ('Mali',), ('Malta',), ('Mozambique',), ('Mauritania',), ('Mauritius',), ('Malawi',), ('Malaysia',), ('Namibia',), ('Niger',), ('Nigeria',), ('Nauru',), ('Oman',), ('Palau',), ('Papua New Guinea',), ('Qatar',), ('Russian Federation',), ('Rwanda',), ('Sudan',), ('Senegal',), ('Singapore',), ('Solomon Islands',), ('Sierra Leone',), ('Somalia',), ('Sao Tome and Principe',), ('Suriname',), ('Slovakia',), ('Slovenia',), ('Swaziland',), ('Seychelles',), ('Chad',), ('Togo',), ('Tajikistan',), ('Turkmenistan',), ('Tonga',), ('Trinidad and Tobago',), ('Tunisia',), ('Tuvalu',), ('Tanzania',), ('Uganda',), ('Ukraine',), ('Uzbekistan',), ('Saint Vincent and the Grenadines',), ('Vanuatu',), ('Samoa',), ('Zambia',), ('Zimbabwe',)]","[('Angola',), ('United Arab Emirates',), ('Armenia',), ('Antigua and Barbuda',), ('Azerbaijan',), ('Burundi',), ('Benin',), ('Burkina Faso',), ('Bangladesh',), ('Bahrain',), ('Bahamas',), ('Bosnia and Herzegovina',), ('Belarus',), ('Belize',), ('Barbados',), ('Brunei',), ('Botswana',), ('Central African Republic',), ('Côte d’Ivoire',), ('Cameroon',), ('Congo, The Democratic Republic of the',), ('Congo',), ('Comoros',), ('Cape Verde',), ('Cyprus',), ('Czech Republic',), ('Germany',), ('Djibouti',), ('Dominica',), ('Algeria',), ('Eritrea',), ('Estonia',), ('Fiji Islands',), ('Micronesia, Federated States of',), ('Gabon',), ('Georgia',), ('Ghana',), ('Guinea',), ('Gambia',), ('Guinea-Bissau',), ('Equatorial Guinea',), ('Grenada',), ('Guyana',), ('Croatia',), ('Jamaica',), ('Kazakstan',), ('Kenya',), ('Kyrgyzstan',), ('Cambodia',), ('Kiribati',), ('Saint Kitts and Nevis',), ('Kuwait',), ('Laos',), ('Libyan Arab Jamahiriya',), ('Saint Lucia',), ('Lesotho',), ('Lithuania',), ('Latvia',), ('Morocco',), ('Moldova',), ('Madagascar',), ('Maldives',), ('Marshall Islands',), ('Macedonia',), ('Mali',), ('Malta',), ('Mozambique',), ('Mauritania',), ('Mauritius',), ('Malawi',), ('Malaysia',), ('Namibia',), ('Niger',), ('Nigeria',), ('Nauru',), ('Oman',), ('Palau',), ('Papua New Guinea',), ('Qatar',), ('Russian Federation',), ('Rwanda',), ('Sudan',), ('Senegal',), ('Singapore',), ('Solomon Islands',), ('Sierra Leone',), ('Somalia',), ('Sao Tome and Principe',), ('Suriname',), ('Slovakia',), ('Slovenia',), ('Swaziland',), ('Seychelles',), ('Chad',), ('Togo',), ('Tajikistan',), ('Turkmenistan',), ('Tonga',), ('Trinidad and Tobago',), ('Tunisia',), ('Tuvalu',), ('Tanzania',), ('Uganda',), ('Ukraine',), ('Uzbekistan',), ('Saint Vincent and the Grenadines',), ('Vanuatu',), ('Samoa',), ('Zambia',), ('Zimbabwe',)]",,1.0,
"List the contestant numbers and names, ordered by contestant name descending.","[CONTESTANTS.contestant_number, CONTESTANTS.contestant_name]","Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",EASY,"SELECT CONTESTANTS.contestant_number, CONTESTANTS.contestant_name FROM CONTESTANTS ORDER BY CONTESTANTS.contestant_name DESC;","SELECT contestant_number ,  contestant_name FROM contestants ORDER BY contestant_name DESC",voter_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""contestant_number"" and ""contestant_name"" from the ""CONTESTANTS"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for all contestants. 3. Join Structure: No JOIN is required since all necessary information is available in the ""CONTESTANTS"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and ordering the data. 5. Ordering Structure: Use ORDER BY in descending order on ""contestant_name"" to sort the results as specified.","[(2, 'Tabatha Gehling'), (8, 'Nita Coster'), (11, 'Loraine NygrenTania Mattioli'), (9, 'Kurt Walser'), (3, 'Kelly Clauss'), (6, 'Jessie Eichman'), (4, 'Jessie Alloway'), (10, 'Ericka Dieter'), (1, 'Edwina Burnam'), (7, 'Allie Rogalski'), (5, 'Alana Bregman')]","[(2, 'Tabatha Gehling'), (8, 'Nita Coster'), (11, 'Loraine NygrenTania Mattioli'), (9, 'Kurt Walser'), (3, 'Kelly Clauss'), (6, 'Jessie Eichman'), (4, 'Jessie Alloway'), (10, 'Ericka Dieter'), (1, 'Edwina Burnam'), (7, 'Allie Rogalski'), (5, 'Alana Bregman')]",,1.0,
How many states are there?,[AREA_CODE_STATE.state],"Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",EASY,SELECT COUNT(DISTINCT AREA_CODE_STATE.state) FROM AREA_CODE_STATE;,SELECT count(*) FROM area_code_state,voter_1,"1. Sequential Structure: Start with the SELECT clause to count the distinct states, as the question asks for the number of states. 2. Condition Structure: No specific filtering condition is required since we want to count all states. 3. Join Structure: No JOIN is necessary because the required data is contained within the ""AREA_CODE_STATE"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""AREA_CODE_STATE.state"" to count the unique states.","[(51,)]","[(305,)]",,0.0,
How many poker players are there?,[poker_player.Poker_Player_ID],"Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT COUNT(poker_player.Poker_Player_ID) AS total_poker_players FROM poker_player;,SELECT count(*) FROM poker_player,poker_player,"1. Sequential Structure: Begin with the SELECT clause to count the number of poker players. Use COUNT on the ""poker_player.Poker_Player_ID"" field to determine the total number of poker players. 2. Condition Structure: No specific filtering condition is required since we want the total count of all poker players. 3. Join Structure: No JOIN is necessary as the required information is available within the ""poker_player"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of poker players.","[(5,)]","[(5,)]",,1.0,
How many contestants did not get voted?,"[CONTESTANTS.contestant_number, VOTES.contestant_number, VOTES.contestant_number = CONTESTANTS.contestant_number]","Table AREA_CODE_STATE, columns = [*,area_code,state]
Table CONTESTANTS, columns = [*,contestant_number,contestant_name]
Table VOTES, columns = [*,vote_id,phone_number,state,contestant_number,created]
","Foreign_keys = [VOTES.contestant_number = CONTESTANTS.contestant_number,VOTES.state = AREA_CODE_STATE.state]
",NESTED,SELECT COUNT(DISTINCT CONTESTANTS.contestant_number) AS no_votes_count FROM CONTESTANTS LEFT JOIN VOTES ON CONTESTANTS.contestant_number = VOTES.contestant_number WHERE VOTES.vote_id IS NULL;,SELECT count(*) FROM contestants WHERE contestant_number NOT IN ( SELECT contestant_number FROM votes ),voter_1,"1. Sequential Structure: Start with the SELECT clause to count the number of contestants who did not receive any votes. Use the FROM clause to specify the CONTESTANTS table. Use a LEFT JOIN with the VOTES table on the contestant_number to include all contestants and their corresponding votes. Apply a WHERE clause to filter contestants who do not have any matching entries in the VOTES table. 2. Condition Structure: Use the WHERE clause to filter for contestants where the vote_id (or any column from the VOTES table) is NULL, indicating no votes were cast for them. 3. Join Structure: Use a LEFT JOIN between the CONTESTANTS and VOTES tables based on contestant_number to include all contestants and their votes, even if no votes exist. 4. Aggregation Structure: Use COUNT to calculate the total number of contestants who did not receive any votes.","[(8,)]","[(8,)]",,1.0,
List the earnings of poker players in descending order.,[poker_player.Earnings],"Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT poker_player.Earnings FROM poker_player ORDER BY poker_player.Earnings DESC;,SELECT Earnings FROM poker_player ORDER BY Earnings DESC,poker_player,"1. Sequential Structure: Start with the SELECT clause to specify the field ""poker_player.Earnings"" as the query is focused on listing earnings. 2. Condition Structure: No specific filtering condition is required since the query asks for all poker players' earnings. 3. Join Structure: No JOIN is necessary because the required data is available within the ""poker_player"" table. 4. Aggregation Structure: No aggregation is needed as the query simply lists the earnings. Use ORDER BY in descending order to sort the earnings.","[(596462.0,), (476090.0,), (189233.0,), (142800.0,), (104871.0,)]","[(596462.0,), (476090.0,), (189233.0,), (142800.0,), (104871.0,)]",,1.0,
What is the total number of people living in the nations that do not use English?,"[country.Population, country.Code = countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.IsOfficial, English]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT SUM(country.Population) AS total_population FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.Language = 'English' AND countrylanguage.IsOfficial != 'Yes';,"SELECT sum(Population) FROM country WHERE Name NOT IN (SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"")",world_1,1. Sequential Structure: Start with the SELECT clause to calculate the total population of nations. Use the FROM clause to specify the country table and JOIN it with the countrylanguage table to link countries with their languages. Apply a WHERE clause to filter for nations that do not use English as an official language. 2. Condition Structure: Use the WHERE clause to filter for records where the language is 'English' and IsOfficial is not 'Yes'. 3. Join Structure: Use an INNER JOIN between the country and countrylanguage tables based on the CountryCode and Code fields to connect countries with their languages. 4. Aggregation Structure: Use the SUM function to calculate the total population of the filtered nations.,"[(627418300,)]","[(5451331150,)]",,0.0,
How many official languages are spoken in Afghanistan?,"[country.Name, countrylanguage.IsOfficial, countrylanguage.Language, countrylanguage.CountryCode = country.Code, Afghanistan]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT COUNT(countrylanguage.Language) FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Name = 'Afghanistan' AND countrylanguage.IsOfficial = 'T';,"SELECT COUNT(*) FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.Name  =  ""Afghanistan"" AND IsOfficial  =  ""T""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the number of official languages spoken in Afghanistan. Use COUNT on ""countrylanguage.Language"" to get the total number of official languages. 2. Condition Structure: Use a WHERE clause to filter for records where ""country.Name"" is 'Afghanistan' and ""countrylanguage.IsOfficial"" is 'T' (indicating the language is official). 3. Join Structure: Use a JOIN between the ""country"" and ""countrylanguage"" tables based on ""country.Code"" and ""countrylanguage.CountryCode"" to link countries with their languages. 4. Aggregation Structure: Use COUNT to aggregate the number of official languages for Afghanistan.","[(2,)]","[(2,)]",,1.0,
What is the average earnings of poker players?,[poker_player.Earnings],"Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",EASY,SELECT AVG(poker_player.Earnings) AS average_earnings FROM poker_player;,SELECT avg(Earnings) FROM poker_player,poker_player,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average earnings. 2. Aggregation Structure: Use the AVG function to calculate the average of the ""poker_player.Earnings"" column. 3. Condition Structure: No specific filtering condition is required as we want the average earnings of all poker players. 4. Join Structure: No JOIN is necessary since the required data is available within the ""poker_player"" table.","[(301891.2,)]","[(301891.2,)]",,1.0,
What is the official language used in the country the name of whose head of state is Beatrix.,"[country.HeadOfState, country.Code, countrylanguage.CountryCode = country.Code, countrylanguage.Language, countrylanguage.IsOfficial, Beatrix]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT countrylanguage.Language FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.HeadOfState = 'Beatrix' AND countrylanguage.IsOfficial = 'T';,"SELECT T2.Language FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T1.HeadOfState  =  ""Beatrix"" AND T2.IsOfficial  =  ""T""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countrylanguage.Language"" field, as the question asks for the official language. 2. Condition Structure: Use a WHERE clause to filter for the country where the ""country.HeadOfState"" is ""Beatrix"" and the language is official (""countrylanguage.IsOfficial"" = 'T'). 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables on the ""country.Code"" and ""countrylanguage.CountryCode"" fields to link the country with its languages. 4. Aggregation Structure: No aggregation is needed since we are retrieving a specific language.","[('Dutch',), ('Dutch',), ('Papiamento',), ('Dutch',)]","[('Dutch',), ('Dutch',), ('Papiamento',), ('Dutch',)]",,1.0,
What are the names of poker players?,"[people.Name, poker_player.People_ID = people.People_ID]","Table people, columns = [*,People_ID,Nationality,Name,Birth_Date,Height]
Table poker_player, columns = [*,Poker_Player_ID,People_ID,Final_Table_Made,Best_Finish,Money_Rank,Earnings]
","Foreign_keys = [poker_player.People_ID = people.People_ID]
",NON-NESTED,SELECT people.Name FROM poker_player JOIN people ON poker_player.People_ID = people.People_ID;,SELECT T1.Name FROM people AS T1 JOIN poker_player AS T2 ON T1.People_ID  =  T2.People_ID,poker_player,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""people.Name"" field, as the question asks for the names of poker players. 2. Condition Structure: No specific filtering condition is required since the question asks for all poker players' names. 3. Join Structure: Use an INNER JOIN between the ""poker_player"" table and the ""people"" table on the foreign key ""poker_player.People_ID = people.People_ID"" to link poker players with their corresponding names. 4. Aggregation Structure: No aggregation is needed since the query only retrieves names without any summarization.","[('Aleksey Ostapenko',), ('Teodor Salparov',), ('Yevgeni Sivozhelez',), ('Maksim Botin',), ('Semen Poltavskiy',)]","[('Aleksey Ostapenko',), ('Teodor Salparov',), ('Yevgeni Sivozhelez',), ('Maksim Botin',), ('Semen Poltavskiy',)]",,1.0,
What are the names of nations speak both English and French?,"[country.Name, countrylanguage.Language, countrylanguage.CountryCode = country.Code, English, French]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT country.Name FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Code IN ( SELECT CountryCode FROM countrylanguage WHERE Language = 'English' ) AND country.Code IN ( SELECT CountryCode FROM countrylanguage WHERE Language = 'French' );,"SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""English"" INTERSECT SELECT T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode WHERE T2.Language  =  ""French""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of nations. Use the FROM clause to specify the country table and JOIN it with the countrylanguage table to link countries with their languages. Apply a WHERE clause to filter for countries that speak both English and French. 2. Condition Structure: Use the WHERE clause with a subquery to ensure that the country has entries for both English and French in the countrylanguage table. 3. Join Structure: Use an INNER JOIN between the country and countrylanguage tables based on the CountryCode and Code fields to connect countries with their languages. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Canada',), ('Monaco',), ('Monaco',), ('Monaco',), ('Monaco',), ('Seychelles',), ('Seychelles',), ('Seychelles',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('United States',), ('Virgin Islands, U.S.',), ('Virgin Islands, U.S.',), ('Virgin Islands, U.S.',), ('Vanuatu',), ('Vanuatu',), ('Vanuatu',)]","[('Canada',), ('Monaco',), ('Seychelles',), ('United States',), ('Vanuatu',), ('Virgin Islands, U.S.',)]",,1.0,
Which unique cities are in Asian countries where Chinese is the official language ?,"[city.Name, country.Continent, countrylanguage.Language, countrylanguage.IsOfficial, city.CountryCode = country.Code, countrylanguage.CountryCode = country.Code, Asian, Chinese, TRUE]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT DISTINCT city.Name FROM city JOIN country ON city.CountryCode = country.Code JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Continent = 'Asian' AND countrylanguage.Language = 'Chinese' AND countrylanguage.IsOfficial = 'TRUE';,"select distinct t3.name from country as t1 join countrylanguage as t2 on t1.code  =  t2.countrycode join city as t3 on t1.code  =  t3.countrycode where t2.isofficial  =  't' and t2.language  =  'chinese' and t1.continent  =  ""asia""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the unique city names (""city.Name""). Use DISTINCT to ensure uniqueness. 2. Condition Structure: Use a WHERE clause to filter for countries in the ""Asian"" continent and where the language is ""Chinese"" and is marked as official (""IsOfficial = 'TRUE'""). 3. Join Structure: Use JOINs to connect the ""city"" table with the ""country"" table on ""city.CountryCode = country.Code"" and the ""countrylanguage"" table on ""countrylanguage.CountryCode = country.Code"" to link cities with their respective countries and languages. 4. Aggregation Structure: No aggregation is needed, as the query only requires unique city names.",[],[],,1.0,
"Return the names of conductors that do not have the nationality ""USA"".","[conductor.Name, conductor.Nationality]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT conductor.Name FROM conductor WHERE conductor.Nationality != 'USA';,SELECT Name FROM conductor WHERE Nationality != 'USA',orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""conductor.Name"" of conductors. 2. Condition Structure: Use a WHERE clause to filter out conductors whose ""conductor.Nationality"" is ""USA"". 3. Join Structure: No JOIN is required since all necessary information is in the ""conductor"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.","[('Igor Stravinsky',), ('Paul Jorgensen',), ('Charles Dutoit',), ('Pierre Boulez',), ('Robert Craft',), ('Michael Tilson Thomas',)]","[('Igor Stravinsky',), ('Paul Jorgensen',), ('Charles Dutoit',), ('Pierre Boulez',), ('Robert Craft',), ('Michael Tilson Thomas',)]",,1.0,
What are the orchestras that do not have any performances?,"[orchestra.Orchestra_ID,performance.Orchestra_ID,orchestra.Orchestra_ID = performance.Orchestra_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NESTED,SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance);,SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance),orchestra,"1. Sequential Structure: Begin with the SELECT clause to retrieve the names of orchestras. Use the FROM clause to specify the orchestra table. Apply a WHERE clause to filter orchestras that do not have any performances by ensuring that their Orchestra_ID is not present in the performance table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude orchestras whose Orchestra_ID appears in the performance table, meaning they have performances. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Orchestra_ID entries in the performance table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('San Francisco Symphony Orchestra',)]","[('San Francisco Symphony Orchestra',)]",,1.0,
What are the codes of the countries that do not speak English and whose government forms are not Republic?,"[country.Code, country.GovernmentForm, countrylanguage.Language, countrylanguage.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT DISTINCT country.Code FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.Language != 'English' AND country.GovernmentForm != 'Republic';,"SELECT Code FROM country WHERE GovernmentForm != ""Republic"" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  ""English""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the codes of countries. Use the FROM clause to specify the country table and JOIN it with the countrylanguage table to link countries with their languages. Apply a WHERE clause to filter for countries that do not speak English and whose government forms are not Republic. 2. Condition Structure: Use the WHERE clause to filter for countries where the language is not 'English' and the government form is not 'Republic'. 3. Join Structure: Use an INNER JOIN between the country and countrylanguage tables based on the CountryCode and Code fields to connect countries with their languages. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('ABW',), ('AFG',), ('AND',), ('ANT',), ('ARE',), ('ARG',), ('ASM',), ('ATG',), ('AUS',), ('AUT',), ('AZE',), ('BEL',), ('BHR',), ('BHS',), ('BIH',), ('BLZ',), ('BRA',), ('BRB',), ('BRN',), ('BTN',), ('CAN',), ('CCK',), ('CHE',), ('CHN',), ('COK',), ('CUB',), ('CXR',), ('DEU',), ('DNK',), ('ESH',), ('ESP',), ('FRO',), ('FSM',), ('GBR',), ('GIB',), ('GLP',), ('GRD',), ('GRL',), ('GUF',), ('GUM',), ('HKG',), ('IND',), ('IRN',), ('JAM',), ('JOR',), ('JPN',), ('KHM',), ('KNA',), ('KWT',), ('LBY',), ('LCA',), ('LIE',), ('LSO',), ('LUX',), ('MAC',), ('MAR',), ('MCO',), ('MDG',), ('MEX',), ('MNP',), ('MTQ',), ('MYS',), ('MYT',), ('NCL',), ('NGA',), ('NIU',), ('NLD',), ('NOR',), ('NPL',), ('NZL',), ('OMN',), ('PCN',), ('PNG',), ('PRI',), ('PRK',), ('PSE',), ('PYF',), ('QAT',), ('REU',), ('RUS',), ('SAU',), ('SDN',), ('SJM',), ('SLB',), ('SPM',), ('SWE',), ('SWZ',), ('THA',), ('TKL',), ('TMP',), ('TON',), ('TUV',), ('USA',), ('VAT',), ('VCT',), ('VEN',), ('VIR',), ('VNM',), ('WLF',), ('WSM',), ('YUG',)]","[('AFG',), ('AND',), ('ARE',), ('ARG',), ('ATA',), ('ATF',), ('AUT',), ('AZE',), ('BEL',), ('BHS',), ('BIH',), ('BRA',), ('BTN',), ('BVT',), ('CHE',), ('CHN',), ('CUB',), ('DEU',), ('ESH',), ('ESP',), ('FRO',), ('FSM',), ('GLP',), ('GRD',), ('GRL',), ('GUF',), ('HMD',), ('IND',), ('IOT',), ('IRN',), ('JAM',), ('JOR',), ('KHM',), ('LBY',), ('LIE',), ('LUX',), ('MAR',), ('MDG',), ('MEX',), ('MTQ',), ('MYT',), ('NCL',), ('NGA',), ('NLD',), ('NPL',), ('OMN',), ('PCN',), ('PNG',), ('PRK',), ('PSE',), ('PYF',), ('QAT',), ('REU',), ('RUS',), ('SAU',), ('SDN',), ('SGS',), ('SJM',), ('SLB',), ('SPM',), ('SWE',), ('SWZ',), ('THA',), ('TMP',), ('VAT',), ('VEN',), ('VNM',), ('WLF',), ('YUG',)]",,1.0,
Show the names of all of the high schooler Kyle's friends.,"[Highschooler.name, Highschooler.ID, Friend.student_id = Highschooler.ID, Friend.friend_id = Highschooler.ID, Kyle]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT Highschooler.name FROM Friend JOIN Highschooler ON Friend.friend_id = Highschooler.ID WHERE Friend.student_id = (SELECT ID FROM Highschooler WHERE name = 'Kyle');,"SELECT T3.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id JOIN Highschooler AS T3 ON T1.friend_id  =  T3.id WHERE T2.name  =  ""Kyle""",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of Kyle's friends. The ""Highschooler.name"" field will be used to get the names. 2. Condition Structure: Use a WHERE clause to filter for the student whose name is ""Kyle"" and retrieve their friends. 3. Join Structure: Use an INNER JOIN between the ""Friend"" table and the ""Highschooler"" table twice. The first join links ""Friend.student_id"" to ""Highschooler.ID"" to identify Kyle, and the second join links ""Friend.friend_id"" to ""Highschooler.ID"" to get the names of Kyle's friends. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of Kyle's friends.","[('Jordan',)]","[('Jordan',)]",,1.0,
What are the names of conductors as well as the corresonding orchestras that they have conducted?,"[conductor.Name, orchestra.Orchestra, orchestra.Conductor_ID = conductor.Conductor_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NON-NESTED,"SELECT conductor.Name, orchestra.Orchestra FROM conductor JOIN orchestra ON orchestra.Conductor_ID = conductor.Conductor_ID;","SELECT T1.Name ,  T2.Orchestra FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID",orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""conductor.Name"" and ""orchestra.Orchestra."" 2. Condition Structure: No specific filtering condition is required, as the question asks for all conductors and their corresponding orchestras. 3. Join Structure: Use an INNER JOIN between the ""conductor"" and ""orchestra"" tables based on the foreign key relationship ""orchestra.Conductor_ID = conductor.Conductor_ID"" to link each conductor with their orchestra. 4. Aggregation Structure: No aggregation is needed since the query only involves retrieving data without any summarization.","[('Antal Doráti', 'London Symphony Orchestra'), ('Igor Stravinsky', 'Columbia Symphony Orchestra'), ('Colin Davis', 'Royal Concertgebouw Orchestra'), ('Paul Jorgensen', 'Royal Danish Orchestra'), ('Antal Brown', 'Detroit Symphony Orchestra'), ('Charles Dutoit', 'Montreal Symphony Orchestra'), ('Gerard Schwarz', 'Seattle Symphony Orchestra'), ('Pierre Boulez', 'Chicago Symphony Orchestra'), ('Valeri Gergiev', 'Kirov Orchestra'), ('Robert Craft', 'Philharmonia Orchestra'), ('Seiji Ozawa', 'Orchestre de Paris'), ('Michael Tilson Thomas', 'San Francisco Symphony Orchestra')]","[('Antal Doráti', 'London Symphony Orchestra'), ('Igor Stravinsky', 'Columbia Symphony Orchestra'), ('Colin Davis', 'Royal Concertgebouw Orchestra'), ('Paul Jorgensen', 'Royal Danish Orchestra'), ('Antal Brown', 'Detroit Symphony Orchestra'), ('Charles Dutoit', 'Montreal Symphony Orchestra'), ('Gerard Schwarz', 'Seattle Symphony Orchestra'), ('Pierre Boulez', 'Chicago Symphony Orchestra'), ('Valeri Gergiev', 'Kirov Orchestra'), ('Robert Craft', 'Philharmonia Orchestra'), ('Seiji Ozawa', 'Orchestre de Paris'), ('Michael Tilson Thomas', 'San Francisco Symphony Orchestra')]",,1.0,
How many high schoolers are there?,[Highschooler.ID],"Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,SELECT COUNT(Highschooler.ID) AS total_highschoolers FROM Highschooler;,SELECT count(*) FROM Highschooler,network_1,"1. Sequential Structure: Start with the SELECT clause to count the number of high schoolers. 2. Condition Structure: No specific filtering condition is required since we want the total count of high schoolers. 3. Join Structure: No JOIN is necessary as the required information is available in the ""Highschooler"" table. 4. Aggregation Structure: Use COUNT on ""Highschooler.ID"" to calculate the total number of high schoolers.","[(16,)]","[(16,)]",,1.0,
What is Kyle's id?,"[Highschooler.ID, Highschooler.name]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,SELECT Highschooler.ID FROM Highschooler WHERE Highschooler.name = 'Kyle';,"SELECT ID FROM Highschooler WHERE name  =  ""Kyle""",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Highschooler.ID"" of the student named Kyle. 2. Condition Structure: Use a WHERE clause to filter for the student whose name is 'Kyle'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Highschooler"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[(1934,)]","[(1934,)]",,1.0,
Return the names of friends of the high school student Kyle.,"[Highschooler.name, Highschooler.ID, Friend.student_id = Highschooler.ID, Friend.friend_id = Highschooler.ID, Kyle]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT H2.name FROM Friend JOIN Highschooler AS H1 ON Friend.student_id = H1.ID JOIN Highschooler AS H2 ON Friend.friend_id = H2.ID WHERE H1.name = 'Kyle';,"SELECT T3.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id JOIN Highschooler AS T3 ON T1.friend_id  =  T3.id WHERE T2.name  =  ""Kyle""",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of friends. The ""Highschooler.name"" field will be used to get the names of the friends. 2. Condition Structure: Use a WHERE clause to filter for the student whose name is ""Kyle"" and find their friends. 3. Join Structure: Use an INNER JOIN between the ""Friend"" table and the ""Highschooler"" table twice. The first join links ""Friend.student_id"" to ""Highschooler.ID"" to identify Kyle, and the second join links ""Friend.friend_id"" to ""Highschooler.ID"" to get the names of Kyle's friends. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names of friends.","[('Jordan',)]","[('Jordan',)]",,1.0,
Show name of all students who have some friends and also are liked by someone else.,"[Highschooler.name, Friend.student_id, Friend.friend_id = Highschooler.ID, Likes.liked_id = Highschooler.ID, Likes.student_id]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT DISTINCT Highschooler.name FROM Highschooler JOIN Friend ON Highschooler.ID = Friend.student_id JOIN Likes ON Highschooler.ID = Likes.liked_id;,SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id INTERSECT SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.liked_id  =  T2.id,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Highschooler.name"" of students who meet the specified conditions. 2. Condition Structure: Use WHERE clauses to filter students who have friends (exist in the ""Friend"" table as ""student_id"") and are liked by someone else (exist in the ""Likes"" table as ""liked_id""). 3. Join Structure: Use JOINs to connect the ""Highschooler"" table with the ""Friend"" table on ""Highschooler.ID = Friend.student_id"" and with the ""Likes"" table on ""Highschooler.ID = Likes.liked_id"" to ensure the conditions are met. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique student names are returned.","[('Cassandra',), ('Gabriel',), ('Alexis',), ('Kris',), ('Jordan',), ('Kyle',), ('Jessica',), ('Haley',)]","[('Alexis',), ('Cassandra',), ('Gabriel',), ('Haley',), ('Jessica',), ('Jordan',), ('Kris',), ('Kyle',)]",,1.0,
What are the different government forms and what is the total population of each for government forms that have an average life expectancy greater than 72?,"[country.GovernmentForm, country.Population, country.LifeExpectancy]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT GovernmentForm, SUM(Population) AS TotalPopulation FROM country GROUP BY GovernmentForm HAVING AVG(LifeExpectancy) > 72;","SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the government forms and the total population for each government form. Use the FROM clause to specify the country table. Apply a GROUP BY clause to group records by government form. Use the HAVING clause to filter government forms where the average life expectancy is greater than 72. 2. Condition Structure: Use the HAVING clause to filter for government forms with an average life expectancy greater than 72. 3. Join Structure: Not required, as all the necessary data is available in the country table. 4. Aggregation Structure: Use SUM to calculate the total population for each government form and AVG to calculate the average life expectancy for filtering.","[('Commonwealth of the US', 3947000), ('Constitutional Monarchy (Emirate)', 1972000), ('Constitutional Monarchy, Federation', 82516000), ('Dependent Territory of the UK', 193050), ('Emirate Federation', 2441000), ('Federation', 7160400), ('Monarchy (Emirate)', 617000), ('Monarchy (Sultanate)', 2870000), ('Nonmetropolitan Territory of France', 464000), ('Nonmetropolitan Territory of The Netherlands', 320000), ('Overseas Department of France', 1731000), ('Parliamentary Coprincipality', 78000), ('Part of Denmark', 99000), ('Socialistic Republic', 115072000), ('Socialistic State', 5605000), ('Special Administrative Region of China', 7255000), ('US Territory', 329000)]","[(3947000, 'Commonwealth of the US'), (1972000, 'Constitutional Monarchy (Emirate)'), (82516000, 'Constitutional Monarchy, Federation'), (193050, 'Dependent Territory of the UK'), (2441000, 'Emirate Federation'), (7160400, 'Federation'), (617000, 'Monarchy (Emirate)'), (2870000, 'Monarchy (Sultanate)'), (464000, 'Nonmetropolitan Territory of France'), (320000, 'Nonmetropolitan Territory of The Netherlands'), (1731000, 'Overseas Department of France'), (78000, 'Parliamentary Coprincipality'), (99000, 'Part of Denmark'), (115072000, 'Socialistic Republic'), (5605000, 'Socialistic State'), (7255000, 'Special Administrative Region of China'), (329000, 'US Territory')]",,1.0,
What are the codes of countries where Spanish is spoken by the largest percentage of people?,"[countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.Percentage, country.Code, countrylanguage.CountryCode = country.Code, Spanish]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT countrylanguage.CountryCode FROM countrylanguage WHERE countrylanguage.Language = 'Spanish' ORDER BY countrylanguage.Percentage DESC LIMIT 1;,"SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  ""Spanish"" GROUP BY CountryCode",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countrylanguage.CountryCode"" for countries where Spanish is spoken by the largest percentage of people. Use ORDER BY in descending order on ""countrylanguage.Percentage"" to rank countries by the percentage of Spanish speakers. Use LIMIT 1 to select the country with the highest percentage. 2. Condition Structure: Use a WHERE clause to filter for records where ""countrylanguage.Language"" is 'Spanish.' 3. Join Structure: No JOIN is necessary, as all the required data is in the ""countrylanguage"" table. 4. Aggregation Structure: No aggregation is needed, but ORDER BY and LIMIT are used to identify the country with the largest percentage of Spanish speakers.","[('CUB',)]","[('ABW', 7.4), ('AND', 44.6), ('ARG', 96.8), ('BLZ', 31.6), ('BOL', 87.7), ('CAN', 0.7), ('CHL', 89.7), ('COL', 99.0), ('CRI', 97.5), ('CUB', 100.0), ('DOM', 98.0), ('ECU', 93.0), ('ESP', 74.4), ('FRA', 0.4), ('GTM', 64.7), ('HND', 97.2), ('MEX', 92.1), ('NIC', 97.6), ('PAN', 76.8), ('PER', 79.8), ('PRI', 51.3), ('PRY', 55.1), ('SLV', 100.0), ('SWE', 0.6), ('URY', 95.7), ('USA', 7.5), ('VEN', 96.9), ('VIR', 13.3)]",,0.0,
Return the names of the 3 most populated countries.,"[country.Name, country.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT country.Name FROM country ORDER BY country.Population DESC LIMIT 3;,SELECT Name FROM country ORDER BY Population DESC LIMIT 3,world_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the name of the country. Since the question asks for the 3 most populated countries, we also need to include the population for ordering purposes. 2. Condition Structure: No specific filtering condition is required as we are considering all countries. 3. Join Structure: No JOIN is required since all necessary data is within the ""country"" table. 4. Aggregation Structure: Use ORDER BY in descending order on the ""country.Population"" to rank countries by their population. Use LIMIT 3 to retrieve only the top 3 most populated countries.","[('China',), ('India',), ('United States',)]","[('China',), ('India',), ('United States',)]",,1.0,
What are the ids of high school students who do not have friends?,"[Highschooler.ID, Friend.student_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NESTED,SELECT ID FROM Highschooler WHERE ID NOT IN (SELECT student_id FROM Friend);,SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of high school students. Use the FROM clause to specify the Highschooler table. Apply a WHERE clause to filter students who do not have any friends by ensuring their ID is not present in the Friend table as a student_id. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose ID appears in the Friend table as a student_id, indicating they have friends. 3. Join Structure: Not required, as we only need to filter based on the absence of matching student_id entries in the Friend table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[(1025,), (1641,)]","[(1025,), (1641,)]",,1.0,
What are names of countries with the top 3 largest population?,"[country.Name, country.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT country.Name FROM country ORDER BY country.Population DESC LIMIT 3;,SELECT Name FROM country ORDER BY Population DESC LIMIT 3,world_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the country name. 2. Aggregation Structure: Use ORDER BY in descending order on the ""country.Population"" to rank countries by their population. 3. Limiting Structure: Use LIMIT 3 to retrieve only the names of the top 3 countries with the largest population. 4. Join Structure: No JOIN is required since all necessary data is within the ""country"" table.","[('China',), ('India',), ('United States',)]","[('China',), ('India',), ('United States',)]",,1.0,
What are the names and areas of countries with the top 5 largest area?,"[country.Name, country.SurfaceArea]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,"SELECT country.Name, country.SurfaceArea FROM country ORDER BY country.SurfaceArea DESC LIMIT 5;","SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5",world_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required fields, which are the country name and its surface area. 2. Condition Structure: No specific filtering condition is required since we are retrieving the top 5 countries by surface area. 3. Aggregation Structure: No aggregation function is needed as we are directly retrieving and sorting the surface area values. 4. Ordering Structure: Use ORDER BY in descending order on ""country.SurfaceArea"" to rank countries by their area. 5. Limiting Structure: Use LIMIT 5 to retrieve only the top 5 countries with the largest surface area. 6. Join Structure: No JOIN is required since all necessary data is within the ""country"" table.","[('Russian Federation', 17075400.0), ('Antarctica', 13120000.0), ('Canada', 9970610.0), ('China', 9572900.0), ('United States', 9363520.0)]","[('Russian Federation', 17075400.0), ('Antarctica', 13120000.0), ('Canada', 9970610.0), ('China', 9572900.0), ('United States', 9363520.0)]",,1.0,
Show names of all high school students who do not have any friends.,"[Highschooler.name,Highschooler.ID,Friend.student_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NESTED,SELECT Highschooler.name FROM Highschooler WHERE Highschooler.ID NOT IN (SELECT Friend.student_id FROM Friend);,SELECT name FROM Highschooler EXCEPT SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of high school students. Use the FROM clause to specify the Highschooler table. Apply a WHERE clause to filter students who do not have any friends by ensuring their ID is not present in the Friend table as a student_id. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose ID appears in the Friend table as a student_id, indicating they have friends. 3. Join Structure: Not required, as we only need to filter based on the absence of matching student_id entries in the Friend table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Brittany',), ('John',)]","[('Brittany',), ('John',)]",,1.0,
Show the names of conductors that have conducted more than one orchestras.,"[conductor.Name,orchestra.Conductor_ID,orchestra.Orchestra_ID,orchestra.Conductor_ID = conductor.Conductor_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NON-NESTED,SELECT conductor.Name FROM conductor JOIN orchestra ON orchestra.Conductor_ID = conductor.Conductor_ID GROUP BY conductor.Conductor_ID HAVING COUNT(orchestra.Orchestra_ID) > 1;,SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*)  >  1,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""conductor.Name."" Use GROUP BY to group records by ""conductor.Conductor_ID"" since we are interested in conductors who have conducted multiple orchestras. Use HAVING to filter groups where the count of ""orchestra.Orchestra_ID"" is greater than one. 2. Condition Structure: Use a HAVING clause to filter for conductors who have conducted more than one orchestra. 3. Join Structure: Use an INNER JOIN between the ""conductor"" and ""orchestra"" tables on ""orchestra.Conductor_ID = conductor.Conductor_ID"" to associate each conductor with their orchestras. 4. Aggregation Structure: Use COUNT on ""orchestra.Orchestra_ID"" to count the number of orchestras conducted by each conductor.",[],[],,1.0,
What are the names of the countries that are in the continent of Europe and have a population of 80000?,"[country.Name, country.Continent, country.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT country.Name FROM country WHERE country.Continent = 'Europe' AND country.Population = 80000;,"SELECT Name FROM country WHERE continent  =  ""Europe"" AND Population  =  ""80000""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Name"" of countries that meet the specified conditions. 2. Condition Structure: Use a WHERE clause to filter for countries that are in the continent of ""Europe"" and have a population of 80000. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving country names based on specific conditions.",[],[],,1.0,
What are the names of high schoolers who both have friends and are liked?,"[Highschooler.name,Friend.student_id,Friend.friend_id = Highschooler.ID,Likes.student_id,Likes.liked_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NESTED,SELECT DISTINCT Highschooler.name FROM Highschooler JOIN Friend ON Highschooler.ID = Friend.student_id JOIN Likes ON Highschooler.ID = Likes.liked_id;,SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id INTERSECT SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.liked_id  =  T2.id,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of high schoolers. Use the FROM clause to specify the Highschooler table. Use JOINs to connect the Highschooler table with the Friend and Likes tables to identify students who both have friends and are liked. 2. Condition Structure: Use WHERE conditions to ensure that the student has at least one friend and is liked by at least one other student. 3. Join Structure: Use INNER JOINs between the Highschooler table and the Friend table (on student_id and friend_id) and the Likes table (on liked_id) to connect the relationships. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('Cassandra',), ('Gabriel',), ('Alexis',), ('Kris',), ('Jordan',), ('Kyle',), ('Jessica',), ('Haley',)]","[('Alexis',), ('Cassandra',), ('Gabriel',), ('Haley',), ('Jessica',), ('Jordan',), ('Kris',), ('Kyle',)]",,1.0,
Return the names and surface areas of the 5 largest countries.,"[country.Name, country.SurfaceArea]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,"SELECT country.Name, country.SurfaceArea FROM country ORDER BY country.SurfaceArea DESC LIMIT 5;","SELECT Name ,  SurfaceArea FROM country ORDER BY SurfaceArea DESC LIMIT 5",world_1,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the country name and surface area. 2. Aggregation Structure: No aggregation is required since we are directly retrieving the surface areas of countries. 3. Ordering Structure: Use ORDER BY in descending order on ""country.SurfaceArea"" to rank countries by their surface area. 4. Limiting Structure: Use LIMIT 5 to retrieve only the top 5 largest countries by surface area. 5. Join Structure: No JOIN is required since all necessary data is within the ""country"" table.","[('Russian Federation', 17075400.0), ('Antarctica', 13120000.0), ('Canada', 9970610.0), ('China', 9572900.0), ('United States', 9363520.0)]","[('Russian Federation', 17075400.0), ('Antarctica', 13120000.0), ('Canada', 9970610.0), ('China', 9572900.0), ('United States', 9363520.0)]",,1.0,
What are the African countries that have a  population less than any country in Asia?,"[country.Name, country.Continent, country.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT Name FROM country WHERE Continent = 'Africa' AND Population < ANY (SELECT Population FROM country WHERE Continent = 'Asia');,"SELECT Name FROM country WHERE Continent  =  ""Africa""  AND population  <  (SELECT max(population) FROM country WHERE Continent  =  ""Asia"")",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of African countries. Use the FROM clause to specify the country table. Apply a WHERE clause to filter for countries in Africa with a population less than the population of any country in Asia. 2. Condition Structure: Use the WHERE clause to filter for countries where the continent is 'Africa' and the population is less than the population of any country in Asia. Use a subquery to retrieve the populations of countries in Asia. 3. Join Structure: Not required, as all data is available within the country table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.",[],"[('Angola',), ('Burundi',), ('Benin',), ('Burkina Faso',), ('Botswana',), ('Central African Republic',), ('Côte d’Ivoire',), ('Cameroon',), ('Congo, The Democratic Republic of the',), ('Congo',), ('Comoros',), ('Cape Verde',), ('Djibouti',), ('Algeria',), ('Egypt',), ('Eritrea',), ('Western Sahara',), ('Ethiopia',), ('Gabon',), ('Ghana',), ('Guinea',), ('Gambia',), ('Guinea-Bissau',), ('Equatorial Guinea',), ('British Indian Ocean Territory',), ('Kenya',), ('Liberia',), ('Libyan Arab Jamahiriya',), ('Lesotho',), ('Morocco',), ('Madagascar',), ('Mali',), ('Mozambique',), ('Mauritania',), ('Mauritius',), ('Malawi',), ('Mayotte',), ('Namibia',), ('Niger',), ('Nigeria',), ('Réunion',), ('Rwanda',), ('Sudan',), ('Senegal',), ('Saint Helena',), ('Sierra Leone',), ('Somalia',), ('Sao Tome and Principe',), ('Swaziland',), ('Seychelles',), ('Chad',), ('Togo',), ('Tunisia',), ('Tanzania',), ('Uganda',), ('South Africa',), ('Zambia',), ('Zimbabwe',)]","near ""SELECT"": syntax error",0.0,
Which language is spoken by the largest number of countries?,"[countrylanguage.Language, countrylanguage.CountryCode, country.Code, countrylanguage.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,"SELECT countrylanguage.Language, COUNT(DISTINCT countrylanguage.CountryCode) AS country_count FROM countrylanguage GROUP BY countrylanguage.Language ORDER BY country_count DESC LIMIT 1;",SELECT LANGUAGE FROM countrylanguage GROUP BY LANGUAGE ORDER BY count(*) DESC LIMIT 1,world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countrylanguage.Language"" and the count of distinct countries where the language is spoken. Use COUNT with DISTINCT on ""countrylanguage.CountryCode"" to count the number of countries for each language. 2. Condition Structure: No specific filtering condition is required, as we are interested in all languages. 3. Join Structure: No JOIN is necessary because the required data is available in the ""countrylanguage"" table. 4. Aggregation Structure: Use GROUP BY on ""countrylanguage.Language"" to group the results by each language. Use ORDER BY in descending order on the count of countries to rank the languages by the number of countries where they are spoken. Use LIMIT 1 to select the language spoken by the largest number of countries.","[('English', 60)]","[('English',)]",,1.0,
What grade is Kyle in?,"[Highschooler.name, Highschooler.grade]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,SELECT Highschooler.grade FROM Highschooler WHERE Highschooler.name = 'Kyle';,"SELECT grade FROM Highschooler WHERE name  =  ""Kyle""",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the grade of the student named ""Kyle"". 2. Condition Structure: Use a WHERE clause to filter for the student whose name is ""Kyle"". 3. Join Structure: No JOIN is required since all necessary information is in the ""Highschooler"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[(12,)]","[(12,)]",,1.0,
Show the names of all high schoolers in grade 10.,"[Highschooler.name, Highschooler.grade, 10]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,SELECT Highschooler.name FROM Highschooler WHERE Highschooler.grade = 10;,SELECT name FROM Highschooler WHERE grade  =  10,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of high schoolers. 2. Condition Structure: Use a WHERE clause to filter for high schoolers in grade 10. 3. Join Structure: No JOIN is required since all necessary information is in the ""Highschooler"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.","[('Haley',), ('Andrew',), ('Kris',), ('Brittany',)]","[('Haley',), ('Andrew',), ('Kris',), ('Brittany',)]",,1.0,
"What are the maximum and minimum share of performances whose type is not ""Live final"".","[performance.Share, performance.Type]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,"SELECT MAX(performance.Share) AS max_share, MIN(performance.Share) AS min_share FROM performance WHERE performance.Type != 'Live final';","SELECT max(SHARE) ,  min(SHARE) FROM performance WHERE TYPE != ""Live final""",orchestra,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate values, which are the maximum and minimum shares. 2. Condition Structure: Use a WHERE clause to filter performances where the ""performance.Type"" is not ""Live final"". 3. Join Structure: No JOIN is required since all necessary data is within the ""performance"" table. 4. Aggregation Structure: Use MAX and MIN functions to calculate the maximum and minimum share of the filtered performances.","[('44.7%', '22.7%')]","[('44.7%', '22.7%')]",,1.0,
Show the name of the conductor that has conducted the most number of orchestras.,"[conductor.Name,orchestra.Conductor_ID,orchestra.Conductor_ID = conductor.Conductor_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NON-NESTED,SELECT conductor.Name FROM conductor JOIN orchestra ON orchestra.Conductor_ID = conductor.Conductor_ID GROUP BY conductor.Conductor_ID ORDER BY COUNT(orchestra.Orchestra_ID) DESC LIMIT 1;,SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID ORDER BY COUNT(*) DESC LIMIT 1,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""conductor.Name."" Use COUNT to count the number of orchestras conducted by each conductor. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the conductor with the most orchestras. 3. Join Structure: Use a JOIN between the ""conductor"" and ""orchestra"" tables based on ""orchestra.Conductor_ID = conductor.Conductor_ID"" to associate each conductor with their orchestras. 4. Aggregation Structure: Use COUNT to count the number of orchestras for each conductor, GROUP BY ""conductor.Conductor_ID"" to group the results by conductor, and ORDER BY the count in descending order to rank conductors by the number of orchestras. Use LIMIT 1 to select the conductor with the highest count.","[('Michael Tilson Thomas',)]","[('Michael Tilson Thomas',)]",,1.0,
What are the cities whose population is between 160000 and 900000?,"[city.Name, city.Population, 160000, 900000]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT city.Name FROM city WHERE city.Population BETWEEN 160000 AND 900000;,SELECT name FROM city WHERE Population BETWEEN 160000 AND 900000,world_1,"1. Sequential Structure: Start with the SELECT clause to specify the city names, as the question asks for the names of cities. 2. Condition Structure: Use a WHERE clause to filter cities where the population is between 160000 and 900000. 3. Join Structure: No JOIN is required since all necessary information is in the ""city"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving city names that meet the specified population condition.","[('Qandahar',), ('Herat',), ('Amsterdam',), ('Rotterdam',), ('Haag',), ('Utrecht',), ('Eindhoven',), ('Tilburg',), ('Groningen',), ('Breda',), ('Tirana',), ('Oran',), ('Constantine',), ('Annaba',), ('Batna',), ('Sétif',), ('Huambo',), ('Dubai',), ('Abu Dhabi',), ('Sharja',), ('al-Ayn',), ('Lomas de Zamora',), ('Quilmes',), ('Almirante Brown',), ('La Plata',), ('Mar del Plata',), ('San Miguel de Tucumán',), ('Lanús',), ('Merlo',), ('General San Martín',), ('Salta',), ('Moreno',), ('Santa Fé',), ('Avellaneda',), ('Tres de Febrero',), ('Morón',), ('Florencio Varela',), ('San Isidro',), ('Tigre',), ('Malvinas Argentinas',), ('Vicente López',), ('Berazategui',), ('Corrientes',), ('San Miguel',), ('Bahía Blanca',), ('Esteban Echeverría',), ('Resistencia',), ('José C. Paz',), ('Paraná',), ('Godoy Cruz',), ('Posadas',), ('Guaymallén',), ('Santiago del Estero',), ('San Salvador de Jujuy',), ('Hurlingham',), ('Neuquén',), ('Gjumri',), ('Vanadzor',), ('Canberra',), ('Gold Coast',), ('Newcastle',), ('Central Coast',), ('Wollongong',), ('Gäncä',), ('Sumqayit',), ('Nassau',), ('Khulna',), ('Rajshahi',), ('Narayanganj',), ('Rangpur',), ('Mymensingh',), ('Barisal',), ('Tungi',), ('Antwerpen',), ('Gent',), ('Charleroi',), ('Liège',), ('Cotonou',), ('Porto-Novo',), ('La Paz',), ('El Alto',), ('Cochabamba',), ('Oruro',), ('Sucre',), ('Sarajevo',), ('Gaborone',), ('São Gonçalo',), ('Nova Iguaçu',), ('São Luís',), ('Maceió',), ('Duque de Caxias',), ('São Bernardo do Campo',), ('Teresina',), ('Natal',), ('Osasco',), ('Campo Grande',), ('Santo André',), ('João Pessoa',), ('Jaboatão dos Guararapes',), ('Contagem',), ('São José dos Campos',), ('Uberlândia',), ('Feira de Santana',), ('Ribeirão Preto',), ('Sorocaba',), ('Niterói',), ('Cuiabá',), ('Juiz de Fora',), ('Aracaju',), ('São João de Meriti',), ('Londrina',), ('Joinville',), ('Belford Roxo',), ('Santos',), ('Ananindeua',), ('Campos dos Goytacazes',), ('Mauá',), ('Carapicuíba',), ('Olinda',), ('Campina Grande',), ('São José do Rio Preto',), ('Caxias do Sul',), ('Moji das Cruzes',), ('Diadema',), ('Aparecida de Goiânia',), ('Piracicaba',), ('Cariacica',), ('Vila Velha',), ('Pelotas',), ('Bauru',), ('Porto Velho',), ('Serra',), ('Betim',), ('Jundíaí',), ('Canoas',), ('Franca',), ('São Vicente',), ('Maringá',), ('Montes Claros',), ('Anápolis',), ('Florianópolis',), ('Petrópolis',), ('Itaquaquecetuba',), ('Vitória',), ('Ponta Grossa',), ('Rio Branco',), ('Foz do Iguaçu',), ('Macapá',), ('Ilhéus',), ('Vitória da Conquista',), ('Uberaba',), ('Paulista',), ('Limeira',), ('Blumenau',), ('Caruaru',), ('Santarém',), ('Volta Redonda',), ('Novo Hamburgo',), ('Caucaia',), ('Santa Maria',), ('Cascavel',), ('Guarujá',), ('Ribeirão das Neves',), ('Governador Valadares',), ('Taubaté',), ('Imperatriz',), ('Gravataí',), ('Embu',), ('Mossoró',), ('Várzea Grande',), ('Petrolina',), ('Barueri',), ('Viamão',), ('Ipatinga',), ('Juazeiro',), ('Juazeiro do Norte',), ('Taboão da Serra',), ('São José dos Pinhais',), ('Magé',), ('Suzano',), ('São Leopoldo',), ('Marília',), ('São Carlos',), ('Sumaré',), ('Presidente Prudente',), ('Divinópolis',), ('Sete Lagoas',), ('Rio Grande',), ('Itabuna',), ('Jequié',), ('Arapiraca',), ('Colombo',), ('Americana',), ('Alvorada',), ('Araraquara',), ('Itaboraí',), ('Santa Bárbara d´Oeste',), ('Nova Friburgo',), ('Jacareí',), ('Araçatuba',), ('Barra Mansa',), ('Praia Grande',), ('Marabá',), ('Criciúma',), ('Boa Vista',), ('Passo Fundo',), ('Dourados',), ('Santa Luzia',), ('Rio Claro',), ('Maracanaú',), ('Guarapuava',), ('Glasgow',), ('Liverpool',), ('Edinburgh',), ('Sheffield',), ('Manchester',), ('Leeds',), ('Bristol',), ('Cardiff',), ('Coventry',), ('Leicester',), ('Bradford',), ('Belfast',), ('Nottingham',), ('Kingston upon Hull',), ('Plymouth',), ('Stoke-on-Trent',), ('Wolverhampton',), ('Derby',), ('Swansea',), ('Southampton',), ('Aberdeen',), ('Northampton',), ('Dudley',), ('Portsmouth',), ('Newcastle upon Tyne',), ('Sunderland',), ('Luton',), ('Swindon',), ('Southend-on-Sea',), ('Walsall',), ('Bournemouth',), ('Plovdiv',), ('Varna',), ('Burgas',), ('Ruse',), ('Ouagadougou',), ('Bobo-Dioulasso',), ('Bujumbura',), ('Puente Alto',), ('Viña del Mar',), ('Valparaíso',), ('Talcahuano',), ('Antofagasta',), ('San Bernardo',), ('Temuco',), ('Concepción',), ('Rancagua',), ('Arica',), ('Talca',), ('Chillán',), ('Iquique',), ('San José',), ('Djibouti',), ('Santiago de los Caballeros',), ('Cuenca',), ('Machala',), ('Santo Domingo de los Colorados',), ('Portoviejo',), ('Ambato',), ('Manta',), ('Shubra al-Khayma',), ('Port Said',), ('Suez',), ('al-Mahallat al-Kubra',), ('Tanta',), ('al-Mansura',), ('Luxor',), ('Asyut',), ('Bahtim',), ('Zagazig',), ('al-Faiyum',), ('Ismailia',), ('Kafr al-Dawwar',), ('Assuan',), ('Damanhur',), ('al-Minya',), ('Bani Suwayf',), ('Qina',), ('Sawhaj',), ('San Salvador',), ('Asmara',), ('Valencia',), ('Sevilla',), ('Zaragoza',), ('Málaga',), ('Bilbao',), ('Las Palmas de Gran Canaria',), ('Murcia',), ('Palma de Mallorca',), ('Valladolid',), ('Córdoba',), ('Vigo',), ('Alicante [Alacant]',), ('Gijón',), ('L´Hospitalet de Llobregat',), ('Granada',), ('A Coruña (La Coruña)',), ('Vitoria-Gasteiz',), ('Santa Cruz de Tenerife',), ('Badalona',), ('Oviedo',), ('Móstoles',), ('Elche [Elx]',), ('Sabadell',), ('Santander',), ('Jerez de la Frontera',), ('Pamplona [Iruña]',), ('Donostia-San Sebastián',), ('Cartagena',), ('Leganés',), ('Fuenlabrada',), ('Almería',), ('Terrassa',), ('Alcalá de Henares',), ('Burgos',), ('Johannesburg',), ('Port Elizabeth',), ('Pretoria',), ('Inanda',), ('Durban',), ('Vanderbijlpark',), ('Kempton Park',), ('Alberton',), ('Pinetown',), ('Pietermaritzburg',), ('Benoni',), ('Randburg',), ('Umlazi',), ('Bloemfontein',), ('Vereeniging',), ('Wonderboom',), ('Roodepoort',), ('Boksburg',), ('Klerksdorp',), ('Soshanguve',), ('Newcastle',), ('East London',), ('Welkom',), ('Kimberley',), ('Uitenhage',), ('Chatsworth',), ('Mdantsane',), ('Krugersdorp',), ('Botshabelo',), ('Brakpan',), ('Witbank',), ('Oberholzer',), ('Germiston',), ('Springs',), ('Dire Dawa',), ('Cebu',), ('Zamboanga',), ('Pasig',), ('Valenzuela',), ('Las Piñas',), ('Antipolo',), ('Taguig',), ('Cagayan de Oro',), ('Parañaque',), ('Makati',), ('Bacolod',), ('General Santos',), ('Marikina',), ('Dasmariñas',), ('Muntinlupa',), ('Iloilo',), ('Pasay',), ('Malabon',), ('San José del Monte',), ('Bacoor',), ('Iligan',), ('Calamba',), ('Mandaluyong',), ('Butuan',), ('Angeles',), ('Tarlac',), ('Mandaue',), ('Baguio',), ('Batangas',), ('Cainta',), ('San Pedro',), ('Navotas',), ('Cabanatuan',), ('San Fernando',), ('Lipa',), ('Lapu-Lapu',), ('San Pablo',), ('Biñan',), ('Taytay',), ('Lucena',), ('Imus',), ('Olongapo',), ('Binangonan',), ('Santa Rosa',), ('Tagum',), ('Tacloban',), ('Malolos',), ('Mabalacat',), ('Cotabato',), ('Meycauayan',), ('Puerto Princesa',), ('Libreville',), ('Kutaisi',), ('Kumasi',), ('Ciudad de Guatemala',), ('Mixco',), ('Bissau',), ('Georgetown',), ('Port-au-Prince',), ('Carrefour',), ('Delmas',), ('Tegucigalpa',), ('San Pedro Sula',), ('Malang',), ('Bandar Lampung',), ('Bekasi',), ('Padang',), ('Surakarta',), ('Banjarmasin',), ('Pekan Baru',), ('Denpasar',), ('Yogyakarta',), ('Pontianak',), ('Samarinda',), ('Jambi',), ('Depok',), ('Cimahi',), ('Balikpapan',), ('Manado',), ('Mataram',), ('Pekalongan',), ('Tegal',), ('Bogor',), ('Ciputat',), ('Pondokgede',), ('Cirebon',), ('Kediri',), ('Ambon',), ('Jember',), ('Cilacap',), ('Cimanggis',), ('Pematang Siantar',), ('Purwokerto',), ('Ciomas',), ('Tasikmalaya',), ('Madiun',), ('Srinagar',), ('Agra',), ('Coimbatore',), ('Thane (Thana)',), ('Allahabad',), ('Meerut',), ('Vishakhapatnam',), ('Jabalpur',), ('Amritsar',), ('Faridabad',), ('Vijayawada',), ('Gwalior',), ('Jodhpur',), ('Nashik (Nasik)',), ('Hubli-Dharwad',), ('Solapur (Sholapur)',), ('Ranchi',), ('Bareilly',), ('Guwahati (Gauhati)',), ('Shambajinagar (Aurangabad)',), ('Cochin (Kochi)',), ('Rajkot',), ('Kota',), ('Thiruvananthapuram (Trivandrum',), ('Pimpri-Chinchwad',), ('Jalandhar (Jullundur)',), ('Gorakhpur',), ('Chandigarh',), ('Mysore',), ('Aligarh',), ('Guntur',), ('Jamshedpur',), ('Ghaziabad',), ('Warangal',), ('Raipur',), ('Moradabad',), ('Durgapur',), ('Amravati',), ('Calicut (Kozhikode)',), ('Bikaner',), ('Bhubaneswar',), ('Kolhapur',), ('Kataka (Cuttack)',), ('Ajmer',), ('Bhavnagar',), ('Tiruchirapalli',), ('Bhilai',), ('Bhiwandi',), ('Saharanpur',), ('Ulhasnagar',), ('Salem',), ('Ujjain',), ('Malegaon',), ('Jamnagar',), ('Bokaro Steel City',), ('Akola',), ('Belgaum',), ('Rajahmundry',), ('Nellore',), ('Udaipur',), ('New Bombay',), ('Bhatpara',), ('Gulbarga',), ('New Delhi',), ('Jhansi',), ('Gaya',), ('Kakinada',), ('Dhule (Dhulia)',), ('Panihati',), ('Nanded (Nander)',), ('Mangalore',), ('Dehra Dun',), ('Kamarhati',), ('Davangere',), ('Asansol',), ('Bhagalpur',), ('Bellary',), ('Barddhaman (Burdwan)',), ('Rampur',), ('Jalgaon',), ('Muzaffarpur',), ('Nizamabad',), ('Muzaffarnagar',), ('Patiala',), ('Shahjahanpur',), ('Kurnool',), ('Tiruppur (Tirupper)',), ('Rohtak',), ('South Dum Dum',), ('Mathura',), ('Chandrapur',), ('Barahanagar (Baranagar)',), ('Darbhanga',), ('Siliguri (Shiliguri)',), ('Raurkela',), ('Ambattur',), ('Panipat',), ('Firozabad',), ('Ichalkaranji',), ('Jammu',), ('Ramagundam',), ('Eluru',), ('Brahmapur',), ('Alwar',), ('Pondicherry',), ('Thanjavur',), ('Bihar Sharif',), ('Tuticorin',), ('Imphal',), ('Latur',), ('Sagar',), ('Farrukhabad-cum-Fatehgarh',), ('Sangli',), ('Parbhani',), ('Nagar Coil',), ('Bijapur',), ('Kukatpalle',), ('Bally',), ('Bhilwara',), ('Ratlam',), ('Avadi',), ('Dindigul',), ('Ahmadnagar',), ('Bilaspur',), ('Shimoga',), ('Kharagpur',), ('Mira Bhayandar',), ('Vellore',), ('Jalna',), ('Burnpur',), ('Anantapur',), ('Allappuzha (Alleppey)',), ('Tirupati',), ('Karnal',), ('Burhanpur',), ('Hisar (Hissar)',), ('Tiruvottiyur',), ('Mirzapur-cum-Vindhyachal',), ('Secunderabad',), ('Nadiad',), ('Dewas',), ('Murwara (Katni)',), ('Ganganagar',), ('Vizianagaram',), ('Mosul',), ('Irbil',), ('Kirkuk',), ('Basra',), ('al-Sulaymaniya',), ('al-Najaf',), ('Karbala',), ('al-Hilla',), ('al-Nasiriya',), ('al-Amara',), ('al-Diwaniya',), ('al-Ramadi',), ('al-Kut',), ('Ahvaz',), ('Qom',), ('Kermanshah',), ('Urmia',), ('Zahedan',), ('Rasht',), ('Hamadan',), ('Kerman',), ('Arak',), ('Ardebil',), ('Yazd',), ('Qazvin',), ('Zanjan',), ('Sanandaj',), ('Bandar-e-Abbas',), ('Khorramabad',), ('Eslamshahr',), ('Borujerd',), ('Abadan',), ('Dezful',), ('Kashan',), ('Sari',), ('Gorgan',), ('Najafabad',), ('Sabzevar',), ('Khomeynishahr',), ('Dublin',), ('Jerusalem',), ('Tel Aviv-Jaffa',), ('Haifa',), ('Rishon Le Ziyyon',), ('Beerseba',), ('Holon',), ('Palermo',), ('Genova',), ('Bologna',), ('Firenze',), ('Catania',), ('Bari',), ('Venezia',), ('Messina',), ('Verona',), ('Trieste',), ('Padova',), ('Taranto',), ('Brescia',), ('Reggio di Calabria',), ('Modena',), ('Prato',), ('Parma',), ('Cagliari',), ('Livorno',), ('Graz',), ('Linz',), ('Chiba',), ('Sakai',), ('Kumamoto',), ('Okayama',), ('Sagamihara',), ('Hamamatsu',), ('Kagoshima',), ('Funabashi',), ('Higashiosaka',), ('Hachioji',), ('Niigata',), ('Amagasaki',), ('Himeji',), ('Shizuoka',), ('Urawa',), ('Matsuyama',), ('Matsudo',), ('Kanazawa',), ('Kawaguchi',), ('Ichikawa',), ('Omiya',), ('Utsunomiya',), ('Oita',), ('Nagasaki',), ('Yokosuka',), ('Kurashiki',), ('Gifu',), ('Hirakata',), ('Nishinomiya',), ('Toyonaka',), ('Wakayama',), ('Fukuyama',), ('Fujisawa',), ('Asahikawa',), ('Machida',), ('Nara',), ('Takatsuki',), ('Iwaki',), ('Nagano',), ('Toyohashi',), ('Toyota',), ('Suita',), ('Takamatsu',), ('Koriyama',), ('Okazaki',), ('Kawagoe',), ('Tokorozawa',), ('Toyama',), ('Kochi',), ('Kashiwa',), ('Akita',), ('Miyazaki',), ('Koshigaya',), ('Naha',), ('Aomori',), ('Hakodate',), ('Akashi',), ('Yokkaichi',), ('Fukushima',), ('Morioka',), ('Maebashi',), ('Kasugai',), ('Otsu',), ('Ichihara',), ('Yao',), ('Ichinomiya',), ('Tokushima',), ('Kakogawa',), ('Ibaraki',), ('Neyagawa',), ('Shimonoseki',), ('Yamagata',), ('Fukui',), ('Hiratsuka',), ('Mito',), ('Sasebo',), ('Hachinohe',), ('Takasaki',), ('Shimizu',), ('Kurume',), ('Fuji',), ('Soka',), ('Fuchu',), ('Chigasaki',), ('Atsugi',), ('Numazu',), ('Ageo',), ('Yamato',), ('Matsumoto',), ('Kure',), ('Takarazuka',), ('Kasukabe',), ('Chofu',), ('Odawara',), ('Kofu',), ('Kushiro',), ('Kishiwada',), ('Hitachi',), ('Nagaoka',), ('Itami',), ('Uji',), ('Suzuka',), ('Hirosaki',), ('Ube',), ('Kodaira',), ('Takaoka',), ('Obihiro',), ('Tomakomai',), ('Saga',), ('Sakura',), ('Kamakura',), ('Mitaka',), ('Izumi',), ('Hino',), ('Hadano',), ('Ashikaga',), ('Tsu',), ('Sayama',), ('Yachiyo',), ('Tsukuba',), ('Sanaa',), ('Aden',), ('Taizz',), ('Hodeida',), ('al-Zarqa',), ('Irbid',), ('Novi Sad',), ('Niš',), ('Phnom Penh',), ('Garoua',), ('Calgary',), ('Toronto',), ('North York',), ('Winnipeg',), ('Edmonton',), ('Mississauga',), ('Scarborough',), ('Vancouver',), ('Etobicoke',), ('London',), ('Hamilton',), ('Ottawa',), ('Laval',), ('Surrey',), ('Brampton',), ('Windsor',), ('Saskatoon',), ('Kitchener',), ('Markham',), ('Regina',), ('Burnaby',), ('Québec',), ('Qaraghandy',), ('Shymkent',), ('Taraz',), ('Astana',), ('Öskemen',), ('Pavlodar',), ('Semey',), ('Aqtöbe',), ('Qostanay',), ('Petropavl',), ('Oral',), ('Temirtau',), ('Mombasa',), ('Kisumu',), ('Nakuru',), ('Bangui',), ('Handan',), ('Wuxi',), ('Xuzhou',), ('Datong',), ('Yichun',), ('Benxi',), ('Luoyang',), ('Suzhou',), ('Xining',), ('Huainan',), ('Jixi',), ('Daqing',), ('Fuxin',), ('Amoy [Xiamen]',), ('Liuzhou',), ('Shantou',), ('Jinzhou',), ('Mudanjiang',), ('Yinchuan',), ('Changzhou',), ('Zhangjiakou',), ('Dandong',), ('Hegang',), ('Kaifeng',), ('Jiamusi',), ('Liaoyang',), ('Hengyang',), ('Baoding',), ('Hunjiang',), ('Xinxiang',), ('Huangshi',), ('Haikou',), ('Yantai',), ('Bengbu',), ('Xiangtan',), ('Weifang',), ('Wuhu',), ('Pingxiang',), ('Yingkou',), ('Anyang',), ('Panzhihua',), ('Pingdingshan',), ('Xiangfan',), ('Zhuzhou',), ('Jiaozuo',), ('Wenzhou',), ('Zhangjiang',), ('Zigong',), ('Shuangyashan',), ('Zaozhuang',), ('Yakeshi',), ('Yichang',), ('Zhenjiang',), ('Huaibei',), ('Qinhuangdao',), ('Guilin',), ('Liupanshui',), ('Panjin',), ('Yangquan',), ('Jinxi',), ('Liaoyuan',), ('Lianyungang',), ('Xianyang',), ('Tai´an',), ('Chifeng',), ('Shaoguan',), ('Nantong',), ('Leshan',), ('Baoji',), ('Linyi',), ('Tonghua',), ('Siping',), ('Changzhi',), ('Tengzhou',), ('Chaozhou',), ('Yangzhou',), ('Dongwan',), ('Ma´anshan',), ('Foshan',), ('Yueyang',), ('Xingtai',), ('Changde',), ('Shihezi',), ('Yancheng',), ('Jiujiang',), ('Dongying',), ('Shashi',), ('Xintai',), ('Jingdezhen',), ('Tongchuan',), ('Zhongshan',), ('Shiyan',), ('Tieli',), ('Jining',), ('Wuhai',), ('Mianyang',), ('Luzhou',), ('Zunyi',), ('Shizuishan',), ('Neijiang',), ('Tongliao',), ('Tieling',), ('Wafangdian',), ('Anqing',), ('Shaoyang',), ('Laiwu',), ('Chengde',), ('Tianshui',), ('Nanyang',), ('Cangzhou',), ('Yibin',), ('Huaiyin',), ('Dunhua',), ('Yanji',), ('Jiangmen',), ('Tongling',), ('Suihua',), ('Gongziling',), ('Xiantao',), ('Chaoyang',), ('Ganzhou',), ('Huzhou',), ('Baicheng',), ('Shangzi',), ('Yangjiang',), ('Qitaihe',), ('Gejiu',), ('Jiangyin',), ('Hebi',), ('Jiaxing',), ('Wuzhou',), ('Meihekou',), ('Xuchang',), ('Liaocheng',), ('Haicheng',), ('Qianjiang',), ('Baiyin',), ('Bei´an',), ('Yixing',), ('Laizhou',), ('Qaramay',), ('Acheng',), ('Dezhou',), ('Nanping',), ('Zhaoqing',), ('Beipiao',), ('Fengcheng',), ('Fuyu',), ('Xinyang',), ('Dongtai',), ('Yuci',), ('Honghu',), ('Ezhou',), ('Heze',), ('Daxian',), ('Linfen',), ('Tianmen',), ('Yiyang',), ('Quanzhou',), ('Rizhao',), ('Deyang',), ('Guangyuan',), ('Changshu',), ('Zhangzhou',), ('Hailar',), ('Nanchong',), ('Jiutai',), ('Zhaodong',), ('Shaoxing',), ('Fuyang',), ('Maoming',), ('Qujing',), ('Ghulja',), ('Jiaohe',), ('Puyang',), ('Huadian',), ('Jiangyou',), ('Qashqar',), ('Anshun',), ('Fuling',), ('Xinyu',), ('Hanzhong',), ('Danyang',), ('Chenzhou',), ('Xiaogan',), ('Shangqiu',), ('Zhuhai',), ('Qingyuan',), ('Aqsu',), ('Jining',), ('Xiaoshan',), ('Zaoyang',), ('Xinghua',), ('Hami',), ('Huizhou',), ('Jinmen',), ('Sanming',), ('Bishkek',), ('Osh',), ('Cartagena',), ('Cúcuta',), ('Bucaramanga',), ('Ibagué',), ('Pereira',), ('Santa Marta',), ('Manizales',), ('Bello',), ('Pasto',), ('Neiva',), ('Soledad',), ('Armenia',), ('Villavicencio',), ('Soacha',), ('Valledupar',), ('Montería',), ('Itagüí',), ('Palmira',), ('Buenaventura',), ('Floridablanca',), ('Sincelejo',), ('Popayán',), ('Barrancabermeja',), ('Pointe-Noire',), ('Lubumbashi',), ('Mbuji-Mayi',), ('Kolwezi',), ('Kisangani',), ('Kananga',), ('Likasi',), ('Bukavu',), ('Kikwit',), ('Tshikapa',), ('Matadi',), ('Mbandaka',), ('Hamhung',), ('Chongjin',), ('Nampo',), ('Sinuiju',), ('Wonsan',), ('Phyongsong',), ('Sariwon',), ('Haeju',), ('Kanggye',), ('Kimchaek',), ('Hyesan',), ('Kaesong',), ('Songnam',), ('Puchon',), ('Suwon',), ('Anyang',), ('Chonju',), ('Chongju',), ('Koyang',), ('Ansan',), ('Pohang',), ('Chang-won',), ('Masan',), ('Kwangmyong',), ('Chonan',), ('Chinju',), ('Iksan',), ('Pyongtaek',), ('Kumi',), ('Uijongbu',), ('Kyongju',), ('Kunsan',), ('Cheju',), ('Kimhae',), ('Sunchon',), ('Mokpo',), ('Yong-in',), ('Wonju',), ('Kunpo',), ('Chunchon',), ('Namyangju',), ('Kangnung',), ('Chungju',), ('Andong',), ('Yosu',), ('Kyongsan',), ('Paju',), ('Yangsan',), ('Athenai',), ('Thessaloniki',), ('Pireus',), ('Zagreb',), ('Split',), ('Rijeka',), ('Santiago de Cuba',), ('Camagüey',), ('Holguín',), ('Santa Clara',), ('Guantánamo',), ('Nicosia',), ('Vientiane',), ('Riga',), ('Maseru',), ('Tripoli',), ('Monrovia',), ('Bengasi',), ('Vilnius',), ('Kaunas',), ('Klaipeda',), ('El-Aaiún',), ('Macao',), ('Antananarivo',), ('Skopje',), ('Blantyre',), ('Lilongwe',), ('Ipoh',), ('Johor Baharu',), ('Petaling Jaya',), ('Kelang',), ('Kuala Terengganu',), ('Pinang',), ('Kota Bharu',), ('Kuantan',), ('Taiping',), ('Seremban',), ('Bamako',), ('Rabat',), ('Marrakech',), ('Fès',), ('Tanger',), ('Salé',), ('Meknès',), ('Oujda',), ('Kénitra',), ('Tétouan',), ('Safi',), ('Nouakchott',), ('Naucalpan de Juárez',), ('Mexicali',), ('Culiacán',), ('Acapulco de Juárez',), ('Tlalnepantla de Baz',), ('Mérida',), ('Chihuahua',), ('San Luis Potosí',), ('Guadalupe',), ('Toluca',), ('Aguascalientes',), ('Querétaro',), ('Morelia',), ('Hermosillo',), ('Saltillo',), ('Torreón',), ('Centro (Villahermosa)',), ('San Nicolás de los Garza',), ('Durango',), ('Chimalhuacán',), ('Tlaquepaque',), ('Atizapán de Zaragoza',), ('Veracruz',), ('Cuautitlán Izcalli',), ('Irapuato',), ('Tuxtla Gutiérrez',), ('Tultitlán',), ('Reynosa',), ('Benito Juárez',), ('Matamoros',), ('Xalapa',), ('Celaya',), ('Mazatlán',), ('Ensenada',), ('Ahome',), ('Cajeme',), ('Cuernavaca',), ('Tonalá',), ('Valle de Chalco Solidaridad',), ('Nuevo Laredo',), ('Tepic',), ('Tampico',), ('Ixtapaluca',), ('Apodaca',), ('Guasave',), ('Gómez Palacio',), ('Tapachula',), ('Nicolás Romero',), ('Coatzacoalcos',), ('Uruapan',), ('Victoria',), ('Oaxaca de Juárez',), ('Coacalco de Berriozábal',), ('Pachuca de Soto',), ('General Escobedo',), ('Salamanca',), ('Santa Catarina',), ('Tehuacán',), ('Chalco',), ('Cárdenas',), ('Campeche',), ('La Paz',), ('Othón P. Blanco (Chetumal)',), ('Texcoco',), ('La Paz',), ('Metepec',), ('Monclova',), ('Huixquilucan',), ('Chilpancingo de los Bravo',), ('Puerto Vallarta',), ('Fresnillo',), ('Ciudad Madero',), ('Soledad de Graciano Sánchez',), ('San Juan del Río',), ('San Felipe del Progreso',), ('Córdoba',), ('Tecámac',), ('Ocosingo',), ('Carmen',), ('Lázaro Cárdenas',), ('Jiutepec',), ('Papantla',), ('Comalcalco',), ('Zamora',), ('Chisinau',), ('Tiraspol',), ('Ulan Bator',), ('Matola',), ('Beira',), ('Nampula',), ('Chimoio',), ('Mandalay',), ('Moulmein (Mawlamyine)',), ('Pegu (Bago)',), ('Bassein (Pathein)',), ('Windhoek',), ('Kathmandu',), ('Niamey',), ('Ogbomosho',), ('Kano',), ('Oshogbo',), ('Ilorin',), ('Abeokuta',), ('Port Harcourt',), ('Zaria',), ('Ilesha',), ('Onitsha',), ('Iwo',), ('Ado-Ekiti',), ('Abuja',), ('Kaduna',), ('Mushin',), ('Maiduguri',), ('Enugu',), ('Ede',), ('Aba',), ('Ife',), ('Ila',), ('Oyo',), ('Ikerre',), ('Benin City',), ('Iseyin',), ('Katsina',), ('Jos',), ('Sokoto',), ('Ilobu',), ('Offa',), ('Ikorodu',), ('Ilawe-Ekiti',), ('Owo',), ('Ikirun',), ('Shaki',), ('Calabar',), ('Ondo',), ('Akure',), ('Oslo',), ('Bergen',), ('Bouaké',), ('Quetta',), ('Islamabad',), ('Sargodha',), ('Sialkot',), ('Bahawalpur',), ('Sukkur',), ('Jhang',), ('Sheikhupura',), ('Larkana',), ('Gujrat',), ('Mardan',), ('Kasur',), ('Rahim Yar Khan',), ('Sahiwal',), ('Okara',), ('Wah',), ('Dera Ghazi Khan',), ('Mirpur Khas',), ('Nawabshah',), ('Mingora',), ('Chiniot',), ('Ciudad de Panamá',), ('San Miguelito',), ('Port Moresby',), ('Asunción',), ('Arequipa',), ('Trujillo',), ('Chiclayo',), ('Callao',), ('Iquitos',), ('Chimbote',), ('Huancayo',), ('Piura',), ('Cusco',), ('Pucallpa',), ('Tacna',), ('Ica',), ('Lisboa',), ('Porto',), ('San Juan',), ('Bayamón',), ('Ponce',), ('Carolina',), ('Lódz',), ('Kraków',), ('Wroclaw',), ('Poznan',), ('Gdansk',), ('Szczecin',), ('Bydgoszcz',), ('Lublin',), ('Katowice',), ('Bialystok',), ('Czestochowa',), ('Gdynia',), ('Sosnowiec',), ('Radom',), ('Kielce',), ('Gliwice',), ('Torun',), ('Bytom',), ('Zabrze',), ('Bielsko-Biala',), ('Olsztyn',), ('Rzeszów',), ('Doha',), ('Marseille',), ('Lyon',), ('Toulouse',), ('Nice',), ('Nantes',), ('Strasbourg',), ('Montpellier',), ('Bordeaux',), ('Rennes',), ('Le Havre',), ('Reims',), ('Lille',), ('St-Étienne',), ('Toulon',), ('Iasi',), ('Constanta',), ('Cluj-Napoca',), ('Galati',), ('Timisoara',), ('Brasov',), ('Craiova',), ('Ploiesti',), ('Braila',), ('Oradea',), ('Bacau',), ('Pitesti',), ('Arad',), ('Sibiu',), ('Târgu Mures',), ('Kigali',), ('Stockholm',), ('Gothenburg [Göteborg]',), ('Malmö',), ('Uppsala',), ('Frankfurt am Main',), ('Essen',), ('Dortmund',), ('Stuttgart',), ('Düsseldorf',), ('Bremen',), ('Duisburg',), ('Hannover',), ('Leipzig',), ('Nürnberg',), ('Dresden',), ('Bochum',), ('Wuppertal',), ('Bielefeld',), ('Mannheim',), ('Bonn',), ('Gelsenkirchen',), ('Karlsruhe',), ('Wiesbaden',), ('Münster',), ('Mönchengladbach',), ('Chemnitz',), ('Augsburg',), ('Halle/Saale',), ('Braunschweig',), ('Aachen',), ('Krefeld',), ('Magdeburg',), ('Kiel',), ('Oberhausen',), ('Lübeck',), ('Hagen',), ('Rostock',), ('Freiburg im Breisgau',), ('Erfurt',), ('Kassel',), ('Saarbrücken',), ('Mainz',), ('Hamm',), ('Herne',), ('Mülheim an der Ruhr',), ('Solingen',), ('Osnabrück',), ('Ludwigshafen am Rhein',), ('Leverkusen',), ('Ndola',), ('Kitwe',), ('Medina',), ('al-Dammam',), ('al-Taif',), ('Tabuk',), ('Burayda',), ('al-Hufuf',), ('al-Mubarraz',), ('Khamis Mushayt',), ('Hail',), ('Pikine',), ('Dakar',), ('Thiès',), ('Kaolack',), ('Ziguinchor',), ('Freetown',), ('Bratislava',), ('Košice',), ('Ljubljana',), ('Colombo',), ('Dehiwala',), ('Moratuwa',), ('Sharq al-Nil',), ('Port Sudan',), ('Kassala',), ('Obeid',), ('Nyala',), ('Wad Madani',), ('al-Qadarif',), ('Kusti',), ('Helsinki [Helsingfors]',), ('Espoo',), ('Tampere',), ('Vantaa',), ('Turku [Åbo]',), ('Zürich',), ('Geneve',), ('Basel',), ('Hims',), ('Hama',), ('Latakia',), ('Dushanbe',), ('Khujand',), ('Tainan',), ('Panchiao',), ('Chungho',), ('Keelung (Chilung)',), ('Sanchung',), ('Hsinchuang',), ('Hsinchu',), ('Chungli',), ('Fengshan',), ('Taoyuan',), ('Chiayi',), ('Hsintien',), ('Changhwa',), ('Yungho',), ('Tucheng',), ('Pingtung',), ('Yungkang',), ('Pingchen',), ('Tali',), ('Taiping',), ('Pate',), ('Fengyuan',), ('Luchou',), ('Dodoma',), ('Mwanza',), ('København',), ('Århus',), ('Odense',), ('Aalborg',), ('Nonthaburi',), ('Nakhon Ratchasima',), ('Chiang Mai',), ('Lomé',), ('N´Djaména',), ('Brno',), ('Ostrava',), ('Plzen',), ('Tunis',), ('Sfax',), ('Ariana',), ('Ettadhamen',), ('Gaziantep',), ('Konya',), ('Mersin (Içel)',), ('Antalya',), ('Diyarbakir',), ('Kayseri',), ('Eskisehir',), ('Sanliurfa',), ('Samsun',), ('Malatya',), ('Gebze',), ('Denizli',), ('Sivas',), ('Erzurum',), ('Tarsus',), ('Kahramanmaras',), ('Elâzig',), ('Van',), ('Sultanbeyli',), ('Izmit (Kocaeli)',), ('Manisa',), ('Batman',), ('Balikesir',), ('Sakarya (Adapazari)',), ('Ashgabat',), ('Chärjew',), ('Kampala',), ('Zaporizzja',), ('Lviv',), ('Kryvyi Rig',), ('Mykolajiv',), ('Mariupol',), ('Lugansk',), ('Vinnytsja',), ('Makijivka',), ('Herson',), ('Sevastopol',), ('Simferopol',), ('Pultava [Poltava]',), ('Tšernigiv',), ('Tšerkasy',), ('Gorlivka',), ('Zytomyr',), ('Sumy',), ('Dniprodzerzynsk',), ('Kirovograd',), ('Hmelnytskyi',), ('Tšernivtsi',), ('Rivne',), ('Krementšuk',), ('Ivano-Frankivsk',), ('Ternopil',), ('Lutsk',), ('Bila Tserkva',), ('Kramatorsk',), ('Melitopol',), ('Kertš',), ('Debrecen',), ('Miskolc',), ('Auckland',), ('Christchurch',), ('Manukau',), ('North Shore',), ('Waitakere',), ('Wellington',), ('Namangan',), ('Samarkand',), ('Andijon',), ('Buhoro',), ('Karsi',), ('Nukus',), ('Kükon',), ('Fargona',), ('Gomel',), ('Mogiljov',), ('Vitebsk',), ('Grodno',), ('Brest',), ('Bobruisk',), ('Baranovitši',), ('Barquisimeto',), ('Valencia',), ('Ciudad Guayana',), ('Petare',), ('Maracay',), ('Barcelona',), ('Maturín',), ('San Cristóbal',), ('Ciudad Bolívar',), ('Cumaná',), ('Mérida',), ('Cabimas',), ('Barinas',), ('Turmero',), ('Baruta',), ('Puerto Cabello',), ('Santa Ana de Coro',), ('Los Teques',), ('Punto Fijo',), ('Guarenas',), ('Krasnojarsk',), ('Saratov',), ('Toljatti',), ('Uljanovsk',), ('Izevsk',), ('Krasnodar',), ('Jaroslavl',), ('Habarovsk',), ('Vladivostok',), ('Irkutsk',), ('Barnaul',), ('Novokuznetsk',), ('Penza',), ('Rjazan',), ('Orenburg',), ('Lipetsk',), ('Nabereznyje Tšelny',), ('Tula',), ('Tjumen',), ('Kemerovo',), ('Astrahan',), ('Tomsk',), ('Kirov',), ('Ivanovo',), ('Tšeboksary',), ('Brjansk',), ('Tver',), ('Kursk',), ('Magnitogorsk',), ('Kaliningrad',), ('Nizni Tagil',), ('Murmansk',), ('Ulan-Ude',), ('Kurgan',), ('Arkangeli',), ('Sotši',), ('Smolensk',), ('Orjol',), ('Stavropol',), ('Belgorod',), ('Kaluga',), ('Vladimir',), ('Mahatškala',), ('Tšerepovets',), ('Saransk',), ('Tambov',), ('Vladikavkaz',), ('Tšita',), ('Vologda',), ('Veliki Novgorod',), ('Komsomolsk-na-Amure',), ('Kostroma',), ('Volzski',), ('Taganrog',), ('Petroskoi',), ('Bratsk',), ('Dzerzinsk',), ('Surgut',), ('Orsk',), ('Sterlitamak',), ('Angarsk',), ('Joškar-Ola',), ('Rybinsk',), ('Prokopjevsk',), ('Niznevartovsk',), ('Naltšik',), ('Syktyvkar',), ('Severodvinsk',), ('Bijsk',), ('Niznekamsk',), ('Blagoveštšensk',), ('Šahty',), ('Staryi Oskol',), ('Zelenograd',), ('Balakovo',), ('Novorossijsk',), ('Pihkova',), ('Zlatoust',), ('Jakutsk',), ('Podolsk',), ('Petropavlovsk-Kamtšatski',), ('Kamensk-Uralski',), ('Engels',), ('Syzran',), ('Grozny',), ('Novotšerkassk',), ('Berezniki',), ('Juzno-Sahalinsk',), ('Volgodonsk',), ('Abakan',), ('Maikop',), ('Miass',), ('Armavir',), ('Ljubertsy',), ('Rubtsovsk',), ('Haiphong',), ('Da Nang',), ('Biên Hoa',), ('Nha Trang',), ('Hue',), ('Can Tho',), ('Cam Pha',), ('Nam Dinh',), ('Quy Nhon',), ('Tallinn',), ('San Jose',), ('Indianapolis',), ('San Francisco',), ('Jacksonville',), ('Columbus',), ('Austin',), ('Baltimore',), ('Memphis',), ('Milwaukee',), ('Boston',), ('Washington',), ('Nashville-Davidson',), ('El Paso',), ('Seattle',), ('Denver',), ('Charlotte',), ('Fort Worth',), ('Portland',), ('Oklahoma City',), ('Tucson',), ('New Orleans',), ('Las Vegas',), ('Cleveland',), ('Long Beach',), ('Albuquerque',), ('Kansas City',), ('Fresno',), ('Virginia Beach',), ('Atlanta',), ('Sacramento',), ('Oakland',), ('Mesa',), ('Tulsa',), ('Omaha',), ('Minneapolis',), ('Honolulu',), ('Miami',), ('Colorado Springs',), ('Saint Louis',), ('Wichita',), ('Santa Ana',), ('Pittsburgh',), ('Arlington',), ('Cincinnati',), ('Anaheim',), ('Toledo',), ('Tampa',), ('Buffalo',), ('Saint Paul',), ('Corpus Christi',), ('Aurora',), ('Raleigh',), ('Newark',), ('Lexington-Fayette',), ('Anchorage',), ('Louisville',), ('Riverside',), ('Saint Petersburg',), ('Bakersfield',), ('Stockton',), ('Birmingham',), ('Jersey City',), ('Norfolk',), ('Baton Rouge',), ('Hialeah',), ('Lincoln',), ('Greensboro',), ('Plano',), ('Rochester',), ('Glendale',), ('Akron',), ('Garland',), ('Madison',), ('Fort Wayne',), ('Fremont',), ('Scottsdale',), ('Montgomery',), ('Shreveport',), ('Augusta-Richmond County',), ('Lubbock',), ('Chesapeake',), ('Mobile',), ('Des Moines',), ('Grand Rapids',), ('Richmond',), ('Yonkers',), ('Spokane',), ('Glendale',), ('Tacoma',), ('Irving',), ('Huntington Beach',), ('Modesto',), ('Durham',), ('Columbus',), ('Orlando',), ('Boise City',), ('Winston-Salem',), ('San Bernardino',), ('Jackson',), ('Little Rock',), ('Salt Lake City',), ('Reno',), ('Newport News',), ('Chandler',), ('Laredo',), ('Henderson',), ('Arlington',), ('Knoxville',), ('Amarillo',), ('Providence',), ('Chula Vista',), ('Worcester',), ('Oxnard',), ('Dayton',), ('Garden Grove',), ('Oceanside',), ('Bulawayo',), ('Chitungwiza',), ('Mount Darwin',), ('Gaza',)]","[('Qandahar',), ('Herat',), ('Amsterdam',), ('Rotterdam',), ('Haag',), ('Utrecht',), ('Eindhoven',), ('Tilburg',), ('Groningen',), ('Breda',), ('Tirana',), ('Oran',), ('Constantine',), ('Annaba',), ('Batna',), ('Sétif',), ('Huambo',), ('Dubai',), ('Abu Dhabi',), ('Sharja',), ('al-Ayn',), ('Lomas de Zamora',), ('Quilmes',), ('Almirante Brown',), ('La Plata',), ('Mar del Plata',), ('San Miguel de Tucumán',), ('Lanús',), ('Merlo',), ('General San Martín',), ('Salta',), ('Moreno',), ('Santa Fé',), ('Avellaneda',), ('Tres de Febrero',), ('Morón',), ('Florencio Varela',), ('San Isidro',), ('Tigre',), ('Malvinas Argentinas',), ('Vicente López',), ('Berazategui',), ('Corrientes',), ('San Miguel',), ('Bahía Blanca',), ('Esteban Echeverría',), ('Resistencia',), ('José C. Paz',), ('Paraná',), ('Godoy Cruz',), ('Posadas',), ('Guaymallén',), ('Santiago del Estero',), ('San Salvador de Jujuy',), ('Hurlingham',), ('Neuquén',), ('Gjumri',), ('Vanadzor',), ('Canberra',), ('Gold Coast',), ('Newcastle',), ('Central Coast',), ('Wollongong',), ('Gäncä',), ('Sumqayit',), ('Nassau',), ('Khulna',), ('Rajshahi',), ('Narayanganj',), ('Rangpur',), ('Mymensingh',), ('Barisal',), ('Tungi',), ('Antwerpen',), ('Gent',), ('Charleroi',), ('Liège',), ('Cotonou',), ('Porto-Novo',), ('La Paz',), ('El Alto',), ('Cochabamba',), ('Oruro',), ('Sucre',), ('Sarajevo',), ('Gaborone',), ('São Gonçalo',), ('Nova Iguaçu',), ('São Luís',), ('Maceió',), ('Duque de Caxias',), ('São Bernardo do Campo',), ('Teresina',), ('Natal',), ('Osasco',), ('Campo Grande',), ('Santo André',), ('João Pessoa',), ('Jaboatão dos Guararapes',), ('Contagem',), ('São José dos Campos',), ('Uberlândia',), ('Feira de Santana',), ('Ribeirão Preto',), ('Sorocaba',), ('Niterói',), ('Cuiabá',), ('Juiz de Fora',), ('Aracaju',), ('São João de Meriti',), ('Londrina',), ('Joinville',), ('Belford Roxo',), ('Santos',), ('Ananindeua',), ('Campos dos Goytacazes',), ('Mauá',), ('Carapicuíba',), ('Olinda',), ('Campina Grande',), ('São José do Rio Preto',), ('Caxias do Sul',), ('Moji das Cruzes',), ('Diadema',), ('Aparecida de Goiânia',), ('Piracicaba',), ('Cariacica',), ('Vila Velha',), ('Pelotas',), ('Bauru',), ('Porto Velho',), ('Serra',), ('Betim',), ('Jundíaí',), ('Canoas',), ('Franca',), ('São Vicente',), ('Maringá',), ('Montes Claros',), ('Anápolis',), ('Florianópolis',), ('Petrópolis',), ('Itaquaquecetuba',), ('Vitória',), ('Ponta Grossa',), ('Rio Branco',), ('Foz do Iguaçu',), ('Macapá',), ('Ilhéus',), ('Vitória da Conquista',), ('Uberaba',), ('Paulista',), ('Limeira',), ('Blumenau',), ('Caruaru',), ('Santarém',), ('Volta Redonda',), ('Novo Hamburgo',), ('Caucaia',), ('Santa Maria',), ('Cascavel',), ('Guarujá',), ('Ribeirão das Neves',), ('Governador Valadares',), ('Taubaté',), ('Imperatriz',), ('Gravataí',), ('Embu',), ('Mossoró',), ('Várzea Grande',), ('Petrolina',), ('Barueri',), ('Viamão',), ('Ipatinga',), ('Juazeiro',), ('Juazeiro do Norte',), ('Taboão da Serra',), ('São José dos Pinhais',), ('Magé',), ('Suzano',), ('São Leopoldo',), ('Marília',), ('São Carlos',), ('Sumaré',), ('Presidente Prudente',), ('Divinópolis',), ('Sete Lagoas',), ('Rio Grande',), ('Itabuna',), ('Jequié',), ('Arapiraca',), ('Colombo',), ('Americana',), ('Alvorada',), ('Araraquara',), ('Itaboraí',), ('Santa Bárbara d´Oeste',), ('Nova Friburgo',), ('Jacareí',), ('Araçatuba',), ('Barra Mansa',), ('Praia Grande',), ('Marabá',), ('Criciúma',), ('Boa Vista',), ('Passo Fundo',), ('Dourados',), ('Santa Luzia',), ('Rio Claro',), ('Maracanaú',), ('Guarapuava',), ('Glasgow',), ('Liverpool',), ('Edinburgh',), ('Sheffield',), ('Manchester',), ('Leeds',), ('Bristol',), ('Cardiff',), ('Coventry',), ('Leicester',), ('Bradford',), ('Belfast',), ('Nottingham',), ('Kingston upon Hull',), ('Plymouth',), ('Stoke-on-Trent',), ('Wolverhampton',), ('Derby',), ('Swansea',), ('Southampton',), ('Aberdeen',), ('Northampton',), ('Dudley',), ('Portsmouth',), ('Newcastle upon Tyne',), ('Sunderland',), ('Luton',), ('Swindon',), ('Southend-on-Sea',), ('Walsall',), ('Bournemouth',), ('Plovdiv',), ('Varna',), ('Burgas',), ('Ruse',), ('Ouagadougou',), ('Bobo-Dioulasso',), ('Bujumbura',), ('Puente Alto',), ('Viña del Mar',), ('Valparaíso',), ('Talcahuano',), ('Antofagasta',), ('San Bernardo',), ('Temuco',), ('Concepción',), ('Rancagua',), ('Arica',), ('Talca',), ('Chillán',), ('Iquique',), ('San José',), ('Djibouti',), ('Santiago de los Caballeros',), ('Cuenca',), ('Machala',), ('Santo Domingo de los Colorados',), ('Portoviejo',), ('Ambato',), ('Manta',), ('Shubra al-Khayma',), ('Port Said',), ('Suez',), ('al-Mahallat al-Kubra',), ('Tanta',), ('al-Mansura',), ('Luxor',), ('Asyut',), ('Bahtim',), ('Zagazig',), ('al-Faiyum',), ('Ismailia',), ('Kafr al-Dawwar',), ('Assuan',), ('Damanhur',), ('al-Minya',), ('Bani Suwayf',), ('Qina',), ('Sawhaj',), ('San Salvador',), ('Asmara',), ('Valencia',), ('Sevilla',), ('Zaragoza',), ('Málaga',), ('Bilbao',), ('Las Palmas de Gran Canaria',), ('Murcia',), ('Palma de Mallorca',), ('Valladolid',), ('Córdoba',), ('Vigo',), ('Alicante [Alacant]',), ('Gijón',), ('L´Hospitalet de Llobregat',), ('Granada',), ('A Coruña (La Coruña)',), ('Vitoria-Gasteiz',), ('Santa Cruz de Tenerife',), ('Badalona',), ('Oviedo',), ('Móstoles',), ('Elche [Elx]',), ('Sabadell',), ('Santander',), ('Jerez de la Frontera',), ('Pamplona [Iruña]',), ('Donostia-San Sebastián',), ('Cartagena',), ('Leganés',), ('Fuenlabrada',), ('Almería',), ('Terrassa',), ('Alcalá de Henares',), ('Burgos',), ('Johannesburg',), ('Port Elizabeth',), ('Pretoria',), ('Inanda',), ('Durban',), ('Vanderbijlpark',), ('Kempton Park',), ('Alberton',), ('Pinetown',), ('Pietermaritzburg',), ('Benoni',), ('Randburg',), ('Umlazi',), ('Bloemfontein',), ('Vereeniging',), ('Wonderboom',), ('Roodepoort',), ('Boksburg',), ('Klerksdorp',), ('Soshanguve',), ('Newcastle',), ('East London',), ('Welkom',), ('Kimberley',), ('Uitenhage',), ('Chatsworth',), ('Mdantsane',), ('Krugersdorp',), ('Botshabelo',), ('Brakpan',), ('Witbank',), ('Oberholzer',), ('Germiston',), ('Springs',), ('Dire Dawa',), ('Cebu',), ('Zamboanga',), ('Pasig',), ('Valenzuela',), ('Las Piñas',), ('Antipolo',), ('Taguig',), ('Cagayan de Oro',), ('Parañaque',), ('Makati',), ('Bacolod',), ('General Santos',), ('Marikina',), ('Dasmariñas',), ('Muntinlupa',), ('Iloilo',), ('Pasay',), ('Malabon',), ('San José del Monte',), ('Bacoor',), ('Iligan',), ('Calamba',), ('Mandaluyong',), ('Butuan',), ('Angeles',), ('Tarlac',), ('Mandaue',), ('Baguio',), ('Batangas',), ('Cainta',), ('San Pedro',), ('Navotas',), ('Cabanatuan',), ('San Fernando',), ('Lipa',), ('Lapu-Lapu',), ('San Pablo',), ('Biñan',), ('Taytay',), ('Lucena',), ('Imus',), ('Olongapo',), ('Binangonan',), ('Santa Rosa',), ('Tagum',), ('Tacloban',), ('Malolos',), ('Mabalacat',), ('Cotabato',), ('Meycauayan',), ('Puerto Princesa',), ('Libreville',), ('Kutaisi',), ('Kumasi',), ('Ciudad de Guatemala',), ('Mixco',), ('Bissau',), ('Georgetown',), ('Port-au-Prince',), ('Carrefour',), ('Delmas',), ('Tegucigalpa',), ('San Pedro Sula',), ('Malang',), ('Bandar Lampung',), ('Bekasi',), ('Padang',), ('Surakarta',), ('Banjarmasin',), ('Pekan Baru',), ('Denpasar',), ('Yogyakarta',), ('Pontianak',), ('Samarinda',), ('Jambi',), ('Depok',), ('Cimahi',), ('Balikpapan',), ('Manado',), ('Mataram',), ('Pekalongan',), ('Tegal',), ('Bogor',), ('Ciputat',), ('Pondokgede',), ('Cirebon',), ('Kediri',), ('Ambon',), ('Jember',), ('Cilacap',), ('Cimanggis',), ('Pematang Siantar',), ('Purwokerto',), ('Ciomas',), ('Tasikmalaya',), ('Madiun',), ('Srinagar',), ('Agra',), ('Coimbatore',), ('Thane (Thana)',), ('Allahabad',), ('Meerut',), ('Vishakhapatnam',), ('Jabalpur',), ('Amritsar',), ('Faridabad',), ('Vijayawada',), ('Gwalior',), ('Jodhpur',), ('Nashik (Nasik)',), ('Hubli-Dharwad',), ('Solapur (Sholapur)',), ('Ranchi',), ('Bareilly',), ('Guwahati (Gauhati)',), ('Shambajinagar (Aurangabad)',), ('Cochin (Kochi)',), ('Rajkot',), ('Kota',), ('Thiruvananthapuram (Trivandrum',), ('Pimpri-Chinchwad',), ('Jalandhar (Jullundur)',), ('Gorakhpur',), ('Chandigarh',), ('Mysore',), ('Aligarh',), ('Guntur',), ('Jamshedpur',), ('Ghaziabad',), ('Warangal',), ('Raipur',), ('Moradabad',), ('Durgapur',), ('Amravati',), ('Calicut (Kozhikode)',), ('Bikaner',), ('Bhubaneswar',), ('Kolhapur',), ('Kataka (Cuttack)',), ('Ajmer',), ('Bhavnagar',), ('Tiruchirapalli',), ('Bhilai',), ('Bhiwandi',), ('Saharanpur',), ('Ulhasnagar',), ('Salem',), ('Ujjain',), ('Malegaon',), ('Jamnagar',), ('Bokaro Steel City',), ('Akola',), ('Belgaum',), ('Rajahmundry',), ('Nellore',), ('Udaipur',), ('New Bombay',), ('Bhatpara',), ('Gulbarga',), ('New Delhi',), ('Jhansi',), ('Gaya',), ('Kakinada',), ('Dhule (Dhulia)',), ('Panihati',), ('Nanded (Nander)',), ('Mangalore',), ('Dehra Dun',), ('Kamarhati',), ('Davangere',), ('Asansol',), ('Bhagalpur',), ('Bellary',), ('Barddhaman (Burdwan)',), ('Rampur',), ('Jalgaon',), ('Muzaffarpur',), ('Nizamabad',), ('Muzaffarnagar',), ('Patiala',), ('Shahjahanpur',), ('Kurnool',), ('Tiruppur (Tirupper)',), ('Rohtak',), ('South Dum Dum',), ('Mathura',), ('Chandrapur',), ('Barahanagar (Baranagar)',), ('Darbhanga',), ('Siliguri (Shiliguri)',), ('Raurkela',), ('Ambattur',), ('Panipat',), ('Firozabad',), ('Ichalkaranji',), ('Jammu',), ('Ramagundam',), ('Eluru',), ('Brahmapur',), ('Alwar',), ('Pondicherry',), ('Thanjavur',), ('Bihar Sharif',), ('Tuticorin',), ('Imphal',), ('Latur',), ('Sagar',), ('Farrukhabad-cum-Fatehgarh',), ('Sangli',), ('Parbhani',), ('Nagar Coil',), ('Bijapur',), ('Kukatpalle',), ('Bally',), ('Bhilwara',), ('Ratlam',), ('Avadi',), ('Dindigul',), ('Ahmadnagar',), ('Bilaspur',), ('Shimoga',), ('Kharagpur',), ('Mira Bhayandar',), ('Vellore',), ('Jalna',), ('Burnpur',), ('Anantapur',), ('Allappuzha (Alleppey)',), ('Tirupati',), ('Karnal',), ('Burhanpur',), ('Hisar (Hissar)',), ('Tiruvottiyur',), ('Mirzapur-cum-Vindhyachal',), ('Secunderabad',), ('Nadiad',), ('Dewas',), ('Murwara (Katni)',), ('Ganganagar',), ('Vizianagaram',), ('Mosul',), ('Irbil',), ('Kirkuk',), ('Basra',), ('al-Sulaymaniya',), ('al-Najaf',), ('Karbala',), ('al-Hilla',), ('al-Nasiriya',), ('al-Amara',), ('al-Diwaniya',), ('al-Ramadi',), ('al-Kut',), ('Ahvaz',), ('Qom',), ('Kermanshah',), ('Urmia',), ('Zahedan',), ('Rasht',), ('Hamadan',), ('Kerman',), ('Arak',), ('Ardebil',), ('Yazd',), ('Qazvin',), ('Zanjan',), ('Sanandaj',), ('Bandar-e-Abbas',), ('Khorramabad',), ('Eslamshahr',), ('Borujerd',), ('Abadan',), ('Dezful',), ('Kashan',), ('Sari',), ('Gorgan',), ('Najafabad',), ('Sabzevar',), ('Khomeynishahr',), ('Dublin',), ('Jerusalem',), ('Tel Aviv-Jaffa',), ('Haifa',), ('Rishon Le Ziyyon',), ('Beerseba',), ('Holon',), ('Palermo',), ('Genova',), ('Bologna',), ('Firenze',), ('Catania',), ('Bari',), ('Venezia',), ('Messina',), ('Verona',), ('Trieste',), ('Padova',), ('Taranto',), ('Brescia',), ('Reggio di Calabria',), ('Modena',), ('Prato',), ('Parma',), ('Cagliari',), ('Livorno',), ('Graz',), ('Linz',), ('Chiba',), ('Sakai',), ('Kumamoto',), ('Okayama',), ('Sagamihara',), ('Hamamatsu',), ('Kagoshima',), ('Funabashi',), ('Higashiosaka',), ('Hachioji',), ('Niigata',), ('Amagasaki',), ('Himeji',), ('Shizuoka',), ('Urawa',), ('Matsuyama',), ('Matsudo',), ('Kanazawa',), ('Kawaguchi',), ('Ichikawa',), ('Omiya',), ('Utsunomiya',), ('Oita',), ('Nagasaki',), ('Yokosuka',), ('Kurashiki',), ('Gifu',), ('Hirakata',), ('Nishinomiya',), ('Toyonaka',), ('Wakayama',), ('Fukuyama',), ('Fujisawa',), ('Asahikawa',), ('Machida',), ('Nara',), ('Takatsuki',), ('Iwaki',), ('Nagano',), ('Toyohashi',), ('Toyota',), ('Suita',), ('Takamatsu',), ('Koriyama',), ('Okazaki',), ('Kawagoe',), ('Tokorozawa',), ('Toyama',), ('Kochi',), ('Kashiwa',), ('Akita',), ('Miyazaki',), ('Koshigaya',), ('Naha',), ('Aomori',), ('Hakodate',), ('Akashi',), ('Yokkaichi',), ('Fukushima',), ('Morioka',), ('Maebashi',), ('Kasugai',), ('Otsu',), ('Ichihara',), ('Yao',), ('Ichinomiya',), ('Tokushima',), ('Kakogawa',), ('Ibaraki',), ('Neyagawa',), ('Shimonoseki',), ('Yamagata',), ('Fukui',), ('Hiratsuka',), ('Mito',), ('Sasebo',), ('Hachinohe',), ('Takasaki',), ('Shimizu',), ('Kurume',), ('Fuji',), ('Soka',), ('Fuchu',), ('Chigasaki',), ('Atsugi',), ('Numazu',), ('Ageo',), ('Yamato',), ('Matsumoto',), ('Kure',), ('Takarazuka',), ('Kasukabe',), ('Chofu',), ('Odawara',), ('Kofu',), ('Kushiro',), ('Kishiwada',), ('Hitachi',), ('Nagaoka',), ('Itami',), ('Uji',), ('Suzuka',), ('Hirosaki',), ('Ube',), ('Kodaira',), ('Takaoka',), ('Obihiro',), ('Tomakomai',), ('Saga',), ('Sakura',), ('Kamakura',), ('Mitaka',), ('Izumi',), ('Hino',), ('Hadano',), ('Ashikaga',), ('Tsu',), ('Sayama',), ('Yachiyo',), ('Tsukuba',), ('Sanaa',), ('Aden',), ('Taizz',), ('Hodeida',), ('al-Zarqa',), ('Irbid',), ('Novi Sad',), ('Niš',), ('Phnom Penh',), ('Garoua',), ('Calgary',), ('Toronto',), ('North York',), ('Winnipeg',), ('Edmonton',), ('Mississauga',), ('Scarborough',), ('Vancouver',), ('Etobicoke',), ('London',), ('Hamilton',), ('Ottawa',), ('Laval',), ('Surrey',), ('Brampton',), ('Windsor',), ('Saskatoon',), ('Kitchener',), ('Markham',), ('Regina',), ('Burnaby',), ('Québec',), ('Qaraghandy',), ('Shymkent',), ('Taraz',), ('Astana',), ('Öskemen',), ('Pavlodar',), ('Semey',), ('Aqtöbe',), ('Qostanay',), ('Petropavl',), ('Oral',), ('Temirtau',), ('Mombasa',), ('Kisumu',), ('Nakuru',), ('Bangui',), ('Handan',), ('Wuxi',), ('Xuzhou',), ('Datong',), ('Yichun',), ('Benxi',), ('Luoyang',), ('Suzhou',), ('Xining',), ('Huainan',), ('Jixi',), ('Daqing',), ('Fuxin',), ('Amoy [Xiamen]',), ('Liuzhou',), ('Shantou',), ('Jinzhou',), ('Mudanjiang',), ('Yinchuan',), ('Changzhou',), ('Zhangjiakou',), ('Dandong',), ('Hegang',), ('Kaifeng',), ('Jiamusi',), ('Liaoyang',), ('Hengyang',), ('Baoding',), ('Hunjiang',), ('Xinxiang',), ('Huangshi',), ('Haikou',), ('Yantai',), ('Bengbu',), ('Xiangtan',), ('Weifang',), ('Wuhu',), ('Pingxiang',), ('Yingkou',), ('Anyang',), ('Panzhihua',), ('Pingdingshan',), ('Xiangfan',), ('Zhuzhou',), ('Jiaozuo',), ('Wenzhou',), ('Zhangjiang',), ('Zigong',), ('Shuangyashan',), ('Zaozhuang',), ('Yakeshi',), ('Yichang',), ('Zhenjiang',), ('Huaibei',), ('Qinhuangdao',), ('Guilin',), ('Liupanshui',), ('Panjin',), ('Yangquan',), ('Jinxi',), ('Liaoyuan',), ('Lianyungang',), ('Xianyang',), ('Tai´an',), ('Chifeng',), ('Shaoguan',), ('Nantong',), ('Leshan',), ('Baoji',), ('Linyi',), ('Tonghua',), ('Siping',), ('Changzhi',), ('Tengzhou',), ('Chaozhou',), ('Yangzhou',), ('Dongwan',), ('Ma´anshan',), ('Foshan',), ('Yueyang',), ('Xingtai',), ('Changde',), ('Shihezi',), ('Yancheng',), ('Jiujiang',), ('Dongying',), ('Shashi',), ('Xintai',), ('Jingdezhen',), ('Tongchuan',), ('Zhongshan',), ('Shiyan',), ('Tieli',), ('Jining',), ('Wuhai',), ('Mianyang',), ('Luzhou',), ('Zunyi',), ('Shizuishan',), ('Neijiang',), ('Tongliao',), ('Tieling',), ('Wafangdian',), ('Anqing',), ('Shaoyang',), ('Laiwu',), ('Chengde',), ('Tianshui',), ('Nanyang',), ('Cangzhou',), ('Yibin',), ('Huaiyin',), ('Dunhua',), ('Yanji',), ('Jiangmen',), ('Tongling',), ('Suihua',), ('Gongziling',), ('Xiantao',), ('Chaoyang',), ('Ganzhou',), ('Huzhou',), ('Baicheng',), ('Shangzi',), ('Yangjiang',), ('Qitaihe',), ('Gejiu',), ('Jiangyin',), ('Hebi',), ('Jiaxing',), ('Wuzhou',), ('Meihekou',), ('Xuchang',), ('Liaocheng',), ('Haicheng',), ('Qianjiang',), ('Baiyin',), ('Bei´an',), ('Yixing',), ('Laizhou',), ('Qaramay',), ('Acheng',), ('Dezhou',), ('Nanping',), ('Zhaoqing',), ('Beipiao',), ('Fengcheng',), ('Fuyu',), ('Xinyang',), ('Dongtai',), ('Yuci',), ('Honghu',), ('Ezhou',), ('Heze',), ('Daxian',), ('Linfen',), ('Tianmen',), ('Yiyang',), ('Quanzhou',), ('Rizhao',), ('Deyang',), ('Guangyuan',), ('Changshu',), ('Zhangzhou',), ('Hailar',), ('Nanchong',), ('Jiutai',), ('Zhaodong',), ('Shaoxing',), ('Fuyang',), ('Maoming',), ('Qujing',), ('Ghulja',), ('Jiaohe',), ('Puyang',), ('Huadian',), ('Jiangyou',), ('Qashqar',), ('Anshun',), ('Fuling',), ('Xinyu',), ('Hanzhong',), ('Danyang',), ('Chenzhou',), ('Xiaogan',), ('Shangqiu',), ('Zhuhai',), ('Qingyuan',), ('Aqsu',), ('Jining',), ('Xiaoshan',), ('Zaoyang',), ('Xinghua',), ('Hami',), ('Huizhou',), ('Jinmen',), ('Sanming',), ('Bishkek',), ('Osh',), ('Cartagena',), ('Cúcuta',), ('Bucaramanga',), ('Ibagué',), ('Pereira',), ('Santa Marta',), ('Manizales',), ('Bello',), ('Pasto',), ('Neiva',), ('Soledad',), ('Armenia',), ('Villavicencio',), ('Soacha',), ('Valledupar',), ('Montería',), ('Itagüí',), ('Palmira',), ('Buenaventura',), ('Floridablanca',), ('Sincelejo',), ('Popayán',), ('Barrancabermeja',), ('Pointe-Noire',), ('Lubumbashi',), ('Mbuji-Mayi',), ('Kolwezi',), ('Kisangani',), ('Kananga',), ('Likasi',), ('Bukavu',), ('Kikwit',), ('Tshikapa',), ('Matadi',), ('Mbandaka',), ('Hamhung',), ('Chongjin',), ('Nampo',), ('Sinuiju',), ('Wonsan',), ('Phyongsong',), ('Sariwon',), ('Haeju',), ('Kanggye',), ('Kimchaek',), ('Hyesan',), ('Kaesong',), ('Songnam',), ('Puchon',), ('Suwon',), ('Anyang',), ('Chonju',), ('Chongju',), ('Koyang',), ('Ansan',), ('Pohang',), ('Chang-won',), ('Masan',), ('Kwangmyong',), ('Chonan',), ('Chinju',), ('Iksan',), ('Pyongtaek',), ('Kumi',), ('Uijongbu',), ('Kyongju',), ('Kunsan',), ('Cheju',), ('Kimhae',), ('Sunchon',), ('Mokpo',), ('Yong-in',), ('Wonju',), ('Kunpo',), ('Chunchon',), ('Namyangju',), ('Kangnung',), ('Chungju',), ('Andong',), ('Yosu',), ('Kyongsan',), ('Paju',), ('Yangsan',), ('Athenai',), ('Thessaloniki',), ('Pireus',), ('Zagreb',), ('Split',), ('Rijeka',), ('Santiago de Cuba',), ('Camagüey',), ('Holguín',), ('Santa Clara',), ('Guantánamo',), ('Nicosia',), ('Vientiane',), ('Riga',), ('Maseru',), ('Tripoli',), ('Monrovia',), ('Bengasi',), ('Vilnius',), ('Kaunas',), ('Klaipeda',), ('El-Aaiún',), ('Macao',), ('Antananarivo',), ('Skopje',), ('Blantyre',), ('Lilongwe',), ('Ipoh',), ('Johor Baharu',), ('Petaling Jaya',), ('Kelang',), ('Kuala Terengganu',), ('Pinang',), ('Kota Bharu',), ('Kuantan',), ('Taiping',), ('Seremban',), ('Bamako',), ('Rabat',), ('Marrakech',), ('Fès',), ('Tanger',), ('Salé',), ('Meknès',), ('Oujda',), ('Kénitra',), ('Tétouan',), ('Safi',), ('Nouakchott',), ('Naucalpan de Juárez',), ('Mexicali',), ('Culiacán',), ('Acapulco de Juárez',), ('Tlalnepantla de Baz',), ('Mérida',), ('Chihuahua',), ('San Luis Potosí',), ('Guadalupe',), ('Toluca',), ('Aguascalientes',), ('Querétaro',), ('Morelia',), ('Hermosillo',), ('Saltillo',), ('Torreón',), ('Centro (Villahermosa)',), ('San Nicolás de los Garza',), ('Durango',), ('Chimalhuacán',), ('Tlaquepaque',), ('Atizapán de Zaragoza',), ('Veracruz',), ('Cuautitlán Izcalli',), ('Irapuato',), ('Tuxtla Gutiérrez',), ('Tultitlán',), ('Reynosa',), ('Benito Juárez',), ('Matamoros',), ('Xalapa',), ('Celaya',), ('Mazatlán',), ('Ensenada',), ('Ahome',), ('Cajeme',), ('Cuernavaca',), ('Tonalá',), ('Valle de Chalco Solidaridad',), ('Nuevo Laredo',), ('Tepic',), ('Tampico',), ('Ixtapaluca',), ('Apodaca',), ('Guasave',), ('Gómez Palacio',), ('Tapachula',), ('Nicolás Romero',), ('Coatzacoalcos',), ('Uruapan',), ('Victoria',), ('Oaxaca de Juárez',), ('Coacalco de Berriozábal',), ('Pachuca de Soto',), ('General Escobedo',), ('Salamanca',), ('Santa Catarina',), ('Tehuacán',), ('Chalco',), ('Cárdenas',), ('Campeche',), ('La Paz',), ('Othón P. Blanco (Chetumal)',), ('Texcoco',), ('La Paz',), ('Metepec',), ('Monclova',), ('Huixquilucan',), ('Chilpancingo de los Bravo',), ('Puerto Vallarta',), ('Fresnillo',), ('Ciudad Madero',), ('Soledad de Graciano Sánchez',), ('San Juan del Río',), ('San Felipe del Progreso',), ('Córdoba',), ('Tecámac',), ('Ocosingo',), ('Carmen',), ('Lázaro Cárdenas',), ('Jiutepec',), ('Papantla',), ('Comalcalco',), ('Zamora',), ('Chisinau',), ('Tiraspol',), ('Ulan Bator',), ('Matola',), ('Beira',), ('Nampula',), ('Chimoio',), ('Mandalay',), ('Moulmein (Mawlamyine)',), ('Pegu (Bago)',), ('Bassein (Pathein)',), ('Windhoek',), ('Kathmandu',), ('Niamey',), ('Ogbomosho',), ('Kano',), ('Oshogbo',), ('Ilorin',), ('Abeokuta',), ('Port Harcourt',), ('Zaria',), ('Ilesha',), ('Onitsha',), ('Iwo',), ('Ado-Ekiti',), ('Abuja',), ('Kaduna',), ('Mushin',), ('Maiduguri',), ('Enugu',), ('Ede',), ('Aba',), ('Ife',), ('Ila',), ('Oyo',), ('Ikerre',), ('Benin City',), ('Iseyin',), ('Katsina',), ('Jos',), ('Sokoto',), ('Ilobu',), ('Offa',), ('Ikorodu',), ('Ilawe-Ekiti',), ('Owo',), ('Ikirun',), ('Shaki',), ('Calabar',), ('Ondo',), ('Akure',), ('Oslo',), ('Bergen',), ('Bouaké',), ('Quetta',), ('Islamabad',), ('Sargodha',), ('Sialkot',), ('Bahawalpur',), ('Sukkur',), ('Jhang',), ('Sheikhupura',), ('Larkana',), ('Gujrat',), ('Mardan',), ('Kasur',), ('Rahim Yar Khan',), ('Sahiwal',), ('Okara',), ('Wah',), ('Dera Ghazi Khan',), ('Mirpur Khas',), ('Nawabshah',), ('Mingora',), ('Chiniot',), ('Ciudad de Panamá',), ('San Miguelito',), ('Port Moresby',), ('Asunción',), ('Arequipa',), ('Trujillo',), ('Chiclayo',), ('Callao',), ('Iquitos',), ('Chimbote',), ('Huancayo',), ('Piura',), ('Cusco',), ('Pucallpa',), ('Tacna',), ('Ica',), ('Lisboa',), ('Porto',), ('San Juan',), ('Bayamón',), ('Ponce',), ('Carolina',), ('Lódz',), ('Kraków',), ('Wroclaw',), ('Poznan',), ('Gdansk',), ('Szczecin',), ('Bydgoszcz',), ('Lublin',), ('Katowice',), ('Bialystok',), ('Czestochowa',), ('Gdynia',), ('Sosnowiec',), ('Radom',), ('Kielce',), ('Gliwice',), ('Torun',), ('Bytom',), ('Zabrze',), ('Bielsko-Biala',), ('Olsztyn',), ('Rzeszów',), ('Doha',), ('Marseille',), ('Lyon',), ('Toulouse',), ('Nice',), ('Nantes',), ('Strasbourg',), ('Montpellier',), ('Bordeaux',), ('Rennes',), ('Le Havre',), ('Reims',), ('Lille',), ('St-Étienne',), ('Toulon',), ('Iasi',), ('Constanta',), ('Cluj-Napoca',), ('Galati',), ('Timisoara',), ('Brasov',), ('Craiova',), ('Ploiesti',), ('Braila',), ('Oradea',), ('Bacau',), ('Pitesti',), ('Arad',), ('Sibiu',), ('Târgu Mures',), ('Kigali',), ('Stockholm',), ('Gothenburg [Göteborg]',), ('Malmö',), ('Uppsala',), ('Frankfurt am Main',), ('Essen',), ('Dortmund',), ('Stuttgart',), ('Düsseldorf',), ('Bremen',), ('Duisburg',), ('Hannover',), ('Leipzig',), ('Nürnberg',), ('Dresden',), ('Bochum',), ('Wuppertal',), ('Bielefeld',), ('Mannheim',), ('Bonn',), ('Gelsenkirchen',), ('Karlsruhe',), ('Wiesbaden',), ('Münster',), ('Mönchengladbach',), ('Chemnitz',), ('Augsburg',), ('Halle/Saale',), ('Braunschweig',), ('Aachen',), ('Krefeld',), ('Magdeburg',), ('Kiel',), ('Oberhausen',), ('Lübeck',), ('Hagen',), ('Rostock',), ('Freiburg im Breisgau',), ('Erfurt',), ('Kassel',), ('Saarbrücken',), ('Mainz',), ('Hamm',), ('Herne',), ('Mülheim an der Ruhr',), ('Solingen',), ('Osnabrück',), ('Ludwigshafen am Rhein',), ('Leverkusen',), ('Ndola',), ('Kitwe',), ('Medina',), ('al-Dammam',), ('al-Taif',), ('Tabuk',), ('Burayda',), ('al-Hufuf',), ('al-Mubarraz',), ('Khamis Mushayt',), ('Hail',), ('Pikine',), ('Dakar',), ('Thiès',), ('Kaolack',), ('Ziguinchor',), ('Freetown',), ('Bratislava',), ('Košice',), ('Ljubljana',), ('Colombo',), ('Dehiwala',), ('Moratuwa',), ('Sharq al-Nil',), ('Port Sudan',), ('Kassala',), ('Obeid',), ('Nyala',), ('Wad Madani',), ('al-Qadarif',), ('Kusti',), ('Helsinki [Helsingfors]',), ('Espoo',), ('Tampere',), ('Vantaa',), ('Turku [Åbo]',), ('Zürich',), ('Geneve',), ('Basel',), ('Hims',), ('Hama',), ('Latakia',), ('Dushanbe',), ('Khujand',), ('Tainan',), ('Panchiao',), ('Chungho',), ('Keelung (Chilung)',), ('Sanchung',), ('Hsinchuang',), ('Hsinchu',), ('Chungli',), ('Fengshan',), ('Taoyuan',), ('Chiayi',), ('Hsintien',), ('Changhwa',), ('Yungho',), ('Tucheng',), ('Pingtung',), ('Yungkang',), ('Pingchen',), ('Tali',), ('Taiping',), ('Pate',), ('Fengyuan',), ('Luchou',), ('Dodoma',), ('Mwanza',), ('København',), ('Århus',), ('Odense',), ('Aalborg',), ('Nonthaburi',), ('Nakhon Ratchasima',), ('Chiang Mai',), ('Lomé',), ('N´Djaména',), ('Brno',), ('Ostrava',), ('Plzen',), ('Tunis',), ('Sfax',), ('Ariana',), ('Ettadhamen',), ('Gaziantep',), ('Konya',), ('Mersin (Içel)',), ('Antalya',), ('Diyarbakir',), ('Kayseri',), ('Eskisehir',), ('Sanliurfa',), ('Samsun',), ('Malatya',), ('Gebze',), ('Denizli',), ('Sivas',), ('Erzurum',), ('Tarsus',), ('Kahramanmaras',), ('Elâzig',), ('Van',), ('Sultanbeyli',), ('Izmit (Kocaeli)',), ('Manisa',), ('Batman',), ('Balikesir',), ('Sakarya (Adapazari)',), ('Ashgabat',), ('Chärjew',), ('Kampala',), ('Zaporizzja',), ('Lviv',), ('Kryvyi Rig',), ('Mykolajiv',), ('Mariupol',), ('Lugansk',), ('Vinnytsja',), ('Makijivka',), ('Herson',), ('Sevastopol',), ('Simferopol',), ('Pultava [Poltava]',), ('Tšernigiv',), ('Tšerkasy',), ('Gorlivka',), ('Zytomyr',), ('Sumy',), ('Dniprodzerzynsk',), ('Kirovograd',), ('Hmelnytskyi',), ('Tšernivtsi',), ('Rivne',), ('Krementšuk',), ('Ivano-Frankivsk',), ('Ternopil',), ('Lutsk',), ('Bila Tserkva',), ('Kramatorsk',), ('Melitopol',), ('Kertš',), ('Debrecen',), ('Miskolc',), ('Auckland',), ('Christchurch',), ('Manukau',), ('North Shore',), ('Waitakere',), ('Wellington',), ('Namangan',), ('Samarkand',), ('Andijon',), ('Buhoro',), ('Karsi',), ('Nukus',), ('Kükon',), ('Fargona',), ('Gomel',), ('Mogiljov',), ('Vitebsk',), ('Grodno',), ('Brest',), ('Bobruisk',), ('Baranovitši',), ('Barquisimeto',), ('Valencia',), ('Ciudad Guayana',), ('Petare',), ('Maracay',), ('Barcelona',), ('Maturín',), ('San Cristóbal',), ('Ciudad Bolívar',), ('Cumaná',), ('Mérida',), ('Cabimas',), ('Barinas',), ('Turmero',), ('Baruta',), ('Puerto Cabello',), ('Santa Ana de Coro',), ('Los Teques',), ('Punto Fijo',), ('Guarenas',), ('Krasnojarsk',), ('Saratov',), ('Toljatti',), ('Uljanovsk',), ('Izevsk',), ('Krasnodar',), ('Jaroslavl',), ('Habarovsk',), ('Vladivostok',), ('Irkutsk',), ('Barnaul',), ('Novokuznetsk',), ('Penza',), ('Rjazan',), ('Orenburg',), ('Lipetsk',), ('Nabereznyje Tšelny',), ('Tula',), ('Tjumen',), ('Kemerovo',), ('Astrahan',), ('Tomsk',), ('Kirov',), ('Ivanovo',), ('Tšeboksary',), ('Brjansk',), ('Tver',), ('Kursk',), ('Magnitogorsk',), ('Kaliningrad',), ('Nizni Tagil',), ('Murmansk',), ('Ulan-Ude',), ('Kurgan',), ('Arkangeli',), ('Sotši',), ('Smolensk',), ('Orjol',), ('Stavropol',), ('Belgorod',), ('Kaluga',), ('Vladimir',), ('Mahatškala',), ('Tšerepovets',), ('Saransk',), ('Tambov',), ('Vladikavkaz',), ('Tšita',), ('Vologda',), ('Veliki Novgorod',), ('Komsomolsk-na-Amure',), ('Kostroma',), ('Volzski',), ('Taganrog',), ('Petroskoi',), ('Bratsk',), ('Dzerzinsk',), ('Surgut',), ('Orsk',), ('Sterlitamak',), ('Angarsk',), ('Joškar-Ola',), ('Rybinsk',), ('Prokopjevsk',), ('Niznevartovsk',), ('Naltšik',), ('Syktyvkar',), ('Severodvinsk',), ('Bijsk',), ('Niznekamsk',), ('Blagoveštšensk',), ('Šahty',), ('Staryi Oskol',), ('Zelenograd',), ('Balakovo',), ('Novorossijsk',), ('Pihkova',), ('Zlatoust',), ('Jakutsk',), ('Podolsk',), ('Petropavlovsk-Kamtšatski',), ('Kamensk-Uralski',), ('Engels',), ('Syzran',), ('Grozny',), ('Novotšerkassk',), ('Berezniki',), ('Juzno-Sahalinsk',), ('Volgodonsk',), ('Abakan',), ('Maikop',), ('Miass',), ('Armavir',), ('Ljubertsy',), ('Rubtsovsk',), ('Haiphong',), ('Da Nang',), ('Biên Hoa',), ('Nha Trang',), ('Hue',), ('Can Tho',), ('Cam Pha',), ('Nam Dinh',), ('Quy Nhon',), ('Tallinn',), ('San Jose',), ('Indianapolis',), ('San Francisco',), ('Jacksonville',), ('Columbus',), ('Austin',), ('Baltimore',), ('Memphis',), ('Milwaukee',), ('Boston',), ('Washington',), ('Nashville-Davidson',), ('El Paso',), ('Seattle',), ('Denver',), ('Charlotte',), ('Fort Worth',), ('Portland',), ('Oklahoma City',), ('Tucson',), ('New Orleans',), ('Las Vegas',), ('Cleveland',), ('Long Beach',), ('Albuquerque',), ('Kansas City',), ('Fresno',), ('Virginia Beach',), ('Atlanta',), ('Sacramento',), ('Oakland',), ('Mesa',), ('Tulsa',), ('Omaha',), ('Minneapolis',), ('Honolulu',), ('Miami',), ('Colorado Springs',), ('Saint Louis',), ('Wichita',), ('Santa Ana',), ('Pittsburgh',), ('Arlington',), ('Cincinnati',), ('Anaheim',), ('Toledo',), ('Tampa',), ('Buffalo',), ('Saint Paul',), ('Corpus Christi',), ('Aurora',), ('Raleigh',), ('Newark',), ('Lexington-Fayette',), ('Anchorage',), ('Louisville',), ('Riverside',), ('Saint Petersburg',), ('Bakersfield',), ('Stockton',), ('Birmingham',), ('Jersey City',), ('Norfolk',), ('Baton Rouge',), ('Hialeah',), ('Lincoln',), ('Greensboro',), ('Plano',), ('Rochester',), ('Glendale',), ('Akron',), ('Garland',), ('Madison',), ('Fort Wayne',), ('Fremont',), ('Scottsdale',), ('Montgomery',), ('Shreveport',), ('Augusta-Richmond County',), ('Lubbock',), ('Chesapeake',), ('Mobile',), ('Des Moines',), ('Grand Rapids',), ('Richmond',), ('Yonkers',), ('Spokane',), ('Glendale',), ('Tacoma',), ('Irving',), ('Huntington Beach',), ('Modesto',), ('Durham',), ('Columbus',), ('Orlando',), ('Boise City',), ('Winston-Salem',), ('San Bernardino',), ('Jackson',), ('Little Rock',), ('Salt Lake City',), ('Reno',), ('Newport News',), ('Chandler',), ('Laredo',), ('Henderson',), ('Arlington',), ('Knoxville',), ('Amarillo',), ('Providence',), ('Chula Vista',), ('Worcester',), ('Oxnard',), ('Dayton',), ('Garden Grove',), ('Oceanside',), ('Bulawayo',), ('Chitungwiza',), ('Mount Darwin',), ('Gaza',)]",,1.0,
Give the language that is spoken in the most countries.,"[countrylanguage.Language, countrylanguage.CountryCode, country.Code, countrylanguage.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT countrylanguage.Language FROM countrylanguage GROUP BY countrylanguage.Language ORDER BY COUNT(countrylanguage.CountryCode) DESC LIMIT 1;,SELECT LANGUAGE FROM countrylanguage GROUP BY LANGUAGE ORDER BY count(*) DESC LIMIT 1,world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countrylanguage.Language"" that is spoken in the most countries. Use COUNT to count the number of countries where each language is spoken. 2. Condition Structure: No specific filtering condition is required, as we are considering all languages. 3. Join Structure: No JOIN is necessary because the required data is available in the ""countrylanguage"" table. 4. Aggregation Structure: Use COUNT on ""countrylanguage.CountryCode"" to count the number of countries for each language. Use GROUP BY to group the results by ""countrylanguage.Language"" and ORDER BY in descending order of the count. Use LIMIT 1 to get the language spoken in the most countries.","[('English',)]","[('English',)]",,1.0,
"Return the record companies of orchestras, sorted descending by the years in which they were founded.","[orchestra.Record_Company, orchestra.Year_of_Founded]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,"SELECT orchestra.Record_Company, orchestra.Year_of_Founded FROM orchestra ORDER BY orchestra.Year_of_Founded DESC;",SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""orchestra.Record_Company"" and ""orchestra.Year_of_Founded"". 2. Condition Structure: No specific filtering condition is required as we want all record companies and their founding years. 3. Join Structure: No JOIN is required since all necessary information is available in the ""orchestra"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY in descending order on ""orchestra.Year_of_Founded"" to sort the results by the founding years.","[('Columbia Masterworks', 2009.0), ('Philips', 2008.0), ('Philips Classics Records', 2008.0), ('RCA', 2008.0), ('EMI', 2007.0), ('Koch Records / Naxos Records', 2006.0), ('Decca Records', 2004.0), ('Mercury Records', 2003.0), ('Deutsche Grammophon', 2003.0), ('Kultur', 2002.0), ('Decca Records', 2002.0), ('Delos Records', 2002.0)]","[('Columbia Masterworks',), ('Philips',), ('Philips Classics Records',), ('RCA',), ('EMI',), ('Koch Records / Naxos Records',), ('Decca Records',), ('Mercury Records',), ('Deutsche Grammophon',), ('Kultur',), ('Decca Records',), ('Delos Records',)]",,1.0,
Count the number of conductors.,[conductor.Conductor_ID],"Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT COUNT(conductor.Conductor_ID) AS conductor_count FROM conductor;,SELECT count(*) FROM conductor,orchestra,"1. Sequential Structure: Start with the SELECT clause to count the number of conductors. 2. Condition Structure: No specific filtering condition is required as we want to count all conductors. 3. Join Structure: No JOIN is required since the information is available in the ""conductor"" table. 4. Aggregation Structure: Use COUNT on ""conductor.Conductor_ID"" to calculate the total number of conductors.","[(12,)]","[(12,)]",,1.0,
What are the names of the high schoolers and how many friends does each have?,"[Highschooler.name, Highschooler.ID, Friend.student_id = Highschooler.ID, Friend.friend_id]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,"SELECT Highschooler.name, COUNT(Friend.friend_id) AS num_friends FROM Highschooler LEFT JOIN Friend ON Highschooler.ID = Friend.student_id GROUP BY Highschooler.ID;","SELECT T2.name ,  count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of high schoolers (""Highschooler.name"") and the count of their friends. Use COUNT to calculate the number of friends for each high schooler. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use a LEFT JOIN between the ""Highschooler"" table and the ""Friend"" table on ""Highschooler.ID = Friend.student_id"" to associate each high schooler with their friends. A LEFT JOIN ensures that high schoolers with no friends are also included in the result. 4. Aggregation Structure: Use COUNT on ""Friend.friend_id"" to count the number of friends for each high schooler, and GROUP BY ""Highschooler.ID"" to group the results by each high schooler.","[('John', 0), ('Haley', 1), ('Alexis', 2), ('Jordan', 1), ('Austin', 1), ('Tiffany', 1), ('Kris', 2), ('Jessica', 1), ('Jordan', 2), ('Brittany', 0), ('Logan', 1), ('Gabriel', 2), ('Cassandra', 1), ('Andrew', 3), ('Gabriel', 1), ('Kyle', 1)]","[('Haley', 1), ('Alexis', 2), ('Jordan', 1), ('Austin', 1), ('Tiffany', 1), ('Kris', 2), ('Jessica', 1), ('Jordan', 2), ('Logan', 1), ('Gabriel', 2), ('Cassandra', 1), ('Andrew', 3), ('Gabriel', 1), ('Kyle', 1)]",,1.0,
Which African countries have a smaller population than that of any country in Asia?,"[country.Name, country.Continent, country.Population, city.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT Name FROM country WHERE Continent = 'Africa' AND Population < ALL (SELECT Population FROM country WHERE Continent = 'Asia');,"SELECT Name FROM country WHERE Continent  =  ""Africa""  AND population  <  (SELECT min(population) FROM country WHERE Continent  =  ""Asia"")",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of African countries. Use the FROM clause to specify the country table. Apply a WHERE clause to filter for countries in Africa with a population smaller than the population of any country in Asia. 2. Condition Structure: Use the WHERE clause to filter for countries in Africa (Continent = 'Africa') and ensure their population is less than the population of all countries in Asia using a subquery. 3. Join Structure: Not required, as all necessary data is in the country table. 4. Aggregation Structure: Use a subquery in the WHERE clause to find the minimum population of countries in Asia and compare it with the population of African countries.",[],"[('British Indian Ocean Territory',), ('Mayotte',), ('Saint Helena',), ('Sao Tome and Principe',), ('Seychelles',)]","near ""ALL"": syntax error",0.0,
Count the number of different nationalities of conductors.,[conductor.Nationality],"Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT COUNT(DISTINCT conductor.Nationality) AS number_of_nationalities FROM conductor;,SELECT count(DISTINCT Nationality) FROM conductor,orchestra,"1. Sequential Structure: Start with the SELECT clause to count the distinct nationalities of conductors. 2. Condition Structure: No specific filtering condition is required as we are counting all distinct nationalities. 3. Join Structure: No JOIN is required since all necessary information is in the ""conductor"" table. 4. Aggregation Structure: Use COUNT with DISTINCT to count the number of unique nationalities.","[(3,)]","[(3,)]",,1.0,
What is the name of the conductor who has conducted the most orchestras?,"[conductor.Name,orchestra.Conductor_ID,orchestra.Conductor_ID = conductor.Conductor_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NON-NESTED,SELECT conductor.Name FROM orchestra JOIN conductor ON orchestra.Conductor_ID = conductor.Conductor_ID GROUP BY conductor.Conductor_ID ORDER BY COUNT(orchestra.Orchestra_ID) DESC LIMIT 1;,SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID ORDER BY COUNT(*) DESC LIMIT 1,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""conductor.Name"" of the conductor who has conducted the most orchestras. Use COUNT to count the number of orchestras conducted by each conductor. 2. Condition Structure: No specific filtering condition is required, as we are interested in all conductors. 3. Join Structure: Use an INNER JOIN between the ""orchestra"" and ""conductor"" tables on ""orchestra.Conductor_ID = conductor.Conductor_ID"" to associate each orchestra with its conductor. 4. Aggregation Structure: Use COUNT to count the number of orchestras conducted by each conductor, GROUP BY ""conductor.Conductor_ID"" to group the results by conductor, and ORDER BY the count in descending order to find the conductor with the most orchestras. Use LIMIT 1 to select the top result.","[('Michael Tilson Thomas',)]","[('Michael Tilson Thomas',)]",,1.0,
"What are the names of conductors, ordered by age?","[conductor.Name, conductor.Age]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,"SELECT conductor.Name, conductor.Age FROM conductor ORDER BY conductor.Age ASC;",SELECT Name FROM conductor ORDER BY Age ASC,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""conductor.Name"" and ""conductor.Age"" fields. 2. Condition Structure: No specific filtering condition is required as we want all conductors. 3. Join Structure: No JOIN is required since all necessary information is available in the ""conductor"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results by ""conductor.Age"" in ascending order.","[('Antal Doráti', 40), ('Igor Stravinsky', 41), ('Colin Davis', 42), ('Michael Tilson Thomas', 42), ('Paul Jorgensen', 43), ('Antal Brown', 43), ('Charles Dutoit', 43), ('Seiji Ozawa', 43), ('Valeri Gergiev', 47), ('Pierre Boulez', 49), ('Gerard Schwarz', 50), ('Robert Craft', 63)]","[('Antal Doráti',), ('Igor Stravinsky',), ('Colin Davis',), ('Michael Tilson Thomas',), ('Paul Jorgensen',), ('Antal Brown',), ('Charles Dutoit',), ('Seiji Ozawa',), ('Valeri Gergiev',), ('Pierre Boulez',), ('Gerard Schwarz',), ('Robert Craft',)]",,1.0,
What are the Asian countries which have a population larger than that of any country in Africa?,"[country.Name, country.Continent, country.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT Name FROM country WHERE Continent = 'Asia' AND Population > (SELECT MAX(Population) FROM country WHERE Continent = 'Africa');,"SELECT Name FROM country WHERE Continent  =  ""Asia""  AND population  >  (SELECT min(population) FROM country WHERE Continent  =  ""Africa"")",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries. Use the FROM clause to specify the country table. Apply a WHERE clause to filter for countries in Asia with a population larger than the population of any country in Africa. 2. Condition Structure: Use the WHERE clause to filter for countries where the continent is 'Asia' and the population is greater than the maximum population of any country in Africa. Use a subquery to calculate the maximum population of countries in Africa. 3. Join Structure: Not required, as all data is available within the country table. 4. Aggregation Structure: Use a subquery with MAX to find the maximum population of countries in Africa, which is then used in the filtering condition.","[('Bangladesh',), ('China',), ('Indonesia',), ('India',), ('Japan',), ('Pakistan',)]","[('Afghanistan',), ('United Arab Emirates',), ('Armenia',), ('Azerbaijan',), ('Bangladesh',), ('Bahrain',), ('Brunei',), ('Bhutan',), ('China',), ('Cyprus',), ('Georgia',), ('Hong Kong',), ('Indonesia',), ('India',), ('Iran',), ('Iraq',), ('Israel',), ('Jordan',), ('Japan',), ('Kazakstan',), ('Kyrgyzstan',), ('Cambodia',), ('South Korea',), ('Kuwait',), ('Laos',), ('Lebanon',), ('Sri Lanka',), ('Macao',), ('Maldives',), ('Myanmar',), ('Mongolia',), ('Malaysia',), ('Nepal',), ('Oman',), ('Pakistan',), ('Philippines',), ('North Korea',), ('Palestine',), ('Qatar',), ('Saudi Arabia',), ('Singapore',), ('Syria',), ('Thailand',), ('Tajikistan',), ('Turkmenistan',), ('East Timor',), ('Turkey',), ('Taiwan',), ('Uzbekistan',), ('Vietnam',), ('Yemen',)]",,0.0,
Return the average attendance across all shows.,[show.Attendance],"Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT AVG(show.Attendance) AS average_attendance FROM show;,SELECT avg(Attendance) FROM SHOW,orchestra,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average attendance. 2. Aggregation Structure: Use the AVG function to calculate the average attendance across all shows. 3. Condition Structure: No specific filtering condition is required as the query asks for the average attendance across all shows. 4. Join Structure: No JOIN is required since all necessary data is within the ""show"" table.","[(1326.4,)]","[(1326.4,)]",,1.0,
"What are the population, name and leader of the country with the largest area?","[country.Population, country.Name, country.HeadOfState, country.SurfaceArea]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT Population, Name, HeadOfState FROM country WHERE SurfaceArea = (SELECT MAX(SurfaceArea) FROM country);","SELECT Name ,  population ,  HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the population, name, and leader (HeadOfState) of the country. Use the FROM clause to specify the country table. Apply a WHERE clause to filter for the country with the largest surface area. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the country with the maximum surface area. 3. Join Structure: Not required, as all the necessary data is available in the country table. 4. Aggregation Structure: Use the MAX function in a subquery to find the largest surface area, which is then used in the filtering condition.","[(146934000, 'Russian Federation', 'Vladimir Putin')]","[('Russian Federation', 146934000, 'Vladimir Putin')]",,1.0,
Return the names of the 3 countries with the fewest people.,"[country.Name, country.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT country.Name FROM country ORDER BY country.Population ASC LIMIT 3;,SELECT Name FROM country ORDER BY Population ASC LIMIT 3,world_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the country name. Since the question asks for the countries with the fewest people, the population field will also be used for sorting. 2. Condition Structure: No specific filtering condition is required as we are considering all countries. 3. Join Structure: No JOIN is required since all necessary data is within the ""country"" table. 4. Aggregation Structure: Use ORDER BY in ascending order on the ""country.Population"" field to rank countries by population. Use LIMIT 3 to retrieve only the names of the 3 countries with the fewest people.","[('Antarctica',), ('French Southern territories',), ('Bouvet Island',)]","[('Antarctica',), ('French Southern territories',), ('Bouvet Island',)]",,1.0,
Return the codes of countries that do not speak English and do not have Republics for governments.,"[country.Code, country.GovernmentForm, countrylanguage.CountryCode, countrylanguage.Language, city.CountryCode = country.Code, countrylanguage.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT country.Code FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.Language != 'English' AND country.GovernmentForm NOT LIKE '%Republic%';,"SELECT Code FROM country WHERE GovernmentForm != ""Republic"" EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  ""English""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the codes of countries. Use the FROM clause to specify the country table and JOIN it with the countrylanguage table to check the languages spoken in each country. Apply a WHERE clause to filter countries that do not speak English and do not have ""Republic"" in their GovernmentForm. 2. Condition Structure: Use the WHERE clause to filter for countries where the language is not English and the GovernmentForm does not contain ""Republic"". 3. Join Structure: Use an INNER JOIN between the country and countrylanguage tables based on the CountryCode to connect countries with their languages. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.","[('ABW',), ('ABW',), ('ABW',), ('AFG',), ('AFG',), ('AFG',), ('AFG',), ('AFG',), ('AND',), ('AND',), ('AND',), ('AND',), ('ANT',), ('ANT',), ('ARE',), ('ARE',), ('ASM',), ('ASM',), ('ATG',), ('AUS',), ('AUS',), ('AUS',), ('AUS',), ('AUS',), ('AUS',), ('AUS',), ('BEL',), ('BEL',), ('BEL',), ('BEL',), ('BEL',), ('BEL',), ('BHR',), ('BHS',), ('BHS',), ('BLZ',), ('BLZ',), ('BLZ',), ('BRB',), ('BRN',), ('BRN',), ('BRN',), ('BTN',), ('BTN',), ('BTN',), ('CAN',), ('CAN',), ('CAN',), ('CAN',), ('CAN',), ('CAN',), ('CAN',), ('CAN',), ('CAN',), ('CAN',), ('CAN',), ('CCK',), ('CHE',), ('CHE',), ('CHE',), ('CHE',), ('COK',), ('CXR',), ('DNK',), ('DNK',), ('DNK',), ('DNK',), ('DNK',), ('DNK',), ('ESH',), ('ESP',), ('ESP',), ('ESP',), ('ESP',), ('FRO',), ('FRO',), ('GBR',), ('GBR',), ('GIB',), ('GLP',), ('GLP',), ('GRD',), ('GRL',), ('GRL',), ('GUF',), ('GUF',), ('GUM',), ('GUM',), ('GUM',), ('GUM',), ('HKG',), ('HKG',), ('HKG',), ('HKG',), ('JAM',), ('JAM',), ('JOR',), ('JOR',), ('JOR',), ('JPN',), ('JPN',), ('JPN',), ('JPN',), ('JPN',), ('KHM',), ('KHM',), ('KHM',), ('KHM',), ('KNA',), ('KWT',), ('LBY',), ('LBY',), ('LCA',), ('LIE',), ('LIE',), ('LIE',), ('LSO',), ('LSO',), ('LUX',), ('LUX',), ('LUX',), ('LUX',), ('LUX',), ('MAC',), ('MAC',), ('MAC',), ('MAR',), ('MAR',), ('MCO',), ('MCO',), ('MCO',), ('MNP',), ('MNP',), ('MNP',), ('MNP',), ('MNP',), ('MTQ',), ('MTQ',), ('MYS',), ('MYS',), ('MYS',), ('MYS',), ('MYS',), ('MYT',), ('MYT',), ('MYT',), ('NCL',), ('NCL',), ('NCL',), ('NIU',), ('NLD',), ('NLD',), ('NLD',), ('NLD',), ('NOR',), ('NOR',), ('NOR',), ('NOR',), ('NPL',), ('NPL',), ('NPL',), ('NPL',), ('NPL',), ('NPL',), ('NPL',), ('NZL',), ('OMN',), ('OMN',), ('PCN',), ('PNG',), ('PNG',), ('PRI',), ('PSE',), ('PSE',), ('PYF',), ('PYF',), ('PYF',), ('QAT',), ('QAT',), ('REU',), ('REU',), ('REU',), ('REU',), ('REU',), ('SAU',), ('SJM',), ('SJM',), ('SLB',), ('SLB',), ('SLB',), ('SPM',), ('SWE',), ('SWE',), ('SWE',), ('SWE',), ('SWE',), ('SWE',), ('SWZ',), ('SWZ',), ('THA',), ('THA',), ('THA',), ('THA',), ('THA',), ('THA',), ('TKL',), ('TMP',), ('TMP',), ('TON',), ('TUV',), ('TUV',), ('VAT',), ('VCT',), ('VIR',), ('VIR',), ('WLF',), ('WLF',), ('WSM',), ('WSM',)]","[('AFG',), ('AND',), ('ARE',), ('ARG',), ('ATA',), ('ATF',), ('AUT',), ('AZE',), ('BEL',), ('BHS',), ('BIH',), ('BRA',), ('BTN',), ('BVT',), ('CHE',), ('CHN',), ('CUB',), ('DEU',), ('ESH',), ('ESP',), ('FRO',), ('FSM',), ('GLP',), ('GRD',), ('GRL',), ('GUF',), ('HMD',), ('IND',), ('IOT',), ('IRN',), ('JAM',), ('JOR',), ('KHM',), ('LBY',), ('LIE',), ('LUX',), ('MAR',), ('MDG',), ('MEX',), ('MTQ',), ('MYT',), ('NCL',), ('NGA',), ('NLD',), ('NPL',), ('OMN',), ('PCN',), ('PNG',), ('PRK',), ('PSE',), ('PYF',), ('QAT',), ('REU',), ('RUS',), ('SAU',), ('SDN',), ('SGS',), ('SJM',), ('SLB',), ('SPM',), ('SWE',), ('SWZ',), ('THA',), ('TMP',), ('VAT',), ('VEN',), ('VNM',), ('WLF',), ('YUG',)]",,1.0,
Which grades have 4 or more high schoolers?,[Highschooler.grade],"Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,"SELECT Highschooler.grade, COUNT(*) AS highschooler_count FROM Highschooler GROUP BY Highschooler.grade HAVING COUNT(*) >= 4;",SELECT grade FROM Highschooler GROUP BY grade HAVING count(*)  >=  4,network_1,"1. Sequential Structure: Begin with the SELECT clause to specify the grade and the count of high schoolers in each grade. 2. Aggregation Structure: Use COUNT to calculate the number of high schoolers in each grade. 3. Grouping Structure: Use GROUP BY on ""Highschooler.grade"" to group the results by grade. 4. Condition Structure: Apply the HAVING clause to filter for grades that have 4 or more high schoolers. 5. Join Structure: No JOIN is required since all necessary data is within the ""Highschooler"" table.","[(9, 4), (10, 4), (11, 4), (12, 4)]","[(9,), (10,), (11,), (12,)]",,1.0,
Count the number of orchestras that have CD or DVD as their record format.,"[orchestra.Orchestra_ID, orchestra.Major_Record_Format, CD, DVD]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT COUNT(orchestra.Orchestra_ID) FROM orchestra WHERE orchestra.Major_Record_Format = 'CD' OR orchestra.Major_Record_Format = 'DVD';,"SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format  =  ""CD"" OR Major_Record_Format  =  ""DVD""",orchestra,"1. Sequential Structure: Start with the SELECT clause to count the number of orchestras. 2. Condition Structure: Use a WHERE clause to filter orchestras where the ""orchestra.Major_Record_Format"" is either 'CD' or 'DVD'. 3. Join Structure: No JOIN is required since all necessary information is in the ""orchestra"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of orchestras that meet the specified condition.","[(11,)]","[(11,)]",,1.0,
Show the years in which orchestras that have given more than one performance are founded.,"[orchestra.Year_of_Founded,performance.Orchestra_ID,performance.Performance_ID = show.Performance_ID,orchestra.Orchestra_ID = performance.Orchestra_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NESTED,"SELECT orchestra.Year_of_Founded FROM orchestra JOIN performance ON orchestra.Orchestra_ID = performance.Orchestra_ID GROUP BY orchestra.Orchestra_ID, orchestra.Year_of_Founded HAVING COUNT(performance.Performance_ID) > 1;",SELECT Year_of_Founded FROM orchestra AS T1 JOIN performance AS T2 ON T1.Orchestra_ID  =  T2.Orchestra_ID GROUP BY T2.Orchestra_ID HAVING COUNT(*)  >  1,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Year_of_Founded"" from the ""orchestra"" table. Use the FROM clause to specify the ""orchestra"" table and JOIN it with the ""performance"" table to link orchestras with their performances. Apply a GROUP BY clause on the ""Orchestra_ID"" to count the number of performances for each orchestra. Use the HAVING clause to filter orchestras that have given more than one performance. 2. Condition Structure: Use the HAVING clause with COUNT(*) to filter orchestras that have more than one performance. 3. Join Structure: Use an INNER JOIN between the ""orchestra"" and ""performance"" tables based on ""Orchestra_ID"" to connect orchestras with their performances. 4. Aggregation Structure: Use COUNT(*) to count the number of performances for each orchestra and filter those with more than one performance.",[],[],,1.0,
What is the name of the conductor who has worked the greatest number of years?,"[conductor.Name, conductor.Year_of_Work]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT conductor.Name FROM conductor ORDER BY conductor.Year_of_Work DESC LIMIT 1;,SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""conductor.Name"" of the conductor who has worked the greatest number of years. 2. Condition Structure: No specific filtering condition is required since we are looking for the conductor with the maximum ""Year_of_Work"". 3. Join Structure: No JOIN is necessary as all the required information is available in the ""conductor"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""conductor.Year_of_Work"" to rank conductors by their years of work and apply LIMIT 1 to select the conductor with the greatest number of years.","[('Robert Craft',)]","[('Robert Craft',)]",,1.0,
How many cities in each district have a population that is above the average population across all cities?,"[city.District, city.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT District, COUNT(*) AS city_count FROM city WHERE Population > (SELECT AVG(Population) FROM city) GROUP BY District;","SELECT count(*) ,  District FROM city WHERE Population  >  (SELECT avg(Population) FROM city) GROUP BY District",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the district and the count of cities in each district. Use the FROM clause to specify the city table. Apply a WHERE clause to filter cities with a population above the average population across all cities. Use GROUP BY to group the results by district. 2. Condition Structure: Use the WHERE clause with a subquery to filter cities whose population is greater than the average population of all cities. The subquery calculates the average population. 3. Join Structure: Not required, as all data is from the city table. 4. Aggregation Structure: Use COUNT to count the number of cities in each district and AVG in the subquery to calculate the average population across all cities.","[('Abidjan', 1), ('Abu Dhabi', 1), ('Adana', 1), ('Addis Abeba', 1), ('Aden', 1), ('Aguascalientes', 1), ('Ahal', 1), ('Aichi', 2), ('Alagoas', 1), ('Alberta', 2), ('Aleksandria', 1), ('Aleppo', 1), ('Alger', 1), ('Almaty Qalasy', 1), ('Altai', 1), ('Amazonas', 1), ('Amman', 1), ('Anambra & Enugu & Eb', 1), ('Andalusia', 2), ('Andhra Pradesh', 5), ('Anhui', 5), ('Ankara', 1), ('Antalya', 1), ('Antananarivo', 1), ('Antioquia', 1), ('Antwerpen', 1), ('Aragonia', 1), ('Aragua', 1), ('Arequipa', 1), ('Arizona', 3), ('Arkangeli', 1), ('Ashanti', 1), ('Assam', 1), ('Astrahan', 1), ('Asunción', 1), ('Atlantique', 1), ('Atlántico', 1), ('Attika', 1), ('Auckland', 1), ('Baden-Württemberg', 1), ('Baghdad', 1), ('Bahia', 2), ('Baijeri', 2), ('Baja California', 3), ('Baki', 1), ('Bali', 1), ('Baluchistan', 1), ('Bamako', 1), ('Banaadir', 1), ('Bangkok', 1), ('Bangui', 1), ('Baskimaa', 1), ('Basra', 1), ('Baškortostan', 1), ('Beirut', 1), ('Bengasi', 1), ('Berliini', 1), ('Bihar', 1), ('Bishkek shaary', 1), ('Blantyre', 1), ('Bolívar', 2), ('Bratislava', 1), ('Brazzaville', 1), ('Bremen', 1), ('British Colombia', 1), ('Brjansk', 1), ('Budapest', 1), ('Buenos Aires', 12), ('Bukarest', 1), ('Bulawayo', 1), ('Burjatia', 1), ('Bursa', 1), ('California', 8), ('Callao', 1), ('Campania', 1), ('Canary Islands', 1), ('Cap-Vert', 2), ('Carabobo', 1), ('Casablanca', 1), ('Ceará', 1), ('Central', 2), ('Central Java', 2), ('Central Macedonia', 1), ('Central Serbia', 1), ('Central Visayas', 1), ('Centre', 1), ('Chandigarh', 1), ('Chari-Baguirmi', 1), ('Chhatisgarh', 2), ('Chiapas', 1), ('Chiba', 4), ('Chihuahua', 2), ('Chisinau', 1), ('Chittagong', 1), ('Chollabuk', 1), ('Chongqing', 1), ('Chungchongbuk', 1), ('Coahuila de Zaragoza', 2), ('Coast', 1), ('Cochabamba', 1), ('Colorado', 2), ('Conakry', 1), ('Constantine', 1), ('Cortés', 1), ('Córdoba', 1), ('Damascus', 1), ('Dar es Salaam', 1), ('Delhi', 1), ('Dhaka', 1), ('District of Columbia', 1), ('Distrito Central', 1), ('Distrito Federal', 4), ('Distrito Nacional', 1), ('Diyarbakir', 1), ('Djibouti', 1), ('Dnipropetrovsk', 2), ('Doha', 1), ('Dolnoslaskie', 1), ('Donetsk', 3), ('Dubai', 1), ('Durango', 1), ('East Azerbaidzan', 1), ('East Java', 2), ('East Kasai', 1), ('Eastern Cape', 1), ('Ehime', 1), ('Emilia-Romagna', 1), ('England', 7), ('Esfahan', 1), ('Eskisehir', 1), ('Estuaire', 1), ('Fars', 1), ('Federaatio', 1), ('Florida', 2), ('Fujian', 2), ('Fukuoka', 2), ('Fukushima', 1), ('Fès-Boulemane', 1), ('Gansu', 1), ('Gauteng', 7), ('Gaza', 1), ('Gaziantep', 1), ('Georgia', 1), ('Gifu', 1), ('Gilan', 1), ('Giza', 1), ('Goiás', 1), ('Gomel', 1), ('Grad Sofija', 1), ('Grad Zagreb', 1), ('Greater Accra', 1), ('Guanajuato', 3), ('Guangdong', 4), ('Guangxi', 3), ('Guatemala', 1), ('Guayas', 1), ('Guerrero', 1), ('Guizhou', 2), ('Gujarat', 5), ('Habarovsk', 1), ('Hainan', 1), ('Haiphong', 1), ('Hamadan', 1), ('Hamburg', 1), ('Hamgyong N', 1), ('Hamgyong P', 1), ('Hanoi', 1), ('Harare', 1), ('Harjumaa', 1), ('Harkova', 1), ('Haryana', 1), ('Haute-Zaïre', 1), ('Hawaii', 1), ('Hebei', 6), ('Heilongjiang', 9), ('Henan', 7), ('Herson', 1), ('Hessen', 1), ('Hims', 1), ('Hiroshima', 2), ('Hlavní mesto Praha', 1), ('Ho Chi Minh City', 1), ('Hokkaido', 2), ('Hongkong', 1), ('Horad Minsk', 1), ('Hsinchu', 1), ('Hubei', 4), ('Hunan', 4), ('Hyogo', 4), ('Illinois', 1), ('Inchon', 1), ('Indiana', 1), ('Inner Mongolia', 3), ('Irbil', 1), ('Irkutsk', 1), ('Ishikawa', 1), ('Islamabad', 1), ('Istanbul', 1), ('Ivanovo', 1), ('Izmir', 1), ('Içel', 1), ('Jakarta Raya', 1), ('Jalisco', 3), ('Jambi', 1), ('Jammu and Kashmir', 1), ('Jaroslavl', 1), ('Jerusalem', 1), ('Jharkhand', 2), ('Jiangsu', 7), ('Jiangxi', 2), ('Jilin', 4), ('Jizní Morava', 1), ('Kabol', 1), ('Kadiogo', 1), ('Kaduna', 1), ('Kagoshima', 1), ('Kairo', 1), ('Kalimantan Barat', 1), ('Kalimantan Selatan', 1), ('Kalimantan Timur', 1), ('Kaliningrad', 1), ('Kanagawa', 5), ('Kano & Jigawa', 1), ('Kaohsiung', 1), ('Karnataka', 3), ('Karotegin', 1), ('Katalonia', 1), ('Kaunas', 1), ('Kayseri', 1), ('Keelung', 1), ('Kemerovo', 2), ('Kerala', 3), ('Kerman', 1), ('Kermanshah', 1), ('Khartum', 3), ('Khorasan', 1), ('Khulna', 1), ('Khuzestan', 1), ('Kinshasa', 1), ('Kiova', 1), ('Kirov', 1), ('Konya', 1), ('Kouilou', 1), ('Kowloon and New Kowl', 1), ('Krasnodar', 2), ('Krasnojarsk', 1), ('Kujawsko-Pomorskie', 1), ('Kumamoto', 1), ('Kurgan', 1), ('Kursk', 1), ('KwaZulu-Natal', 4), ('Kwangju', 1), ('Kwara & Kogi', 1), ('Kyonggi', 7), ('Kyongsangbuk', 1), ('Kyongsangnam', 3), ('Kyoto', 1), ('København', 1), ('La Habana', 1), ('La Libertad', 1), ('La Paz', 2), ('Lagos', 1), ('Lambayeque', 1), ('Lampung', 1), ('Lara', 1), ('Latium', 1), ('Leinster', 1), ('Liaoning', 12), ('Liguria', 1), ('Lilongwe', 1), ('Lima', 1), ('Lipetsk', 1), ('Lisboa', 2), ('Littoral', 1), ('Lodzkie', 1), ('Lombardia', 1), ('Loreto', 1), ('Louisiana', 1), ('Luanda', 1), ('Lubelskie', 1), ('Lugansk', 1), ('Lusaka', 1), ('Luxor', 1), ('Lviv', 1), ('Macau', 1), ('Madhya Pradesh', 5), ('Madrid', 1), ('Maekel', 1), ('Magdalena', 1), ('Maharashtra', 13), ('Malopolskie', 1), ('Managua', 1), ('Mandalay', 1), ('Manitoba', 1), ('Maputo', 2), ('Maranhão', 1), ('Maritime', 1), ('Markazi', 1), ('Marrakech-Tensift-Al', 1), ('Maryland', 1), ('Massachusetts', 1), ('Mato Grosso', 1), ('Mato Grosso do Sul', 1), ('Mazowieckie', 1), ('Medina', 1), ('Mekka', 3), ('Meknès-Tafilalet', 1), ('Michigan', 1), ('Michoacán de Ocampo', 1), ('Midi-Pyrénées', 1), ('Minas Gerais', 4), ('Minnesota', 1), ('Miranda', 1), ('Missouri', 1), ('Miyagi', 1), ('Mogiljov', 1), ('Montevideo', 1), ('Montserrado', 1), ('Moscow (City)', 1), ('Murcia', 1), ('Murmansk', 1), ('Mykolajiv', 1), ('México', 9), ('Nagano', 1), ('Nagasaki', 1), ('Nairobi', 1), ('Namangan', 1), ('Nampo-si', 1), ('Nara', 1), ('National Capital Reg', 12), ('Nebraska', 1), ('Nevada', 1), ('New Mexico', 1), ('New South Wales', 1), ('New York', 1), ('Newmaa', 1), ('Niamey', 1), ('Niedersachsen', 1), ('Niigata', 1), ('Ninawa', 1), ('Ningxia', 1), ('Nizni Novgorod', 1), ('Noord-Holland', 1), ('Nordrhein-Westfalen', 7), ('Norte de Santander', 1), ('North Carolina', 1), ('Northern Mindanao', 1), ('Nothwest Border Prov', 1), ('Nouakchott', 1), ('Novosibirsk', 1), ('Nuevo León', 3), ('Odesa', 1), ('Ogun', 1), ('Ohio', 2), ('Oita', 1), ('Okayama', 2), ('Oklahoma', 2), ('Omsk', 1), ('Ondo & Ekiti', 1), ('Ontario', 4), ('Oran', 1), ('Oregon', 1), ('Orenburg', 1), ('Oriental', 1), ('Orissa', 2), ('Osaka', 6), ('Oslo', 1), ('Ouest', 1), ('Oyo & Osun', 5), ('Panamá', 1), ('Paraná', 2), ('Paraíba', 2), ('Pará', 2), ('Peking', 1), ('Pennsylvania', 1), ('Penza', 1), ('Perak', 1), ('Perm', 1), ('Pernambuco', 3), ('Phnom Penh', 1), ('Piauí', 1), ('Pichincha', 1), ('Piemonte', 1), ('Pietari', 1), ('Pomorskie', 1), ('Port Said', 1), ('Primorje', 1), ('Provence-Alpes-Côte', 1), ('Puebla', 1), ('Punjab', 11), ('Pusan', 1), ('Pyongyang-si', 1), ('Qaraghandy', 1), ('Qinghai', 1), ('Qom', 1), ('Quang Nam-Da Nang', 1), ('Queensland', 1), ('Querétaro de Arteaga', 1), ('Quintana Roo', 1), ('Québec', 1), ('Rabat-Salé-Zammour-Z', 2), ('Rajasthan', 5), ('Rangoon [Yangon]', 1), ('Rhône-Alpes', 1), ('Riau', 1), ('Riika', 1), ('Rio Grande do Norte', 1), ('Rio Grande do Sul', 1), ('Rio de Janeiro', 8), ('Risaralda', 1), ('Rivers & Bayelsa', 1), ('Riyadh', 1), ('Rjazan', 1), ('Rostov-na-Donu', 1), ('Saitama', 3), ('Saksi', 2), ('Salta', 1), ('Samara', 2), ('Samarkand', 1), ('San Juan', 1), ('San Luis Potosí', 1), ('San Salvador', 1), ('Sanaa', 1), ('Sanliurfa', 1), ('Santa Catarina', 1), ('Santa Cruz', 1), ('Santa Fé', 2), ('Santafé de Bogotá', 1), ('Santander', 1), ('Santiago', 3), ('Santiago de Cuba', 1), ('Saratov', 1), ('Scotland', 2), ('Seoul', 1), ('Sergipe', 1), ('Shaanxi', 2), ('Shaba', 2), ('Shandong', 7), ('Shanghai', 1), ('Shanxi', 3), ('Shizuoka', 2), ('Sichuan', 3), ('Sinaloa', 3), ('Sindh', 2), ('Sisilia', 1), ('Sistan va Baluchesta', 1), ('Skopje', 1), ('Smolensk', 1), ('Sofala', 1), ('Sonora', 2), ('South Australia', 1), ('South Kazakstan', 1), ('Southern Mindanao', 2), ('Southern Tagalog', 2), ('Suez', 1), ('Sulawesi Selatan', 1), ('Sumatera Barat', 1), ('Sumatera Selatan', 1), ('Sumatera Utara', 1), ('Sverdlovsk', 2), ('São Paulo', 13), ('Tabasco', 1), ('Taegu', 1), ('Taejon', 1), ('Taichung', 1), ('Tainan', 1), ('Taipei', 5), ('Tamaulipas', 2), ('Tamil Nadu', 5), ('Tanger-Tétouan', 1), ('Tatarstan', 2), ('Tbilisi', 1), ('Teheran', 2), ('Tennessee', 2), ('Texas', 6), ('Tianjin', 1), ('Tjumen', 1), ('Tochigi', 1), ('Tokyo-to', 3), ('Tolima', 1), ('Tomsk', 1), ('Toscana', 1), ('Toskent Shahri', 1), ('Tripoli', 1), ('Tucumán', 1), ('Tula', 1), ('Tunis', 1), ('Tver', 1), ('Tšeljabinsk', 2), ('Tšuvassia', 1), ('Udmurtia', 1), ('Ulaanbaatar', 1), ('Uljanovsk', 1), ('Uttar Pradesh', 12), ('Valencia', 1), ('Valle', 1), ('Veracruz', 2), ('Viangchan', 1), ('Victoria', 1), ('Vilna', 1), ('Vinnytsja', 1), ('Virginia', 1), ('Volgograd', 1), ('Voronez', 1), ('Wakayama', 1), ('Washington', 1), ('West Australia', 1), ('West Azerbaidzan', 1), ('West Bengali', 3), ('West Götanmaan län', 1), ('West Java', 4), ('West Kasai', 1), ('Western', 2), ('Western Cape', 1), ('Western Mindanao', 1), ('Western Visayas', 2), ('Wielkopolskie', 1), ('Wien', 1), ('Wilayah Persekutuan', 1), ('Wisconsin', 1), ('Xinxiang', 1), ('Yerevan', 1), ('Yogyakarta', 1), ('Yucatán', 1), ('Yunnan', 1), ('Zachodnio-Pomorskie', 1), ('Zaporizzja', 1), ('Zhejiang', 3), ('Zuid-Holland', 2), ('Zulia', 1), ('al-Daqahliya', 1), ('al-Gharbiya', 2), ('al-Qalyubiya', 1), ('al-Sharqiya', 1), ('al-Sulaymaniya', 1), ('al-Tamim', 1), ('al-Zarqa', 1), ('Île-de-France', 1), ('–', 1)]","[(1, 'Abidjan'), (1, 'Abu Dhabi'), (1, 'Adana'), (1, 'Addis Abeba'), (1, 'Aden'), (1, 'Aguascalientes'), (1, 'Ahal'), (2, 'Aichi'), (1, 'Alagoas'), (2, 'Alberta'), (1, 'Aleksandria'), (1, 'Aleppo'), (1, 'Alger'), (1, 'Almaty Qalasy'), (1, 'Altai'), (1, 'Amazonas'), (1, 'Amman'), (1, 'Anambra & Enugu & Eb'), (2, 'Andalusia'), (5, 'Andhra Pradesh'), (5, 'Anhui'), (1, 'Ankara'), (1, 'Antalya'), (1, 'Antananarivo'), (1, 'Antioquia'), (1, 'Antwerpen'), (1, 'Aragonia'), (1, 'Aragua'), (1, 'Arequipa'), (3, 'Arizona'), (1, 'Arkangeli'), (1, 'Ashanti'), (1, 'Assam'), (1, 'Astrahan'), (1, 'Asunción'), (1, 'Atlantique'), (1, 'Atlántico'), (1, 'Attika'), (1, 'Auckland'), (1, 'Baden-Württemberg'), (1, 'Baghdad'), (2, 'Bahia'), (2, 'Baijeri'), (3, 'Baja California'), (1, 'Baki'), (1, 'Bali'), (1, 'Baluchistan'), (1, 'Bamako'), (1, 'Banaadir'), (1, 'Bangkok'), (1, 'Bangui'), (1, 'Baskimaa'), (1, 'Basra'), (1, 'Baškortostan'), (1, 'Beirut'), (1, 'Bengasi'), (1, 'Berliini'), (1, 'Bihar'), (1, 'Bishkek shaary'), (1, 'Blantyre'), (2, 'Bolívar'), (1, 'Bratislava'), (1, 'Brazzaville'), (1, 'Bremen'), (1, 'British Colombia'), (1, 'Brjansk'), (1, 'Budapest'), (12, 'Buenos Aires'), (1, 'Bukarest'), (1, 'Bulawayo'), (1, 'Burjatia'), (1, 'Bursa'), (8, 'California'), (1, 'Callao'), (1, 'Campania'), (1, 'Canary Islands'), (2, 'Cap-Vert'), (1, 'Carabobo'), (1, 'Casablanca'), (1, 'Ceará'), (2, 'Central'), (2, 'Central Java'), (1, 'Central Macedonia'), (1, 'Central Serbia'), (1, 'Central Visayas'), (1, 'Centre'), (1, 'Chandigarh'), (1, 'Chari-Baguirmi'), (2, 'Chhatisgarh'), (1, 'Chiapas'), (4, 'Chiba'), (2, 'Chihuahua'), (1, 'Chisinau'), (1, 'Chittagong'), (1, 'Chollabuk'), (1, 'Chongqing'), (1, 'Chungchongbuk'), (2, 'Coahuila de Zaragoza'), (1, 'Coast'), (1, 'Cochabamba'), (2, 'Colorado'), (1, 'Conakry'), (1, 'Constantine'), (1, 'Cortés'), (1, 'Córdoba'), (1, 'Damascus'), (1, 'Dar es Salaam'), (1, 'Delhi'), (1, 'Dhaka'), (1, 'District of Columbia'), (1, 'Distrito Central'), (4, 'Distrito Federal'), (1, 'Distrito Nacional'), (1, 'Diyarbakir'), (1, 'Djibouti'), (2, 'Dnipropetrovsk'), (1, 'Doha'), (1, 'Dolnoslaskie'), (3, 'Donetsk'), (1, 'Dubai'), (1, 'Durango'), (1, 'East Azerbaidzan'), (2, 'East Java'), (1, 'East Kasai'), (1, 'Eastern Cape'), (1, 'Ehime'), (1, 'Emilia-Romagna'), (7, 'England'), (1, 'Esfahan'), (1, 'Eskisehir'), (1, 'Estuaire'), (1, 'Fars'), (1, 'Federaatio'), (2, 'Florida'), (2, 'Fujian'), (2, 'Fukuoka'), (1, 'Fukushima'), (1, 'Fès-Boulemane'), (1, 'Gansu'), (7, 'Gauteng'), (1, 'Gaza'), (1, 'Gaziantep'), (1, 'Georgia'), (1, 'Gifu'), (1, 'Gilan'), (1, 'Giza'), (1, 'Goiás'), (1, 'Gomel'), (1, 'Grad Sofija'), (1, 'Grad Zagreb'), (1, 'Greater Accra'), (3, 'Guanajuato'), (4, 'Guangdong'), (3, 'Guangxi'), (1, 'Guatemala'), (1, 'Guayas'), (1, 'Guerrero'), (2, 'Guizhou'), (5, 'Gujarat'), (1, 'Habarovsk'), (1, 'Hainan'), (1, 'Haiphong'), (1, 'Hamadan'), (1, 'Hamburg'), (1, 'Hamgyong N'), (1, 'Hamgyong P'), (1, 'Hanoi'), (1, 'Harare'), (1, 'Harjumaa'), (1, 'Harkova'), (1, 'Haryana'), (1, 'Haute-Zaïre'), (1, 'Hawaii'), (6, 'Hebei'), (9, 'Heilongjiang'), (7, 'Henan'), (1, 'Herson'), (1, 'Hessen'), (1, 'Hims'), (2, 'Hiroshima'), (1, 'Hlavní mesto Praha'), (1, 'Ho Chi Minh City'), (2, 'Hokkaido'), (1, 'Hongkong'), (1, 'Horad Minsk'), (1, 'Hsinchu'), (4, 'Hubei'), (4, 'Hunan'), (4, 'Hyogo'), (1, 'Illinois'), (1, 'Inchon'), (1, 'Indiana'), (3, 'Inner Mongolia'), (1, 'Irbil'), (1, 'Irkutsk'), (1, 'Ishikawa'), (1, 'Islamabad'), (1, 'Istanbul'), (1, 'Ivanovo'), (1, 'Izmir'), (1, 'Içel'), (1, 'Jakarta Raya'), (3, 'Jalisco'), (1, 'Jambi'), (1, 'Jammu and Kashmir'), (1, 'Jaroslavl'), (1, 'Jerusalem'), (2, 'Jharkhand'), (7, 'Jiangsu'), (2, 'Jiangxi'), (4, 'Jilin'), (1, 'Jizní Morava'), (1, 'Kabol'), (1, 'Kadiogo'), (1, 'Kaduna'), (1, 'Kagoshima'), (1, 'Kairo'), (1, 'Kalimantan Barat'), (1, 'Kalimantan Selatan'), (1, 'Kalimantan Timur'), (1, 'Kaliningrad'), (5, 'Kanagawa'), (1, 'Kano & Jigawa'), (1, 'Kaohsiung'), (3, 'Karnataka'), (1, 'Karotegin'), (1, 'Katalonia'), (1, 'Kaunas'), (1, 'Kayseri'), (1, 'Keelung'), (2, 'Kemerovo'), (3, 'Kerala'), (1, 'Kerman'), (1, 'Kermanshah'), (3, 'Khartum'), (1, 'Khorasan'), (1, 'Khulna'), (1, 'Khuzestan'), (1, 'Kinshasa'), (1, 'Kiova'), (1, 'Kirov'), (1, 'Konya'), (1, 'Kouilou'), (1, 'Kowloon and New Kowl'), (2, 'Krasnodar'), (1, 'Krasnojarsk'), (1, 'Kujawsko-Pomorskie'), (1, 'Kumamoto'), (1, 'Kurgan'), (1, 'Kursk'), (4, 'KwaZulu-Natal'), (1, 'Kwangju'), (1, 'Kwara & Kogi'), (7, 'Kyonggi'), (1, 'Kyongsangbuk'), (3, 'Kyongsangnam'), (1, 'Kyoto'), (1, 'København'), (1, 'La Habana'), (1, 'La Libertad'), (2, 'La Paz'), (1, 'Lagos'), (1, 'Lambayeque'), (1, 'Lampung'), (1, 'Lara'), (1, 'Latium'), (1, 'Leinster'), (12, 'Liaoning'), (1, 'Liguria'), (1, 'Lilongwe'), (1, 'Lima'), (1, 'Lipetsk'), (2, 'Lisboa'), (1, 'Littoral'), (1, 'Lodzkie'), (1, 'Lombardia'), (1, 'Loreto'), (1, 'Louisiana'), (1, 'Luanda'), (1, 'Lubelskie'), (1, 'Lugansk'), (1, 'Lusaka'), (1, 'Luxor'), (1, 'Lviv'), (1, 'Macau'), (5, 'Madhya Pradesh'), (1, 'Madrid'), (1, 'Maekel'), (1, 'Magdalena'), (13, 'Maharashtra'), (1, 'Malopolskie'), (1, 'Managua'), (1, 'Mandalay'), (1, 'Manitoba'), (2, 'Maputo'), (1, 'Maranhão'), (1, 'Maritime'), (1, 'Markazi'), (1, 'Marrakech-Tensift-Al'), (1, 'Maryland'), (1, 'Massachusetts'), (1, 'Mato Grosso'), (1, 'Mato Grosso do Sul'), (1, 'Mazowieckie'), (1, 'Medina'), (3, 'Mekka'), (1, 'Meknès-Tafilalet'), (1, 'Michigan'), (1, 'Michoacán de Ocampo'), (1, 'Midi-Pyrénées'), (4, 'Minas Gerais'), (1, 'Minnesota'), (1, 'Miranda'), (1, 'Missouri'), (1, 'Miyagi'), (1, 'Mogiljov'), (1, 'Montevideo'), (1, 'Montserrado'), (1, 'Moscow (City)'), (1, 'Murcia'), (1, 'Murmansk'), (1, 'Mykolajiv'), (9, 'México'), (1, 'Nagano'), (1, 'Nagasaki'), (1, 'Nairobi'), (1, 'Namangan'), (1, 'Nampo-si'), (1, 'Nara'), (12, 'National Capital Reg'), (1, 'Nebraska'), (1, 'Nevada'), (1, 'New Mexico'), (1, 'New South Wales'), (1, 'New York'), (1, 'Newmaa'), (1, 'Niamey'), (1, 'Niedersachsen'), (1, 'Niigata'), (1, 'Ninawa'), (1, 'Ningxia'), (1, 'Nizni Novgorod'), (1, 'Noord-Holland'), (7, 'Nordrhein-Westfalen'), (1, 'Norte de Santander'), (1, 'North Carolina'), (1, 'Northern Mindanao'), (1, 'Nothwest Border Prov'), (1, 'Nouakchott'), (1, 'Novosibirsk'), (3, 'Nuevo León'), (1, 'Odesa'), (1, 'Ogun'), (2, 'Ohio'), (1, 'Oita'), (2, 'Okayama'), (2, 'Oklahoma'), (1, 'Omsk'), (1, 'Ondo & Ekiti'), (4, 'Ontario'), (1, 'Oran'), (1, 'Oregon'), (1, 'Orenburg'), (1, 'Oriental'), (2, 'Orissa'), (6, 'Osaka'), (1, 'Oslo'), (1, 'Ouest'), (5, 'Oyo & Osun'), (1, 'Panamá'), (2, 'Paraná'), (2, 'Paraíba'), (2, 'Pará'), (1, 'Peking'), (1, 'Pennsylvania'), (1, 'Penza'), (1, 'Perak'), (1, 'Perm'), (3, 'Pernambuco'), (1, 'Phnom Penh'), (1, 'Piauí'), (1, 'Pichincha'), (1, 'Piemonte'), (1, 'Pietari'), (1, 'Pomorskie'), (1, 'Port Said'), (1, 'Primorje'), (1, 'Provence-Alpes-Côte'), (1, 'Puebla'), (11, 'Punjab'), (1, 'Pusan'), (1, 'Pyongyang-si'), (1, 'Qaraghandy'), (1, 'Qinghai'), (1, 'Qom'), (1, 'Quang Nam-Da Nang'), (1, 'Queensland'), (1, 'Querétaro de Arteaga'), (1, 'Quintana Roo'), (1, 'Québec'), (2, 'Rabat-Salé-Zammour-Z'), (5, 'Rajasthan'), (1, 'Rangoon [Yangon]'), (1, 'Rhône-Alpes'), (1, 'Riau'), (1, 'Riika'), (1, 'Rio Grande do Norte'), (1, 'Rio Grande do Sul'), (8, 'Rio de Janeiro'), (1, 'Risaralda'), (1, 'Rivers & Bayelsa'), (1, 'Riyadh'), (1, 'Rjazan'), (1, 'Rostov-na-Donu'), (3, 'Saitama'), (2, 'Saksi'), (1, 'Salta'), (2, 'Samara'), (1, 'Samarkand'), (1, 'San Juan'), (1, 'San Luis Potosí'), (1, 'San Salvador'), (1, 'Sanaa'), (1, 'Sanliurfa'), (1, 'Santa Catarina'), (1, 'Santa Cruz'), (2, 'Santa Fé'), (1, 'Santafé de Bogotá'), (1, 'Santander'), (3, 'Santiago'), (1, 'Santiago de Cuba'), (1, 'Saratov'), (2, 'Scotland'), (1, 'Seoul'), (1, 'Sergipe'), (2, 'Shaanxi'), (2, 'Shaba'), (7, 'Shandong'), (1, 'Shanghai'), (3, 'Shanxi'), (2, 'Shizuoka'), (3, 'Sichuan'), (3, 'Sinaloa'), (2, 'Sindh'), (1, 'Sisilia'), (1, 'Sistan va Baluchesta'), (1, 'Skopje'), (1, 'Smolensk'), (1, 'Sofala'), (2, 'Sonora'), (1, 'South Australia'), (1, 'South Kazakstan'), (2, 'Southern Mindanao'), (2, 'Southern Tagalog'), (1, 'Suez'), (1, 'Sulawesi Selatan'), (1, 'Sumatera Barat'), (1, 'Sumatera Selatan'), (1, 'Sumatera Utara'), (2, 'Sverdlovsk'), (13, 'São Paulo'), (1, 'Tabasco'), (1, 'Taegu'), (1, 'Taejon'), (1, 'Taichung'), (1, 'Tainan'), (5, 'Taipei'), (2, 'Tamaulipas'), (5, 'Tamil Nadu'), (1, 'Tanger-Tétouan'), (2, 'Tatarstan'), (1, 'Tbilisi'), (2, 'Teheran'), (2, 'Tennessee'), (6, 'Texas'), (1, 'Tianjin'), (1, 'Tjumen'), (1, 'Tochigi'), (3, 'Tokyo-to'), (1, 'Tolima'), (1, 'Tomsk'), (1, 'Toscana'), (1, 'Toskent Shahri'), (1, 'Tripoli'), (1, 'Tucumán'), (1, 'Tula'), (1, 'Tunis'), (1, 'Tver'), (2, 'Tšeljabinsk'), (1, 'Tšuvassia'), (1, 'Udmurtia'), (1, 'Ulaanbaatar'), (1, 'Uljanovsk'), (12, 'Uttar Pradesh'), (1, 'Valencia'), (1, 'Valle'), (2, 'Veracruz'), (1, 'Viangchan'), (1, 'Victoria'), (1, 'Vilna'), (1, 'Vinnytsja'), (1, 'Virginia'), (1, 'Volgograd'), (1, 'Voronez'), (1, 'Wakayama'), (1, 'Washington'), (1, 'West Australia'), (1, 'West Azerbaidzan'), (3, 'West Bengali'), (1, 'West Götanmaan län'), (4, 'West Java'), (1, 'West Kasai'), (2, 'Western'), (1, 'Western Cape'), (1, 'Western Mindanao'), (2, 'Western Visayas'), (1, 'Wielkopolskie'), (1, 'Wien'), (1, 'Wilayah Persekutuan'), (1, 'Wisconsin'), (1, 'Xinxiang'), (1, 'Yerevan'), (1, 'Yogyakarta'), (1, 'Yucatán'), (1, 'Yunnan'), (1, 'Zachodnio-Pomorskie'), (1, 'Zaporizzja'), (3, 'Zhejiang'), (2, 'Zuid-Holland'), (1, 'Zulia'), (1, 'al-Daqahliya'), (2, 'al-Gharbiya'), (1, 'al-Qalyubiya'), (1, 'al-Sharqiya'), (1, 'al-Sulaymaniya'), (1, 'al-Tamim'), (1, 'al-Zarqa'), (1, 'Île-de-France'), (1, '–')]",,1.0,
Please show the different record companies and the corresponding number of orchestras.,"[orchestra.Record_Company, orchestra.Orchestra_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,"SELECT orchestra.Record_Company, COUNT(orchestra.Orchestra_ID) AS orchestra_count FROM orchestra GROUP BY orchestra.Record_Company;","SELECT Record_Company ,  COUNT(*) FROM orchestra GROUP BY Record_Company",orchestra,"1. Sequential Structure: Start with the SELECT clause to specify the record company and the count of orchestras. 2. Aggregation Structure: Use COUNT to calculate the number of orchestras for each record company. 3. Grouping Structure: Use GROUP BY on ""orchestra.Record_Company"" to group the results by each record company. 4. Join Structure: No JOIN is required since all necessary data is within the ""orchestra"" table.","[('Columbia Masterworks', 1), ('Decca Records', 2), ('Delos Records', 1), ('Deutsche Grammophon', 1), ('EMI', 1), ('Koch Records / Naxos Records', 1), ('Kultur', 1), ('Mercury Records', 1), ('Philips', 1), ('Philips Classics Records', 1), ('RCA', 1)]","[('Columbia Masterworks', 1), ('Decca Records', 2), ('Delos Records', 1), ('Deutsche Grammophon', 1), ('EMI', 1), ('Koch Records / Naxos Records', 1), ('Kultur', 1), ('Mercury Records', 1), ('Philips', 1), ('Philips Classics Records', 1), ('RCA', 1)]",,1.0,
Return the grade that has the greatest number of high schoolers.,[Highschooler.grade],"Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,"SELECT Highschooler.grade, COUNT(*) AS student_count FROM Highschooler GROUP BY Highschooler.grade ORDER BY COUNT(*) DESC LIMIT 1;",SELECT grade FROM Highschooler GROUP BY grade ORDER BY count(*) DESC LIMIT 1,network_1,"1. Sequential Structure: Begin with the SELECT clause to specify the grade, as well as the count of high schoolers in each grade. 2. Aggregation Structure: Use COUNT to calculate the number of high schoolers in each grade. 3. Grouping Structure: Use GROUP BY on ""Highschooler.grade"" to aggregate the results by grade. 4. Ordering Structure: Use ORDER BY in descending order on the count of high schoolers to rank grades by the number of students. 5. Limiting Structure: Use LIMIT 1 to retrieve the grade with the greatest number of high schoolers. 6. Join Structure: No JOIN is required since all necessary data is within the ""Highschooler"" table.","[(12, 4)]","[(12,)]",,1.0,
"What are the major record formats of orchestras, sorted by their frequency?",[orchestra.Major_Record_Format],"Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,"SELECT orchestra.Major_Record_Format, COUNT(*) AS frequency FROM orchestra GROUP BY orchestra.Major_Record_Format ORDER BY frequency DESC;",SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC,orchestra,"1. Sequential Structure: Begin with the SELECT clause to specify the ""orchestra.Major_Record_Format"" and its frequency. 2. Aggregation Structure: Use COUNT to calculate the frequency of each major record format. 3. Grouping Structure: Use GROUP BY on ""orchestra.Major_Record_Format"" to aggregate the results by each record format. 4. Ordering Structure: Use ORDER BY in descending order on the frequency to sort the record formats by their occurrence. 5. Join Structure: No JOIN is required since all necessary data is within the ""orchestra"" table.","[('CD', 10), ('DVD', 1), ('CD / LP', 1)]","[('CD / LP',), ('DVD',), ('CD',)]",,1.0,
What are the names of all high schoolers in grade 10?,"[Highschooler.name, Highschooler.grade, 10]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,SELECT Highschooler.name FROM Highschooler WHERE Highschooler.grade = 10;,SELECT name FROM Highschooler WHERE grade  =  10,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of high schoolers. 2. Condition Structure: Use a WHERE clause to filter for high schoolers in grade 10. 3. Join Structure: No JOIN is required since all necessary information is in the ""Highschooler"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.","[('Haley',), ('Andrew',), ('Kris',), ('Brittany',)]","[('Haley',), ('Andrew',), ('Kris',), ('Brittany',)]",,1.0,
What are the country codes of countries where people use languages other than English?,"[countrylanguage.CountryCode, countrylanguage.Language, country.Code, city.CountryCode = country.Code, countrylanguage.CountryCode = country.Code, English]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT DISTINCT CountryCode FROM countrylanguage WHERE Language != 'English';,"SELECT DISTINCT CountryCode FROM countrylanguage WHERE LANGUAGE != ""English""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct country codes. Use the FROM clause to specify the countrylanguage table, as it contains information about languages spoken in each country. Apply a WHERE clause to filter for languages other than English. 2. Condition Structure: Use the WHERE clause to exclude rows where the language is 'English'. 3. Join Structure: Not required, as all necessary data is available in the countrylanguage table. 4. Aggregation Structure: Not needed, as we are retrieving distinct country codes without any aggregation.","[('ABW',), ('AFG',), ('AGO',), ('ALB',), ('AND',), ('ANT',), ('ARE',), ('ARG',), ('ARM',), ('ASM',), ('ATG',), ('AUS',), ('AUT',), ('AZE',), ('BDI',), ('BEL',), ('BEN',), ('BFA',), ('BGD',), ('BGR',), ('BHR',), ('BHS',), ('BIH',), ('BLR',), ('BLZ',), ('BOL',), ('BRA',), ('BRB',), ('BRN',), ('BTN',), ('BWA',), ('CAF',), ('CAN',), ('CCK',), ('CHE',), ('CHL',), ('CHN',), ('CIV',), ('CMR',), ('COD',), ('COG',), ('COK',), ('COL',), ('COM',), ('CPV',), ('CRI',), ('CUB',), ('CXR',), ('CYP',), ('CZE',), ('DEU',), ('DJI',), ('DMA',), ('DNK',), ('DOM',), ('DZA',), ('ECU',), ('EGY',), ('ERI',), ('ESH',), ('ESP',), ('EST',), ('ETH',), ('FIN',), ('FJI',), ('FRA',), ('FRO',), ('FSM',), ('GAB',), ('GBR',), ('GEO',), ('GHA',), ('GIB',), ('GIN',), ('GLP',), ('GMB',), ('GNB',), ('GNQ',), ('GRC',), ('GRD',), ('GRL',), ('GTM',), ('GUF',), ('GUM',), ('GUY',), ('HKG',), ('HND',), ('HRV',), ('HTI',), ('HUN',), ('IDN',), ('IND',), ('IRL',), ('IRN',), ('IRQ',), ('ISL',), ('ISR',), ('ITA',), ('JAM',), ('JOR',), ('JPN',), ('KAZ',), ('KEN',), ('KGZ',), ('KHM',), ('KIR',), ('KNA',), ('KOR',), ('KWT',), ('LAO',), ('LBN',), ('LBR',), ('LBY',), ('LCA',), ('LIE',), ('LKA',), ('LSO',), ('LTU',), ('LUX',), ('LVA',), ('MAC',), ('MAR',), ('MCO',), ('MDA',), ('MDG',), ('MDV',), ('MEX',), ('MHL',), ('MKD',), ('MLI',), ('MLT',), ('MMR',), ('MNG',), ('MNP',), ('MOZ',), ('MRT',), ('MTQ',), ('MUS',), ('MWI',), ('MYS',), ('MYT',), ('NAM',), ('NCL',), ('NER',), ('NGA',), ('NIC',), ('NIU',), ('NLD',), ('NOR',), ('NPL',), ('NRU',), ('NZL',), ('OMN',), ('PAK',), ('PAN',), ('PCN',), ('PER',), ('PHL',), ('PLW',), ('PNG',), ('POL',), ('PRI',), ('PRK',), ('PRT',), ('PRY',), ('PSE',), ('PYF',), ('QAT',), ('REU',), ('ROM',), ('RUS',), ('RWA',), ('SAU',), ('SDN',), ('SEN',), ('SGP',), ('SJM',), ('SLB',), ('SLE',), ('SLV',), ('SMR',), ('SOM',), ('SPM',), ('STP',), ('SUR',), ('SVK',), ('SVN',), ('SWE',), ('SWZ',), ('SYC',), ('SYR',), ('TCD',), ('TGO',), ('THA',), ('TJK',), ('TKL',), ('TKM',), ('TMP',), ('TON',), ('TTO',), ('TUN',), ('TUR',), ('TUV',), ('TWN',), ('TZA',), ('UGA',), ('UKR',), ('URY',), ('USA',), ('UZB',), ('VAT',), ('VCT',), ('VEN',), ('VIR',), ('VNM',), ('VUT',), ('WLF',), ('WSM',), ('YEM',), ('YUG',), ('ZAF',), ('ZMB',), ('ZWE',)]","[('ABW',), ('AFG',), ('AGO',), ('ALB',), ('AND',), ('ANT',), ('ARE',), ('ARG',), ('ARM',), ('ASM',), ('ATG',), ('AUS',), ('AUT',), ('AZE',), ('BDI',), ('BEL',), ('BEN',), ('BFA',), ('BGD',), ('BGR',), ('BHR',), ('BHS',), ('BIH',), ('BLR',), ('BLZ',), ('BOL',), ('BRA',), ('BRB',), ('BRN',), ('BTN',), ('BWA',), ('CAF',), ('CAN',), ('CCK',), ('CHE',), ('CHL',), ('CHN',), ('CIV',), ('CMR',), ('COD',), ('COG',), ('COK',), ('COL',), ('COM',), ('CPV',), ('CRI',), ('CUB',), ('CXR',), ('CYP',), ('CZE',), ('DEU',), ('DJI',), ('DMA',), ('DNK',), ('DOM',), ('DZA',), ('ECU',), ('EGY',), ('ERI',), ('ESH',), ('ESP',), ('EST',), ('ETH',), ('FIN',), ('FJI',), ('FRA',), ('FRO',), ('FSM',), ('GAB',), ('GBR',), ('GEO',), ('GHA',), ('GIB',), ('GIN',), ('GLP',), ('GMB',), ('GNB',), ('GNQ',), ('GRC',), ('GRD',), ('GRL',), ('GTM',), ('GUF',), ('GUM',), ('GUY',), ('HKG',), ('HND',), ('HRV',), ('HTI',), ('HUN',), ('IDN',), ('IND',), ('IRL',), ('IRN',), ('IRQ',), ('ISL',), ('ISR',), ('ITA',), ('JAM',), ('JOR',), ('JPN',), ('KAZ',), ('KEN',), ('KGZ',), ('KHM',), ('KIR',), ('KNA',), ('KOR',), ('KWT',), ('LAO',), ('LBN',), ('LBR',), ('LBY',), ('LCA',), ('LIE',), ('LKA',), ('LSO',), ('LTU',), ('LUX',), ('LVA',), ('MAC',), ('MAR',), ('MCO',), ('MDA',), ('MDG',), ('MDV',), ('MEX',), ('MHL',), ('MKD',), ('MLI',), ('MLT',), ('MMR',), ('MNG',), ('MNP',), ('MOZ',), ('MRT',), ('MTQ',), ('MUS',), ('MWI',), ('MYS',), ('MYT',), ('NAM',), ('NCL',), ('NER',), ('NGA',), ('NIC',), ('NIU',), ('NLD',), ('NOR',), ('NPL',), ('NRU',), ('NZL',), ('OMN',), ('PAK',), ('PAN',), ('PCN',), ('PER',), ('PHL',), ('PLW',), ('PNG',), ('POL',), ('PRI',), ('PRK',), ('PRT',), ('PRY',), ('PSE',), ('PYF',), ('QAT',), ('REU',), ('ROM',), ('RUS',), ('RWA',), ('SAU',), ('SDN',), ('SEN',), ('SGP',), ('SJM',), ('SLB',), ('SLE',), ('SLV',), ('SMR',), ('SOM',), ('SPM',), ('STP',), ('SUR',), ('SVK',), ('SVN',), ('SWE',), ('SWZ',), ('SYC',), ('SYR',), ('TCD',), ('TGO',), ('THA',), ('TJK',), ('TKL',), ('TKM',), ('TMP',), ('TON',), ('TTO',), ('TUN',), ('TUR',), ('TUV',), ('TWN',), ('TZA',), ('UGA',), ('UKR',), ('URY',), ('USA',), ('UZB',), ('VAT',), ('VCT',), ('VEN',), ('VIR',), ('VNM',), ('VUT',), ('WLF',), ('WSM',), ('YEM',), ('YUG',), ('ZAF',), ('ZMB',), ('ZWE',)]",,1.0,
List the names of conductors in ascending order of age.,"[conductor.Name, conductor.Age]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT conductor.Name FROM conductor ORDER BY conductor.Age ASC;,SELECT Name FROM conductor ORDER BY Age ASC,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Name"" of conductors. 2. Condition Structure: No specific filtering condition is required as we want all conductors. 3. Join Structure: No JOIN is required since all necessary information is in the ""conductor"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in ascending order based on ""Age"".","[('Antal Doráti',), ('Igor Stravinsky',), ('Colin Davis',), ('Michael Tilson Thomas',), ('Paul Jorgensen',), ('Antal Brown',), ('Charles Dutoit',), ('Seiji Ozawa',), ('Valeri Gergiev',), ('Pierre Boulez',), ('Gerard Schwarz',), ('Robert Craft',)]","[('Antal Doráti',), ('Igor Stravinsky',), ('Colin Davis',), ('Michael Tilson Thomas',), ('Paul Jorgensen',), ('Antal Brown',), ('Charles Dutoit',), ('Seiji Ozawa',), ('Valeri Gergiev',), ('Pierre Boulez',), ('Gerard Schwarz',), ('Robert Craft',)]",,1.0,
Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .,"[country.Population, country.SurfaceArea, country.Continent, country.Code, North America, 3000]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,"SELECT SUM(country.Population) AS total_population, AVG(country.SurfaceArea) AS average_surface_area FROM country WHERE country.Continent = 'North America' AND country.SurfaceArea > 3000;","select sum(population) ,  avg(surfacearea) from country where continent  =  ""north america"" and surfacearea  >  3000",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the total population and average surface area of countries in North America with a surface area greater than 3000. 2. Condition Structure: Use a WHERE clause to filter for countries in the ""North America"" continent and with a surface area greater than 3000. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use SUM to calculate the total population and AVG to calculate the average surface area for the filtered countries.","[(480753000, 1344763.7222222222)]","[(None, None)]",,0.0,
Give the names of countries that are in Europe and have a population equal to 80000.,"[country.Name, country.Continent, country.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT country.Name FROM country WHERE country.Continent = 'Europe' AND country.Population = 80000;,"SELECT Name FROM country WHERE continent  =  ""Europe"" AND Population  =  ""80000""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Name"" of countries that meet the specified conditions. 2. Condition Structure: Use a WHERE clause to filter for countries that are in the ""Europe"" continent and have a population equal to 80000. 3. Join Structure: No JOIN is required since all necessary information is available in the ""country"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific country names based on the given conditions.",[],[],,1.0,
Return the names of cities that have a population between 160000 and 900000 .,"[city.Name, city.Population, 160000, 900000]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT city.Name FROM city WHERE city.Population BETWEEN 160000 AND 900000;,select name from city where population between 160000 and 900000,world_1,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is the ""city.Name"". 2. Condition Structure: Use a WHERE clause to filter cities with a population between 160000 and 900000. 3. Join Structure: No JOIN is required since all necessary information is in the ""city"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving city names that meet the specified population condition.","[('Qandahar',), ('Herat',), ('Amsterdam',), ('Rotterdam',), ('Haag',), ('Utrecht',), ('Eindhoven',), ('Tilburg',), ('Groningen',), ('Breda',), ('Tirana',), ('Oran',), ('Constantine',), ('Annaba',), ('Batna',), ('Sétif',), ('Huambo',), ('Dubai',), ('Abu Dhabi',), ('Sharja',), ('al-Ayn',), ('Lomas de Zamora',), ('Quilmes',), ('Almirante Brown',), ('La Plata',), ('Mar del Plata',), ('San Miguel de Tucumán',), ('Lanús',), ('Merlo',), ('General San Martín',), ('Salta',), ('Moreno',), ('Santa Fé',), ('Avellaneda',), ('Tres de Febrero',), ('Morón',), ('Florencio Varela',), ('San Isidro',), ('Tigre',), ('Malvinas Argentinas',), ('Vicente López',), ('Berazategui',), ('Corrientes',), ('San Miguel',), ('Bahía Blanca',), ('Esteban Echeverría',), ('Resistencia',), ('José C. Paz',), ('Paraná',), ('Godoy Cruz',), ('Posadas',), ('Guaymallén',), ('Santiago del Estero',), ('San Salvador de Jujuy',), ('Hurlingham',), ('Neuquén',), ('Gjumri',), ('Vanadzor',), ('Canberra',), ('Gold Coast',), ('Newcastle',), ('Central Coast',), ('Wollongong',), ('Gäncä',), ('Sumqayit',), ('Nassau',), ('Khulna',), ('Rajshahi',), ('Narayanganj',), ('Rangpur',), ('Mymensingh',), ('Barisal',), ('Tungi',), ('Antwerpen',), ('Gent',), ('Charleroi',), ('Liège',), ('Cotonou',), ('Porto-Novo',), ('La Paz',), ('El Alto',), ('Cochabamba',), ('Oruro',), ('Sucre',), ('Sarajevo',), ('Gaborone',), ('São Gonçalo',), ('Nova Iguaçu',), ('São Luís',), ('Maceió',), ('Duque de Caxias',), ('São Bernardo do Campo',), ('Teresina',), ('Natal',), ('Osasco',), ('Campo Grande',), ('Santo André',), ('João Pessoa',), ('Jaboatão dos Guararapes',), ('Contagem',), ('São José dos Campos',), ('Uberlândia',), ('Feira de Santana',), ('Ribeirão Preto',), ('Sorocaba',), ('Niterói',), ('Cuiabá',), ('Juiz de Fora',), ('Aracaju',), ('São João de Meriti',), ('Londrina',), ('Joinville',), ('Belford Roxo',), ('Santos',), ('Ananindeua',), ('Campos dos Goytacazes',), ('Mauá',), ('Carapicuíba',), ('Olinda',), ('Campina Grande',), ('São José do Rio Preto',), ('Caxias do Sul',), ('Moji das Cruzes',), ('Diadema',), ('Aparecida de Goiânia',), ('Piracicaba',), ('Cariacica',), ('Vila Velha',), ('Pelotas',), ('Bauru',), ('Porto Velho',), ('Serra',), ('Betim',), ('Jundíaí',), ('Canoas',), ('Franca',), ('São Vicente',), ('Maringá',), ('Montes Claros',), ('Anápolis',), ('Florianópolis',), ('Petrópolis',), ('Itaquaquecetuba',), ('Vitória',), ('Ponta Grossa',), ('Rio Branco',), ('Foz do Iguaçu',), ('Macapá',), ('Ilhéus',), ('Vitória da Conquista',), ('Uberaba',), ('Paulista',), ('Limeira',), ('Blumenau',), ('Caruaru',), ('Santarém',), ('Volta Redonda',), ('Novo Hamburgo',), ('Caucaia',), ('Santa Maria',), ('Cascavel',), ('Guarujá',), ('Ribeirão das Neves',), ('Governador Valadares',), ('Taubaté',), ('Imperatriz',), ('Gravataí',), ('Embu',), ('Mossoró',), ('Várzea Grande',), ('Petrolina',), ('Barueri',), ('Viamão',), ('Ipatinga',), ('Juazeiro',), ('Juazeiro do Norte',), ('Taboão da Serra',), ('São José dos Pinhais',), ('Magé',), ('Suzano',), ('São Leopoldo',), ('Marília',), ('São Carlos',), ('Sumaré',), ('Presidente Prudente',), ('Divinópolis',), ('Sete Lagoas',), ('Rio Grande',), ('Itabuna',), ('Jequié',), ('Arapiraca',), ('Colombo',), ('Americana',), ('Alvorada',), ('Araraquara',), ('Itaboraí',), ('Santa Bárbara d´Oeste',), ('Nova Friburgo',), ('Jacareí',), ('Araçatuba',), ('Barra Mansa',), ('Praia Grande',), ('Marabá',), ('Criciúma',), ('Boa Vista',), ('Passo Fundo',), ('Dourados',), ('Santa Luzia',), ('Rio Claro',), ('Maracanaú',), ('Guarapuava',), ('Glasgow',), ('Liverpool',), ('Edinburgh',), ('Sheffield',), ('Manchester',), ('Leeds',), ('Bristol',), ('Cardiff',), ('Coventry',), ('Leicester',), ('Bradford',), ('Belfast',), ('Nottingham',), ('Kingston upon Hull',), ('Plymouth',), ('Stoke-on-Trent',), ('Wolverhampton',), ('Derby',), ('Swansea',), ('Southampton',), ('Aberdeen',), ('Northampton',), ('Dudley',), ('Portsmouth',), ('Newcastle upon Tyne',), ('Sunderland',), ('Luton',), ('Swindon',), ('Southend-on-Sea',), ('Walsall',), ('Bournemouth',), ('Plovdiv',), ('Varna',), ('Burgas',), ('Ruse',), ('Ouagadougou',), ('Bobo-Dioulasso',), ('Bujumbura',), ('Puente Alto',), ('Viña del Mar',), ('Valparaíso',), ('Talcahuano',), ('Antofagasta',), ('San Bernardo',), ('Temuco',), ('Concepción',), ('Rancagua',), ('Arica',), ('Talca',), ('Chillán',), ('Iquique',), ('San José',), ('Djibouti',), ('Santiago de los Caballeros',), ('Cuenca',), ('Machala',), ('Santo Domingo de los Colorados',), ('Portoviejo',), ('Ambato',), ('Manta',), ('Shubra al-Khayma',), ('Port Said',), ('Suez',), ('al-Mahallat al-Kubra',), ('Tanta',), ('al-Mansura',), ('Luxor',), ('Asyut',), ('Bahtim',), ('Zagazig',), ('al-Faiyum',), ('Ismailia',), ('Kafr al-Dawwar',), ('Assuan',), ('Damanhur',), ('al-Minya',), ('Bani Suwayf',), ('Qina',), ('Sawhaj',), ('San Salvador',), ('Asmara',), ('Valencia',), ('Sevilla',), ('Zaragoza',), ('Málaga',), ('Bilbao',), ('Las Palmas de Gran Canaria',), ('Murcia',), ('Palma de Mallorca',), ('Valladolid',), ('Córdoba',), ('Vigo',), ('Alicante [Alacant]',), ('Gijón',), ('L´Hospitalet de Llobregat',), ('Granada',), ('A Coruña (La Coruña)',), ('Vitoria-Gasteiz',), ('Santa Cruz de Tenerife',), ('Badalona',), ('Oviedo',), ('Móstoles',), ('Elche [Elx]',), ('Sabadell',), ('Santander',), ('Jerez de la Frontera',), ('Pamplona [Iruña]',), ('Donostia-San Sebastián',), ('Cartagena',), ('Leganés',), ('Fuenlabrada',), ('Almería',), ('Terrassa',), ('Alcalá de Henares',), ('Burgos',), ('Johannesburg',), ('Port Elizabeth',), ('Pretoria',), ('Inanda',), ('Durban',), ('Vanderbijlpark',), ('Kempton Park',), ('Alberton',), ('Pinetown',), ('Pietermaritzburg',), ('Benoni',), ('Randburg',), ('Umlazi',), ('Bloemfontein',), ('Vereeniging',), ('Wonderboom',), ('Roodepoort',), ('Boksburg',), ('Klerksdorp',), ('Soshanguve',), ('Newcastle',), ('East London',), ('Welkom',), ('Kimberley',), ('Uitenhage',), ('Chatsworth',), ('Mdantsane',), ('Krugersdorp',), ('Botshabelo',), ('Brakpan',), ('Witbank',), ('Oberholzer',), ('Germiston',), ('Springs',), ('Dire Dawa',), ('Cebu',), ('Zamboanga',), ('Pasig',), ('Valenzuela',), ('Las Piñas',), ('Antipolo',), ('Taguig',), ('Cagayan de Oro',), ('Parañaque',), ('Makati',), ('Bacolod',), ('General Santos',), ('Marikina',), ('Dasmariñas',), ('Muntinlupa',), ('Iloilo',), ('Pasay',), ('Malabon',), ('San José del Monte',), ('Bacoor',), ('Iligan',), ('Calamba',), ('Mandaluyong',), ('Butuan',), ('Angeles',), ('Tarlac',), ('Mandaue',), ('Baguio',), ('Batangas',), ('Cainta',), ('San Pedro',), ('Navotas',), ('Cabanatuan',), ('San Fernando',), ('Lipa',), ('Lapu-Lapu',), ('San Pablo',), ('Biñan',), ('Taytay',), ('Lucena',), ('Imus',), ('Olongapo',), ('Binangonan',), ('Santa Rosa',), ('Tagum',), ('Tacloban',), ('Malolos',), ('Mabalacat',), ('Cotabato',), ('Meycauayan',), ('Puerto Princesa',), ('Libreville',), ('Kutaisi',), ('Kumasi',), ('Ciudad de Guatemala',), ('Mixco',), ('Bissau',), ('Georgetown',), ('Port-au-Prince',), ('Carrefour',), ('Delmas',), ('Tegucigalpa',), ('San Pedro Sula',), ('Malang',), ('Bandar Lampung',), ('Bekasi',), ('Padang',), ('Surakarta',), ('Banjarmasin',), ('Pekan Baru',), ('Denpasar',), ('Yogyakarta',), ('Pontianak',), ('Samarinda',), ('Jambi',), ('Depok',), ('Cimahi',), ('Balikpapan',), ('Manado',), ('Mataram',), ('Pekalongan',), ('Tegal',), ('Bogor',), ('Ciputat',), ('Pondokgede',), ('Cirebon',), ('Kediri',), ('Ambon',), ('Jember',), ('Cilacap',), ('Cimanggis',), ('Pematang Siantar',), ('Purwokerto',), ('Ciomas',), ('Tasikmalaya',), ('Madiun',), ('Srinagar',), ('Agra',), ('Coimbatore',), ('Thane (Thana)',), ('Allahabad',), ('Meerut',), ('Vishakhapatnam',), ('Jabalpur',), ('Amritsar',), ('Faridabad',), ('Vijayawada',), ('Gwalior',), ('Jodhpur',), ('Nashik (Nasik)',), ('Hubli-Dharwad',), ('Solapur (Sholapur)',), ('Ranchi',), ('Bareilly',), ('Guwahati (Gauhati)',), ('Shambajinagar (Aurangabad)',), ('Cochin (Kochi)',), ('Rajkot',), ('Kota',), ('Thiruvananthapuram (Trivandrum',), ('Pimpri-Chinchwad',), ('Jalandhar (Jullundur)',), ('Gorakhpur',), ('Chandigarh',), ('Mysore',), ('Aligarh',), ('Guntur',), ('Jamshedpur',), ('Ghaziabad',), ('Warangal',), ('Raipur',), ('Moradabad',), ('Durgapur',), ('Amravati',), ('Calicut (Kozhikode)',), ('Bikaner',), ('Bhubaneswar',), ('Kolhapur',), ('Kataka (Cuttack)',), ('Ajmer',), ('Bhavnagar',), ('Tiruchirapalli',), ('Bhilai',), ('Bhiwandi',), ('Saharanpur',), ('Ulhasnagar',), ('Salem',), ('Ujjain',), ('Malegaon',), ('Jamnagar',), ('Bokaro Steel City',), ('Akola',), ('Belgaum',), ('Rajahmundry',), ('Nellore',), ('Udaipur',), ('New Bombay',), ('Bhatpara',), ('Gulbarga',), ('New Delhi',), ('Jhansi',), ('Gaya',), ('Kakinada',), ('Dhule (Dhulia)',), ('Panihati',), ('Nanded (Nander)',), ('Mangalore',), ('Dehra Dun',), ('Kamarhati',), ('Davangere',), ('Asansol',), ('Bhagalpur',), ('Bellary',), ('Barddhaman (Burdwan)',), ('Rampur',), ('Jalgaon',), ('Muzaffarpur',), ('Nizamabad',), ('Muzaffarnagar',), ('Patiala',), ('Shahjahanpur',), ('Kurnool',), ('Tiruppur (Tirupper)',), ('Rohtak',), ('South Dum Dum',), ('Mathura',), ('Chandrapur',), ('Barahanagar (Baranagar)',), ('Darbhanga',), ('Siliguri (Shiliguri)',), ('Raurkela',), ('Ambattur',), ('Panipat',), ('Firozabad',), ('Ichalkaranji',), ('Jammu',), ('Ramagundam',), ('Eluru',), ('Brahmapur',), ('Alwar',), ('Pondicherry',), ('Thanjavur',), ('Bihar Sharif',), ('Tuticorin',), ('Imphal',), ('Latur',), ('Sagar',), ('Farrukhabad-cum-Fatehgarh',), ('Sangli',), ('Parbhani',), ('Nagar Coil',), ('Bijapur',), ('Kukatpalle',), ('Bally',), ('Bhilwara',), ('Ratlam',), ('Avadi',), ('Dindigul',), ('Ahmadnagar',), ('Bilaspur',), ('Shimoga',), ('Kharagpur',), ('Mira Bhayandar',), ('Vellore',), ('Jalna',), ('Burnpur',), ('Anantapur',), ('Allappuzha (Alleppey)',), ('Tirupati',), ('Karnal',), ('Burhanpur',), ('Hisar (Hissar)',), ('Tiruvottiyur',), ('Mirzapur-cum-Vindhyachal',), ('Secunderabad',), ('Nadiad',), ('Dewas',), ('Murwara (Katni)',), ('Ganganagar',), ('Vizianagaram',), ('Mosul',), ('Irbil',), ('Kirkuk',), ('Basra',), ('al-Sulaymaniya',), ('al-Najaf',), ('Karbala',), ('al-Hilla',), ('al-Nasiriya',), ('al-Amara',), ('al-Diwaniya',), ('al-Ramadi',), ('al-Kut',), ('Ahvaz',), ('Qom',), ('Kermanshah',), ('Urmia',), ('Zahedan',), ('Rasht',), ('Hamadan',), ('Kerman',), ('Arak',), ('Ardebil',), ('Yazd',), ('Qazvin',), ('Zanjan',), ('Sanandaj',), ('Bandar-e-Abbas',), ('Khorramabad',), ('Eslamshahr',), ('Borujerd',), ('Abadan',), ('Dezful',), ('Kashan',), ('Sari',), ('Gorgan',), ('Najafabad',), ('Sabzevar',), ('Khomeynishahr',), ('Dublin',), ('Jerusalem',), ('Tel Aviv-Jaffa',), ('Haifa',), ('Rishon Le Ziyyon',), ('Beerseba',), ('Holon',), ('Palermo',), ('Genova',), ('Bologna',), ('Firenze',), ('Catania',), ('Bari',), ('Venezia',), ('Messina',), ('Verona',), ('Trieste',), ('Padova',), ('Taranto',), ('Brescia',), ('Reggio di Calabria',), ('Modena',), ('Prato',), ('Parma',), ('Cagliari',), ('Livorno',), ('Graz',), ('Linz',), ('Chiba',), ('Sakai',), ('Kumamoto',), ('Okayama',), ('Sagamihara',), ('Hamamatsu',), ('Kagoshima',), ('Funabashi',), ('Higashiosaka',), ('Hachioji',), ('Niigata',), ('Amagasaki',), ('Himeji',), ('Shizuoka',), ('Urawa',), ('Matsuyama',), ('Matsudo',), ('Kanazawa',), ('Kawaguchi',), ('Ichikawa',), ('Omiya',), ('Utsunomiya',), ('Oita',), ('Nagasaki',), ('Yokosuka',), ('Kurashiki',), ('Gifu',), ('Hirakata',), ('Nishinomiya',), ('Toyonaka',), ('Wakayama',), ('Fukuyama',), ('Fujisawa',), ('Asahikawa',), ('Machida',), ('Nara',), ('Takatsuki',), ('Iwaki',), ('Nagano',), ('Toyohashi',), ('Toyota',), ('Suita',), ('Takamatsu',), ('Koriyama',), ('Okazaki',), ('Kawagoe',), ('Tokorozawa',), ('Toyama',), ('Kochi',), ('Kashiwa',), ('Akita',), ('Miyazaki',), ('Koshigaya',), ('Naha',), ('Aomori',), ('Hakodate',), ('Akashi',), ('Yokkaichi',), ('Fukushima',), ('Morioka',), ('Maebashi',), ('Kasugai',), ('Otsu',), ('Ichihara',), ('Yao',), ('Ichinomiya',), ('Tokushima',), ('Kakogawa',), ('Ibaraki',), ('Neyagawa',), ('Shimonoseki',), ('Yamagata',), ('Fukui',), ('Hiratsuka',), ('Mito',), ('Sasebo',), ('Hachinohe',), ('Takasaki',), ('Shimizu',), ('Kurume',), ('Fuji',), ('Soka',), ('Fuchu',), ('Chigasaki',), ('Atsugi',), ('Numazu',), ('Ageo',), ('Yamato',), ('Matsumoto',), ('Kure',), ('Takarazuka',), ('Kasukabe',), ('Chofu',), ('Odawara',), ('Kofu',), ('Kushiro',), ('Kishiwada',), ('Hitachi',), ('Nagaoka',), ('Itami',), ('Uji',), ('Suzuka',), ('Hirosaki',), ('Ube',), ('Kodaira',), ('Takaoka',), ('Obihiro',), ('Tomakomai',), ('Saga',), ('Sakura',), ('Kamakura',), ('Mitaka',), ('Izumi',), ('Hino',), ('Hadano',), ('Ashikaga',), ('Tsu',), ('Sayama',), ('Yachiyo',), ('Tsukuba',), ('Sanaa',), ('Aden',), ('Taizz',), ('Hodeida',), ('al-Zarqa',), ('Irbid',), ('Novi Sad',), ('Niš',), ('Phnom Penh',), ('Garoua',), ('Calgary',), ('Toronto',), ('North York',), ('Winnipeg',), ('Edmonton',), ('Mississauga',), ('Scarborough',), ('Vancouver',), ('Etobicoke',), ('London',), ('Hamilton',), ('Ottawa',), ('Laval',), ('Surrey',), ('Brampton',), ('Windsor',), ('Saskatoon',), ('Kitchener',), ('Markham',), ('Regina',), ('Burnaby',), ('Québec',), ('Qaraghandy',), ('Shymkent',), ('Taraz',), ('Astana',), ('Öskemen',), ('Pavlodar',), ('Semey',), ('Aqtöbe',), ('Qostanay',), ('Petropavl',), ('Oral',), ('Temirtau',), ('Mombasa',), ('Kisumu',), ('Nakuru',), ('Bangui',), ('Handan',), ('Wuxi',), ('Xuzhou',), ('Datong',), ('Yichun',), ('Benxi',), ('Luoyang',), ('Suzhou',), ('Xining',), ('Huainan',), ('Jixi',), ('Daqing',), ('Fuxin',), ('Amoy [Xiamen]',), ('Liuzhou',), ('Shantou',), ('Jinzhou',), ('Mudanjiang',), ('Yinchuan',), ('Changzhou',), ('Zhangjiakou',), ('Dandong',), ('Hegang',), ('Kaifeng',), ('Jiamusi',), ('Liaoyang',), ('Hengyang',), ('Baoding',), ('Hunjiang',), ('Xinxiang',), ('Huangshi',), ('Haikou',), ('Yantai',), ('Bengbu',), ('Xiangtan',), ('Weifang',), ('Wuhu',), ('Pingxiang',), ('Yingkou',), ('Anyang',), ('Panzhihua',), ('Pingdingshan',), ('Xiangfan',), ('Zhuzhou',), ('Jiaozuo',), ('Wenzhou',), ('Zhangjiang',), ('Zigong',), ('Shuangyashan',), ('Zaozhuang',), ('Yakeshi',), ('Yichang',), ('Zhenjiang',), ('Huaibei',), ('Qinhuangdao',), ('Guilin',), ('Liupanshui',), ('Panjin',), ('Yangquan',), ('Jinxi',), ('Liaoyuan',), ('Lianyungang',), ('Xianyang',), ('Tai´an',), ('Chifeng',), ('Shaoguan',), ('Nantong',), ('Leshan',), ('Baoji',), ('Linyi',), ('Tonghua',), ('Siping',), ('Changzhi',), ('Tengzhou',), ('Chaozhou',), ('Yangzhou',), ('Dongwan',), ('Ma´anshan',), ('Foshan',), ('Yueyang',), ('Xingtai',), ('Changde',), ('Shihezi',), ('Yancheng',), ('Jiujiang',), ('Dongying',), ('Shashi',), ('Xintai',), ('Jingdezhen',), ('Tongchuan',), ('Zhongshan',), ('Shiyan',), ('Tieli',), ('Jining',), ('Wuhai',), ('Mianyang',), ('Luzhou',), ('Zunyi',), ('Shizuishan',), ('Neijiang',), ('Tongliao',), ('Tieling',), ('Wafangdian',), ('Anqing',), ('Shaoyang',), ('Laiwu',), ('Chengde',), ('Tianshui',), ('Nanyang',), ('Cangzhou',), ('Yibin',), ('Huaiyin',), ('Dunhua',), ('Yanji',), ('Jiangmen',), ('Tongling',), ('Suihua',), ('Gongziling',), ('Xiantao',), ('Chaoyang',), ('Ganzhou',), ('Huzhou',), ('Baicheng',), ('Shangzi',), ('Yangjiang',), ('Qitaihe',), ('Gejiu',), ('Jiangyin',), ('Hebi',), ('Jiaxing',), ('Wuzhou',), ('Meihekou',), ('Xuchang',), ('Liaocheng',), ('Haicheng',), ('Qianjiang',), ('Baiyin',), ('Bei´an',), ('Yixing',), ('Laizhou',), ('Qaramay',), ('Acheng',), ('Dezhou',), ('Nanping',), ('Zhaoqing',), ('Beipiao',), ('Fengcheng',), ('Fuyu',), ('Xinyang',), ('Dongtai',), ('Yuci',), ('Honghu',), ('Ezhou',), ('Heze',), ('Daxian',), ('Linfen',), ('Tianmen',), ('Yiyang',), ('Quanzhou',), ('Rizhao',), ('Deyang',), ('Guangyuan',), ('Changshu',), ('Zhangzhou',), ('Hailar',), ('Nanchong',), ('Jiutai',), ('Zhaodong',), ('Shaoxing',), ('Fuyang',), ('Maoming',), ('Qujing',), ('Ghulja',), ('Jiaohe',), ('Puyang',), ('Huadian',), ('Jiangyou',), ('Qashqar',), ('Anshun',), ('Fuling',), ('Xinyu',), ('Hanzhong',), ('Danyang',), ('Chenzhou',), ('Xiaogan',), ('Shangqiu',), ('Zhuhai',), ('Qingyuan',), ('Aqsu',), ('Jining',), ('Xiaoshan',), ('Zaoyang',), ('Xinghua',), ('Hami',), ('Huizhou',), ('Jinmen',), ('Sanming',), ('Bishkek',), ('Osh',), ('Cartagena',), ('Cúcuta',), ('Bucaramanga',), ('Ibagué',), ('Pereira',), ('Santa Marta',), ('Manizales',), ('Bello',), ('Pasto',), ('Neiva',), ('Soledad',), ('Armenia',), ('Villavicencio',), ('Soacha',), ('Valledupar',), ('Montería',), ('Itagüí',), ('Palmira',), ('Buenaventura',), ('Floridablanca',), ('Sincelejo',), ('Popayán',), ('Barrancabermeja',), ('Pointe-Noire',), ('Lubumbashi',), ('Mbuji-Mayi',), ('Kolwezi',), ('Kisangani',), ('Kananga',), ('Likasi',), ('Bukavu',), ('Kikwit',), ('Tshikapa',), ('Matadi',), ('Mbandaka',), ('Hamhung',), ('Chongjin',), ('Nampo',), ('Sinuiju',), ('Wonsan',), ('Phyongsong',), ('Sariwon',), ('Haeju',), ('Kanggye',), ('Kimchaek',), ('Hyesan',), ('Kaesong',), ('Songnam',), ('Puchon',), ('Suwon',), ('Anyang',), ('Chonju',), ('Chongju',), ('Koyang',), ('Ansan',), ('Pohang',), ('Chang-won',), ('Masan',), ('Kwangmyong',), ('Chonan',), ('Chinju',), ('Iksan',), ('Pyongtaek',), ('Kumi',), ('Uijongbu',), ('Kyongju',), ('Kunsan',), ('Cheju',), ('Kimhae',), ('Sunchon',), ('Mokpo',), ('Yong-in',), ('Wonju',), ('Kunpo',), ('Chunchon',), ('Namyangju',), ('Kangnung',), ('Chungju',), ('Andong',), ('Yosu',), ('Kyongsan',), ('Paju',), ('Yangsan',), ('Athenai',), ('Thessaloniki',), ('Pireus',), ('Zagreb',), ('Split',), ('Rijeka',), ('Santiago de Cuba',), ('Camagüey',), ('Holguín',), ('Santa Clara',), ('Guantánamo',), ('Nicosia',), ('Vientiane',), ('Riga',), ('Maseru',), ('Tripoli',), ('Monrovia',), ('Bengasi',), ('Vilnius',), ('Kaunas',), ('Klaipeda',), ('El-Aaiún',), ('Macao',), ('Antananarivo',), ('Skopje',), ('Blantyre',), ('Lilongwe',), ('Ipoh',), ('Johor Baharu',), ('Petaling Jaya',), ('Kelang',), ('Kuala Terengganu',), ('Pinang',), ('Kota Bharu',), ('Kuantan',), ('Taiping',), ('Seremban',), ('Bamako',), ('Rabat',), ('Marrakech',), ('Fès',), ('Tanger',), ('Salé',), ('Meknès',), ('Oujda',), ('Kénitra',), ('Tétouan',), ('Safi',), ('Nouakchott',), ('Naucalpan de Juárez',), ('Mexicali',), ('Culiacán',), ('Acapulco de Juárez',), ('Tlalnepantla de Baz',), ('Mérida',), ('Chihuahua',), ('San Luis Potosí',), ('Guadalupe',), ('Toluca',), ('Aguascalientes',), ('Querétaro',), ('Morelia',), ('Hermosillo',), ('Saltillo',), ('Torreón',), ('Centro (Villahermosa)',), ('San Nicolás de los Garza',), ('Durango',), ('Chimalhuacán',), ('Tlaquepaque',), ('Atizapán de Zaragoza',), ('Veracruz',), ('Cuautitlán Izcalli',), ('Irapuato',), ('Tuxtla Gutiérrez',), ('Tultitlán',), ('Reynosa',), ('Benito Juárez',), ('Matamoros',), ('Xalapa',), ('Celaya',), ('Mazatlán',), ('Ensenada',), ('Ahome',), ('Cajeme',), ('Cuernavaca',), ('Tonalá',), ('Valle de Chalco Solidaridad',), ('Nuevo Laredo',), ('Tepic',), ('Tampico',), ('Ixtapaluca',), ('Apodaca',), ('Guasave',), ('Gómez Palacio',), ('Tapachula',), ('Nicolás Romero',), ('Coatzacoalcos',), ('Uruapan',), ('Victoria',), ('Oaxaca de Juárez',), ('Coacalco de Berriozábal',), ('Pachuca de Soto',), ('General Escobedo',), ('Salamanca',), ('Santa Catarina',), ('Tehuacán',), ('Chalco',), ('Cárdenas',), ('Campeche',), ('La Paz',), ('Othón P. Blanco (Chetumal)',), ('Texcoco',), ('La Paz',), ('Metepec',), ('Monclova',), ('Huixquilucan',), ('Chilpancingo de los Bravo',), ('Puerto Vallarta',), ('Fresnillo',), ('Ciudad Madero',), ('Soledad de Graciano Sánchez',), ('San Juan del Río',), ('San Felipe del Progreso',), ('Córdoba',), ('Tecámac',), ('Ocosingo',), ('Carmen',), ('Lázaro Cárdenas',), ('Jiutepec',), ('Papantla',), ('Comalcalco',), ('Zamora',), ('Chisinau',), ('Tiraspol',), ('Ulan Bator',), ('Matola',), ('Beira',), ('Nampula',), ('Chimoio',), ('Mandalay',), ('Moulmein (Mawlamyine)',), ('Pegu (Bago)',), ('Bassein (Pathein)',), ('Windhoek',), ('Kathmandu',), ('Niamey',), ('Ogbomosho',), ('Kano',), ('Oshogbo',), ('Ilorin',), ('Abeokuta',), ('Port Harcourt',), ('Zaria',), ('Ilesha',), ('Onitsha',), ('Iwo',), ('Ado-Ekiti',), ('Abuja',), ('Kaduna',), ('Mushin',), ('Maiduguri',), ('Enugu',), ('Ede',), ('Aba',), ('Ife',), ('Ila',), ('Oyo',), ('Ikerre',), ('Benin City',), ('Iseyin',), ('Katsina',), ('Jos',), ('Sokoto',), ('Ilobu',), ('Offa',), ('Ikorodu',), ('Ilawe-Ekiti',), ('Owo',), ('Ikirun',), ('Shaki',), ('Calabar',), ('Ondo',), ('Akure',), ('Oslo',), ('Bergen',), ('Bouaké',), ('Quetta',), ('Islamabad',), ('Sargodha',), ('Sialkot',), ('Bahawalpur',), ('Sukkur',), ('Jhang',), ('Sheikhupura',), ('Larkana',), ('Gujrat',), ('Mardan',), ('Kasur',), ('Rahim Yar Khan',), ('Sahiwal',), ('Okara',), ('Wah',), ('Dera Ghazi Khan',), ('Mirpur Khas',), ('Nawabshah',), ('Mingora',), ('Chiniot',), ('Ciudad de Panamá',), ('San Miguelito',), ('Port Moresby',), ('Asunción',), ('Arequipa',), ('Trujillo',), ('Chiclayo',), ('Callao',), ('Iquitos',), ('Chimbote',), ('Huancayo',), ('Piura',), ('Cusco',), ('Pucallpa',), ('Tacna',), ('Ica',), ('Lisboa',), ('Porto',), ('San Juan',), ('Bayamón',), ('Ponce',), ('Carolina',), ('Lódz',), ('Kraków',), ('Wroclaw',), ('Poznan',), ('Gdansk',), ('Szczecin',), ('Bydgoszcz',), ('Lublin',), ('Katowice',), ('Bialystok',), ('Czestochowa',), ('Gdynia',), ('Sosnowiec',), ('Radom',), ('Kielce',), ('Gliwice',), ('Torun',), ('Bytom',), ('Zabrze',), ('Bielsko-Biala',), ('Olsztyn',), ('Rzeszów',), ('Doha',), ('Marseille',), ('Lyon',), ('Toulouse',), ('Nice',), ('Nantes',), ('Strasbourg',), ('Montpellier',), ('Bordeaux',), ('Rennes',), ('Le Havre',), ('Reims',), ('Lille',), ('St-Étienne',), ('Toulon',), ('Iasi',), ('Constanta',), ('Cluj-Napoca',), ('Galati',), ('Timisoara',), ('Brasov',), ('Craiova',), ('Ploiesti',), ('Braila',), ('Oradea',), ('Bacau',), ('Pitesti',), ('Arad',), ('Sibiu',), ('Târgu Mures',), ('Kigali',), ('Stockholm',), ('Gothenburg [Göteborg]',), ('Malmö',), ('Uppsala',), ('Frankfurt am Main',), ('Essen',), ('Dortmund',), ('Stuttgart',), ('Düsseldorf',), ('Bremen',), ('Duisburg',), ('Hannover',), ('Leipzig',), ('Nürnberg',), ('Dresden',), ('Bochum',), ('Wuppertal',), ('Bielefeld',), ('Mannheim',), ('Bonn',), ('Gelsenkirchen',), ('Karlsruhe',), ('Wiesbaden',), ('Münster',), ('Mönchengladbach',), ('Chemnitz',), ('Augsburg',), ('Halle/Saale',), ('Braunschweig',), ('Aachen',), ('Krefeld',), ('Magdeburg',), ('Kiel',), ('Oberhausen',), ('Lübeck',), ('Hagen',), ('Rostock',), ('Freiburg im Breisgau',), ('Erfurt',), ('Kassel',), ('Saarbrücken',), ('Mainz',), ('Hamm',), ('Herne',), ('Mülheim an der Ruhr',), ('Solingen',), ('Osnabrück',), ('Ludwigshafen am Rhein',), ('Leverkusen',), ('Ndola',), ('Kitwe',), ('Medina',), ('al-Dammam',), ('al-Taif',), ('Tabuk',), ('Burayda',), ('al-Hufuf',), ('al-Mubarraz',), ('Khamis Mushayt',), ('Hail',), ('Pikine',), ('Dakar',), ('Thiès',), ('Kaolack',), ('Ziguinchor',), ('Freetown',), ('Bratislava',), ('Košice',), ('Ljubljana',), ('Colombo',), ('Dehiwala',), ('Moratuwa',), ('Sharq al-Nil',), ('Port Sudan',), ('Kassala',), ('Obeid',), ('Nyala',), ('Wad Madani',), ('al-Qadarif',), ('Kusti',), ('Helsinki [Helsingfors]',), ('Espoo',), ('Tampere',), ('Vantaa',), ('Turku [Åbo]',), ('Zürich',), ('Geneve',), ('Basel',), ('Hims',), ('Hama',), ('Latakia',), ('Dushanbe',), ('Khujand',), ('Tainan',), ('Panchiao',), ('Chungho',), ('Keelung (Chilung)',), ('Sanchung',), ('Hsinchuang',), ('Hsinchu',), ('Chungli',), ('Fengshan',), ('Taoyuan',), ('Chiayi',), ('Hsintien',), ('Changhwa',), ('Yungho',), ('Tucheng',), ('Pingtung',), ('Yungkang',), ('Pingchen',), ('Tali',), ('Taiping',), ('Pate',), ('Fengyuan',), ('Luchou',), ('Dodoma',), ('Mwanza',), ('København',), ('Århus',), ('Odense',), ('Aalborg',), ('Nonthaburi',), ('Nakhon Ratchasima',), ('Chiang Mai',), ('Lomé',), ('N´Djaména',), ('Brno',), ('Ostrava',), ('Plzen',), ('Tunis',), ('Sfax',), ('Ariana',), ('Ettadhamen',), ('Gaziantep',), ('Konya',), ('Mersin (Içel)',), ('Antalya',), ('Diyarbakir',), ('Kayseri',), ('Eskisehir',), ('Sanliurfa',), ('Samsun',), ('Malatya',), ('Gebze',), ('Denizli',), ('Sivas',), ('Erzurum',), ('Tarsus',), ('Kahramanmaras',), ('Elâzig',), ('Van',), ('Sultanbeyli',), ('Izmit (Kocaeli)',), ('Manisa',), ('Batman',), ('Balikesir',), ('Sakarya (Adapazari)',), ('Ashgabat',), ('Chärjew',), ('Kampala',), ('Zaporizzja',), ('Lviv',), ('Kryvyi Rig',), ('Mykolajiv',), ('Mariupol',), ('Lugansk',), ('Vinnytsja',), ('Makijivka',), ('Herson',), ('Sevastopol',), ('Simferopol',), ('Pultava [Poltava]',), ('Tšernigiv',), ('Tšerkasy',), ('Gorlivka',), ('Zytomyr',), ('Sumy',), ('Dniprodzerzynsk',), ('Kirovograd',), ('Hmelnytskyi',), ('Tšernivtsi',), ('Rivne',), ('Krementšuk',), ('Ivano-Frankivsk',), ('Ternopil',), ('Lutsk',), ('Bila Tserkva',), ('Kramatorsk',), ('Melitopol',), ('Kertš',), ('Debrecen',), ('Miskolc',), ('Auckland',), ('Christchurch',), ('Manukau',), ('North Shore',), ('Waitakere',), ('Wellington',), ('Namangan',), ('Samarkand',), ('Andijon',), ('Buhoro',), ('Karsi',), ('Nukus',), ('Kükon',), ('Fargona',), ('Gomel',), ('Mogiljov',), ('Vitebsk',), ('Grodno',), ('Brest',), ('Bobruisk',), ('Baranovitši',), ('Barquisimeto',), ('Valencia',), ('Ciudad Guayana',), ('Petare',), ('Maracay',), ('Barcelona',), ('Maturín',), ('San Cristóbal',), ('Ciudad Bolívar',), ('Cumaná',), ('Mérida',), ('Cabimas',), ('Barinas',), ('Turmero',), ('Baruta',), ('Puerto Cabello',), ('Santa Ana de Coro',), ('Los Teques',), ('Punto Fijo',), ('Guarenas',), ('Krasnojarsk',), ('Saratov',), ('Toljatti',), ('Uljanovsk',), ('Izevsk',), ('Krasnodar',), ('Jaroslavl',), ('Habarovsk',), ('Vladivostok',), ('Irkutsk',), ('Barnaul',), ('Novokuznetsk',), ('Penza',), ('Rjazan',), ('Orenburg',), ('Lipetsk',), ('Nabereznyje Tšelny',), ('Tula',), ('Tjumen',), ('Kemerovo',), ('Astrahan',), ('Tomsk',), ('Kirov',), ('Ivanovo',), ('Tšeboksary',), ('Brjansk',), ('Tver',), ('Kursk',), ('Magnitogorsk',), ('Kaliningrad',), ('Nizni Tagil',), ('Murmansk',), ('Ulan-Ude',), ('Kurgan',), ('Arkangeli',), ('Sotši',), ('Smolensk',), ('Orjol',), ('Stavropol',), ('Belgorod',), ('Kaluga',), ('Vladimir',), ('Mahatškala',), ('Tšerepovets',), ('Saransk',), ('Tambov',), ('Vladikavkaz',), ('Tšita',), ('Vologda',), ('Veliki Novgorod',), ('Komsomolsk-na-Amure',), ('Kostroma',), ('Volzski',), ('Taganrog',), ('Petroskoi',), ('Bratsk',), ('Dzerzinsk',), ('Surgut',), ('Orsk',), ('Sterlitamak',), ('Angarsk',), ('Joškar-Ola',), ('Rybinsk',), ('Prokopjevsk',), ('Niznevartovsk',), ('Naltšik',), ('Syktyvkar',), ('Severodvinsk',), ('Bijsk',), ('Niznekamsk',), ('Blagoveštšensk',), ('Šahty',), ('Staryi Oskol',), ('Zelenograd',), ('Balakovo',), ('Novorossijsk',), ('Pihkova',), ('Zlatoust',), ('Jakutsk',), ('Podolsk',), ('Petropavlovsk-Kamtšatski',), ('Kamensk-Uralski',), ('Engels',), ('Syzran',), ('Grozny',), ('Novotšerkassk',), ('Berezniki',), ('Juzno-Sahalinsk',), ('Volgodonsk',), ('Abakan',), ('Maikop',), ('Miass',), ('Armavir',), ('Ljubertsy',), ('Rubtsovsk',), ('Haiphong',), ('Da Nang',), ('Biên Hoa',), ('Nha Trang',), ('Hue',), ('Can Tho',), ('Cam Pha',), ('Nam Dinh',), ('Quy Nhon',), ('Tallinn',), ('San Jose',), ('Indianapolis',), ('San Francisco',), ('Jacksonville',), ('Columbus',), ('Austin',), ('Baltimore',), ('Memphis',), ('Milwaukee',), ('Boston',), ('Washington',), ('Nashville-Davidson',), ('El Paso',), ('Seattle',), ('Denver',), ('Charlotte',), ('Fort Worth',), ('Portland',), ('Oklahoma City',), ('Tucson',), ('New Orleans',), ('Las Vegas',), ('Cleveland',), ('Long Beach',), ('Albuquerque',), ('Kansas City',), ('Fresno',), ('Virginia Beach',), ('Atlanta',), ('Sacramento',), ('Oakland',), ('Mesa',), ('Tulsa',), ('Omaha',), ('Minneapolis',), ('Honolulu',), ('Miami',), ('Colorado Springs',), ('Saint Louis',), ('Wichita',), ('Santa Ana',), ('Pittsburgh',), ('Arlington',), ('Cincinnati',), ('Anaheim',), ('Toledo',), ('Tampa',), ('Buffalo',), ('Saint Paul',), ('Corpus Christi',), ('Aurora',), ('Raleigh',), ('Newark',), ('Lexington-Fayette',), ('Anchorage',), ('Louisville',), ('Riverside',), ('Saint Petersburg',), ('Bakersfield',), ('Stockton',), ('Birmingham',), ('Jersey City',), ('Norfolk',), ('Baton Rouge',), ('Hialeah',), ('Lincoln',), ('Greensboro',), ('Plano',), ('Rochester',), ('Glendale',), ('Akron',), ('Garland',), ('Madison',), ('Fort Wayne',), ('Fremont',), ('Scottsdale',), ('Montgomery',), ('Shreveport',), ('Augusta-Richmond County',), ('Lubbock',), ('Chesapeake',), ('Mobile',), ('Des Moines',), ('Grand Rapids',), ('Richmond',), ('Yonkers',), ('Spokane',), ('Glendale',), ('Tacoma',), ('Irving',), ('Huntington Beach',), ('Modesto',), ('Durham',), ('Columbus',), ('Orlando',), ('Boise City',), ('Winston-Salem',), ('San Bernardino',), ('Jackson',), ('Little Rock',), ('Salt Lake City',), ('Reno',), ('Newport News',), ('Chandler',), ('Laredo',), ('Henderson',), ('Arlington',), ('Knoxville',), ('Amarillo',), ('Providence',), ('Chula Vista',), ('Worcester',), ('Oxnard',), ('Dayton',), ('Garden Grove',), ('Oceanside',), ('Bulawayo',), ('Chitungwiza',), ('Mount Darwin',), ('Gaza',)]","[('Qandahar',), ('Herat',), ('Amsterdam',), ('Rotterdam',), ('Haag',), ('Utrecht',), ('Eindhoven',), ('Tilburg',), ('Groningen',), ('Breda',), ('Tirana',), ('Oran',), ('Constantine',), ('Annaba',), ('Batna',), ('Sétif',), ('Huambo',), ('Dubai',), ('Abu Dhabi',), ('Sharja',), ('al-Ayn',), ('Lomas de Zamora',), ('Quilmes',), ('Almirante Brown',), ('La Plata',), ('Mar del Plata',), ('San Miguel de Tucumán',), ('Lanús',), ('Merlo',), ('General San Martín',), ('Salta',), ('Moreno',), ('Santa Fé',), ('Avellaneda',), ('Tres de Febrero',), ('Morón',), ('Florencio Varela',), ('San Isidro',), ('Tigre',), ('Malvinas Argentinas',), ('Vicente López',), ('Berazategui',), ('Corrientes',), ('San Miguel',), ('Bahía Blanca',), ('Esteban Echeverría',), ('Resistencia',), ('José C. Paz',), ('Paraná',), ('Godoy Cruz',), ('Posadas',), ('Guaymallén',), ('Santiago del Estero',), ('San Salvador de Jujuy',), ('Hurlingham',), ('Neuquén',), ('Gjumri',), ('Vanadzor',), ('Canberra',), ('Gold Coast',), ('Newcastle',), ('Central Coast',), ('Wollongong',), ('Gäncä',), ('Sumqayit',), ('Nassau',), ('Khulna',), ('Rajshahi',), ('Narayanganj',), ('Rangpur',), ('Mymensingh',), ('Barisal',), ('Tungi',), ('Antwerpen',), ('Gent',), ('Charleroi',), ('Liège',), ('Cotonou',), ('Porto-Novo',), ('La Paz',), ('El Alto',), ('Cochabamba',), ('Oruro',), ('Sucre',), ('Sarajevo',), ('Gaborone',), ('São Gonçalo',), ('Nova Iguaçu',), ('São Luís',), ('Maceió',), ('Duque de Caxias',), ('São Bernardo do Campo',), ('Teresina',), ('Natal',), ('Osasco',), ('Campo Grande',), ('Santo André',), ('João Pessoa',), ('Jaboatão dos Guararapes',), ('Contagem',), ('São José dos Campos',), ('Uberlândia',), ('Feira de Santana',), ('Ribeirão Preto',), ('Sorocaba',), ('Niterói',), ('Cuiabá',), ('Juiz de Fora',), ('Aracaju',), ('São João de Meriti',), ('Londrina',), ('Joinville',), ('Belford Roxo',), ('Santos',), ('Ananindeua',), ('Campos dos Goytacazes',), ('Mauá',), ('Carapicuíba',), ('Olinda',), ('Campina Grande',), ('São José do Rio Preto',), ('Caxias do Sul',), ('Moji das Cruzes',), ('Diadema',), ('Aparecida de Goiânia',), ('Piracicaba',), ('Cariacica',), ('Vila Velha',), ('Pelotas',), ('Bauru',), ('Porto Velho',), ('Serra',), ('Betim',), ('Jundíaí',), ('Canoas',), ('Franca',), ('São Vicente',), ('Maringá',), ('Montes Claros',), ('Anápolis',), ('Florianópolis',), ('Petrópolis',), ('Itaquaquecetuba',), ('Vitória',), ('Ponta Grossa',), ('Rio Branco',), ('Foz do Iguaçu',), ('Macapá',), ('Ilhéus',), ('Vitória da Conquista',), ('Uberaba',), ('Paulista',), ('Limeira',), ('Blumenau',), ('Caruaru',), ('Santarém',), ('Volta Redonda',), ('Novo Hamburgo',), ('Caucaia',), ('Santa Maria',), ('Cascavel',), ('Guarujá',), ('Ribeirão das Neves',), ('Governador Valadares',), ('Taubaté',), ('Imperatriz',), ('Gravataí',), ('Embu',), ('Mossoró',), ('Várzea Grande',), ('Petrolina',), ('Barueri',), ('Viamão',), ('Ipatinga',), ('Juazeiro',), ('Juazeiro do Norte',), ('Taboão da Serra',), ('São José dos Pinhais',), ('Magé',), ('Suzano',), ('São Leopoldo',), ('Marília',), ('São Carlos',), ('Sumaré',), ('Presidente Prudente',), ('Divinópolis',), ('Sete Lagoas',), ('Rio Grande',), ('Itabuna',), ('Jequié',), ('Arapiraca',), ('Colombo',), ('Americana',), ('Alvorada',), ('Araraquara',), ('Itaboraí',), ('Santa Bárbara d´Oeste',), ('Nova Friburgo',), ('Jacareí',), ('Araçatuba',), ('Barra Mansa',), ('Praia Grande',), ('Marabá',), ('Criciúma',), ('Boa Vista',), ('Passo Fundo',), ('Dourados',), ('Santa Luzia',), ('Rio Claro',), ('Maracanaú',), ('Guarapuava',), ('Glasgow',), ('Liverpool',), ('Edinburgh',), ('Sheffield',), ('Manchester',), ('Leeds',), ('Bristol',), ('Cardiff',), ('Coventry',), ('Leicester',), ('Bradford',), ('Belfast',), ('Nottingham',), ('Kingston upon Hull',), ('Plymouth',), ('Stoke-on-Trent',), ('Wolverhampton',), ('Derby',), ('Swansea',), ('Southampton',), ('Aberdeen',), ('Northampton',), ('Dudley',), ('Portsmouth',), ('Newcastle upon Tyne',), ('Sunderland',), ('Luton',), ('Swindon',), ('Southend-on-Sea',), ('Walsall',), ('Bournemouth',), ('Plovdiv',), ('Varna',), ('Burgas',), ('Ruse',), ('Ouagadougou',), ('Bobo-Dioulasso',), ('Bujumbura',), ('Puente Alto',), ('Viña del Mar',), ('Valparaíso',), ('Talcahuano',), ('Antofagasta',), ('San Bernardo',), ('Temuco',), ('Concepción',), ('Rancagua',), ('Arica',), ('Talca',), ('Chillán',), ('Iquique',), ('San José',), ('Djibouti',), ('Santiago de los Caballeros',), ('Cuenca',), ('Machala',), ('Santo Domingo de los Colorados',), ('Portoviejo',), ('Ambato',), ('Manta',), ('Shubra al-Khayma',), ('Port Said',), ('Suez',), ('al-Mahallat al-Kubra',), ('Tanta',), ('al-Mansura',), ('Luxor',), ('Asyut',), ('Bahtim',), ('Zagazig',), ('al-Faiyum',), ('Ismailia',), ('Kafr al-Dawwar',), ('Assuan',), ('Damanhur',), ('al-Minya',), ('Bani Suwayf',), ('Qina',), ('Sawhaj',), ('San Salvador',), ('Asmara',), ('Valencia',), ('Sevilla',), ('Zaragoza',), ('Málaga',), ('Bilbao',), ('Las Palmas de Gran Canaria',), ('Murcia',), ('Palma de Mallorca',), ('Valladolid',), ('Córdoba',), ('Vigo',), ('Alicante [Alacant]',), ('Gijón',), ('L´Hospitalet de Llobregat',), ('Granada',), ('A Coruña (La Coruña)',), ('Vitoria-Gasteiz',), ('Santa Cruz de Tenerife',), ('Badalona',), ('Oviedo',), ('Móstoles',), ('Elche [Elx]',), ('Sabadell',), ('Santander',), ('Jerez de la Frontera',), ('Pamplona [Iruña]',), ('Donostia-San Sebastián',), ('Cartagena',), ('Leganés',), ('Fuenlabrada',), ('Almería',), ('Terrassa',), ('Alcalá de Henares',), ('Burgos',), ('Johannesburg',), ('Port Elizabeth',), ('Pretoria',), ('Inanda',), ('Durban',), ('Vanderbijlpark',), ('Kempton Park',), ('Alberton',), ('Pinetown',), ('Pietermaritzburg',), ('Benoni',), ('Randburg',), ('Umlazi',), ('Bloemfontein',), ('Vereeniging',), ('Wonderboom',), ('Roodepoort',), ('Boksburg',), ('Klerksdorp',), ('Soshanguve',), ('Newcastle',), ('East London',), ('Welkom',), ('Kimberley',), ('Uitenhage',), ('Chatsworth',), ('Mdantsane',), ('Krugersdorp',), ('Botshabelo',), ('Brakpan',), ('Witbank',), ('Oberholzer',), ('Germiston',), ('Springs',), ('Dire Dawa',), ('Cebu',), ('Zamboanga',), ('Pasig',), ('Valenzuela',), ('Las Piñas',), ('Antipolo',), ('Taguig',), ('Cagayan de Oro',), ('Parañaque',), ('Makati',), ('Bacolod',), ('General Santos',), ('Marikina',), ('Dasmariñas',), ('Muntinlupa',), ('Iloilo',), ('Pasay',), ('Malabon',), ('San José del Monte',), ('Bacoor',), ('Iligan',), ('Calamba',), ('Mandaluyong',), ('Butuan',), ('Angeles',), ('Tarlac',), ('Mandaue',), ('Baguio',), ('Batangas',), ('Cainta',), ('San Pedro',), ('Navotas',), ('Cabanatuan',), ('San Fernando',), ('Lipa',), ('Lapu-Lapu',), ('San Pablo',), ('Biñan',), ('Taytay',), ('Lucena',), ('Imus',), ('Olongapo',), ('Binangonan',), ('Santa Rosa',), ('Tagum',), ('Tacloban',), ('Malolos',), ('Mabalacat',), ('Cotabato',), ('Meycauayan',), ('Puerto Princesa',), ('Libreville',), ('Kutaisi',), ('Kumasi',), ('Ciudad de Guatemala',), ('Mixco',), ('Bissau',), ('Georgetown',), ('Port-au-Prince',), ('Carrefour',), ('Delmas',), ('Tegucigalpa',), ('San Pedro Sula',), ('Malang',), ('Bandar Lampung',), ('Bekasi',), ('Padang',), ('Surakarta',), ('Banjarmasin',), ('Pekan Baru',), ('Denpasar',), ('Yogyakarta',), ('Pontianak',), ('Samarinda',), ('Jambi',), ('Depok',), ('Cimahi',), ('Balikpapan',), ('Manado',), ('Mataram',), ('Pekalongan',), ('Tegal',), ('Bogor',), ('Ciputat',), ('Pondokgede',), ('Cirebon',), ('Kediri',), ('Ambon',), ('Jember',), ('Cilacap',), ('Cimanggis',), ('Pematang Siantar',), ('Purwokerto',), ('Ciomas',), ('Tasikmalaya',), ('Madiun',), ('Srinagar',), ('Agra',), ('Coimbatore',), ('Thane (Thana)',), ('Allahabad',), ('Meerut',), ('Vishakhapatnam',), ('Jabalpur',), ('Amritsar',), ('Faridabad',), ('Vijayawada',), ('Gwalior',), ('Jodhpur',), ('Nashik (Nasik)',), ('Hubli-Dharwad',), ('Solapur (Sholapur)',), ('Ranchi',), ('Bareilly',), ('Guwahati (Gauhati)',), ('Shambajinagar (Aurangabad)',), ('Cochin (Kochi)',), ('Rajkot',), ('Kota',), ('Thiruvananthapuram (Trivandrum',), ('Pimpri-Chinchwad',), ('Jalandhar (Jullundur)',), ('Gorakhpur',), ('Chandigarh',), ('Mysore',), ('Aligarh',), ('Guntur',), ('Jamshedpur',), ('Ghaziabad',), ('Warangal',), ('Raipur',), ('Moradabad',), ('Durgapur',), ('Amravati',), ('Calicut (Kozhikode)',), ('Bikaner',), ('Bhubaneswar',), ('Kolhapur',), ('Kataka (Cuttack)',), ('Ajmer',), ('Bhavnagar',), ('Tiruchirapalli',), ('Bhilai',), ('Bhiwandi',), ('Saharanpur',), ('Ulhasnagar',), ('Salem',), ('Ujjain',), ('Malegaon',), ('Jamnagar',), ('Bokaro Steel City',), ('Akola',), ('Belgaum',), ('Rajahmundry',), ('Nellore',), ('Udaipur',), ('New Bombay',), ('Bhatpara',), ('Gulbarga',), ('New Delhi',), ('Jhansi',), ('Gaya',), ('Kakinada',), ('Dhule (Dhulia)',), ('Panihati',), ('Nanded (Nander)',), ('Mangalore',), ('Dehra Dun',), ('Kamarhati',), ('Davangere',), ('Asansol',), ('Bhagalpur',), ('Bellary',), ('Barddhaman (Burdwan)',), ('Rampur',), ('Jalgaon',), ('Muzaffarpur',), ('Nizamabad',), ('Muzaffarnagar',), ('Patiala',), ('Shahjahanpur',), ('Kurnool',), ('Tiruppur (Tirupper)',), ('Rohtak',), ('South Dum Dum',), ('Mathura',), ('Chandrapur',), ('Barahanagar (Baranagar)',), ('Darbhanga',), ('Siliguri (Shiliguri)',), ('Raurkela',), ('Ambattur',), ('Panipat',), ('Firozabad',), ('Ichalkaranji',), ('Jammu',), ('Ramagundam',), ('Eluru',), ('Brahmapur',), ('Alwar',), ('Pondicherry',), ('Thanjavur',), ('Bihar Sharif',), ('Tuticorin',), ('Imphal',), ('Latur',), ('Sagar',), ('Farrukhabad-cum-Fatehgarh',), ('Sangli',), ('Parbhani',), ('Nagar Coil',), ('Bijapur',), ('Kukatpalle',), ('Bally',), ('Bhilwara',), ('Ratlam',), ('Avadi',), ('Dindigul',), ('Ahmadnagar',), ('Bilaspur',), ('Shimoga',), ('Kharagpur',), ('Mira Bhayandar',), ('Vellore',), ('Jalna',), ('Burnpur',), ('Anantapur',), ('Allappuzha (Alleppey)',), ('Tirupati',), ('Karnal',), ('Burhanpur',), ('Hisar (Hissar)',), ('Tiruvottiyur',), ('Mirzapur-cum-Vindhyachal',), ('Secunderabad',), ('Nadiad',), ('Dewas',), ('Murwara (Katni)',), ('Ganganagar',), ('Vizianagaram',), ('Mosul',), ('Irbil',), ('Kirkuk',), ('Basra',), ('al-Sulaymaniya',), ('al-Najaf',), ('Karbala',), ('al-Hilla',), ('al-Nasiriya',), ('al-Amara',), ('al-Diwaniya',), ('al-Ramadi',), ('al-Kut',), ('Ahvaz',), ('Qom',), ('Kermanshah',), ('Urmia',), ('Zahedan',), ('Rasht',), ('Hamadan',), ('Kerman',), ('Arak',), ('Ardebil',), ('Yazd',), ('Qazvin',), ('Zanjan',), ('Sanandaj',), ('Bandar-e-Abbas',), ('Khorramabad',), ('Eslamshahr',), ('Borujerd',), ('Abadan',), ('Dezful',), ('Kashan',), ('Sari',), ('Gorgan',), ('Najafabad',), ('Sabzevar',), ('Khomeynishahr',), ('Dublin',), ('Jerusalem',), ('Tel Aviv-Jaffa',), ('Haifa',), ('Rishon Le Ziyyon',), ('Beerseba',), ('Holon',), ('Palermo',), ('Genova',), ('Bologna',), ('Firenze',), ('Catania',), ('Bari',), ('Venezia',), ('Messina',), ('Verona',), ('Trieste',), ('Padova',), ('Taranto',), ('Brescia',), ('Reggio di Calabria',), ('Modena',), ('Prato',), ('Parma',), ('Cagliari',), ('Livorno',), ('Graz',), ('Linz',), ('Chiba',), ('Sakai',), ('Kumamoto',), ('Okayama',), ('Sagamihara',), ('Hamamatsu',), ('Kagoshima',), ('Funabashi',), ('Higashiosaka',), ('Hachioji',), ('Niigata',), ('Amagasaki',), ('Himeji',), ('Shizuoka',), ('Urawa',), ('Matsuyama',), ('Matsudo',), ('Kanazawa',), ('Kawaguchi',), ('Ichikawa',), ('Omiya',), ('Utsunomiya',), ('Oita',), ('Nagasaki',), ('Yokosuka',), ('Kurashiki',), ('Gifu',), ('Hirakata',), ('Nishinomiya',), ('Toyonaka',), ('Wakayama',), ('Fukuyama',), ('Fujisawa',), ('Asahikawa',), ('Machida',), ('Nara',), ('Takatsuki',), ('Iwaki',), ('Nagano',), ('Toyohashi',), ('Toyota',), ('Suita',), ('Takamatsu',), ('Koriyama',), ('Okazaki',), ('Kawagoe',), ('Tokorozawa',), ('Toyama',), ('Kochi',), ('Kashiwa',), ('Akita',), ('Miyazaki',), ('Koshigaya',), ('Naha',), ('Aomori',), ('Hakodate',), ('Akashi',), ('Yokkaichi',), ('Fukushima',), ('Morioka',), ('Maebashi',), ('Kasugai',), ('Otsu',), ('Ichihara',), ('Yao',), ('Ichinomiya',), ('Tokushima',), ('Kakogawa',), ('Ibaraki',), ('Neyagawa',), ('Shimonoseki',), ('Yamagata',), ('Fukui',), ('Hiratsuka',), ('Mito',), ('Sasebo',), ('Hachinohe',), ('Takasaki',), ('Shimizu',), ('Kurume',), ('Fuji',), ('Soka',), ('Fuchu',), ('Chigasaki',), ('Atsugi',), ('Numazu',), ('Ageo',), ('Yamato',), ('Matsumoto',), ('Kure',), ('Takarazuka',), ('Kasukabe',), ('Chofu',), ('Odawara',), ('Kofu',), ('Kushiro',), ('Kishiwada',), ('Hitachi',), ('Nagaoka',), ('Itami',), ('Uji',), ('Suzuka',), ('Hirosaki',), ('Ube',), ('Kodaira',), ('Takaoka',), ('Obihiro',), ('Tomakomai',), ('Saga',), ('Sakura',), ('Kamakura',), ('Mitaka',), ('Izumi',), ('Hino',), ('Hadano',), ('Ashikaga',), ('Tsu',), ('Sayama',), ('Yachiyo',), ('Tsukuba',), ('Sanaa',), ('Aden',), ('Taizz',), ('Hodeida',), ('al-Zarqa',), ('Irbid',), ('Novi Sad',), ('Niš',), ('Phnom Penh',), ('Garoua',), ('Calgary',), ('Toronto',), ('North York',), ('Winnipeg',), ('Edmonton',), ('Mississauga',), ('Scarborough',), ('Vancouver',), ('Etobicoke',), ('London',), ('Hamilton',), ('Ottawa',), ('Laval',), ('Surrey',), ('Brampton',), ('Windsor',), ('Saskatoon',), ('Kitchener',), ('Markham',), ('Regina',), ('Burnaby',), ('Québec',), ('Qaraghandy',), ('Shymkent',), ('Taraz',), ('Astana',), ('Öskemen',), ('Pavlodar',), ('Semey',), ('Aqtöbe',), ('Qostanay',), ('Petropavl',), ('Oral',), ('Temirtau',), ('Mombasa',), ('Kisumu',), ('Nakuru',), ('Bangui',), ('Handan',), ('Wuxi',), ('Xuzhou',), ('Datong',), ('Yichun',), ('Benxi',), ('Luoyang',), ('Suzhou',), ('Xining',), ('Huainan',), ('Jixi',), ('Daqing',), ('Fuxin',), ('Amoy [Xiamen]',), ('Liuzhou',), ('Shantou',), ('Jinzhou',), ('Mudanjiang',), ('Yinchuan',), ('Changzhou',), ('Zhangjiakou',), ('Dandong',), ('Hegang',), ('Kaifeng',), ('Jiamusi',), ('Liaoyang',), ('Hengyang',), ('Baoding',), ('Hunjiang',), ('Xinxiang',), ('Huangshi',), ('Haikou',), ('Yantai',), ('Bengbu',), ('Xiangtan',), ('Weifang',), ('Wuhu',), ('Pingxiang',), ('Yingkou',), ('Anyang',), ('Panzhihua',), ('Pingdingshan',), ('Xiangfan',), ('Zhuzhou',), ('Jiaozuo',), ('Wenzhou',), ('Zhangjiang',), ('Zigong',), ('Shuangyashan',), ('Zaozhuang',), ('Yakeshi',), ('Yichang',), ('Zhenjiang',), ('Huaibei',), ('Qinhuangdao',), ('Guilin',), ('Liupanshui',), ('Panjin',), ('Yangquan',), ('Jinxi',), ('Liaoyuan',), ('Lianyungang',), ('Xianyang',), ('Tai´an',), ('Chifeng',), ('Shaoguan',), ('Nantong',), ('Leshan',), ('Baoji',), ('Linyi',), ('Tonghua',), ('Siping',), ('Changzhi',), ('Tengzhou',), ('Chaozhou',), ('Yangzhou',), ('Dongwan',), ('Ma´anshan',), ('Foshan',), ('Yueyang',), ('Xingtai',), ('Changde',), ('Shihezi',), ('Yancheng',), ('Jiujiang',), ('Dongying',), ('Shashi',), ('Xintai',), ('Jingdezhen',), ('Tongchuan',), ('Zhongshan',), ('Shiyan',), ('Tieli',), ('Jining',), ('Wuhai',), ('Mianyang',), ('Luzhou',), ('Zunyi',), ('Shizuishan',), ('Neijiang',), ('Tongliao',), ('Tieling',), ('Wafangdian',), ('Anqing',), ('Shaoyang',), ('Laiwu',), ('Chengde',), ('Tianshui',), ('Nanyang',), ('Cangzhou',), ('Yibin',), ('Huaiyin',), ('Dunhua',), ('Yanji',), ('Jiangmen',), ('Tongling',), ('Suihua',), ('Gongziling',), ('Xiantao',), ('Chaoyang',), ('Ganzhou',), ('Huzhou',), ('Baicheng',), ('Shangzi',), ('Yangjiang',), ('Qitaihe',), ('Gejiu',), ('Jiangyin',), ('Hebi',), ('Jiaxing',), ('Wuzhou',), ('Meihekou',), ('Xuchang',), ('Liaocheng',), ('Haicheng',), ('Qianjiang',), ('Baiyin',), ('Bei´an',), ('Yixing',), ('Laizhou',), ('Qaramay',), ('Acheng',), ('Dezhou',), ('Nanping',), ('Zhaoqing',), ('Beipiao',), ('Fengcheng',), ('Fuyu',), ('Xinyang',), ('Dongtai',), ('Yuci',), ('Honghu',), ('Ezhou',), ('Heze',), ('Daxian',), ('Linfen',), ('Tianmen',), ('Yiyang',), ('Quanzhou',), ('Rizhao',), ('Deyang',), ('Guangyuan',), ('Changshu',), ('Zhangzhou',), ('Hailar',), ('Nanchong',), ('Jiutai',), ('Zhaodong',), ('Shaoxing',), ('Fuyang',), ('Maoming',), ('Qujing',), ('Ghulja',), ('Jiaohe',), ('Puyang',), ('Huadian',), ('Jiangyou',), ('Qashqar',), ('Anshun',), ('Fuling',), ('Xinyu',), ('Hanzhong',), ('Danyang',), ('Chenzhou',), ('Xiaogan',), ('Shangqiu',), ('Zhuhai',), ('Qingyuan',), ('Aqsu',), ('Jining',), ('Xiaoshan',), ('Zaoyang',), ('Xinghua',), ('Hami',), ('Huizhou',), ('Jinmen',), ('Sanming',), ('Bishkek',), ('Osh',), ('Cartagena',), ('Cúcuta',), ('Bucaramanga',), ('Ibagué',), ('Pereira',), ('Santa Marta',), ('Manizales',), ('Bello',), ('Pasto',), ('Neiva',), ('Soledad',), ('Armenia',), ('Villavicencio',), ('Soacha',), ('Valledupar',), ('Montería',), ('Itagüí',), ('Palmira',), ('Buenaventura',), ('Floridablanca',), ('Sincelejo',), ('Popayán',), ('Barrancabermeja',), ('Pointe-Noire',), ('Lubumbashi',), ('Mbuji-Mayi',), ('Kolwezi',), ('Kisangani',), ('Kananga',), ('Likasi',), ('Bukavu',), ('Kikwit',), ('Tshikapa',), ('Matadi',), ('Mbandaka',), ('Hamhung',), ('Chongjin',), ('Nampo',), ('Sinuiju',), ('Wonsan',), ('Phyongsong',), ('Sariwon',), ('Haeju',), ('Kanggye',), ('Kimchaek',), ('Hyesan',), ('Kaesong',), ('Songnam',), ('Puchon',), ('Suwon',), ('Anyang',), ('Chonju',), ('Chongju',), ('Koyang',), ('Ansan',), ('Pohang',), ('Chang-won',), ('Masan',), ('Kwangmyong',), ('Chonan',), ('Chinju',), ('Iksan',), ('Pyongtaek',), ('Kumi',), ('Uijongbu',), ('Kyongju',), ('Kunsan',), ('Cheju',), ('Kimhae',), ('Sunchon',), ('Mokpo',), ('Yong-in',), ('Wonju',), ('Kunpo',), ('Chunchon',), ('Namyangju',), ('Kangnung',), ('Chungju',), ('Andong',), ('Yosu',), ('Kyongsan',), ('Paju',), ('Yangsan',), ('Athenai',), ('Thessaloniki',), ('Pireus',), ('Zagreb',), ('Split',), ('Rijeka',), ('Santiago de Cuba',), ('Camagüey',), ('Holguín',), ('Santa Clara',), ('Guantánamo',), ('Nicosia',), ('Vientiane',), ('Riga',), ('Maseru',), ('Tripoli',), ('Monrovia',), ('Bengasi',), ('Vilnius',), ('Kaunas',), ('Klaipeda',), ('El-Aaiún',), ('Macao',), ('Antananarivo',), ('Skopje',), ('Blantyre',), ('Lilongwe',), ('Ipoh',), ('Johor Baharu',), ('Petaling Jaya',), ('Kelang',), ('Kuala Terengganu',), ('Pinang',), ('Kota Bharu',), ('Kuantan',), ('Taiping',), ('Seremban',), ('Bamako',), ('Rabat',), ('Marrakech',), ('Fès',), ('Tanger',), ('Salé',), ('Meknès',), ('Oujda',), ('Kénitra',), ('Tétouan',), ('Safi',), ('Nouakchott',), ('Naucalpan de Juárez',), ('Mexicali',), ('Culiacán',), ('Acapulco de Juárez',), ('Tlalnepantla de Baz',), ('Mérida',), ('Chihuahua',), ('San Luis Potosí',), ('Guadalupe',), ('Toluca',), ('Aguascalientes',), ('Querétaro',), ('Morelia',), ('Hermosillo',), ('Saltillo',), ('Torreón',), ('Centro (Villahermosa)',), ('San Nicolás de los Garza',), ('Durango',), ('Chimalhuacán',), ('Tlaquepaque',), ('Atizapán de Zaragoza',), ('Veracruz',), ('Cuautitlán Izcalli',), ('Irapuato',), ('Tuxtla Gutiérrez',), ('Tultitlán',), ('Reynosa',), ('Benito Juárez',), ('Matamoros',), ('Xalapa',), ('Celaya',), ('Mazatlán',), ('Ensenada',), ('Ahome',), ('Cajeme',), ('Cuernavaca',), ('Tonalá',), ('Valle de Chalco Solidaridad',), ('Nuevo Laredo',), ('Tepic',), ('Tampico',), ('Ixtapaluca',), ('Apodaca',), ('Guasave',), ('Gómez Palacio',), ('Tapachula',), ('Nicolás Romero',), ('Coatzacoalcos',), ('Uruapan',), ('Victoria',), ('Oaxaca de Juárez',), ('Coacalco de Berriozábal',), ('Pachuca de Soto',), ('General Escobedo',), ('Salamanca',), ('Santa Catarina',), ('Tehuacán',), ('Chalco',), ('Cárdenas',), ('Campeche',), ('La Paz',), ('Othón P. Blanco (Chetumal)',), ('Texcoco',), ('La Paz',), ('Metepec',), ('Monclova',), ('Huixquilucan',), ('Chilpancingo de los Bravo',), ('Puerto Vallarta',), ('Fresnillo',), ('Ciudad Madero',), ('Soledad de Graciano Sánchez',), ('San Juan del Río',), ('San Felipe del Progreso',), ('Córdoba',), ('Tecámac',), ('Ocosingo',), ('Carmen',), ('Lázaro Cárdenas',), ('Jiutepec',), ('Papantla',), ('Comalcalco',), ('Zamora',), ('Chisinau',), ('Tiraspol',), ('Ulan Bator',), ('Matola',), ('Beira',), ('Nampula',), ('Chimoio',), ('Mandalay',), ('Moulmein (Mawlamyine)',), ('Pegu (Bago)',), ('Bassein (Pathein)',), ('Windhoek',), ('Kathmandu',), ('Niamey',), ('Ogbomosho',), ('Kano',), ('Oshogbo',), ('Ilorin',), ('Abeokuta',), ('Port Harcourt',), ('Zaria',), ('Ilesha',), ('Onitsha',), ('Iwo',), ('Ado-Ekiti',), ('Abuja',), ('Kaduna',), ('Mushin',), ('Maiduguri',), ('Enugu',), ('Ede',), ('Aba',), ('Ife',), ('Ila',), ('Oyo',), ('Ikerre',), ('Benin City',), ('Iseyin',), ('Katsina',), ('Jos',), ('Sokoto',), ('Ilobu',), ('Offa',), ('Ikorodu',), ('Ilawe-Ekiti',), ('Owo',), ('Ikirun',), ('Shaki',), ('Calabar',), ('Ondo',), ('Akure',), ('Oslo',), ('Bergen',), ('Bouaké',), ('Quetta',), ('Islamabad',), ('Sargodha',), ('Sialkot',), ('Bahawalpur',), ('Sukkur',), ('Jhang',), ('Sheikhupura',), ('Larkana',), ('Gujrat',), ('Mardan',), ('Kasur',), ('Rahim Yar Khan',), ('Sahiwal',), ('Okara',), ('Wah',), ('Dera Ghazi Khan',), ('Mirpur Khas',), ('Nawabshah',), ('Mingora',), ('Chiniot',), ('Ciudad de Panamá',), ('San Miguelito',), ('Port Moresby',), ('Asunción',), ('Arequipa',), ('Trujillo',), ('Chiclayo',), ('Callao',), ('Iquitos',), ('Chimbote',), ('Huancayo',), ('Piura',), ('Cusco',), ('Pucallpa',), ('Tacna',), ('Ica',), ('Lisboa',), ('Porto',), ('San Juan',), ('Bayamón',), ('Ponce',), ('Carolina',), ('Lódz',), ('Kraków',), ('Wroclaw',), ('Poznan',), ('Gdansk',), ('Szczecin',), ('Bydgoszcz',), ('Lublin',), ('Katowice',), ('Bialystok',), ('Czestochowa',), ('Gdynia',), ('Sosnowiec',), ('Radom',), ('Kielce',), ('Gliwice',), ('Torun',), ('Bytom',), ('Zabrze',), ('Bielsko-Biala',), ('Olsztyn',), ('Rzeszów',), ('Doha',), ('Marseille',), ('Lyon',), ('Toulouse',), ('Nice',), ('Nantes',), ('Strasbourg',), ('Montpellier',), ('Bordeaux',), ('Rennes',), ('Le Havre',), ('Reims',), ('Lille',), ('St-Étienne',), ('Toulon',), ('Iasi',), ('Constanta',), ('Cluj-Napoca',), ('Galati',), ('Timisoara',), ('Brasov',), ('Craiova',), ('Ploiesti',), ('Braila',), ('Oradea',), ('Bacau',), ('Pitesti',), ('Arad',), ('Sibiu',), ('Târgu Mures',), ('Kigali',), ('Stockholm',), ('Gothenburg [Göteborg]',), ('Malmö',), ('Uppsala',), ('Frankfurt am Main',), ('Essen',), ('Dortmund',), ('Stuttgart',), ('Düsseldorf',), ('Bremen',), ('Duisburg',), ('Hannover',), ('Leipzig',), ('Nürnberg',), ('Dresden',), ('Bochum',), ('Wuppertal',), ('Bielefeld',), ('Mannheim',), ('Bonn',), ('Gelsenkirchen',), ('Karlsruhe',), ('Wiesbaden',), ('Münster',), ('Mönchengladbach',), ('Chemnitz',), ('Augsburg',), ('Halle/Saale',), ('Braunschweig',), ('Aachen',), ('Krefeld',), ('Magdeburg',), ('Kiel',), ('Oberhausen',), ('Lübeck',), ('Hagen',), ('Rostock',), ('Freiburg im Breisgau',), ('Erfurt',), ('Kassel',), ('Saarbrücken',), ('Mainz',), ('Hamm',), ('Herne',), ('Mülheim an der Ruhr',), ('Solingen',), ('Osnabrück',), ('Ludwigshafen am Rhein',), ('Leverkusen',), ('Ndola',), ('Kitwe',), ('Medina',), ('al-Dammam',), ('al-Taif',), ('Tabuk',), ('Burayda',), ('al-Hufuf',), ('al-Mubarraz',), ('Khamis Mushayt',), ('Hail',), ('Pikine',), ('Dakar',), ('Thiès',), ('Kaolack',), ('Ziguinchor',), ('Freetown',), ('Bratislava',), ('Košice',), ('Ljubljana',), ('Colombo',), ('Dehiwala',), ('Moratuwa',), ('Sharq al-Nil',), ('Port Sudan',), ('Kassala',), ('Obeid',), ('Nyala',), ('Wad Madani',), ('al-Qadarif',), ('Kusti',), ('Helsinki [Helsingfors]',), ('Espoo',), ('Tampere',), ('Vantaa',), ('Turku [Åbo]',), ('Zürich',), ('Geneve',), ('Basel',), ('Hims',), ('Hama',), ('Latakia',), ('Dushanbe',), ('Khujand',), ('Tainan',), ('Panchiao',), ('Chungho',), ('Keelung (Chilung)',), ('Sanchung',), ('Hsinchuang',), ('Hsinchu',), ('Chungli',), ('Fengshan',), ('Taoyuan',), ('Chiayi',), ('Hsintien',), ('Changhwa',), ('Yungho',), ('Tucheng',), ('Pingtung',), ('Yungkang',), ('Pingchen',), ('Tali',), ('Taiping',), ('Pate',), ('Fengyuan',), ('Luchou',), ('Dodoma',), ('Mwanza',), ('København',), ('Århus',), ('Odense',), ('Aalborg',), ('Nonthaburi',), ('Nakhon Ratchasima',), ('Chiang Mai',), ('Lomé',), ('N´Djaména',), ('Brno',), ('Ostrava',), ('Plzen',), ('Tunis',), ('Sfax',), ('Ariana',), ('Ettadhamen',), ('Gaziantep',), ('Konya',), ('Mersin (Içel)',), ('Antalya',), ('Diyarbakir',), ('Kayseri',), ('Eskisehir',), ('Sanliurfa',), ('Samsun',), ('Malatya',), ('Gebze',), ('Denizli',), ('Sivas',), ('Erzurum',), ('Tarsus',), ('Kahramanmaras',), ('Elâzig',), ('Van',), ('Sultanbeyli',), ('Izmit (Kocaeli)',), ('Manisa',), ('Batman',), ('Balikesir',), ('Sakarya (Adapazari)',), ('Ashgabat',), ('Chärjew',), ('Kampala',), ('Zaporizzja',), ('Lviv',), ('Kryvyi Rig',), ('Mykolajiv',), ('Mariupol',), ('Lugansk',), ('Vinnytsja',), ('Makijivka',), ('Herson',), ('Sevastopol',), ('Simferopol',), ('Pultava [Poltava]',), ('Tšernigiv',), ('Tšerkasy',), ('Gorlivka',), ('Zytomyr',), ('Sumy',), ('Dniprodzerzynsk',), ('Kirovograd',), ('Hmelnytskyi',), ('Tšernivtsi',), ('Rivne',), ('Krementšuk',), ('Ivano-Frankivsk',), ('Ternopil',), ('Lutsk',), ('Bila Tserkva',), ('Kramatorsk',), ('Melitopol',), ('Kertš',), ('Debrecen',), ('Miskolc',), ('Auckland',), ('Christchurch',), ('Manukau',), ('North Shore',), ('Waitakere',), ('Wellington',), ('Namangan',), ('Samarkand',), ('Andijon',), ('Buhoro',), ('Karsi',), ('Nukus',), ('Kükon',), ('Fargona',), ('Gomel',), ('Mogiljov',), ('Vitebsk',), ('Grodno',), ('Brest',), ('Bobruisk',), ('Baranovitši',), ('Barquisimeto',), ('Valencia',), ('Ciudad Guayana',), ('Petare',), ('Maracay',), ('Barcelona',), ('Maturín',), ('San Cristóbal',), ('Ciudad Bolívar',), ('Cumaná',), ('Mérida',), ('Cabimas',), ('Barinas',), ('Turmero',), ('Baruta',), ('Puerto Cabello',), ('Santa Ana de Coro',), ('Los Teques',), ('Punto Fijo',), ('Guarenas',), ('Krasnojarsk',), ('Saratov',), ('Toljatti',), ('Uljanovsk',), ('Izevsk',), ('Krasnodar',), ('Jaroslavl',), ('Habarovsk',), ('Vladivostok',), ('Irkutsk',), ('Barnaul',), ('Novokuznetsk',), ('Penza',), ('Rjazan',), ('Orenburg',), ('Lipetsk',), ('Nabereznyje Tšelny',), ('Tula',), ('Tjumen',), ('Kemerovo',), ('Astrahan',), ('Tomsk',), ('Kirov',), ('Ivanovo',), ('Tšeboksary',), ('Brjansk',), ('Tver',), ('Kursk',), ('Magnitogorsk',), ('Kaliningrad',), ('Nizni Tagil',), ('Murmansk',), ('Ulan-Ude',), ('Kurgan',), ('Arkangeli',), ('Sotši',), ('Smolensk',), ('Orjol',), ('Stavropol',), ('Belgorod',), ('Kaluga',), ('Vladimir',), ('Mahatškala',), ('Tšerepovets',), ('Saransk',), ('Tambov',), ('Vladikavkaz',), ('Tšita',), ('Vologda',), ('Veliki Novgorod',), ('Komsomolsk-na-Amure',), ('Kostroma',), ('Volzski',), ('Taganrog',), ('Petroskoi',), ('Bratsk',), ('Dzerzinsk',), ('Surgut',), ('Orsk',), ('Sterlitamak',), ('Angarsk',), ('Joškar-Ola',), ('Rybinsk',), ('Prokopjevsk',), ('Niznevartovsk',), ('Naltšik',), ('Syktyvkar',), ('Severodvinsk',), ('Bijsk',), ('Niznekamsk',), ('Blagoveštšensk',), ('Šahty',), ('Staryi Oskol',), ('Zelenograd',), ('Balakovo',), ('Novorossijsk',), ('Pihkova',), ('Zlatoust',), ('Jakutsk',), ('Podolsk',), ('Petropavlovsk-Kamtšatski',), ('Kamensk-Uralski',), ('Engels',), ('Syzran',), ('Grozny',), ('Novotšerkassk',), ('Berezniki',), ('Juzno-Sahalinsk',), ('Volgodonsk',), ('Abakan',), ('Maikop',), ('Miass',), ('Armavir',), ('Ljubertsy',), ('Rubtsovsk',), ('Haiphong',), ('Da Nang',), ('Biên Hoa',), ('Nha Trang',), ('Hue',), ('Can Tho',), ('Cam Pha',), ('Nam Dinh',), ('Quy Nhon',), ('Tallinn',), ('San Jose',), ('Indianapolis',), ('San Francisco',), ('Jacksonville',), ('Columbus',), ('Austin',), ('Baltimore',), ('Memphis',), ('Milwaukee',), ('Boston',), ('Washington',), ('Nashville-Davidson',), ('El Paso',), ('Seattle',), ('Denver',), ('Charlotte',), ('Fort Worth',), ('Portland',), ('Oklahoma City',), ('Tucson',), ('New Orleans',), ('Las Vegas',), ('Cleveland',), ('Long Beach',), ('Albuquerque',), ('Kansas City',), ('Fresno',), ('Virginia Beach',), ('Atlanta',), ('Sacramento',), ('Oakland',), ('Mesa',), ('Tulsa',), ('Omaha',), ('Minneapolis',), ('Honolulu',), ('Miami',), ('Colorado Springs',), ('Saint Louis',), ('Wichita',), ('Santa Ana',), ('Pittsburgh',), ('Arlington',), ('Cincinnati',), ('Anaheim',), ('Toledo',), ('Tampa',), ('Buffalo',), ('Saint Paul',), ('Corpus Christi',), ('Aurora',), ('Raleigh',), ('Newark',), ('Lexington-Fayette',), ('Anchorage',), ('Louisville',), ('Riverside',), ('Saint Petersburg',), ('Bakersfield',), ('Stockton',), ('Birmingham',), ('Jersey City',), ('Norfolk',), ('Baton Rouge',), ('Hialeah',), ('Lincoln',), ('Greensboro',), ('Plano',), ('Rochester',), ('Glendale',), ('Akron',), ('Garland',), ('Madison',), ('Fort Wayne',), ('Fremont',), ('Scottsdale',), ('Montgomery',), ('Shreveport',), ('Augusta-Richmond County',), ('Lubbock',), ('Chesapeake',), ('Mobile',), ('Des Moines',), ('Grand Rapids',), ('Richmond',), ('Yonkers',), ('Spokane',), ('Glendale',), ('Tacoma',), ('Irving',), ('Huntington Beach',), ('Modesto',), ('Durham',), ('Columbus',), ('Orlando',), ('Boise City',), ('Winston-Salem',), ('San Bernardino',), ('Jackson',), ('Little Rock',), ('Salt Lake City',), ('Reno',), ('Newport News',), ('Chandler',), ('Laredo',), ('Henderson',), ('Arlington',), ('Knoxville',), ('Amarillo',), ('Providence',), ('Chula Vista',), ('Worcester',), ('Oxnard',), ('Dayton',), ('Garden Grove',), ('Oceanside',), ('Bulawayo',), ('Chitungwiza',), ('Mount Darwin',), ('Gaza',)]",,1.0,
Show the ID of the high schooler named Kyle.,"[Highschooler.ID, Highschooler.name, Kyle]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,SELECT Highschooler.ID FROM Highschooler WHERE Highschooler.name = 'Kyle';,"SELECT ID FROM Highschooler WHERE name  =  ""Kyle""",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Highschooler.ID"" of the high schooler named Kyle. 2. Condition Structure: Use a WHERE clause to filter for the high schooler whose ""Highschooler.name"" is 'Kyle'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Highschooler"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[(1934,)]","[(1934,)]",,1.0,
Find the number of cities in each district whose population is greater than the average population of cities?,"[city.District, city.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT District, COUNT(*) AS city_count FROM city WHERE Population > (SELECT AVG(Population) FROM city) GROUP BY District;","SELECT count(*) ,  District FROM city WHERE Population  >  (SELECT avg(Population) FROM city) GROUP BY District",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the district and the count of cities. Use the FROM clause to specify the city table. Apply a GROUP BY clause to group the data by district. Use a HAVING clause to filter districts where the population of cities is greater than the average population of all cities. 2. Condition Structure: Use the HAVING clause with a subquery to calculate the average population of all cities and filter cities whose population is greater than this average. 3. Join Structure: Not required, as all data is available within the city table. 4. Aggregation Structure: Use COUNT to count the number of cities in each district and AVG in a subquery to calculate the average population of all cities.","[('Abidjan', 1), ('Abu Dhabi', 1), ('Adana', 1), ('Addis Abeba', 1), ('Aden', 1), ('Aguascalientes', 1), ('Ahal', 1), ('Aichi', 2), ('Alagoas', 1), ('Alberta', 2), ('Aleksandria', 1), ('Aleppo', 1), ('Alger', 1), ('Almaty Qalasy', 1), ('Altai', 1), ('Amazonas', 1), ('Amman', 1), ('Anambra & Enugu & Eb', 1), ('Andalusia', 2), ('Andhra Pradesh', 5), ('Anhui', 5), ('Ankara', 1), ('Antalya', 1), ('Antananarivo', 1), ('Antioquia', 1), ('Antwerpen', 1), ('Aragonia', 1), ('Aragua', 1), ('Arequipa', 1), ('Arizona', 3), ('Arkangeli', 1), ('Ashanti', 1), ('Assam', 1), ('Astrahan', 1), ('Asunción', 1), ('Atlantique', 1), ('Atlántico', 1), ('Attika', 1), ('Auckland', 1), ('Baden-Württemberg', 1), ('Baghdad', 1), ('Bahia', 2), ('Baijeri', 2), ('Baja California', 3), ('Baki', 1), ('Bali', 1), ('Baluchistan', 1), ('Bamako', 1), ('Banaadir', 1), ('Bangkok', 1), ('Bangui', 1), ('Baskimaa', 1), ('Basra', 1), ('Baškortostan', 1), ('Beirut', 1), ('Bengasi', 1), ('Berliini', 1), ('Bihar', 1), ('Bishkek shaary', 1), ('Blantyre', 1), ('Bolívar', 2), ('Bratislava', 1), ('Brazzaville', 1), ('Bremen', 1), ('British Colombia', 1), ('Brjansk', 1), ('Budapest', 1), ('Buenos Aires', 12), ('Bukarest', 1), ('Bulawayo', 1), ('Burjatia', 1), ('Bursa', 1), ('California', 8), ('Callao', 1), ('Campania', 1), ('Canary Islands', 1), ('Cap-Vert', 2), ('Carabobo', 1), ('Casablanca', 1), ('Ceará', 1), ('Central', 2), ('Central Java', 2), ('Central Macedonia', 1), ('Central Serbia', 1), ('Central Visayas', 1), ('Centre', 1), ('Chandigarh', 1), ('Chari-Baguirmi', 1), ('Chhatisgarh', 2), ('Chiapas', 1), ('Chiba', 4), ('Chihuahua', 2), ('Chisinau', 1), ('Chittagong', 1), ('Chollabuk', 1), ('Chongqing', 1), ('Chungchongbuk', 1), ('Coahuila de Zaragoza', 2), ('Coast', 1), ('Cochabamba', 1), ('Colorado', 2), ('Conakry', 1), ('Constantine', 1), ('Cortés', 1), ('Córdoba', 1), ('Damascus', 1), ('Dar es Salaam', 1), ('Delhi', 1), ('Dhaka', 1), ('District of Columbia', 1), ('Distrito Central', 1), ('Distrito Federal', 4), ('Distrito Nacional', 1), ('Diyarbakir', 1), ('Djibouti', 1), ('Dnipropetrovsk', 2), ('Doha', 1), ('Dolnoslaskie', 1), ('Donetsk', 3), ('Dubai', 1), ('Durango', 1), ('East Azerbaidzan', 1), ('East Java', 2), ('East Kasai', 1), ('Eastern Cape', 1), ('Ehime', 1), ('Emilia-Romagna', 1), ('England', 7), ('Esfahan', 1), ('Eskisehir', 1), ('Estuaire', 1), ('Fars', 1), ('Federaatio', 1), ('Florida', 2), ('Fujian', 2), ('Fukuoka', 2), ('Fukushima', 1), ('Fès-Boulemane', 1), ('Gansu', 1), ('Gauteng', 7), ('Gaza', 1), ('Gaziantep', 1), ('Georgia', 1), ('Gifu', 1), ('Gilan', 1), ('Giza', 1), ('Goiás', 1), ('Gomel', 1), ('Grad Sofija', 1), ('Grad Zagreb', 1), ('Greater Accra', 1), ('Guanajuato', 3), ('Guangdong', 4), ('Guangxi', 3), ('Guatemala', 1), ('Guayas', 1), ('Guerrero', 1), ('Guizhou', 2), ('Gujarat', 5), ('Habarovsk', 1), ('Hainan', 1), ('Haiphong', 1), ('Hamadan', 1), ('Hamburg', 1), ('Hamgyong N', 1), ('Hamgyong P', 1), ('Hanoi', 1), ('Harare', 1), ('Harjumaa', 1), ('Harkova', 1), ('Haryana', 1), ('Haute-Zaïre', 1), ('Hawaii', 1), ('Hebei', 6), ('Heilongjiang', 9), ('Henan', 7), ('Herson', 1), ('Hessen', 1), ('Hims', 1), ('Hiroshima', 2), ('Hlavní mesto Praha', 1), ('Ho Chi Minh City', 1), ('Hokkaido', 2), ('Hongkong', 1), ('Horad Minsk', 1), ('Hsinchu', 1), ('Hubei', 4), ('Hunan', 4), ('Hyogo', 4), ('Illinois', 1), ('Inchon', 1), ('Indiana', 1), ('Inner Mongolia', 3), ('Irbil', 1), ('Irkutsk', 1), ('Ishikawa', 1), ('Islamabad', 1), ('Istanbul', 1), ('Ivanovo', 1), ('Izmir', 1), ('Içel', 1), ('Jakarta Raya', 1), ('Jalisco', 3), ('Jambi', 1), ('Jammu and Kashmir', 1), ('Jaroslavl', 1), ('Jerusalem', 1), ('Jharkhand', 2), ('Jiangsu', 7), ('Jiangxi', 2), ('Jilin', 4), ('Jizní Morava', 1), ('Kabol', 1), ('Kadiogo', 1), ('Kaduna', 1), ('Kagoshima', 1), ('Kairo', 1), ('Kalimantan Barat', 1), ('Kalimantan Selatan', 1), ('Kalimantan Timur', 1), ('Kaliningrad', 1), ('Kanagawa', 5), ('Kano & Jigawa', 1), ('Kaohsiung', 1), ('Karnataka', 3), ('Karotegin', 1), ('Katalonia', 1), ('Kaunas', 1), ('Kayseri', 1), ('Keelung', 1), ('Kemerovo', 2), ('Kerala', 3), ('Kerman', 1), ('Kermanshah', 1), ('Khartum', 3), ('Khorasan', 1), ('Khulna', 1), ('Khuzestan', 1), ('Kinshasa', 1), ('Kiova', 1), ('Kirov', 1), ('Konya', 1), ('Kouilou', 1), ('Kowloon and New Kowl', 1), ('Krasnodar', 2), ('Krasnojarsk', 1), ('Kujawsko-Pomorskie', 1), ('Kumamoto', 1), ('Kurgan', 1), ('Kursk', 1), ('KwaZulu-Natal', 4), ('Kwangju', 1), ('Kwara & Kogi', 1), ('Kyonggi', 7), ('Kyongsangbuk', 1), ('Kyongsangnam', 3), ('Kyoto', 1), ('København', 1), ('La Habana', 1), ('La Libertad', 1), ('La Paz', 2), ('Lagos', 1), ('Lambayeque', 1), ('Lampung', 1), ('Lara', 1), ('Latium', 1), ('Leinster', 1), ('Liaoning', 12), ('Liguria', 1), ('Lilongwe', 1), ('Lima', 1), ('Lipetsk', 1), ('Lisboa', 2), ('Littoral', 1), ('Lodzkie', 1), ('Lombardia', 1), ('Loreto', 1), ('Louisiana', 1), ('Luanda', 1), ('Lubelskie', 1), ('Lugansk', 1), ('Lusaka', 1), ('Luxor', 1), ('Lviv', 1), ('Macau', 1), ('Madhya Pradesh', 5), ('Madrid', 1), ('Maekel', 1), ('Magdalena', 1), ('Maharashtra', 13), ('Malopolskie', 1), ('Managua', 1), ('Mandalay', 1), ('Manitoba', 1), ('Maputo', 2), ('Maranhão', 1), ('Maritime', 1), ('Markazi', 1), ('Marrakech-Tensift-Al', 1), ('Maryland', 1), ('Massachusetts', 1), ('Mato Grosso', 1), ('Mato Grosso do Sul', 1), ('Mazowieckie', 1), ('Medina', 1), ('Mekka', 3), ('Meknès-Tafilalet', 1), ('Michigan', 1), ('Michoacán de Ocampo', 1), ('Midi-Pyrénées', 1), ('Minas Gerais', 4), ('Minnesota', 1), ('Miranda', 1), ('Missouri', 1), ('Miyagi', 1), ('Mogiljov', 1), ('Montevideo', 1), ('Montserrado', 1), ('Moscow (City)', 1), ('Murcia', 1), ('Murmansk', 1), ('Mykolajiv', 1), ('México', 9), ('Nagano', 1), ('Nagasaki', 1), ('Nairobi', 1), ('Namangan', 1), ('Nampo-si', 1), ('Nara', 1), ('National Capital Reg', 12), ('Nebraska', 1), ('Nevada', 1), ('New Mexico', 1), ('New South Wales', 1), ('New York', 1), ('Newmaa', 1), ('Niamey', 1), ('Niedersachsen', 1), ('Niigata', 1), ('Ninawa', 1), ('Ningxia', 1), ('Nizni Novgorod', 1), ('Noord-Holland', 1), ('Nordrhein-Westfalen', 7), ('Norte de Santander', 1), ('North Carolina', 1), ('Northern Mindanao', 1), ('Nothwest Border Prov', 1), ('Nouakchott', 1), ('Novosibirsk', 1), ('Nuevo León', 3), ('Odesa', 1), ('Ogun', 1), ('Ohio', 2), ('Oita', 1), ('Okayama', 2), ('Oklahoma', 2), ('Omsk', 1), ('Ondo & Ekiti', 1), ('Ontario', 4), ('Oran', 1), ('Oregon', 1), ('Orenburg', 1), ('Oriental', 1), ('Orissa', 2), ('Osaka', 6), ('Oslo', 1), ('Ouest', 1), ('Oyo & Osun', 5), ('Panamá', 1), ('Paraná', 2), ('Paraíba', 2), ('Pará', 2), ('Peking', 1), ('Pennsylvania', 1), ('Penza', 1), ('Perak', 1), ('Perm', 1), ('Pernambuco', 3), ('Phnom Penh', 1), ('Piauí', 1), ('Pichincha', 1), ('Piemonte', 1), ('Pietari', 1), ('Pomorskie', 1), ('Port Said', 1), ('Primorje', 1), ('Provence-Alpes-Côte', 1), ('Puebla', 1), ('Punjab', 11), ('Pusan', 1), ('Pyongyang-si', 1), ('Qaraghandy', 1), ('Qinghai', 1), ('Qom', 1), ('Quang Nam-Da Nang', 1), ('Queensland', 1), ('Querétaro de Arteaga', 1), ('Quintana Roo', 1), ('Québec', 1), ('Rabat-Salé-Zammour-Z', 2), ('Rajasthan', 5), ('Rangoon [Yangon]', 1), ('Rhône-Alpes', 1), ('Riau', 1), ('Riika', 1), ('Rio Grande do Norte', 1), ('Rio Grande do Sul', 1), ('Rio de Janeiro', 8), ('Risaralda', 1), ('Rivers & Bayelsa', 1), ('Riyadh', 1), ('Rjazan', 1), ('Rostov-na-Donu', 1), ('Saitama', 3), ('Saksi', 2), ('Salta', 1), ('Samara', 2), ('Samarkand', 1), ('San Juan', 1), ('San Luis Potosí', 1), ('San Salvador', 1), ('Sanaa', 1), ('Sanliurfa', 1), ('Santa Catarina', 1), ('Santa Cruz', 1), ('Santa Fé', 2), ('Santafé de Bogotá', 1), ('Santander', 1), ('Santiago', 3), ('Santiago de Cuba', 1), ('Saratov', 1), ('Scotland', 2), ('Seoul', 1), ('Sergipe', 1), ('Shaanxi', 2), ('Shaba', 2), ('Shandong', 7), ('Shanghai', 1), ('Shanxi', 3), ('Shizuoka', 2), ('Sichuan', 3), ('Sinaloa', 3), ('Sindh', 2), ('Sisilia', 1), ('Sistan va Baluchesta', 1), ('Skopje', 1), ('Smolensk', 1), ('Sofala', 1), ('Sonora', 2), ('South Australia', 1), ('South Kazakstan', 1), ('Southern Mindanao', 2), ('Southern Tagalog', 2), ('Suez', 1), ('Sulawesi Selatan', 1), ('Sumatera Barat', 1), ('Sumatera Selatan', 1), ('Sumatera Utara', 1), ('Sverdlovsk', 2), ('São Paulo', 13), ('Tabasco', 1), ('Taegu', 1), ('Taejon', 1), ('Taichung', 1), ('Tainan', 1), ('Taipei', 5), ('Tamaulipas', 2), ('Tamil Nadu', 5), ('Tanger-Tétouan', 1), ('Tatarstan', 2), ('Tbilisi', 1), ('Teheran', 2), ('Tennessee', 2), ('Texas', 6), ('Tianjin', 1), ('Tjumen', 1), ('Tochigi', 1), ('Tokyo-to', 3), ('Tolima', 1), ('Tomsk', 1), ('Toscana', 1), ('Toskent Shahri', 1), ('Tripoli', 1), ('Tucumán', 1), ('Tula', 1), ('Tunis', 1), ('Tver', 1), ('Tšeljabinsk', 2), ('Tšuvassia', 1), ('Udmurtia', 1), ('Ulaanbaatar', 1), ('Uljanovsk', 1), ('Uttar Pradesh', 12), ('Valencia', 1), ('Valle', 1), ('Veracruz', 2), ('Viangchan', 1), ('Victoria', 1), ('Vilna', 1), ('Vinnytsja', 1), ('Virginia', 1), ('Volgograd', 1), ('Voronez', 1), ('Wakayama', 1), ('Washington', 1), ('West Australia', 1), ('West Azerbaidzan', 1), ('West Bengali', 3), ('West Götanmaan län', 1), ('West Java', 4), ('West Kasai', 1), ('Western', 2), ('Western Cape', 1), ('Western Mindanao', 1), ('Western Visayas', 2), ('Wielkopolskie', 1), ('Wien', 1), ('Wilayah Persekutuan', 1), ('Wisconsin', 1), ('Xinxiang', 1), ('Yerevan', 1), ('Yogyakarta', 1), ('Yucatán', 1), ('Yunnan', 1), ('Zachodnio-Pomorskie', 1), ('Zaporizzja', 1), ('Zhejiang', 3), ('Zuid-Holland', 2), ('Zulia', 1), ('al-Daqahliya', 1), ('al-Gharbiya', 2), ('al-Qalyubiya', 1), ('al-Sharqiya', 1), ('al-Sulaymaniya', 1), ('al-Tamim', 1), ('al-Zarqa', 1), ('Île-de-France', 1), ('–', 1)]","[(1, 'Abidjan'), (1, 'Abu Dhabi'), (1, 'Adana'), (1, 'Addis Abeba'), (1, 'Aden'), (1, 'Aguascalientes'), (1, 'Ahal'), (2, 'Aichi'), (1, 'Alagoas'), (2, 'Alberta'), (1, 'Aleksandria'), (1, 'Aleppo'), (1, 'Alger'), (1, 'Almaty Qalasy'), (1, 'Altai'), (1, 'Amazonas'), (1, 'Amman'), (1, 'Anambra & Enugu & Eb'), (2, 'Andalusia'), (5, 'Andhra Pradesh'), (5, 'Anhui'), (1, 'Ankara'), (1, 'Antalya'), (1, 'Antananarivo'), (1, 'Antioquia'), (1, 'Antwerpen'), (1, 'Aragonia'), (1, 'Aragua'), (1, 'Arequipa'), (3, 'Arizona'), (1, 'Arkangeli'), (1, 'Ashanti'), (1, 'Assam'), (1, 'Astrahan'), (1, 'Asunción'), (1, 'Atlantique'), (1, 'Atlántico'), (1, 'Attika'), (1, 'Auckland'), (1, 'Baden-Württemberg'), (1, 'Baghdad'), (2, 'Bahia'), (2, 'Baijeri'), (3, 'Baja California'), (1, 'Baki'), (1, 'Bali'), (1, 'Baluchistan'), (1, 'Bamako'), (1, 'Banaadir'), (1, 'Bangkok'), (1, 'Bangui'), (1, 'Baskimaa'), (1, 'Basra'), (1, 'Baškortostan'), (1, 'Beirut'), (1, 'Bengasi'), (1, 'Berliini'), (1, 'Bihar'), (1, 'Bishkek shaary'), (1, 'Blantyre'), (2, 'Bolívar'), (1, 'Bratislava'), (1, 'Brazzaville'), (1, 'Bremen'), (1, 'British Colombia'), (1, 'Brjansk'), (1, 'Budapest'), (12, 'Buenos Aires'), (1, 'Bukarest'), (1, 'Bulawayo'), (1, 'Burjatia'), (1, 'Bursa'), (8, 'California'), (1, 'Callao'), (1, 'Campania'), (1, 'Canary Islands'), (2, 'Cap-Vert'), (1, 'Carabobo'), (1, 'Casablanca'), (1, 'Ceará'), (2, 'Central'), (2, 'Central Java'), (1, 'Central Macedonia'), (1, 'Central Serbia'), (1, 'Central Visayas'), (1, 'Centre'), (1, 'Chandigarh'), (1, 'Chari-Baguirmi'), (2, 'Chhatisgarh'), (1, 'Chiapas'), (4, 'Chiba'), (2, 'Chihuahua'), (1, 'Chisinau'), (1, 'Chittagong'), (1, 'Chollabuk'), (1, 'Chongqing'), (1, 'Chungchongbuk'), (2, 'Coahuila de Zaragoza'), (1, 'Coast'), (1, 'Cochabamba'), (2, 'Colorado'), (1, 'Conakry'), (1, 'Constantine'), (1, 'Cortés'), (1, 'Córdoba'), (1, 'Damascus'), (1, 'Dar es Salaam'), (1, 'Delhi'), (1, 'Dhaka'), (1, 'District of Columbia'), (1, 'Distrito Central'), (4, 'Distrito Federal'), (1, 'Distrito Nacional'), (1, 'Diyarbakir'), (1, 'Djibouti'), (2, 'Dnipropetrovsk'), (1, 'Doha'), (1, 'Dolnoslaskie'), (3, 'Donetsk'), (1, 'Dubai'), (1, 'Durango'), (1, 'East Azerbaidzan'), (2, 'East Java'), (1, 'East Kasai'), (1, 'Eastern Cape'), (1, 'Ehime'), (1, 'Emilia-Romagna'), (7, 'England'), (1, 'Esfahan'), (1, 'Eskisehir'), (1, 'Estuaire'), (1, 'Fars'), (1, 'Federaatio'), (2, 'Florida'), (2, 'Fujian'), (2, 'Fukuoka'), (1, 'Fukushima'), (1, 'Fès-Boulemane'), (1, 'Gansu'), (7, 'Gauteng'), (1, 'Gaza'), (1, 'Gaziantep'), (1, 'Georgia'), (1, 'Gifu'), (1, 'Gilan'), (1, 'Giza'), (1, 'Goiás'), (1, 'Gomel'), (1, 'Grad Sofija'), (1, 'Grad Zagreb'), (1, 'Greater Accra'), (3, 'Guanajuato'), (4, 'Guangdong'), (3, 'Guangxi'), (1, 'Guatemala'), (1, 'Guayas'), (1, 'Guerrero'), (2, 'Guizhou'), (5, 'Gujarat'), (1, 'Habarovsk'), (1, 'Hainan'), (1, 'Haiphong'), (1, 'Hamadan'), (1, 'Hamburg'), (1, 'Hamgyong N'), (1, 'Hamgyong P'), (1, 'Hanoi'), (1, 'Harare'), (1, 'Harjumaa'), (1, 'Harkova'), (1, 'Haryana'), (1, 'Haute-Zaïre'), (1, 'Hawaii'), (6, 'Hebei'), (9, 'Heilongjiang'), (7, 'Henan'), (1, 'Herson'), (1, 'Hessen'), (1, 'Hims'), (2, 'Hiroshima'), (1, 'Hlavní mesto Praha'), (1, 'Ho Chi Minh City'), (2, 'Hokkaido'), (1, 'Hongkong'), (1, 'Horad Minsk'), (1, 'Hsinchu'), (4, 'Hubei'), (4, 'Hunan'), (4, 'Hyogo'), (1, 'Illinois'), (1, 'Inchon'), (1, 'Indiana'), (3, 'Inner Mongolia'), (1, 'Irbil'), (1, 'Irkutsk'), (1, 'Ishikawa'), (1, 'Islamabad'), (1, 'Istanbul'), (1, 'Ivanovo'), (1, 'Izmir'), (1, 'Içel'), (1, 'Jakarta Raya'), (3, 'Jalisco'), (1, 'Jambi'), (1, 'Jammu and Kashmir'), (1, 'Jaroslavl'), (1, 'Jerusalem'), (2, 'Jharkhand'), (7, 'Jiangsu'), (2, 'Jiangxi'), (4, 'Jilin'), (1, 'Jizní Morava'), (1, 'Kabol'), (1, 'Kadiogo'), (1, 'Kaduna'), (1, 'Kagoshima'), (1, 'Kairo'), (1, 'Kalimantan Barat'), (1, 'Kalimantan Selatan'), (1, 'Kalimantan Timur'), (1, 'Kaliningrad'), (5, 'Kanagawa'), (1, 'Kano & Jigawa'), (1, 'Kaohsiung'), (3, 'Karnataka'), (1, 'Karotegin'), (1, 'Katalonia'), (1, 'Kaunas'), (1, 'Kayseri'), (1, 'Keelung'), (2, 'Kemerovo'), (3, 'Kerala'), (1, 'Kerman'), (1, 'Kermanshah'), (3, 'Khartum'), (1, 'Khorasan'), (1, 'Khulna'), (1, 'Khuzestan'), (1, 'Kinshasa'), (1, 'Kiova'), (1, 'Kirov'), (1, 'Konya'), (1, 'Kouilou'), (1, 'Kowloon and New Kowl'), (2, 'Krasnodar'), (1, 'Krasnojarsk'), (1, 'Kujawsko-Pomorskie'), (1, 'Kumamoto'), (1, 'Kurgan'), (1, 'Kursk'), (4, 'KwaZulu-Natal'), (1, 'Kwangju'), (1, 'Kwara & Kogi'), (7, 'Kyonggi'), (1, 'Kyongsangbuk'), (3, 'Kyongsangnam'), (1, 'Kyoto'), (1, 'København'), (1, 'La Habana'), (1, 'La Libertad'), (2, 'La Paz'), (1, 'Lagos'), (1, 'Lambayeque'), (1, 'Lampung'), (1, 'Lara'), (1, 'Latium'), (1, 'Leinster'), (12, 'Liaoning'), (1, 'Liguria'), (1, 'Lilongwe'), (1, 'Lima'), (1, 'Lipetsk'), (2, 'Lisboa'), (1, 'Littoral'), (1, 'Lodzkie'), (1, 'Lombardia'), (1, 'Loreto'), (1, 'Louisiana'), (1, 'Luanda'), (1, 'Lubelskie'), (1, 'Lugansk'), (1, 'Lusaka'), (1, 'Luxor'), (1, 'Lviv'), (1, 'Macau'), (5, 'Madhya Pradesh'), (1, 'Madrid'), (1, 'Maekel'), (1, 'Magdalena'), (13, 'Maharashtra'), (1, 'Malopolskie'), (1, 'Managua'), (1, 'Mandalay'), (1, 'Manitoba'), (2, 'Maputo'), (1, 'Maranhão'), (1, 'Maritime'), (1, 'Markazi'), (1, 'Marrakech-Tensift-Al'), (1, 'Maryland'), (1, 'Massachusetts'), (1, 'Mato Grosso'), (1, 'Mato Grosso do Sul'), (1, 'Mazowieckie'), (1, 'Medina'), (3, 'Mekka'), (1, 'Meknès-Tafilalet'), (1, 'Michigan'), (1, 'Michoacán de Ocampo'), (1, 'Midi-Pyrénées'), (4, 'Minas Gerais'), (1, 'Minnesota'), (1, 'Miranda'), (1, 'Missouri'), (1, 'Miyagi'), (1, 'Mogiljov'), (1, 'Montevideo'), (1, 'Montserrado'), (1, 'Moscow (City)'), (1, 'Murcia'), (1, 'Murmansk'), (1, 'Mykolajiv'), (9, 'México'), (1, 'Nagano'), (1, 'Nagasaki'), (1, 'Nairobi'), (1, 'Namangan'), (1, 'Nampo-si'), (1, 'Nara'), (12, 'National Capital Reg'), (1, 'Nebraska'), (1, 'Nevada'), (1, 'New Mexico'), (1, 'New South Wales'), (1, 'New York'), (1, 'Newmaa'), (1, 'Niamey'), (1, 'Niedersachsen'), (1, 'Niigata'), (1, 'Ninawa'), (1, 'Ningxia'), (1, 'Nizni Novgorod'), (1, 'Noord-Holland'), (7, 'Nordrhein-Westfalen'), (1, 'Norte de Santander'), (1, 'North Carolina'), (1, 'Northern Mindanao'), (1, 'Nothwest Border Prov'), (1, 'Nouakchott'), (1, 'Novosibirsk'), (3, 'Nuevo León'), (1, 'Odesa'), (1, 'Ogun'), (2, 'Ohio'), (1, 'Oita'), (2, 'Okayama'), (2, 'Oklahoma'), (1, 'Omsk'), (1, 'Ondo & Ekiti'), (4, 'Ontario'), (1, 'Oran'), (1, 'Oregon'), (1, 'Orenburg'), (1, 'Oriental'), (2, 'Orissa'), (6, 'Osaka'), (1, 'Oslo'), (1, 'Ouest'), (5, 'Oyo & Osun'), (1, 'Panamá'), (2, 'Paraná'), (2, 'Paraíba'), (2, 'Pará'), (1, 'Peking'), (1, 'Pennsylvania'), (1, 'Penza'), (1, 'Perak'), (1, 'Perm'), (3, 'Pernambuco'), (1, 'Phnom Penh'), (1, 'Piauí'), (1, 'Pichincha'), (1, 'Piemonte'), (1, 'Pietari'), (1, 'Pomorskie'), (1, 'Port Said'), (1, 'Primorje'), (1, 'Provence-Alpes-Côte'), (1, 'Puebla'), (11, 'Punjab'), (1, 'Pusan'), (1, 'Pyongyang-si'), (1, 'Qaraghandy'), (1, 'Qinghai'), (1, 'Qom'), (1, 'Quang Nam-Da Nang'), (1, 'Queensland'), (1, 'Querétaro de Arteaga'), (1, 'Quintana Roo'), (1, 'Québec'), (2, 'Rabat-Salé-Zammour-Z'), (5, 'Rajasthan'), (1, 'Rangoon [Yangon]'), (1, 'Rhône-Alpes'), (1, 'Riau'), (1, 'Riika'), (1, 'Rio Grande do Norte'), (1, 'Rio Grande do Sul'), (8, 'Rio de Janeiro'), (1, 'Risaralda'), (1, 'Rivers & Bayelsa'), (1, 'Riyadh'), (1, 'Rjazan'), (1, 'Rostov-na-Donu'), (3, 'Saitama'), (2, 'Saksi'), (1, 'Salta'), (2, 'Samara'), (1, 'Samarkand'), (1, 'San Juan'), (1, 'San Luis Potosí'), (1, 'San Salvador'), (1, 'Sanaa'), (1, 'Sanliurfa'), (1, 'Santa Catarina'), (1, 'Santa Cruz'), (2, 'Santa Fé'), (1, 'Santafé de Bogotá'), (1, 'Santander'), (3, 'Santiago'), (1, 'Santiago de Cuba'), (1, 'Saratov'), (2, 'Scotland'), (1, 'Seoul'), (1, 'Sergipe'), (2, 'Shaanxi'), (2, 'Shaba'), (7, 'Shandong'), (1, 'Shanghai'), (3, 'Shanxi'), (2, 'Shizuoka'), (3, 'Sichuan'), (3, 'Sinaloa'), (2, 'Sindh'), (1, 'Sisilia'), (1, 'Sistan va Baluchesta'), (1, 'Skopje'), (1, 'Smolensk'), (1, 'Sofala'), (2, 'Sonora'), (1, 'South Australia'), (1, 'South Kazakstan'), (2, 'Southern Mindanao'), (2, 'Southern Tagalog'), (1, 'Suez'), (1, 'Sulawesi Selatan'), (1, 'Sumatera Barat'), (1, 'Sumatera Selatan'), (1, 'Sumatera Utara'), (2, 'Sverdlovsk'), (13, 'São Paulo'), (1, 'Tabasco'), (1, 'Taegu'), (1, 'Taejon'), (1, 'Taichung'), (1, 'Tainan'), (5, 'Taipei'), (2, 'Tamaulipas'), (5, 'Tamil Nadu'), (1, 'Tanger-Tétouan'), (2, 'Tatarstan'), (1, 'Tbilisi'), (2, 'Teheran'), (2, 'Tennessee'), (6, 'Texas'), (1, 'Tianjin'), (1, 'Tjumen'), (1, 'Tochigi'), (3, 'Tokyo-to'), (1, 'Tolima'), (1, 'Tomsk'), (1, 'Toscana'), (1, 'Toskent Shahri'), (1, 'Tripoli'), (1, 'Tucumán'), (1, 'Tula'), (1, 'Tunis'), (1, 'Tver'), (2, 'Tšeljabinsk'), (1, 'Tšuvassia'), (1, 'Udmurtia'), (1, 'Ulaanbaatar'), (1, 'Uljanovsk'), (12, 'Uttar Pradesh'), (1, 'Valencia'), (1, 'Valle'), (2, 'Veracruz'), (1, 'Viangchan'), (1, 'Victoria'), (1, 'Vilna'), (1, 'Vinnytsja'), (1, 'Virginia'), (1, 'Volgograd'), (1, 'Voronez'), (1, 'Wakayama'), (1, 'Washington'), (1, 'West Australia'), (1, 'West Azerbaidzan'), (3, 'West Bengali'), (1, 'West Götanmaan län'), (4, 'West Java'), (1, 'West Kasai'), (2, 'Western'), (1, 'Western Cape'), (1, 'Western Mindanao'), (2, 'Western Visayas'), (1, 'Wielkopolskie'), (1, 'Wien'), (1, 'Wilayah Persekutuan'), (1, 'Wisconsin'), (1, 'Xinxiang'), (1, 'Yerevan'), (1, 'Yogyakarta'), (1, 'Yucatán'), (1, 'Yunnan'), (1, 'Zachodnio-Pomorskie'), (1, 'Zaporizzja'), (3, 'Zhejiang'), (2, 'Zuid-Holland'), (1, 'Zulia'), (1, 'al-Daqahliya'), (2, 'al-Gharbiya'), (1, 'al-Qalyubiya'), (1, 'al-Sharqiya'), (1, 'al-Sulaymaniya'), (1, 'al-Tamim'), (1, 'al-Zarqa'), (1, 'Île-de-France'), (1, '–')]",,1.0,
how many countries are in Asia?,"[country.Name, country.Continent, Asia]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT COUNT(country.Name) FROM country WHERE country.Continent = 'Asia';,"SELECT count(*) FROM country WHERE continent  =  ""Asia""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the number of countries in Asia. 2. Condition Structure: Use a WHERE clause to filter for countries where ""country.Continent"" is 'Asia'. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of countries in Asia.","[(51,)]","[(51,)]",,1.0,
Give the country codes for countries in which people speak langauges that are not English.,"[countrylanguage.CountryCode, countrylanguage.Language, country.Code, countrylanguage.CountryCode = country.Code, English]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT DISTINCT CountryCode FROM countrylanguage WHERE Language != 'English';,"SELECT DISTINCT CountryCode FROM countrylanguage WHERE LANGUAGE != ""English""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the country codes. Use the FROM clause to specify the countrylanguage table. Apply a WHERE clause to filter for languages that are not English. 2. Condition Structure: Use the WHERE clause to exclude rows where the language is 'English'. 3. Join Structure: Not required, as the necessary data is available in the countrylanguage table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.","[('ABW',), ('AFG',), ('AGO',), ('ALB',), ('AND',), ('ANT',), ('ARE',), ('ARG',), ('ARM',), ('ASM',), ('ATG',), ('AUS',), ('AUT',), ('AZE',), ('BDI',), ('BEL',), ('BEN',), ('BFA',), ('BGD',), ('BGR',), ('BHR',), ('BHS',), ('BIH',), ('BLR',), ('BLZ',), ('BOL',), ('BRA',), ('BRB',), ('BRN',), ('BTN',), ('BWA',), ('CAF',), ('CAN',), ('CCK',), ('CHE',), ('CHL',), ('CHN',), ('CIV',), ('CMR',), ('COD',), ('COG',), ('COK',), ('COL',), ('COM',), ('CPV',), ('CRI',), ('CUB',), ('CXR',), ('CYP',), ('CZE',), ('DEU',), ('DJI',), ('DMA',), ('DNK',), ('DOM',), ('DZA',), ('ECU',), ('EGY',), ('ERI',), ('ESH',), ('ESP',), ('EST',), ('ETH',), ('FIN',), ('FJI',), ('FRA',), ('FRO',), ('FSM',), ('GAB',), ('GBR',), ('GEO',), ('GHA',), ('GIB',), ('GIN',), ('GLP',), ('GMB',), ('GNB',), ('GNQ',), ('GRC',), ('GRD',), ('GRL',), ('GTM',), ('GUF',), ('GUM',), ('GUY',), ('HKG',), ('HND',), ('HRV',), ('HTI',), ('HUN',), ('IDN',), ('IND',), ('IRL',), ('IRN',), ('IRQ',), ('ISL',), ('ISR',), ('ITA',), ('JAM',), ('JOR',), ('JPN',), ('KAZ',), ('KEN',), ('KGZ',), ('KHM',), ('KIR',), ('KNA',), ('KOR',), ('KWT',), ('LAO',), ('LBN',), ('LBR',), ('LBY',), ('LCA',), ('LIE',), ('LKA',), ('LSO',), ('LTU',), ('LUX',), ('LVA',), ('MAC',), ('MAR',), ('MCO',), ('MDA',), ('MDG',), ('MDV',), ('MEX',), ('MHL',), ('MKD',), ('MLI',), ('MLT',), ('MMR',), ('MNG',), ('MNP',), ('MOZ',), ('MRT',), ('MTQ',), ('MUS',), ('MWI',), ('MYS',), ('MYT',), ('NAM',), ('NCL',), ('NER',), ('NGA',), ('NIC',), ('NIU',), ('NLD',), ('NOR',), ('NPL',), ('NRU',), ('NZL',), ('OMN',), ('PAK',), ('PAN',), ('PCN',), ('PER',), ('PHL',), ('PLW',), ('PNG',), ('POL',), ('PRI',), ('PRK',), ('PRT',), ('PRY',), ('PSE',), ('PYF',), ('QAT',), ('REU',), ('ROM',), ('RUS',), ('RWA',), ('SAU',), ('SDN',), ('SEN',), ('SGP',), ('SJM',), ('SLB',), ('SLE',), ('SLV',), ('SMR',), ('SOM',), ('SPM',), ('STP',), ('SUR',), ('SVK',), ('SVN',), ('SWE',), ('SWZ',), ('SYC',), ('SYR',), ('TCD',), ('TGO',), ('THA',), ('TJK',), ('TKL',), ('TKM',), ('TMP',), ('TON',), ('TTO',), ('TUN',), ('TUR',), ('TUV',), ('TWN',), ('TZA',), ('UGA',), ('UKR',), ('URY',), ('USA',), ('UZB',), ('VAT',), ('VCT',), ('VEN',), ('VIR',), ('VNM',), ('VUT',), ('WLF',), ('WSM',), ('YEM',), ('YUG',), ('ZAF',), ('ZMB',), ('ZWE',)]","[('ABW',), ('AFG',), ('AGO',), ('ALB',), ('AND',), ('ANT',), ('ARE',), ('ARG',), ('ARM',), ('ASM',), ('ATG',), ('AUS',), ('AUT',), ('AZE',), ('BDI',), ('BEL',), ('BEN',), ('BFA',), ('BGD',), ('BGR',), ('BHR',), ('BHS',), ('BIH',), ('BLR',), ('BLZ',), ('BOL',), ('BRA',), ('BRB',), ('BRN',), ('BTN',), ('BWA',), ('CAF',), ('CAN',), ('CCK',), ('CHE',), ('CHL',), ('CHN',), ('CIV',), ('CMR',), ('COD',), ('COG',), ('COK',), ('COL',), ('COM',), ('CPV',), ('CRI',), ('CUB',), ('CXR',), ('CYP',), ('CZE',), ('DEU',), ('DJI',), ('DMA',), ('DNK',), ('DOM',), ('DZA',), ('ECU',), ('EGY',), ('ERI',), ('ESH',), ('ESP',), ('EST',), ('ETH',), ('FIN',), ('FJI',), ('FRA',), ('FRO',), ('FSM',), ('GAB',), ('GBR',), ('GEO',), ('GHA',), ('GIB',), ('GIN',), ('GLP',), ('GMB',), ('GNB',), ('GNQ',), ('GRC',), ('GRD',), ('GRL',), ('GTM',), ('GUF',), ('GUM',), ('GUY',), ('HKG',), ('HND',), ('HRV',), ('HTI',), ('HUN',), ('IDN',), ('IND',), ('IRL',), ('IRN',), ('IRQ',), ('ISL',), ('ISR',), ('ITA',), ('JAM',), ('JOR',), ('JPN',), ('KAZ',), ('KEN',), ('KGZ',), ('KHM',), ('KIR',), ('KNA',), ('KOR',), ('KWT',), ('LAO',), ('LBN',), ('LBR',), ('LBY',), ('LCA',), ('LIE',), ('LKA',), ('LSO',), ('LTU',), ('LUX',), ('LVA',), ('MAC',), ('MAR',), ('MCO',), ('MDA',), ('MDG',), ('MDV',), ('MEX',), ('MHL',), ('MKD',), ('MLI',), ('MLT',), ('MMR',), ('MNG',), ('MNP',), ('MOZ',), ('MRT',), ('MTQ',), ('MUS',), ('MWI',), ('MYS',), ('MYT',), ('NAM',), ('NCL',), ('NER',), ('NGA',), ('NIC',), ('NIU',), ('NLD',), ('NOR',), ('NPL',), ('NRU',), ('NZL',), ('OMN',), ('PAK',), ('PAN',), ('PCN',), ('PER',), ('PHL',), ('PLW',), ('PNG',), ('POL',), ('PRI',), ('PRK',), ('PRT',), ('PRY',), ('PSE',), ('PYF',), ('QAT',), ('REU',), ('ROM',), ('RUS',), ('RWA',), ('SAU',), ('SDN',), ('SEN',), ('SGP',), ('SJM',), ('SLB',), ('SLE',), ('SLV',), ('SMR',), ('SOM',), ('SPM',), ('STP',), ('SUR',), ('SVK',), ('SVN',), ('SWE',), ('SWZ',), ('SYC',), ('SYR',), ('TCD',), ('TGO',), ('THA',), ('TJK',), ('TKL',), ('TKM',), ('TMP',), ('TON',), ('TTO',), ('TUN',), ('TUR',), ('TUV',), ('TWN',), ('TZA',), ('UGA',), ('UKR',), ('URY',), ('USA',), ('UZB',), ('VAT',), ('VCT',), ('VEN',), ('VIR',), ('VNM',), ('VUT',), ('WLF',), ('WSM',), ('YEM',), ('YUG',), ('ZAF',), ('ZMB',), ('ZWE',)]",,1.0,
Which cities are in European countries where English is not the official language?,"[city.Name, country.Continent, countrylanguage.Language, countrylanguage.IsOfficial, city.CountryCode = country.Code, countrylanguage.CountryCode = country.Code, European, English, 0]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT city.Name FROM city JOIN country ON city.CountryCode = country.Code JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Continent = 'Europe' AND countrylanguage.Language = 'English' AND countrylanguage.IsOfficial = 0;,SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English'),world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of cities. Use the FROM clause to specify the city table. Join it with the country table to filter cities in European countries, and then join with the countrylanguage table to check the language conditions. Apply a WHERE clause to filter for countries in Europe where English is not the official language. 2. Condition Structure: Use the WHERE clause to filter for countries in the ""European"" continent and where the language is ""English"" but is not marked as official (IsOfficial = 0). 3. Join Structure: Use INNER JOINs between the city, country, and countrylanguage tables. The city table is joined with the country table on CountryCode = Code, and the country table is joined with the countrylanguage table on CountryCode = Code. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",[],"[('Amsterdam',), ('Rotterdam',), ('Haag',), ('Utrecht',), ('Eindhoven',), ('Tilburg',), ('Groningen',), ('Breda',), ('Apeldoorn',), ('Nijmegen',), ('Enschede',), ('Haarlem',), ('Almere',), ('Arnhem',), ('Zaanstad',), ('´s-Hertogenbosch',), ('Amersfoort',), ('Maastricht',), ('Dordrecht',), ('Leiden',), ('Haarlemmermeer',), ('Zoetermeer',), ('Emmen',), ('Zwolle',), ('Ede',), ('Delft',), ('Heerlen',), ('Alkmaar',), ('Tirana',), ('Andorra la Vella',), ('Antwerpen',), ('Gent',), ('Charleroi',), ('Liège',), ('Bruxelles [Brussel]',), ('Brugge',), ('Schaerbeek',), ('Namur',), ('Mons',), ('Sarajevo',), ('Banja Luka',), ('Zenica',), ('Sofija',), ('Plovdiv',), ('Varna',), ('Burgas',), ('Ruse',), ('Stara Zagora',), ('Pleven',), ('Sliven',), ('Dobric',), ('Šumen',), ('Madrid',), ('Barcelona',), ('Valencia',), ('Sevilla',), ('Zaragoza',), ('Málaga',), ('Bilbao',), ('Las Palmas de Gran Canaria',), ('Murcia',), ('Palma de Mallorca',), ('Valladolid',), ('Córdoba',), ('Vigo',), ('Alicante [Alacant]',), ('Gijón',), ('L´Hospitalet de Llobregat',), ('Granada',), ('A Coruña (La Coruña)',), ('Vitoria-Gasteiz',), ('Santa Cruz de Tenerife',), ('Badalona',), ('Oviedo',), ('Móstoles',), ('Elche [Elx]',), ('Sabadell',), ('Santander',), ('Jerez de la Frontera',), ('Pamplona [Iruña]',), ('Donostia-San Sebastián',), ('Cartagena',), ('Leganés',), ('Fuenlabrada',), ('Almería',), ('Terrassa',), ('Alcalá de Henares',), ('Burgos',), ('Salamanca',), ('Albacete',), ('Getafe',), ('Cádiz',), ('Alcorcón',), ('Huelva',), ('León',), ('Castellón de la Plana [Castell',), ('Badajoz',), ('[San Cristóbal de] la Laguna',), ('Logroño',), ('Santa Coloma de Gramenet',), ('Tarragona',), ('Lleida (Lérida)',), ('Jaén',), ('Ourense (Orense)',), ('Mataró',), ('Algeciras',), ('Marbella',), ('Barakaldo',), ('Dos Hermanas',), ('Santiago de Compostela',), ('Torrejón de Ardoz',), ('Tórshavn',), ('Longyearbyen',), ('Reykjavík',), ('Roma',), ('Milano',), ('Napoli',), ('Torino',), ('Palermo',), ('Genova',), ('Bologna',), ('Firenze',), ('Catania',), ('Bari',), ('Venezia',), ('Messina',), ('Verona',), ('Trieste',), ('Padova',), ('Taranto',), ('Brescia',), ('Reggio di Calabria',), ('Modena',), ('Prato',), ('Parma',), ('Cagliari',), ('Livorno',), ('Perugia',), ('Foggia',), ('Reggio nell´ Emilia',), ('Salerno',), ('Ravenna',), ('Ferrara',), ('Rimini',), ('Syrakusa',), ('Sassari',), ('Monza',), ('Bergamo',), ('Pescara',), ('Latina',), ('Vicenza',), ('Terni',), ('Forlì',), ('Trento',), ('Novara',), ('Piacenza',), ('Ancona',), ('Lecce',), ('Bolzano',), ('Catanzaro',), ('La Spezia',), ('Udine',), ('Torre del Greco',), ('Andria',), ('Brindisi',), ('Giugliano in Campania',), ('Pisa',), ('Barletta',), ('Arezzo',), ('Alessandria',), ('Cesena',), ('Pesaro',), ('Wien',), ('Graz',), ('Linz',), ('Salzburg',), ('Innsbruck',), ('Klagenfurt',), ('Beograd',), ('Novi Sad',), ('Niš',), ('Priština',), ('Kragujevac',), ('Podgorica',), ('Subotica',), ('Prizren',), ('Athenai',), ('Thessaloniki',), ('Pireus',), ('Patras',), ('Peristerion',), ('Herakleion',), ('Kallithea',), ('Larisa',), ('Zagreb',), ('Split',), ('Rijeka',), ('Osijek',), ('Riga',), ('Daugavpils',), ('Liepaja',), ('Schaan',), ('Vaduz',), ('Vilnius',), ('Kaunas',), ('Klaipeda',), ('Šiauliai',), ('Panevezys',), ('Luxembourg [Luxemburg/Lëtzebuerg]',), ('Skopje',), ('Chisinau',), ('Tiraspol',), ('Balti',), ('Bender (Tîghina)',), ('Monte-Carlo',), ('Monaco-Ville',), ('Oslo',), ('Bergen',), ('Trondheim',), ('Stavanger',), ('Bærum',), ('Lisboa',), ('Porto',), ('Amadora',), ('Coímbra',), ('Braga',), ('Warszawa',), ('Lódz',), ('Kraków',), ('Wroclaw',), ('Poznan',), ('Gdansk',), ('Szczecin',), ('Bydgoszcz',), ('Lublin',), ('Katowice',), ('Bialystok',), ('Czestochowa',), ('Gdynia',), ('Sosnowiec',), ('Radom',), ('Kielce',), ('Gliwice',), ('Torun',), ('Bytom',), ('Zabrze',), ('Bielsko-Biala',), ('Olsztyn',), ('Rzeszów',), ('Ruda Slaska',), ('Rybnik',), ('Walbrzych',), ('Tychy',), ('Dabrowa Górnicza',), ('Plock',), ('Elblag',), ('Opole',), ('Gorzów Wielkopolski',), ('Wloclawek',), ('Chorzów',), ('Tarnów',), ('Zielona Góra',), ('Koszalin',), ('Legnica',), ('Kalisz',), ('Grudziadz',), ('Slupsk',), ('Jastrzebie-Zdrój',), ('Jaworzno',), ('Jelenia Góra',), ('Paris',), ('Marseille',), ('Lyon',), ('Toulouse',), ('Nice',), ('Nantes',), ('Strasbourg',), ('Montpellier',), ('Bordeaux',), ('Rennes',), ('Le Havre',), ('Reims',), ('Lille',), ('St-Étienne',), ('Toulon',), ('Grenoble',), ('Angers',), ('Dijon',), ('Brest',), ('Le Mans',), ('Clermont-Ferrand',), ('Amiens',), ('Aix-en-Provence',), ('Limoges',), ('Nîmes',), ('Tours',), ('Villeurbanne',), ('Metz',), ('Besançon',), ('Caen',), ('Orléans',), ('Mulhouse',), ('Rouen',), ('Boulogne-Billancourt',), ('Perpignan',), ('Nancy',), ('Roubaix',), ('Argenteuil',), ('Tourcoing',), ('Montreuil',), ('Bucuresti',), ('Iasi',), ('Constanta',), ('Cluj-Napoca',), ('Galati',), ('Timisoara',), ('Brasov',), ('Craiova',), ('Ploiesti',), ('Braila',), ('Oradea',), ('Bacau',), ('Pitesti',), ('Arad',), ('Sibiu',), ('Târgu Mures',), ('Baia Mare',), ('Buzau',), ('Satu Mare',), ('Botosani',), ('Piatra Neamt',), ('Râmnicu Vâlcea',), ('Suceava',), ('Drobeta-Turnu Severin',), ('Târgoviste',), ('Focsani',), ('Târgu Jiu',), ('Tulcea',), ('Resita',), ('Stockholm',), ('Gothenburg [Göteborg]',), ('Malmö',), ('Uppsala',), ('Linköping',), ('Västerås',), ('Örebro',), ('Norrköping',), ('Helsingborg',), ('Jönköping',), ('Umeå',), ('Lund',), ('Borås',), ('Sundsvall',), ('Gävle',), ('Berlin',), ('Hamburg',), ('Munich [München]',), ('Köln',), ('Frankfurt am Main',), ('Essen',), ('Dortmund',), ('Stuttgart',), ('Düsseldorf',), ('Bremen',), ('Duisburg',), ('Hannover',), ('Leipzig',), ('Nürnberg',), ('Dresden',), ('Bochum',), ('Wuppertal',), ('Bielefeld',), ('Mannheim',), ('Bonn',), ('Gelsenkirchen',), ('Karlsruhe',), ('Wiesbaden',), ('Münster',), ('Mönchengladbach',), ('Chemnitz',), ('Augsburg',), ('Halle/Saale',), ('Braunschweig',), ('Aachen',), ('Krefeld',), ('Magdeburg',), ('Kiel',), ('Oberhausen',), ('Lübeck',), ('Hagen',), ('Rostock',), ('Freiburg im Breisgau',), ('Erfurt',), ('Kassel',), ('Saarbrücken',), ('Mainz',), ('Hamm',), ('Herne',), ('Mülheim an der Ruhr',), ('Solingen',), ('Osnabrück',), ('Ludwigshafen am Rhein',), ('Leverkusen',), ('Oldenburg',), ('Neuss',), ('Heidelberg',), ('Darmstadt',), ('Paderborn',), ('Potsdam',), ('Würzburg',), ('Regensburg',), ('Recklinghausen',), ('Göttingen',), ('Bremerhaven',), ('Wolfsburg',), ('Bottrop',), ('Remscheid',), ('Heilbronn',), ('Pforzheim',), ('Offenbach am Main',), ('Ulm',), ('Ingolstadt',), ('Gera',), ('Salzgitter',), ('Cottbus',), ('Reutlingen',), ('Fürth',), ('Siegen',), ('Koblenz',), ('Moers',), ('Bergisch Gladbach',), ('Zwickau',), ('Hildesheim',), ('Witten',), ('Schwerin',), ('Erlangen',), ('Kaiserslautern',), ('Trier',), ('Jena',), ('Iserlohn',), ('Gütersloh',), ('Marl',), ('Lünen',), ('Düren',), ('Ratingen',), ('Velbert',), ('Esslingen am Neckar',), ('Serravalle',), ('San Marino',), ('Bratislava',), ('Košice',), ('Prešov',), ('Ljubljana',), ('Maribor',), ('Helsinki [Helsingfors]',), ('Espoo',), ('Tampere',), ('Vantaa',), ('Turku [Åbo]',), ('Oulu',), ('Lahti',), ('Zürich',), ('Geneve',), ('Basel',), ('Bern',), ('Lausanne',), ('København',), ('Århus',), ('Odense',), ('Aalborg',), ('Frederiksberg',), ('Praha',), ('Brno',), ('Ostrava',), ('Plzen',), ('Olomouc',), ('Liberec',), ('Ceské Budejovice',), ('Hradec Králové',), ('Ústí nad Labem',), ('Pardubice',), ('Kyiv',), ('Harkova [Harkiv]',), ('Dnipropetrovsk',), ('Donetsk',), ('Odesa',), ('Zaporizzja',), ('Lviv',), ('Kryvyi Rig',), ('Mykolajiv',), ('Mariupol',), ('Lugansk',), ('Vinnytsja',), ('Makijivka',), ('Herson',), ('Sevastopol',), ('Simferopol',), ('Pultava [Poltava]',), ('Tšernigiv',), ('Tšerkasy',), ('Gorlivka',), ('Zytomyr',), ('Sumy',), ('Dniprodzerzynsk',), ('Kirovograd',), ('Hmelnytskyi',), ('Tšernivtsi',), ('Rivne',), ('Krementšuk',), ('Ivano-Frankivsk',), ('Ternopil',), ('Lutsk',), ('Bila Tserkva',), ('Kramatorsk',), ('Melitopol',), ('Kertš',), ('Nikopol',), ('Berdjansk',), ('Pavlograd',), ('Sjeverodonetsk',), ('Slovjansk',), ('Uzgorod',), ('Altševsk',), ('Lysytšansk',), ('Jevpatorija',), ('Kamjanets-Podilskyi',), ('Jenakijeve',), ('Krasnyi Lutš',), ('Stahanov',), ('Oleksandrija',), ('Konotop',), ('Kostjantynivka',), ('Berdytšiv',), ('Izmajil',), ('Šostka',), ('Uman',), ('Brovary',), ('Mukatševe',), ('Budapest',), ('Debrecen',), ('Miskolc',), ('Szeged',), ('Pécs',), ('Györ',), ('Nyiregyháza',), ('Kecskemét',), ('Székesfehérvár',), ('Minsk',), ('Gomel',), ('Mogiljov',), ('Vitebsk',), ('Grodno',), ('Bobruisk',), ('Baranovitši',), ('Borisov',), ('Pinsk',), ('Orša',), ('Mozyr',), ('Novopolotsk',), ('Lida',), ('Soligorsk',), ('Molodetšno',), ('Città del Vaticano',), ('Moscow',), ('St Petersburg',), ('Novosibirsk',), ('Nizni Novgorod',), ('Jekaterinburg',), ('Samara',), ('Omsk',), ('Kazan',), ('Ufa',), ('Tšeljabinsk',), ('Rostov-na-Donu',), ('Perm',), ('Volgograd',), ('Voronez',), ('Krasnojarsk',), ('Saratov',), ('Toljatti',), ('Uljanovsk',), ('Izevsk',), ('Krasnodar',), ('Jaroslavl',), ('Habarovsk',), ('Vladivostok',), ('Irkutsk',), ('Barnaul',), ('Novokuznetsk',), ('Penza',), ('Rjazan',), ('Orenburg',), ('Lipetsk',), ('Nabereznyje Tšelny',), ('Tula',), ('Tjumen',), ('Kemerovo',), ('Astrahan',), ('Tomsk',), ('Kirov',), ('Ivanovo',), ('Tšeboksary',), ('Brjansk',), ('Tver',), ('Kursk',), ('Magnitogorsk',), ('Kaliningrad',), ('Nizni Tagil',), ('Murmansk',), ('Ulan-Ude',), ('Kurgan',), ('Arkangeli',), ('Sotši',), ('Smolensk',), ('Orjol',), ('Stavropol',), ('Belgorod',), ('Kaluga',), ('Vladimir',), ('Mahatškala',), ('Tšerepovets',), ('Saransk',), ('Tambov',), ('Vladikavkaz',), ('Tšita',), ('Vologda',), ('Veliki Novgorod',), ('Komsomolsk-na-Amure',), ('Kostroma',), ('Volzski',), ('Taganrog',), ('Petroskoi',), ('Bratsk',), ('Dzerzinsk',), ('Surgut',), ('Orsk',), ('Sterlitamak',), ('Angarsk',), ('Joškar-Ola',), ('Rybinsk',), ('Prokopjevsk',), ('Niznevartovsk',), ('Naltšik',), ('Syktyvkar',), ('Severodvinsk',), ('Bijsk',), ('Niznekamsk',), ('Blagoveštšensk',), ('Šahty',), ('Staryi Oskol',), ('Zelenograd',), ('Balakovo',), ('Novorossijsk',), ('Pihkova',), ('Zlatoust',), ('Jakutsk',), ('Podolsk',), ('Petropavlovsk-Kamtšatski',), ('Kamensk-Uralski',), ('Engels',), ('Syzran',), ('Grozny',), ('Novotšerkassk',), ('Berezniki',), ('Juzno-Sahalinsk',), ('Volgodonsk',), ('Abakan',), ('Maikop',), ('Miass',), ('Armavir',), ('Ljubertsy',), ('Rubtsovsk',), ('Kovrov',), ('Nahodka',), ('Ussurijsk',), ('Salavat',), ('Mytištši',), ('Kolomna',), ('Elektrostal',), ('Murom',), ('Kolpino',), ('Norilsk',), ('Almetjevsk',), ('Novomoskovsk',), ('Dimitrovgrad',), ('Pervouralsk',), ('Himki',), ('Balašiha',), ('Nevinnomyssk',), ('Pjatigorsk',), ('Korolev',), ('Serpuhov',), ('Odintsovo',), ('Orehovo-Zujevo',), ('Kamyšin',), ('Novotšeboksarsk',), ('Tšerkessk',), ('Atšinsk',), ('Magadan',), ('Mitšurinsk',), ('Kislovodsk',), ('Jelets',), ('Seversk',), ('Noginsk',), ('Velikije Luki',), ('Novokuibyševsk',), ('Neftekamsk',), ('Leninsk-Kuznetski',), ('Oktjabrski',), ('Sergijev Posad',), ('Arzamas',), ('Kiseljovsk',), ('Novotroitsk',), ('Obninsk',), ('Kansk',), ('Glazov',), ('Solikamsk',), ('Sarapul',), ('Ust-Ilimsk',), ('Štšolkovo',), ('Mezduretšensk',), ('Usolje-Sibirskoje',), ('Elista',), ('Novošahtinsk',), ('Votkinsk',), ('Kyzyl',), ('Serov',), ('Zelenodolsk',), ('Zeleznodoroznyi',), ('Kinešma',), ('Kuznetsk',), ('Uhta',), ('Jessentuki',), ('Tobolsk',), ('Neftejugansk',), ('Bataisk',), ('Nojabrsk',), ('Balašov',), ('Zeleznogorsk',), ('Zukovski',), ('Anzero-Sudzensk',), ('Bugulma',), ('Novouralsk',), ('Puškin',), ('Vorkuta',), ('Derbent',), ('Kirovo-Tšepetsk',), ('Krasnogorsk',), ('Klin',), ('Tšaikovski',), ('Novyi Urengoi',), ('Tallinn',), ('Tartu',)]",,0.0,
Show the names of conductors and the orchestras they have conducted.,"[conductor.Name, orchestra.Orchestra, orchestra.Conductor_ID = conductor.Conductor_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NON-NESTED,"SELECT conductor.Name, orchestra.Orchestra FROM conductor JOIN orchestra ON orchestra.Conductor_ID = conductor.Conductor_ID;","SELECT T1.Name ,  T2.Orchestra FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID",orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of conductors (""conductor.Name"") and the orchestras they have conducted (""orchestra.Orchestra""). 2. Condition Structure: No specific filtering condition is required, as the question asks for all conductors and their orchestras. 3. Join Structure: Use an INNER JOIN between the ""conductor"" and ""orchestra"" tables based on the foreign key relationship ""orchestra.Conductor_ID = conductor.Conductor_ID"" to link each conductor with their respective orchestras. 4. Aggregation Structure: No aggregation is needed, as the query simply retrieves the required fields without any summarization.","[('Antal Doráti', 'London Symphony Orchestra'), ('Igor Stravinsky', 'Columbia Symphony Orchestra'), ('Colin Davis', 'Royal Concertgebouw Orchestra'), ('Paul Jorgensen', 'Royal Danish Orchestra'), ('Antal Brown', 'Detroit Symphony Orchestra'), ('Charles Dutoit', 'Montreal Symphony Orchestra'), ('Gerard Schwarz', 'Seattle Symphony Orchestra'), ('Pierre Boulez', 'Chicago Symphony Orchestra'), ('Valeri Gergiev', 'Kirov Orchestra'), ('Robert Craft', 'Philharmonia Orchestra'), ('Seiji Ozawa', 'Orchestre de Paris'), ('Michael Tilson Thomas', 'San Francisco Symphony Orchestra')]","[('Antal Doráti', 'London Symphony Orchestra'), ('Igor Stravinsky', 'Columbia Symphony Orchestra'), ('Colin Davis', 'Royal Concertgebouw Orchestra'), ('Paul Jorgensen', 'Royal Danish Orchestra'), ('Antal Brown', 'Detroit Symphony Orchestra'), ('Charles Dutoit', 'Montreal Symphony Orchestra'), ('Gerard Schwarz', 'Seattle Symphony Orchestra'), ('Pierre Boulez', 'Chicago Symphony Orchestra'), ('Valeri Gergiev', 'Kirov Orchestra'), ('Robert Craft', 'Philharmonia Orchestra'), ('Seiji Ozawa', 'Orchestre de Paris'), ('Michael Tilson Thomas', 'San Francisco Symphony Orchestra')]",,1.0,
"What are the names of conductors, sorted descending by the number of years they have worked?","[conductor.Name, conductor.Year_of_Work]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,"SELECT conductor.Name, conductor.Year_of_Work FROM conductor ORDER BY conductor.Year_of_Work DESC;",SELECT Name FROM conductor ORDER BY Year_of_Work DESC,orchestra,"1. Sequential Structure: Begin with the SELECT clause to retrieve the names of conductors and their years of work. 2. Condition Structure: No specific filtering condition is required as we want all conductors. 3. Join Structure: No JOIN is required since all necessary information is available in the ""conductor"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in descending order based on ""conductor.Year_of_Work"".","[('Robert Craft', 21), ('Antal Brown', 20), ('Gerard Schwarz', 20), ('Valeri Gergiev', 16), ('Charles Dutoit', 12), ('Michael Tilson Thomas', 12), ('Igor Stravinsky', 11), ('Paul Jorgensen', 11), ('Pierre Boulez', 11), ('Antal Doráti', 10), ('Seiji Ozawa', 10), ('Colin Davis', 6)]","[('Robert Craft',), ('Antal Brown',), ('Gerard Schwarz',), ('Valeri Gergiev',), ('Charles Dutoit',), ('Michael Tilson Thomas',), ('Igor Stravinsky',), ('Paul Jorgensen',), ('Pierre Boulez',), ('Antal Doráti',), ('Seiji Ozawa',), ('Colin Davis',)]",,1.0,
What are the record companies that are used by both orchestras founded before 2003 and those founded after 2003?,"[orchestra.Record_Company,orchestra.Year_of_Founded]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NESTED,SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003;,SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the record companies. Use the FROM clause to specify the orchestra table. Apply a WHERE clause to filter orchestras founded before 2003 and those founded after 2003. Use INTERSECT to find record companies that are common to both groups. 2. Condition Structure: Use two separate WHERE clauses to filter orchestras founded before 2003 and those founded after 2003. Use INTERSECT to find the overlap between the two sets of record companies. 3. Join Structure: Not required, as all the necessary data is in the orchestra table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.","[('Decca Records',)]","[('Decca Records',)]",,1.0,
Show the names and grades of each high schooler.,"[Highschooler.name, Highschooler.grade]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,"SELECT Highschooler.name, Highschooler.grade FROM Highschooler;","SELECT name ,  grade FROM Highschooler",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""name"" and ""grade"" of each high schooler. 2. Condition Structure: No specific filtering condition is required as we want all high schoolers' names and grades. 3. Join Structure: No JOIN is necessary since all the required information is available in the ""Highschooler"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and grades of all high schoolers.","[('Jordan', 9), ('Gabriel', 9), ('Tiffany', 9), ('Cassandra', 9), ('Haley', 10), ('Andrew', 10), ('Kris', 10), ('Brittany', 10), ('Alexis', 11), ('Austin', 11), ('Gabriel', 11), ('Jessica', 11), ('Jordan', 12), ('John', 12), ('Kyle', 12), ('Logan', 12)]","[('Jordan', 9), ('Gabriel', 9), ('Tiffany', 9), ('Cassandra', 9), ('Haley', 10), ('Andrew', 10), ('Kris', 10), ('Brittany', 10), ('Alexis', 11), ('Austin', 11), ('Gabriel', 11), ('Jessica', 11), ('Jordan', 12), ('John', 12), ('Kyle', 12), ('Logan', 12)]",,1.0,
Count the number of countries for which Spanish is the predominantly spoken language.,"[country.Code, countrylanguage.Language, countrylanguage.Percentage, countrylanguage.CountryCode = country.Code, Spanish]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT COUNT(*) FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.Language = 'Spanish' AND countrylanguage.Percentage = ( SELECT MAX(cl.Percentage) FROM countrylanguage AS cl WHERE cl.CountryCode = countrylanguage.CountryCode );,"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  ""Spanish"" GROUP BY CountryCode",world_1,"1. Sequential Structure: Start with the SELECT clause to count the number of countries. Use COUNT to aggregate the results. 2. Condition Structure: Use a WHERE clause to filter for records where the language is ""Spanish"" and it is predominantly spoken. This can be determined by checking if the ""Percentage"" is the highest for that country. 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables on ""country.Code"" and ""countrylanguage.CountryCode"" to link countries with their languages. 4. Aggregation Structure: Use a subquery to identify the predominant language for each country by finding the maximum ""Percentage"" for each ""CountryCode."" Then, filter for ""Spanish"" in the main query.","[(21,)]","[(1, 7.4), (1, 44.6), (1, 96.8), (1, 31.6), (1, 87.7), (1, 0.7), (1, 89.7), (1, 99.0), (1, 97.5), (1, 100.0), (1, 98.0), (1, 93.0), (1, 74.4), (1, 0.4), (1, 64.7), (1, 97.2), (1, 92.1), (1, 97.6), (1, 76.8), (1, 79.8), (1, 51.3), (1, 55.1), (1, 100.0), (1, 0.6), (1, 95.7), (1, 7.5), (1, 96.9), (1, 13.3)]",,0.0,
Show the ids of high schoolers who have friends and are also liked by someone else.,"[Friend.student_id, Friend.friend_id = Highschooler.ID, Likes.liked_id, Likes.student_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT DISTINCT Highschooler.ID FROM Highschooler JOIN Friend ON Highschooler.ID = Friend.student_id JOIN Likes ON Highschooler.ID = Likes.liked_id;,SELECT student_id FROM Friend INTERSECT SELECT liked_id FROM Likes,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of high schoolers. Since we are looking for high schoolers who meet two conditions, we will use DISTINCT to ensure unique IDs. 2. Condition Structure: Use a WHERE clause to filter high schoolers who have friends (exist in the Friend table as student_id) and are also liked by someone else (exist in the Likes table as liked_id). 3. Join Structure: Use JOINs to connect the Friend and Likes tables with the Highschooler table based on the relevant foreign key relationships. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique IDs are returned.","[(1101,), (1247,), (1304,), (1468,), (1501,), (1689,), (1709,), (1934,)]","[(1101,), (1247,), (1304,), (1468,), (1501,), (1689,), (1709,), (1934,)]",,1.0,
Count the number of high schoolers.,[Highschooler.ID],"Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,SELECT COUNT(Highschooler.ID) AS total_highschoolers FROM Highschooler;,SELECT count(*) FROM Highschooler,network_1,"1. Sequential Structure: Start with the SELECT clause to count the number of high schoolers. 2. Condition Structure: No specific filtering condition is required as we want to count all high schoolers. 3. Join Structure: No JOIN is necessary since the required information is available within the ""Highschooler"" table. 4. Aggregation Structure: Use COUNT on ""Highschooler.ID"" to calculate the total number of high schoolers.","[(16,)]","[(16,)]",,1.0,
Return the country codes for countries that do not speak English.,"[country.Code, countrylanguage.Language, countrylanguage.CountryCode = country.Code, English]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT DISTINCT country.Code FROM country WHERE country.Code NOT IN ( SELECT countrylanguage.CountryCode FROM countrylanguage WHERE countrylanguage.Language = 'English' );,"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  ""English""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the country codes. Use the FROM clause to specify the countrylanguage table. Apply a WHERE clause to filter for countries that do not speak English. 2. Condition Structure: Use the WHERE clause to exclude countries where the language is 'English'. This can be achieved by checking that the country codes are not present in the subset of country codes where the language is 'English'. 3. Join Structure: Not required, as the necessary data is available in the countrylanguage table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.","[('AFG',), ('AGO',), ('ALB',), ('AND',), ('ARE',), ('ARG',), ('ARM',), ('ATA',), ('ATF',), ('AUT',), ('AZE',), ('BDI',), ('BEL',), ('BEN',), ('BFA',), ('BGD',), ('BGR',), ('BHS',), ('BIH',), ('BLR',), ('BOL',), ('BRA',), ('BTN',), ('BVT',), ('BWA',), ('CAF',), ('CHE',), ('CHL',), ('CHN',), ('CIV',), ('CMR',), ('COD',), ('COG',), ('COL',), ('COM',), ('CPV',), ('CRI',), ('CUB',), ('CYP',), ('CZE',), ('DEU',), ('DJI',), ('DMA',), ('DOM',), ('DZA',), ('ECU',), ('EGY',), ('ERI',), ('ESH',), ('ESP',), ('EST',), ('ETH',), ('FIN',), ('FJI',), ('FRA',), ('FRO',), ('FSM',), ('GAB',), ('GEO',), ('GHA',), ('GIN',), ('GLP',), ('GMB',), ('GNB',), ('GNQ',), ('GRC',), ('GRD',), ('GRL',), ('GTM',), ('GUF',), ('GUY',), ('HMD',), ('HND',), ('HRV',), ('HTI',), ('HUN',), ('IDN',), ('IND',), ('IOT',), ('IRN',), ('IRQ',), ('ISR',), ('ITA',), ('JAM',), ('JOR',), ('KAZ',), ('KEN',), ('KGZ',), ('KHM',), ('KIR',), ('KOR',), ('LAO',), ('LBN',), ('LBR',), ('LBY',), ('LIE',), ('LKA',), ('LTU',), ('LUX',), ('LVA',), ('MAR',), ('MDA',), ('MDG',), ('MEX',), ('MKD',), ('MLI',), ('MMR',), ('MNG',), ('MOZ',), ('MRT',), ('MTQ',), ('MUS',), ('MWI',), ('MYT',), ('NAM',), ('NCL',), ('NER',), ('NGA',), ('NIC',), ('NLD',), ('NPL',), ('OMN',), ('PAK',), ('PAN',), ('PCN',), ('PER',), ('PHL',), ('PNG',), ('POL',), ('PRK',), ('PRT',), ('PRY',), ('PSE',), ('PYF',), ('QAT',), ('REU',), ('ROM',), ('RUS',), ('RWA',), ('SAU',), ('SDN',), ('SEN',), ('SGP',), ('SGS',), ('SJM',), ('SLB',), ('SLE',), ('SLV',), ('SMR',), ('SOM',), ('SPM',), ('STP',), ('SUR',), ('SVK',), ('SVN',), ('SWE',), ('SWZ',), ('SYR',), ('TCD',), ('TGO',), ('THA',), ('TJK',), ('TKM',), ('TMP',), ('TUN',), ('TUR',), ('TWN',), ('TZA',), ('UGA',), ('UKR',), ('URY',), ('UZB',), ('VAT',), ('VEN',), ('VNM',), ('WLF',), ('YEM',), ('YUG',), ('ZMB',)]","[('AFG',), ('AGO',), ('ALB',), ('AND',), ('ARE',), ('ARG',), ('ARM',), ('AUT',), ('AZE',), ('BDI',), ('BEL',), ('BEN',), ('BFA',), ('BGD',), ('BGR',), ('BHS',), ('BIH',), ('BLR',), ('BOL',), ('BRA',), ('BTN',), ('BWA',), ('CAF',), ('CHE',), ('CHL',), ('CHN',), ('CIV',), ('CMR',), ('COD',), ('COG',), ('COL',), ('COM',), ('CPV',), ('CRI',), ('CUB',), ('CYP',), ('CZE',), ('DEU',), ('DJI',), ('DMA',), ('DOM',), ('DZA',), ('ECU',), ('EGY',), ('ERI',), ('ESH',), ('ESP',), ('EST',), ('ETH',), ('FIN',), ('FJI',), ('FRA',), ('FRO',), ('FSM',), ('GAB',), ('GEO',), ('GHA',), ('GIN',), ('GLP',), ('GMB',), ('GNB',), ('GNQ',), ('GRC',), ('GRD',), ('GRL',), ('GTM',), ('GUF',), ('GUY',), ('HND',), ('HRV',), ('HTI',), ('HUN',), ('IDN',), ('IND',), ('IRN',), ('IRQ',), ('ISR',), ('ITA',), ('JAM',), ('JOR',), ('KAZ',), ('KEN',), ('KGZ',), ('KHM',), ('KIR',), ('KOR',), ('LAO',), ('LBN',), ('LBR',), ('LBY',), ('LIE',), ('LKA',), ('LTU',), ('LUX',), ('LVA',), ('MAR',), ('MDA',), ('MDG',), ('MEX',), ('MKD',), ('MLI',), ('MMR',), ('MNG',), ('MOZ',), ('MRT',), ('MTQ',), ('MUS',), ('MWI',), ('MYT',), ('NAM',), ('NCL',), ('NER',), ('NGA',), ('NIC',), ('NLD',), ('NPL',), ('OMN',), ('PAK',), ('PAN',), ('PCN',), ('PER',), ('PHL',), ('PNG',), ('POL',), ('PRK',), ('PRT',), ('PRY',), ('PSE',), ('PYF',), ('QAT',), ('REU',), ('ROM',), ('RUS',), ('RWA',), ('SAU',), ('SDN',), ('SEN',), ('SGP',), ('SJM',), ('SLB',), ('SLE',), ('SLV',), ('SMR',), ('SOM',), ('SPM',), ('STP',), ('SUR',), ('SVK',), ('SVN',), ('SWE',), ('SWZ',), ('SYR',), ('TCD',), ('TGO',), ('THA',), ('TJK',), ('TKM',), ('TMP',), ('TUN',), ('TUR',), ('TWN',), ('TZA',), ('UGA',), ('UKR',), ('URY',), ('UZB',), ('VAT',), ('VEN',), ('VNM',), ('WLF',), ('YEM',), ('YUG',), ('ZMB',)]",,1.0,
What is the total number of countries where Spanish is spoken by the largest percentage of people?,"[countrylanguage.Language, countrylanguage.Percentage, countrylanguage.CountryCode = country.Code, country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT COUNT(*) FROM countrylanguage WHERE Language = 'Spanish' AND Percentage = (SELECT MAX(Percentage) FROM countrylanguage WHERE Language = 'Spanish');,"SELECT count(*) ,   max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  ""Spanish"" GROUP BY CountryCode",world_1,"1. Sequential Structure: Start with the SELECT clause to count the total number of countries. Use the FROM clause to specify the countrylanguage table. Apply a WHERE clause to filter for the language 'Spanish' and ensure that the percentage is the maximum percentage for that language across all countries. 2. Condition Structure: Use the WHERE clause with a subquery to filter for countries where the percentage of people speaking Spanish is the maximum percentage for that language. 3. Join Structure: Not required, as all necessary data is in the countrylanguage table. 4. Aggregation Structure: Use MAX in a subquery to find the maximum percentage of people speaking Spanish, and COUNT to calculate the total number of countries meeting this condition.","[(2,)]","[(1, 7.4), (1, 44.6), (1, 96.8), (1, 31.6), (1, 87.7), (1, 0.7), (1, 89.7), (1, 99.0), (1, 97.5), (1, 100.0), (1, 98.0), (1, 93.0), (1, 74.4), (1, 0.4), (1, 64.7), (1, 97.2), (1, 92.1), (1, 97.6), (1, 76.8), (1, 79.8), (1, 51.3), (1, 55.1), (1, 100.0), (1, 0.6), (1, 95.7), (1, 7.5), (1, 96.9), (1, 13.3)]",,0.0,
What are the names and grades for each high schooler?,"[Highschooler.name, Highschooler.grade]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,"SELECT Highschooler.name, Highschooler.grade FROM Highschooler;","SELECT name ,  grade FROM Highschooler",network_1,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are the ""Highschooler.name"" and ""Highschooler.grade"". 2. Condition Structure: No specific filtering condition is required as we want the names and grades of all high schoolers. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Highschooler"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the names and grades of all high schoolers.","[('Jordan', 9), ('Gabriel', 9), ('Tiffany', 9), ('Cassandra', 9), ('Haley', 10), ('Andrew', 10), ('Kris', 10), ('Brittany', 10), ('Alexis', 11), ('Austin', 11), ('Gabriel', 11), ('Jessica', 11), ('Jordan', 12), ('John', 12), ('Kyle', 12), ('Logan', 12)]","[('Jordan', 9), ('Gabriel', 9), ('Tiffany', 9), ('Cassandra', 9), ('Haley', 10), ('Andrew', 10), ('Kris', 10), ('Brittany', 10), ('Alexis', 11), ('Austin', 11), ('Gabriel', 11), ('Jessica', 11), ('Jordan', 12), ('John', 12), ('Kyle', 12), ('Logan', 12)]",,1.0,
Please show the name of the conductor that has conducted orchestras founded after 2008.,"[conductor.Name, orchestra.Year_of_Founded, orchestra.Conductor_ID = conductor.Conductor_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NON-NESTED,SELECT DISTINCT conductor.Name FROM orchestra JOIN conductor ON orchestra.Conductor_ID = conductor.Conductor_ID WHERE orchestra.Year_of_Founded > 2008;,SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID WHERE Year_of_Founded  >  2008,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""conductor.Name."" 2. Condition Structure: Use a WHERE clause to filter for orchestras that were founded after 2008 by checking ""orchestra.Year_of_Founded > 2008."" 3. Join Structure: Use an INNER JOIN between the ""orchestra"" and ""conductor"" tables based on the foreign key ""orchestra.Conductor_ID = conductor.Conductor_ID"" to link each orchestra with its conductor. 4. Aggregation Structure: No aggregation is needed as the query only requires the names of conductors.","[('Igor Stravinsky',)]","[('Igor Stravinsky',)]",,1.0,
Return the grade for the high schooler named Kyle.,"[Highschooler.name, Highschooler.grade, Highschooler.name = 'Kyle']","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,SELECT Highschooler.grade FROM Highschooler WHERE Highschooler.name = 'Kyle';,"SELECT grade FROM Highschooler WHERE name  =  ""Kyle""",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Highschooler.grade"" for the high schooler named 'Kyle'. 2. Condition Structure: Use a WHERE clause to filter for the high schooler whose ""Highschooler.name"" is 'Kyle'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Highschooler"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single field based on a specific condition.","[(12,)]","[(12,)]",,1.0,
What are the names of high schoolers who have 3 or more friends?,"[Highschooler.name, Friend.student_id, Friend.friend_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT Highschooler.name FROM Highschooler JOIN Friend ON Friend.student_id = Highschooler.ID GROUP BY Highschooler.ID HAVING COUNT(Friend.friend_id) >= 3;,SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  3,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of high schoolers. Use the ""Highschooler.name"" field for this purpose. 2. Condition Structure: Use a HAVING clause to filter for high schoolers who have 3 or more friends. This requires counting the number of friends for each student. 3. Join Structure: Use a JOIN between the ""Friend"" table and the ""Highschooler"" table. Specifically, join ""Friend.student_id"" with ""Highschooler.ID"" to associate each student with their friends. 4. Aggregation Structure: Use COUNT on ""Friend.friend_id"" to count the number of friends for each student. Group the results by ""Highschooler.ID"" to ensure the count is calculated per student.","[('Andrew',)]","[('Andrew',)]",,1.0,
Show the record companies shared by orchestras founded before 2003 and after 2003.,"[orchestra.Record_Company, orchestra.Year_of_Founded]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NESTED,(SELECT Record_Company FROM orchestra WHERE Year_of_Founded < 2003) INTERSECT (SELECT Record_Company FROM orchestra WHERE Year_of_Founded > 2003);,SELECT Record_Company FROM orchestra WHERE Year_of_Founded  <  2003 INTERSECT SELECT Record_Company FROM orchestra WHERE Year_of_Founded  >  2003,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the record companies. Use the FROM clause to specify the orchestra table. Apply a WHERE clause to filter orchestras founded before 2003 and after 2003. Use INTERSECT to find the record companies shared by both groups. 2. Condition Structure: Use two separate WHERE clauses to filter orchestras founded before 2003 and after 2003, respectively. 3. Join Structure: Not required, as all data is available within the orchestra table. 4. Aggregation Structure: Not needed, as we are only retrieving and comparing specific records without any aggregation.",[],"[('Decca Records',)]","near ""("": syntax error",0.0,
What is the grade of each high schooler?,"[Highschooler.ID, Highschooler.grade]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,"SELECT Highschooler.ID, Highschooler.grade FROM Highschooler;",SELECT grade FROM Highschooler,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Highschooler.ID"" and ""Highschooler.grade"" for each high schooler. 2. Condition Structure: No specific filtering condition is required as we want the grade of every high schooler. 3. Join Structure: No JOIN is necessary since all the required data is available in the ""Highschooler"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the grade for each high schooler.","[(1510, 9), (1689, 9), (1381, 9), (1709, 9), (1101, 10), (1782, 10), (1468, 10), (1641, 10), (1247, 11), (1316, 11), (1911, 11), (1501, 11), (1304, 12), (1025, 12), (1934, 12), (1661, 12)]","[(9,), (9,), (9,), (9,), (10,), (10,), (10,), (10,), (11,), (11,), (11,), (11,), (12,), (12,), (12,), (12,)]",,1.0,
How many high schoolers are there in grade 9 or 10?,"[Highschooler.ID, Highschooler.grade, 9, 10]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,"SELECT COUNT(Highschooler.ID) FROM Highschooler WHERE Highschooler.grade IN (9, 10);",SELECT count(*) FROM Highschooler WHERE grade  =  9 OR grade  =  10,network_1,"1. Sequential Structure: Start with the SELECT clause to count the number of high schoolers in grades 9 or 10. 2. Condition Structure: Use a WHERE clause to filter for high schoolers whose grade is either 9 or 10. 3. Join Structure: No JOIN is required since all necessary information is in the ""Highschooler"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of high schoolers meeting the grade condition.","[(8,)]","[(8,)]",,1.0,
What is the name of the high schooler who has the greatest number of friends?,"[Highschooler.name, Friend.student_id, Friend.friend_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT Highschooler.name FROM Friend JOIN Highschooler ON Friend.student_id = Highschooler.ID GROUP BY Highschooler.ID ORDER BY COUNT(Friend.friend_id) DESC LIMIT 1;,SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the high schooler. Use COUNT to calculate the number of friends for each student. Use ORDER BY in descending order to rank students by the number of friends and LIMIT 1 to get the student with the greatest number of friends. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all students. 3. Join Structure: Use a JOIN between the ""Friend"" table and the ""Highschooler"" table on ""Friend.student_id = Highschooler.ID"" to associate each student with their name. 4. Aggregation Structure: Use COUNT on ""Friend.friend_id"" to count the number of friends for each student, and GROUP BY ""Highschooler.ID"" to group the results by each student.","[('Andrew',)]","[('Andrew',)]",,1.0,
Return the different names of cities that are in Asia and for which Chinese is the official language.,"[city.Name, city.CountryCode = country.Code, country.Continent, countrylanguage.CountryCode = country.Code, countrylanguage.Language, countrylanguage.IsOfficial, Asia, Chinese, 'T']","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT DISTINCT city.Name FROM city JOIN country ON city.CountryCode = country.Code JOIN countrylanguage ON countrylanguage.CountryCode = country.Code WHERE country.Continent = 'Asia' AND countrylanguage.Language = 'Chinese' AND countrylanguage.IsOfficial = 'T';,"SELECT DISTINCT T3.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode JOIN city AS T3 ON T1.Code  =  T3.CountryCode WHERE T2.IsOfficial  =  'T' AND T2.Language  =  'Chinese' AND T1.Continent  =  ""Asia""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct city names (""city.Name""). 2. Condition Structure: Use a WHERE clause to filter for cities in countries where the continent is ""Asia"" and the language is ""Chinese"" with ""IsOfficial"" set to 'T'. 3. Join Structure: Use JOINs to connect the ""city"" table with the ""country"" table on ""city.CountryCode = country.Code"" and the ""countrylanguage"" table on ""countrylanguage.CountryCode = country.Code"" to link cities with their respective countries and languages. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique city names are returned.","[('Shanghai',), ('Peking',), ('Chongqing',), ('Tianjin',), ('Wuhan',), ('Harbin',), ('Shenyang',), ('Kanton [Guangzhou]',), ('Chengdu',), ('Nanking [Nanjing]',), ('Changchun',), ('Xi´an',), ('Dalian',), ('Qingdao',), ('Jinan',), ('Hangzhou',), ('Zhengzhou',), ('Shijiazhuang',), ('Taiyuan',), ('Kunming',), ('Changsha',), ('Nanchang',), ('Fuzhou',), ('Lanzhou',), ('Guiyang',), ('Ningbo',), ('Hefei',), ('Urumtši [Ürümqi]',), ('Anshan',), ('Fushun',), ('Nanning',), ('Zibo',), ('Qiqihar',), ('Jilin',), ('Tangshan',), ('Baotou',), ('Shenzhen',), ('Hohhot',), ('Handan',), ('Wuxi',), ('Xuzhou',), ('Datong',), ('Yichun',), ('Benxi',), ('Luoyang',), ('Suzhou',), ('Xining',), ('Huainan',), ('Jixi',), ('Daqing',), ('Fuxin',), ('Amoy [Xiamen]',), ('Liuzhou',), ('Shantou',), ('Jinzhou',), ('Mudanjiang',), ('Yinchuan',), ('Changzhou',), ('Zhangjiakou',), ('Dandong',), ('Hegang',), ('Kaifeng',), ('Jiamusi',), ('Liaoyang',), ('Hengyang',), ('Baoding',), ('Hunjiang',), ('Xinxiang',), ('Huangshi',), ('Haikou',), ('Yantai',), ('Bengbu',), ('Xiangtan',), ('Weifang',), ('Wuhu',), ('Pingxiang',), ('Yingkou',), ('Anyang',), ('Panzhihua',), ('Pingdingshan',), ('Xiangfan',), ('Zhuzhou',), ('Jiaozuo',), ('Wenzhou',), ('Zhangjiang',), ('Zigong',), ('Shuangyashan',), ('Zaozhuang',), ('Yakeshi',), ('Yichang',), ('Zhenjiang',), ('Huaibei',), ('Qinhuangdao',), ('Guilin',), ('Liupanshui',), ('Panjin',), ('Yangquan',), ('Jinxi',), ('Liaoyuan',), ('Lianyungang',), ('Xianyang',), ('Tai´an',), ('Chifeng',), ('Shaoguan',), ('Nantong',), ('Leshan',), ('Baoji',), ('Linyi',), ('Tonghua',), ('Siping',), ('Changzhi',), ('Tengzhou',), ('Chaozhou',), ('Yangzhou',), ('Dongwan',), ('Ma´anshan',), ('Foshan',), ('Yueyang',), ('Xingtai',), ('Changde',), ('Shihezi',), ('Yancheng',), ('Jiujiang',), ('Dongying',), ('Shashi',), ('Xintai',), ('Jingdezhen',), ('Tongchuan',), ('Zhongshan',), ('Shiyan',), ('Tieli',), ('Jining',), ('Wuhai',), ('Mianyang',), ('Luzhou',), ('Zunyi',), ('Shizuishan',), ('Neijiang',), ('Tongliao',), ('Tieling',), ('Wafangdian',), ('Anqing',), ('Shaoyang',), ('Laiwu',), ('Chengde',), ('Tianshui',), ('Nanyang',), ('Cangzhou',), ('Yibin',), ('Huaiyin',), ('Dunhua',), ('Yanji',), ('Jiangmen',), ('Tongling',), ('Suihua',), ('Gongziling',), ('Xiantao',), ('Chaoyang',), ('Ganzhou',), ('Huzhou',), ('Baicheng',), ('Shangzi',), ('Yangjiang',), ('Qitaihe',), ('Gejiu',), ('Jiangyin',), ('Hebi',), ('Jiaxing',), ('Wuzhou',), ('Meihekou',), ('Xuchang',), ('Liaocheng',), ('Haicheng',), ('Qianjiang',), ('Baiyin',), ('Bei´an',), ('Yixing',), ('Laizhou',), ('Qaramay',), ('Acheng',), ('Dezhou',), ('Nanping',), ('Zhaoqing',), ('Beipiao',), ('Fengcheng',), ('Fuyu',), ('Xinyang',), ('Dongtai',), ('Yuci',), ('Honghu',), ('Ezhou',), ('Heze',), ('Daxian',), ('Linfen',), ('Tianmen',), ('Yiyang',), ('Quanzhou',), ('Rizhao',), ('Deyang',), ('Guangyuan',), ('Changshu',), ('Zhangzhou',), ('Hailar',), ('Nanchong',), ('Jiutai',), ('Zhaodong',), ('Shaoxing',), ('Fuyang',), ('Maoming',), ('Qujing',), ('Ghulja',), ('Jiaohe',), ('Puyang',), ('Huadian',), ('Jiangyou',), ('Qashqar',), ('Anshun',), ('Fuling',), ('Xinyu',), ('Hanzhong',), ('Danyang',), ('Chenzhou',), ('Xiaogan',), ('Shangqiu',), ('Zhuhai',), ('Qingyuan',), ('Aqsu',), ('Xiaoshan',), ('Zaoyang',), ('Xinghua',), ('Hami',), ('Huizhou',), ('Jinmen',), ('Sanming',), ('Ulanhot',), ('Korla',), ('Wanxian',), ('Rui´an',), ('Zhoushan',), ('Liangcheng',), ('Jiaozhou',), ('Taizhou',), ('Taonan',), ('Pingdu',), ('Ji´an',), ('Longkou',), ('Langfang',), ('Zhoukou',), ('Suining',), ('Yulin',), ('Jinhua',), ('Liu´an',), ('Shuangcheng',), ('Suizhou',), ('Ankang',), ('Weinan',), ('Longjing',), ('Da´an',), ('Lengshuijiang',), ('Laiyang',), ('Xianning',), ('Dali',), ('Anda',), ('Jincheng',), ('Longyan',), ('Xichang',), ('Wendeng',), ('Hailun',), ('Binzhou',), ('Linhe',), ('Wuwei',), ('Duyun',), ('Mishan',), ('Shangrao',), ('Changji',), ('Meixian',), ('Yushu',), ('Tiefa',), ('Huai´an',), ('Leiyang',), ('Zalantun',), ('Weihai',), ('Loudi',), ('Qingzhou',), ('Qidong',), ('Huaihua',), ('Luohe',), ('Chuzhou',), ('Kaiyuan',), ('Linqing',), ('Chaohu',), ('Laohekou',), ('Dujiangyan',), ('Zhumadian',), ('Linchuan',), ('Jiaonan',), ('Sanmenxia',), ('Heyuan',), ('Manzhouli',), ('Lhasa',), ('Lianyuan',), ('Kuytun',), ('Puqi',), ('Hongjiang',), ('Qinzhou',), ('Renqiu',), ('Yuyao',), ('Guigang',), ('Kaili',), ('Yan´an',), ('Beihai',), ('Xuangzhou',), ('Quzhou',), ('Yong´an',), ('Zixing',), ('Liyang',), ('Yizheng',), ('Yumen',), ('Liling',), ('Yuncheng',), ('Shanwei',), ('Cixi',), ('Yuanjiang',), ('Bozhou',), ('Jinchang',), ('Fu´an',), ('Suqian',), ('Shishou',), ('Hengshui',), ('Danjiangkou',), ('Fujin',), ('Sanya',), ('Guangshui',), ('Huangshan',), ('Xingcheng',), ('Zhucheng',), ('Kunshan',), ('Haining',), ('Pingliang',), ('Fuqing',), ('Xinzhou',), ('Jieyang',), ('Zhangjiagang',), ('Tong Xian',), ('Ya´an',), ('Emeishan',), ('Enshi',), ('Bose',), ('Yuzhou',), ('Tumen',), ('Putian',), ('Linhai',), ('Xilin Hot',), ('Shaowu',), ('Junan',), ('Huaying',), ('Pingyi',), ('Huangyan',), ('Singapore',)]","[('Shanghai',), ('Peking',), ('Chongqing',), ('Tianjin',), ('Wuhan',), ('Harbin',), ('Shenyang',), ('Kanton [Guangzhou]',), ('Chengdu',), ('Nanking [Nanjing]',), ('Changchun',), ('Xi´an',), ('Dalian',), ('Qingdao',), ('Jinan',), ('Hangzhou',), ('Zhengzhou',), ('Shijiazhuang',), ('Taiyuan',), ('Kunming',), ('Changsha',), ('Nanchang',), ('Fuzhou',), ('Lanzhou',), ('Guiyang',), ('Ningbo',), ('Hefei',), ('Urumtši [Ürümqi]',), ('Anshan',), ('Fushun',), ('Nanning',), ('Zibo',), ('Qiqihar',), ('Jilin',), ('Tangshan',), ('Baotou',), ('Shenzhen',), ('Hohhot',), ('Handan',), ('Wuxi',), ('Xuzhou',), ('Datong',), ('Yichun',), ('Benxi',), ('Luoyang',), ('Suzhou',), ('Xining',), ('Huainan',), ('Jixi',), ('Daqing',), ('Fuxin',), ('Amoy [Xiamen]',), ('Liuzhou',), ('Shantou',), ('Jinzhou',), ('Mudanjiang',), ('Yinchuan',), ('Changzhou',), ('Zhangjiakou',), ('Dandong',), ('Hegang',), ('Kaifeng',), ('Jiamusi',), ('Liaoyang',), ('Hengyang',), ('Baoding',), ('Hunjiang',), ('Xinxiang',), ('Huangshi',), ('Haikou',), ('Yantai',), ('Bengbu',), ('Xiangtan',), ('Weifang',), ('Wuhu',), ('Pingxiang',), ('Yingkou',), ('Anyang',), ('Panzhihua',), ('Pingdingshan',), ('Xiangfan',), ('Zhuzhou',), ('Jiaozuo',), ('Wenzhou',), ('Zhangjiang',), ('Zigong',), ('Shuangyashan',), ('Zaozhuang',), ('Yakeshi',), ('Yichang',), ('Zhenjiang',), ('Huaibei',), ('Qinhuangdao',), ('Guilin',), ('Liupanshui',), ('Panjin',), ('Yangquan',), ('Jinxi',), ('Liaoyuan',), ('Lianyungang',), ('Xianyang',), ('Tai´an',), ('Chifeng',), ('Shaoguan',), ('Nantong',), ('Leshan',), ('Baoji',), ('Linyi',), ('Tonghua',), ('Siping',), ('Changzhi',), ('Tengzhou',), ('Chaozhou',), ('Yangzhou',), ('Dongwan',), ('Ma´anshan',), ('Foshan',), ('Yueyang',), ('Xingtai',), ('Changde',), ('Shihezi',), ('Yancheng',), ('Jiujiang',), ('Dongying',), ('Shashi',), ('Xintai',), ('Jingdezhen',), ('Tongchuan',), ('Zhongshan',), ('Shiyan',), ('Tieli',), ('Jining',), ('Wuhai',), ('Mianyang',), ('Luzhou',), ('Zunyi',), ('Shizuishan',), ('Neijiang',), ('Tongliao',), ('Tieling',), ('Wafangdian',), ('Anqing',), ('Shaoyang',), ('Laiwu',), ('Chengde',), ('Tianshui',), ('Nanyang',), ('Cangzhou',), ('Yibin',), ('Huaiyin',), ('Dunhua',), ('Yanji',), ('Jiangmen',), ('Tongling',), ('Suihua',), ('Gongziling',), ('Xiantao',), ('Chaoyang',), ('Ganzhou',), ('Huzhou',), ('Baicheng',), ('Shangzi',), ('Yangjiang',), ('Qitaihe',), ('Gejiu',), ('Jiangyin',), ('Hebi',), ('Jiaxing',), ('Wuzhou',), ('Meihekou',), ('Xuchang',), ('Liaocheng',), ('Haicheng',), ('Qianjiang',), ('Baiyin',), ('Bei´an',), ('Yixing',), ('Laizhou',), ('Qaramay',), ('Acheng',), ('Dezhou',), ('Nanping',), ('Zhaoqing',), ('Beipiao',), ('Fengcheng',), ('Fuyu',), ('Xinyang',), ('Dongtai',), ('Yuci',), ('Honghu',), ('Ezhou',), ('Heze',), ('Daxian',), ('Linfen',), ('Tianmen',), ('Yiyang',), ('Quanzhou',), ('Rizhao',), ('Deyang',), ('Guangyuan',), ('Changshu',), ('Zhangzhou',), ('Hailar',), ('Nanchong',), ('Jiutai',), ('Zhaodong',), ('Shaoxing',), ('Fuyang',), ('Maoming',), ('Qujing',), ('Ghulja',), ('Jiaohe',), ('Puyang',), ('Huadian',), ('Jiangyou',), ('Qashqar',), ('Anshun',), ('Fuling',), ('Xinyu',), ('Hanzhong',), ('Danyang',), ('Chenzhou',), ('Xiaogan',), ('Shangqiu',), ('Zhuhai',), ('Qingyuan',), ('Aqsu',), ('Xiaoshan',), ('Zaoyang',), ('Xinghua',), ('Hami',), ('Huizhou',), ('Jinmen',), ('Sanming',), ('Ulanhot',), ('Korla',), ('Wanxian',), ('Rui´an',), ('Zhoushan',), ('Liangcheng',), ('Jiaozhou',), ('Taizhou',), ('Taonan',), ('Pingdu',), ('Ji´an',), ('Longkou',), ('Langfang',), ('Zhoukou',), ('Suining',), ('Yulin',), ('Jinhua',), ('Liu´an',), ('Shuangcheng',), ('Suizhou',), ('Ankang',), ('Weinan',), ('Longjing',), ('Da´an',), ('Lengshuijiang',), ('Laiyang',), ('Xianning',), ('Dali',), ('Anda',), ('Jincheng',), ('Longyan',), ('Xichang',), ('Wendeng',), ('Hailun',), ('Binzhou',), ('Linhe',), ('Wuwei',), ('Duyun',), ('Mishan',), ('Shangrao',), ('Changji',), ('Meixian',), ('Yushu',), ('Tiefa',), ('Huai´an',), ('Leiyang',), ('Zalantun',), ('Weihai',), ('Loudi',), ('Qingzhou',), ('Qidong',), ('Huaihua',), ('Luohe',), ('Chuzhou',), ('Kaiyuan',), ('Linqing',), ('Chaohu',), ('Laohekou',), ('Dujiangyan',), ('Zhumadian',), ('Linchuan',), ('Jiaonan',), ('Sanmenxia',), ('Heyuan',), ('Manzhouli',), ('Lhasa',), ('Lianyuan',), ('Kuytun',), ('Puqi',), ('Hongjiang',), ('Qinzhou',), ('Renqiu',), ('Yuyao',), ('Guigang',), ('Kaili',), ('Yan´an',), ('Beihai',), ('Xuangzhou',), ('Quzhou',), ('Yong´an',), ('Zixing',), ('Liyang',), ('Yizheng',), ('Yumen',), ('Liling',), ('Yuncheng',), ('Shanwei',), ('Cixi',), ('Yuanjiang',), ('Bozhou',), ('Jinchang',), ('Fu´an',), ('Suqian',), ('Shishou',), ('Hengshui',), ('Danjiangkou',), ('Fujin',), ('Sanya',), ('Guangshui',), ('Huangshan',), ('Xingcheng',), ('Zhucheng',), ('Kunshan',), ('Haining',), ('Pingliang',), ('Fuqing',), ('Xinzhou',), ('Jieyang',), ('Zhangjiagang',), ('Tong Xian',), ('Ya´an',), ('Emeishan',), ('Enshi',), ('Bose',), ('Yuzhou',), ('Tumen',), ('Putian',), ('Linhai',), ('Xilin Hot',), ('Shaowu',), ('Junan',), ('Huaying',), ('Pingyi',), ('Huangyan',), ('Singapore',)]",,1.0,
What is the record company used by the greatest number of orchestras?,"[orchestra.Record_Company,orchestra.Orchestra_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT orchestra.Record_Company FROM orchestra GROUP BY orchestra.Record_Company ORDER BY COUNT(orchestra.Orchestra_ID) DESC LIMIT 1;,SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1,orchestra,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""orchestra.Record_Company"". 2. Aggregation Structure: Use COUNT to determine the number of orchestras associated with each record company. 3. Grouping Structure: Use GROUP BY on ""orchestra.Record_Company"" to aggregate the results by each record company. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank record companies by the number of orchestras they are associated with. 5. Limiting Structure: Use LIMIT 1 to retrieve the record company associated with the greatest number of orchestras. 6. Join Structure: No JOIN is required since all necessary data is within the ""orchestra"" table.","[('Decca Records',)]","[('Decca Records',)]",,1.0,
Return the name of the high school student with the most friends.,"[Highschooler.name,Friend.student_id,Friend.friend_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT Highschooler.name FROM Friend JOIN Highschooler ON Friend.student_id = Highschooler.ID GROUP BY Highschooler.ID ORDER BY COUNT(Friend.friend_id) DESC LIMIT 1;,SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the high school student. Use COUNT to count the number of friends for each student. Use ORDER BY in descending order to rank students by the number of friends and LIMIT 1 to get the student with the most friends. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all students and their friends. 3. Join Structure: Use a JOIN between the ""Friend"" table and the ""Highschooler"" table on ""Friend.student_id = Highschooler.ID"" to associate each student with their name. 4. Aggregation Structure: Use COUNT on ""Friend.friend_id"" to count the number of friends for each student, and GROUP BY ""Highschooler.ID"" to group the results by each student.","[('Andrew',)]","[('Andrew',)]",,1.0,
Find the government form name and total population for each government form whose average life expectancy is longer than 72.,"[country.GovernmentForm, country.Population, country.LifeExpectancy]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT GovernmentForm, SUM(Population) AS TotalPopulation FROM country GROUP BY GovernmentForm HAVING AVG(LifeExpectancy) > 72;","SELECT sum(Population) ,  GovernmentForm FROM country GROUP BY GovernmentForm HAVING avg(LifeExpectancy)  >  72",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the government form name and the total population for each government form. Use the FROM clause to specify the country table. Apply a GROUP BY clause to group data by government form, allowing us to calculate the total population and average life expectancy for each government form. Use the HAVING clause to filter government forms with an average life expectancy greater than 72. 2. Condition Structure: Use the HAVING clause to filter groups where the average life expectancy is greater than 72. 3. Join Structure: Not required, as all the necessary data is available in the country table. 4. Aggregation Structure: Use SUM to calculate the total population for each government form and AVG to calculate the average life expectancy for filtering.","[('Commonwealth of the US', 3947000), ('Constitutional Monarchy (Emirate)', 1972000), ('Constitutional Monarchy, Federation', 82516000), ('Dependent Territory of the UK', 193050), ('Emirate Federation', 2441000), ('Federation', 7160400), ('Monarchy (Emirate)', 617000), ('Monarchy (Sultanate)', 2870000), ('Nonmetropolitan Territory of France', 464000), ('Nonmetropolitan Territory of The Netherlands', 320000), ('Overseas Department of France', 1731000), ('Parliamentary Coprincipality', 78000), ('Part of Denmark', 99000), ('Socialistic Republic', 115072000), ('Socialistic State', 5605000), ('Special Administrative Region of China', 7255000), ('US Territory', 329000)]","[(3947000, 'Commonwealth of the US'), (1972000, 'Constitutional Monarchy (Emirate)'), (82516000, 'Constitutional Monarchy, Federation'), (193050, 'Dependent Territory of the UK'), (2441000, 'Emirate Federation'), (7160400, 'Federation'), (617000, 'Monarchy (Emirate)'), (2870000, 'Monarchy (Sultanate)'), (464000, 'Nonmetropolitan Territory of France'), (320000, 'Nonmetropolitan Territory of The Netherlands'), (1731000, 'Overseas Department of France'), (78000, 'Parliamentary Coprincipality'), (99000, 'Part of Denmark'), (115072000, 'Socialistic Republic'), (5605000, 'Socialistic State'), (7255000, 'Special Administrative Region of China'), (329000, 'US Territory')]",,1.0,
Count the number of high schoolers in grades 9 or 10.,"[Highschooler.ID, Highschooler.grade, 9, 10]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,"SELECT COUNT(Highschooler.ID) FROM Highschooler WHERE Highschooler.grade IN (9, 10);",SELECT count(*) FROM Highschooler WHERE grade  =  9 OR grade  =  10,network_1,"1. Sequential Structure: Start with the SELECT clause to count the number of high schoolers. 2. Condition Structure: Use a WHERE clause to filter high schoolers whose grade is either 9 or 10. 3. Join Structure: No JOIN is required since all necessary information is in the ""Highschooler"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of high schoolers meeting the grade condition.","[(8,)]","[(8,)]",,1.0,
Which grade has the most high schoolers?,[Highschooler.grade],"Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,"SELECT Highschooler.grade, COUNT(*) AS highschooler_count FROM Highschooler GROUP BY Highschooler.grade ORDER BY highschooler_count DESC LIMIT 1;",SELECT grade FROM Highschooler GROUP BY grade ORDER BY count(*) DESC LIMIT 1,network_1,"1. Sequential Structure: Begin with the SELECT clause to specify the grade and the count of high schoolers in each grade. 2. Aggregation Structure: Use COUNT to calculate the number of high schoolers in each grade. 3. Grouping Structure: Use GROUP BY on ""Highschooler.grade"" to aggregate the results by grade. 4. Ordering Structure: Use ORDER BY in descending order on the count of high schoolers to rank grades by the number of high schoolers. 5. Limiting Structure: Use LIMIT 1 to retrieve the grade with the most high schoolers. 6. Join Structure: No JOIN is required since all necessary data is within the ""Highschooler"" table.","[(12, 4)]","[(12,)]",,1.0,
What is the language spoken by the largest percentage of people in each country?,"[countrylanguage.Language, countrylanguage.Percentage, countrylanguage.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,"SELECT countrylanguage.CountryCode, countrylanguage.Language, MAX(countrylanguage.Percentage) AS MaxPercentage FROM countrylanguage GROUP BY countrylanguage.CountryCode;","SELECT LANGUAGE ,  CountryCode ,  max(Percentage) FROM countrylanguage GROUP BY CountryCode",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""countrylanguage.Language"" and ""countrylanguage.CountryCode"" for each country. Use an aggregate function (MAX) on ""countrylanguage.Percentage"" to find the language spoken by the largest percentage of people in each country. 2. Condition Structure: No specific filtering condition is required, as we are interested in all countries. 3. Join Structure: No JOIN is necessary because the required data is available in the ""countrylanguage"" table. 4. Aggregation Structure: Use GROUP BY on ""countrylanguage.CountryCode"" to group the results by each country, and apply MAX on ""countrylanguage.Percentage"" to find the language with the largest percentage for each country.","[('ABW', 'Papiamento', 76.7), ('AFG', 'Pashto', 52.4), ('AGO', 'Ovimbundu', 37.2), ('AIA', 'English', 0.0), ('ALB', 'Albaniana', 97.9), ('AND', 'Spanish', 44.6), ('ANT', 'Papiamento', 86.2), ('ARE', 'Arabic', 42.0), ('ARG', 'Spanish', 96.8), ('ARM', 'Armenian', 93.4), ('ASM', 'Samoan', 90.6), ('ATG', 'Creole English', 95.7), ('AUS', 'English', 81.2), ('AUT', 'German', 92.0), ('AZE', 'Azerbaijani', 89.0), ('BDI', 'Kirundi', 98.1), ('BEL', 'Dutch', 59.2), ('BEN', 'Fon', 39.8), ('BFA', 'Mossi', 50.2), ('BGD', 'Bengali', 97.7), ('BGR', 'Bulgariana', 83.2), ('BHR', 'Arabic', 67.7), ('BHS', 'Creole English', 89.7), ('BIH', 'Serbo-Croatian', 99.2), ('BLR', 'Belorussian', 65.6), ('BLZ', 'English', 50.8), ('BMU', 'English', 100.0), ('BOL', 'Spanish', 87.7), ('BRA', 'Portuguese', 97.5), ('BRB', 'Bajan', 95.1), ('BRN', 'Malay', 45.5), ('BTN', 'Dzongkha', 50.0), ('BWA', 'Tswana', 75.5), ('CAF', 'Gbaya', 23.8), ('CAN', 'English', 60.4), ('CCK', 'English', 0.0), ('CHE', 'German', 63.6), ('CHL', 'Spanish', 89.7), ('CHN', 'Chinese', 92.0), ('CIV', 'Akan', 30.0), ('CMR', 'Fang', 19.7), ('COD', 'Luba', 18.0), ('COG', 'Kongo', 51.5), ('COK', 'English', 0.0), ('COL', 'Spanish', 99.0), ('COM', 'Comorian', 75.0), ('CPV', 'Crioulo', 100.0), ('CRI', 'Spanish', 97.5), ('CUB', 'Spanish', 100.0), ('CXR', 'Chinese', 0.0), ('CYM', 'English', 0.0), ('CYP', 'Greek', 74.1), ('CZE', 'Czech', 81.2), ('DEU', 'German', 91.3), ('DJI', 'Somali', 43.9), ('DMA', 'Creole English', 100.0), ('DNK', 'Danish', 93.5), ('DOM', 'Spanish', 98.0), ('DZA', 'Arabic', 86.0), ('ECU', 'Spanish', 93.0), ('EGY', 'Arabic', 98.8), ('ERI', 'Tigrinja', 49.1), ('ESH', 'Arabic', 100.0), ('ESP', 'Spanish', 74.4), ('EST', 'Estonian', 65.3), ('ETH', 'Oromo', 31.0), ('FIN', 'Finnish', 92.7), ('FJI', 'Fijian', 50.8), ('FLK', 'English', 0.0), ('FRA', 'French', 93.6), ('FRO', 'Faroese', 100.0), ('FSM', 'Trukese', 41.6), ('GAB', 'Fang', 35.8), ('GBR', 'English', 97.3), ('GEO', 'Georgiana', 71.7), ('GHA', 'Akan', 52.4), ('GIB', 'English', 88.9), ('GIN', 'Ful', 38.6), ('GLP', 'Creole French', 95.0), ('GMB', 'Malinke', 34.1), ('GNB', 'Crioulo', 36.4), ('GNQ', 'Fang', 84.8), ('GRC', 'Greek', 98.5), ('GRD', 'Creole English', 100.0), ('GRL', 'Greenlandic', 87.5), ('GTM', 'Spanish', 64.7), ('GUF', 'Creole French', 94.3), ('GUM', 'English', 37.5), ('GUY', 'Creole English', 96.4), ('HKG', 'Canton Chinese', 88.7), ('HND', 'Spanish', 97.2), ('HRV', 'Serbo-Croatian', 95.9), ('HTI', 'Haiti Creole', 100.0), ('HUN', 'Hungarian', 98.5), ('IDN', 'Javanese', 39.4), ('IND', 'Hindi', 39.9), ('IRL', 'English', 98.4), ('IRN', 'Persian', 45.7), ('IRQ', 'Arabic', 77.2), ('ISL', 'Icelandic', 95.7), ('ISR', 'Hebrew', 63.1), ('ITA', 'Italian', 94.1), ('JAM', 'Creole English', 94.2), ('JOR', 'Arabic', 97.9), ('JPN', 'Japanese', 99.1), ('KAZ', 'Kazakh', 46.0), ('KEN', 'Kikuyu', 20.9), ('KGZ', 'Kirgiz', 59.7), ('KHM', 'Khmer', 88.6), ('KIR', 'Kiribati', 98.9), ('KNA', 'Creole English', 100.0), ('KOR', 'Korean', 99.9), ('KWT', 'Arabic', 78.1), ('LAO', 'Lao', 67.2), ('LBN', 'Arabic', 93.0), ('LBR', 'Kpelle', 19.5), ('LBY', 'Arabic', 96.0), ('LCA', 'Creole French', 80.0), ('LIE', 'German', 89.0), ('LKA', 'Singali', 60.3), ('LSO', 'Sotho', 85.0), ('LTU', 'Lithuanian', 81.6), ('LUX', 'Luxembourgish', 64.4), ('LVA', 'Latvian', 55.1), ('MAC', 'Canton Chinese', 85.6), ('MAR', 'Arabic', 65.0), ('MCO', 'French', 41.9), ('MDA', 'Romanian', 61.9), ('MDG', 'Malagasy', 98.9), ('MDV', 'Dhivehi', 100.0), ('MEX', 'Spanish', 92.1), ('MHL', 'Marshallese', 96.8), ('MKD', 'Macedonian', 66.5), ('MLI', 'Bambara', 31.8), ('MLT', 'Maltese', 95.8), ('MMR', 'Burmese', 69.0), ('MNG', 'Mongolian', 78.8), ('MNP', 'Philippene Languages', 34.1), ('MOZ', 'Makua', 27.8), ('MRT', 'Hassaniya', 81.7), ('MSR', 'English', 0.0), ('MTQ', 'Creole French', 96.6), ('MUS', 'Creole French', 70.6), ('MWI', 'Chichewa', 58.3), ('MYS', 'Malay', 58.4), ('MYT', 'Mahoré', 41.9), ('NAM', 'Ovambo', 50.7), ('NCL', 'Malenasian Languages', 45.4), ('NER', 'Hausa', 53.1), ('NFK', 'English', 0.0), ('NGA', 'Joruba', 21.4), ('NIC', 'Spanish', 97.6), ('NIU', 'English', 0.0), ('NLD', 'Dutch', 95.6), ('NOR', 'Norwegian', 96.6), ('NPL', 'Nepali', 50.4), ('NRU', 'Nauru', 57.5), ('NZL', 'English', 87.0), ('OMN', 'Arabic', 76.7), ('PAK', 'Punjabi', 48.2), ('PAN', 'Spanish', 76.8), ('PCN', 'Pitcairnese', 0.0), ('PER', 'Spanish', 79.8), ('PHL', 'Pilipino', 29.3), ('PLW', 'Palau', 82.2), ('PNG', 'Papuan Languages', 78.1), ('POL', 'Polish', 97.6), ('PRI', 'Spanish', 51.3), ('PRK', 'Korean', 99.9), ('PRT', 'Portuguese', 99.0), ('PRY', 'Spanish', 55.1), ('PSE', 'Arabic', 95.9), ('PYF', 'Tahitian', 46.4), ('QAT', 'Arabic', 40.7), ('REU', 'Creole French', 91.5), ('ROM', 'Romanian', 90.7), ('RUS', 'Russian', 86.6), ('RWA', 'Rwanda', 100.0), ('SAU', 'Arabic', 95.0), ('SDN', 'Arabic', 49.4), ('SEN', 'Wolof', 48.1), ('SGP', 'Chinese', 77.1), ('SHN', 'English', 0.0), ('SJM', 'Norwegian', 0.0), ('SLB', 'Malenasian Languages', 85.6), ('SLE', 'Mende', 34.8), ('SLV', 'Spanish', 100.0), ('SMR', 'Italian', 100.0), ('SOM', 'Somali', 98.3), ('SPM', 'French', 0.0), ('STP', 'Crioulo', 86.3), ('SUR', 'Sranantonga', 81.0), ('SVK', 'Slovak', 85.6), ('SVN', 'Slovene', 87.9), ('SWE', 'Swedish', 89.5), ('SWZ', 'Swazi', 89.9), ('SYC', 'Seselwa', 91.3), ('SYR', 'Arabic', 90.0), ('TCA', 'English', 0.0), ('TCD', 'Sara', 27.7), ('TGO', 'Ewe', 23.2), ('THA', 'Thai', 52.6), ('TJK', 'Tadzhik', 62.2), ('TKL', 'English', 0.0), ('TKM', 'Turkmenian', 76.7), ('TMP', 'Portuguese', 0.0), ('TON', 'Tongan', 98.3), ('TTO', 'English', 93.5), ('TUN', 'Arabic', 69.9), ('TUR', 'Turkish', 87.6), ('TUV', 'Tuvalu', 92.5), ('TWN', 'Min', 66.7), ('TZA', 'Nyamwesi', 21.1), ('UGA', 'Ganda', 18.1), ('UKR', 'Ukrainian', 64.7), ('UMI', 'English', 0.0), ('URY', 'Spanish', 95.7), ('USA', 'English', 86.2), ('UZB', 'Uzbek', 72.6), ('VAT', 'Italian', 0.0), ('VCT', 'Creole English', 99.1), ('VEN', 'Spanish', 96.9), ('VGB', 'English', 0.0), ('VIR', 'English', 81.7), ('VNM', 'Vietnamese', 86.8), ('VUT', 'Bislama', 56.6), ('WLF', 'Futuna', 0.0), ('WSM', 'Samoan-English', 52.0), ('YEM', 'Arabic', 99.6), ('YUG', 'Serbo-Croatian', 75.2), ('ZAF', 'Zulu', 22.7), ('ZMB', 'Bemba', 29.7), ('ZWE', 'Shona', 72.1)]","[('Papiamento', 'ABW', 76.7), ('Pashto', 'AFG', 52.4), ('Ovimbundu', 'AGO', 37.2), ('English', 'AIA', 0.0), ('Albaniana', 'ALB', 97.9), ('Spanish', 'AND', 44.6), ('Papiamento', 'ANT', 86.2), ('Arabic', 'ARE', 42.0), ('Spanish', 'ARG', 96.8), ('Armenian', 'ARM', 93.4), ('Samoan', 'ASM', 90.6), ('Creole English', 'ATG', 95.7), ('English', 'AUS', 81.2), ('German', 'AUT', 92.0), ('Azerbaijani', 'AZE', 89.0), ('Kirundi', 'BDI', 98.1), ('Dutch', 'BEL', 59.2), ('Fon', 'BEN', 39.8), ('Mossi', 'BFA', 50.2), ('Bengali', 'BGD', 97.7), ('Bulgariana', 'BGR', 83.2), ('Arabic', 'BHR', 67.7), ('Creole English', 'BHS', 89.7), ('Serbo-Croatian', 'BIH', 99.2), ('Belorussian', 'BLR', 65.6), ('English', 'BLZ', 50.8), ('English', 'BMU', 100.0), ('Spanish', 'BOL', 87.7), ('Portuguese', 'BRA', 97.5), ('Bajan', 'BRB', 95.1), ('Malay', 'BRN', 45.5), ('Dzongkha', 'BTN', 50.0), ('Tswana', 'BWA', 75.5), ('Gbaya', 'CAF', 23.8), ('English', 'CAN', 60.4), ('English', 'CCK', 0.0), ('German', 'CHE', 63.6), ('Spanish', 'CHL', 89.7), ('Chinese', 'CHN', 92.0), ('Akan', 'CIV', 30.0), ('Fang', 'CMR', 19.7), ('Luba', 'COD', 18.0), ('Kongo', 'COG', 51.5), ('English', 'COK', 0.0), ('Spanish', 'COL', 99.0), ('Comorian', 'COM', 75.0), ('Crioulo', 'CPV', 100.0), ('Spanish', 'CRI', 97.5), ('Spanish', 'CUB', 100.0), ('Chinese', 'CXR', 0.0), ('English', 'CYM', 0.0), ('Greek', 'CYP', 74.1), ('Czech', 'CZE', 81.2), ('German', 'DEU', 91.3), ('Somali', 'DJI', 43.9), ('Creole English', 'DMA', 100.0), ('Danish', 'DNK', 93.5), ('Spanish', 'DOM', 98.0), ('Arabic', 'DZA', 86.0), ('Spanish', 'ECU', 93.0), ('Arabic', 'EGY', 98.8), ('Tigrinja', 'ERI', 49.1), ('Arabic', 'ESH', 100.0), ('Spanish', 'ESP', 74.4), ('Estonian', 'EST', 65.3), ('Oromo', 'ETH', 31.0), ('Finnish', 'FIN', 92.7), ('Fijian', 'FJI', 50.8), ('English', 'FLK', 0.0), ('French', 'FRA', 93.6), ('Faroese', 'FRO', 100.0), ('Trukese', 'FSM', 41.6), ('Fang', 'GAB', 35.8), ('English', 'GBR', 97.3), ('Georgiana', 'GEO', 71.7), ('Akan', 'GHA', 52.4), ('English', 'GIB', 88.9), ('Ful', 'GIN', 38.6), ('Creole French', 'GLP', 95.0), ('Malinke', 'GMB', 34.1), ('Crioulo', 'GNB', 36.4), ('Fang', 'GNQ', 84.8), ('Greek', 'GRC', 98.5), ('Creole English', 'GRD', 100.0), ('Greenlandic', 'GRL', 87.5), ('Spanish', 'GTM', 64.7), ('Creole French', 'GUF', 94.3), ('English', 'GUM', 37.5), ('Creole English', 'GUY', 96.4), ('Canton Chinese', 'HKG', 88.7), ('Spanish', 'HND', 97.2), ('Serbo-Croatian', 'HRV', 95.9), ('Haiti Creole', 'HTI', 100.0), ('Hungarian', 'HUN', 98.5), ('Javanese', 'IDN', 39.4), ('Hindi', 'IND', 39.9), ('English', 'IRL', 98.4), ('Persian', 'IRN', 45.7), ('Arabic', 'IRQ', 77.2), ('Icelandic', 'ISL', 95.7), ('Hebrew', 'ISR', 63.1), ('Italian', 'ITA', 94.1), ('Creole English', 'JAM', 94.2), ('Arabic', 'JOR', 97.9), ('Japanese', 'JPN', 99.1), ('Kazakh', 'KAZ', 46.0), ('Kikuyu', 'KEN', 20.9), ('Kirgiz', 'KGZ', 59.7), ('Khmer', 'KHM', 88.6), ('Kiribati', 'KIR', 98.9), ('Creole English', 'KNA', 100.0), ('Korean', 'KOR', 99.9), ('Arabic', 'KWT', 78.1), ('Lao', 'LAO', 67.2), ('Arabic', 'LBN', 93.0), ('Kpelle', 'LBR', 19.5), ('Arabic', 'LBY', 96.0), ('Creole French', 'LCA', 80.0), ('German', 'LIE', 89.0), ('Singali', 'LKA', 60.3), ('Sotho', 'LSO', 85.0), ('Lithuanian', 'LTU', 81.6), ('Luxembourgish', 'LUX', 64.4), ('Latvian', 'LVA', 55.1), ('Canton Chinese', 'MAC', 85.6), ('Arabic', 'MAR', 65.0), ('French', 'MCO', 41.9), ('Romanian', 'MDA', 61.9), ('Malagasy', 'MDG', 98.9), ('Dhivehi', 'MDV', 100.0), ('Spanish', 'MEX', 92.1), ('Marshallese', 'MHL', 96.8), ('Macedonian', 'MKD', 66.5), ('Bambara', 'MLI', 31.8), ('Maltese', 'MLT', 95.8), ('Burmese', 'MMR', 69.0), ('Mongolian', 'MNG', 78.8), ('Philippene Languages', 'MNP', 34.1), ('Makua', 'MOZ', 27.8), ('Hassaniya', 'MRT', 81.7), ('English', 'MSR', 0.0), ('Creole French', 'MTQ', 96.6), ('Creole French', 'MUS', 70.6), ('Chichewa', 'MWI', 58.3), ('Malay', 'MYS', 58.4), ('Mahoré', 'MYT', 41.9), ('Ovambo', 'NAM', 50.7), ('Malenasian Languages', 'NCL', 45.4), ('Hausa', 'NER', 53.1), ('English', 'NFK', 0.0), ('Joruba', 'NGA', 21.4), ('Spanish', 'NIC', 97.6), ('English', 'NIU', 0.0), ('Dutch', 'NLD', 95.6), ('Norwegian', 'NOR', 96.6), ('Nepali', 'NPL', 50.4), ('Nauru', 'NRU', 57.5), ('English', 'NZL', 87.0), ('Arabic', 'OMN', 76.7), ('Punjabi', 'PAK', 48.2), ('Spanish', 'PAN', 76.8), ('Pitcairnese', 'PCN', 0.0), ('Spanish', 'PER', 79.8), ('Pilipino', 'PHL', 29.3), ('Palau', 'PLW', 82.2), ('Papuan Languages', 'PNG', 78.1), ('Polish', 'POL', 97.6), ('Spanish', 'PRI', 51.3), ('Korean', 'PRK', 99.9), ('Portuguese', 'PRT', 99.0), ('Spanish', 'PRY', 55.1), ('Arabic', 'PSE', 95.9), ('Tahitian', 'PYF', 46.4), ('Arabic', 'QAT', 40.7), ('Creole French', 'REU', 91.5), ('Romanian', 'ROM', 90.7), ('Russian', 'RUS', 86.6), ('Rwanda', 'RWA', 100.0), ('Arabic', 'SAU', 95.0), ('Arabic', 'SDN', 49.4), ('Wolof', 'SEN', 48.1), ('Chinese', 'SGP', 77.1), ('English', 'SHN', 0.0), ('Norwegian', 'SJM', 0.0), ('Malenasian Languages', 'SLB', 85.6), ('Mende', 'SLE', 34.8), ('Spanish', 'SLV', 100.0), ('Italian', 'SMR', 100.0), ('Somali', 'SOM', 98.3), ('French', 'SPM', 0.0), ('Crioulo', 'STP', 86.3), ('Sranantonga', 'SUR', 81.0), ('Slovak', 'SVK', 85.6), ('Slovene', 'SVN', 87.9), ('Swedish', 'SWE', 89.5), ('Swazi', 'SWZ', 89.9), ('Seselwa', 'SYC', 91.3), ('Arabic', 'SYR', 90.0), ('English', 'TCA', 0.0), ('Sara', 'TCD', 27.7), ('Ewe', 'TGO', 23.2), ('Thai', 'THA', 52.6), ('Tadzhik', 'TJK', 62.2), ('English', 'TKL', 0.0), ('Turkmenian', 'TKM', 76.7), ('Portuguese', 'TMP', 0.0), ('Tongan', 'TON', 98.3), ('English', 'TTO', 93.5), ('Arabic', 'TUN', 69.9), ('Turkish', 'TUR', 87.6), ('Tuvalu', 'TUV', 92.5), ('Min', 'TWN', 66.7), ('Nyamwesi', 'TZA', 21.1), ('Ganda', 'UGA', 18.1), ('Ukrainian', 'UKR', 64.7), ('English', 'UMI', 0.0), ('Spanish', 'URY', 95.7), ('English', 'USA', 86.2), ('Uzbek', 'UZB', 72.6), ('Italian', 'VAT', 0.0), ('Creole English', 'VCT', 99.1), ('Spanish', 'VEN', 96.9), ('English', 'VGB', 0.0), ('English', 'VIR', 81.7), ('Vietnamese', 'VNM', 86.8), ('Bislama', 'VUT', 56.6), ('Futuna', 'WLF', 0.0), ('Samoan-English', 'WSM', 52.0), ('Arabic', 'YEM', 99.6), ('Serbo-Croatian', 'YUG', 75.2), ('Zulu', 'ZAF', 22.7), ('Bemba', 'ZMB', 29.7), ('Shona', 'ZWE', 72.1)]",,1.0,
Show the number of high schoolers for each grade.,"[Highschooler.grade, Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,"SELECT Highschooler.grade, COUNT(Highschooler.ID) AS num_highschoolers FROM Highschooler GROUP BY Highschooler.grade;","SELECT grade ,  count(*) FROM Highschooler GROUP BY grade",network_1,"1. Sequential Structure: Begin with the SELECT clause to specify the grade and the count of high schoolers for each grade. 2. Aggregation Structure: Use COUNT to calculate the number of high schoolers in each grade. 3. Grouping Structure: Use GROUP BY on ""Highschooler.grade"" to group the results by each grade. 4. Join Structure: No JOIN is required since all necessary data is within the ""Highschooler"" table.","[(9, 4), (10, 4), (11, 4), (12, 4)]","[(9, 4), (10, 4), (11, 4), (12, 4)]",,1.0,
What is the average attendance of shows?,[show.Attendance],"Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT AVG(show.Attendance) AS average_attendance FROM show;,SELECT avg(Attendance) FROM SHOW,orchestra,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average attendance. 2. Aggregation Structure: Use the AVG function to calculate the average attendance of shows. 3. Condition Structure: No specific filtering condition is required as we want the average attendance for all shows. 4. Join Structure: No JOIN is required since all necessary data is within the ""show"" table.","[(1326.4,)]","[(1326.4,)]",,1.0,
How many conductors are there?,[conductor.Conductor_ID],"Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT COUNT(conductor.Conductor_ID) AS total_conductors FROM conductor;,SELECT count(*) FROM conductor,orchestra,"1. Sequential Structure: Start with the SELECT clause to count the number of conductors. 2. Condition Structure: No specific filtering condition is required as we want the total count of conductors. 3. Join Structure: No JOIN is necessary since all required information is in the ""conductor"" table. 4. Aggregation Structure: Use COUNT on ""conductor.Conductor_ID"" to calculate the total number of conductors.","[(12,)]","[(12,)]",,1.0,
Which Asian countries have a population that is larger than any country in Africa?,"[country.Name, country.Continent, country.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT Name FROM country WHERE Continent = 'Asia' AND Population > (SELECT MAX(Population) FROM country WHERE Continent = 'Africa');,"SELECT Name FROM country WHERE Continent  =  ""Asia""  AND population  >  (SELECT max(population) FROM country WHERE Continent  =  ""Africa"")",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of countries. Use the FROM clause to specify the country table. Apply a WHERE clause to filter for countries in Asia whose population is larger than the population of any country in Africa. 2. Condition Structure: Use the WHERE clause to filter for countries in Asia (Continent = 'Asia') and ensure their population is greater than the maximum population of any country in Africa. Use a subquery to calculate the maximum population of countries in Africa. 3. Join Structure: Not required, as all data is available within the country table. 4. Aggregation Structure: Use a subquery with MAX to find the maximum population of countries in Africa, and compare it with the population of Asian countries in the main query.","[('Bangladesh',), ('China',), ('Indonesia',), ('India',), ('Japan',), ('Pakistan',)]","[('Bangladesh',), ('China',), ('Indonesia',), ('India',), ('Japan',), ('Pakistan',)]",,1.0,
"What are the name, independence year, and surface area of the country with the smallest population?","[country.Name, country.IndepYear, country.SurfaceArea, country.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);","SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name, independence year, and surface area of the country. Use the FROM clause to specify the country table. Apply a WHERE clause to filter for the country with the smallest population. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the country with the minimum population. 3. Join Structure: Not required, as all data is available within the country table. 4. Aggregation Structure: Use the MIN function in a subquery to find the smallest population, which is then used in the filtering condition.","[('Antarctica', None, 13120000.0), ('French Southern territories', None, 7780.0), ('Bouvet Island', None, 59.0), ('Heard Island and McDonald Islands', None, 359.0), ('British Indian Ocean Territory', None, 78.0), ('South Georgia and the South Sandwich Islands', None, 3903.0), ('United States Minor Outlying Islands', None, 16.0)]","[('Antarctica', 13120000.0, None)]",,1.0,
"What are the names of conductors whose nationalities are not ""USA""?","[conductor.Name, conductor.Nationality]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT conductor.Name FROM conductor WHERE conductor.Nationality != 'USA';,SELECT Name FROM conductor WHERE Nationality != 'USA',orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""conductor.Name"" of conductors whose nationalities are not ""USA"". 2. Condition Structure: Use a WHERE clause to filter conductors where ""conductor.Nationality"" is not equal to ""USA"". 3. Join Structure: No JOIN is required since all necessary information is in the ""conductor"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.","[('Igor Stravinsky',), ('Paul Jorgensen',), ('Charles Dutoit',), ('Pierre Boulez',), ('Robert Craft',), ('Michael Tilson Thomas',)]","[('Igor Stravinsky',), ('Paul Jorgensen',), ('Charles Dutoit',), ('Pierre Boulez',), ('Robert Craft',), ('Michael Tilson Thomas',)]",,1.0,
Count the number of likes for each student id.,"[Likes.liked_id, COUNT(Likes.liked_id]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,"SELECT Likes.liked_id, COUNT(Likes.liked_id) AS like_count FROM Likes GROUP BY Likes.liked_id;","SELECT student_id ,  count(*) FROM Likes GROUP BY student_id",network_1,"1. Sequential Structure: Begin with the SELECT clause to specify the student ID (Likes.liked_id) and the count of likes for each student. 2. Aggregation Structure: Use the COUNT function to count the number of likes for each student ID. 3. Grouping Structure: Use GROUP BY on ""Likes.liked_id"" to calculate the count of likes for each student. 4. Join Structure: No JOIN is required since all necessary data is within the ""Likes"" table.","[(1101, 1), (1247, 1), (1304, 1), (1468, 2), (1501, 1), (1689, 1), (1709, 2), (1934, 1)]","[(1025, 1), (1247, 1), (1316, 1), (1501, 1), (1641, 1), (1689, 1), (1709, 1), (1782, 1), (1911, 1), (1934, 1)]",,1.0,
Return the country name and the numbers of languages spoken for each country that speaks at least 3 languages.,"[country.Name, countrylanguage.CountryCode, countrylanguage.Language, countrylanguage.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,"SELECT country.Name, COUNT(DISTINCT countrylanguage.Language) AS NumberOfLanguages FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode GROUP BY country.Name HAVING COUNT(DISTINCT countrylanguage.Language) >= 3;","SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Name"" and the count of distinct languages spoken in each country. Use GROUP BY to group the results by country. 2. Condition Structure: Apply a HAVING clause to filter for countries where the count of languages is at least 3. 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables on ""country.Code = countrylanguage.CountryCode"" to associate each country with its languages. 4. Aggregation Structure: Use COUNT on ""countrylanguage.Language"" to count the number of languages spoken in each country.","[('Afghanistan', 5), ('Albania', 3), ('American Samoa', 3), ('Andorra', 4), ('Angola', 9), ('Argentina', 3), ('Aruba', 4), ('Australia', 8), ('Austria', 8), ('Azerbaijan', 4), ('Bangladesh', 7), ('Belarus', 4), ('Belgium', 6), ('Belize', 4), ('Benin', 7), ('Bhutan', 3), ('Bolivia', 4), ('Botswana', 5), ('Brazil', 5), ('Brunei', 4), ('Bulgaria', 4), ('Burkina Faso', 6), ('Burundi', 3), ('Cambodia', 4), ('Cameroon', 8), ('Canada', 12), ('Central African Republic', 6), ('Chad', 8), ('Chile', 4), ('China', 12), ('Colombia', 5), ('Comoros', 5), ('Congo', 6), ('Congo, The Democratic Republic of the', 10), ('Costa Rica', 4), ('Czech Republic', 8), ('Côte d’Ivoire', 5), ('Denmark', 7), ('Djibouti', 3), ('Eritrea', 6), ('Estonia', 5), ('Ethiopia', 7), ('Finland', 5), ('France', 6), ('French Polynesia', 3), ('Gabon', 4), ('Gambia', 5), ('Georgia', 6), ('Germany', 6), ('Ghana', 6), ('Guam', 5), ('Guatemala', 5), ('Guinea', 7), ('Guinea-Bissau', 6), ('Guyana', 3), ('Honduras', 4), ('Hong Kong', 5), ('Hungary', 6), ('India', 12), ('Indonesia', 9), ('Iran', 10), ('Iraq', 5), ('Israel', 3), ('Italy', 8), ('Japan', 6), ('Jordan', 3), ('Kazakstan', 6), ('Kenya', 10), ('Kyrgyzstan', 7), ('Laos', 4), ('Latvia', 6), ('Lebanon', 3), ('Lesotho', 3), ('Liberia', 8), ('Liechtenstein', 3), ('Lithuania', 5), ('Luxembourg', 5), ('Macao', 4), ('Macedonia', 5), ('Malawi', 4), ('Malaysia', 6), ('Mali', 6), ('Mauritania', 6), ('Mauritius', 6), ('Mayotte', 3), ('Mexico', 6), ('Micronesia, Federated States of', 6), ('Moldova', 5), ('Monaco', 4), ('Mongolia', 6), ('Mozambique', 10), ('Myanmar', 8), ('Namibia', 8), ('Nauru', 5), ('Nepal', 7), ('Netherlands', 4), ('Netherlands Antilles', 3), ('New Caledonia', 3), ('Nicaragua', 4), ('Niger', 5), ('Nigeria', 10), ('Northern Mariana Islands', 6), ('Norway', 5), ('Pakistan', 8), ('Palau', 4), ('Panama', 6), ('Paraguay', 4), ('Peru', 3), ('Philippines', 10), ('Poland', 4), ('Romania', 6), ('Russian Federation', 12), ('Réunion', 5), ('Samoa', 3), ('Senegal', 6), ('Seychelles', 3), ('Sierra Leone', 8), ('Singapore', 3), ('Slovakia', 5), ('Slovenia', 3), ('Solomon Islands', 3), ('South Africa', 11), ('Spain', 4), ('Sri Lanka', 3), ('Sudan', 10), ('Sweden', 6), ('Switzerland', 4), ('Taiwan', 6), ('Tajikistan', 3), ('Tanzania', 11), ('Thailand', 6), ('Togo', 8), ('Trinidad and Tobago', 3), ('Tunisia', 3), ('Turkey', 3), ('Turkmenistan', 4), ('Tuvalu', 3), ('Uganda', 10), ('Ukraine', 7), ('United Kingdom', 3), ('United States', 12), ('Uzbekistan', 6), ('Vanuatu', 3), ('Venezuela', 3), ('Vietnam', 9), ('Virgin Islands, U.S.', 3), ('Yugoslavia', 6), ('Zambia', 6), ('Zimbabwe', 4)]","[(5, 'Afghanistan'), (3, 'Albania'), (3, 'American Samoa'), (4, 'Andorra'), (9, 'Angola'), (3, 'Argentina'), (4, 'Aruba'), (8, 'Australia'), (8, 'Austria'), (4, 'Azerbaijan'), (7, 'Bangladesh'), (4, 'Belarus'), (6, 'Belgium'), (4, 'Belize'), (7, 'Benin'), (3, 'Bhutan'), (4, 'Bolivia'), (5, 'Botswana'), (5, 'Brazil'), (4, 'Brunei'), (4, 'Bulgaria'), (6, 'Burkina Faso'), (3, 'Burundi'), (4, 'Cambodia'), (8, 'Cameroon'), (12, 'Canada'), (6, 'Central African Republic'), (8, 'Chad'), (4, 'Chile'), (12, 'China'), (5, 'Colombia'), (5, 'Comoros'), (6, 'Congo'), (10, 'Congo, The Democratic Republic of the'), (4, 'Costa Rica'), (8, 'Czech Republic'), (5, 'Côte d’Ivoire'), (7, 'Denmark'), (3, 'Djibouti'), (6, 'Eritrea'), (5, 'Estonia'), (7, 'Ethiopia'), (5, 'Finland'), (6, 'France'), (3, 'French Polynesia'), (4, 'Gabon'), (5, 'Gambia'), (6, 'Georgia'), (6, 'Germany'), (6, 'Ghana'), (5, 'Guam'), (5, 'Guatemala'), (7, 'Guinea'), (6, 'Guinea-Bissau'), (3, 'Guyana'), (4, 'Honduras'), (5, 'Hong Kong'), (6, 'Hungary'), (12, 'India'), (9, 'Indonesia'), (10, 'Iran'), (5, 'Iraq'), (3, 'Israel'), (8, 'Italy'), (6, 'Japan'), (3, 'Jordan'), (6, 'Kazakstan'), (10, 'Kenya'), (7, 'Kyrgyzstan'), (4, 'Laos'), (6, 'Latvia'), (3, 'Lebanon'), (3, 'Lesotho'), (8, 'Liberia'), (3, 'Liechtenstein'), (5, 'Lithuania'), (5, 'Luxembourg'), (4, 'Macao'), (5, 'Macedonia'), (4, 'Malawi'), (6, 'Malaysia'), (6, 'Mali'), (6, 'Mauritania'), (6, 'Mauritius'), (3, 'Mayotte'), (6, 'Mexico'), (6, 'Micronesia, Federated States of'), (5, 'Moldova'), (4, 'Monaco'), (6, 'Mongolia'), (10, 'Mozambique'), (8, 'Myanmar'), (8, 'Namibia'), (5, 'Nauru'), (7, 'Nepal'), (4, 'Netherlands'), (3, 'Netherlands Antilles'), (3, 'New Caledonia'), (4, 'Nicaragua'), (5, 'Niger'), (10, 'Nigeria'), (6, 'Northern Mariana Islands'), (5, 'Norway'), (8, 'Pakistan'), (4, 'Palau'), (6, 'Panama'), (4, 'Paraguay'), (3, 'Peru'), (10, 'Philippines'), (4, 'Poland'), (6, 'Romania'), (12, 'Russian Federation'), (5, 'Réunion'), (3, 'Samoa'), (6, 'Senegal'), (3, 'Seychelles'), (8, 'Sierra Leone'), (3, 'Singapore'), (5, 'Slovakia'), (3, 'Slovenia'), (3, 'Solomon Islands'), (11, 'South Africa'), (4, 'Spain'), (3, 'Sri Lanka'), (10, 'Sudan'), (6, 'Sweden'), (4, 'Switzerland'), (6, 'Taiwan'), (3, 'Tajikistan'), (11, 'Tanzania'), (6, 'Thailand'), (8, 'Togo'), (3, 'Trinidad and Tobago'), (3, 'Tunisia'), (3, 'Turkey'), (4, 'Turkmenistan'), (3, 'Tuvalu'), (10, 'Uganda'), (7, 'Ukraine'), (3, 'United Kingdom'), (12, 'United States'), (6, 'Uzbekistan'), (3, 'Vanuatu'), (3, 'Venezuela'), (9, 'Vietnam'), (3, 'Virgin Islands, U.S.'), (6, 'Yugoslavia'), (6, 'Zambia'), (4, 'Zimbabwe')]",,1.0,
"Give the name, population, and head of state for the country that has the largest area.","[country.Name, country.Population, country.HeadOfState, country.SurfaceArea]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT Name, Population, HeadOfState FROM country WHERE SurfaceArea = (SELECT MAX(SurfaceArea) FROM country);","SELECT Name ,  population ,  HeadOfState FROM country ORDER BY SurfaceArea DESC LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name, population, and head of state of the country. Use the FROM clause to specify the country table. Apply a WHERE clause to filter for the country with the largest surface area. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the country with the maximum surface area. 3. Join Structure: Not required, as all the required data is available in the country table. 4. Aggregation Structure: Use MAX in a subquery to find the largest surface area and filter based on this value to retrieve the relevant country details.","[('Russian Federation', 146934000, 'Vladimir Putin')]","[('Russian Federation', 146934000, 'Vladimir Putin')]",,1.0,
How many friends does each student have?,"[Friend.student_id, Friend.friend_id, Friend.student_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,"SELECT Highschooler.ID, COUNT(Friend.friend_id) AS num_friends FROM Highschooler JOIN Friend ON Friend.student_id = Highschooler.ID GROUP BY Highschooler.ID;","SELECT student_id ,  count(*) FROM Friend GROUP BY student_id",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Highschooler.ID"" and the count of friends for each student. Use COUNT to calculate the number of friends for each student. 2. Condition Structure: No specific filtering condition is required, as we need the count of friends for all students. 3. Join Structure: Use a JOIN between the ""Friend"" table and the ""Highschooler"" table on ""Friend.student_id = Highschooler.ID"" to associate each student with their friends. 4. Aggregation Structure: Use COUNT on ""Friend.friend_id"" to count the number of friends for each student, and GROUP BY ""Highschooler.ID"" to group the results by each student.","[(1101, 1), (1247, 2), (1304, 1), (1316, 1), (1381, 1), (1468, 2), (1501, 1), (1510, 2), (1661, 1), (1689, 2), (1709, 1), (1782, 3), (1911, 1), (1934, 1)]","[(1101, 1), (1247, 2), (1304, 1), (1316, 1), (1381, 1), (1468, 2), (1501, 1), (1510, 2), (1661, 1), (1689, 2), (1709, 1), (1782, 3), (1911, 1), (1934, 1)]",,1.0,
List the record company shared by the most number of orchestras.,"[orchestra.Record_Company,orchestra.Orchestra_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT orchestra.Record_Company FROM orchestra GROUP BY orchestra.Record_Company ORDER BY COUNT(orchestra.Orchestra_ID) DESC LIMIT 1;,SELECT Record_Company FROM orchestra GROUP BY Record_Company ORDER BY COUNT(*) DESC LIMIT 1,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""orchestra.Record_Company"" that is shared by the most orchestras. 2. Aggregation Structure: Use COUNT to calculate the number of orchestras associated with each record company. 3. Grouping Structure: Use GROUP BY on ""orchestra.Record_Company"" to group the orchestras by their record company. 4. Ordering Structure: Use ORDER BY in descending order on the count of orchestras to rank the record companies by the number of orchestras they are associated with. 5. Limiting Structure: Use LIMIT 1 to retrieve the record company shared by the most orchestras. 6. Join Structure: No JOIN is required since all necessary data is within the ""orchestra"" table.","[('Decca Records',)]","[('Decca Records',)]",,1.0,
What are the names of students who have no friends?,"[Highschooler.ID, Highschooler.name, Friend.student_id = Highschooler.ID, Friend.friend_id]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NESTED,SELECT name FROM Highschooler WHERE ID NOT IN (SELECT student_id FROM Friend);,SELECT name FROM Highschooler EXCEPT SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of students. Use the FROM clause to specify the Highschooler table. Apply a WHERE clause to filter students who have no friends by ensuring their ID does not appear as a student_id in the Friend table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose ID appears in the Friend table as a student_id, indicating they have friends. 3. Join Structure: Not required, as we only need to filter based on the absence of matching student_id entries in the Friend table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Brittany',), ('John',)]","[('Brittany',), ('John',)]",,1.0,
Show the student IDs and numbers of friends corresponding to each.,"[Highschooler.ID, Friend.student_id, Friend.friend_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,"SELECT Friend.student_id, COUNT(Friend.friend_id) AS number_of_friends FROM Friend GROUP BY Friend.student_id;","SELECT student_id ,  count(*) FROM Friend GROUP BY student_id",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""student_id"" and the count of their friends. Use COUNT to calculate the number of friends for each student. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use the ""Friend"" table directly, as it already contains the relationships between students and their friends. No additional JOIN is necessary since the ""student_id"" and ""friend_id"" are sufficient for the query. 4. Aggregation Structure: Use COUNT on ""friend_id"" to count the number of friends for each ""student_id,"" and GROUP BY ""student_id"" to group the results by each student.","[(1101, 1), (1247, 2), (1304, 1), (1316, 1), (1381, 1), (1468, 2), (1501, 1), (1510, 2), (1661, 1), (1689, 2), (1709, 1), (1782, 3), (1911, 1), (1934, 1)]","[(1101, 1), (1247, 2), (1304, 1), (1316, 1), (1381, 1), (1468, 2), (1501, 1), (1510, 2), (1661, 1), (1689, 2), (1709, 1), (1782, 3), (1911, 1), (1934, 1)]",,1.0,
What are the record companies of orchestras in descending order of years in which they were founded?,"[orchestra.Record_Company, orchestra.Year_of_Founded]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,"SELECT orchestra.Record_Company, orchestra.Year_of_Founded FROM orchestra ORDER BY orchestra.Year_of_Founded DESC;",SELECT Record_Company FROM orchestra ORDER BY Year_of_Founded DESC,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""orchestra.Record_Company"" and ""orchestra.Year_of_Founded"" fields. 2. Condition Structure: No specific filtering condition is required as we want all record companies and their founding years. 3. Join Structure: No JOIN is required since all necessary information is available in the ""orchestra"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving and sorting the data. 5. Ordering Structure: Use ORDER BY in descending order on ""orchestra.Year_of_Founded"" to sort the record companies by their founding years.","[('Columbia Masterworks', 2009.0), ('Philips', 2008.0), ('Philips Classics Records', 2008.0), ('RCA', 2008.0), ('EMI', 2007.0), ('Koch Records / Naxos Records', 2006.0), ('Decca Records', 2004.0), ('Mercury Records', 2003.0), ('Deutsche Grammophon', 2003.0), ('Kultur', 2002.0), ('Decca Records', 2002.0), ('Delos Records', 2002.0)]","[('Columbia Masterworks',), ('Philips',), ('Philips Classics Records',), ('RCA',), ('EMI',), ('Koch Records / Naxos Records',), ('Decca Records',), ('Mercury Records',), ('Deutsche Grammophon',), ('Kultur',), ('Decca Records',), ('Delos Records',)]",,1.0,
Show the names of high school students and their corresponding number of friends.,"[Highschooler.name, Friend.student_id, Friend.friend_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,"SELECT Highschooler.name, COUNT(Friend.friend_id) AS number_of_friends FROM Highschooler JOIN Friend ON Highschooler.ID = Friend.student_id GROUP BY Highschooler.ID;","SELECT T2.name ,  count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of high school students (""Highschooler.name"") and their corresponding number of friends. Use COUNT to calculate the number of friends for each student. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Highschooler"" table and the ""Friend"" table. The ""Friend.student_id"" column is used to link each student to their friends, and ""Friend.friend_id"" is used to count the friends. 4. Aggregation Structure: Use COUNT on ""Friend.friend_id"" to count the number of friends for each student. Use GROUP BY on ""Highschooler.ID"" to group the results by each student.","[('Haley', 1), ('Alexis', 2), ('Jordan', 1), ('Austin', 1), ('Tiffany', 1), ('Kris', 2), ('Jessica', 1), ('Jordan', 2), ('Logan', 1), ('Gabriel', 2), ('Cassandra', 1), ('Andrew', 3), ('Gabriel', 1), ('Kyle', 1)]","[('Haley', 1), ('Alexis', 2), ('Jordan', 1), ('Austin', 1), ('Tiffany', 1), ('Kris', 2), ('Jessica', 1), ('Jordan', 2), ('Logan', 1), ('Gabriel', 2), ('Cassandra', 1), ('Andrew', 3), ('Gabriel', 1), ('Kyle', 1)]",,1.0,
"What are the names of countries that speak more than 2 languages, as well as how many languages they speak?","[country.Name, countrylanguage.Language, countrylanguage.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,"SELECT country.Name, COUNT(countrylanguage.Language) AS LanguageCount FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode GROUP BY country.Name HAVING COUNT(countrylanguage.Language) > 2;","SELECT COUNT(T2.Language) ,  T1.Name FROM country AS T1 JOIN countrylanguage AS T2 ON T1.Code  =  T2.CountryCode GROUP BY T1.Name HAVING COUNT(*)  >  2",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Name"" and the count of languages spoken in each country. Use an alias for the count of languages for clarity. 2. Condition Structure: Use a HAVING clause to filter for countries that speak more than 2 languages. 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables on ""country.Code = countrylanguage.CountryCode"" to associate each country with its languages. 4. Aggregation Structure: Use COUNT on ""countrylanguage.Language"" to count the number of languages spoken in each country, and GROUP BY ""country.Name"" to group the results by country.","[('Afghanistan', 5), ('Albania', 3), ('American Samoa', 3), ('Andorra', 4), ('Angola', 9), ('Argentina', 3), ('Aruba', 4), ('Australia', 8), ('Austria', 8), ('Azerbaijan', 4), ('Bangladesh', 7), ('Belarus', 4), ('Belgium', 6), ('Belize', 4), ('Benin', 7), ('Bhutan', 3), ('Bolivia', 4), ('Botswana', 5), ('Brazil', 5), ('Brunei', 4), ('Bulgaria', 4), ('Burkina Faso', 6), ('Burundi', 3), ('Cambodia', 4), ('Cameroon', 8), ('Canada', 12), ('Central African Republic', 6), ('Chad', 8), ('Chile', 4), ('China', 12), ('Colombia', 5), ('Comoros', 5), ('Congo', 6), ('Congo, The Democratic Republic of the', 10), ('Costa Rica', 4), ('Czech Republic', 8), ('Côte d’Ivoire', 5), ('Denmark', 7), ('Djibouti', 3), ('Eritrea', 6), ('Estonia', 5), ('Ethiopia', 7), ('Finland', 5), ('France', 6), ('French Polynesia', 3), ('Gabon', 4), ('Gambia', 5), ('Georgia', 6), ('Germany', 6), ('Ghana', 6), ('Guam', 5), ('Guatemala', 5), ('Guinea', 7), ('Guinea-Bissau', 6), ('Guyana', 3), ('Honduras', 4), ('Hong Kong', 5), ('Hungary', 6), ('India', 12), ('Indonesia', 9), ('Iran', 10), ('Iraq', 5), ('Israel', 3), ('Italy', 8), ('Japan', 6), ('Jordan', 3), ('Kazakstan', 6), ('Kenya', 10), ('Kyrgyzstan', 7), ('Laos', 4), ('Latvia', 6), ('Lebanon', 3), ('Lesotho', 3), ('Liberia', 8), ('Liechtenstein', 3), ('Lithuania', 5), ('Luxembourg', 5), ('Macao', 4), ('Macedonia', 5), ('Malawi', 4), ('Malaysia', 6), ('Mali', 6), ('Mauritania', 6), ('Mauritius', 6), ('Mayotte', 3), ('Mexico', 6), ('Micronesia, Federated States of', 6), ('Moldova', 5), ('Monaco', 4), ('Mongolia', 6), ('Mozambique', 10), ('Myanmar', 8), ('Namibia', 8), ('Nauru', 5), ('Nepal', 7), ('Netherlands', 4), ('Netherlands Antilles', 3), ('New Caledonia', 3), ('Nicaragua', 4), ('Niger', 5), ('Nigeria', 10), ('Northern Mariana Islands', 6), ('Norway', 5), ('Pakistan', 8), ('Palau', 4), ('Panama', 6), ('Paraguay', 4), ('Peru', 3), ('Philippines', 10), ('Poland', 4), ('Romania', 6), ('Russian Federation', 12), ('Réunion', 5), ('Samoa', 3), ('Senegal', 6), ('Seychelles', 3), ('Sierra Leone', 8), ('Singapore', 3), ('Slovakia', 5), ('Slovenia', 3), ('Solomon Islands', 3), ('South Africa', 11), ('Spain', 4), ('Sri Lanka', 3), ('Sudan', 10), ('Sweden', 6), ('Switzerland', 4), ('Taiwan', 6), ('Tajikistan', 3), ('Tanzania', 11), ('Thailand', 6), ('Togo', 8), ('Trinidad and Tobago', 3), ('Tunisia', 3), ('Turkey', 3), ('Turkmenistan', 4), ('Tuvalu', 3), ('Uganda', 10), ('Ukraine', 7), ('United Kingdom', 3), ('United States', 12), ('Uzbekistan', 6), ('Vanuatu', 3), ('Venezuela', 3), ('Vietnam', 9), ('Virgin Islands, U.S.', 3), ('Yugoslavia', 6), ('Zambia', 6), ('Zimbabwe', 4)]","[(5, 'Afghanistan'), (3, 'Albania'), (3, 'American Samoa'), (4, 'Andorra'), (9, 'Angola'), (3, 'Argentina'), (4, 'Aruba'), (8, 'Australia'), (8, 'Austria'), (4, 'Azerbaijan'), (7, 'Bangladesh'), (4, 'Belarus'), (6, 'Belgium'), (4, 'Belize'), (7, 'Benin'), (3, 'Bhutan'), (4, 'Bolivia'), (5, 'Botswana'), (5, 'Brazil'), (4, 'Brunei'), (4, 'Bulgaria'), (6, 'Burkina Faso'), (3, 'Burundi'), (4, 'Cambodia'), (8, 'Cameroon'), (12, 'Canada'), (6, 'Central African Republic'), (8, 'Chad'), (4, 'Chile'), (12, 'China'), (5, 'Colombia'), (5, 'Comoros'), (6, 'Congo'), (10, 'Congo, The Democratic Republic of the'), (4, 'Costa Rica'), (8, 'Czech Republic'), (5, 'Côte d’Ivoire'), (7, 'Denmark'), (3, 'Djibouti'), (6, 'Eritrea'), (5, 'Estonia'), (7, 'Ethiopia'), (5, 'Finland'), (6, 'France'), (3, 'French Polynesia'), (4, 'Gabon'), (5, 'Gambia'), (6, 'Georgia'), (6, 'Germany'), (6, 'Ghana'), (5, 'Guam'), (5, 'Guatemala'), (7, 'Guinea'), (6, 'Guinea-Bissau'), (3, 'Guyana'), (4, 'Honduras'), (5, 'Hong Kong'), (6, 'Hungary'), (12, 'India'), (9, 'Indonesia'), (10, 'Iran'), (5, 'Iraq'), (3, 'Israel'), (8, 'Italy'), (6, 'Japan'), (3, 'Jordan'), (6, 'Kazakstan'), (10, 'Kenya'), (7, 'Kyrgyzstan'), (4, 'Laos'), (6, 'Latvia'), (3, 'Lebanon'), (3, 'Lesotho'), (8, 'Liberia'), (3, 'Liechtenstein'), (5, 'Lithuania'), (5, 'Luxembourg'), (4, 'Macao'), (5, 'Macedonia'), (4, 'Malawi'), (6, 'Malaysia'), (6, 'Mali'), (6, 'Mauritania'), (6, 'Mauritius'), (3, 'Mayotte'), (6, 'Mexico'), (6, 'Micronesia, Federated States of'), (5, 'Moldova'), (4, 'Monaco'), (6, 'Mongolia'), (10, 'Mozambique'), (8, 'Myanmar'), (8, 'Namibia'), (5, 'Nauru'), (7, 'Nepal'), (4, 'Netherlands'), (3, 'Netherlands Antilles'), (3, 'New Caledonia'), (4, 'Nicaragua'), (5, 'Niger'), (10, 'Nigeria'), (6, 'Northern Mariana Islands'), (5, 'Norway'), (8, 'Pakistan'), (4, 'Palau'), (6, 'Panama'), (4, 'Paraguay'), (3, 'Peru'), (10, 'Philippines'), (4, 'Poland'), (6, 'Romania'), (12, 'Russian Federation'), (5, 'Réunion'), (3, 'Samoa'), (6, 'Senegal'), (3, 'Seychelles'), (8, 'Sierra Leone'), (3, 'Singapore'), (5, 'Slovakia'), (3, 'Slovenia'), (3, 'Solomon Islands'), (11, 'South Africa'), (4, 'Spain'), (3, 'Sri Lanka'), (10, 'Sudan'), (6, 'Sweden'), (4, 'Switzerland'), (6, 'Taiwan'), (3, 'Tajikistan'), (11, 'Tanzania'), (6, 'Thailand'), (8, 'Togo'), (3, 'Trinidad and Tobago'), (3, 'Tunisia'), (3, 'Turkey'), (4, 'Turkmenistan'), (3, 'Tuvalu'), (10, 'Uganda'), (7, 'Ukraine'), (3, 'United Kingdom'), (12, 'United States'), (6, 'Uzbekistan'), (3, 'Vanuatu'), (3, 'Venezuela'), (9, 'Vietnam'), (3, 'Virgin Islands, U.S.'), (6, 'Yugoslavia'), (6, 'Zambia'), (4, 'Zimbabwe')]",,1.0,
What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?,"[country.Population, country.SurfaceArea, country.Continent, country.Code, North America, 3000]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,"SELECT SUM(country.Population) AS total_population, AVG(country.SurfaceArea) AS average_area FROM country WHERE country.Continent = 'North America' AND country.SurfaceArea > 3000;","select sum(population) ,  avg(surfacearea) from country where continent  =  ""north america"" and surfacearea  >  3000",world_1,"1. Sequential Structure: Start with the SELECT clause to specify the required aggregate values, which are the total population and the average area of countries. 2. Condition Structure: Use a WHERE clause to filter for countries in the continent of ""North America"" and with a surface area greater than 3000. 3. Join Structure: No JOIN is required since all necessary data is within the ""country"" table. 4. Aggregation Structure: Use SUM to calculate the total population and AVG to calculate the average surface area of the filtered countries.","[(480753000, 1344763.7222222222)]","[(None, None)]",,0.0,
"Find the number of orchestras whose record format is ""CD"" or ""DVD"".","[orchestra.Major_Record_Format,orchestra.Orchestra_ID,CD,DVD]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT COUNT(orchestra.Orchestra_ID) FROM orchestra WHERE orchestra.Major_Record_Format = 'CD' OR orchestra.Major_Record_Format = 'DVD';,"SELECT COUNT(*) FROM orchestra WHERE Major_Record_Format  =  ""CD"" OR Major_Record_Format  =  ""DVD""",orchestra,"1. Sequential Structure: Start with the SELECT clause to count the number of orchestras whose record format is ""CD"" or ""DVD"". 2. Condition Structure: Use a WHERE clause to filter orchestras where ""orchestra.Major_Record_Format"" is either ""CD"" or ""DVD"". 3. Join Structure: No JOIN is required since all necessary information is in the ""orchestra"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of orchestras that meet the specified condition.","[(11,)]","[(11,)]",,1.0,
What are the country codes for countries that do not speak English?,"[countrylanguage.CountryCode, countrylanguage.Language, country.Code, countrylanguage.CountryCode = country.Code, English]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT DISTINCT CountryCode FROM countrylanguage WHERE Language != 'English';,"SELECT CountryCode FROM countrylanguage EXCEPT SELECT CountryCode FROM countrylanguage WHERE LANGUAGE  =  ""English""",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the country codes. Use the FROM clause to specify the countrylanguage table. Apply a WHERE clause to filter for countries that do not speak English. 2. Condition Structure: Use the WHERE clause to exclude entries where the language is 'English'. This ensures we only retrieve country codes for countries that do not speak English. 3. Join Structure: Not required, as all necessary data is available in the countrylanguage table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.","[('ABW',), ('AFG',), ('AGO',), ('ALB',), ('AND',), ('ANT',), ('ARE',), ('ARG',), ('ARM',), ('ASM',), ('ATG',), ('AUS',), ('AUT',), ('AZE',), ('BDI',), ('BEL',), ('BEN',), ('BFA',), ('BGD',), ('BGR',), ('BHR',), ('BHS',), ('BIH',), ('BLR',), ('BLZ',), ('BOL',), ('BRA',), ('BRB',), ('BRN',), ('BTN',), ('BWA',), ('CAF',), ('CAN',), ('CCK',), ('CHE',), ('CHL',), ('CHN',), ('CIV',), ('CMR',), ('COD',), ('COG',), ('COK',), ('COL',), ('COM',), ('CPV',), ('CRI',), ('CUB',), ('CXR',), ('CYP',), ('CZE',), ('DEU',), ('DJI',), ('DMA',), ('DNK',), ('DOM',), ('DZA',), ('ECU',), ('EGY',), ('ERI',), ('ESH',), ('ESP',), ('EST',), ('ETH',), ('FIN',), ('FJI',), ('FRA',), ('FRO',), ('FSM',), ('GAB',), ('GBR',), ('GEO',), ('GHA',), ('GIB',), ('GIN',), ('GLP',), ('GMB',), ('GNB',), ('GNQ',), ('GRC',), ('GRD',), ('GRL',), ('GTM',), ('GUF',), ('GUM',), ('GUY',), ('HKG',), ('HND',), ('HRV',), ('HTI',), ('HUN',), ('IDN',), ('IND',), ('IRL',), ('IRN',), ('IRQ',), ('ISL',), ('ISR',), ('ITA',), ('JAM',), ('JOR',), ('JPN',), ('KAZ',), ('KEN',), ('KGZ',), ('KHM',), ('KIR',), ('KNA',), ('KOR',), ('KWT',), ('LAO',), ('LBN',), ('LBR',), ('LBY',), ('LCA',), ('LIE',), ('LKA',), ('LSO',), ('LTU',), ('LUX',), ('LVA',), ('MAC',), ('MAR',), ('MCO',), ('MDA',), ('MDG',), ('MDV',), ('MEX',), ('MHL',), ('MKD',), ('MLI',), ('MLT',), ('MMR',), ('MNG',), ('MNP',), ('MOZ',), ('MRT',), ('MTQ',), ('MUS',), ('MWI',), ('MYS',), ('MYT',), ('NAM',), ('NCL',), ('NER',), ('NGA',), ('NIC',), ('NIU',), ('NLD',), ('NOR',), ('NPL',), ('NRU',), ('NZL',), ('OMN',), ('PAK',), ('PAN',), ('PCN',), ('PER',), ('PHL',), ('PLW',), ('PNG',), ('POL',), ('PRI',), ('PRK',), ('PRT',), ('PRY',), ('PSE',), ('PYF',), ('QAT',), ('REU',), ('ROM',), ('RUS',), ('RWA',), ('SAU',), ('SDN',), ('SEN',), ('SGP',), ('SJM',), ('SLB',), ('SLE',), ('SLV',), ('SMR',), ('SOM',), ('SPM',), ('STP',), ('SUR',), ('SVK',), ('SVN',), ('SWE',), ('SWZ',), ('SYC',), ('SYR',), ('TCD',), ('TGO',), ('THA',), ('TJK',), ('TKL',), ('TKM',), ('TMP',), ('TON',), ('TTO',), ('TUN',), ('TUR',), ('TUV',), ('TWN',), ('TZA',), ('UGA',), ('UKR',), ('URY',), ('USA',), ('UZB',), ('VAT',), ('VCT',), ('VEN',), ('VIR',), ('VNM',), ('VUT',), ('WLF',), ('WSM',), ('YEM',), ('YUG',), ('ZAF',), ('ZMB',), ('ZWE',)]","[('AFG',), ('AGO',), ('ALB',), ('AND',), ('ARE',), ('ARG',), ('ARM',), ('AUT',), ('AZE',), ('BDI',), ('BEL',), ('BEN',), ('BFA',), ('BGD',), ('BGR',), ('BHS',), ('BIH',), ('BLR',), ('BOL',), ('BRA',), ('BTN',), ('BWA',), ('CAF',), ('CHE',), ('CHL',), ('CHN',), ('CIV',), ('CMR',), ('COD',), ('COG',), ('COL',), ('COM',), ('CPV',), ('CRI',), ('CUB',), ('CYP',), ('CZE',), ('DEU',), ('DJI',), ('DMA',), ('DOM',), ('DZA',), ('ECU',), ('EGY',), ('ERI',), ('ESH',), ('ESP',), ('EST',), ('ETH',), ('FIN',), ('FJI',), ('FRA',), ('FRO',), ('FSM',), ('GAB',), ('GEO',), ('GHA',), ('GIN',), ('GLP',), ('GMB',), ('GNB',), ('GNQ',), ('GRC',), ('GRD',), ('GRL',), ('GTM',), ('GUF',), ('GUY',), ('HND',), ('HRV',), ('HTI',), ('HUN',), ('IDN',), ('IND',), ('IRN',), ('IRQ',), ('ISR',), ('ITA',), ('JAM',), ('JOR',), ('KAZ',), ('KEN',), ('KGZ',), ('KHM',), ('KIR',), ('KOR',), ('LAO',), ('LBN',), ('LBR',), ('LBY',), ('LIE',), ('LKA',), ('LTU',), ('LUX',), ('LVA',), ('MAR',), ('MDA',), ('MDG',), ('MEX',), ('MKD',), ('MLI',), ('MMR',), ('MNG',), ('MOZ',), ('MRT',), ('MTQ',), ('MUS',), ('MWI',), ('MYT',), ('NAM',), ('NCL',), ('NER',), ('NGA',), ('NIC',), ('NLD',), ('NPL',), ('OMN',), ('PAK',), ('PAN',), ('PCN',), ('PER',), ('PHL',), ('PNG',), ('POL',), ('PRK',), ('PRT',), ('PRY',), ('PSE',), ('PYF',), ('QAT',), ('REU',), ('ROM',), ('RUS',), ('RWA',), ('SAU',), ('SDN',), ('SEN',), ('SGP',), ('SJM',), ('SLB',), ('SLE',), ('SLV',), ('SMR',), ('SOM',), ('SPM',), ('STP',), ('SUR',), ('SVK',), ('SVN',), ('SWE',), ('SWZ',), ('SYR',), ('TCD',), ('TGO',), ('THA',), ('TJK',), ('TKM',), ('TMP',), ('TUN',), ('TUR',), ('TWN',), ('TZA',), ('UGA',), ('UKR',), ('URY',), ('UZB',), ('VAT',), ('VEN',), ('VNM',), ('WLF',), ('YEM',), ('YUG',), ('ZMB',)]",,1.0,
What are the names of conductors who have conducted orchestras founded after the year 2008?,"[conductor.Name,orchestra.Year_of_Founded,orchestra.Conductor_ID = conductor.Conductor_ID,2008]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NON-NESTED,SELECT DISTINCT conductor.Name FROM conductor JOIN orchestra ON orchestra.Conductor_ID = conductor.Conductor_ID WHERE orchestra.Year_of_Founded > 2008;,SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID WHERE Year_of_Founded  >  2008,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""conductor.Name."" 2. Condition Structure: Use a WHERE clause to filter for orchestras that were founded after the year 2008. This condition will be applied to the ""orchestra.Year_of_Founded"" field. 3. Join Structure: Use an INNER JOIN between the ""orchestra"" and ""conductor"" tables based on the foreign key relationship ""orchestra.Conductor_ID = conductor.Conductor_ID"" to link each orchestra with its respective conductor. 4. Aggregation Structure: No aggregation is needed as the query only requires the names of conductors.","[('Igor Stravinsky',)]","[('Igor Stravinsky',)]",,1.0,
Please show the record formats of orchestras in ascending order of count.,[orchestra.Major_Record_Format],"Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,"SELECT orchestra.Major_Record_Format, COUNT(*) AS format_count FROM orchestra GROUP BY orchestra.Major_Record_Format ORDER BY format_count ASC;",SELECT Major_Record_Format FROM orchestra GROUP BY Major_Record_Format ORDER BY COUNT(*) ASC,orchestra,"1. Sequential Structure: Begin with the SELECT clause to specify the ""orchestra.Major_Record_Format"" and the count of each record format. 2. Aggregation Structure: Use COUNT to calculate the number of orchestras for each record format. 3. Grouping Structure: Use GROUP BY on ""orchestra.Major_Record_Format"" to group the results by each record format. 4. Ordering Structure: Use ORDER BY in ascending order on the count to sort the record formats by their frequency. 5. Join Structure: No JOIN is required since all necessary data is within the ""orchestra"" table.","[('CD / LP', 1), ('DVD', 1), ('CD', 10)]","[('CD / LP',), ('DVD',), ('CD',)]",,1.0,
How many friends does the high school student Kyle have?,"[Highschooler.ID, Highschooler.name, Friend.student_id, Friend.friend_id, Friend.student_id = Highschooler.ID, Highschooler.name = 'Kyle']","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT COUNT(Friend.friend_id) FROM Highschooler JOIN Friend ON Highschooler.ID = Friend.student_id WHERE Highschooler.name = 'Kyle';,"SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  ""Kyle""",network_1,"1. Sequential Structure: Start with the SELECT clause to count the number of friends for the student named ""Kyle."" Use COUNT on ""Friend.friend_id"" to determine the number of friends. 2. Condition Structure: Use a WHERE clause to filter for the student whose name is ""Kyle."" This requires joining the ""Highschooler"" table to identify Kyle's ID. 3. Join Structure: Use a JOIN between the ""Highschooler"" table and the ""Friend"" table on ""Highschooler.ID = Friend.student_id"" to associate students with their friends. 4. Aggregation Structure: Use COUNT to aggregate the number of friends for the student named ""Kyle.""","[(1,)]","[(1,)]",,1.0,
Count the number of friends Kyle has.,"[Highschooler.name, Highschooler.ID, Friend.student_id = Highschooler.ID, Friend.friend_id]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT COUNT(Friend.friend_id) FROM Friend JOIN Highschooler ON Friend.student_id = Highschooler.ID WHERE Highschooler.name = 'Kyle';,"SELECT count(*) FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  ""Kyle""",network_1,"1. Sequential Structure: Start with the SELECT clause to count the number of friends Kyle has. Use COUNT on ""Friend.friend_id"" to count the number of friends. 2. Condition Structure: Use a WHERE clause to filter for the student whose name is ""Kyle."" This requires joining the ""Highschooler"" table to get the ID of Kyle. 3. Join Structure: Use a JOIN between the ""Friend"" table and the ""Highschooler"" table on ""Friend.student_id = Highschooler.ID"" to associate each student with their friends. 4. Aggregation Structure: Use COUNT to aggregate the number of friends for Kyle.","[(1,)]","[(1,)]",,1.0,
What are the ids of students who both have friends and are liked?,"[Friend.student_id, Friend.friend_id, Likes.student_id, Likes.liked_id, Friend.student_id = Likes.student_id]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NESTED,SELECT DISTINCT Friend.student_id FROM Friend JOIN Likes ON Friend.student_id = Likes.student_id;,SELECT student_id FROM Friend INTERSECT SELECT liked_id FROM Likes,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of students. Use the FROM clause to specify the Friend and Likes tables. Apply a WHERE clause to filter for students who both have friends and are liked. 2. Condition Structure: Use the WHERE clause to ensure that the student_id exists in both the Friend and Likes tables, indicating that the student has friends and is liked. 3. Join Structure: Not required, as the filtering can be done using the WHERE clause with conditions on the same student_id in both tables. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.","[(1247,), (1316,), (1501,), (1689,), (1709,), (1782,), (1911,), (1934,)]","[(1101,), (1247,), (1304,), (1468,), (1501,), (1689,), (1709,), (1934,)]",,1.0,
List the names of orchestras that have no performance.,"[orchestra.Orchestra,performance.Orchestra_ID,orchestra.Orchestra_ID = performance.Orchestra_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NESTED,SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance);,SELECT Orchestra FROM orchestra WHERE Orchestra_ID NOT IN (SELECT Orchestra_ID FROM performance),orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of orchestras. Use the FROM clause to specify the orchestra table. Apply a WHERE clause to filter orchestras that have no performance by ensuring their Orchestra_ID is not present in the performance table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude orchestras whose Orchestra_ID appears in the performance table, meaning they have performances. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Orchestra_ID entries in the performance table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('San Francisco Symphony Orchestra',)]","[('San Francisco Symphony Orchestra',)]",,1.0,
List the name of the conductor with the most years of work.,"[conductor.Name, conductor.Year_of_Work]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT conductor.Name FROM conductor ORDER BY conductor.Year_of_Work DESC LIMIT 1;,SELECT Name FROM conductor ORDER BY Year_of_Work DESC LIMIT 1,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""conductor.Name"" of the conductor with the most years of work. 2. Condition Structure: No specific filtering condition is needed since we are looking for the conductor with the maximum years of work. 3. Join Structure: No JOIN is required as all the necessary information is in the ""conductor"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""conductor.Year_of_Work"" to rank conductors by their years of work and apply LIMIT 1 to select the conductor with the most years of work.","[('Robert Craft',)]","[('Robert Craft',)]",,1.0,
How many high schoolers are in each grade?,[Highschooler.grade],"Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,"SELECT Highschooler.grade, COUNT(*) AS highschooler_count FROM Highschooler GROUP BY Highschooler.grade;","SELECT grade ,  count(*) FROM Highschooler GROUP BY grade",network_1,"1. Sequential Structure: Begin with the SELECT clause to specify the grade and the count of high schoolers in each grade. 2. Aggregation Structure: Use COUNT to calculate the number of high schoolers in each grade. 3. Grouping Structure: Use GROUP BY on ""Highschooler.grade"" to group the results by each grade. 4. Join Structure: No JOIN is required since all necessary data is within the ""Highschooler"" table.","[(9, 4), (10, 4), (11, 4), (12, 4)]","[(9, 4), (10, 4), (11, 4), (12, 4)]",,1.0,
Show me all grades that have at least 4 students.,"[Highschooler.grade, Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,SELECT Highschooler.grade FROM Highschooler GROUP BY Highschooler.grade HAVING COUNT(Highschooler.ID) >= 4;,SELECT grade FROM Highschooler GROUP BY grade HAVING count(*)  >=  4,network_1,"1. Sequential Structure: Begin with the SELECT clause to specify the grade, as the question asks for grades with at least 4 students. 2. Aggregation Structure: Use COUNT to calculate the number of students in each grade. 3. Grouping Structure: Use GROUP BY on ""Highschooler.grade"" to group students by their grade. 4. Condition Structure: Apply the HAVING clause to filter grades where the count of students is at least 4. 5. Join Structure: No JOIN is required since all necessary data is within the ""Highschooler"" table.","[(9,), (10,), (11,), (12,)]","[(9,), (10,), (11,), (12,)]",,1.0,
"What are the different continents and the total popuation and average life expectancy corresponding to each, for continents that have an average life expectancy less than 72?","[country.Continent, country.Population, country.LifeExpectancy]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT Continent, SUM(Population) AS total_population, AVG(LifeExpectancy) AS average_life_expectancy FROM country GROUP BY Continent HAVING AVG(LifeExpectancy) < 72;","SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the continent, total population, and average life expectancy. Use the FROM clause to specify the country table. Apply a GROUP BY clause to group data by continent. Use the HAVING clause to filter for continents with an average life expectancy less than 72. 2. Condition Structure: Use the HAVING clause to filter groups where the average life expectancy is less than 72. 3. Join Structure: Not required, as all data is available within the country table. 4. Aggregation Structure: Use SUM to calculate the total population and AVG to calculate the average life expectancy for each continent.","[('Africa', 784475000, 52.5719298245614), ('Asia', 3705025700, 67.44117647058823), ('Oceania', 30401150, 69.715), ('South America', 345780000, 70.94615384615385)]","[(784475000, 52.5719298245614, 'Africa'), (3705025700, 67.44117647058823, 'Asia'), (30401150, 69.715, 'Oceania'), (345780000, 70.94615384615385, 'South America')]",,1.0,
What are the names of cities in Europe for which English is not the official language?,"[city.Name, city.CountryCode = country.Code, country.Continent, countrylanguage.CountryCode = country.Code, countrylanguage.Language, countrylanguage.IsOfficial, Europe, English, 0]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,SELECT city.Name FROM city JOIN country ON city.CountryCode = country.Code JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE country.Continent = 'Europe' AND countrylanguage.Language = 'English' AND countrylanguage.IsOfficial = 0;,SELECT DISTINCT T2.Name FROM country AS T1 JOIN city AS T2 ON T2.CountryCode  =  T1.Code WHERE T1.Continent  =  'Europe' AND T1.Name NOT IN (SELECT T3.Name FROM country AS T3 JOIN countrylanguage AS T4 ON T3.Code  =  T4.CountryCode WHERE T4.IsOfficial  =  'T' AND T4.Language  =  'English'),world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of cities. Use the FROM clause to specify the city table. Join it with the country table to filter cities located in Europe. Further, join it with the countrylanguage table to check the language details. Apply a WHERE clause to filter for cities in Europe where English is not the official language. 2. Condition Structure: Use the WHERE clause to filter for countries in the continent 'Europe' and where the language is 'English' and it is not the official language (IsOfficial = 0). 3. Join Structure: Use INNER JOINs between the city, country, and countrylanguage tables. The city table is joined with the country table on CountryCode = Code, and the country table is joined with the countrylanguage table on CountryCode = Code. 4. Aggregation Structure: Not required, as we are retrieving specific records without any aggregation.",[],"[('Amsterdam',), ('Rotterdam',), ('Haag',), ('Utrecht',), ('Eindhoven',), ('Tilburg',), ('Groningen',), ('Breda',), ('Apeldoorn',), ('Nijmegen',), ('Enschede',), ('Haarlem',), ('Almere',), ('Arnhem',), ('Zaanstad',), ('´s-Hertogenbosch',), ('Amersfoort',), ('Maastricht',), ('Dordrecht',), ('Leiden',), ('Haarlemmermeer',), ('Zoetermeer',), ('Emmen',), ('Zwolle',), ('Ede',), ('Delft',), ('Heerlen',), ('Alkmaar',), ('Tirana',), ('Andorra la Vella',), ('Antwerpen',), ('Gent',), ('Charleroi',), ('Liège',), ('Bruxelles [Brussel]',), ('Brugge',), ('Schaerbeek',), ('Namur',), ('Mons',), ('Sarajevo',), ('Banja Luka',), ('Zenica',), ('Sofija',), ('Plovdiv',), ('Varna',), ('Burgas',), ('Ruse',), ('Stara Zagora',), ('Pleven',), ('Sliven',), ('Dobric',), ('Šumen',), ('Madrid',), ('Barcelona',), ('Valencia',), ('Sevilla',), ('Zaragoza',), ('Málaga',), ('Bilbao',), ('Las Palmas de Gran Canaria',), ('Murcia',), ('Palma de Mallorca',), ('Valladolid',), ('Córdoba',), ('Vigo',), ('Alicante [Alacant]',), ('Gijón',), ('L´Hospitalet de Llobregat',), ('Granada',), ('A Coruña (La Coruña)',), ('Vitoria-Gasteiz',), ('Santa Cruz de Tenerife',), ('Badalona',), ('Oviedo',), ('Móstoles',), ('Elche [Elx]',), ('Sabadell',), ('Santander',), ('Jerez de la Frontera',), ('Pamplona [Iruña]',), ('Donostia-San Sebastián',), ('Cartagena',), ('Leganés',), ('Fuenlabrada',), ('Almería',), ('Terrassa',), ('Alcalá de Henares',), ('Burgos',), ('Salamanca',), ('Albacete',), ('Getafe',), ('Cádiz',), ('Alcorcón',), ('Huelva',), ('León',), ('Castellón de la Plana [Castell',), ('Badajoz',), ('[San Cristóbal de] la Laguna',), ('Logroño',), ('Santa Coloma de Gramenet',), ('Tarragona',), ('Lleida (Lérida)',), ('Jaén',), ('Ourense (Orense)',), ('Mataró',), ('Algeciras',), ('Marbella',), ('Barakaldo',), ('Dos Hermanas',), ('Santiago de Compostela',), ('Torrejón de Ardoz',), ('Tórshavn',), ('Longyearbyen',), ('Reykjavík',), ('Roma',), ('Milano',), ('Napoli',), ('Torino',), ('Palermo',), ('Genova',), ('Bologna',), ('Firenze',), ('Catania',), ('Bari',), ('Venezia',), ('Messina',), ('Verona',), ('Trieste',), ('Padova',), ('Taranto',), ('Brescia',), ('Reggio di Calabria',), ('Modena',), ('Prato',), ('Parma',), ('Cagliari',), ('Livorno',), ('Perugia',), ('Foggia',), ('Reggio nell´ Emilia',), ('Salerno',), ('Ravenna',), ('Ferrara',), ('Rimini',), ('Syrakusa',), ('Sassari',), ('Monza',), ('Bergamo',), ('Pescara',), ('Latina',), ('Vicenza',), ('Terni',), ('Forlì',), ('Trento',), ('Novara',), ('Piacenza',), ('Ancona',), ('Lecce',), ('Bolzano',), ('Catanzaro',), ('La Spezia',), ('Udine',), ('Torre del Greco',), ('Andria',), ('Brindisi',), ('Giugliano in Campania',), ('Pisa',), ('Barletta',), ('Arezzo',), ('Alessandria',), ('Cesena',), ('Pesaro',), ('Wien',), ('Graz',), ('Linz',), ('Salzburg',), ('Innsbruck',), ('Klagenfurt',), ('Beograd',), ('Novi Sad',), ('Niš',), ('Priština',), ('Kragujevac',), ('Podgorica',), ('Subotica',), ('Prizren',), ('Athenai',), ('Thessaloniki',), ('Pireus',), ('Patras',), ('Peristerion',), ('Herakleion',), ('Kallithea',), ('Larisa',), ('Zagreb',), ('Split',), ('Rijeka',), ('Osijek',), ('Riga',), ('Daugavpils',), ('Liepaja',), ('Schaan',), ('Vaduz',), ('Vilnius',), ('Kaunas',), ('Klaipeda',), ('Šiauliai',), ('Panevezys',), ('Luxembourg [Luxemburg/Lëtzebuerg]',), ('Skopje',), ('Chisinau',), ('Tiraspol',), ('Balti',), ('Bender (Tîghina)',), ('Monte-Carlo',), ('Monaco-Ville',), ('Oslo',), ('Bergen',), ('Trondheim',), ('Stavanger',), ('Bærum',), ('Lisboa',), ('Porto',), ('Amadora',), ('Coímbra',), ('Braga',), ('Warszawa',), ('Lódz',), ('Kraków',), ('Wroclaw',), ('Poznan',), ('Gdansk',), ('Szczecin',), ('Bydgoszcz',), ('Lublin',), ('Katowice',), ('Bialystok',), ('Czestochowa',), ('Gdynia',), ('Sosnowiec',), ('Radom',), ('Kielce',), ('Gliwice',), ('Torun',), ('Bytom',), ('Zabrze',), ('Bielsko-Biala',), ('Olsztyn',), ('Rzeszów',), ('Ruda Slaska',), ('Rybnik',), ('Walbrzych',), ('Tychy',), ('Dabrowa Górnicza',), ('Plock',), ('Elblag',), ('Opole',), ('Gorzów Wielkopolski',), ('Wloclawek',), ('Chorzów',), ('Tarnów',), ('Zielona Góra',), ('Koszalin',), ('Legnica',), ('Kalisz',), ('Grudziadz',), ('Slupsk',), ('Jastrzebie-Zdrój',), ('Jaworzno',), ('Jelenia Góra',), ('Paris',), ('Marseille',), ('Lyon',), ('Toulouse',), ('Nice',), ('Nantes',), ('Strasbourg',), ('Montpellier',), ('Bordeaux',), ('Rennes',), ('Le Havre',), ('Reims',), ('Lille',), ('St-Étienne',), ('Toulon',), ('Grenoble',), ('Angers',), ('Dijon',), ('Brest',), ('Le Mans',), ('Clermont-Ferrand',), ('Amiens',), ('Aix-en-Provence',), ('Limoges',), ('Nîmes',), ('Tours',), ('Villeurbanne',), ('Metz',), ('Besançon',), ('Caen',), ('Orléans',), ('Mulhouse',), ('Rouen',), ('Boulogne-Billancourt',), ('Perpignan',), ('Nancy',), ('Roubaix',), ('Argenteuil',), ('Tourcoing',), ('Montreuil',), ('Bucuresti',), ('Iasi',), ('Constanta',), ('Cluj-Napoca',), ('Galati',), ('Timisoara',), ('Brasov',), ('Craiova',), ('Ploiesti',), ('Braila',), ('Oradea',), ('Bacau',), ('Pitesti',), ('Arad',), ('Sibiu',), ('Târgu Mures',), ('Baia Mare',), ('Buzau',), ('Satu Mare',), ('Botosani',), ('Piatra Neamt',), ('Râmnicu Vâlcea',), ('Suceava',), ('Drobeta-Turnu Severin',), ('Târgoviste',), ('Focsani',), ('Târgu Jiu',), ('Tulcea',), ('Resita',), ('Stockholm',), ('Gothenburg [Göteborg]',), ('Malmö',), ('Uppsala',), ('Linköping',), ('Västerås',), ('Örebro',), ('Norrköping',), ('Helsingborg',), ('Jönköping',), ('Umeå',), ('Lund',), ('Borås',), ('Sundsvall',), ('Gävle',), ('Berlin',), ('Hamburg',), ('Munich [München]',), ('Köln',), ('Frankfurt am Main',), ('Essen',), ('Dortmund',), ('Stuttgart',), ('Düsseldorf',), ('Bremen',), ('Duisburg',), ('Hannover',), ('Leipzig',), ('Nürnberg',), ('Dresden',), ('Bochum',), ('Wuppertal',), ('Bielefeld',), ('Mannheim',), ('Bonn',), ('Gelsenkirchen',), ('Karlsruhe',), ('Wiesbaden',), ('Münster',), ('Mönchengladbach',), ('Chemnitz',), ('Augsburg',), ('Halle/Saale',), ('Braunschweig',), ('Aachen',), ('Krefeld',), ('Magdeburg',), ('Kiel',), ('Oberhausen',), ('Lübeck',), ('Hagen',), ('Rostock',), ('Freiburg im Breisgau',), ('Erfurt',), ('Kassel',), ('Saarbrücken',), ('Mainz',), ('Hamm',), ('Herne',), ('Mülheim an der Ruhr',), ('Solingen',), ('Osnabrück',), ('Ludwigshafen am Rhein',), ('Leverkusen',), ('Oldenburg',), ('Neuss',), ('Heidelberg',), ('Darmstadt',), ('Paderborn',), ('Potsdam',), ('Würzburg',), ('Regensburg',), ('Recklinghausen',), ('Göttingen',), ('Bremerhaven',), ('Wolfsburg',), ('Bottrop',), ('Remscheid',), ('Heilbronn',), ('Pforzheim',), ('Offenbach am Main',), ('Ulm',), ('Ingolstadt',), ('Gera',), ('Salzgitter',), ('Cottbus',), ('Reutlingen',), ('Fürth',), ('Siegen',), ('Koblenz',), ('Moers',), ('Bergisch Gladbach',), ('Zwickau',), ('Hildesheim',), ('Witten',), ('Schwerin',), ('Erlangen',), ('Kaiserslautern',), ('Trier',), ('Jena',), ('Iserlohn',), ('Gütersloh',), ('Marl',), ('Lünen',), ('Düren',), ('Ratingen',), ('Velbert',), ('Esslingen am Neckar',), ('Serravalle',), ('San Marino',), ('Bratislava',), ('Košice',), ('Prešov',), ('Ljubljana',), ('Maribor',), ('Helsinki [Helsingfors]',), ('Espoo',), ('Tampere',), ('Vantaa',), ('Turku [Åbo]',), ('Oulu',), ('Lahti',), ('Zürich',), ('Geneve',), ('Basel',), ('Bern',), ('Lausanne',), ('København',), ('Århus',), ('Odense',), ('Aalborg',), ('Frederiksberg',), ('Praha',), ('Brno',), ('Ostrava',), ('Plzen',), ('Olomouc',), ('Liberec',), ('Ceské Budejovice',), ('Hradec Králové',), ('Ústí nad Labem',), ('Pardubice',), ('Kyiv',), ('Harkova [Harkiv]',), ('Dnipropetrovsk',), ('Donetsk',), ('Odesa',), ('Zaporizzja',), ('Lviv',), ('Kryvyi Rig',), ('Mykolajiv',), ('Mariupol',), ('Lugansk',), ('Vinnytsja',), ('Makijivka',), ('Herson',), ('Sevastopol',), ('Simferopol',), ('Pultava [Poltava]',), ('Tšernigiv',), ('Tšerkasy',), ('Gorlivka',), ('Zytomyr',), ('Sumy',), ('Dniprodzerzynsk',), ('Kirovograd',), ('Hmelnytskyi',), ('Tšernivtsi',), ('Rivne',), ('Krementšuk',), ('Ivano-Frankivsk',), ('Ternopil',), ('Lutsk',), ('Bila Tserkva',), ('Kramatorsk',), ('Melitopol',), ('Kertš',), ('Nikopol',), ('Berdjansk',), ('Pavlograd',), ('Sjeverodonetsk',), ('Slovjansk',), ('Uzgorod',), ('Altševsk',), ('Lysytšansk',), ('Jevpatorija',), ('Kamjanets-Podilskyi',), ('Jenakijeve',), ('Krasnyi Lutš',), ('Stahanov',), ('Oleksandrija',), ('Konotop',), ('Kostjantynivka',), ('Berdytšiv',), ('Izmajil',), ('Šostka',), ('Uman',), ('Brovary',), ('Mukatševe',), ('Budapest',), ('Debrecen',), ('Miskolc',), ('Szeged',), ('Pécs',), ('Györ',), ('Nyiregyháza',), ('Kecskemét',), ('Székesfehérvár',), ('Minsk',), ('Gomel',), ('Mogiljov',), ('Vitebsk',), ('Grodno',), ('Bobruisk',), ('Baranovitši',), ('Borisov',), ('Pinsk',), ('Orša',), ('Mozyr',), ('Novopolotsk',), ('Lida',), ('Soligorsk',), ('Molodetšno',), ('Città del Vaticano',), ('Moscow',), ('St Petersburg',), ('Novosibirsk',), ('Nizni Novgorod',), ('Jekaterinburg',), ('Samara',), ('Omsk',), ('Kazan',), ('Ufa',), ('Tšeljabinsk',), ('Rostov-na-Donu',), ('Perm',), ('Volgograd',), ('Voronez',), ('Krasnojarsk',), ('Saratov',), ('Toljatti',), ('Uljanovsk',), ('Izevsk',), ('Krasnodar',), ('Jaroslavl',), ('Habarovsk',), ('Vladivostok',), ('Irkutsk',), ('Barnaul',), ('Novokuznetsk',), ('Penza',), ('Rjazan',), ('Orenburg',), ('Lipetsk',), ('Nabereznyje Tšelny',), ('Tula',), ('Tjumen',), ('Kemerovo',), ('Astrahan',), ('Tomsk',), ('Kirov',), ('Ivanovo',), ('Tšeboksary',), ('Brjansk',), ('Tver',), ('Kursk',), ('Magnitogorsk',), ('Kaliningrad',), ('Nizni Tagil',), ('Murmansk',), ('Ulan-Ude',), ('Kurgan',), ('Arkangeli',), ('Sotši',), ('Smolensk',), ('Orjol',), ('Stavropol',), ('Belgorod',), ('Kaluga',), ('Vladimir',), ('Mahatškala',), ('Tšerepovets',), ('Saransk',), ('Tambov',), ('Vladikavkaz',), ('Tšita',), ('Vologda',), ('Veliki Novgorod',), ('Komsomolsk-na-Amure',), ('Kostroma',), ('Volzski',), ('Taganrog',), ('Petroskoi',), ('Bratsk',), ('Dzerzinsk',), ('Surgut',), ('Orsk',), ('Sterlitamak',), ('Angarsk',), ('Joškar-Ola',), ('Rybinsk',), ('Prokopjevsk',), ('Niznevartovsk',), ('Naltšik',), ('Syktyvkar',), ('Severodvinsk',), ('Bijsk',), ('Niznekamsk',), ('Blagoveštšensk',), ('Šahty',), ('Staryi Oskol',), ('Zelenograd',), ('Balakovo',), ('Novorossijsk',), ('Pihkova',), ('Zlatoust',), ('Jakutsk',), ('Podolsk',), ('Petropavlovsk-Kamtšatski',), ('Kamensk-Uralski',), ('Engels',), ('Syzran',), ('Grozny',), ('Novotšerkassk',), ('Berezniki',), ('Juzno-Sahalinsk',), ('Volgodonsk',), ('Abakan',), ('Maikop',), ('Miass',), ('Armavir',), ('Ljubertsy',), ('Rubtsovsk',), ('Kovrov',), ('Nahodka',), ('Ussurijsk',), ('Salavat',), ('Mytištši',), ('Kolomna',), ('Elektrostal',), ('Murom',), ('Kolpino',), ('Norilsk',), ('Almetjevsk',), ('Novomoskovsk',), ('Dimitrovgrad',), ('Pervouralsk',), ('Himki',), ('Balašiha',), ('Nevinnomyssk',), ('Pjatigorsk',), ('Korolev',), ('Serpuhov',), ('Odintsovo',), ('Orehovo-Zujevo',), ('Kamyšin',), ('Novotšeboksarsk',), ('Tšerkessk',), ('Atšinsk',), ('Magadan',), ('Mitšurinsk',), ('Kislovodsk',), ('Jelets',), ('Seversk',), ('Noginsk',), ('Velikije Luki',), ('Novokuibyševsk',), ('Neftekamsk',), ('Leninsk-Kuznetski',), ('Oktjabrski',), ('Sergijev Posad',), ('Arzamas',), ('Kiseljovsk',), ('Novotroitsk',), ('Obninsk',), ('Kansk',), ('Glazov',), ('Solikamsk',), ('Sarapul',), ('Ust-Ilimsk',), ('Štšolkovo',), ('Mezduretšensk',), ('Usolje-Sibirskoje',), ('Elista',), ('Novošahtinsk',), ('Votkinsk',), ('Kyzyl',), ('Serov',), ('Zelenodolsk',), ('Zeleznodoroznyi',), ('Kinešma',), ('Kuznetsk',), ('Uhta',), ('Jessentuki',), ('Tobolsk',), ('Neftejugansk',), ('Bataisk',), ('Nojabrsk',), ('Balašov',), ('Zeleznogorsk',), ('Zukovski',), ('Anzero-Sudzensk',), ('Bugulma',), ('Novouralsk',), ('Puškin',), ('Vorkuta',), ('Derbent',), ('Kirovo-Tšepetsk',), ('Krasnogorsk',), ('Klin',), ('Tšaikovski',), ('Novyi Urengoi',), ('Tallinn',), ('Tartu',)]",,0.0,
"Return the maximum and minimum shares for performances that do not have the type ""Live final"".","[performance.Share, performance.Type]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NESTED,"SELECT MAX(Share) AS max_share, MIN(Share) AS min_share FROM performance WHERE Type != 'Live final';","SELECT max(SHARE) ,  min(SHARE) FROM performance WHERE TYPE != ""Live final""",orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the maximum and minimum shares. Use the FROM clause to specify the performance table. Apply a WHERE clause to filter out performances with the type ""Live final"". 2. Condition Structure: Use the WHERE clause to exclude performances where the type is ""Live final"". 3. Join Structure: Not required, as all the necessary data is in the performance table. 4. Aggregation Structure: Use the MAX and MIN aggregate functions to calculate the maximum and minimum shares for the filtered performances.","[('44.7%', '22.7%')]","[('44.7%', '22.7%')]",,1.0,
Show all the grades of the high schoolers.,[Highschooler.grade],"Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,SELECT Highschooler.grade FROM Highschooler;,SELECT grade FROM Highschooler,network_1,"1. Sequential Structure: Start with the SELECT clause to specify the field needed, which is ""Highschooler.grade"". 2. Condition Structure: No specific filtering condition is required as we want to retrieve all grades. 3. Join Structure: No JOIN is necessary since the required information is available within the ""Highschooler"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving all grades.","[(9,), (9,), (9,), (9,), (10,), (10,), (10,), (10,), (11,), (11,), (11,), (11,), (12,), (12,), (12,), (12,)]","[(9,), (9,), (9,), (9,), (10,), (10,), (10,), (10,), (11,), (11,), (11,), (11,), (12,), (12,), (12,), (12,)]",,1.0,
Return the codes of countries for which Spanish is the predominantly spoken language.,"[country.Code, countrylanguage.Language, countrylanguage.Percentage, countrylanguage.CountryCode = country.Code, Spanish]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,SELECT country.Code FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.Language = 'Spanish' AND countrylanguage.Percentage = ( SELECT MAX(cl.Percentage) FROM countrylanguage AS cl WHERE cl.CountryCode = countrylanguage.CountryCode );,"SELECT CountryCode ,  max(Percentage) FROM countrylanguage WHERE LANGUAGE  =  ""Spanish"" GROUP BY CountryCode",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""country.Code"" for countries where Spanish is the predominantly spoken language. Predominantly spoken implies the highest percentage for the language in that country. 2. Condition Structure: Use a WHERE clause to filter for records where ""countrylanguage.Language"" is 'Spanish'. 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables on ""country.Code = countrylanguage.CountryCode"" to link countries with their languages. 4. Aggregation Structure: Use a subquery to ensure that Spanish has the highest percentage for the country. Compare the percentage of Spanish to the maximum percentage of any language for that country.","[('AND',), ('ARG',), ('BOL',), ('CHL',), ('COL',), ('CRI',), ('CUB',), ('DOM',), ('ECU',), ('ESP',), ('GTM',), ('HND',), ('MEX',), ('NIC',), ('PAN',), ('PER',), ('PRI',), ('PRY',), ('SLV',), ('URY',), ('VEN',)]","[('ABW', 7.4), ('AND', 44.6), ('ARG', 96.8), ('BLZ', 31.6), ('BOL', 87.7), ('CAN', 0.7), ('CHL', 89.7), ('COL', 99.0), ('CRI', 97.5), ('CUB', 100.0), ('DOM', 98.0), ('ECU', 93.0), ('ESP', 74.4), ('FRA', 0.4), ('GTM', 64.7), ('HND', 97.2), ('MEX', 92.1), ('NIC', 97.6), ('PAN', 76.8), ('PER', 79.8), ('PRI', 51.3), ('PRY', 55.1), ('SLV', 100.0), ('SWE', 0.6), ('URY', 95.7), ('USA', 7.5), ('VEN', 96.9), ('VIR', 13.3)]",,0.0,
Show the names of high schoolers who have at least 3 friends.,"[Highschooler.name, Friend.student_id, Friend.friend_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT Highschooler.name FROM Friend JOIN Highschooler ON Friend.student_id = Highschooler.ID GROUP BY Friend.student_id HAVING COUNT(Friend.friend_id) >= 3;,SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  3,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of high schoolers. Use a GROUP BY clause to group by ""Friend.student_id"" to count the number of friends each student has. Apply a HAVING clause to filter students with at least 3 friends. 2. Condition Structure: Use a HAVING clause to filter groups where the count of ""Friend.friend_id"" is greater than or equal to 3. 3. Join Structure: Use an INNER JOIN between the ""Friend"" table and the ""Highschooler"" table on ""Friend.student_id = Highschooler.ID"" to associate each student with their name. 4. Aggregation Structure: Use COUNT on ""Friend.friend_id"" to count the number of friends for each student.","[('Andrew',)]","[('Andrew',)]",,1.0,
What are the names of the nations with the 3 lowest populations?,"[country.Name, country.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT country.Name FROM country ORDER BY country.Population ASC LIMIT 3;,SELECT Name FROM country ORDER BY Population ASC LIMIT 3,world_1,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the name of the nation (""country.Name""). 2. Condition Structure: No specific filtering condition is required since we are looking for the nations with the lowest populations. 3. Join Structure: No JOIN is required since all necessary data is within the ""country"" table. 4. Aggregation Structure: Use ORDER BY in ascending order on ""country.Population"" to rank nations by their population. Use LIMIT 3 to retrieve the names of the 3 nations with the lowest populations.","[('Antarctica',), ('French Southern territories',), ('Bouvet Island',)]","[('Antarctica',), ('French Southern territories',), ('Bouvet Island',)]",,1.0,
What are years of founding for orchestras that have had more than a single performance?,"[orchestra.Year_of_Founded,performance.Orchestra_ID,orchestra.Orchestra_ID = performance.Orchestra_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NON-NESTED,SELECT orchestra.Year_of_Founded FROM orchestra JOIN performance ON orchestra.Orchestra_ID = performance.Orchestra_ID GROUP BY orchestra.Orchestra_ID HAVING COUNT(performance.Orchestra_ID) > 1;,SELECT Year_of_Founded FROM orchestra AS T1 JOIN performance AS T2 ON T1.Orchestra_ID  =  T2.Orchestra_ID GROUP BY T2.Orchestra_ID HAVING COUNT(*)  >  1,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""orchestra.Year_of_Founded."" 2. Condition Structure: Use a HAVING clause to filter orchestras that have had more than one performance. This requires counting the number of performances for each orchestra. 3. Join Structure: Use a JOIN between the ""orchestra"" and ""performance"" tables based on ""orchestra.Orchestra_ID = performance.Orchestra_ID"" to link each orchestra with its performances. 4. Aggregation Structure: Use COUNT on ""performance.Orchestra_ID"" to count the number of performances for each orchestra, then filter with HAVING to select orchestras with more than one performance.",[],[],,1.0,
Count the number of countries in Asia.,"[country.Name, country.Continent]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",EASY,SELECT COUNT(country.Name) AS country_count FROM country WHERE country.Continent = 'Asia';,"SELECT count(*) FROM country WHERE continent  =  ""Asia""",world_1,"1. Sequential Structure: Start with the SELECT clause to count the number of countries. 2. Condition Structure: Use a WHERE clause to filter for countries in the ""Asia"" continent. 3. Join Structure: No JOIN is required since all necessary information is in the ""country"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of countries in Asia.","[(51,)]","[(51,)]",,1.0,
List names of conductors in descending order of years of work.,"[conductor.Name, conductor.Year_of_Work]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT conductor.Name FROM conductor ORDER BY conductor.Year_of_Work DESC;,SELECT Name FROM conductor ORDER BY Year_of_Work DESC,orchestra,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""Name"" of the conductors. Additionally, include ""Year_of_Work"" for sorting purposes. 2. Condition Structure: No specific filtering condition is required as we want all conductors. 3. Join Structure: No JOIN is required since all necessary data is within the ""conductor"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in descending order based on ""Year_of_Work"".","[('Robert Craft',), ('Antal Brown',), ('Gerard Schwarz',), ('Valeri Gergiev',), ('Charles Dutoit',), ('Michael Tilson Thomas',), ('Igor Stravinsky',), ('Paul Jorgensen',), ('Pierre Boulez',), ('Antal Doráti',), ('Seiji Ozawa',), ('Colin Davis',)]","[('Robert Craft',), ('Antal Brown',), ('Gerard Schwarz',), ('Valeri Gergiev',), ('Charles Dutoit',), ('Michael Tilson Thomas',), ('Igor Stravinsky',), ('Paul Jorgensen',), ('Pierre Boulez',), ('Antal Doráti',), ('Seiji Ozawa',), ('Colin Davis',)]",,1.0,
How many orchestras does each record company manage?,"[orchestra.Record_Company, orchestra.Orchestra_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,"SELECT orchestra.Record_Company, COUNT(orchestra.Orchestra_ID) AS orchestra_count FROM orchestra GROUP BY orchestra.Record_Company;","SELECT Record_Company ,  COUNT(*) FROM orchestra GROUP BY Record_Company",orchestra,"1. Sequential Structure: Start with the SELECT clause to specify the record company and the count of orchestras it manages. 2. Aggregation Structure: Use COUNT to calculate the number of orchestras managed by each record company. 3. Grouping Structure: Use GROUP BY on ""orchestra.Record_Company"" to group the results by each record company. 4. Join Structure: No JOIN is required since all necessary data is within the ""orchestra"" table.","[('Columbia Masterworks', 1), ('Decca Records', 2), ('Delos Records', 1), ('Deutsche Grammophon', 1), ('EMI', 1), ('Koch Records / Naxos Records', 1), ('Kultur', 1), ('Mercury Records', 1), ('Philips', 1), ('Philips Classics Records', 1), ('RCA', 1)]","[('Columbia Masterworks', 1), ('Decca Records', 2), ('Delos Records', 1), ('Deutsche Grammophon', 1), ('EMI', 1), ('Koch Records / Naxos Records', 1), ('Kultur', 1), ('Mercury Records', 1), ('Philips', 1), ('Philips Classics Records', 1), ('RCA', 1)]",,1.0,
"What are the country codes of the different countries, and what are the languages spoken by the greatest percentage of people for each?","[country.Code, countrylanguage.Language, countrylanguage.Percentage, countrylanguage.CountryCode = country.Code]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NON-NESTED,"SELECT country.Code, countrylanguage.Language FROM country JOIN countrylanguage ON country.Code = countrylanguage.CountryCode WHERE countrylanguage.Percentage = ( SELECT MAX(cl.Percentage) FROM countrylanguage AS cl WHERE cl.CountryCode = country.Code );","SELECT LANGUAGE ,  CountryCode ,  max(Percentage) FROM countrylanguage GROUP BY CountryCode",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve ""country.Code"" and ""countrylanguage.Language."" Since we need the language spoken by the greatest percentage of people for each country, we will use an aggregate function (MAX) on ""countrylanguage.Percentage."" 2. Condition Structure: No specific filtering condition is required, as we are interested in all countries and their most spoken languages. 3. Join Structure: Use an INNER JOIN between the ""country"" and ""countrylanguage"" tables on ""country.Code"" and ""countrylanguage.CountryCode"" to link each country with its languages. 4. Aggregation Structure: Use MAX on ""countrylanguage.Percentage"" to find the language spoken by the greatest percentage of people for each country. Use GROUP BY on ""country.Code"" to group the results by country.","[('ABW', 'Papiamento'), ('AFG', 'Pashto'), ('AGO', 'Ovimbundu'), ('AIA', 'English'), ('ALB', 'Albaniana'), ('AND', 'Spanish'), ('ANT', 'Papiamento'), ('ARE', 'Arabic'), ('ARG', 'Spanish'), ('ARM', 'Armenian'), ('ASM', 'Samoan'), ('ATG', 'Creole English'), ('AUS', 'English'), ('AUT', 'German'), ('AZE', 'Azerbaijani'), ('BDI', 'Kirundi'), ('BEL', 'Dutch'), ('BEN', 'Fon'), ('BFA', 'Mossi'), ('BGD', 'Bengali'), ('BGR', 'Bulgariana'), ('BHR', 'Arabic'), ('BHS', 'Creole English'), ('BIH', 'Serbo-Croatian'), ('BLR', 'Belorussian'), ('BLZ', 'English'), ('BMU', 'English'), ('BOL', 'Spanish'), ('BRA', 'Portuguese'), ('BRB', 'Bajan'), ('BRN', 'Malay'), ('BTN', 'Dzongkha'), ('BWA', 'Tswana'), ('CAF', 'Gbaya'), ('CAN', 'English'), ('CCK', 'English'), ('CCK', 'Malay'), ('CHE', 'German'), ('CHL', 'Spanish'), ('CHN', 'Chinese'), ('CIV', 'Akan'), ('CMR', 'Fang'), ('COD', 'Luba'), ('COG', 'Kongo'), ('COK', 'English'), ('COK', 'Maori'), ('COL', 'Spanish'), ('COM', 'Comorian'), ('CPV', 'Crioulo'), ('CRI', 'Spanish'), ('CUB', 'Spanish'), ('CXR', 'Chinese'), ('CXR', 'English'), ('CYM', 'English'), ('CYP', 'Greek'), ('CZE', 'Czech'), ('DEU', 'German'), ('DJI', 'Somali'), ('DMA', 'Creole English'), ('DNK', 'Danish'), ('DOM', 'Spanish'), ('DZA', 'Arabic'), ('ECU', 'Spanish'), ('EGY', 'Arabic'), ('ERI', 'Tigrinja'), ('ESH', 'Arabic'), ('ESP', 'Spanish'), ('EST', 'Estonian'), ('ETH', 'Oromo'), ('FIN', 'Finnish'), ('FJI', 'Fijian'), ('FLK', 'English'), ('FRA', 'French'), ('FRO', 'Faroese'), ('FSM', 'Trukese'), ('GAB', 'Fang'), ('GBR', 'English'), ('GEO', 'Georgiana'), ('GHA', 'Akan'), ('GIB', 'English'), ('GIN', 'Ful'), ('GLP', 'Creole French'), ('GMB', 'Malinke'), ('GNB', 'Crioulo'), ('GNQ', 'Fang'), ('GRC', 'Greek'), ('GRD', 'Creole English'), ('GRL', 'Greenlandic'), ('GTM', 'Spanish'), ('GUF', 'Creole French'), ('GUM', 'English'), ('GUY', 'Creole English'), ('HKG', 'Canton Chinese'), ('HND', 'Spanish'), ('HRV', 'Serbo-Croatian'), ('HTI', 'Haiti Creole'), ('HUN', 'Hungarian'), ('IDN', 'Javanese'), ('IND', 'Hindi'), ('IRL', 'English'), ('IRN', 'Persian'), ('IRQ', 'Arabic'), ('ISL', 'Icelandic'), ('ISR', 'Hebrew'), ('ITA', 'Italian'), ('JAM', 'Creole English'), ('JOR', 'Arabic'), ('JPN', 'Japanese'), ('KAZ', 'Kazakh'), ('KEN', 'Kikuyu'), ('KGZ', 'Kirgiz'), ('KHM', 'Khmer'), ('KIR', 'Kiribati'), ('KNA', 'Creole English'), ('KOR', 'Korean'), ('KWT', 'Arabic'), ('LAO', 'Lao'), ('LBN', 'Arabic'), ('LBR', 'Kpelle'), ('LBY', 'Arabic'), ('LCA', 'Creole French'), ('LIE', 'German'), ('LKA', 'Singali'), ('LSO', 'Sotho'), ('LTU', 'Lithuanian'), ('LUX', 'Luxembourgish'), ('LVA', 'Latvian'), ('MAC', 'Canton Chinese'), ('MAR', 'Arabic'), ('MCO', 'French'), ('MDA', 'Romanian'), ('MDG', 'Malagasy'), ('MDV', 'Dhivehi'), ('MEX', 'Spanish'), ('MHL', 'Marshallese'), ('MKD', 'Macedonian'), ('MLI', 'Bambara'), ('MLT', 'Maltese'), ('MMR', 'Burmese'), ('MNG', 'Mongolian'), ('MNP', 'Philippene Languages'), ('MOZ', 'Makua'), ('MRT', 'Hassaniya'), ('MSR', 'English'), ('MTQ', 'Creole French'), ('MUS', 'Creole French'), ('MWI', 'Chichewa'), ('MYS', 'Malay'), ('MYT', 'Mahoré'), ('NAM', 'Ovambo'), ('NCL', 'Malenasian Languages'), ('NER', 'Hausa'), ('NFK', 'English'), ('NGA', 'Joruba'), ('NIC', 'Spanish'), ('NIU', 'English'), ('NIU', 'Niue'), ('NLD', 'Dutch'), ('NOR', 'Norwegian'), ('NPL', 'Nepali'), ('NRU', 'Nauru'), ('NZL', 'English'), ('OMN', 'Arabic'), ('PAK', 'Punjabi'), ('PAN', 'Spanish'), ('PCN', 'Pitcairnese'), ('PER', 'Spanish'), ('PHL', 'Pilipino'), ('PLW', 'Palau'), ('PNG', 'Papuan Languages'), ('POL', 'Polish'), ('PRI', 'Spanish'), ('PRK', 'Korean'), ('PRT', 'Portuguese'), ('PRY', 'Spanish'), ('PSE', 'Arabic'), ('PYF', 'Tahitian'), ('QAT', 'Arabic'), ('REU', 'Creole French'), ('ROM', 'Romanian'), ('RUS', 'Russian'), ('RWA', 'Rwanda'), ('SAU', 'Arabic'), ('SDN', 'Arabic'), ('SEN', 'Wolof'), ('SGP', 'Chinese'), ('SHN', 'English'), ('SJM', 'Norwegian'), ('SJM', 'Russian'), ('SLB', 'Malenasian Languages'), ('SLE', 'Mende'), ('SLV', 'Spanish'), ('SMR', 'Italian'), ('SOM', 'Somali'), ('SPM', 'French'), ('STP', 'Crioulo'), ('SUR', 'Sranantonga'), ('SVK', 'Slovak'), ('SVN', 'Slovene'), ('SWE', 'Swedish'), ('SWZ', 'Swazi'), ('SYC', 'Seselwa'), ('SYR', 'Arabic'), ('TCA', 'English'), ('TCD', 'Sara'), ('TGO', 'Ewe'), ('THA', 'Thai'), ('TJK', 'Tadzhik'), ('TKL', 'English'), ('TKL', 'Tokelau'), ('TKM', 'Turkmenian'), ('TMP', 'Portuguese'), ('TMP', 'Sunda'), ('TON', 'Tongan'), ('TTO', 'English'), ('TUN', 'Arabic'), ('TUR', 'Turkish'), ('TUV', 'Tuvalu'), ('TWN', 'Min'), ('TZA', 'Nyamwesi'), ('UGA', 'Ganda'), ('UKR', 'Ukrainian'), ('UMI', 'English'), ('URY', 'Spanish'), ('USA', 'English'), ('UZB', 'Uzbek'), ('VAT', 'Italian'), ('VCT', 'Creole English'), ('VEN', 'Spanish'), ('VGB', 'English'), ('VIR', 'English'), ('VNM', 'Vietnamese'), ('VUT', 'Bislama'), ('WLF', 'Futuna'), ('WLF', 'Wallis'), ('WSM', 'Samoan-English'), ('YEM', 'Arabic'), ('YUG', 'Serbo-Croatian'), ('ZAF', 'Zulu'), ('ZMB', 'Bemba'), ('ZWE', 'Shona')]","[('Papiamento', 'ABW', 76.7), ('Pashto', 'AFG', 52.4), ('Ovimbundu', 'AGO', 37.2), ('English', 'AIA', 0.0), ('Albaniana', 'ALB', 97.9), ('Spanish', 'AND', 44.6), ('Papiamento', 'ANT', 86.2), ('Arabic', 'ARE', 42.0), ('Spanish', 'ARG', 96.8), ('Armenian', 'ARM', 93.4), ('Samoan', 'ASM', 90.6), ('Creole English', 'ATG', 95.7), ('English', 'AUS', 81.2), ('German', 'AUT', 92.0), ('Azerbaijani', 'AZE', 89.0), ('Kirundi', 'BDI', 98.1), ('Dutch', 'BEL', 59.2), ('Fon', 'BEN', 39.8), ('Mossi', 'BFA', 50.2), ('Bengali', 'BGD', 97.7), ('Bulgariana', 'BGR', 83.2), ('Arabic', 'BHR', 67.7), ('Creole English', 'BHS', 89.7), ('Serbo-Croatian', 'BIH', 99.2), ('Belorussian', 'BLR', 65.6), ('English', 'BLZ', 50.8), ('English', 'BMU', 100.0), ('Spanish', 'BOL', 87.7), ('Portuguese', 'BRA', 97.5), ('Bajan', 'BRB', 95.1), ('Malay', 'BRN', 45.5), ('Dzongkha', 'BTN', 50.0), ('Tswana', 'BWA', 75.5), ('Gbaya', 'CAF', 23.8), ('English', 'CAN', 60.4), ('English', 'CCK', 0.0), ('German', 'CHE', 63.6), ('Spanish', 'CHL', 89.7), ('Chinese', 'CHN', 92.0), ('Akan', 'CIV', 30.0), ('Fang', 'CMR', 19.7), ('Luba', 'COD', 18.0), ('Kongo', 'COG', 51.5), ('English', 'COK', 0.0), ('Spanish', 'COL', 99.0), ('Comorian', 'COM', 75.0), ('Crioulo', 'CPV', 100.0), ('Spanish', 'CRI', 97.5), ('Spanish', 'CUB', 100.0), ('Chinese', 'CXR', 0.0), ('English', 'CYM', 0.0), ('Greek', 'CYP', 74.1), ('Czech', 'CZE', 81.2), ('German', 'DEU', 91.3), ('Somali', 'DJI', 43.9), ('Creole English', 'DMA', 100.0), ('Danish', 'DNK', 93.5), ('Spanish', 'DOM', 98.0), ('Arabic', 'DZA', 86.0), ('Spanish', 'ECU', 93.0), ('Arabic', 'EGY', 98.8), ('Tigrinja', 'ERI', 49.1), ('Arabic', 'ESH', 100.0), ('Spanish', 'ESP', 74.4), ('Estonian', 'EST', 65.3), ('Oromo', 'ETH', 31.0), ('Finnish', 'FIN', 92.7), ('Fijian', 'FJI', 50.8), ('English', 'FLK', 0.0), ('French', 'FRA', 93.6), ('Faroese', 'FRO', 100.0), ('Trukese', 'FSM', 41.6), ('Fang', 'GAB', 35.8), ('English', 'GBR', 97.3), ('Georgiana', 'GEO', 71.7), ('Akan', 'GHA', 52.4), ('English', 'GIB', 88.9), ('Ful', 'GIN', 38.6), ('Creole French', 'GLP', 95.0), ('Malinke', 'GMB', 34.1), ('Crioulo', 'GNB', 36.4), ('Fang', 'GNQ', 84.8), ('Greek', 'GRC', 98.5), ('Creole English', 'GRD', 100.0), ('Greenlandic', 'GRL', 87.5), ('Spanish', 'GTM', 64.7), ('Creole French', 'GUF', 94.3), ('English', 'GUM', 37.5), ('Creole English', 'GUY', 96.4), ('Canton Chinese', 'HKG', 88.7), ('Spanish', 'HND', 97.2), ('Serbo-Croatian', 'HRV', 95.9), ('Haiti Creole', 'HTI', 100.0), ('Hungarian', 'HUN', 98.5), ('Javanese', 'IDN', 39.4), ('Hindi', 'IND', 39.9), ('English', 'IRL', 98.4), ('Persian', 'IRN', 45.7), ('Arabic', 'IRQ', 77.2), ('Icelandic', 'ISL', 95.7), ('Hebrew', 'ISR', 63.1), ('Italian', 'ITA', 94.1), ('Creole English', 'JAM', 94.2), ('Arabic', 'JOR', 97.9), ('Japanese', 'JPN', 99.1), ('Kazakh', 'KAZ', 46.0), ('Kikuyu', 'KEN', 20.9), ('Kirgiz', 'KGZ', 59.7), ('Khmer', 'KHM', 88.6), ('Kiribati', 'KIR', 98.9), ('Creole English', 'KNA', 100.0), ('Korean', 'KOR', 99.9), ('Arabic', 'KWT', 78.1), ('Lao', 'LAO', 67.2), ('Arabic', 'LBN', 93.0), ('Kpelle', 'LBR', 19.5), ('Arabic', 'LBY', 96.0), ('Creole French', 'LCA', 80.0), ('German', 'LIE', 89.0), ('Singali', 'LKA', 60.3), ('Sotho', 'LSO', 85.0), ('Lithuanian', 'LTU', 81.6), ('Luxembourgish', 'LUX', 64.4), ('Latvian', 'LVA', 55.1), ('Canton Chinese', 'MAC', 85.6), ('Arabic', 'MAR', 65.0), ('French', 'MCO', 41.9), ('Romanian', 'MDA', 61.9), ('Malagasy', 'MDG', 98.9), ('Dhivehi', 'MDV', 100.0), ('Spanish', 'MEX', 92.1), ('Marshallese', 'MHL', 96.8), ('Macedonian', 'MKD', 66.5), ('Bambara', 'MLI', 31.8), ('Maltese', 'MLT', 95.8), ('Burmese', 'MMR', 69.0), ('Mongolian', 'MNG', 78.8), ('Philippene Languages', 'MNP', 34.1), ('Makua', 'MOZ', 27.8), ('Hassaniya', 'MRT', 81.7), ('English', 'MSR', 0.0), ('Creole French', 'MTQ', 96.6), ('Creole French', 'MUS', 70.6), ('Chichewa', 'MWI', 58.3), ('Malay', 'MYS', 58.4), ('Mahoré', 'MYT', 41.9), ('Ovambo', 'NAM', 50.7), ('Malenasian Languages', 'NCL', 45.4), ('Hausa', 'NER', 53.1), ('English', 'NFK', 0.0), ('Joruba', 'NGA', 21.4), ('Spanish', 'NIC', 97.6), ('English', 'NIU', 0.0), ('Dutch', 'NLD', 95.6), ('Norwegian', 'NOR', 96.6), ('Nepali', 'NPL', 50.4), ('Nauru', 'NRU', 57.5), ('English', 'NZL', 87.0), ('Arabic', 'OMN', 76.7), ('Punjabi', 'PAK', 48.2), ('Spanish', 'PAN', 76.8), ('Pitcairnese', 'PCN', 0.0), ('Spanish', 'PER', 79.8), ('Pilipino', 'PHL', 29.3), ('Palau', 'PLW', 82.2), ('Papuan Languages', 'PNG', 78.1), ('Polish', 'POL', 97.6), ('Spanish', 'PRI', 51.3), ('Korean', 'PRK', 99.9), ('Portuguese', 'PRT', 99.0), ('Spanish', 'PRY', 55.1), ('Arabic', 'PSE', 95.9), ('Tahitian', 'PYF', 46.4), ('Arabic', 'QAT', 40.7), ('Creole French', 'REU', 91.5), ('Romanian', 'ROM', 90.7), ('Russian', 'RUS', 86.6), ('Rwanda', 'RWA', 100.0), ('Arabic', 'SAU', 95.0), ('Arabic', 'SDN', 49.4), ('Wolof', 'SEN', 48.1), ('Chinese', 'SGP', 77.1), ('English', 'SHN', 0.0), ('Norwegian', 'SJM', 0.0), ('Malenasian Languages', 'SLB', 85.6), ('Mende', 'SLE', 34.8), ('Spanish', 'SLV', 100.0), ('Italian', 'SMR', 100.0), ('Somali', 'SOM', 98.3), ('French', 'SPM', 0.0), ('Crioulo', 'STP', 86.3), ('Sranantonga', 'SUR', 81.0), ('Slovak', 'SVK', 85.6), ('Slovene', 'SVN', 87.9), ('Swedish', 'SWE', 89.5), ('Swazi', 'SWZ', 89.9), ('Seselwa', 'SYC', 91.3), ('Arabic', 'SYR', 90.0), ('English', 'TCA', 0.0), ('Sara', 'TCD', 27.7), ('Ewe', 'TGO', 23.2), ('Thai', 'THA', 52.6), ('Tadzhik', 'TJK', 62.2), ('English', 'TKL', 0.0), ('Turkmenian', 'TKM', 76.7), ('Portuguese', 'TMP', 0.0), ('Tongan', 'TON', 98.3), ('English', 'TTO', 93.5), ('Arabic', 'TUN', 69.9), ('Turkish', 'TUR', 87.6), ('Tuvalu', 'TUV', 92.5), ('Min', 'TWN', 66.7), ('Nyamwesi', 'TZA', 21.1), ('Ganda', 'UGA', 18.1), ('Ukrainian', 'UKR', 64.7), ('English', 'UMI', 0.0), ('Spanish', 'URY', 95.7), ('English', 'USA', 86.2), ('Uzbek', 'UZB', 72.6), ('Italian', 'VAT', 0.0), ('Creole English', 'VCT', 99.1), ('Spanish', 'VEN', 96.9), ('English', 'VGB', 0.0), ('English', 'VIR', 81.7), ('Vietnamese', 'VNM', 86.8), ('Bislama', 'VUT', 56.6), ('Futuna', 'WLF', 0.0), ('Samoan-English', 'WSM', 52.0), ('Arabic', 'YEM', 99.6), ('Serbo-Croatian', 'YUG', 75.2), ('Zulu', 'ZAF', 22.7), ('Bemba', 'ZMB', 29.7), ('Shona', 'ZWE', 72.1)]",,0.0,
What are the names of conductors who have conducted at more than one orchestra?,"[conductor.Name,orchestra.Conductor_ID,orchestra.Orchestra_ID,orchestra.Conductor_ID = conductor.Conductor_ID]","Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",NON-NESTED,SELECT conductor.Name FROM conductor JOIN orchestra ON orchestra.Conductor_ID = conductor.Conductor_ID GROUP BY conductor.Conductor_ID HAVING COUNT(orchestra.Orchestra_ID) > 1;,SELECT T1.Name FROM conductor AS T1 JOIN orchestra AS T2 ON T1.Conductor_ID  =  T2.Conductor_ID GROUP BY T2.Conductor_ID HAVING COUNT(*)  >  1,orchestra,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of conductors (""conductor.Name""). 2. Condition Structure: Use a HAVING clause to filter conductors who have conducted at more than one orchestra. This requires counting the number of orchestras associated with each conductor. 3. Join Structure: Use an INNER JOIN between the ""conductor"" and ""orchestra"" tables on ""orchestra.Conductor_ID = conductor.Conductor_ID"" to link each conductor with their orchestras. 4. Aggregation Structure: Use COUNT on ""orchestra.Orchestra_ID"" to count the number of orchestras each conductor has conducted, then filter with HAVING to include only those with a count greater than one.",[],[],,1.0,
Show ids of all students who do not have any friends.,"[Highschooler.ID, Friend.student_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NESTED,SELECT ID FROM Highschooler WHERE ID NOT IN (SELECT student_id FROM Friend);,SELECT id FROM Highschooler EXCEPT SELECT student_id FROM Friend,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the IDs of students. Use the FROM clause to specify the Highschooler table. Apply a WHERE clause to filter students who do not have any friends by ensuring their ID is not present in the Friend table as a student_id. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose ID appears in the Friend table as a student_id, meaning they have friends. 3. Join Structure: Not required, as we only need to filter based on the absence of matching student_id entries in the Friend table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[(1025,), (1641,)]","[(1025,), (1641,)]",,1.0,
"Give the name, year of independence, and surface area of the country that has the lowest population.","[country.Name, country.IndepYear, country.SurfaceArea, country.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT Name, IndepYear, SurfaceArea FROM country WHERE Population = (SELECT MIN(Population) FROM country);","SELECT Name ,  SurfaceArea ,  IndepYear FROM country ORDER BY Population LIMIT 1",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name, year of independence, and surface area of the country. Use the FROM clause to specify the country table. Apply a WHERE clause to filter for the country with the lowest population. 2. Condition Structure: Use the WHERE clause with a subquery to filter for the country with the minimum population. 3. Join Structure: Not required, as all data is available within the country table. 4. Aggregation Structure: Use the MIN function in a subquery to find the lowest population, which is then used in the filtering condition.","[('Antarctica', None, 13120000.0), ('French Southern territories', None, 7780.0), ('Bouvet Island', None, 59.0), ('Heard Island and McDonald Islands', None, 359.0), ('British Indian Ocean Territory', None, 78.0), ('South Georgia and the South Sandwich Islands', None, 3903.0), ('United States Minor Outlying Islands', None, 16.0)]","[('Antarctica', 13120000.0, None)]",,1.0,
How many different nationalities do conductors have?,[conductor.Nationality],"Table conductor, columns = [*,Conductor_ID,Name,Age,Nationality,Year_of_Work]
Table orchestra, columns = [*,Orchestra_ID,Orchestra,Conductor_ID,Record_Company,Year_of_Founded,Major_Record_Format]
Table performance, columns = [*,Performance_ID,Orchestra_ID,Type,Date,Official_ratings_(millions),Weekly_rank,Share]
Table show, columns = [*,Show_ID,Performance_ID,If_first_show,Result,Attendance]
","Foreign_keys = [orchestra.Conductor_ID = conductor.Conductor_ID,performance.Orchestra_ID = orchestra.Orchestra_ID,show.Performance_ID = performance.Performance_ID]
",EASY,SELECT COUNT(DISTINCT conductor.Nationality) FROM conductor;,SELECT count(DISTINCT Nationality) FROM conductor,orchestra,"1. Sequential Structure: Start with the SELECT clause to count the distinct nationalities of conductors. 2. Condition Structure: No specific filtering condition is required as we are interested in all nationalities. 3. Join Structure: No JOIN is necessary since all relevant information is in the ""conductor"" table. 4. Aggregation Structure: Use COUNT with DISTINCT on ""conductor.Nationality"" to count the unique nationalities.","[(3,)]","[(3,)]",,1.0,
Find the average life expectancy and total population for each continent where the average life expectancy is shorter than 72?,"[country.Continent, country.LifeExpectancy, country.Population]","Table city, columns = [*,ID,Name,CountryCode,District,Population]
Table country, columns = [*,Code,Name,Continent,Region,SurfaceArea,IndepYear,Population,LifeExpectancy,GNP,GNPOld,LocalName,GovernmentForm,HeadOfState,Capital,Code2]
Table countrylanguage, columns = [*,CountryCode,Language,IsOfficial,Percentage]
Table sqlite_sequence, columns = [*,name,seq]
","Foreign_keys = [city.CountryCode = country.Code,countrylanguage.CountryCode = country.Code]
",NESTED,"SELECT Continent, AVG(LifeExpectancy) AS avg_life_expectancy, SUM(Population) AS total_population FROM country GROUP BY Continent HAVING AVG(LifeExpectancy) < 72;","SELECT sum(Population) ,  avg(LifeExpectancy) ,  Continent FROM country GROUP BY Continent HAVING avg(LifeExpectancy)  <  72",world_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the continent, average life expectancy, and total population. Use the FROM clause to specify the country table. Apply a GROUP BY clause to group data by continent. Use the HAVING clause to filter continents where the average life expectancy is less than 72. 2. Condition Structure: Use the HAVING clause to filter for continents where the average life expectancy is shorter than 72. 3. Join Structure: Not required, as all the necessary data is in the country table. 4. Aggregation Structure: Use AVG to calculate the average life expectancy and SUM to calculate the total population for each continent.","[('Africa', 52.5719298245614, 784475000), ('Asia', 67.44117647058823, 3705025700), ('Oceania', 69.715, 30401150), ('South America', 70.94615384615385, 345780000)]","[(784475000, 52.5719298245614, 'Africa'), (3705025700, 67.44117647058823, 'Asia'), (30401150, 69.715, 'Oceania'), (345780000, 70.94615384615385, 'South America')]",,1.0,
Tell me the number of dogs that have not received any treatment .,"[Dogs.dog_id, Treatments.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,SELECT COUNT(dog_id) AS number_of_dogs FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments);,select count(*) from dogs where dog_id not in ( select dog_id from treatments ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to count the number of dogs. Use the FROM clause to specify the Dogs table. Apply a WHERE clause to filter dogs that have not received any treatment by ensuring their dog_id is not present in the Treatments table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude dogs whose dog_id appears in the Treatments table, meaning they have received treatments. 3. Join Structure: Not required, as we only need to filter based on the absence of matching dog_id entries in the Treatments table. 4. Aggregation Structure: Use the COUNT function to calculate the total number of dogs that meet the condition of not having received any treatment.","[(6,)]","[(6,)]",,1.0,
What are the names of high schoolers who have a grade of over 5 and have 2 or more friends?,"[Highschooler.name, Highschooler.grade, Friend.student_id, Friend.friend_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NESTED,"SELECT Highschooler.name FROM Highschooler JOIN Friend ON Highschooler.ID = Friend.student_id WHERE Highschooler.grade > 5 GROUP BY Highschooler.ID, Highschooler.name HAVING COUNT(Friend.friend_id) >= 2;",SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of high schoolers. Use the FROM clause to specify the Highschooler table. Join it with the Friend table to count the number of friends for each high schooler. Apply a WHERE clause to filter high schoolers with a grade greater than 5 and a HAVING clause to ensure they have 2 or more friends. 2. Condition Structure: Use the WHERE clause to filter high schoolers with a grade greater than 5. Use the HAVING clause to filter those with 2 or more friends by counting the occurrences of their student_id in the Friend table. 3. Join Structure: Use an INNER JOIN between the Highschooler and Friend tables, connecting Friend.student_id with Highschooler.ID to count the number of friends for each high schooler. 4. Aggregation Structure: Use COUNT(*) to count the number of friends for each high schooler and filter those with 2 or more friends using the HAVING clause.","[('Alexis',), ('Kris',), ('Jordan',), ('Gabriel',), ('Andrew',)]","[('Alexis',), ('Kris',), ('Jordan',), ('Gabriel',), ('Andrew',)]",,1.0,
"What are the dog name, age and weight of the dogs that were abandoned? Note that 1 stands for yes, and 0 stands for no in the tables.","[Dogs.name, Dogs.age, Dogs.weight, Dogs.abandoned_yn]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,"SELECT Dogs.name, Dogs.age, Dogs.weight FROM Dogs WHERE Dogs.abandoned_yn = 1;","SELECT name ,  age ,  weight FROM Dogs WHERE abandoned_yn  =  1",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""Dogs.name"", ""Dogs.age"", and ""Dogs.weight"" for the dogs that were abandoned. 2. Condition Structure: Use a WHERE clause to filter for dogs where ""Dogs.abandoned_yn"" equals 1, as 1 stands for ""yes"" (abandoned). 3. Join Structure: No JOIN is required since all necessary information is available in the ""Dogs"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving specific fields based on a condition.","[('Kacey', '6', '7.57'), ('Lyric', '4', '4.36'), ('Evangeline', '1', '4.01')]","[('Kacey', '6', '7.57'), ('Lyric', '4', '4.36'), ('Evangeline', '1', '4.01')]",,1.0,
Compute the average age of all the dogs.,[Dogs.age],"Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,SELECT AVG(Dogs.age) AS average_age FROM Dogs;,SELECT avg(age) FROM Dogs,dog_kennels,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average age of all dogs. 2. Aggregation Structure: Use the AVG function to calculate the average age of the dogs. 3. Condition Structure: No specific filtering condition is required since the query asks for the average age of all dogs. 4. Join Structure: No JOIN is required as all necessary data is within the ""Dogs"" table.","[(5.066666666666666,)]","[(5.066666666666666,)]",,1.0,
Show distinct names of singers that have songs with sales more than 300000.,"[singer.Name, song.Sales, song.Singer_ID = singer.Singer_ID, 300000]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NON-NESTED,SELECT DISTINCT singer.Name FROM singer JOIN song ON song.Singer_ID = singer.Singer_ID WHERE song.Sales > 300000;,SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID WHERE T2.Sales  >  300000,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of singers. Use DISTINCT to ensure unique names are returned. 2. Condition Structure: Use a WHERE clause to filter for songs with sales greater than 300000. 3. Join Structure: Use an INNER JOIN to connect the ""singer"" table with the ""song"" table based on the foreign key relationship ""song.Singer_ID = singer.Singer_ID."" 4. Aggregation Structure: No aggregation is needed as we are only retrieving distinct singer names.","[('Liliane Bettencourt',), ('Christy Walton',), ('Iris Fontbona',)]","[('Liliane Bettencourt',), ('Christy Walton',), ('Iris Fontbona',)]",,1.0,
Show the names of singers that have more than one song.,"[singer.Name, song.Singer_ID, song.Singer_ID = singer.Singer_ID]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NON-NESTED,SELECT DISTINCT singer.Name FROM singer JOIN song ON song.Singer_ID = singer.Singer_ID GROUP BY singer.Singer_ID HAVING COUNT(song.Singer_ID) > 1;,SELECT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name HAVING COUNT(*)  >  1,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of singers. Use GROUP BY on ""singer.Singer_ID"" to group songs by each singer. 2. Condition Structure: Apply a HAVING clause to filter for singers who have more than one song. This is achieved by counting the number of songs for each singer using COUNT on ""song.Singer_ID."" 3. Join Structure: Use an INNER JOIN between the ""singer"" and ""song"" tables based on the foreign key relationship ""song.Singer_ID = singer.Singer_ID"" to link each singer with their songs. 4. Aggregation Structure: Use COUNT to count the number of songs for each singer and filter using HAVING to include only those with more than one song.","[('Liliane Bettencourt',), ('Christy Walton',)]","[('Christy Walton',), ('Liliane Bettencourt',)]",,1.0,
How many likes does Kyle have?,"[Highschooler.name, Highschooler.ID, Likes.liked_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT COUNT(Likes.liked_id) FROM Highschooler JOIN Likes ON Highschooler.ID = Likes.liked_id WHERE Highschooler.name = 'Kyle';,"SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  ""Kyle""",network_1,"1. Sequential Structure: Start with the SELECT clause to count the number of likes for Kyle. Use COUNT on ""Likes.liked_id"" to determine the total number of likes. 2. Condition Structure: Use a WHERE clause to filter for the specific student whose name is ""Kyle."" This requires identifying Kyle's ID from the ""Highschooler"" table and matching it with ""Likes.liked_id."" 3. Join Structure: Use a JOIN between the ""Highschooler"" and ""Likes"" tables to connect the student name with the liked ID. 4. Aggregation Structure: Use COUNT to aggregate the number of likes for Kyle.","[(1,)]","[(1,)]",,1.0,
"For each singer name, what is the total sales for their songs?","[singer.Name, song.Sales, song.Singer_ID = singer.Singer_ID]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NON-NESTED,"SELECT singer.Name, SUM(song.Sales) AS Total_Sales FROM singer JOIN song ON song.Singer_ID = singer.Singer_ID GROUP BY singer.Name;","SELECT T1.Name ,  sum(T2.Sales) FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name",singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the singer's name and the total sales of their songs. Use an aggregate function (SUM) on ""song.Sales"" to calculate the total sales for each singer. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""singer"" and ""song"" tables based on the foreign key relationship ""song.Singer_ID = singer.Singer_ID"" to associate each singer with their songs. 4. Aggregation Structure: Use SUM to calculate the total sales for each singer and GROUP BY ""singer.Name"" to group the results by each singer.","[('Christy Walton', 651421.0), ('Gina Rinehart', 292000.0), ('Iris Fontbona', 335000.0), ('Jacqueline Mars', 275000.0), ('Liliane Bettencourt', 1646407.0), ('Susanne Klatten', 261000.0)]","[('Christy Walton', 651421.0), ('Gina Rinehart', 292000.0), ('Iris Fontbona', 335000.0), ('Jacqueline Mars', 275000.0), ('Liliane Bettencourt', 1646407.0), ('Susanne Klatten', 261000.0)]",,1.0,
Find the owner id and zip code of the owner who spent the most money in total for his or her dogs.,"[Owners.owner_id, Owners.zip_code, Treatments.cost_of_treatment, Treatments.dog_id = Dogs.dog_id, Dogs.owner_id = Owners.owner_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Owners.owner_id, Owners.zip_code FROM Treatments JOIN Dogs ON Treatments.dog_id = Dogs.dog_id JOIN Owners ON Dogs.owner_id = Owners.owner_id GROUP BY Owners.owner_id, Owners.zip_code ORDER BY SUM(Treatments.cost_of_treatment) DESC LIMIT 1;","SELECT T1.owner_id ,  T1.zip_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY sum(T3.cost_of_treatment) DESC LIMIT 1",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Owners.owner_id"" and ""Owners.zip_code."" To find the owner who spent the most money, we need to calculate the total cost of treatments for each owner using SUM on ""Treatments.cost_of_treatment."" 2. Condition Structure: No specific filtering condition is required, as we are interested in all owners. 3. Join Structure: Use JOINs to connect the ""Treatments"" table with the ""Dogs"" table on ""Treatments.dog_id = Dogs.dog_id"" and then connect the ""Dogs"" table with the ""Owners"" table on ""Dogs.owner_id = Owners.owner_id."" 4. Aggregation Structure: Use SUM to calculate the total cost of treatments for each owner, GROUP BY ""Owners.owner_id"" and ""Owners.zip_code"" to group the results by owner. Use ORDER BY in descending order on the total cost and LIMIT 1 to select the owner who spent the most.","[(3, '02647')]","[(3, '02647')]",,1.0,
What is the lowest grade of students who do not have any friends?,"[Highschooler.grade, Highschooler.ID, Friend.student_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NESTED,SELECT MIN(grade) FROM Highschooler WHERE ID NOT IN (SELECT student_id FROM Friend);,SELECT min(grade) FROM Highschooler WHERE id NOT IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id),network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the minimum grade of students. Use the FROM clause to specify the Highschooler table. Apply a WHERE clause to filter students who do not have any friends by ensuring their ID is not present in the Friend table as a student_id. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose ID appears in the Friend table as a student_id, meaning they have friends. 3. Join Structure: Not required, as we only need to filter based on the absence of matching student_id entries in the Friend table. 4. Aggregation Structure: Use the MIN function to find the lowest grade among the filtered students.","[(10,)]","[(10,)]",,1.0,
Show the citizenship shared by singers with birth year before 1945 and after 1955.,"[singer.Citizenship, singer.Birth_Year]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NESTED,SELECT Citizenship FROM singer WHERE Birth_Year < 1945 OR Birth_Year > 1955 GROUP BY Citizenship HAVING COUNT(CASE WHEN Birth_Year < 1945 THEN 1 END) > 0 AND COUNT(CASE WHEN Birth_Year > 1955 THEN 1 END) > 0;,SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the citizenship of singers. Use the FROM clause to specify the singer table. Apply a WHERE clause to filter singers born before 1945 and after 1955. Use GROUP BY to group by citizenship and HAVING to ensure the citizenship is shared by singers in both birth year ranges. 2. Condition Structure: Use the WHERE clause to filter singers born before 1945 or after 1955. Then, use the HAVING clause to ensure that the citizenship is shared by singers in both ranges. 3. Join Structure: Not required, as all data is in the singer table. 4. Aggregation Structure: Use COUNT with GROUP BY to group singers by citizenship and ensure that both conditions (before 1945 and after 1955) are met for the same citizenship.","[('United States',)]","[('United States',)]",,1.0,
Which states have both owners and professionals living there?,"[Owners.state, Professionals.state]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,SELECT DISTINCT Owners.state FROM Owners WHERE Owners.state IN (SELECT DISTINCT Professionals.state FROM Professionals);,SELECT state FROM Owners INTERSECT SELECT state FROM Professionals,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct states. Use the FROM clause to specify the Owners and Professionals tables. Apply a WHERE clause to filter states that are present in both tables. 2. Condition Structure: Use the WHERE clause with a condition to match states from the Owners table with states from the Professionals table. 3. Join Structure: Not required, as we are only comparing states between two tables without needing to join them. 4. Aggregation Structure: Not required, as we are retrieving distinct states without any aggregation.","[('Wisconsin',), ('Indiana',), ('Mississippi',)]","[('Indiana',), ('Mississippi',), ('Wisconsin',)]",,1.0,
What is the name of the high schooler who has the greatest number of likes?,"[Highschooler.name, Likes.liked_id, Highschooler.ID = Likes.liked_id]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT Highschooler.name FROM Highschooler JOIN Likes ON Highschooler.ID = Likes.liked_id GROUP BY Highschooler.ID ORDER BY COUNT(Likes.liked_id) DESC LIMIT 1;,SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the high schooler. Use COUNT to count the number of likes for each high schooler. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the high schooler with the greatest number of likes. 3. Join Structure: Use a JOIN between the ""Highschooler"" and ""Likes"" tables based on ""Highschooler.ID = Likes.liked_id"" to associate each high schooler with their likes. 4. Aggregation Structure: Use COUNT on ""Likes.liked_id"" to count the number of likes for each high schooler. Use GROUP BY to group the results by high schooler, and ORDER BY in descending order to rank high schoolers by the number of likes. Use LIMIT 1 to select the high schooler with the greatest number of likes.","[('Cassandra',)]","[('John',)]",,0.0,
What are the arriving date and the departing date of the dogs who have gone through a treatment?,"[Dogs.date_arrived, Dogs.date_departed, Treatments.dog_id = Dogs.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Dogs.date_arrived, Dogs.date_departed FROM Dogs JOIN Treatments ON Treatments.dog_id = Dogs.dog_id;","SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""date_arrived"" and ""date_departed"" fields from the ""Dogs"" table. 2. Condition Structure: Use a WHERE clause to filter for dogs that have undergone a treatment. This can be determined by checking if there is a corresponding record in the ""Treatments"" table. 3. Join Structure: Use an INNER JOIN between the ""Dogs"" table and the ""Treatments"" table on the ""dog_id"" field to link dogs with their treatments. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields for the filtered records.","[('2017-06-18 19:45:38', '2018-03-24 23:48:59'), ('2017-04-20 00:58:55', '2018-03-24 19:12:22'), ('2017-06-18 19:45:38', '2018-03-24 23:48:59'), ('2017-12-22 05:02:02', '2018-03-25 02:11:32'), ('2017-10-24 04:45:13', '2018-03-25 14:15:41'), ('2017-12-29 06:08:26', '2018-03-25 04:42:14'), ('2017-12-29 23:24:13', '2018-03-24 19:36:59'), ('2017-12-22 05:02:02', '2018-03-25 02:11:32'), ('2017-06-18 19:45:38', '2018-03-24 23:48:59'), ('2017-12-29 06:08:26', '2018-03-25 04:42:14'), ('2017-12-29 23:24:13', '2018-03-24 19:36:59'), ('2018-01-02 03:15:29', '2018-03-25 05:07:47'), ('2017-05-06 08:03:52', '2018-03-25 06:29:10'), ('2017-12-29 06:08:26', '2018-03-25 04:42:14'), ('2017-09-08 20:10:13', '2018-03-25 06:58:44')]","[('2017-06-18 19:45:38', '2018-03-24 23:48:59'), ('2017-04-20 00:58:55', '2018-03-24 19:12:22'), ('2017-12-22 05:02:02', '2018-03-25 02:11:32'), ('2017-10-24 04:45:13', '2018-03-25 14:15:41'), ('2017-12-29 06:08:26', '2018-03-25 04:42:14'), ('2017-12-29 23:24:13', '2018-03-24 19:36:59'), ('2018-01-02 03:15:29', '2018-03-25 05:07:47'), ('2017-05-06 08:03:52', '2018-03-25 06:29:10'), ('2017-09-08 20:10:13', '2018-03-25 06:58:44')]",,1.0,
What is the charge amount of the most expensive charge type?,"[Charges.charge_amount, Charges.charge_type]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,SELECT MAX(Charges.charge_amount) AS max_charge_amount FROM Charges;,SELECT max(charge_amount) FROM Charges,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""charge_amount"" of the most expensive charge type. 2. Condition Structure: No specific filtering condition is required since we are looking for the maximum charge amount. 3. Join Structure: No JOIN is necessary as all the required data is in the ""Charges"" table. 4. Aggregation Structure: Use the MAX function to find the highest charge amount.","[(640,)]","[(640,)]",,1.0,
What is the average age of all the dogs?,[Dogs.age],"Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,SELECT AVG(Dogs.age) AS average_age FROM Dogs;,SELECT avg(age) FROM Dogs,dog_kennels,"1. Sequential Structure: Begin with the SELECT clause to specify the required aggregate value, which is the average age of all dogs. 2. Aggregation Structure: Use the AVG function to calculate the average age of the dogs. 3. Condition Structure: No specific filtering condition is required as the query asks for the average age of all dogs. 4. Join Structure: No JOIN is required since all necessary data is within the ""Dogs"" table.","[(5.066666666666666,)]","[(5.066666666666666,)]",,1.0,
What is the name of the singer with the largest net worth?,"[singer.Name, singer.Net_Worth_Millions]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,SELECT singer.Name FROM singer ORDER BY singer.Net_Worth_Millions DESC LIMIT 1;,SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""singer.Name"" of the singer with the largest net worth. 2. Condition Structure: No specific filtering condition is needed since we are looking for the singer with the highest net worth. 3. Join Structure: No JOIN is required, as all necessary information is available in the ""singer"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""singer.Net_Worth_Millions"" to rank singers by net worth and apply LIMIT 1 to select the singer with the largest net worth.","[('Liliane Bettencourt',)]","[('Liliane Bettencourt',)]",,1.0,
"Show the names of high schoolers who have likes, and numbers of likes for each.","[Highschooler.name, Likes.student_id, Likes.liked_id, Likes.student_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,"SELECT Highschooler.name, COUNT(Likes.liked_id) AS number_of_likes FROM Highschooler JOIN Likes ON Likes.student_id = Highschooler.ID GROUP BY Highschooler.name;","SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of high schoolers and the count of likes for each. Use COUNT to calculate the number of likes for each student. 2. Condition Structure: No specific filtering condition is required, as we are interested in all high schoolers who have likes. 3. Join Structure: Use a JOIN between the ""Highschooler"" and ""Likes"" tables based on ""Likes.student_id = Highschooler.ID"" to associate each high schooler with their likes. 4. Aggregation Structure: Use COUNT on ""Likes.liked_id"" to count the number of likes for each high schooler. Use GROUP BY on ""Highschooler.name"" to group the results by each high schooler's name.","[('Alexis', 1), ('Andrew', 1), ('Austin', 1), ('Brittany', 1), ('Cassandra', 1), ('Gabriel', 2), ('Jessica', 1), ('John', 1), ('Kyle', 1)]","[('John', 1), ('Alexis', 1), ('Austin', 1), ('Jessica', 1), ('Brittany', 1), ('Gabriel', 1), ('Cassandra', 1), ('Andrew', 1), ('Gabriel', 1), ('Kyle', 1)]",,1.0,
What is the name of the singer who is worth the most?,"[singer.Name, singer.Net_Worth_Millions]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,SELECT singer.Name FROM singer ORDER BY singer.Net_Worth_Millions DESC LIMIT 1;,SELECT Name FROM singer ORDER BY Net_Worth_Millions DESC LIMIT 1,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""singer.Name"" of the singer with the highest net worth. 2. Condition Structure: No specific filtering condition is required since we are looking for the singer with the maximum net worth. 3. Join Structure: No JOIN is necessary as all relevant information is available in the ""singer"" table. 4. Aggregation Structure: Use ORDER BY in descending order on ""singer.Net_Worth_Millions"" to rank singers by their net worth and apply LIMIT 1 to select the singer with the highest net worth.","[('Liliane Bettencourt',)]","[('Liliane Bettencourt',)]",,1.0,
What is the feature type name of feature AirCon?,"[Other_Available_Features.feature_name,Other_Available_Features.feature_type_code,Ref_Feature_Types.feature_type_code = Other_Available_Features.feature_type_code,Ref_Feature_Types.feature_type_name,AirCon]","Table Other_Available_Features, columns = [*,feature_id,feature_type_code,feature_name,feature_description]
Table Other_Property_Features, columns = [*,property_id,feature_id,property_feature_description]
Table Properties, columns = [*,property_id,property_type_code,date_on_market,date_sold,property_name,property_address,room_count,vendor_requested_price,buyer_offered_price,agreed_selling_price,apt_feature_1,apt_feature_2,apt_feature_3,fld_feature_1,fld_feature_2,fld_feature_3,hse_feature_1,hse_feature_2,hse_feature_3,oth_feature_1,oth_feature_2,oth_feature_3,shp_feature_1,shp_feature_2,shp_feature_3,other_property_details]
Table Ref_Feature_Types, columns = [*,feature_type_code,feature_type_name]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
","Foreign_keys = [Other_Available_Features.feature_type_code = Ref_Feature_Types.feature_type_code,Properties.property_type_code = Ref_Property_Types.property_type_code,Other_Property_Features.property_id = Properties.property_id,Other_Property_Features.feature_id = Other_Available_Features.feature_id]
",NON-NESTED,SELECT Ref_Feature_Types.feature_type_name FROM Other_Available_Features JOIN Ref_Feature_Types ON Other_Available_Features.feature_type_code = Ref_Feature_Types.feature_type_code WHERE Other_Available_Features.feature_name = 'AirCon';,"SELECT T2.feature_type_name FROM Other_Available_Features AS T1 JOIN Ref_Feature_Types AS T2 ON T1.feature_type_code  =  T2.feature_type_code WHERE T1.feature_name  =  ""AirCon""",real_estate_properties,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Ref_Feature_Types.feature_type_name."" 2. Condition Structure: Use a WHERE clause to filter for the feature with the name ""AirCon"" in the ""Other_Available_Features"" table. 3. Join Structure: Use an INNER JOIN to connect ""Other_Available_Features"" with ""Ref_Feature_Types"" on the shared key ""feature_type_code"" to get the corresponding feature type name. 4. Aggregation Structure: No aggregation is needed as we are retrieving a single feature type name.","[('Amenity, eg Pool.',)]","[('Amenity, eg Pool.',)]",,1.0,
Show me the cost of the most recently performed treatment.,"[Treatments.cost_of_treatment, Treatments.date_of_treatment]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,SELECT Treatments.cost_of_treatment FROM Treatments ORDER BY Treatments.date_of_treatment DESC LIMIT 1;,SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1,dog_kennels,"1. Sequential Structure: Begin with the SELECT clause to specify the cost of the treatment, as the question asks for the cost of the most recently performed treatment. 2. Condition Structure: Use ORDER BY on ""Treatments.date_of_treatment"" in descending order to sort treatments by the most recent date. 3. Limiting Structure: Use LIMIT 1 to retrieve only the most recent treatment. 4. Join Structure: No JOIN is required since all necessary data is within the ""Treatments"" table. 5. Aggregation Structure: No aggregation is needed as we are retrieving a single value based on the most recent date.","[(407,)]","[(407,)]",,1.0,
"Return the first name, last name and email of the owners living in a state whose name contains the substring 'North'.","[Owners.first_name, Owners.last_name, Owners.email_address, Owners.state]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,"SELECT Owners.first_name, Owners.last_name, Owners.email_address FROM Owners WHERE Owners.state LIKE '%North%';","SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""first_name"", ""last_name"", and ""email_address"" of the owners. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for owners living in a state whose name contains the substring 'North'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Owners"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.","[('Johann', 'Fisher', 'zboncak.madonna@example.net'), ('Cindy', 'Schmitt', 'wpfeffer@example.net')]","[('Johann', 'Fisher', 'zboncak.madonna@example.net'), ('Cindy', 'Schmitt', 'wpfeffer@example.net')]",,1.0,
Find the states where both owners and professionals live.,"[Owners.state, Professionals.state]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,SELECT DISTINCT Owners.state FROM Owners WHERE Owners.state IN (SELECT DISTINCT Professionals.state FROM Professionals);,SELECT state FROM Owners INTERSECT SELECT state FROM Professionals,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct states. Use the FROM clause to specify the Owners and Professionals tables. Apply a WHERE clause to filter states that are common to both tables. 2. Condition Structure: Use the WHERE clause to match the states in the Owners table with the states in the Professionals table. 3. Join Structure: Not required, as we are comparing states directly between the two tables without needing to join them. 4. Aggregation Structure: Not required, as we are retrieving distinct states without any aggregation.","[('Wisconsin',), ('Indiana',), ('Mississippi',)]","[('Indiana',), ('Mississippi',), ('Wisconsin',)]",,1.0,
List each charge type and its amount.,"[Charges.charge_type, Charges.charge_amount]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,"SELECT Charges.charge_type, Charges.charge_amount FROM Charges;","SELECT charge_type ,  charge_amount FROM Charges",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""charge_type"" and ""charge_amount"" fields from the ""Charges"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for all charge types and their amounts. 3. Join Structure: No JOIN is necessary since all the required data is available within the ""Charges"" table. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves the charge type and amount for each record.","[('Daily Accommodation', 98), ('Drugs', 322), ('Health Check', 640)]","[('Daily Accommodation', 98), ('Drugs', 322), ('Health Check', 640)]",,1.0,
Which owner has paid the largest amount of money in total for their dogs? Show the owner id and zip code.,"[Owners.owner_id, Owners.zip_code, Dogs.owner_id = Owners.owner_id, Treatments.dog_id = Dogs.dog_id, Treatments.cost_of_treatment]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Owners.owner_id, Owners.zip_code FROM Owners JOIN Dogs ON Dogs.owner_id = Owners.owner_id JOIN Treatments ON Treatments.dog_id = Dogs.dog_id GROUP BY Owners.owner_id, Owners.zip_code ORDER BY SUM(Treatments.cost_of_treatment) DESC LIMIT 1;","SELECT T1.owner_id ,  T1.zip_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY sum(T3.cost_of_treatment) DESC LIMIT 1",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""owner_id"" and ""zip_code"" of the owner who has paid the largest total amount for their dogs. Use SUM on ""Treatments.cost_of_treatment"" to calculate the total amount paid by each owner. 2. Condition Structure: No specific filtering condition is required, as we are interested in all owners. 3. Join Structure: Use JOINs to connect the ""Owners"" table with the ""Dogs"" table on ""Dogs.owner_id = Owners.owner_id"" and the ""Dogs"" table with the ""Treatments"" table on ""Treatments.dog_id = Dogs.dog_id"" to link owners with their dogs and the treatments they paid for. 4. Aggregation Structure: Use GROUP BY on ""Owners.owner_id"" and ""Owners.zip_code"" to calculate the total amount paid by each owner. Use ORDER BY in descending order on the total amount and LIMIT 1 to find the owner who paid the largest amount.","[(3, '02647')]","[(3, '02647')]",,1.0,
How many singers are there?,[singer.Singer_ID],"Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,SELECT COUNT(singer.Singer_ID) AS total_singers FROM singer;,SELECT count(*) FROM singer,singer,"1. Sequential Structure: Start with the SELECT clause to count the number of singers. 2. Condition Structure: No specific filtering condition is required as we want to count all singers. 3. Join Structure: No JOIN is necessary since the required information is available within the ""singer"" table. 4. Aggregation Structure: Use COUNT on ""singer.Singer_ID"" to calculate the total number of singers.","[(8,)]","[(8,)]",,1.0,
Which breed do the most dogs have? Give me the breed name.,"[Dogs.breed_code, Breeds.breed_name, Dogs.breed_code = Breeds.breed_code]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,SELECT Breeds.breed_name FROM Dogs JOIN Breeds ON Dogs.breed_code = Breeds.breed_code GROUP BY Breeds.breed_name ORDER BY COUNT(Dogs.dog_id) DESC LIMIT 1;,SELECT T1.breed_name FROM Breeds AS T1 JOIN Dogs AS T2 ON T1.breed_code  =  T2.breed_code GROUP BY T1.breed_name ORDER BY count(*) DESC LIMIT 1,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""breed_name"" from the ""Breeds"" table. Use COUNT to count the number of dogs for each breed. 2. Condition Structure: No specific filtering condition is required, as we are interested in all breeds. 3. Join Structure: Use a JOIN between the ""Dogs"" and ""Breeds"" tables based on the ""breed_code"" to associate each dog with its breed name. 4. Aggregation Structure: Use COUNT to count the number of dogs for each breed, GROUP BY ""breed_name"" to group the results by breed, and ORDER BY the count in descending order to find the breed with the most dogs. Use LIMIT 1 to return only the top result.","[('Bulldog',)]","[('Bulldog',)]",,1.0,
How much does the most expensive charge type costs?,"[Charges.charge_amount,Charges.charge_type]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,SELECT MAX(Charges.charge_amount) AS most_expensive_charge FROM Charges;,SELECT max(charge_amount) FROM Charges,dog_kennels,"1. Sequential Structure: Begin with the SELECT clause to specify the maximum charge amount, as the question asks for the cost of the most expensive charge type. 2. Aggregation Structure: Use the MAX function to find the highest value in the ""Charges.charge_amount"" column. 3. Condition Structure: No specific filtering condition is required since we are looking for the maximum value across all charge types. 4. Join Structure: No JOIN is required since all necessary data is within the ""Charges"" table.","[(640,)]","[(640,)]",,1.0,
What are the names of the singers that have more than one songs?,"[singer.Name, song.Singer_ID, song.Singer_ID = singer.Singer_ID]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NON-NESTED,SELECT DISTINCT singer.Name FROM singer JOIN song ON song.Singer_ID = singer.Singer_ID GROUP BY singer.Singer_ID HAVING COUNT(song.Singer_ID) > 1;,SELECT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name HAVING COUNT(*)  >  1,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of singers. Use GROUP BY on ""singer.Singer_ID"" to group songs by each singer. 2. Condition Structure: Apply a HAVING clause to filter for singers who have more than one song. Use COUNT on ""song.Singer_ID"" to count the number of songs per singer. 3. Join Structure: Use an INNER JOIN between the ""singer"" and ""song"" tables based on the foreign key relationship ""song.Singer_ID = singer.Singer_ID"" to link each singer with their songs. 4. Aggregation Structure: Use COUNT to count the number of songs for each singer and filter using HAVING to include only those with more than one song.","[('Liliane Bettencourt',), ('Christy Walton',)]","[('Christy Walton',), ('Liliane Bettencourt',)]",,1.0,
Give the name of the student with the most likes.,"[Highschooler.name, Likes.liked_id, Likes.liked_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT Highschooler.name FROM Highschooler JOIN Likes ON Highschooler.ID = Likes.liked_id GROUP BY Highschooler.ID ORDER BY COUNT(Likes.liked_id) DESC LIMIT 1;,SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id ORDER BY count(*) DESC LIMIT 1,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the name of the student. Use COUNT on ""Likes.liked_id"" to count the number of likes each student received. Use ORDER BY in descending order to rank students by the number of likes and LIMIT 1 to get the student with the most likes. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all students who received likes. 3. Join Structure: Use a JOIN between the ""Highschooler"" and ""Likes"" tables based on ""Highschooler.ID = Likes.liked_id"" to associate each student with the likes they received. 4. Aggregation Structure: Use COUNT on ""Likes.liked_id"" to count the number of likes for each student, then use GROUP BY to group the results by student.","[('Cassandra',)]","[('John',)]",,0.0,
What is the average grade of students who have friends?,"[Highschooler.grade, Friend.student_id, Friend.student_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT AVG(Highschooler.grade) FROM Highschooler JOIN Friend ON Highschooler.ID = Friend.student_id;,SELECT avg(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id),network_1,"1. Sequential Structure: Start with the SELECT clause to calculate the average grade of students. Use the AVG function on the ""Highschooler.grade"" field. 2. Condition Structure: Use a WHERE clause to filter students who have friends. This can be determined by checking if the ""Friend.student_id"" exists in the ""Friend"" table. 3. Join Structure: Use a JOIN between the ""Highschooler"" table and the ""Friend"" table on ""Highschooler.ID = Friend.student_id"" to associate students with their friends. 4. Aggregation Structure: Use the AVG function to compute the average grade of students who meet the condition of having friends.","[(10.25,)]","[(10.428571428571429,)]",,0.0,
What are the names of properties that are either houses or apartments with more than 1 room?,"[Properties.property_name, Properties.property_type_code, Properties.room_count, Properties.property_type_code = Ref_Property_Types.property_type_code, Ref_Property_Types.property_type_description, houses, apartments, 1]","Table Other_Available_Features, columns = [*,feature_id,feature_type_code,feature_name,feature_description]
Table Other_Property_Features, columns = [*,property_id,feature_id,property_feature_description]
Table Properties, columns = [*,property_id,property_type_code,date_on_market,date_sold,property_name,property_address,room_count,vendor_requested_price,buyer_offered_price,agreed_selling_price,apt_feature_1,apt_feature_2,apt_feature_3,fld_feature_1,fld_feature_2,fld_feature_3,hse_feature_1,hse_feature_2,hse_feature_3,oth_feature_1,oth_feature_2,oth_feature_3,shp_feature_1,shp_feature_2,shp_feature_3,other_property_details]
Table Ref_Feature_Types, columns = [*,feature_type_code,feature_type_name]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
","Foreign_keys = [Other_Available_Features.feature_type_code = Ref_Feature_Types.feature_type_code,Properties.property_type_code = Ref_Property_Types.property_type_code,Other_Property_Features.property_id = Properties.property_id,Other_Property_Features.feature_id = Other_Available_Features.feature_id]
",NON-NESTED,SELECT Properties.property_name FROM Properties JOIN Ref_Property_Types ON Properties.property_type_code = Ref_Property_Types.property_type_code WHERE (Ref_Property_Types.property_type_description = 'houses' OR Ref_Property_Types.property_type_description = 'apartments') AND Properties.room_count > 1;,"SELECT property_name FROM Properties WHERE property_type_code  =  ""House"" UNION SELECT property_name FROM Properties WHERE property_type_code  =  ""Apartment"" AND room_count  >  1",real_estate_properties,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Properties.property_name"" as we are interested in the names of properties. 2. Condition Structure: Use a WHERE clause to filter properties that are either houses or apartments and have more than 1 room. This involves checking the ""Ref_Property_Types.property_type_description"" for ""houses"" or ""apartments"" and ""Properties.room_count"" for values greater than 1. 3. Join Structure: Use an INNER JOIN between ""Properties"" and ""Ref_Property_Types"" on ""Properties.property_type_code = Ref_Property_Types.property_type_code"" to access the property type descriptions. 4. Aggregation Structure: No aggregation is needed as we are retrieving individual property names.",[],"[('longacre',), ('parc coliseum',), ('parc east',), ('park',), ('renoir',), ('ten tower',), ('the cole',), ('vogue',)]",,0.0,
Give me the description of the treatment type whose total cost is the lowest.,"[Treatment_Types.treatment_type_description, Treatments.cost_of_treatment, Treatments.treatment_type_code = Treatment_Types.treatment_type_code]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,SELECT Treatment_Types.treatment_type_description FROM Treatments JOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code GROUP BY Treatments.treatment_type_code ORDER BY SUM(Treatments.cost_of_treatment) ASC LIMIT 1;,SELECT T1.treatment_type_description FROM Treatment_types AS T1 JOIN Treatments AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code GROUP BY T1.treatment_type_code ORDER BY sum(cost_of_treatment) ASC LIMIT 1,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Treatment_Types.treatment_type_description."" 2. Condition Structure: No specific filtering condition is needed, but we need to find the treatment type with the lowest total cost. This will be achieved using ORDER BY and LIMIT 1. 3. Join Structure: Use a JOIN between the ""Treatments"" and ""Treatment_Types"" tables based on ""treatment_type_code"" to link each treatment with its type description. 4. Aggregation Structure: Use SUM on ""Treatments.cost_of_treatment"" to calculate the total cost for each treatment type, then use ORDER BY to sort by the total cost in ascending order and LIMIT 1 to get the treatment type with the lowest total cost.","[('Take for a Walk',)]","[('Take for a Walk',)]",,1.0,
What are the emails of the professionals living in either the state of Hawaii or the state of Wisconsin?,"[Professionals.email_address, Professionals.state]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,SELECT Professionals.email_address FROM Professionals WHERE Professionals.state = 'Hawaii' OR Professionals.state = 'Wisconsin';,SELECT email_address FROM Professionals WHERE state  =  'Hawaii' OR state  =  'Wisconsin',dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Professionals.email_address"" of professionals living in the specified states. 2. Condition Structure: Use a WHERE clause to filter for professionals whose ""state"" is either 'Hawaii' or 'Wisconsin'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Professionals"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving email addresses based on a specific condition.","[('uboehm@example.org',), ('mekhi.little@example.org',)]","[('uboehm@example.org',), ('mekhi.little@example.org',)]",,1.0,
Tell me the age of the oldest dog.,[Dogs.age],"Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,SELECT MAX(Dogs.age) AS oldest_age FROM Dogs;,SELECT max(age) FROM Dogs,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the maximum age of the dogs, as the question asks for the age of the oldest dog. 2. Condition Structure: No specific filtering condition is required since we are looking for the maximum age across all dogs. 3. Join Structure: No JOIN is necessary because the required data is available within the ""Dogs"" table. 4. Aggregation Structure: Use the MAX function to calculate the maximum age from the ""Dogs.age"" column.","[('9',)]","[('9',)]",,1.0,
How much does each charge type costs? List both charge type and amount.,"[Charges.charge_type, Charges.charge_amount]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,"SELECT Charges.charge_type, Charges.charge_amount FROM Charges;","SELECT charge_type ,  charge_amount FROM Charges",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Charges.charge_type"" and ""Charges.charge_amount"". 2. Condition Structure: No specific filtering condition is required as we want to list all charge types and their corresponding amounts. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Charges"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the charge type and its corresponding amount.","[('Daily Accommodation', 98), ('Drugs', 322), ('Health Check', 640)]","[('Daily Accommodation', 98), ('Drugs', 322), ('Health Check', 640)]",,1.0,
Find the number of owners who do not own any dogs at this moment.,"[Owners.owner_id, Dogs.owner_id, Dogs.date_departed]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,SELECT COUNT(*) FROM Owners WHERE owner_id NOT IN ( SELECT owner_id FROM Dogs WHERE date_departed IS NULL );,SELECT count(*) FROM Owners WHERE owner_id NOT IN ( SELECT owner_id FROM Dogs ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to count the number of owners. Use the FROM clause to specify the Owners table. Apply a WHERE clause to filter owners who do not own any dogs at this moment. This is determined by checking if their owner_id is not present in the Dogs table or if all their dogs have a non-NULL date_departed. 2. Condition Structure: Use the WHERE clause with a subquery to filter out owners whose owner_id exists in the Dogs table with a NULL date_departed, as this indicates they currently own a dog. 3. Join Structure: Not required, as the filtering is done using a subquery on the Dogs table. 4. Aggregation Structure: Use COUNT to calculate the total number of owners who meet the condition.","[(15,)]","[(3,)]",,0.0,
Who owns the youngest dog? Give me his or her last name.,"[Dogs.age, Dogs.owner_id = Owners.owner_id, Owners.last_name]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,SELECT Owners.last_name FROM Dogs JOIN Owners ON Dogs.owner_id = Owners.owner_id ORDER BY Dogs.age ASC LIMIT 1;,SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Owners.last_name"" of the owner of the youngest dog. Use ORDER BY on ""Dogs.age"" in ascending order to find the youngest dog. Use LIMIT 1 to get only the owner of the youngest dog. 2. Condition Structure: No specific filtering condition is needed, as we are interested in the youngest dog. 3. Join Structure: Use a JOIN between the ""Dogs"" and ""Owners"" tables based on ""Dogs.owner_id = Owners.owner_id"" to associate each dog with its owner. 4. Aggregation Structure: No aggregation is needed, as we are only retrieving the last name of the owner of the youngest dog.","[('Nicolas',)]","[('Feil',), ('Fisher',), ('Rippin',)]",,0.0,
"List each owner's first name, last name, and the size of his for her dog.","[Owners.first_name, Owners.last_name, Dogs.size_code, Sizes.size_description, Dogs.owner_id = Owners.owner_id, Dogs.size_code = Sizes.size_code]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Owners.first_name, Owners.last_name, Sizes.size_description FROM Dogs JOIN Owners ON Dogs.owner_id = Owners.owner_id JOIN Sizes ON Dogs.size_code = Sizes.size_code;","SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Owners.first_name,"" ""Owners.last_name,"" and ""Sizes.size_description."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOIN clauses to connect the ""Dogs"" table with the ""Owners"" table on ""Dogs.owner_id = Owners.owner_id"" and the ""Sizes"" table on ""Dogs.size_code = Sizes.size_code"" to link each owner with their dog's size. 4. Aggregation Structure: No aggregation is required as the query is retrieving individual records.","[('Jaclyn', 'Stoltenberg', 'Large'), ('Gay', 'Feil', 'Large'), ('Nora', 'Haley', 'Medium'), ('Rachelle', 'Funk', 'Large'), ('Emelie', 'Mertz', 'Medium'), ('Johann', 'Fisher', 'Medium'), ('Jaclyn', 'Stoltenberg', 'Medium'), ('Rachelle', 'Funk', 'Small'), ('Melisa', 'DuBuque', 'Medium'), ('Kade', 'Rippin', 'Medium'), ('Cindy', 'Schmitt', 'Large'), ('Orlando', 'Price', 'Medium'), ('Rolando', 'Prohaska', 'Small'), ('Rachelle', 'Funk', 'Medium'), ('Lorenz', 'Nicolas', 'Medium')]","[('Jaclyn', 'Stoltenberg', 'LGE'), ('Gay', 'Feil', 'LGE'), ('Nora', 'Haley', 'MED'), ('Rachelle', 'Funk', 'LGE'), ('Emelie', 'Mertz', 'MED'), ('Johann', 'Fisher', 'MED'), ('Jaclyn', 'Stoltenberg', 'MED'), ('Rachelle', 'Funk', 'SML'), ('Melisa', 'DuBuque', 'MED'), ('Kade', 'Rippin', 'MED'), ('Cindy', 'Schmitt', 'LGE'), ('Orlando', 'Price', 'MED'), ('Rolando', 'Prohaska', 'SML'), ('Rachelle', 'Funk', 'MED'), ('Lorenz', 'Nicolas', 'MED')]",,1.0,
What are the date and the operating professional's first name of each treatment?,"[Treatments.date_of_treatment, Professionals.first_name, Treatments.professional_id = Professionals.professional_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Treatments.date_of_treatment, Professionals.first_name FROM Treatments JOIN Professionals ON Treatments.professional_id = Professionals.professional_id;","SELECT T1.date_of_treatment ,  T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id  =  T2.professional_id",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""date_of_treatment"" from the ""Treatments"" table and the ""first_name"" of the professional from the ""Professionals"" table. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Treatments"" table and the ""Professionals"" table based on the foreign key relationship ""Treatments.professional_id = Professionals.professional_id"" to link each treatment with its corresponding professional. 4. Aggregation Structure: No aggregation is needed as the query only requires listing the date and professional's first name for each treatment.","[('2018-03-19 04:39:54', 'Monte'), ('2018-03-15 20:25:34', 'Domenica'), ('2018-03-08 05:26:23', 'Vernice'), ('2018-03-01 04:14:46', 'Karley'), ('2018-03-23 13:52:10', 'Sigurd'), ('2018-03-11 04:23:15', 'Vernice'), ('2018-03-10 11:45:58', 'Sigurd'), ('2018-03-24 22:25:58', 'Ruben'), ('2018-03-14 19:10:40', 'Domenica'), ('2018-02-28 17:09:43', 'Velva'), ('2018-03-13 12:22:58', 'Danny'), ('2018-03-16 10:27:36', 'Monte'), ('2018-02-26 09:08:53', 'Karley'), ('2018-03-04 20:33:43', 'Monte'), ('2018-03-15 19:10:02', 'Ruben')]","[('2018-03-19 04:39:54', 'Monte'), ('2018-03-15 20:25:34', 'Domenica'), ('2018-03-08 05:26:23', 'Vernice'), ('2018-03-01 04:14:46', 'Karley'), ('2018-03-23 13:52:10', 'Sigurd'), ('2018-03-11 04:23:15', 'Vernice'), ('2018-03-10 11:45:58', 'Sigurd'), ('2018-03-24 22:25:58', 'Ruben'), ('2018-03-14 19:10:40', 'Domenica'), ('2018-02-28 17:09:43', 'Velva'), ('2018-03-13 12:22:58', 'Danny'), ('2018-03-16 10:27:36', 'Monte'), ('2018-02-26 09:08:53', 'Karley'), ('2018-03-04 20:33:43', 'Monte'), ('2018-03-15 19:10:02', 'Ruben')]",,1.0,
How many dogs went through any treatments?,"[Dogs.dog_id, Treatments.dog_id = Dogs.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,SELECT COUNT(DISTINCT Treatments.dog_id) FROM Dogs JOIN Treatments ON Treatments.dog_id = Dogs.dog_id;,SELECT count(DISTINCT dog_id) FROM Treatments,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""dog_id"" from the ""Treatments"" table, as we are interested in the number of unique dogs that underwent treatments. 2. Condition Structure: No specific filtering condition is required since we are counting all dogs that have any treatment record. 3. Join Structure: Use a JOIN between the ""Dogs"" and ""Treatments"" tables based on ""dog_id"" to ensure we are counting dogs that have treatment records. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Treatments.dog_id"" to count the unique dogs that underwent treatments.","[(9,)]","[(9,)]",,1.0,
What are all the possible breed type and size type combinations?,"[Breeds.breed_name, Sizes.size_description, Dogs.breed_code = Breeds.breed_code, Dogs.size_code = Sizes.size_code]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT DISTINCT Breeds.breed_name, Sizes.size_description FROM Dogs JOIN Breeds ON Dogs.breed_code = Breeds.breed_code JOIN Sizes ON Dogs.size_code = Sizes.size_code;","SELECT DISTINCT breed_code ,  size_code FROM dogs",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct combinations of ""Breeds.breed_name"" and ""Sizes.size_description."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Dogs"" table with the ""Breeds"" table on ""Dogs.breed_code = Breeds.breed_code"" and the ""Sizes"" table on ""Dogs.size_code = Sizes.size_code"" to link each dog with its breed and size. 4. Aggregation Structure: Use DISTINCT to ensure unique combinations of breed type and size type are returned.","[('Eskimo', 'Large'), ('Bulldog', 'Large'), ('Bulldog', 'Medium'), ('Husky', 'Medium'), ('Eskimo', 'Small'), ('Husky', 'Small'), ('Eskimo', 'Medium')]","[('ESK', 'LGE'), ('BUL', 'LGE'), ('BUL', 'MED'), ('HUS', 'MED'), ('ESK', 'SML'), ('HUS', 'SML'), ('ESK', 'MED')]",,0.0,
Find the first names that are used for professionals or owners but are not used as dog names.,"[Professionals.first_name, Owners.first_name, Dogs.name]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,SELECT DISTINCT first_name FROM Professionals WHERE first_name NOT IN (SELECT name FROM Dogs) UNION SELECT DISTINCT first_name FROM Owners WHERE first_name NOT IN (SELECT name FROM Dogs);,SELECT first_name FROM Professionals UNION SELECT first_name FROM Owners EXCEPT SELECT name FROM Dogs,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct first names from the Professionals and Owners tables. Use a UNION to combine the first names from both tables. Use a WHERE clause to filter out names that are also used as dog names in the Dogs table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude names that appear in the Dogs table as dog names. 3. Join Structure: Not required, as the query involves comparing columns across tables without any direct relationships. 4. Aggregation Structure: Not needed, as we are retrieving distinct names without any aggregation.","[('Adelle',), ('Brady',), ('Cindy',), ('Danny',), ('Domenica',), ('Emelie',), ('Ericka',), ('Gay',), ('Heather',), ('Jaclyn',), ('Jayson',), ('Johann',), ('Kade',), ('Karley',), ('Lesly',), ('Lorenz',), ('Melisa',), ('Monte',), ('Nora',), ('Olaf',), ('Orlando',), ('Rachelle',), ('Rolando',), ('Ruben',), ('Sigurd',), ('Taryn',), ('Tre',), ('Velva',), ('Vernice',), ('Winfield',)]","[('Adelle',), ('Brady',), ('Cindy',), ('Danny',), ('Domenica',), ('Emelie',), ('Ericka',), ('Gay',), ('Heather',), ('Jaclyn',), ('Jayson',), ('Johann',), ('Kade',), ('Karley',), ('Lesly',), ('Lorenz',), ('Melisa',), ('Monte',), ('Nora',), ('Olaf',), ('Orlando',), ('Rachelle',), ('Rolando',), ('Ruben',), ('Sigurd',), ('Taryn',), ('Tre',), ('Velva',), ('Vernice',), ('Winfield',)]",,1.0,
What are the names of singers ordered by ascending net worth?,"[singer.Name, singer.Net_Worth_Millions]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,SELECT singer.Name FROM singer ORDER BY singer.Net_Worth_Millions ASC;,SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC,singer,"1. Sequential Structure: Begin with the SELECT clause to specify the required field, which is the ""singer.Name"". 2. Condition Structure: No specific filtering condition is required as we want all singers. 3. Join Structure: No JOIN is required since all necessary information is in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in ascending order based on ""singer.Net_Worth_Millions"".","[('Abigail Johnson',), ('Susanne Klatten',), ('Gina Rinehart',), ('Iris Fontbona',), ('Jacqueline Mars',), ('Alice Walton',), ('Christy Walton',), ('Liliane Bettencourt',)]","[('Abigail Johnson',), ('Susanne Klatten',), ('Gina Rinehart',), ('Iris Fontbona',), ('Jacqueline Mars',), ('Alice Walton',), ('Christy Walton',), ('Liliane Bettencourt',)]",,1.0,
What is the description of the treatment type that costs the least money in total?,"[Treatment_Types.treatment_type_description, Treatments.cost_of_treatment, Treatments.treatment_type_code = Treatment_Types.treatment_type_code]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,SELECT Treatment_Types.treatment_type_description FROM Treatments JOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code GROUP BY Treatment_Types.treatment_type_description ORDER BY SUM(Treatments.cost_of_treatment) ASC LIMIT 1;,SELECT T1.treatment_type_description FROM Treatment_types AS T1 JOIN Treatments AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code GROUP BY T1.treatment_type_code ORDER BY sum(cost_of_treatment) ASC LIMIT 1,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Treatment_Types.treatment_type_description."" 2. Condition Structure: No specific filtering condition is needed, but we need to find the treatment type with the least total cost. This will be achieved using ORDER BY and LIMIT 1. 3. Join Structure: Use a JOIN between the ""Treatments"" and ""Treatment_Types"" tables based on ""treatment_type_code"" to link each treatment with its type description. 4. Aggregation Structure: Use SUM on ""Treatments.cost_of_treatment"" to calculate the total cost for each treatment type, then use ORDER BY to sort by the total cost in ascending order and LIMIT 1 to get the treatment type with the least total cost.","[('Take for a Walk',)]","[('Take for a Walk',)]",,1.0,
"Find the role, street, city and state of the professionals living in a city that contains the substring 'West'.","[Professionals.role_code, Professionals.street, Professionals.city, Professionals.state, Professionals.city, 'West']","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,"SELECT Professionals.role_code, Professionals.street, Professionals.city, Professionals.state FROM Professionals WHERE Professionals.city LIKE '%West%';","SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""role_code"", ""street"", ""city"", and ""state"" from the ""Professionals"" table. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for professionals whose ""city"" contains the substring 'West'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Professionals"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.","[('Employee', '6915 Oberbrunner Point Suite 491\nGleasonville, LA ', 'West Heidi', 'Indiana')]","[('Employee', '6915 Oberbrunner Point Suite 491\nGleasonville, LA ', 'West Heidi', 'Indiana')]",,1.0,
Which dogs are of the rarest breed? Show their names and treatment dates.,"[Dogs.name, Dogs.breed_code, Breeds.breed_code, Treatments.date_of_treatment, Treatments.dog_id = Dogs.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Dogs.name, Treatments.date_of_treatment FROM Dogs JOIN Breeds ON Dogs.breed_code = Breeds.breed_code JOIN Treatments ON Treatments.dog_id = Dogs.dog_id WHERE Dogs.breed_code = ( SELECT Breeds.breed_code FROM Dogs JOIN Breeds ON Dogs.breed_code = Breeds.breed_code GROUP BY Breeds.breed_code ORDER BY COUNT(Dogs.dog_id) ASC LIMIT 1 );","SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the dogs (""Dogs.name"") and their treatment dates (""Treatments.date_of_treatment""). 2. Condition Structure: Identify the rarest breed by finding the breed with the minimum count of dogs. Use a subquery to count the number of dogs for each breed and filter for the minimum count. 3. Join Structure: Use a JOIN between the ""Dogs"" and ""Breeds"" tables on ""Dogs.breed_code = Breeds.breed_code"" to associate each dog with its breed. Additionally, join the ""Treatments"" table with ""Dogs"" on ""Treatments.dog_id = Dogs.dog_id"" to get the treatment dates. 4. Aggregation Structure: Use COUNT in a subquery to determine the number of dogs for each breed, and filter for the breed with the minimum count.","[('Lyric', '2018-03-19 04:39:54'), ('Houston', '2018-03-15 20:25:34'), ('Lyric', '2018-03-08 05:26:23'), ('Lyric', '2018-03-14 19:10:40'), ('Kacey', '2018-03-15 19:10:02')]","[('Lyric', '2018-03-19 04:39:54'), ('Houston', '2018-03-15 20:25:34'), ('Lyric', '2018-03-08 05:26:23'), ('Lyric', '2018-03-14 19:10:40'), ('Kacey', '2018-03-15 19:10:02')]",,1.0,
What is the sname of every sing that does not have any song?,"[singer.Name, song.Singer_ID, singer.Singer_ID = song.Singer_ID]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NESTED,SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song);,SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song),singer,"1. Sequential Structure: Begin with the SELECT clause to retrieve the names of singers. Use the FROM clause to specify the singer table. Apply a WHERE clause to filter singers who do not have any songs by ensuring their Singer_ID is not present in the song table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude singers whose Singer_ID appears in the song table, meaning they have songs. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Singer_ID entries in the song table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Alice Walton',), ('Abigail Johnson',)]","[('Alice Walton',), ('Abigail Johnson',)]",,1.0,
What is the name of the breed with the most dogs?,"[Dogs.breed_code, Breeds.breed_code = Dogs.breed_code, Breeds.breed_name]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,SELECT Breeds.breed_name FROM Dogs JOIN Breeds ON Dogs.breed_code = Breeds.breed_code GROUP BY Breeds.breed_name ORDER BY COUNT(Dogs.dog_id) DESC LIMIT 1;,SELECT T1.breed_name FROM Breeds AS T1 JOIN Dogs AS T2 ON T1.breed_code  =  T2.breed_code GROUP BY T1.breed_name ORDER BY count(*) DESC LIMIT 1,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""breed_name"" from the Breeds table. Use COUNT to count the number of dogs for each breed. 2. Condition Structure: No specific filtering condition is needed, as we are interested in finding the breed with the most dogs. 3. Join Structure: Use a JOIN between the Dogs and Breeds tables on ""breed_code"" to associate each dog with its breed. 4. Aggregation Structure: Use COUNT to count the number of dogs for each breed, GROUP BY ""breed_name"" to group the results by breed, and ORDER BY the count in descending order to rank breeds by the number of dogs. Use LIMIT 1 to select the breed with the most dogs.","[('Bulldog',)]","[('Bulldog',)]",,1.0,
Count the number of dogs that went through a treatment.,"[Dogs.dog_id, Treatments.dog_id = Dogs.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,SELECT COUNT(DISTINCT Dogs.dog_id) FROM Dogs JOIN Treatments ON Treatments.dog_id = Dogs.dog_id;,SELECT count(DISTINCT dog_id) FROM Treatments,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to count the number of distinct ""dog_id"" values from the ""Treatments"" table, as we are interested in the number of dogs that underwent treatment. 2. Condition Structure: No specific filtering condition is required since we are counting all dogs that have a record in the ""Treatments"" table. 3. Join Structure: Use a JOIN between the ""Dogs"" and ""Treatments"" tables based on the foreign key ""Treatments.dog_id = Dogs.dog_id"" to ensure we are counting valid dog entries. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Dogs.dog_id"" to count the unique dogs that went through treatment.","[(9,)]","[(9,)]",,1.0,
Find the average age of the dogs who went through treatments.,"[Dogs.age, Treatments.dog_id, Treatments.dog_id = Dogs.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,SELECT AVG(Dogs.age) AS average_age FROM Dogs JOIN Treatments ON Treatments.dog_id = Dogs.dog_id;,SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to calculate the average age of the dogs. Use the AVG function on the ""Dogs.age"" field. 2. Condition Structure: No specific filtering condition is required, as we are calculating the average age of all dogs who went through treatments. 3. Join Structure: Use an INNER JOIN between the ""Dogs"" and ""Treatments"" tables based on the foreign key ""Treatments.dog_id = Dogs.dog_id"" to link treatments to the respective dogs. 4. Aggregation Structure: Use the AVG function to compute the average age of the dogs who have undergone treatments.","[(5.466666666666667,)]","[(5.111111111111111,)]",,0.0,
What is the count of singers?,[singer.Singer_ID],"Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,SELECT COUNT(singer.Singer_ID) AS singer_count FROM singer;,SELECT count(*) FROM singer,singer,"1. Sequential Structure: Start with the SELECT clause to count the number of singers. 2. Condition Structure: No specific filtering condition is required as we want the total count of singers. 3. Join Structure: No JOIN is necessary since the required information is available within the ""singer"" table. 4. Aggregation Structure: Use COUNT on ""singer.Singer_ID"" to calculate the total number of singers.","[(8,)]","[(8,)]",,1.0,
How many professionals have performed any treatment to dogs?,"[Professionals.professional_id, Treatments.professional_id, Treatments.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,SELECT COUNT(DISTINCT Professionals.professional_id) FROM Professionals JOIN Treatments ON Professionals.professional_id = Treatments.professional_id;,SELECT count(DISTINCT professional_id) FROM Treatments,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""professional_id"" from the ""Treatments"" table, as we are interested in the number of unique professionals who have performed treatments. 2. Condition Structure: No specific filtering condition is required since we are considering all treatments performed by professionals. 3. Join Structure: Use a JOIN between the ""Professionals"" and ""Treatments"" tables based on ""professional_id"" to link professionals with the treatments they performed. 4. Aggregation Structure: Use COUNT with DISTINCT on ""Professionals.professional_id"" to ensure that each professional is counted only once.","[(8,)]","[(8,)]",,1.0,
Return the number of likes that the high schooler named Kyle has.,"[Highschooler.name, Highschooler.ID, Likes.liked_id, Likes.student_id = Highschooler.ID, Kyle]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT COUNT(Likes.liked_id) FROM Highschooler JOIN Likes ON Highschooler.ID = Likes.liked_id WHERE Highschooler.name = 'Kyle';,"SELECT count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.name  =  ""Kyle""",network_1,"1. Sequential Structure: Start with the SELECT clause to count the number of likes associated with the high schooler named Kyle. Use COUNT on ""Likes.liked_id"" to determine the total number of likes. 2. Condition Structure: Use a WHERE clause to filter for the high schooler named Kyle. First, find Kyle's ID from the ""Highschooler"" table using the ""Highschooler.name"" field. Then, filter the ""Likes"" table where ""Likes.liked_id"" matches Kyle's ID. 3. Join Structure: Use a JOIN between the ""Highschooler"" and ""Likes"" tables to connect the high schooler with their likes based on ""Highschooler.ID"" and ""Likes.liked_id."" 4. Aggregation Structure: Use COUNT to aggregate the total number of likes for Kyle.","[(1,)]","[(1,)]",,1.0,
"What are each owner's first name, last name, and the size of their dog?","[Owners.first_name, Owners.last_name, Dogs.size_code, Sizes.size_description, Dogs.owner_id = Owners.owner_id, Dogs.size_code = Sizes.size_code]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Owners.first_name, Owners.last_name, Sizes.size_description FROM Dogs JOIN Owners ON Dogs.owner_id = Owners.owner_id JOIN Sizes ON Dogs.size_code = Sizes.size_code;","SELECT T1.first_name ,  T1.last_name ,  T2.size_code FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Owners.first_name,"" ""Owners.last_name,"" and ""Sizes.size_description."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOIN clauses to connect the ""Dogs"" table with the ""Owners"" table on ""Dogs.owner_id = Owners.owner_id"" and the ""Sizes"" table on ""Dogs.size_code = Sizes.size_code"" to link each owner with their dog's size. 4. Aggregation Structure: No aggregation is required as the query only retrieves specific fields without any summarization.","[('Jaclyn', 'Stoltenberg', 'Large'), ('Gay', 'Feil', 'Large'), ('Nora', 'Haley', 'Medium'), ('Rachelle', 'Funk', 'Large'), ('Emelie', 'Mertz', 'Medium'), ('Johann', 'Fisher', 'Medium'), ('Jaclyn', 'Stoltenberg', 'Medium'), ('Rachelle', 'Funk', 'Small'), ('Melisa', 'DuBuque', 'Medium'), ('Kade', 'Rippin', 'Medium'), ('Cindy', 'Schmitt', 'Large'), ('Orlando', 'Price', 'Medium'), ('Rolando', 'Prohaska', 'Small'), ('Rachelle', 'Funk', 'Medium'), ('Lorenz', 'Nicolas', 'Medium')]","[('Jaclyn', 'Stoltenberg', 'LGE'), ('Gay', 'Feil', 'LGE'), ('Nora', 'Haley', 'MED'), ('Rachelle', 'Funk', 'LGE'), ('Emelie', 'Mertz', 'MED'), ('Johann', 'Fisher', 'MED'), ('Jaclyn', 'Stoltenberg', 'MED'), ('Rachelle', 'Funk', 'SML'), ('Melisa', 'DuBuque', 'MED'), ('Kade', 'Rippin', 'MED'), ('Cindy', 'Schmitt', 'LGE'), ('Orlando', 'Price', 'MED'), ('Rolando', 'Prohaska', 'SML'), ('Rachelle', 'Funk', 'MED'), ('Lorenz', 'Nicolas', 'MED')]",,1.0,
"Which professionals have done at least two treatments? List the professional's id, role, and first name.","[Professionals.professional_id, Professionals.role_code, Professionals.first_name, Treatments.professional_id = Professionals.professional_id, Treatments.treatment_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Professionals.professional_id, Professionals.role_code, Professionals.first_name FROM Professionals JOIN Treatments ON Treatments.professional_id = Professionals.professional_id GROUP BY Professionals.professional_id, Professionals.role_code, Professionals.first_name HAVING COUNT(Treatments.treatment_id) >= 2;","SELECT T1.professional_id ,  T1.role_code ,  T1.first_name FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Professionals.professional_id,"" ""Professionals.role_code,"" and ""Professionals.first_name."" 2. Condition Structure: Use a HAVING clause to filter for professionals who have performed at least two treatments. This requires counting the number of treatments for each professional. 3. Join Structure: Use an INNER JOIN between the ""Treatments"" table and the ""Professionals"" table on ""Treatments.professional_id = Professionals.professional_id"" to link treatments to the professionals who performed them. 4. Aggregation Structure: Use COUNT on ""Treatments.treatment_id"" to count the number of treatments performed by each professional, then filter with HAVING to include only those with at least two treatments.","[(4, 'Veterenarian', 'Vernice'), (6, 'Veterenarian', 'Ruben'), (8, 'Employee', 'Karley'), (9, 'Veterenarian', 'Monte'), (10, 'Employee', 'Domenica'), (14, 'Employee', 'Sigurd')]","[(4, 'Veterenarian', 'Vernice'), (6, 'Veterenarian', 'Ruben'), (8, 'Employee', 'Karley'), (9, 'Veterenarian', 'Monte'), (10, 'Employee', 'Domenica'), (14, 'Employee', 'Sigurd')]",,1.0,
Please show the most common citizenship of singers.,[singer.Citizenship],"Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,SELECT singer.Citizenship FROM singer GROUP BY singer.Citizenship ORDER BY COUNT(*) DESC LIMIT 1;,SELECT Citizenship FROM singer GROUP BY Citizenship ORDER BY COUNT(*) DESC LIMIT 1,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the citizenship of singers, as the question asks for the most common citizenship. 2. Aggregation Structure: Use COUNT to calculate the number of singers for each citizenship. 3. Grouping Structure: Use GROUP BY on ""singer.Citizenship"" to group singers by their citizenship. 4. Ordering Structure: Use ORDER BY in descending order on the count to rank citizenships by their frequency. 5. Limiting Structure: Use LIMIT 1 to retrieve the most common citizenship. 6. Join Structure: No JOIN is required since all necessary data is within the ""singer"" table.","[('United States',)]","[('United States',)]",,1.0,
How much does the most recent treatment cost?,"[Treatments.cost_of_treatment, Treatments.date_of_treatment]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,SELECT Treatments.cost_of_treatment FROM Treatments ORDER BY Treatments.date_of_treatment DESC LIMIT 1;,SELECT cost_of_treatment FROM Treatments ORDER BY date_of_treatment DESC LIMIT 1,dog_kennels,"1. Sequential Structure: Begin with the SELECT clause to retrieve the cost of the most recent treatment. 2. Condition Structure: Use ORDER BY on ""Treatments.date_of_treatment"" in descending order to sort treatments by the most recent date. 3. Limiting Structure: Use LIMIT 1 to retrieve only the most recent treatment. 4. Join Structure: No JOIN is required since all necessary data is within the ""Treatments"" table. 5. Aggregation Structure: No aggregation is needed as we are retrieving a single value based on the most recent date.","[(407,)]","[(407,)]",,1.0,
List the emails of the professionals who live in the state of Hawaii or the state of Wisconsin.,"[Professionals.email_address, Professionals.state]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,SELECT Professionals.email_address FROM Professionals WHERE Professionals.state = 'Hawaii' OR Professionals.state = 'Wisconsin';,SELECT email_address FROM Professionals WHERE state  =  'Hawaii' OR state  =  'Wisconsin',dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the email addresses of professionals. 2. Condition Structure: Use a WHERE clause to filter professionals who live in either the state of Hawaii or the state of Wisconsin. 3. Join Structure: No JOIN is required since all necessary information is in the ""Professionals"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving email addresses based on a specific condition.","[('uboehm@example.org',), ('mekhi.little@example.org',)]","[('uboehm@example.org',), ('mekhi.little@example.org',)]",,1.0,
What are the birth year and citizenship of singers?,"[singer.Birth_Year, singer.Citizenship]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,"SELECT singer.Birth_Year, singer.Citizenship FROM singer;","SELECT Birth_Year ,  Citizenship FROM singer",singer,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""singer.Birth_Year"" and ""singer.Citizenship"". 2. Condition Structure: No specific filtering condition is required as the query asks for all singers' birth years and citizenships. 3. Join Structure: No JOIN is required since all necessary information is available in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields.","[(1944.0, 'France'), (1948.0, 'United States'), (1949.0, 'United States'), (1942.0, 'Chile'), (1940.0, 'United States'), (1953.0, 'Australia'), (1962.0, 'Germany'), (1961.0, 'United States')]","[(1944.0, 'France'), (1948.0, 'United States'), (1949.0, 'United States'), (1942.0, 'Chile'), (1940.0, 'United States'), (1953.0, 'Australia'), (1962.0, 'Germany'), (1961.0, 'United States')]",,1.0,
"Which owner owns the most dogs? List the owner id, first name and last name.","[Dogs.owner_id, Owners.owner_id, Owners.first_name, Owners.last_name, Dogs.owner_id = Owners.owner_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Owners.owner_id, Owners.first_name, Owners.last_name FROM Dogs JOIN Owners ON Dogs.owner_id = Owners.owner_id GROUP BY Dogs.owner_id ORDER BY COUNT(Dogs.dog_id) DESC LIMIT 1;","SELECT T1.owner_id ,  T2.first_name ,  T2.last_name FROM Dogs AS T1 JOIN Owners AS T2 ON T1.owner_id  =  T2.owner_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""owner_id,"" ""first_name,"" and ""last_name"" of the owner. Use COUNT to count the number of dogs owned by each owner. 2. Condition Structure: No specific filtering condition is required, as we are interested in all owners. 3. Join Structure: Use an INNER JOIN between the ""Dogs"" and ""Owners"" tables on ""Dogs.owner_id = Owners.owner_id"" to link each dog to its respective owner. 4. Aggregation Structure: Use COUNT to count the number of dogs for each owner, GROUP BY ""Dogs.owner_id"" to group the results by owner, and ORDER BY the count in descending order to find the owner with the most dogs. Use LIMIT 1 to return only the top result.","[(14, 'Rachelle', 'Funk')]","[(14, 'Rachelle', 'Funk')]",,1.0,
"Which professional did not operate any treatment on dogs? List the professional's id, role and email.","[Professionals.professional_id, Professionals.role_code, Professionals.email_address, Treatments.professional_id = Professionals.professional_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,"SELECT professional_id, role_code, email_address FROM Professionals WHERE professional_id NOT IN (SELECT professional_id FROM Treatments);","SELECT professional_id ,  role_code ,  email_address FROM Professionals EXCEPT SELECT T1.professional_id ,  T1.role_code ,  T1.email_address FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the professional's ID, role, and email address. Use the FROM clause to specify the Professionals table. Apply a WHERE clause to filter professionals who did not operate any treatment on dogs. 2. Condition Structure: Use the WHERE clause with a subquery to exclude professionals whose IDs appear in the Treatments table, as these professionals have operated treatments. 3. Join Structure: Not required, as the filtering is based on the absence of matching professional IDs in the Treatments table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.","[(1, 'Employee', 'deanna.schuster@example.com'), (2, 'Employee', 'lucile.shanahan@example.org'), (3, 'Employee', 'uboehm@example.org'), (11, 'Employee', 'west.eula@example.net'), (12, 'Veterenarian', 'marquardt.furman@example.org'), (13, 'Veterenarian', 'delphine29@example.com'), (15, 'Employee', 'jeichmann@example.com')]","[(1, 'Employee', 'deanna.schuster@example.com'), (2, 'Employee', 'lucile.shanahan@example.org'), (3, 'Employee', 'uboehm@example.org'), (11, 'Employee', 'west.eula@example.net'), (12, 'Veterenarian', 'marquardt.furman@example.org'), (13, 'Veterenarian', 'delphine29@example.com'), (15, 'Employee', 'jeichmann@example.com')]",,1.0,
"Which professionals live in the state of Indiana or have done treatment on more than 2 treatments? List his or her id, last name and cell phone.","[Professionals.professional_id, Professionals.last_name, Professionals.cell_number, Professionals.state, Treatments.professional_id, Treatments.treatment_id, Treatments.dog_id, Treatments.professional_id = Professionals.professional_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT DISTINCT Professionals.professional_id, Professionals.last_name, Professionals.cell_number FROM Professionals LEFT JOIN Treatments ON Professionals.professional_id = Treatments.professional_id WHERE Professionals.state = 'Indiana' OR Professionals.professional_id IN ( SELECT Treatments.professional_id FROM Treatments GROUP BY Treatments.professional_id HAVING COUNT(Treatments.treatment_id) > 2 );","SELECT professional_id ,  last_name ,  cell_number FROM Professionals WHERE state  =  'Indiana' UNION SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Professionals.professional_id,"" ""Professionals.last_name,"" and ""Professionals.cell_number."" 2. Condition Structure: Use a WHERE clause to filter professionals who either live in the state of Indiana (""Professionals.state = 'Indiana'"") or have performed more than 2 treatments. For the latter condition, use a subquery to count the number of treatments performed by each professional and filter those with a count greater than 2. 3. Join Structure: Use a JOIN between the ""Professionals"" and ""Treatments"" tables on ""Treatments.professional_id = Professionals.professional_id"" to associate professionals with their treatments. 4. Aggregation Structure: Use COUNT in the subquery to count the number of treatments for each professional, and apply the condition ""COUNT(Treatments.treatment_id) > 2"" in the WHERE clause.","[(1, 'Braun', '(275)939-2435x80863'), (8, 'Hyatt', '328.842.3792'), (9, 'Kshlerin', '962-983-8109x3509')]","[(1, 'Braun', '(275)939-2435x80863'), (8, 'Hyatt', '328.842.3792'), (9, 'Kshlerin', '962-983-8109x3509')]",,1.0,
What is the most common singer citizenship ?,"[singer.Citizenship, song.Singer_ID = singer.Singer_ID]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NON-NESTED,"SELECT singer.Citizenship, COUNT(singer.Citizenship) AS COUNT FROM singer GROUP BY singer.Citizenship ORDER BY COUNT DESC LIMIT 1;",select citizenship from singer group by citizenship order by count(*) desc limit 1,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""singer.Citizenship"" and the count of occurrences for each citizenship. Use COUNT to count the occurrences of each citizenship. 2. Condition Structure: No specific filtering condition is needed, as we are analyzing all singers' citizenships. 3. Join Structure: No JOIN is required since the citizenship information is directly available in the ""singer"" table. 4. Aggregation Structure: Use GROUP BY on ""singer.Citizenship"" to group the results by citizenship. Use ORDER BY in descending order of the count to rank the citizenships by frequency, and LIMIT 1 to get the most common citizenship.","[('United States', 4)]","[('United States',)]",,1.0,
Which owner has paid for the most treatments on his or her dogs? List the owner id and last name.,"[Owners.owner_id, Owners.last_name, Treatments.dog_id = Dogs.dog_id, Dogs.owner_id = Owners.owner_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Owners.owner_id, Owners.last_name FROM Treatments JOIN Dogs ON Treatments.dog_id = Dogs.dog_id JOIN Owners ON Dogs.owner_id = Owners.owner_id GROUP BY Owners.owner_id, Owners.last_name ORDER BY COUNT(Treatments.treatment_id) DESC LIMIT 1;","SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Owners.owner_id"" and ""Owners.last_name."" Use an aggregate function (COUNT) to count the number of treatments paid for by each owner. 2. Condition Structure: No specific filtering condition is required, as we are interested in all owners. 3. Join Structure: Use JOIN clauses to connect the ""Treatments"" table with the ""Dogs"" table on ""Treatments.dog_id = Dogs.dog_id"" and then connect the ""Dogs"" table with the ""Owners"" table on ""Dogs.owner_id = Owners.owner_id."" 4. Aggregation Structure: Use COUNT to count the number of treatments for each owner, GROUP BY ""Owners.owner_id"" and ""Owners.last_name"" to group the results by owner, and ORDER BY the count in descending order to find the owner with the most treatments. Use LIMIT 1 to return only the top result.","[(14, 'Funk')]","[(14, 'Funk')]",,1.0,
"For each citizenship, what is the maximum net worth?","[singer.Citizenship, singer.Net_Worth_Millions]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,"SELECT singer.Citizenship, MAX(singer.Net_Worth_Millions) AS max_net_worth FROM singer GROUP BY singer.Citizenship;","SELECT Citizenship ,  max(Net_Worth_Millions) FROM singer GROUP BY Citizenship",singer,"1. Sequential Structure: Begin with the SELECT clause to specify the citizenship and the maximum net worth for each citizenship. 2. Aggregation Structure: Use the MAX function to calculate the maximum net worth for each citizenship. 3. Grouping Structure: Use GROUP BY on ""singer.Citizenship"" to calculate the maximum net worth for each citizenship. 4. Join Structure: No JOIN is required since all necessary data is within the ""singer"" table.","[('Australia', 17.0), ('Chile', 17.4), ('France', 30.0), ('Germany', 14.3), ('United States', 28.8)]","[('Australia', 17.0), ('Chile', 17.4), ('France', 30.0), ('Germany', 14.3), ('United States', 28.8)]",,1.0,
Show the names of students who have a grade higher than 5 and have at least 2 friends.,"[Highschooler.name, Highschooler.grade, Friend.student_id, Friend.friend_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NESTED,"SELECT Highschooler.name FROM Highschooler JOIN Friend ON Highschooler.ID = Friend.student_id WHERE Highschooler.grade > 5 GROUP BY Highschooler.ID, Highschooler.name HAVING COUNT(Friend.friend_id) >= 2;",SELECT T2.name FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id WHERE T2.grade  >  5 GROUP BY T1.student_id HAVING count(*)  >=  2,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of students. Use the FROM clause to specify the Highschooler table. Join it with the Friend table to count the number of friends for each student. Apply a WHERE clause to filter students with a grade higher than 5 and a HAVING clause to ensure they have at least 2 friends. 2. Condition Structure: Use the WHERE clause to filter students with a grade higher than 5. Use the HAVING clause to filter students with at least 2 friends by counting the number of friend relationships in the Friend table. 3. Join Structure: Use an INNER JOIN between the Highschooler and Friend tables, connecting Friend.student_id with Highschooler.ID to count the number of friends for each student. 4. Aggregation Structure: Use COUNT(*) to count the number of friends for each student and apply the HAVING clause to filter students with at least 2 friends.","[('Alexis',), ('Kris',), ('Jordan',), ('Gabriel',), ('Andrew',)]","[('Alexis',), ('Kris',), ('Jordan',), ('Gabriel',), ('Andrew',)]",,1.0,
What are the song titles and singer names?,"[song.Title, singer.Name, song.Singer_ID = singer.Singer_ID]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NON-NESTED,"SELECT song.Title, singer.Name FROM song JOIN singer ON song.Singer_ID = singer.Singer_ID;","SELECT T2.Title ,  T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID",singer,"1. Sequential Structure: Start with the SELECT clause to retrieve ""song.Title"" and ""singer.Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to combine the ""song"" and ""singer"" tables based on the foreign key relationship ""song.Singer_ID = singer.Singer_ID."" 4. Aggregation Structure: No aggregation is required as the query simply retrieves song titles and singer names.","[(""Do They Know It's Christmas"", 'Liliane Bettencourt'), (""F**k It (I Don't Want You Back)"", 'Liliane Bettencourt'), ('Cha Cha Slide', 'Christy Walton'), ('Call on Me', 'Iris Fontbona'), ('Yeah', 'Christy Walton'), ('All This Time', 'Gina Rinehart'), ('Left Outside Alone', 'Jacqueline Mars'), ('Mysterious Girl', 'Susanne Klatten')]","[(""Do They Know It's Christmas"", 'Liliane Bettencourt'), (""F**k It (I Don't Want You Back)"", 'Liliane Bettencourt'), ('Cha Cha Slide', 'Christy Walton'), ('Call on Me', 'Iris Fontbona'), ('Yeah', 'Christy Walton'), ('All This Time', 'Gina Rinehart'), ('Left Outside Alone', 'Jacqueline Mars'), ('Mysterious Girl', 'Susanne Klatten')]",,1.0,
How many available features are there in total?,[Other_Available_Features.feature_id],"Table Other_Available_Features, columns = [*,feature_id,feature_type_code,feature_name,feature_description]
Table Other_Property_Features, columns = [*,property_id,feature_id,property_feature_description]
Table Properties, columns = [*,property_id,property_type_code,date_on_market,date_sold,property_name,property_address,room_count,vendor_requested_price,buyer_offered_price,agreed_selling_price,apt_feature_1,apt_feature_2,apt_feature_3,fld_feature_1,fld_feature_2,fld_feature_3,hse_feature_1,hse_feature_2,hse_feature_3,oth_feature_1,oth_feature_2,oth_feature_3,shp_feature_1,shp_feature_2,shp_feature_3,other_property_details]
Table Ref_Feature_Types, columns = [*,feature_type_code,feature_type_name]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
","Foreign_keys = [Other_Available_Features.feature_type_code = Ref_Feature_Types.feature_type_code,Properties.property_type_code = Ref_Property_Types.property_type_code,Other_Property_Features.property_id = Properties.property_id,Other_Property_Features.feature_id = Other_Available_Features.feature_id]
",EASY,SELECT COUNT(Other_Available_Features.feature_id) AS total_features FROM Other_Available_Features;,SELECT count(*) FROM Other_Available_Features,real_estate_properties,"1. Sequential Structure: Start with the SELECT clause to count the total number of available features. 2. Condition Structure: No specific filtering condition is required as we want the total count of all features. 3. Join Structure: No JOIN is necessary since all required data is in the ""Other_Available_Features"" table. 4. Aggregation Structure: Use COUNT to calculate the total number of features based on the ""feature_id"" column.","[(3,)]","[(3,)]",,1.0,
"Give me the id, role and email of the professionals who did not perform any treatment on dogs.","[Professionals.professional_id, Professionals.role_code, Professionals.email_address, Treatments.professional_id = Professionals.professional_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,"SELECT professional_id, role_code, email_address FROM Professionals WHERE professional_id NOT IN (SELECT professional_id FROM Treatments);","SELECT professional_id ,  role_code ,  email_address FROM Professionals EXCEPT SELECT T1.professional_id ,  T1.role_code ,  T1.email_address FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the professional ID, role, and email address from the Professionals table. Use the FROM clause to specify the Professionals table. Apply a WHERE clause to filter professionals who did not perform any treatment. 2. Condition Structure: Use the WHERE clause with a subquery to exclude professionals whose IDs appear in the Treatments table, indicating they performed treatments. 3. Join Structure: Not required, as the filtering is based on the absence of matching professional IDs in the Treatments table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.","[(1, 'Employee', 'deanna.schuster@example.com'), (2, 'Employee', 'lucile.shanahan@example.org'), (3, 'Employee', 'uboehm@example.org'), (11, 'Employee', 'west.eula@example.net'), (12, 'Veterenarian', 'marquardt.furman@example.org'), (13, 'Veterenarian', 'delphine29@example.com'), (15, 'Employee', 'jeichmann@example.com')]","[(1, 'Employee', 'deanna.schuster@example.com'), (2, 'Employee', 'lucile.shanahan@example.org'), (3, 'Employee', 'uboehm@example.org'), (11, 'Employee', 'west.eula@example.net'), (12, 'Veterenarian', 'marquardt.furman@example.org'), (13, 'Veterenarian', 'delphine29@example.com'), (15, 'Employee', 'jeichmann@example.com')]",,1.0,
Show titles of songs and names of singers.,"[song.Title, singer.Name, song.Singer_ID = singer.Singer_ID]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NON-NESTED,"SELECT song.Title, singer.Name FROM song JOIN singer ON song.Singer_ID = singer.Singer_ID;","SELECT T2.Title ,  T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID",singer,"1. Sequential Structure: Start with the SELECT clause to retrieve ""song.Title"" and ""singer.Name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""song"" and ""singer"" tables based on the foreign key relationship ""song.Singer_ID = singer.Singer_ID"" to link songs with their respective singers. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the titles of songs and the names of singers.","[(""Do They Know It's Christmas"", 'Liliane Bettencourt'), (""F**k It (I Don't Want You Back)"", 'Liliane Bettencourt'), ('Cha Cha Slide', 'Christy Walton'), ('Call on Me', 'Iris Fontbona'), ('Yeah', 'Christy Walton'), ('All This Time', 'Gina Rinehart'), ('Left Outside Alone', 'Jacqueline Mars'), ('Mysterious Girl', 'Susanne Klatten')]","[(""Do They Know It's Christmas"", 'Liliane Bettencourt'), (""F**k It (I Don't Want You Back)"", 'Liliane Bettencourt'), ('Cha Cha Slide', 'Christy Walton'), ('Call on Me', 'Iris Fontbona'), ('Yeah', 'Christy Walton'), ('All This Time', 'Gina Rinehart'), ('Left Outside Alone', 'Jacqueline Mars'), ('Mysterious Girl', 'Susanne Klatten')]",,1.0,
What is the age of the oldest dog?,[Dogs.age],"Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,SELECT MAX(Dogs.age) AS oldest_age FROM Dogs;,SELECT max(age) FROM Dogs,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the maximum age of the dogs, as the question asks for the age of the oldest dog. 2. Condition Structure: No specific filtering condition is required since we are looking for the maximum age across all dogs. 3. Join Structure: No JOIN is necessary because the required data is available within the ""Dogs"" table. 4. Aggregation Structure: Use the MAX function to find the maximum age from the ""Dogs.age"" column.","[('9',)]","[('9',)]",,1.0,
List pairs of the owner's first name and the dogs's name.,"[Owners.first_name, Dogs.name, Dogs.owner_id = Owners.owner_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Owners.first_name, Dogs.name FROM Dogs JOIN Owners ON Dogs.owner_id = Owners.owner_id;","SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the owner's first name (""Owners.first_name"") and the dog's name (""Dogs.name""). 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Dogs"" table and the ""Owners"" table based on the foreign key relationship ""Dogs.owner_id = Owners.owner_id"" to link each dog with its respective owner. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves pairs of data.","[('Jaclyn', 'Kacey'), ('Gay', 'Hipolito'), ('Nora', 'Mavis'), ('Rachelle', 'Houston'), ('Emelie', 'Jeffrey'), ('Johann', 'Merritt'), ('Jaclyn', 'Narciso'), ('Rachelle', 'George'), ('Melisa', 'Bessie'), ('Kade', 'Troy'), ('Cindy', 'Betty'), ('Orlando', 'Holden'), ('Rolando', 'Jesus'), ('Rachelle', 'Lyric'), ('Lorenz', 'Evangeline')]","[('Jaclyn', 'Kacey'), ('Gay', 'Hipolito'), ('Nora', 'Mavis'), ('Rachelle', 'Houston'), ('Emelie', 'Jeffrey'), ('Johann', 'Merritt'), ('Jaclyn', 'Narciso'), ('Rachelle', 'George'), ('Melisa', 'Bessie'), ('Kade', 'Troy'), ('Cindy', 'Betty'), ('Orlando', 'Holden'), ('Rolando', 'Jesus'), ('Rachelle', 'Lyric'), ('Lorenz', 'Evangeline')]",,1.0,
What are each professional's first name and description of the treatment they have performed?,"[Professionals.first_name, Treatment_Types.treatment_type_description, Treatments.professional_id = Professionals.professional_id, Treatments.treatment_type_code = Treatment_Types.treatment_type_code]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Professionals.first_name, Treatment_Types.treatment_type_description FROM Treatments JOIN Professionals ON Treatments.professional_id = Professionals.professional_id JOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;","SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Professionals.first_name"" and ""Treatment_Types.treatment_type_description."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOIN clauses to connect the ""Treatments"" table with ""Professionals"" on ""Treatments.professional_id = Professionals.professional_id"" and with ""Treatment_Types"" on ""Treatments.treatment_type_code = Treatment_Types.treatment_type_code"" to link professionals with the treatments they performed. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the relevant details for each professional and the treatments they performed.","[('Monte', 'Take for a Walk'), ('Domenica', 'Vaccination'), ('Vernice', 'Physical examination'), ('Karley', 'Vaccination'), ('Sigurd', 'Vaccination'), ('Vernice', 'Physical examination'), ('Sigurd', 'Physical examination'), ('Ruben', 'Physical examination'), ('Domenica', 'Take for a Walk'), ('Velva', 'Take for a Walk'), ('Danny', 'Vaccination'), ('Monte', 'Physical examination'), ('Karley', 'Vaccination'), ('Monte', 'Take for a Walk'), ('Ruben', 'Take for a Walk')]","[('Monte', 'Take for a Walk'), ('Domenica', 'Vaccination'), ('Vernice', 'Physical examination'), ('Karley', 'Vaccination'), ('Sigurd', 'Vaccination'), ('Sigurd', 'Physical examination'), ('Ruben', 'Physical examination'), ('Domenica', 'Take for a Walk'), ('Velva', 'Take for a Walk'), ('Danny', 'Vaccination'), ('Monte', 'Physical examination'), ('Ruben', 'Take for a Walk')]",,1.0,
"List the email, cell phone and home phone of all the professionals.","[Professionals.email_address, Professionals.cell_number, Professionals.home_phone]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,"SELECT Professionals.email_address, Professionals.cell_number, Professionals.home_phone FROM Professionals;","SELECT email_address ,  cell_number ,  home_phone FROM professionals",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""email_address,"" ""cell_number,"" and ""home_phone"" from the ""Professionals"" table. 2. Condition Structure: No specific filtering condition is required as the query asks for all professionals. 3. Join Structure: No JOIN is necessary since all the required data is available within the ""Professionals"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all professionals.","[('deanna.schuster@example.com', '(275)939-2435x80863', '+71(6)2898266914'), ('lucile.shanahan@example.org', '889-940-2676', '+02(1)0259033559'), ('uboehm@example.org', '(369)908-7311x065', '325-155-0801x7005'), ('lourdes.lowe@example.net', '00230569697', '312.216.3352'), ('mekhi.little@example.org', '011.193.9081x3186', '1-609-566-2752x25197'), ('jacynthe.mclaughlin@example.net', '139-321-7313', '+43(5)1132733868'), ('lambert62@example.org', '499-434-0215x1628', '022.529.0550x1319'), ('goyette.roosevelt@example.net', '328.842.3792', '891.475.2256'), ('schneider.kathryne@example.org', '962-983-8109x3509', '320-508-6023'), ('jerrod.bahringer@example.org', '461-801-2600', '(230)338-3342x585'), ('west.eula@example.net', '609-405-2990', '(920)304-4499x59146'), ('marquardt.furman@example.org', '1-181-670-9466', '246-951-0080x76716'), ('delphine29@example.com', '880-659-7577x736', '346.594.3739'), ('cole.margarita@example.org', '1-185-137-1945x409', '971.048.3763x9404'), ('jeichmann@example.com', '1-258-285-4707x8020', '1-138-287-3775')]","[('deanna.schuster@example.com', '(275)939-2435x80863', '+71(6)2898266914'), ('lucile.shanahan@example.org', '889-940-2676', '+02(1)0259033559'), ('uboehm@example.org', '(369)908-7311x065', '325-155-0801x7005'), ('lourdes.lowe@example.net', '00230569697', '312.216.3352'), ('mekhi.little@example.org', '011.193.9081x3186', '1-609-566-2752x25197'), ('jacynthe.mclaughlin@example.net', '139-321-7313', '+43(5)1132733868'), ('lambert62@example.org', '499-434-0215x1628', '022.529.0550x1319'), ('goyette.roosevelt@example.net', '328.842.3792', '891.475.2256'), ('schneider.kathryne@example.org', '962-983-8109x3509', '320-508-6023'), ('jerrod.bahringer@example.org', '461-801-2600', '(230)338-3342x585'), ('west.eula@example.net', '609-405-2990', '(920)304-4499x59146'), ('marquardt.furman@example.org', '1-181-670-9466', '246-951-0080x76716'), ('delphine29@example.com', '880-659-7577x736', '346.594.3739'), ('cole.margarita@example.org', '1-185-137-1945x409', '971.048.3763x9404'), ('jeichmann@example.com', '1-258-285-4707x8020', '1-138-287-3775')]",,1.0,
What are the first name and last name of the professionals who have done treatment with cost below average?,"[Professionals.first_name, Professionals.last_name, Treatments.cost_of_treatment, Treatments.professional_id = Professionals.professional_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,"SELECT Professionals.first_name, Professionals.last_name FROM Professionals JOIN Treatments ON Treatments.professional_id = Professionals.professional_id WHERE Treatments.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);","SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the first name and last name of professionals. Use the FROM clause to specify the Professionals table and JOIN it with the Treatments table to link professionals with their treatments. Apply a WHERE clause to filter treatments with a cost below the average treatment cost. 2. Condition Structure: Use the WHERE clause with a subquery to filter for treatments where the cost is less than the average cost of all treatments. 3. Join Structure: Use an INNER JOIN between the Professionals and Treatments tables based on the professional_id to connect professionals with their treatments. 4. Aggregation Structure: Use AVG in a subquery to calculate the average treatment cost, which is then used in the filtering condition.","[('Domenica', 'Jacobs'), ('Vernice', 'Tillman'), ('Karley', 'Hyatt'), ('Vernice', 'Tillman'), ('Ruben', ""O'Reilly""), ('Domenica', 'Jacobs'), ('Monte', 'Kshlerin'), ('Monte', 'Kshlerin')]","[('Taryn', 'Braun'), ('Jayson', 'Ullrich'), ('Olaf', 'Watsica'), ('Vernice', 'Tillman'), ('Danny', 'Considine'), ('Ruben', ""O'Reilly""), ('Velva', 'Hayes'), ('Karley', 'Hyatt'), ('Monte', 'Kshlerin'), ('Domenica', 'Jacobs'), ('Brady', 'Pouros'), ('Winfield', 'Christiansen'), ('Ericka', 'Murazik'), ('Sigurd', 'Frami'), ('Lesly', 'Walter')]",,0.0,
Which professionals have done at least two types of treatments? List the professional id and cell phone.,"[Professionals.professional_id, Professionals.cell_number, Treatments.treatment_type_code, Treatments.professional_id = Professionals.professional_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,"SELECT Professionals.professional_id, Professionals.cell_number FROM Professionals JOIN Treatments ON Treatments.professional_id = Professionals.professional_id GROUP BY Professionals.professional_id, Professionals.cell_number HAVING COUNT(DISTINCT Treatments.treatment_type_code) >= 2;","SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the professional ID and cell phone number. Use the FROM clause to specify the Professionals table and JOIN it with the Treatments table to link professionals with the treatments they have performed. Use GROUP BY to group records by professional ID and cell number, and apply a HAVING clause to filter professionals who have performed at least two different types of treatments. 2. Condition Structure: Use the HAVING clause with COUNT(DISTINCT treatment_type_code) to filter for professionals who have performed at least two distinct types of treatments. 3. Join Structure: Use an INNER JOIN between the Professionals and Treatments tables based on professional_id to connect professionals with their treatments. 4. Aggregation Structure: Use COUNT(DISTINCT treatment_type_code) to count the number of distinct treatment types performed by each professional.","[(6, '139-321-7313'), (9, '962-983-8109x3509'), (10, '461-801-2600'), (14, '1-185-137-1945x409')]","[(4, '00230569697'), (6, '139-321-7313'), (8, '328.842.3792'), (9, '962-983-8109x3509'), (10, '461-801-2600'), (14, '1-185-137-1945x409')]",,0.0,
How many dogs have not gone through any treatment?,"[Dogs.dog_id, Treatments.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,SELECT COUNT(*) FROM Dogs WHERE dog_id NOT IN (SELECT dog_id FROM Treatments);,SELECT count(*) FROM Dogs WHERE dog_id NOT IN ( SELECT dog_id FROM Treatments ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to count the number of dogs. Use the FROM clause to specify the Dogs table. Apply a WHERE clause to filter dogs that have not gone through any treatment by ensuring their dog_id is not present in the Treatments table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude dogs whose dog_id appears in the Treatments table, meaning they have undergone treatment. 3. Join Structure: Not required, as we only need to filter based on the absence of matching dog_id entries in the Treatments table. 4. Aggregation Structure: Use COUNT(*) to count the number of dogs that meet the specified condition.","[(6,)]","[(6,)]",,1.0,
Find the first names of owners living in Virginia and the names of dogs they own.,"[Owners.first_name, Owners.state, Dogs.name, Dogs.owner_id = Owners.owner_id, Virginia]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Owners.first_name, Dogs.name FROM Owners JOIN Dogs ON Dogs.owner_id = Owners.owner_id WHERE Owners.state = 'Virginia';","SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T1.state  =  'Virginia'",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the first names of owners (""Owners.first_name"") and the names of their dogs (""Dogs.name""). 2. Condition Structure: Use a WHERE clause to filter for owners who live in Virginia (""Owners.state = 'Virginia'""). 3. Join Structure: Use an INNER JOIN between the ""Dogs"" and ""Owners"" tables based on the foreign key relationship ""Dogs.owner_id = Owners.owner_id"" to associate each dog with its owner. 4. Aggregation Structure: No aggregation is needed as the query simply retrieves matching records.","[('Melisa', 'Bessie')]","[('Melisa', 'Bessie')]",,1.0,
List the first name of all the professionals along with the description of the treatment they have done.,"[Professionals.first_name, Treatment_Types.treatment_type_description, Treatments.professional_id = Professionals.professional_id, Treatments.treatment_type_code = Treatment_Types.treatment_type_code]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Professionals.first_name, Treatment_Types.treatment_type_description FROM Professionals JOIN Treatments ON Treatments.professional_id = Professionals.professional_id JOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;","SELECT DISTINCT T1.first_name ,  T3.treatment_type_description FROM professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id JOIN Treatment_types AS T3 ON T2.treatment_type_code  =  T3.treatment_type_code",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Professionals.first_name"" and ""Treatment_Types.treatment_type_description."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Professionals"" table with the ""Treatments"" table on ""Treatments.professional_id = Professionals.professional_id"" and the ""Treatments"" table with the ""Treatment_Types"" table on ""Treatments.treatment_type_code = Treatment_Types.treatment_type_code."" 4. Aggregation Structure: No aggregation is required as the query simply retrieves the relevant fields.","[('Monte', 'Take for a Walk'), ('Domenica', 'Vaccination'), ('Vernice', 'Physical examination'), ('Karley', 'Vaccination'), ('Sigurd', 'Vaccination'), ('Vernice', 'Physical examination'), ('Sigurd', 'Physical examination'), ('Ruben', 'Physical examination'), ('Domenica', 'Take for a Walk'), ('Velva', 'Take for a Walk'), ('Danny', 'Vaccination'), ('Monte', 'Physical examination'), ('Karley', 'Vaccination'), ('Monte', 'Take for a Walk'), ('Ruben', 'Take for a Walk')]","[('Monte', 'Take for a Walk'), ('Domenica', 'Vaccination'), ('Vernice', 'Physical examination'), ('Karley', 'Vaccination'), ('Sigurd', 'Vaccination'), ('Sigurd', 'Physical examination'), ('Ruben', 'Physical examination'), ('Domenica', 'Take for a Walk'), ('Velva', 'Take for a Walk'), ('Danny', 'Vaccination'), ('Monte', 'Physical examination'), ('Ruben', 'Take for a Walk')]",,1.0,
"What are the id, role, and first name of the professionals who have performed two or more treatments?","[Professionals.professional_id,Professionals.role_code,Professionals.first_name,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Professionals.professional_id, Professionals.role_code, Professionals.first_name FROM Professionals JOIN Treatments ON Treatments.professional_id = Professionals.professional_id GROUP BY Professionals.professional_id, Professionals.role_code, Professionals.first_name HAVING COUNT(Treatments.treatment_id) >= 2;","SELECT T1.professional_id ,  T1.role_code ,  T1.first_name FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Professionals.professional_id,"" ""Professionals.role_code,"" and ""Professionals.first_name."" 2. Condition Structure: Use a HAVING clause to filter professionals who have performed two or more treatments. This requires counting the number of treatments performed by each professional. 3. Join Structure: Use an INNER JOIN between the ""Professionals"" and ""Treatments"" tables on ""Treatments.professional_id = Professionals.professional_id"" to link treatments to the professionals who performed them. 4. Aggregation Structure: Use COUNT on ""Treatments.treatment_id"" to count the number of treatments performed by each professional, then filter with HAVING to include only those with two or more treatments.","[(4, 'Veterenarian', 'Vernice'), (6, 'Veterenarian', 'Ruben'), (8, 'Employee', 'Karley'), (9, 'Veterenarian', 'Monte'), (10, 'Employee', 'Domenica'), (14, 'Employee', 'Sigurd')]","[(4, 'Veterenarian', 'Vernice'), (6, 'Veterenarian', 'Ruben'), (8, 'Employee', 'Karley'), (9, 'Veterenarian', 'Monte'), (10, 'Employee', 'Domenica'), (14, 'Employee', 'Sigurd')]",,1.0,
"What are the names of high schoolers who have likes, and how many likes does each have?","[Highschooler.name, Likes.liked_id, Likes.student_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,"SELECT Highschooler.name, COUNT(Likes.liked_id) AS like_count FROM Highschooler JOIN Likes ON Highschooler.ID = Likes.liked_id GROUP BY Highschooler.name;","SELECT T2.name ,  count(*) FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id",network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of high schoolers and the count of likes they have received. Use ""Highschooler.name"" and COUNT on ""Likes.liked_id."" 2. Condition Structure: Use a WHERE clause to ensure that only high schoolers who have received likes are included. 3. Join Structure: Use a JOIN between the ""Highschooler"" table and the ""Likes"" table on ""Highschooler.ID = Likes.liked_id"" to associate each high schooler with the likes they have received. 4. Aggregation Structure: Use COUNT to count the number of likes for each high schooler and GROUP BY ""Highschooler.name"" to group the results by each high schooler's name.","[('Alexis', 1), ('Cassandra', 2), ('Gabriel', 1), ('Haley', 1), ('Jessica', 1), ('Jordan', 1), ('Kris', 2), ('Kyle', 1)]","[('John', 1), ('Alexis', 1), ('Austin', 1), ('Jessica', 1), ('Brittany', 1), ('Gabriel', 1), ('Cassandra', 1), ('Andrew', 1), ('Gabriel', 1), ('Kyle', 1)]",,0.0,
What are the birth years and citizenships of the singers?,"[singer.Birth_Year, singer.Citizenship]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,"SELECT singer.Birth_Year, singer.Citizenship FROM singer;","SELECT Birth_Year ,  Citizenship FROM singer",singer,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""singer.Birth_Year"" and ""singer.Citizenship"". 2. Condition Structure: No specific filtering condition is required as the query asks for all singers' birth years and citizenships. 3. Join Structure: No JOIN is required since all necessary information is available in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields.","[(1944.0, 'France'), (1948.0, 'United States'), (1949.0, 'United States'), (1942.0, 'Chile'), (1940.0, 'United States'), (1953.0, 'Australia'), (1962.0, 'Germany'), (1961.0, 'United States')]","[(1944.0, 'France'), (1948.0, 'United States'), (1949.0, 'United States'), (1942.0, 'Chile'), (1940.0, 'United States'), (1953.0, 'Australia'), (1962.0, 'Germany'), (1961.0, 'United States')]",,1.0,
How many professionals did not operate any treatment on dogs?,"[Professionals.professional_id, Treatments.professional_id, Professionals.professional_id = Treatments.professional_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,SELECT COUNT(professional_id) AS num_professionals FROM Professionals WHERE professional_id NOT IN (SELECT professional_id FROM Treatments);,SELECT count(*) FROM Professionals WHERE professional_id NOT IN ( SELECT professional_id FROM Treatments ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to count the number of professionals. Use the FROM clause to specify the Professionals table. Apply a WHERE clause to filter professionals who did not operate any treatment on dogs by ensuring their professional_id is not present in the Treatments table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude professionals whose professional_id appears in the Treatments table, meaning they have operated treatments. 3. Join Structure: Not required, as we only need to filter based on the absence of matching professional_id entries in the Treatments table. 4. Aggregation Structure: Use COUNT to count the number of professionals who meet the condition.","[(7,)]","[(7,)]",,1.0,
Show the names of singers and the total sales of their songs.,"[singer.Name, song.Sales, song.Singer_ID = singer.Singer_ID]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NON-NESTED,"SELECT singer.Name, SUM(song.Sales) AS Total_Sales FROM singer JOIN song ON song.Singer_ID = singer.Singer_ID GROUP BY singer.Name;","SELECT T1.Name ,  sum(T2.Sales) FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID GROUP BY T1.Name",singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""singer.Name"" and the total sales of their songs. Use the SUM function to calculate the total sales. 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN to combine the ""singer"" and ""song"" tables based on the foreign key relationship ""song.Singer_ID = singer.Singer_ID."" 4. Aggregation Structure: Use SUM to aggregate the ""song.Sales"" for each singer, and GROUP BY ""singer.Name"" to group the results by singer.","[('Christy Walton', 651421.0), ('Gina Rinehart', 292000.0), ('Iris Fontbona', 335000.0), ('Jacqueline Mars', 275000.0), ('Liliane Bettencourt', 1646407.0), ('Susanne Klatten', 261000.0)]","[('Christy Walton', 651421.0), ('Gina Rinehart', 292000.0), ('Iris Fontbona', 335000.0), ('Jacqueline Mars', 275000.0), ('Liliane Bettencourt', 1646407.0), ('Susanne Klatten', 261000.0)]",,1.0,
Show the property type descriptions of properties belonging to that code.,"[Ref_Property_Types.property_type_description,Properties.property_type_code,Properties.property_type_code = Ref_Property_Types.property_type_code]","Table Other_Available_Features, columns = [*,feature_id,feature_type_code,feature_name,feature_description]
Table Other_Property_Features, columns = [*,property_id,feature_id,property_feature_description]
Table Properties, columns = [*,property_id,property_type_code,date_on_market,date_sold,property_name,property_address,room_count,vendor_requested_price,buyer_offered_price,agreed_selling_price,apt_feature_1,apt_feature_2,apt_feature_3,fld_feature_1,fld_feature_2,fld_feature_3,hse_feature_1,hse_feature_2,hse_feature_3,oth_feature_1,oth_feature_2,oth_feature_3,shp_feature_1,shp_feature_2,shp_feature_3,other_property_details]
Table Ref_Feature_Types, columns = [*,feature_type_code,feature_type_name]
Table Ref_Property_Types, columns = [*,property_type_code,property_type_description]
","Foreign_keys = [Other_Available_Features.feature_type_code = Ref_Feature_Types.feature_type_code,Properties.property_type_code = Ref_Property_Types.property_type_code,Other_Property_Features.property_id = Properties.property_id,Other_Property_Features.feature_id = Other_Available_Features.feature_id]
",NON-NESTED,SELECT Ref_Property_Types.property_type_description FROM Properties JOIN Ref_Property_Types ON Properties.property_type_code = Ref_Property_Types.property_type_code;,SELECT T2.property_type_description FROM Properties AS T1 JOIN Ref_Property_Types AS T2 ON T1.property_type_code  =  T2.property_type_code GROUP BY T1.property_type_code,real_estate_properties,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Ref_Property_Types.property_type_description."" 2. Condition Structure: No specific filtering condition is mentioned in the question, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Properties"" table and the ""Ref_Property_Types"" table based on the foreign key relationship ""Properties.property_type_code = Ref_Property_Types.property_type_code"" to link property type codes with their descriptions. 4. Aggregation Structure: No aggregation is required as the query only retrieves property type descriptions.","[('House, Bungalow, etc.',), ('House, Bungalow, etc.',), ('Other, to be determined.',), ('Field, Meadow.',), ('Apartment, Flat, Condo, etc.',), ('Shop, Retail Outlet.',), ('Shop, Retail Outlet.',), ('Apartment, Flat, Condo, etc.',), ('Apartment, Flat, Condo, etc.',), ('Apartment, Flat, Condo, etc.',), ('Other, to be determined.',), ('Apartment, Flat, Condo, etc.',), ('Other, to be determined.',), ('Other, to be determined.',), ('Apartment, Flat, Condo, etc.',)]","[('Apartment, Flat, Condo, etc.',), ('Field, Meadow.',), ('House, Bungalow, etc.',), ('Other, to be determined.',), ('Shop, Retail Outlet.',)]",,1.0,
What is the average age of the dogs who have gone through any treatments?,"[Dogs.age, Treatments.dog_id, Dogs.dog_id = Treatments.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,SELECT AVG(Dogs.age) AS average_age FROM Dogs JOIN Treatments ON Dogs.dog_id = Treatments.dog_id;,SELECT avg(age) FROM Dogs WHERE dog_id IN ( SELECT dog_id FROM Treatments ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to calculate the average age of the dogs. Use the AVG function on the ""Dogs.age"" field. 2. Condition Structure: No specific filtering condition is needed, as we are considering all dogs who have undergone treatments. 3. Join Structure: Use an INNER JOIN between the ""Dogs"" and ""Treatments"" tables based on the foreign key relationship ""Dogs.dog_id = Treatments.dog_id"" to link dogs with their treatments. 4. Aggregation Structure: Use the AVG function to compute the average age of the dogs who have undergone treatments.","[(5.466666666666667,)]","[(5.111111111111111,)]",,0.0,
Count the number of dogs of an age below the average.,[Dogs.age],"Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,SELECT COUNT(*) FROM Dogs WHERE age < (SELECT AVG(age) FROM Dogs);,SELECT count(*) FROM Dogs WHERE age  <  ( SELECT avg(age) FROM Dogs ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to count the number of dogs. Use the FROM clause to specify the Dogs table. Apply a WHERE clause to filter dogs whose age is below the average age. 2. Condition Structure: Use the WHERE clause with a subquery to compare each dog's age to the average age of all dogs. The subquery calculates the average age. 3. Join Structure: Not required, as all data is from the Dogs table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average age and COUNT to count the number of dogs meeting the condition.","[(9,)]","[(9,)]",,1.0,
"Find the id, last name and cell phone of the professionals who live in the state of Indiana or have performed more than two treatments.","[Professionals.professional_id, Professionals.last_name, Professionals.cell_number, Professionals.state, Treatments.professional_id = Professionals.professional_id, Treatments.treatment_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Professionals.professional_id, Professionals.last_name, Professionals.cell_number FROM Professionals LEFT JOIN Treatments ON Treatments.professional_id = Professionals.professional_id WHERE Professionals.state = 'Indiana' OR Professionals.professional_id IN ( SELECT Treatments.professional_id FROM Treatments GROUP BY Treatments.professional_id HAVING COUNT(Treatments.treatment_id) > 2 );","SELECT professional_id ,  last_name ,  cell_number FROM Professionals WHERE state  =  'Indiana' UNION SELECT T1.professional_id ,  T1.last_name ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >  2",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the required fields: ""Professionals.professional_id,"" ""Professionals.last_name,"" and ""Professionals.cell_number."" 2. Condition Structure: Use a WHERE clause to filter professionals who live in the state of Indiana (""Professionals.state = 'Indiana'"") or a HAVING clause to filter professionals who have performed more than two treatments. The HAVING clause will be used in conjunction with a GROUP BY clause. 3. Join Structure: Use a LEFT JOIN between the ""Professionals"" table and the ""Treatments"" table on ""Treatments.professional_id = Professionals.professional_id"" to associate professionals with their treatments. 4. Aggregation Structure: Use COUNT on ""Treatments.treatment_id"" to count the number of treatments performed by each professional. Apply the HAVING clause to filter professionals with more than two treatments.","[(1, 'Braun', '(275)939-2435x80863'), (8, 'Hyatt', '328.842.3792'), (8, 'Hyatt', '328.842.3792'), (9, 'Kshlerin', '962-983-8109x3509'), (9, 'Kshlerin', '962-983-8109x3509'), (9, 'Kshlerin', '962-983-8109x3509')]","[(1, 'Braun', '(275)939-2435x80863'), (8, 'Hyatt', '328.842.3792'), (9, 'Kshlerin', '962-983-8109x3509')]",,1.0,
List the cost of each treatment and the corresponding treatment type description.,"[Treatments.cost_of_treatment, Treatment_Types.treatment_type_description, Treatments.treatment_type_code = Treatment_Types.treatment_type_code]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Treatments.cost_of_treatment, Treatment_Types.treatment_type_description FROM Treatments JOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;","SELECT T1.cost_of_treatment ,  T2.treatment_type_description FROM Treatments AS T1 JOIN treatment_types AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Treatments.cost_of_treatment"" and ""Treatment_Types.treatment_type_description."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Treatments"" and ""Treatment_Types"" tables based on the foreign key relationship ""Treatments.treatment_type_code = Treatment_Types.treatment_type_code"" to link each treatment with its type description. 4. Aggregation Structure: No aggregation is required as the question asks for individual treatment costs and their corresponding descriptions.","[(567, 'Take for a Walk'), (147, 'Vaccination'), (429, 'Physical examination'), (266, 'Vaccination'), (668, 'Vaccination'), (313, 'Physical examination'), (852, 'Physical examination'), (407, 'Physical examination'), (139, 'Take for a Walk'), (681, 'Take for a Walk'), (514, 'Vaccination'), (428, 'Physical examination'), (945, 'Vaccination'), (349, 'Take for a Walk'), (656, 'Take for a Walk')]","[(567, 'Take for a Walk'), (147, 'Vaccination'), (429, 'Physical examination'), (266, 'Vaccination'), (668, 'Vaccination'), (313, 'Physical examination'), (852, 'Physical examination'), (407, 'Physical examination'), (139, 'Take for a Walk'), (681, 'Take for a Walk'), (514, 'Vaccination'), (428, 'Physical examination'), (945, 'Vaccination'), (349, 'Take for a Walk'), (656, 'Take for a Walk')]",,1.0,
Show different citizenship of singers and the number of singers of each citizenship.,"[singer.Citizenship, singer.Singer_ID]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,"SELECT singer.Citizenship, COUNT(singer.Singer_ID) AS number_of_singers FROM singer GROUP BY singer.Citizenship;","SELECT Citizenship ,  COUNT(*) FROM singer GROUP BY Citizenship",singer,"1. Sequential Structure: Begin with the SELECT clause to specify the citizenship and the count of singers for each citizenship. 2. Aggregation Structure: Use COUNT to calculate the number of singers for each citizenship. 3. Grouping Structure: Use GROUP BY on ""singer.Citizenship"" to group the results by each citizenship. 4. Join Structure: No JOIN is required since all necessary data is within the ""singer"" table.","[('Australia', 1), ('Chile', 1), ('France', 1), ('Germany', 1), ('United States', 4)]","[('Australia', 1), ('Chile', 1), ('France', 1), ('Germany', 1), ('United States', 4)]",,1.0,
What are the arriving date and the departing date of all the dogs?,"[Dogs.date_arrived, Dogs.date_departed]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,"SELECT Dogs.date_arrived, Dogs.date_departed FROM Dogs;","SELECT date_arrived ,  date_departed FROM Dogs",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Dogs.date_arrived"" and ""Dogs.date_departed"". 2. Condition Structure: No specific filtering condition is required as the query asks for the arriving and departing dates of all dogs. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Dogs"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the arriving and departing dates for all dogs.","[('2017-09-08 20:10:13', '2018-03-25 06:58:44'), ('2017-12-22 05:02:02', '2018-03-25 02:11:32'), ('2017-06-25 10:14:05', '2018-03-25 10:25:46'), ('2017-04-20 00:58:55', '2018-03-24 19:12:22'), ('2017-10-25 00:55:34', '2018-03-25 04:50:22'), ('2017-04-15 09:25:31', '2018-03-25 13:07:04'), ('2017-05-06 08:03:52', '2018-03-25 06:29:10'), ('2017-10-16 20:06:21', '2018-03-25 02:47:40'), ('2018-01-17 11:44:16', '2018-03-25 06:46:07'), ('2017-12-29 06:08:26', '2018-03-25 04:42:14'), ('2017-07-25 15:19:07', '2018-03-25 15:05:16'), ('2017-10-24 04:45:13', '2018-03-25 14:15:41'), ('2018-01-02 03:15:29', '2018-03-25 05:07:47'), ('2017-06-18 19:45:38', '2018-03-24 23:48:59'), ('2017-12-29 23:24:13', '2018-03-24 19:36:59')]","[('2017-09-08 20:10:13', '2018-03-25 06:58:44'), ('2017-12-22 05:02:02', '2018-03-25 02:11:32'), ('2017-06-25 10:14:05', '2018-03-25 10:25:46'), ('2017-04-20 00:58:55', '2018-03-24 19:12:22'), ('2017-10-25 00:55:34', '2018-03-25 04:50:22'), ('2017-04-15 09:25:31', '2018-03-25 13:07:04'), ('2017-05-06 08:03:52', '2018-03-25 06:29:10'), ('2017-10-16 20:06:21', '2018-03-25 02:47:40'), ('2018-01-17 11:44:16', '2018-03-25 06:46:07'), ('2017-12-29 06:08:26', '2018-03-25 04:42:14'), ('2017-07-25 15:19:07', '2018-03-25 15:05:16'), ('2017-10-24 04:45:13', '2018-03-25 14:15:41'), ('2018-01-02 03:15:29', '2018-03-25 05:07:47'), ('2017-06-18 19:45:38', '2018-03-24 23:48:59'), ('2017-12-29 23:24:13', '2018-03-24 19:36:59')]",,1.0,
What are the names of the singers who are not French citizens?,"[singer.Name, singer.Citizenship]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NESTED,SELECT Name FROM singer WHERE Citizenship != 'French';,"SELECT Name FROM singer WHERE Citizenship != ""France""",singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of singers. Use the FROM clause to specify the singer table. Apply a WHERE clause to filter singers who are not French citizens. 2. Condition Structure: Use the WHERE clause to exclude singers whose citizenship is 'French'. 3. Join Structure: Not required, as all the necessary data is in the singer table. 4. Aggregation Structure: Not needed, as we are retrieving specific records without any aggregation.","[('Liliane Bettencourt',), ('Christy Walton',), ('Alice Walton',), ('Iris Fontbona',), ('Jacqueline Mars',), ('Gina Rinehart',), ('Susanne Klatten',), ('Abigail Johnson',)]","[('Christy Walton',), ('Alice Walton',), ('Iris Fontbona',), ('Jacqueline Mars',), ('Gina Rinehart',), ('Susanne Klatten',), ('Abigail Johnson',)]",,1.0,
List the arrival date and the departure date for all the dogs.,"[Dogs.date_arrived, Dogs.date_departed]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,"SELECT Dogs.date_arrived, Dogs.date_departed FROM Dogs;","SELECT date_arrived ,  date_departed FROM Dogs",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to specify the fields needed, which are ""Dogs.date_arrived"" and ""Dogs.date_departed"". 2. Condition Structure: No specific filtering condition is required as the query asks for all dogs. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Dogs"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the arrival and departure dates for all dogs.","[('2017-09-08 20:10:13', '2018-03-25 06:58:44'), ('2017-12-22 05:02:02', '2018-03-25 02:11:32'), ('2017-06-25 10:14:05', '2018-03-25 10:25:46'), ('2017-04-20 00:58:55', '2018-03-24 19:12:22'), ('2017-10-25 00:55:34', '2018-03-25 04:50:22'), ('2017-04-15 09:25:31', '2018-03-25 13:07:04'), ('2017-05-06 08:03:52', '2018-03-25 06:29:10'), ('2017-10-16 20:06:21', '2018-03-25 02:47:40'), ('2018-01-17 11:44:16', '2018-03-25 06:46:07'), ('2017-12-29 06:08:26', '2018-03-25 04:42:14'), ('2017-07-25 15:19:07', '2018-03-25 15:05:16'), ('2017-10-24 04:45:13', '2018-03-25 14:15:41'), ('2018-01-02 03:15:29', '2018-03-25 05:07:47'), ('2017-06-18 19:45:38', '2018-03-24 23:48:59'), ('2017-12-29 23:24:13', '2018-03-24 19:36:59')]","[('2017-09-08 20:10:13', '2018-03-25 06:58:44'), ('2017-12-22 05:02:02', '2018-03-25 02:11:32'), ('2017-06-25 10:14:05', '2018-03-25 10:25:46'), ('2017-04-20 00:58:55', '2018-03-24 19:12:22'), ('2017-10-25 00:55:34', '2018-03-25 04:50:22'), ('2017-04-15 09:25:31', '2018-03-25 13:07:04'), ('2017-05-06 08:03:52', '2018-03-25 06:29:10'), ('2017-10-16 20:06:21', '2018-03-25 02:47:40'), ('2018-01-17 11:44:16', '2018-03-25 06:46:07'), ('2017-12-29 06:08:26', '2018-03-25 04:42:14'), ('2017-07-25 15:19:07', '2018-03-25 15:05:16'), ('2017-10-24 04:45:13', '2018-03-25 14:15:41'), ('2018-01-02 03:15:29', '2018-03-25 05:07:47'), ('2017-06-18 19:45:38', '2018-03-24 23:48:59'), ('2017-12-29 23:24:13', '2018-03-24 19:36:59')]",,1.0,
Find the minimum grade of students who have no friends.,"[Highschooler.grade, Highschooler.ID, Friend.student_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NESTED,SELECT MIN(grade) FROM Highschooler WHERE ID NOT IN (SELECT student_id FROM Friend);,SELECT min(grade) FROM Highschooler WHERE id NOT IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id),network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the minimum grade. Use the FROM clause to specify the Highschooler table. Apply a WHERE clause to filter students who have no friends by ensuring their ID is not present in the Friend table as a student_id. 2. Condition Structure: Use the WHERE clause with a subquery to exclude students whose ID appears in the Friend table as a student_id, meaning they have friends. 3. Join Structure: Not required, as we only need to filter based on the absence of matching student_id entries in the Friend table. 4. Aggregation Structure: Use the MIN function to find the minimum grade among the filtered students who have no friends.","[(10,)]","[(10,)]",,1.0,
Show the names of students who have at least 2 likes.,"[Highschooler.name, Likes.student_id, Likes.liked_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT Highschooler.name FROM Highschooler JOIN Likes ON Highschooler.ID = Likes.student_id GROUP BY Highschooler.ID HAVING COUNT(Likes.liked_id) >= 2;,SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  2,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of students. Use the ""Highschooler.name"" field for this purpose. 2. Condition Structure: Use a HAVING clause to filter students who have at least 2 likes. This requires counting the number of likes for each student. 3. Join Structure: Use a JOIN between the ""Highschooler"" table and the ""Likes"" table on ""Highschooler.ID = Likes.student_id"" to associate each student with their likes. 4. Aggregation Structure: Use COUNT on ""Likes.liked_id"" to count the number of likes for each student, then filter with HAVING to select students with at least 2 likes.",[],[],,1.0,
"What are the email, cell phone and home phone of each professional?","[Professionals.email_address, Professionals.cell_number, Professionals.home_phone]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,"SELECT Professionals.email_address, Professionals.cell_number, Professionals.home_phone FROM Professionals;","SELECT email_address ,  cell_number ,  home_phone FROM professionals",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""Professionals.email_address"", ""Professionals.cell_number"", and ""Professionals.home_phone"". 2. Condition Structure: No specific filtering condition is required as the query asks for all professionals. 3. Join Structure: No JOIN is necessary since all the required information is available in the ""Professionals"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving the specified fields for all professionals.","[('deanna.schuster@example.com', '(275)939-2435x80863', '+71(6)2898266914'), ('lucile.shanahan@example.org', '889-940-2676', '+02(1)0259033559'), ('uboehm@example.org', '(369)908-7311x065', '325-155-0801x7005'), ('lourdes.lowe@example.net', '00230569697', '312.216.3352'), ('mekhi.little@example.org', '011.193.9081x3186', '1-609-566-2752x25197'), ('jacynthe.mclaughlin@example.net', '139-321-7313', '+43(5)1132733868'), ('lambert62@example.org', '499-434-0215x1628', '022.529.0550x1319'), ('goyette.roosevelt@example.net', '328.842.3792', '891.475.2256'), ('schneider.kathryne@example.org', '962-983-8109x3509', '320-508-6023'), ('jerrod.bahringer@example.org', '461-801-2600', '(230)338-3342x585'), ('west.eula@example.net', '609-405-2990', '(920)304-4499x59146'), ('marquardt.furman@example.org', '1-181-670-9466', '246-951-0080x76716'), ('delphine29@example.com', '880-659-7577x736', '346.594.3739'), ('cole.margarita@example.org', '1-185-137-1945x409', '971.048.3763x9404'), ('jeichmann@example.com', '1-258-285-4707x8020', '1-138-287-3775')]","[('deanna.schuster@example.com', '(275)939-2435x80863', '+71(6)2898266914'), ('lucile.shanahan@example.org', '889-940-2676', '+02(1)0259033559'), ('uboehm@example.org', '(369)908-7311x065', '325-155-0801x7005'), ('lourdes.lowe@example.net', '00230569697', '312.216.3352'), ('mekhi.little@example.org', '011.193.9081x3186', '1-609-566-2752x25197'), ('jacynthe.mclaughlin@example.net', '139-321-7313', '+43(5)1132733868'), ('lambert62@example.org', '499-434-0215x1628', '022.529.0550x1319'), ('goyette.roosevelt@example.net', '328.842.3792', '891.475.2256'), ('schneider.kathryne@example.org', '962-983-8109x3509', '320-508-6023'), ('jerrod.bahringer@example.org', '461-801-2600', '(230)338-3342x585'), ('west.eula@example.net', '609-405-2990', '(920)304-4499x59146'), ('marquardt.furman@example.org', '1-181-670-9466', '246-951-0080x76716'), ('delphine29@example.com', '880-659-7577x736', '346.594.3739'), ('cole.margarita@example.org', '1-185-137-1945x409', '971.048.3763x9404'), ('jeichmann@example.com', '1-258-285-4707x8020', '1-138-287-3775')]",,1.0,
List the last name of the owner owning the youngest dog.,"[Dogs.age, Dogs.owner_id = Owners.owner_id, Owners.last_name]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,SELECT Owners.last_name FROM Dogs JOIN Owners ON Dogs.owner_id = Owners.owner_id ORDER BY Dogs.age ASC LIMIT 1;,SELECT T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T2.age  =  ( SELECT max(age) FROM Dogs ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Owners.last_name."" To find the youngest dog, we need to use the ""Dogs.age"" column. Use ORDER BY on ""Dogs.age"" in ascending order to rank dogs by age, and LIMIT 1 to select the youngest dog. 2. Condition Structure: No specific filtering condition is required since we are only interested in the youngest dog. 3. Join Structure: Use a JOIN between the ""Dogs"" and ""Owners"" tables based on the foreign key relationship ""Dogs.owner_id = Owners.owner_id"" to associate each dog with its owner. 4. Aggregation Structure: No aggregation is needed as we are only retrieving the last name of the owner of the youngest dog.","[('Nicolas',)]","[('Feil',), ('Fisher',), ('Rippin',)]",,0.0,
Which dogs have not cost their owner more than 1000 for treatment ? List the dog names .,"[Dogs.name, Treatments.dog_id, Treatments.cost_of_treatment, Treatments.dog_id = Dogs.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,"SELECT Dogs.name FROM Dogs JOIN Treatments ON Dogs.dog_id = Treatments.dog_id GROUP BY Dogs.dog_id, Dogs.name HAVING SUM(Treatments.cost_of_treatment) <= 1000;",select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of dogs. Use the FROM clause to specify the Dogs table and JOIN it with the Treatments table to link dogs with their treatment costs. Use a GROUP BY clause to group treatments by dog_id, allowing us to calculate the total cost of treatments for each dog. Apply a HAVING clause to filter dogs whose total treatment cost is not more than 1000. 2. Condition Structure: Use the HAVING clause with SUM(cost_of_treatment) to filter for dogs whose total treatment cost is less than or equal to 1000. 3. Join Structure: Use an INNER JOIN between the Dogs and Treatments tables based on dog_id to connect dogs with their treatment records. 4. Aggregation Structure: Use the SUM function to calculate the total cost of treatments for each dog and filter based on this aggregated value.","[('Kacey',), ('Hipolito',), ('Houston',), ('Narciso',), ('Holden',), ('Jesus',)]","[('Kacey',), ('Hipolito',), ('Mavis',), ('Houston',), ('Jeffrey',), ('Merritt',), ('Narciso',), ('George',), ('Bessie',), ('Betty',), ('Holden',), ('Jesus',)]",,0.0,
What are the names of the dogs for which the owner has not spend more than 1000 for treatment ?,"[Dogs.name, Treatments.dog_id, Treatments.cost_of_treatment, Treatments.dog_id = Dogs.dog_id, Dogs.owner_id = Owners.owner_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,"SELECT Dogs.name FROM Dogs JOIN Treatments ON Dogs.dog_id = Treatments.dog_id JOIN Owners ON Dogs.owner_id = Owners.owner_id GROUP BY Dogs.dog_id, Dogs.name, Dogs.owner_id HAVING SUM(Treatments.cost_of_treatment) <= 1000;",select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum(cost_of_treatment)  >  1000 ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the dogs. Use the FROM clause to specify the Dogs table and JOIN it with the Treatments table to link dogs with their treatment costs. Additionally, JOIN the Owners table to associate dogs with their owners. Use a GROUP BY clause to group by dog_id and owner_id to calculate the total treatment cost per owner for each dog. Apply a HAVING clause to filter out owners who have spent more than 1000 on treatments for their dogs. 2. Condition Structure: Use the HAVING clause to filter for owners whose total treatment cost for their dogs is less than or equal to 1000. 3. Join Structure: Use INNER JOINs between the Dogs, Treatments, and Owners tables based on the relationships Dogs.dog_id = Treatments.dog_id and Dogs.owner_id = Owners.owner_id to connect dogs, their treatments, and their owners. 4. Aggregation Structure: Use SUM to calculate the total treatment cost for each dog grouped by owner and dog, and filter using the HAVING clause.","[('Kacey',), ('Hipolito',), ('Houston',), ('Narciso',), ('Holden',), ('Jesus',)]","[('Kacey',), ('Hipolito',), ('Mavis',), ('Houston',), ('Jeffrey',), ('Merritt',), ('Narciso',), ('George',), ('Bessie',), ('Betty',), ('Holden',), ('Jesus',)]",,0.0,
Which dogs are owned by someone who lives in Virginia? List the owner's first name and the dog's name.,"[Owners.first_name,Owners.state,Dogs.name,Dogs.owner_id = Owners.owner_id,Virginia]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Owners.first_name, Dogs.name FROM Dogs JOIN Owners ON Dogs.owner_id = Owners.owner_id WHERE Owners.state = 'Virginia';","SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id WHERE T1.state  =  'Virginia'",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the owner's first name (""Owners.first_name"") and the dog's name (""Dogs.name""). 2. Condition Structure: Use a WHERE clause to filter for owners who live in the state of Virginia (""Owners.state = 'Virginia'""). 3. Join Structure: Use an INNER JOIN between the ""Dogs"" table and the ""Owners"" table on the foreign key relationship ""Dogs.owner_id = Owners.owner_id"" to associate each dog with its owner. 4. Aggregation Structure: No aggregation is needed as the query only requires listing specific fields.","[('Melisa', 'Bessie')]","[('Melisa', 'Bessie')]",,1.0,
Which professionals have operated a treatment that costs less than the average? Give me theor first names and last names.,"[Professionals.first_name, Professionals.last_name, Treatments.cost_of_treatment, Treatments.professional_id = Professionals.professional_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,"SELECT Professionals.first_name, Professionals.last_name FROM Professionals JOIN Treatments ON Treatments.professional_id = Professionals.professional_id WHERE Treatments.cost_of_treatment < (SELECT AVG(cost_of_treatment) FROM Treatments);","SELECT DISTINCT T1.first_name ,  T1.last_name FROM Professionals AS T1 JOIN Treatments AS T2 WHERE cost_of_treatment  <  ( SELECT avg(cost_of_treatment) FROM Treatments )",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the first and last names of professionals. Use the FROM clause to specify the Professionals table and JOIN it with the Treatments table to link professionals with their treatments. Apply a WHERE clause to filter treatments whose cost is less than the average cost of all treatments. 2. Condition Structure: Use the WHERE clause with a subquery to calculate the average cost of treatments and filter for treatments with costs below this average. 3. Join Structure: Use an INNER JOIN between the Professionals and Treatments tables based on the professional_id to connect professionals with their treatments. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average cost of treatments, which is then used in the filtering condition.","[('Domenica', 'Jacobs'), ('Vernice', 'Tillman'), ('Karley', 'Hyatt'), ('Vernice', 'Tillman'), ('Ruben', ""O'Reilly""), ('Domenica', 'Jacobs'), ('Monte', 'Kshlerin'), ('Monte', 'Kshlerin')]","[('Taryn', 'Braun'), ('Jayson', 'Ullrich'), ('Olaf', 'Watsica'), ('Vernice', 'Tillman'), ('Danny', 'Considine'), ('Ruben', ""O'Reilly""), ('Velva', 'Hayes'), ('Karley', 'Hyatt'), ('Monte', 'Kshlerin'), ('Domenica', 'Jacobs'), ('Brady', 'Pouros'), ('Winfield', 'Christiansen'), ('Ericka', 'Murazik'), ('Sigurd', 'Frami'), ('Lesly', 'Walter')]",,0.0,
Tell me the owner id and last name of the owner who spent the most on treatments of his or her dogs.,"[Owners.owner_id, Owners.last_name, Treatments.cost_of_treatment, Treatments.dog_id = Dogs.dog_id, Dogs.owner_id = Owners.owner_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Owners.owner_id, Owners.last_name FROM Treatments JOIN Dogs ON Treatments.dog_id = Dogs.dog_id JOIN Owners ON Dogs.owner_id = Owners.owner_id GROUP BY Owners.owner_id, Owners.last_name ORDER BY SUM(Treatments.cost_of_treatment) DESC LIMIT 1;","SELECT T1.owner_id ,  T1.last_name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id JOIN Treatments AS T3 ON T2.dog_id  =  T3.dog_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Owners.owner_id"" and ""Owners.last_name."" Use an aggregate function (SUM) on ""Treatments.cost_of_treatment"" to calculate the total treatment cost for each owner. Use ORDER BY in descending order to rank owners by their total spending and LIMIT 1 to get the owner who spent the most. 2. Condition Structure: No specific filtering condition is needed, as we are interested in all owners and their spending. 3. Join Structure: Use JOIN clauses to connect the ""Treatments"" table with the ""Dogs"" table on ""Treatments.dog_id = Dogs.dog_id"" and the ""Dogs"" table with the ""Owners"" table on ""Dogs.owner_id = Owners.owner_id."" 4. Aggregation Structure: Use SUM to calculate the total treatment cost for each owner, GROUP BY ""Owners.owner_id"" and ""Owners.last_name"" to aggregate the spending per owner, and use ORDER BY with LIMIT 1 to find the owner with the highest spending.","[(3, 'Stoltenberg')]","[(14, 'Funk')]",,0.0,
How many owners temporarily do not have any dogs?,"[Owners.owner_id, Dogs.owner_id, Dogs.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,SELECT COUNT(*) FROM Owners WHERE owner_id NOT IN ( SELECT owner_id FROM Dogs WHERE date_adopted IS NULL AND date_departed IS NULL );,SELECT count(*) FROM Owners WHERE owner_id NOT IN ( SELECT owner_id FROM Dogs ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to count the number of owners. Use the FROM clause to specify the Owners table. Apply a WHERE clause to filter owners who temporarily do not have any dogs. This can be achieved by checking for owners whose owner_id is not associated with any dog in the Dogs table. 2. Condition Structure: Use the WHERE clause with a subquery to filter for owners whose owner_id is not present in the Dogs table or whose dogs have been adopted or departed (indicated by non-NULL values in the date_adopted or date_departed columns). 3. Join Structure: Not required, as the filtering is based on the absence of matching owner_id entries in the Dogs table. 4. Aggregation Structure: Use COUNT to calculate the total number of such owners.","[(15,)]","[(3,)]",,0.0,
Find the distinct breed type and size type combinations for dogs.,"[Dogs.breed_code, Dogs.size_code, Dogs.breed_code = Breeds.breed_code, Dogs.size_code = Sizes.size_code]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT DISTINCT Breeds.breed_name, Sizes.size_description FROM Dogs JOIN Breeds ON Dogs.breed_code = Breeds.breed_code JOIN Sizes ON Dogs.size_code = Sizes.size_code;","SELECT DISTINCT breed_code ,  size_code FROM dogs",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct combinations of ""breed_name"" and ""size_description."" 2. Condition Structure: No specific filtering condition is required, so no WHERE clause is needed. 3. Join Structure: Use JOINs to connect the ""Dogs"" table with the ""Breeds"" table on ""Dogs.breed_code = Breeds.breed_code"" and the ""Sizes"" table on ""Dogs.size_code = Sizes.size_code"" to get the breed and size descriptions. 4. Aggregation Structure: Use DISTINCT to ensure unique combinations of breed and size types are returned.","[('Eskimo', 'Large'), ('Bulldog', 'Large'), ('Bulldog', 'Medium'), ('Husky', 'Medium'), ('Eskimo', 'Small'), ('Husky', 'Small'), ('Eskimo', 'Medium')]","[('ESK', 'LGE'), ('BUL', 'LGE'), ('BUL', 'MED'), ('HUS', 'MED'), ('ESK', 'SML'), ('HUS', 'SML'), ('ESK', 'MED')]",,0.0,
List the name of singers in ascending order of net worth.,"[singer.Name, singer.Net_Worth_Millions]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,SELECT singer.Name FROM singer ORDER BY singer.Net_Worth_Millions ASC;,SELECT Name FROM singer ORDER BY Net_Worth_Millions ASC,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""singer.Name"" and ""singer.Net_Worth_Millions"". 2. Condition Structure: No specific filtering condition is required as we want all singers. 3. Join Structure: No JOIN is required since all necessary information is in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed, but use ORDER BY to sort the results in ascending order based on ""singer.Net_Worth_Millions"".","[('Abigail Johnson',), ('Susanne Klatten',), ('Gina Rinehart',), ('Iris Fontbona',), ('Jacqueline Mars',), ('Alice Walton',), ('Christy Walton',), ('Liliane Bettencourt',)]","[('Abigail Johnson',), ('Susanne Klatten',), ('Gina Rinehart',), ('Iris Fontbona',), ('Jacqueline Mars',), ('Alice Walton',), ('Christy Walton',), ('Liliane Bettencourt',)]",,1.0,
Find the id and cell phone of the professionals who operate two or more types of treatments.,"[Professionals.professional_id, Professionals.cell_number, Treatments.professional_id, Treatments.treatment_type_code, Treatments.professional_id = Professionals.professional_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Professionals.professional_id, Professionals.cell_number FROM Professionals JOIN Treatments ON Treatments.professional_id = Professionals.professional_id GROUP BY Professionals.professional_id, Professionals.cell_number HAVING COUNT(DISTINCT Treatments.treatment_type_code) >= 2;","SELECT T1.professional_id ,  T1.cell_number FROM Professionals AS T1 JOIN Treatments AS T2 ON T1.professional_id  =  T2.professional_id GROUP BY T1.professional_id HAVING count(*)  >=  2",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Professionals.professional_id"" and ""Professionals.cell_number."" 2. Condition Structure: Use a HAVING clause to filter professionals who operate on two or more types of treatments. This requires counting distinct ""treatment_type_code"" for each professional. 3. Join Structure: Use a JOIN between the ""Treatments"" and ""Professionals"" tables based on ""Treatments.professional_id = Professionals.professional_id"" to link treatments with the professionals who performed them. 4. Aggregation Structure: Use COUNT with DISTINCT on ""treatment_type_code"" to count the number of unique treatment types for each professional, then filter with HAVING to include only those with two or more treatment types.","[(6, '139-321-7313'), (9, '962-983-8109x3509'), (10, '461-801-2600'), (14, '1-185-137-1945x409')]","[(4, '00230569697'), (6, '139-321-7313'), (8, '328.842.3792'), (9, '962-983-8109x3509'), (10, '461-801-2600'), (14, '1-185-137-1945x409')]",,0.0,
What are the names of students who have 2 or more likes?,"[Highschooler.name, Likes.student_id, Likes.liked_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT Highschooler.name FROM Highschooler JOIN Likes ON Highschooler.ID = Likes.student_id GROUP BY Highschooler.ID HAVING COUNT(Likes.liked_id) >= 2;,SELECT T2.name FROM Likes AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id GROUP BY T1.student_id HAVING count(*)  >=  2,network_1,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of students. Use ""Highschooler.name"" to get the names of students. 2. Condition Structure: Use a HAVING clause to filter students who have 2 or more likes. This requires counting the number of ""Likes.liked_id"" for each ""Likes.student_id."" 3. Join Structure: Use a JOIN between the ""Highschooler"" and ""Likes"" tables. The ""Likes.student_id"" is linked to ""Highschooler.ID"" to associate each student with their likes. 4. Aggregation Structure: Use COUNT on ""Likes.liked_id"" to count the number of likes for each student, then filter with HAVING to select students with 2 or more likes.",[],[],,1.0,
Show the name of singers whose birth year is either 1948 or 1949?,"[singer.Name, singer.Birth_Year, 1948, 1949]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,"SELECT singer.Name FROM singer WHERE singer.Birth_Year IN (1948, 1949);",SELECT Name FROM singer WHERE Birth_Year  =  1948 OR Birth_Year  =  1949,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""singer.Name"" of singers whose birth year is either 1948 or 1949. 2. Condition Structure: Use a WHERE clause to filter for singers whose ""singer.Birth_Year"" is either 1948 or 1949. 3. Join Structure: No JOIN is required since all necessary information is in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.","[('Christy Walton',), ('Alice Walton',)]","[('Christy Walton',), ('Alice Walton',)]",,1.0,
Find the average grade of all students who have some friends.,"[Highschooler.grade, Friend.student_id, Friend.student_id = Highschooler.ID]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",NON-NESTED,SELECT AVG(Highschooler.grade) FROM Highschooler JOIN Friend ON Highschooler.ID = Friend.student_id GROUP BY Highschooler.ID;,SELECT avg(grade) FROM Highschooler WHERE id IN (SELECT T1.student_id FROM Friend AS T1 JOIN Highschooler AS T2 ON T1.student_id  =  T2.id),network_1,"1. Sequential Structure: Start with the SELECT clause to calculate the average grade of students. Use the AVG function on the ""Highschooler.grade"" field. 2. Condition Structure: Use a WHERE clause to filter students who have at least one friend. This can be determined by checking if their ""Highschooler.ID"" exists in the ""Friend.student_id"" column. 3. Join Structure: Use a JOIN between the ""Highschooler"" and ""Friend"" tables to link students with their friends based on ""Highschooler.ID = Friend.student_id."" 4. Aggregation Structure: Use AVG to compute the average grade of the filtered students.","[(10.0,), (11.0,), (12.0,), (11.0,), (9.0,), (10.0,), (11.0,), (9.0,), (12.0,), (9.0,), (9.0,), (10.0,), (11.0,), (12.0,)]","[(10.428571428571429,)]",,0.0,
How many dogs have an age below the average?,[Dogs.age],"Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,SELECT COUNT(*) AS num_dogs FROM Dogs WHERE age < (SELECT AVG(age) FROM Dogs);,SELECT count(*) FROM Dogs WHERE age  <  ( SELECT avg(age) FROM Dogs ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to count the number of dogs. Use the FROM clause to specify the Dogs table. Apply a WHERE clause to filter dogs whose age is below the average age. 2. Condition Structure: Use the WHERE clause with a subquery to compare each dog's age to the average age of all dogs. The subquery calculates the average age from the Dogs table. 3. Join Structure: Not required, as all data is from the Dogs table. 4. Aggregation Structure: Use the AVG function in a subquery to calculate the average age, and use COUNT to count the number of dogs meeting the condition.","[(9,)]","[(9,)]",,1.0,
"For each citizenship, how many singers are from that country?","[singer.Citizenship, singer.Singer_ID]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,"SELECT singer.Citizenship, COUNT(singer.Singer_ID) AS singer_count FROM singer GROUP BY singer.Citizenship;","SELECT Citizenship ,  COUNT(*) FROM singer GROUP BY Citizenship",singer,"1. Sequential Structure: Start with the SELECT clause to specify the citizenship and the count of singers for each citizenship. 2. Aggregation Structure: Use COUNT to calculate the number of singers for each citizenship. 3. Grouping Structure: Use GROUP BY on ""singer.Citizenship"" to group the results by each citizenship. 4. Join Structure: No JOIN is required since all necessary data is within the ""singer"" table.","[('Australia', 1), ('Chile', 1), ('France', 1), ('Germany', 1), ('United States', 4)]","[('Australia', 1), ('Chile', 1), ('France', 1), ('Germany', 1), ('United States', 4)]",,1.0,
"List the date of each treatment, together with the first name of the professional who operated it.","[Treatments.date_of_treatment, Professionals.first_name, Treatments.professional_id = Professionals.professional_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Treatments.date_of_treatment, Professionals.first_name FROM Treatments JOIN Professionals ON Treatments.professional_id = Professionals.professional_id;","SELECT T1.date_of_treatment ,  T2.first_name FROM Treatments AS T1 JOIN Professionals AS T2 ON T1.professional_id  =  T2.professional_id",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Treatments.date_of_treatment"" and ""Professionals.first_name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Treatments"" and ""Professionals"" tables based on the foreign key ""Treatments.professional_id = Professionals.professional_id"" to link each treatment with the professional who performed it. 4. Aggregation Structure: No aggregation is required as the query only involves listing the date of treatment and the professional's first name.","[('2018-03-19 04:39:54', 'Monte'), ('2018-03-15 20:25:34', 'Domenica'), ('2018-03-08 05:26:23', 'Vernice'), ('2018-03-01 04:14:46', 'Karley'), ('2018-03-23 13:52:10', 'Sigurd'), ('2018-03-11 04:23:15', 'Vernice'), ('2018-03-10 11:45:58', 'Sigurd'), ('2018-03-24 22:25:58', 'Ruben'), ('2018-03-14 19:10:40', 'Domenica'), ('2018-02-28 17:09:43', 'Velva'), ('2018-03-13 12:22:58', 'Danny'), ('2018-03-16 10:27:36', 'Monte'), ('2018-02-26 09:08:53', 'Karley'), ('2018-03-04 20:33:43', 'Monte'), ('2018-03-15 19:10:02', 'Ruben')]","[('2018-03-19 04:39:54', 'Monte'), ('2018-03-15 20:25:34', 'Domenica'), ('2018-03-08 05:26:23', 'Vernice'), ('2018-03-01 04:14:46', 'Karley'), ('2018-03-23 13:52:10', 'Sigurd'), ('2018-03-11 04:23:15', 'Vernice'), ('2018-03-10 11:45:58', 'Sigurd'), ('2018-03-24 22:25:58', 'Ruben'), ('2018-03-14 19:10:40', 'Domenica'), ('2018-02-28 17:09:43', 'Velva'), ('2018-03-13 12:22:58', 'Danny'), ('2018-03-16 10:27:36', 'Monte'), ('2018-02-26 09:08:53', 'Karley'), ('2018-03-04 20:33:43', 'Monte'), ('2018-03-15 19:10:02', 'Ruben')]",,1.0,
what are the different names of the singers that have sales more than 300000?,"[singer.Name, song.Sales, song.Singer_ID = singer.Singer_ID, 300000]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NON-NESTED,SELECT DISTINCT singer.Name FROM song JOIN singer ON song.Singer_ID = singer.Singer_ID WHERE song.Sales > 300000;,SELECT DISTINCT T1.Name FROM singer AS T1 JOIN song AS T2 ON T1.Singer_ID  =  T2.Singer_ID WHERE T2.Sales  >  300000,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the distinct names of singers. Use DISTINCT to ensure unique names are returned. 2. Condition Structure: Use a WHERE clause to filter for songs with sales greater than 300,000. 3. Join Structure: Use an INNER JOIN between the ""song"" and ""singer"" tables based on the foreign key relationship ""song.Singer_ID = singer.Singer_ID"" to link songs with their respective singers. 4. Aggregation Structure: No aggregation is needed, but DISTINCT is applied to ensure unique singer names are returned.","[('Liliane Bettencourt',), ('Christy Walton',), ('Iris Fontbona',)]","[('Liliane Bettencourt',), ('Christy Walton',), ('Iris Fontbona',)]",,1.0,
What are the citizenships that are shared by singers with a birth year before 1945 and after 1955?,"[singer.Citizenship, singer.Birth_Year]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NESTED,SELECT DISTINCT Citizenship FROM singer WHERE Birth_Year < 1945 OR Birth_Year > 1955;,SELECT Citizenship FROM singer WHERE Birth_Year  <  1945 INTERSECT SELECT Citizenship FROM singer WHERE Birth_Year  >  1955,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct citizenships. Use the FROM clause to specify the singer table. Apply a WHERE clause to filter singers with a birth year before 1945 or after 1955. 2. Condition Structure: Use the WHERE clause with conditions to filter singers whose birth year is either less than 1945 or greater than 1955. 3. Join Structure: Not required, as all data is available within the singer table. 4. Aggregation Structure: Not needed, as we are retrieving distinct citizenships without any aggregation.","[('France',), ('Chile',), ('United States',), ('Germany',)]","[('United States',)]",,1.0,
What are each owner's first name and their dogs's name?,"[Owners.first_name, Dogs.name, Dogs.owner_id = Owners.owner_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Owners.first_name, Dogs.name FROM Dogs JOIN Owners ON Dogs.owner_id = Owners.owner_id;","SELECT T1.first_name ,  T2.name FROM Owners AS T1 JOIN Dogs AS T2 ON T1.owner_id  =  T2.owner_id",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Owners.first_name"" and ""Dogs.name."" 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use an INNER JOIN between the ""Dogs"" and ""Owners"" tables based on the foreign key relationship ""Dogs.owner_id = Owners.owner_id"" to associate each dog with its respective owner. 4. Aggregation Structure: No aggregation is required as the query simply retrieves the names of owners and their dogs.","[('Jaclyn', 'Kacey'), ('Gay', 'Hipolito'), ('Nora', 'Mavis'), ('Rachelle', 'Houston'), ('Emelie', 'Jeffrey'), ('Johann', 'Merritt'), ('Jaclyn', 'Narciso'), ('Rachelle', 'George'), ('Melisa', 'Bessie'), ('Kade', 'Troy'), ('Cindy', 'Betty'), ('Orlando', 'Holden'), ('Rolando', 'Jesus'), ('Rachelle', 'Lyric'), ('Lorenz', 'Evangeline')]","[('Jaclyn', 'Kacey'), ('Gay', 'Hipolito'), ('Nora', 'Mavis'), ('Rachelle', 'Houston'), ('Emelie', 'Jeffrey'), ('Johann', 'Merritt'), ('Jaclyn', 'Narciso'), ('Rachelle', 'George'), ('Melisa', 'Bessie'), ('Kade', 'Troy'), ('Cindy', 'Betty'), ('Orlando', 'Holden'), ('Rolando', 'Jesus'), ('Rachelle', 'Lyric'), ('Lorenz', 'Evangeline')]",,1.0,
Find the arriving date and the departing date of the dogs that received a treatment.,"[Dogs.date_arrived, Dogs.date_departed, Treatments.dog_id = Dogs.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Dogs.date_arrived, Dogs.date_departed FROM Dogs JOIN Treatments ON Treatments.dog_id = Dogs.dog_id;","SELECT DISTINCT T1.date_arrived ,  T1.date_departed FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve ""Dogs.date_arrived"" and ""Dogs.date_departed."" 2. Condition Structure: Use a WHERE clause to filter for dogs that received a treatment. This can be determined by checking if there is a matching record in the ""Treatments"" table for the ""Dogs.dog_id."" 3. Join Structure: Use an INNER JOIN between the ""Dogs"" and ""Treatments"" tables on ""Treatments.dog_id = Dogs.dog_id"" to link dogs with their treatments. 4. Aggregation Structure: No aggregation is needed as the query only retrieves specific fields for dogs that meet the condition.","[('2017-06-18 19:45:38', '2018-03-24 23:48:59'), ('2017-04-20 00:58:55', '2018-03-24 19:12:22'), ('2017-06-18 19:45:38', '2018-03-24 23:48:59'), ('2017-12-22 05:02:02', '2018-03-25 02:11:32'), ('2017-10-24 04:45:13', '2018-03-25 14:15:41'), ('2017-12-29 06:08:26', '2018-03-25 04:42:14'), ('2017-12-29 23:24:13', '2018-03-24 19:36:59'), ('2017-12-22 05:02:02', '2018-03-25 02:11:32'), ('2017-06-18 19:45:38', '2018-03-24 23:48:59'), ('2017-12-29 06:08:26', '2018-03-25 04:42:14'), ('2017-12-29 23:24:13', '2018-03-24 19:36:59'), ('2018-01-02 03:15:29', '2018-03-25 05:07:47'), ('2017-05-06 08:03:52', '2018-03-25 06:29:10'), ('2017-12-29 06:08:26', '2018-03-25 04:42:14'), ('2017-09-08 20:10:13', '2018-03-25 06:58:44')]","[('2017-06-18 19:45:38', '2018-03-24 23:48:59'), ('2017-04-20 00:58:55', '2018-03-24 19:12:22'), ('2017-12-22 05:02:02', '2018-03-25 02:11:32'), ('2017-10-24 04:45:13', '2018-03-25 14:15:41'), ('2017-12-29 06:08:26', '2018-03-25 04:42:14'), ('2017-12-29 23:24:13', '2018-03-24 19:36:59'), ('2018-01-02 03:15:29', '2018-03-25 05:07:47'), ('2017-05-06 08:03:52', '2018-03-25 06:29:10'), ('2017-09-08 20:10:13', '2018-03-25 06:58:44')]",,1.0,
"Which professionals live in a city containing the substring 'West'? List his or her role, street, city and state.","[Professionals.role_code, Professionals.street, Professionals.city, Professionals.state, Professionals.city]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,"SELECT Professionals.role_code, Professionals.street, Professionals.city, Professionals.state FROM Professionals WHERE Professionals.city LIKE '%West%';","SELECT role_code ,  street ,  city ,  state FROM professionals WHERE city LIKE '%West%'",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the role, street, city, and state of professionals. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for professionals whose city contains the substring 'West'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Professionals"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.","[('Employee', '6915 Oberbrunner Point Suite 491\nGleasonville, LA ', 'West Heidi', 'Indiana')]","[('Employee', '6915 Oberbrunner Point Suite 491\nGleasonville, LA ', 'West Heidi', 'Indiana')]",,1.0,
"Which owners live in the state whose name contains the substring 'North'? List his first name, last name and email.","[Owners.first_name, Owners.last_name, Owners.email_address, Owners.state, 'North']","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,"SELECT Owners.first_name, Owners.last_name, Owners.email_address FROM Owners WHERE Owners.state LIKE '%North%';","SELECT first_name ,  last_name ,  email_address FROM Owners WHERE state LIKE '%North%'",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""Owners.first_name"", ""Owners.last_name"", and ""Owners.email_address"" of the owners. 2. Condition Structure: Use a WHERE clause with the LIKE operator to filter for owners whose ""Owners.state"" contains the substring 'North'. 3. Join Structure: No JOIN is required since all necessary information is in the ""Owners"" table. 4. Aggregation Structure: No aggregation is needed as we are retrieving specific fields based on a condition.","[('Johann', 'Fisher', 'zboncak.madonna@example.net'), ('Cindy', 'Schmitt', 'wpfeffer@example.net')]","[('Johann', 'Fisher', 'zboncak.madonna@example.net'), ('Cindy', 'Schmitt', 'wpfeffer@example.net')]",,1.0,
List the name of singers that do not have any song.,"[singer.Name, song.Singer_ID = singer.Singer_ID]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",NESTED,SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song);,SELECT Name FROM singer WHERE Singer_ID NOT IN (SELECT Singer_ID FROM song),singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of singers. Use the FROM clause to specify the singer table. Apply a WHERE clause to filter singers who do not have any songs by ensuring their Singer_ID is not present in the song table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude singers whose Singer_ID appears in the song table, meaning they have songs. 3. Join Structure: Not required, as we only need to filter based on the absence of matching Singer_ID entries in the song table. 4. Aggregation Structure: Not needed, as no aggregation functions are required for this query.","[('Alice Walton',), ('Abigail Johnson',)]","[('Alice Walton',), ('Abigail Johnson',)]",,1.0,
Find the number of professionals who have ever treated dogs.,"[Professionals.professional_id, Treatments.professional_id = Professionals.professional_id, Treatments.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,SELECT COUNT(DISTINCT Professionals.professional_id) FROM Treatments JOIN Professionals ON Treatments.professional_id = Professionals.professional_id;,SELECT count(DISTINCT professional_id) FROM Treatments,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to count the distinct ""professional_id"" from the ""Professionals"" table, as we are interested in the number of unique professionals who have treated dogs. 2. Condition Structure: No specific filtering condition is required since we are considering all professionals who have treated dogs. 3. Join Structure: Use an INNER JOIN between the ""Treatments"" table and the ""Professionals"" table on ""Treatments.professional_id = Professionals.professional_id"" to link treatments to the professionals who performed them. 4. Aggregation Structure: Use COUNT with DISTINCT to count the unique ""professional_id"" values from the joined data.","[(8,)]","[(8,)]",,1.0,
"Return the owner id, first name and last name of the owner who has the most dogs.","[Owners.owner_id, Owners.first_name, Owners.last_name, Dogs.owner_id = Owners.owner_id, Dogs.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Owners.owner_id, Owners.first_name, Owners.last_name FROM Dogs JOIN Owners ON Dogs.owner_id = Owners.owner_id GROUP BY Owners.owner_id, Owners.first_name, Owners.last_name ORDER BY COUNT(Dogs.dog_id) DESC LIMIT 1;","SELECT T1.owner_id ,  T2.first_name ,  T2.last_name FROM Dogs AS T1 JOIN Owners AS T2 ON T1.owner_id  =  T2.owner_id GROUP BY T1.owner_id ORDER BY count(*) DESC LIMIT 1",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""owner_id,"" ""first_name,"" and ""last_name"" of the owner. Use COUNT to count the number of dogs each owner has. 2. Condition Structure: No specific filtering condition is required, as we are interested in finding the owner with the most dogs. 3. Join Structure: Use an INNER JOIN between the ""Dogs"" and ""Owners"" tables on ""Dogs.owner_id = Owners.owner_id"" to associate each dog with its respective owner. 4. Aggregation Structure: Use COUNT to count the number of dogs per owner, GROUP BY ""Owners.owner_id"" to group the results by owner, and ORDER BY the count in descending order. Use LIMIT 1 to select the owner with the most dogs.","[(14, 'Rachelle', 'Funk')]","[(14, 'Rachelle', 'Funk')]",,1.0,
Which first names are used for professionals or owners but are not used as dog names?,"[Professionals.first_name, Owners.first_name, Dogs.name]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,SELECT DISTINCT first_name FROM Professionals UNION SELECT DISTINCT first_name FROM Owners WHERE first_name NOT IN (SELECT DISTINCT name FROM Dogs);,SELECT first_name FROM Professionals UNION SELECT first_name FROM Owners EXCEPT SELECT name FROM Dogs,dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve distinct first names from the Professionals and Owners tables. Use a UNION to combine the first names from both tables. Then, use a WHERE clause to filter out names that are also used as dog names in the Dogs table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude names that appear in the Dogs.name column. 3. Join Structure: Not required, as the query involves filtering based on names across separate tables without any direct relationships. 4. Aggregation Structure: Not needed, as we are retrieving distinct names without any aggregation.","[('Adelle',), ('Brady',), ('Cindy',), ('Danny',), ('Domenica',), ('Emelie',), ('Ericka',), ('Gay',), ('Heather',), ('Jaclyn',), ('Jayson',), ('Johann',), ('Kade',), ('Karley',), ('Lesly',), ('Lorenz',), ('Melisa',), ('Monte',), ('Nora',), ('Olaf',), ('Orlando',), ('Rachelle',), ('Rolando',), ('Ruben',), ('Sigurd',), ('Taryn',), ('Tre',), ('Velva',), ('Vernice',), ('Winfield',)]","[('Adelle',), ('Brady',), ('Cindy',), ('Danny',), ('Domenica',), ('Emelie',), ('Ericka',), ('Gay',), ('Heather',), ('Jaclyn',), ('Jayson',), ('Johann',), ('Kade',), ('Karley',), ('Lesly',), ('Lorenz',), ('Melisa',), ('Monte',), ('Nora',), ('Olaf',), ('Orlando',), ('Rachelle',), ('Rolando',), ('Ruben',), ('Sigurd',), ('Taryn',), ('Tre',), ('Velva',), ('Vernice',), ('Winfield',)]",,1.0,
Show different citizenships and the maximum net worth of singers of each citizenship.,"[singer.Citizenship, singer.Net_Worth_Millions]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,"SELECT singer.Citizenship, MAX(singer.Net_Worth_Millions) AS max_net_worth FROM singer GROUP BY singer.Citizenship;","SELECT Citizenship ,  max(Net_Worth_Millions) FROM singer GROUP BY Citizenship",singer,"1. Sequential Structure: Begin with the SELECT clause to specify the fields needed, which are the citizenship and the maximum net worth. 2. Aggregation Structure: Use the MAX function to calculate the maximum net worth for singers of each citizenship. 3. Grouping Structure: Use GROUP BY on ""singer.Citizenship"" to calculate the maximum net worth for each citizenship. 4. Join Structure: No JOIN is required since all necessary data is within the ""singer"" table.","[('Australia', 17.0), ('Chile', 17.4), ('France', 30.0), ('Germany', 14.3), ('United States', 28.8)]","[('Australia', 17.0), ('Chile', 17.4), ('France', 30.0), ('Germany', 14.3), ('United States', 28.8)]",,1.0,
"List the name of singers whose citizenship is not ""France"".","[singer.Name, singer.Citizenship]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,SELECT singer.Name FROM singer WHERE singer.Citizenship != 'France';,"SELECT Name FROM singer WHERE Citizenship != ""France""",singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""singer.Name"" of singers whose citizenship is not ""France"". 2. Condition Structure: Use a WHERE clause to filter singers where ""singer.Citizenship"" is not equal to ""France"". 3. Join Structure: No JOIN is required since all necessary information is in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.","[('Christy Walton',), ('Alice Walton',), ('Iris Fontbona',), ('Jacqueline Mars',), ('Gina Rinehart',), ('Susanne Klatten',), ('Abigail Johnson',)]","[('Christy Walton',), ('Alice Walton',), ('Iris Fontbona',), ('Jacqueline Mars',), ('Gina Rinehart',), ('Susanne Klatten',), ('Abigail Johnson',)]",,1.0,
"List the dog name, age and weight of the dogs who have been abandoned? 1 stands for yes, and 0 stands for no.","[Dogs.name, Dogs.age, Dogs.weight, Dogs.abandoned_yn]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",EASY,"SELECT Dogs.name, Dogs.age, Dogs.weight FROM Dogs WHERE Dogs.abandoned_yn = 1;","SELECT name ,  age ,  weight FROM Dogs WHERE abandoned_yn  =  1",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the fields ""Dogs.name"", ""Dogs.age"", and ""Dogs.weight"" for the dogs who have been abandoned. 2. Condition Structure: Use a WHERE clause to filter for dogs where ""Dogs.abandoned_yn"" equals 1, as 1 stands for abandoned. 3. Join Structure: No JOIN is required since all necessary information is available in the ""Dogs"" table. 4. Aggregation Structure: No aggregation is needed, as we are simply retrieving specific fields based on a condition.","[('Kacey', '6', '7.57'), ('Lyric', '4', '4.36'), ('Evangeline', '1', '4.01')]","[('Kacey', '6', '7.57'), ('Lyric', '4', '4.36'), ('Evangeline', '1', '4.01')]",,1.0,
What are the cost and treatment type description of each treatment?,"[Treatments.cost_of_treatment, Treatment_Types.treatment_type_description, Treatments.treatment_type_code = Treatment_Types.treatment_type_code]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NON-NESTED,"SELECT Treatments.cost_of_treatment, Treatment_Types.treatment_type_description FROM Treatments JOIN Treatment_Types ON Treatments.treatment_type_code = Treatment_Types.treatment_type_code;","SELECT T1.cost_of_treatment ,  T2.treatment_type_description FROM Treatments AS T1 JOIN treatment_types AS T2 ON T1.treatment_type_code  =  T2.treatment_type_code",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""cost_of_treatment"" and ""treatment_type_description"" fields. 2. Condition Structure: No specific filtering condition is mentioned, so no WHERE clause is needed. 3. Join Structure: Use a JOIN between the ""Treatments"" table and the ""Treatment_Types"" table based on the foreign key relationship ""Treatments.treatment_type_code = Treatment_Types.treatment_type_code"" to link each treatment with its type description. 4. Aggregation Structure: No aggregation is required as the question asks for details of each treatment.","[(567, 'Take for a Walk'), (147, 'Vaccination'), (429, 'Physical examination'), (266, 'Vaccination'), (668, 'Vaccination'), (313, 'Physical examination'), (852, 'Physical examination'), (407, 'Physical examination'), (139, 'Take for a Walk'), (681, 'Take for a Walk'), (514, 'Vaccination'), (428, 'Physical examination'), (945, 'Vaccination'), (349, 'Take for a Walk'), (656, 'Take for a Walk')]","[(567, 'Take for a Walk'), (147, 'Vaccination'), (429, 'Physical examination'), (266, 'Vaccination'), (668, 'Vaccination'), (313, 'Physical examination'), (852, 'Physical examination'), (407, 'Physical examination'), (139, 'Take for a Walk'), (681, 'Take for a Walk'), (514, 'Vaccination'), (428, 'Physical examination'), (945, 'Vaccination'), (349, 'Take for a Walk'), (656, 'Take for a Walk')]",,1.0,
List the names of the dogs of the rarest breed and the treatment dates of them.,"[Dogs.name, Dogs.breed_code, Breeds.breed_code, Breeds.breed_name, Treatments.date_of_treatment, Treatments.dog_id = Dogs.dog_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,"SELECT Dogs.name, Treatments.date_of_treatment FROM Dogs JOIN Breeds ON Dogs.breed_code = Breeds.breed_code JOIN Treatments ON Treatments.dog_id = Dogs.dog_id WHERE Dogs.breed_code = ( SELECT Breeds.breed_code FROM Breeds JOIN Dogs ON Dogs.breed_code = Breeds.breed_code GROUP BY Breeds.breed_code HAVING COUNT(Dogs.dog_id) = ( SELECT MIN(breed_count) FROM ( SELECT COUNT(Dogs.dog_id) AS breed_count FROM Dogs GROUP BY Dogs.breed_code ) AS BreedCounts ) );","SELECT T1.name ,  T2.date_of_treatment FROM Dogs AS T1 JOIN Treatments AS T2 ON T1.dog_id  =  T2.dog_id WHERE T1.breed_code  =  ( SELECT breed_code FROM Dogs GROUP BY breed_code ORDER BY count(*) ASC LIMIT 1 )",dog_kennels,"1. Sequential Structure: Start with the SELECT clause to retrieve the names of the dogs and their treatment dates. Use the FROM clause to specify the Dogs and Breeds tables, and join them with the Treatments table to get the treatment dates. Apply a WHERE clause to filter for dogs belonging to the rarest breed. 2. Condition Structure: Use a subquery in the WHERE clause to identify the rarest breed by counting the number of dogs for each breed and selecting the breed with the minimum count. 3. Join Structure: Use INNER JOINs between the Dogs and Breeds tables on breed_code to connect dogs with their breeds, and between the Dogs and Treatments tables on dog_id to get the treatment dates. 4. Aggregation Structure: Use COUNT in the subquery to count the number of dogs for each breed and MIN to find the rarest breed.","[('Lyric', '2018-03-19 04:39:54'), ('Houston', '2018-03-15 20:25:34'), ('Lyric', '2018-03-08 05:26:23'), ('Lyric', '2018-03-14 19:10:40'), ('Kacey', '2018-03-15 19:10:02')]","[('Lyric', '2018-03-19 04:39:54'), ('Houston', '2018-03-15 20:25:34'), ('Lyric', '2018-03-08 05:26:23'), ('Lyric', '2018-03-14 19:10:40'), ('Kacey', '2018-03-15 19:10:02')]",,1.0,
What are the names of the singers whose birth years are either 1948 or 1949?,"[singer.Name, singer.Birth_Year, 1948, 1949]","Table singer, columns = [*,Singer_ID,Name,Birth_Year,Net_Worth_Millions,Citizenship]
Table song, columns = [*,Song_ID,Title,Singer_ID,Sales,Highest_Position]
","Foreign_keys = [song.Singer_ID = singer.Singer_ID]
",EASY,"SELECT singer.Name FROM singer WHERE singer.Birth_Year IN (1948, 1949);",SELECT Name FROM singer WHERE Birth_Year  =  1948 OR Birth_Year  =  1949,singer,"1. Sequential Structure: Start with the SELECT clause to retrieve the ""singer.Name"" of singers whose birth years are either 1948 or 1949. 2. Condition Structure: Use a WHERE clause to filter for singers whose ""singer.Birth_Year"" is either 1948 or 1949. 3. Join Structure: No JOIN is required since all necessary information is in the ""singer"" table. 4. Aggregation Structure: No aggregation is needed as we are simply retrieving names based on a specific condition.","[('Christy Walton',), ('Alice Walton',)]","[('Christy Walton',), ('Alice Walton',)]",,1.0,
Find the number of professionals who have not treated any dogs.,"[Professionals.professional_id, Treatments.professional_id, Professionals.professional_id = Treatments.professional_id]","Table Breeds, columns = [*,breed_code,breed_name]
Table Charges, columns = [*,charge_id,charge_type,charge_amount]
Table Dogs, columns = [*,dog_id,owner_id,abandoned_yn,breed_code,size_code,name,age,date_of_birth,gender,weight,date_arrived,date_adopted,date_departed]
Table Owners, columns = [*,owner_id,first_name,last_name,street,city,state,zip_code,email_address,home_phone,cell_number]
Table Professionals, columns = [*,professional_id,role_code,first_name,street,city,state,zip_code,last_name,email_address,home_phone,cell_number]
Table Sizes, columns = [*,size_code,size_description]
Table Treatment_Types, columns = [*,treatment_type_code,treatment_type_description]
Table Treatments, columns = [*,treatment_id,dog_id,professional_id,treatment_type_code,date_of_treatment,cost_of_treatment]
","Foreign_keys = [Dogs.owner_id = Owners.owner_id,Dogs.owner_id = Owners.owner_id,Dogs.size_code = Sizes.size_code,Dogs.breed_code = Breeds.breed_code,Treatments.dog_id = Dogs.dog_id,Treatments.professional_id = Professionals.professional_id,Treatments.treatment_type_code = Treatment_Types.treatment_type_code]
",NESTED,SELECT COUNT(professional_id) AS num_professionals FROM Professionals WHERE professional_id NOT IN (SELECT professional_id FROM Treatments);,SELECT count(*) FROM Professionals WHERE professional_id NOT IN ( SELECT professional_id FROM Treatments ),dog_kennels,"1. Sequential Structure: Start with the SELECT clause to count the number of professionals. Use the FROM clause to specify the Professionals table. Apply a WHERE clause to filter professionals who have not treated any dogs by ensuring their professional_id is not present in the Treatments table. 2. Condition Structure: Use the WHERE clause with a subquery to exclude professionals whose professional_id appears in the Treatments table, meaning they have treated dogs. 3. Join Structure: Not required, as we only need to filter based on the absence of matching professional_id entries in the Treatments table. 4. Aggregation Structure: Use COUNT to calculate the total number of professionals who meet the condition of not treating any dogs.","[(7,)]","[(7,)]",,1.0,
How many likes correspond to each student id?,"[Likes.student_id, Likes.liked_id]","Table Friend, columns = [*,student_id,friend_id]
Table Highschooler, columns = [*,ID,name,grade]
Table Likes, columns = [*,student_id,liked_id]
","Foreign_keys = [Friend.friend_id = Highschooler.ID,Friend.student_id = Highschooler.ID,Likes.student_id = Highschooler.ID,Likes.liked_id = Highschooler.ID]
",EASY,"SELECT Likes.student_id, COUNT(Likes.liked_id) AS like_count FROM Likes GROUP BY Likes.student_id;","SELECT student_id ,  count(*) FROM Likes GROUP BY student_id",network_1,"1. Sequential Structure: Begin with the SELECT clause to specify the student ID and the count of likes corresponding to each student. 2. Aggregation Structure: Use COUNT to calculate the number of likes for each student ID. 3. Grouping Structure: Use GROUP BY on ""Likes.student_id"" to aggregate the results by each student ID. 4. Join Structure: No JOIN is required since all necessary data is within the ""Likes"" table.","[(1025, 1), (1247, 1), (1316, 1), (1501, 1), (1641, 1), (1689, 1), (1709, 1), (1782, 1), (1911, 1), (1934, 1)]","[(1025, 1), (1247, 1), (1316, 1), (1501, 1), (1641, 1), (1689, 1), (1709, 1), (1782, 1), (1911, 1), (1934, 1)]",,1.0,
